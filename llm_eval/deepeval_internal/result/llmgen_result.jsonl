{
    "project_name": "sed",
    "function_addr": 4232128,
    "strip_function_name": "sub_4093C0",
    "strip_decompiled_code": "__int64 __fastcall sub_4093C0(__int64 a1, __int64 *a2, signed __int64 a3, signed __int64 a4, signed __int64 a5)\n{\n  __int64 v6; // r9\n  __int64 v7; // rbx\n  bool v8; // of\n  signed __int64 v9; // rbx\n  __int64 v10; // rsi\n  signed __int64 v11; // r9\n  __int64 result; // rax\n  __int64 v13; // rsi\n  __int64 v14; // rax\n\n  v6 = *a2;\n  v7 = *a2 >> 1;\n  v8 = __OFADD__(*a2, v7);\n  v9 = *a2 + v7;\n  if ( v8 )\n  {\n    v9 = 0x7FFFFFFFFFFFFFFFLL;\n    if ( a4 != -1 )\n      v9 = a4;\n  }\n  else if ( v9 > a4 && a4 != -1 )\n  {\n    v9 = a4;\n  }\n  v10 = a5 * v9;\n  if ( !is_mul_ok(a5, v9) )\n  {\n    v13 = 0x7FFFFFFFFFFFFFFFLL;\nLABEL_15:\n    v14 = v13 / a5;\n    v10 = v13 - v13 % a5;\n    v9 = v14;\n    if ( a1 )\n      goto LABEL_8;\nLABEL_16:\n    *a2 = 0LL;\n    goto LABEL_8;\n  }\n  if ( v10 <= 127 )\n  {\n    v13 = 128LL;\n    goto LABEL_15;\n  }\n  if ( !a1 )\n    goto LABEL_16;\nLABEL_8:\n  if ( v9 - v6 < a3 )\n  {\n    if ( (v8 = __OFADD__(a3, v6), v11 = a3 + v6, v9 = v11, v8)\n      || v11 > a4 && a4 != -1\n      || (v10 = a5 * v11, !is_mul_ok(a5, v11)) )\n    {\n      sub_411C90(a1, v10);\n    }\n  }\n  result = sub_411AA0(a1, v10);\n  *a2 = v9;\n  return result;\n}\n",
    "function_name": "xpalloc",
    "decompiled_code": "void *__fastcall xpalloc(void *pa, __int64 *a2, ptrdiff_t a3, ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  __int64 v6; // r9\n  __int64 v7; // rbx\n  bool v8; // of\n  ptrdiff_t v9; // rbx\n  signed __int64 v10; // r9\n  void *result; // rax\n  __int64 v12; // rsi\n\n  v6 = *a2;\n  v7 = *a2 >> 1;\n  v8 = __OFADD__(*a2, v7);\n  v9 = *a2 + v7;\n  if ( v8 )\n  {\n    v9 = 0x7FFFFFFFFFFFFFFFLL;\n    if ( nitems_max != -1 )\n      v9 = nitems_max;\n  }\n  else if ( v9 > nitems_max && nitems_max != -1 )\n  {\n    v9 = nitems_max;\n  }\n  if ( !is_mul_ok(item_size, v9) )\n  {\n    v12 = 0x7FFFFFFFFFFFFFFFLL;\nLABEL_15:\n    v9 = v12 / item_size;\n    if ( pa )\n      goto LABEL_8;\nLABEL_16:\n    *a2 = 0LL;\n    goto LABEL_8;\n  }\n  if ( item_size * v9 <= 127 )\n  {\n    v12 = 128LL;\n    goto LABEL_15;\n  }\n  if ( !pa )\n    goto LABEL_16;\nLABEL_8:\n  if ( v9 - v6 < a3 )\n  {\n    if ( (v8 = __OFADD__(a3, v6), v10 = a3 + v6, v9 = v10, v8)\n      || v10 > nitems_max && nitems_max != -1\n      || !is_mul_ok(item_size, v10) )\n    {\n      xalloc_die();\n    }\n  }\n  result = xrealloc(pa, v9);\n  *a2 = v9;\n  return result;\n}\n",
    "source_code": "\nstatic void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
    "comment": "Allocates or reallocates memory for an array based on its current size, growth constraints, and item size, ensuring safe memory usage.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Dynamically reallocates memory for an array , adjusting size based on current usage , minimum increments , and maximum limits while ensuring safety against overflow .\n",
    "cpbcs_sum": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
    "misum_sum": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
    "decom_sum": "Resizes a dynamic buffer to at least the requested growth size, enforcing limits, preventing integer overflow, and reallocating memory as required.",
    "cfg_sum": "Adjusts a requested allocation size with overflow safeguards and limits, ensuring alignment before invoking memory management routines to allocate or resize storage.",
    "work_score": {
        "decom": {
            "summary": "Resizes a dynamic buffer to at least the requested growth size, enforcing limits, preventing integer overflow, and reallocating memory as required.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary accurately states core behaviors: it describes resizing a dynamic buffer, enforcing growth limits, preventing integer overflow, and reallocating memory, all of which match the source code\u2019s semantics. While the description is generic and omits specifics like the DEFAULT_MXFAST threshold and special handling for small allocations, the claims made are correct and relevant to the function\u2019s behavior.",
                "The summary mentions buffer resizing, enforcing limits, and preventing integer overflow, which are accurate high-level behaviors from the code. However, it does not explicitly state the core purpose: growing an array by about 50% or to DEFAULT_MXFAST for small allocations, with constraints nitems_incr_min, nitems_max, and safe integer operations. The description is too generic to reflect the specific growth logic and thresholds, resulting in partial accuracy but missing the distinctive domain semantics.",
                "The summary correctly identifies the core behavior of resizing a dynamic buffer, enforcing constraints, and preventing integer overflow, which matches the source code's growth calculations and wraparound checks. It also mentions reallocating memory, which is accurate. However, it is generic and omits specific details like small-request growth to DEFAULT_MXFAST, 50% growth heuristic, handling of NULL pointers, and the exact constraints applied. There are no inaccurate claims, but the gain is low due to the lack of specificity, resulting in limited engineering value."
            ]
        },
        "cfg": {
            "summary": "Adjusts a requested allocation size with overflow safeguards and limits, ensuring alignment before invoking memory management routines to allocate or resize storage.",
            "score": [
                0.9,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly captures core behaviors such as adjusting allocation size, applying overflow safeguards, respecting limits, and performing allocation/resizing via memory management routines. These points align with the source code\u2019s logic involving growth constraints, wrap-around checks, and alignment adjustments before calling xrealloc. No contradictory or irrelevant claims are present, indicating high accuracy.",
                "The summary correctly notes overflow safeguards, limits, and memory management invocation, which are [ACCURATE] reflective of the code's behavior. However, it does not specify the core primary purpose of dynamically growing an array to a larger size based on initial size, a default small-allocation threshold, and constraints such as minimum increment and maximum allowed items. This omission means the domain-specific growth logic that distinguishes this function is not covered, and while the summary captures general safety and allocation aspects, it lacks critical specifics around how size changes are determined.",
                "The summary accurately captures core behavior: adjusting allocation size, applying overflow safeguards, using limits, and allocation/resizing via memory routines. It omits specifics like initial growth strategy (DEFAULT_MXFAST and ~50% growth) and constraints involving nitems_incr_min and nitems_max, but nothing in the summary contradicts the code. The claims are correct but mostly broad and generic, providing limited detailed insight, with no fatal errors or overwhelming noise."
            ]
        },
        "comment": {
            "summary": "Allocates or reallocates memory for an array based on its current size, growth constraints, and item size, ensuring safe memory usage.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function allocates or reallocates memory for an array using its current size, growth constraints, and item size, reflecting the domain semantics of xpalloc. It also notes the focus on safe memory usage, which aligns with the code's safeguards against overflow and adherence to maximum limits. Although the summary is somewhat generic and lacks details about specific growth logic like DEFAULT_MXFAST or overflow handling functions, all claims are accurate and relevant to the source code.",
                "The summary correctly notes that the function allocates or reallocates memory for an array according to current size, constraints, and item size, which matches the core purpose. However, it lacks specifics about the growth strategy (DEFAULT_MXFAST small allocation threshold, 50% growth), safety checks against integer overflow, enforcement of minimum and maximum item counts, and error handling via xalloc_die. The coverage is minimal beyond the core idea.",
                "The summary correctly captures the core purpose of the function\u2014allocating or reallocating memory for an array based on current size, growth constraints, and item size\u2014and notes that it ensures safe memory usage, which aligns with checks against overflow and limits in the source code. However, it is very generic, omitting specifics such as the DEFAULT_MXFAST threshold, 50% growth logic, and the exact conditions that trigger allocation failure handling. There are no inaccurate statements, but the gain is low due to missing detail, and noise is minimal."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 210003,
    "strip_function_name": "mu_get_host_name",
    "strip_decompiled_code": "__int64 __fastcall mu_get_host_name(char **a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-34h]\n  char *ptr; // [rsp+20h] [rbp-30h]\n  size_t size; // [rsp+28h] [rbp-28h]\n  char *v5; // [rsp+30h] [rbp-20h]\n  char *v6; // [rsp+30h] [rbp-20h]\n  size_t v7; // [rsp+38h] [rbp-18h]\n  struct hostent *v8; // [rsp+40h] [rbp-10h]\n  size_t v9; // [rsp+48h] [rbp-8h]\n\n  ptr = 0LL;\n  size = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      if ( size )\n      {\n        v7 = 2 * size;\n        if ( 2 * size < size )\n          goto LABEL_20;\n        size *= 2LL;\n        v5 = (char *)realloc(ptr, v7);\n      }\n      else\n      {\n        size = 64LL;\n        v5 = (char *)malloc(0x40uLL);\n      }\n      if ( !v5 )\n        goto LABEL_20;\n      ptr = v5;\n      v5[size - 1] = 0;\n      if ( !gethostname(v5, size - 1) )\n        break;\n      if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )\n      {\n        v2 = *__errno_location();\n        free(v5);\n        return v2;\n      }\n    }\n  }\n  while ( v5[size - 1] );\n  if ( !strchr(v5, 46) )\n  {\n    v8 = gethostbyname(v5);\n    if ( v8 )\n    {\n      v9 = strlen(v8->h_name);\n      if ( size < v9 + 1 )\n      {\n        v6 = (char *)realloc(v5, v9 + 1);\n        if ( !v6 )\n        {\nLABEL_20:\n          free(ptr);\n          return 12LL;\n        }\n        ptr = v6;\n      }\n      strcpy(ptr, v8->h_name);\n    }\n  }\n  *a1 = ptr;\n  return 0LL;\n}\n",
    "function_name": "mu_get_host_name",
    "decompiled_code": "int __cdecl mu_get_host_name(char **host)\n{\n  int rc; // [rsp+1Ch] [rbp-34h]\n  char *hostname; // [rsp+20h] [rbp-30h]\n  size_t size; // [rsp+28h] [rbp-28h]\n  char *p; // [rsp+30h] [rbp-20h]\n  char *pa; // [rsp+30h] [rbp-20h]\n  __int64 ns; // [rsp+38h] [rbp-18h]\n  struct hostent *hp; // [rsp+40h] [rbp-10h]\n  size_t len; // [rsp+48h] [rbp-8h]\n\n  hostname = 0LL;\n  size = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      if ( size )\n      {\n        ns = 2 * size;\n        if ( 2 * size < size )\n          goto LABEL_20;\n        size *= 2LL;\n        p = (char *)realloc(hostname, ns);\n      }\n      else\n      {\n        size = 64LL;\n        p = (char *)malloc(0x40uLL);\n      }\n      if ( !p )\n        goto LABEL_20;\n      hostname = p;\n      p[size - 1] = 0;\n      if ( !gethostname(p, size - 1) )\n        break;\n      if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )\n      {\n        rc = *__errno_location();\n        free(p);\n        return rc;\n      }\n    }\n  }\n  while ( p[size - 1] );\n  if ( !strchr(p, 46) )\n  {\n    hp = gethostbyname(p);\n    if ( hp )\n    {\n      len = strlen(hp->h_name);\n      if ( size < len + 1 )\n      {\n        pa = (char *)realloc(p, len + 1);\n        if ( !pa )\n        {\nLABEL_20:\n          free(hostname);\n          return 12;\n        }\n        hostname = pa;\n      }\n      strcpy(hostname, hp->h_name);\n    }\n  }\n  *host = hostname;\n  return 0;\n}\n",
    "source_code": "\nint\nmu_get_host_name (char **host)\n{\n  char *hostname = NULL;\n  size_t size = 0;\n  char *p;\n\n  while (1)\n    {\n      if (size == 0)\n\t{\n\t  size = MAXHOSTNAMELEN;\n\t  p = malloc (size);\n\t}\n      else\n\t{\n\t  size_t ns = size * 2;\n\t  if (ns < size)\n\t    {\n\t      free (hostname);\n\t      return ENOMEM;\n\t    }\n\t  size = ns;\n\t  p = realloc (hostname, size);\n\t}\n      if (!p)\n\t{\n\t  free (hostname);\n\t  return ENOMEM;\n\t}\n      hostname = p;\n      hostname[size - 1] = 0;\n      if (gethostname (hostname, size - 1) == 0)\n\t{\n\t  if (!hostname[size - 1])\n\t    break;\n\t}\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n\t       && errno != ENOMEM)\n\t{\n\t  int rc = errno;\n\t  free (hostname);\n\t  return rc;\n\t}\n    }\n\n  /* Try to return fully qualified host name */\n  if (!strchr (hostname, '.'))\n    {\n      struct hostent *hp = gethostbyname (hostname);\n      if (hp)\n\t{\n\t  size_t len = strlen (hp->h_name);\n\t  if (size < len + 1)\n\t    {\n\t      p = realloc (hostname, len + 1);\n\t      if (!p)\n\t\t{\n\t\t  free (hostname);\n\t\t  return ENOMEM;\n\t\t}\n\t      hostname = p;\n\t    }\n\t  strcpy (hostname, hp->h_name);\n\t}\n    }\n  \n  *host = hostname;\n  return 0;\n}",
    "comment": "Retrieves the host name of the machine, expanding the buffer as needed, and attempts to return the fully qualified host name if not present.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the host name from a hostname structure , dynamically allocating memory as needed and handling potential errors during the process .\n",
    "cpbcs_sum": "Retrieves the current working directory, dynamically allocating memory for it, and ensures the buffer has been opened successfully.\n",
    "misum_sum": "Reads a string from a POSIX ACL file, allocates memory to store the buffer and returning an error code on failure.\n",
    "decom_sum": "Retrieves the system\u2019s hostname, expanding the buffer as needed, and resolves it to a fully qualified domain name if missing a dot.",
    "cfg_sum": "Retrieves the system's hostname, expanding buffer as needed, optionally resolving full domain name, and returns it to the caller with error handling.",
    "work_score": {
        "decom": {
            "summary": "Retrieves the system\u2019s hostname, expanding the buffer as needed, and resolves it to a fully qualified domain name if missing a dot.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function retrieves the system\u2019s hostname and expands the buffer as needed, which matches the loop logic with malloc/realloc handling buffer size. It also accurately notes that the hostname is resolved to a fully qualified domain name if it lacks a dot, as implemented with gethostbyname logic. All claims reflect the source code\u2019s behavior without contradiction, resulting in high precision.",
                "The summary accurately reflects the core purpose: obtaining the system's hostname and, if necessary, resolving it to a fully qualified domain name. It also correctly notes the dynamic buffer resizing to accommodate the hostname length. However, it omits secondary semantics such as specific error handling (e.g., ENOMEM, errno checks), handling of edge cases like integer overflow in size doubling, and details about using system calls (`gethostname`, `gethostbyname`). Coverage of these would increase completeness.",
                "The summary captures the primary purpose of the function accurately: obtaining the system hostname, dynamically resizing the buffer for longer names, and resolving to a fully qualified domain name if it lacks a dot. These are specific and verifiable details that align with the source code. There is no contradictory or irrelevant information, and the claims are concise yet precise, offering high-value insight with minimal noise."
            ]
        },
        "cfg": {
            "summary": "Retrieves the system's hostname, expanding buffer as needed, optionally resolving full domain name, and returns it to the caller with error handling.",
            "score": [
                1.0,
                0.8,
                0.8
            ],
            "reason": [
                "The summary contains accurate claims about the function: it retrieves the system's hostname using gethostname, dynamically expands the buffer as needed, optionally resolves the full domain name using gethostbyname, and includes error handling for allocation and system call failures. All these statements directly align with the source code behavior, with no contradictory or irrelevant content.",
                "The summary correctly identifies the core function of retrieving the system's hostname, handling dynamic buffer resizing, optionally resolving to a fully qualified domain name, and returning it with error handling. This matches the primary domain-specific operation in the source. It also covers key secondary behaviors like buffer expansion loop and optional domain resolution, though it omits finer error specifics such as specific errno cases and memory allocation failure handling details, which slightly limits completeness.",
                "The summary contains accurate and concise claims about the function\u2019s primary purpose: retrieving the system\u2019s hostname, dynamically expanding the buffer, optionally resolving to a fully qualified domain name if needed, returning it via the output parameter, and handling errors. All of these details match the source code\u2019s core logic. There is no contradictory or irrelevant noise, but the gain is moderate since the description is high-level and lacks specifics such as distinguishing between gethostname errors or exact memory handling details."
            ]
        },
        "comment": {
            "summary": "Retrieves the host name of the machine, expanding the buffer as needed, and attempts to return the fully qualified host name if not present.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary contains two atomic claims: that the function retrieves the host name of the machine, and that it expands the buffer as needed, attempting to return the fully qualified host name if missing. Both claims are directly supported by the source code: the loop dynamically allocates and reallocates the buffer for increasing sizes, uses gethostname to retrieve the host name, and later checks for a dot to determine if it should attempt to fetch the fully qualified name via gethostbyname. No significant inaccuracies or noise are present.",
                "The summary correctly captures the core purpose of retrieving the host name and the attempt to return a fully qualified host name, aligning with the source code\u2019s main operation. It also notes buffer expansion, which reflects the loop that reallocates memory. However, it omits other important behaviors such as handling specific error codes, returning ENOMEM on allocation overflow, and using gethostbyname when no dot is present. Secondary coverage is limited to basic memory management and the primary retrieval logic without detailing edge cases or error handling.",
                "The summary accurately states the core purpose of the function \u2014 retrieving the host name of the machine \u2014 and correctly notes buffer expansion as needed, as well as the attempt to return a fully qualified host name if the original lacks a dot. These claims align with the source code\u2019s logic. There are no inaccurate or noisy claims, but the details are generic and omit specifics about error handling, multiple allocation retries, and conditions for using gethostbyname, resulting in low informational gain despite being accurate."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579183232,
    "strip_function_name": "sub_FFFFFFFF81052880",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81052880(unsigned int *a1)\n{\n  unsigned __int64 v2; // rdi\n  __int64 v3; // r8\n  __int64 v4; // rcx\n  bool v5; // cf\n  unsigned __int64 v6; // rcx\n  unsigned int v7; // eax\n  unsigned __int64 v8; // rdx\n  unsigned int v9; // eax\n  char v10; // cl\n  _QWORD v12[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  memset(a1, 0, 0x70uLL);\n  sub_FFFFFFFF81083F50(v12);\n  sub_FFFFFFFF810843D0(v12);\n  *(_QWORD *)a1 = v12[0] + (v12[1] != 0LL);\n  sub_FFFFFFFF8106C890(a1 + 2, 0LL, 5LL);\n  *((_WORD *)a1 + 40) = dword_FFFFFFFF81DFB1E4;\n  sub_FFFFFFFF810EB320(a1);\n  sub_FFFFFFFF81121050(a1);\n  v2 = *((_QWORD *)a1 + 4);\n  v3 = *((_QWORD *)a1 + 8);\n  v4 = *((_QWORD *)a1 + 4);\n  v5 = __CFADD__(v3, v4);\n  v6 = v3 + v4;\n  if ( !v5 && v2 <= v6 )\n  {\n    v7 = a1[26];\n    if ( v7 <= 1 )\n    {\n      v10 = 0;\nLABEL_9:\n      *((_QWORD *)a1 + 5) <<= v10;\n      *((_QWORD *)a1 + 6) <<= v10;\n      a1[26] = 1;\n      *((_QWORD *)a1 + 4) = v2 << v10;\n      *((_QWORD *)a1 + 7) <<= v10;\n      *((_QWORD *)a1 + 9) <<= v10;\n      *((_QWORD *)a1 + 11) <<= v10;\n      *((_QWORD *)a1 + 12) <<= v10;\n      *((_QWORD *)a1 + 8) = v3 << v10;\n      return 0LL;\n    }\n    v8 = 2 * v6;\n    v9 = v7 >> 1;\n    if ( v6 <= 2 * v6 )\n    {\n      v10 = 1;\n      while ( v9 != 1 )\n      {\n        ++v10;\n        v9 >>= 1;\n        if ( 2 * v8 < v8 )\n          return 0LL;\n        v8 *= 2LL;\n      }\n      goto LABEL_9;\n    }\n  }\n  return 0LL;\n}\n",
    "function_name": "do_sysinfo",
    "decompiled_code": "__int64 __fastcall do_sysinfo(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  unsigned __int64 v7; // rdi\n  __int64 v8; // r8\n  __int64 v9; // rcx\n  bool v10; // cf\n  unsigned __int64 v11; // rcx\n  unsigned int v12; // eax\n  unsigned __int64 v13; // rdx\n  unsigned int v14; // eax\n  char v15; // cl\n  _QWORD v17[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  memset(a1, 0, 0x70uLL);\n  ktime_get_ts(v17, a2, a3, 0LL, a5, a6);\n  monotonic_to_bootbased(v17);\n  *(_QWORD *)a1 = v17[0] + (v17[1] != 0LL);\n  get_avenrun((_QWORD *)a1 + 1, 0LL, 5);\n  *((_WORD *)a1 + 40) = nr_threads;\n  si_meminfo((__int64)a1);\n  si_swapinfo((__int64)a1);\n  v7 = *((_QWORD *)a1 + 4);\n  v8 = *((_QWORD *)a1 + 8);\n  v9 = *((_QWORD *)a1 + 4);\n  v10 = __CFADD__(v8, v9);\n  v11 = v8 + v9;\n  if ( !v10 && v7 <= v11 )\n  {\n    v12 = a1[26];\n    if ( v12 <= 1 )\n    {\n      v15 = 0;\nLABEL_9:\n      *((_QWORD *)a1 + 5) <<= v15;\n      *((_QWORD *)a1 + 6) <<= v15;\n      a1[26] = 1;\n      *((_QWORD *)a1 + 4) = v7 << v15;\n      *((_QWORD *)a1 + 7) <<= v15;\n      *((_QWORD *)a1 + 9) <<= v15;\n      *((_QWORD *)a1 + 11) <<= v15;\n      *((_QWORD *)a1 + 12) <<= v15;\n      *((_QWORD *)a1 + 8) = v8 << v15;\n      return 0LL;\n    }\n    v13 = 2 * v11;\n    v14 = v12 >> 1;\n    if ( v11 <= 2 * v11 )\n    {\n      v15 = 1;\n      while ( v14 != 1 )\n      {\n        ++v15;\n        v14 >>= 1;\n        if ( 2 * v13 < v13 )\n          return 0LL;\n        v13 *= 2LL;\n      }\n      goto LABEL_9;\n    }\n  }\n  return 0LL;\n}\n",
    "source_code": "static int do_sysinfo(struct sysinfo *info)\n{\n\tunsigned long mem_total, sav_total;\n\tunsigned int mem_unit, bitcount;\n\tstruct timespec tp;\n\n\tmemset(info, 0, sizeof(struct sysinfo));\n\n\tktime_get_ts(&tp);\n\tmonotonic_to_bootbased(&tp);\n\tinfo->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);\n\n\tget_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);\n\n\tinfo->procs = nr_threads;\n\n\tsi_meminfo(info);\n\tsi_swapinfo(info);\n\n\t/*\n\t * If the sum of all the available memory (i.e. ram + swap)\n\t * is less than can be stored in a 32 bit unsigned long then\n\t * we can be binary compatible with 2.2.x kernels.  If not,\n\t * well, in that case 2.2.x was broken anyways...\n\t *\n\t *  -Erik Andersen <andersee@debian.org>\n\t */\n\n\tmem_total = info->totalram + info->totalswap;\n\tif (mem_total < info->totalram || mem_total < info->totalswap)\n\t\tgoto out;\n\tbitcount = 0;\n\tmem_unit = info->mem_unit;\n\twhile (mem_unit > 1) {\n\t\tbitcount++;\n\t\tmem_unit >>= 1;\n\t\tsav_total = mem_total;\n\t\tmem_total <<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If mem_total did not overflow, multiply all memory values by\n\t * info->mem_unit and set it to 1.  This leaves things compatible\n\t * with 2.2.x, and also retains compatibility with earlier 2.4.x\n\t * kernels...\n\t */\n\n\tinfo->mem_unit = 1;\n\tinfo->totalram <<= bitcount;\n\tinfo->freeram <<= bitcount;\n\tinfo->sharedram <<= bitcount;\n\tinfo->bufferram <<= bitcount;\n\tinfo->totalswap <<= bitcount;\n\tinfo->freeswap <<= bitcount;\n\tinfo->totalhigh <<= bitcount;\n\tinfo->freehigh <<= bitcount;\n\nout:\n\treturn 0;\n}",
    "comment": "Populates the `sysinfo` structure with system uptime, load averages, process count, and adjusted memory and swap information, ensuring compatibility with older kernels.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes a high-resolution timer by configuring it with minimum and maximum values , ensuring it does n't exceed predefined limits .\n",
    "cpbcs_sum": "Initiates a high-resolution timer by setting the start time and clock times, updating the timer's expiration and CPU affinity accordingly.\n",
    "misum_sum": "Sets the current time and adjusts the new PID based on the provided clock and header while validating the new CPU clock and size.\n",
    "decom_sum": "Initializes a 112-byte structure, computes size-related values, and left-shifts multiple fields to align memory blocks based on capacity requirements.",
    "cfg_sum": "Initializes a 0x70-byte data structure, processes and scales its numeric fields based on value thresholds, then updates status flags and returns success.",
    "work_score": {
        "decom": {
            "summary": "Initializes a 112-byte structure, computes size-related values, and left-shifts multiple fields to align memory blocks based on capacity requirements.",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function initializes a structure and adjusts memory-related fields using left shifts, which matches the code's behavior of memset on struct sysinfo and bit-shifting multiple memory fields. However, it inaccurately specifies a fixed size of 112 bytes that is not evident in the source and omits key details like uptime calculation, load averages, process count, and swap/memory info gathering. These omissions and the erroneous size claim reduce alignment, resulting in only partial accuracy.",
                "The summary fails to cover the core primary purpose of retrieving and populating system information such as uptime, load averages, process count, memory, and swap stats, along with handling overflow and kernel compatibility adjustments. It inaccurately focuses on a fixed 112-byte size and generic size alignment, omitting the detailed data gathering from various system calls and conditional memory scaling present in the code. No accurate claim addresses the main domain-specific behavior.",
                "The summary contains partially accurate but overly generic claims. It correctly states that the function initializes a structure and shifts multiple memory-related fields, but it inaccurately specifies the structure size as 112 bytes, which is not directly derivable from the code and could be wrong. The mention of 'align memory blocks based on capacity requirements' is vague and does not capture the actual overflow prevention and compatibility logic. These shortcomings introduce noise, with no clear fatal errors about the primary purpose, but the gain is low due to lack of specific detail on uptime, process count, and memory handling logic."
            ]
        },
        "cfg": {
            "summary": "Initializes a 0x70-byte data structure, processes and scales its numeric fields based on value thresholds, then updates status flags and returns success.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary contains vague and partially inaccurate claims. It correctly notes initialization and scaling of numeric fields, which matches the memset call and bit-shifting operations in the code. However, it misstates the structure size as 0x70 bytes without evidence from the source, omits key behaviors like uptime calculation and memory info retrieval, and incorrectly claims updating of status flags, which the function does not perform. These inaccuracies reduce precision, with fewer than half of the claims being accurate.",
                "The summary fails to capture the core purpose of retrieving and populating system information such as uptime, load averages, process count, and memory/swap statistics while handling compatibility-related scaling. It instead describes generic structure initialization, numeric processing, and status flag updates without domain-specific terms, and includes inaccurate details such as '0x70-byte' size and 'status flags' that are not present in the code. No accurate claim covers the primary function's domain semantics, and secondary behaviors like overflow checks and memory unit adjustments are omitted.",
                "The summary contains mostly inaccurate claims: it mentions initializing a 0x70-byte data structure, but the code clearly uses sizeof(struct sysinfo) without indicating its fixed size. It describes processing numeric fields based on thresholds, which loosely matches the scaling logic using mem_unit and bitcount, but omits key functions like ktime_get_ts, get_avenrun, and si_meminfo/si_swapinfo that collect uptime, load, and memory stats. The claim about updating status flags is unsupported, as no flags are updated in the code. These inaccuracies dominate and omit the primary behavior of computing system information, resulting in very low net benefit with NOISE as the worst failure mode."
            ]
        },
        "comment": {
            "summary": "Populates the `sysinfo` structure with system uptime, load averages, process count, and adjusted memory and swap information, ensuring compatibility with older kernels.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function populates the sysinfo structure with uptime, load averages, process count, and memory/swap stats, and notes the compatibility logic with older kernels. All mentioned elements are directly supported by the source code, with no inaccuracies or irrelevant details, resulting in a high proportion of accurate claims.",
                "The summary accurately covers the core purpose of populating the sysinfo structure with uptime, load averages, process count, and adjusted memory/swap values, matching the function's domain-specific behavior. It correctly notes the compatibility adjustments for older kernels. However, it omits secondary details such as the specific adjustment logic using mem_unit and bitcount, overflow checks, invocation of si_meminfo and si_swapinfo, uptime rounding, and error path handling. These omissions limit coverage of critical secondary semantics.",
                "The summary accurately reflects core behavior: populating sysinfo with uptime, load averages, process count, and memory/swap data. It also correctly notes the adjustment for compatibility with older kernels, which aligns with the code\u2019s bit-shifting logic and comments on 2.2.x compatibility. All claims are accurate, with no contradictory or irrelevant statements. The specificity covers primary purpose and key I/O, providing useful insight without noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582460464,
    "strip_function_name": "sub_FFFFFFFF81372A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81372A30(__int64 a1, _DWORD *a2)\n{\n  __int64 v2; // r12\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // rax\n  int i; // ecx\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // rdx\n  int v11; // esi\n  int v12; // eax\n\n  v2 = *(_QWORD *)(a1 + 400);\n  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 888) + 416LL) & 0x20) == 0 )\n    return 4294967274LL;\n  if ( !v2 )\n    return 4294967274LL;\n  sub_FFFFFFFF81379AC0(1, (unsigned int)\"drm\", (unsigned int)\"drm_markbufs\", (unsigned int)\"%d, %d, %d\\n\", a2[1], a2[2]);\n  v4 = (int)a2[1];\n  v5 = v4 >> 1;\n  if ( !(v4 >> 1) )\n    return 4294967274LL;\n  for ( i = 0; ; ++i )\n  {\n    v5 >>= 1;\n    v7 = i + 1;\n    if ( !v5 )\n      break;\n  }\n  if ( (v4 & (v4 - 1)) != 0 )\n  {\n    v7 = i + 2;\n    v8 = i - 3;\n  }\n  else\n  {\n    v8 = i - 4;\n  }\n  if ( v8 > 0x11 )\n    return 4294967274LL;\n  v9 = a2[2];\n  if ( v9 < 0 )\n    return 4294967274LL;\n  v10 = (_DWORD *)(v2 + 88LL * v7);\n  v11 = v10[1];\n  if ( v9 > v11 )\n    return 4294967274LL;\n  v12 = a2[3];\n  if ( v11 < v12 || v12 < 0 )\n    return 4294967274LL;\n  v10[18] = v9;\n  v10[19] = a2[3];\n  return 0LL;\n}\n",
    "function_name": "drm_markbufs",
    "decompiled_code": "__int64 __fastcall drm_markbufs(__int64 a1, _DWORD *a2)\n{\n  __int64 v2; // r12\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // rax\n  int i; // ecx\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // rdx\n  int v11; // esi\n  int v12; // eax\n\n  v2 = *(_QWORD *)(a1 + 400);\n  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 888) + 416LL) & 0x20) == 0 )\n    return 4294967274LL;\n  if ( !v2 )\n    return 4294967274LL;\n  drm_ut_debug_printk(\n    1,\n    (int)\"drm\",\n    (__int64)\"drm_markbufs\",\n    (__int64)\"%d, %d, %d\\n\",\n    (unsigned int)a2[1],\n    (unsigned int)a2[2],\n    a2[3]);\n  v4 = (int)a2[1];\n  v5 = v4 >> 1;\n  if ( !(v4 >> 1) )\n    return 4294967274LL;\n  for ( i = 0; ; ++i )\n  {\n    v5 >>= 1;\n    v7 = i + 1;\n    if ( !v5 )\n      break;\n  }\n  if ( (v4 & (v4 - 1)) != 0 )\n  {\n    v7 = i + 2;\n    v8 = i - 3;\n  }\n  else\n  {\n    v8 = i - 4;\n  }\n  if ( v8 > 0x11 )\n    return 4294967274LL;\n  v9 = a2[2];\n  if ( v9 < 0 )\n    return 4294967274LL;\n  v10 = (_DWORD *)(v2 + 88LL * v7);\n  v11 = v10[1];\n  if ( v9 > v11 )\n    return 4294967274LL;\n  v12 = a2[3];\n  if ( v11 < v12 || v12 < 0 )\n    return 4294967274LL;\n  v10[18] = v9;\n  v10[19] = a2[3];\n  return 0LL;\n}\n",
    "source_code": "int drm_markbufs(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tstruct drm_buf_desc *request = data;\n\tint order;\n\tstruct drm_buf_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\treturn -EINVAL;\n\n\tif (!dma)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"%d, %d, %d\\n\",\n\t\t  request->size, request->low_mark, request->high_mark);\n\torder = drm_order(request->size);\n\tif (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)\n\t\treturn -EINVAL;\n\tentry = &dma->bufs[order];\n\n\tif (request->low_mark < 0 || request->low_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\tif (request->high_mark < 0 || request->high_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\n\tentry->freelist.low_mark = request->low_mark;\n\tentry->freelist.high_mark = request->high_mark;\n\n\treturn 0;\n}",
    "comment": "Configures buffer management parameters, including size and free list thresholds, for a Direct Rendering Manager (DRM) device's DMA buffers.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Marks the buffer usage for a DRM device by writing minimum and maximum values to its control register .\n",
    "cpbcs_sum": "Retrieves the vblank state of a specified CRTC in a formatted buffer, ensuring the device fits within valid bounds.\n",
    "misum_sum": "Converts a DRM connector to a formatted string representation, returning an error if the device does not already enabled.\n",
    "decom_sum": "Marks DRM buffer entries with given indices after validating parameters and hardware state, updating two fields in the selected buffer structure.",
    "cfg_sum": "Validates DRM buffer parameters against device flags and constraints, then updates buffer metadata or returns an error code on invalid input.",
    "work_score": {
        "decom": {
            "summary": "Marks DRM buffer entries with given indices after validating parameters and hardware state, updating two fields in the selected buffer structure.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function marks DRM buffer entries with given indices, but the source code shows it updates low_mark and high_mark values in the freelist after parameter validation, without any notion of 'indices'. While it correctly mentions validation of parameters and hardware state and updating two fields, the core operation is misrepresented, making a significant claim inaccurate.",
                "The summary incorrectly claims that the function marks DRM buffer entries with given indices, which is inaccurate because the code selects a buffer entry based on buffer size order, not indices, and updates its freelist's low and high mark values. It also omits key details such as validation against DRIVER_HAVE_DMA, order range checks, and bounds checks for low/high marks. The core purpose \u2014 validating a buffer size and updating freelist thresholds in a DMA buffer entry \u2014 is not correctly covered, and secondary behaviors are largely missing.",
                "The summary contains an inaccurate core claim: it states the function marks buffer entries with given indices, but the source code actually updates 'low_mark' and 'high_mark' thresholds in the freelist based on the request, not indices of buffers themselves. This misrepresents the primary purpose and main side effect, which is a FATAL error. There is a minor accurate element about validating parameters and hardware state, but the central WHAT is wrong, making the description misleading and unusable."
            ]
        },
        "cfg": {
            "summary": "Validates DRM buffer parameters against device flags and constraints, then updates buffer metadata or returns an error code on invalid input.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function validates DRM buffer parameters against device constraints and device flags, and updates metadata or returns an error code on invalid input, which matches the source code's sequence of checks for device features, DMA existence, size/order ranges, and mark bounds before updating freelist marks. All claims are accurate and grounded in the code\u2019s actual behavior, with no incorrect or irrelevant statements.",
                "The summary accurately captures the core action of validating DRM buffer parameters and returning errors on invalid input, which aligns with the function's main purpose. However, it omits specifics critical to complete coverage, such as checks for DRIVER_HAVE_DMA, the calculation and validation of buffer order against DRM_MIN_ORDER and DRM_MAX_ORDER, and the detailed constraints on low_mark and high_mark relative to buf_count. It also does not explicitly state that the function updates freelist low/high marks rather than generic 'buffer metadata'.",
                "The summary accurately captures the primary purpose of the function: validating DRM buffer parameters against device features and constraints, then updating metadata or returning an error code on invalid input. There are no contradictory or irrelevant claims (no FATAL or NOISE). The claim is correct but generic, lacking specifics such as the exact fields validated, detailed constraints, or the specific metadata updated, so informational gain is low."
            ]
        },
        "comment": {
            "summary": "Configures buffer management parameters, including size and free list thresholds, for a Direct Rendering Manager (DRM) device's DMA buffers.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function configures buffer management parameters for a DRM device's DMA buffers, including size and free list thresholds. This matches the code behavior: the function validates and sets low/high water marks for the freelist based on the requested size. No contradictory or irrelevant claims are present, and all claims are accurate but somewhat generic, covering the central functionality without extra detail.",
                "The summary accurately describes the core purpose: configuring DMA buffer parameters for a DRM device, including size and free list thresholds. This matches the code\u2019s main function of validating input and setting low/high watermark values for a specific buffer order. However, it omits notable secondary details such as the specific validation checks for device features, absence of DMA, bounds checking for size and marks, and the error returns for invalid values. These omissions reduce completeness in coverage of behavior-critical semantics.",
                "The summary correctly captures the core purpose of the function: setting buffer management parameters (size and free list thresholds) for a DRM device's DMA buffers, which aligns with the code\u2019s actions using request->size, low_mark, and high_mark. No claims are inaccurate, and there is no noise\u2014however, the description is fairly generic with low detail, omitting specific validation logic and bounds-checking present in the source, so the informational gain is modest."
            ]
        }
    }
}
{
    "project_name": "lua",
    "function_addr": 39904,
    "strip_function_name": "sub_9BE0",
    "strip_decompiled_code": "const char *__fastcall sub_9BE0(__int64 a1, __int64 *a2, int a3, _QWORD *a4)\n{\n  __int64 v6; // rdx\n  __int64 v7; // r12\n  __int64 v8; // rdi\n  int v9; // ebp\n  const char *result; // rax\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // [rsp+8h] [rbp-30h]\n\n  v6 = *a2;\n  if ( (*((_BYTE *)a2 + 66) & 2) != 0 )\n  {\n    v7 = a2[4];\n    v8 = *(_QWORD *)(*(_QWORD *)v6 + 24LL);\n    if ( a3 < 0 )\n    {\n      v9 = -a3;\n      if ( v9 < (int)(((v7 - v6) >> 4) - *(unsigned __int8 *)(v8 + 10)) )\n      {\n        *a4 = v6 + 16 * (v9 + (unsigned __int64)*(unsigned __int8 *)(v8 + 10));\n        return \"(*vararg)\";\n      }\n      return 0LL;\n    }\n    v13 = a4;\n    result = (const char *)sub_CF30(v8, (unsigned int)a3, (unsigned int)((a2[5] - *(_QWORD *)(v8 + 56)) >> 2) - 1);\n    v12 = a3;\n    a4 = v13;\n    if ( result )\n    {\nLABEL_11:\n      *a4 = v7 + 16 * v12 - 16;\n      return result;\n    }\n  }\n  else\n  {\n    v7 = v6 + 16;\n  }\n  if ( *(__int64 **)(a1 + 32) == a2 )\n    v11 = *(_QWORD *)(a1 + 16);\n  else\n    v11 = *(_QWORD *)a2[3];\n  v12 = a3;\n  if ( (v11 - v7) >> 4 >= a3 && a3 > 0 )\n  {\n    result = \"(*temporary)\";\n    goto LABEL_11;\n  }\n  return 0LL;\n}\n",
    "function_name": "findlocal",
    "decompiled_code": "const char *__fastcall findlocal(__int64 a1, __int64 *a2, int a3, _QWORD *a4)\n{\n  __int64 v6; // rdx\n  __int64 v7; // r12\n  __int64 v8; // rdi\n  int v9; // ebp\n  const char *result; // rax\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // [rsp+8h] [rbp-30h]\n\n  v6 = *a2;\n  if ( (*((_BYTE *)a2 + 66) & 2) != 0 )\n  {\n    v7 = a2[4];\n    v8 = *(_QWORD *)(*(_QWORD *)v6 + 24LL);\n    if ( a3 < 0 )\n    {\n      v9 = -a3;\n      if ( v9 < (int)(((v7 - v6) >> 4) - *(unsigned __int8 *)(v8 + 10)) )\n      {\n        *a4 = v6 + 16 * (v9 + (unsigned __int64)*(unsigned __int8 *)(v8 + 10));\n        return \"(*vararg)\";\n      }\n      return 0LL;\n    }\n    v13 = a4;\n    result = (const char *)luaF_getlocalname(v8, a3, (unsigned int)((a2[5] - *(_QWORD *)(v8 + 56)) >> 2) - 1);\n    v12 = a3;\n    a4 = v13;\n    if ( result )\n    {\nLABEL_11:\n      *a4 = v7 + 16 * v12 - 16;\n      return result;\n    }\n  }\n  else\n  {\n    v7 = v6 + 16;\n  }\n  if ( *(__int64 **)(a1 + 32) == a2 )\n    v11 = *(_QWORD *)(a1 + 16);\n  else\n    v11 = *(_QWORD *)a2[3];\n  v12 = a3;\n  if ( (v11 - v7) >> 4 >= a3 && a3 > 0 )\n  {\n    result = \"(*temporary)\";\n    goto LABEL_11;\n  }\n  return 0LL;\n}\n",
    "source_code": "\nstatic const char* findlocal(lua_State* L, CallInfo* ci, int n, StkId* pos) {\n  const char* name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0) /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  } else\n    base = ci->func + 1;\n  if (name == NULL) { /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\"; /* generic name for any valid slot */\n    else\n      return NULL; /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}",
    "comment": "Retrieves the local variable name from a Lua function's call frame or returns a generic name for temporary slots if no name exists.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Retrieves a specified column value from a table , handling both integer and non-integer inputs , ensuring valid column indices .\n",
    "cpbcs_sum": "Retrieves the value of an upvalue from a Lua stack based on its type, handling both direct and negative values accordingly.\n",
    "misum_sum": "Converts a binary tree to an additional token based on the integer value and current stack pointers, handling memory allocation errors appropriately.\n",
    "decom_sum": "Retrieves a function argument or temporary value location and returns either \"(*vararg)\" or \"(*temporary)\" if within valid bounds.",
    "cfg_sum": "Validates argument index and retrieves a pointer to a function argument, returning \u201c(*vararg)\u201d or \u201c(*temporary)\u201d for special cases, otherwise NULL.",
    "work_score": {
        "decom": {
            "summary": "Retrieves a function argument or temporary value location and returns either \"(*vararg)\" or \"(*temporary)\" if within valid bounds.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function returns \"(*vararg)\" for varargs, but the source code actually uses a separate function `findvararg` and does not return that string. It also omits mention of returning NULL when no valid slot is found and inaccurately describes all retrieval as function arguments or temporary values. While it correctly notes that \"(*temporary)\" can be returned within valid bounds, less than half of the claims are accurate.",
                "The summary fails to accurately describe the core purpose, which is to find the name and stack position of a local variable or vararg in a Lua function frame. It incorrectly mentions returning \"(*vararg)\"\u2014the source code calls findvararg for varargs and never returns that literal\u2014and omits critical specifics such as use of luaF_getlocalname, conditional handling for Lua vs non-Lua frames, computing the position, and returning NULL when out of bounds. The core domain operation is missing and multiple details are inaccurate, leaving only a partial and incorrect picture.",
                "The summary inaccurately states that the function returns \"(*vararg)\" for varargs, but the source code shows varargs are handled by calling `findvararg` and returning its result. The only hardcoded name returned is \"(*temporary)\" for valid temporary slots. This is a FATAL error concerning a core output of the function. While the summary partially captures that it retrieves a location and may return a placeholder name, the incorrect placeholder name for varargs undermines trust in primary behavior."
            ]
        },
        "cfg": {
            "summary": "Validates argument index and retrieves a pointer to a function argument, returning \u201c(*vararg)\u201d or \u201c(*temporary)\u201d for special cases, otherwise NULL.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function behavior: it claims the function retrieves a pointer to a function argument, which is inaccurate as it returns a variable name string and sets a stack position. It also mentions returning \"(*vararg)\" as a special case, but the actual code returns the result from `findvararg` for varargs and uses \"(*temporary)\" only when no standard name is available. The claim about returning NULL is accurate. Overall, less than half of the claims match the source code semantics.",
                "The summary misstates the core purpose; the function retrieves the name of a local variable or vararg from a Lua stack frame, not a pointer to a function argument. The special string for varargs in the code is provided by findvararg, not \u201c(*vararg)\u201d as claimed, making that claim inaccurate. It also omits key behavioral details such as how base and limit are determined, interactions with luaF_getlocalname, handling of negative indices for varargs, and the conditions leading to returning NULL. The core domain effect of finding a local name in a stack frame is not covered.",
                "The summary contains a key inaccuracy about returning \u201c(*vararg)\u201d; the actual code calls `findvararg` and returns its result, not a fixed string. It also misstates that the function specifically retrieves a function argument, whereas it can access local variables or varargs from the call frame. While it correctly notes returning \u201c(*temporary)\u201d when no standard name exists and NULL for invalid cases, these correct points are outweighed by the misleading claim about vararg handling, which affects understanding of core I/O behavior."
            ]
        },
        "comment": {
            "summary": "Retrieves the local variable name from a Lua function's call frame or returns a generic name for temporary slots if no name exists.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary captures the main behavior: retrieving a local variable name from a Lua function call frame and returning a generic name for temporary slots when no name exists. This aligns with the source code logic, which checks for Lua functions, retrieves names via luaF_getlocalname or findvararg, and falls back to '(*temporary)' if the slot is valid but unnamed. While the summary omits some specifics like vararg handling and positional assignment via 'pos', the majority of its claims are accurate and grounded in the code.",
                "The summary accurately describes the core functionality of retrieving a local variable name from a Lua call frame and returning a generic name if none exists, which aligns with the source code's primary purpose. However, it omits important secondary details such as handling negative indices for vararg access, behavior when not dealing with Lua frames, the specific conditions for returning NULL, and the assignment to the output position pointer. This incomplete coverage limits the score despite correct core representation.",
                "The summary accurately captures the primary purpose of the function: it attempts to retrieve the local variable name from a Lua call frame and uses a generic name for temporary slots when no standard name is found. This reflects the code's logic for both Lua and non-Lua frames, handling varargs, and fallback naming. There is no contradictory or irrelevant information, and the claim is specific enough to be useful, though it omits some details like vararg handling and positional output assignment."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 441281,
    "strip_function_name": "mu_ident_stat",
    "strip_decompiled_code": "unsigned __int64 __fastcall mu_ident_stat(int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  int v9; // edx\n  int v10; // ecx\n  int v11; // r8d\n  int v12; // r9d\n  int v13; // eax\n  int v14; // ecx\n  int v15; // r8d\n  int v16; // r9d\n  int v17; // r9d\n  char v19; // [rsp+0h] [rbp-50h]\n  char v20; // [rsp+0h] [rbp-50h]\n  char v21; // [rsp+0h] [rbp-50h]\n  unsigned int iterator; // [rsp+1Ch] [rbp-34h]\n  __int64 v23; // [rsp+20h] [rbp-30h] BYREF\n  __int64 v24; // [rsp+28h] [rbp-28h] BYREF\n  __int64 v25; // [rsp+30h] [rbp-20h] BYREF\n  _QWORD *v26; // [rsp+38h] [rbp-18h] BYREF\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v28; // [rsp+48h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  mu_stream_printf(a1, (int)\"BEGIN IDENT STAT\\n\", a3, a4, a5, a6, v19);\n  mu_assoc_count(qword_2DFC80, &v23);\n  mu_stream_printf(a1, (int)\"N=%zu\\n\", v23, v6, v7, v8, v20);\n  if ( v23 )\n  {\n    iterator = mu_assoc_get_iterator(qword_2DFC80, &v24);\n    if ( iterator )\n    {\n      v13 = mu_strerror(iterator);\n      mu_stream_printf(a1, (int)\"mu_assoc_get_iterator: %s\\n\", v13, v14, v15, v16, v21);\n    }\n    else\n    {\n      v27 = 0LL;\n      mu_iterator_first(v24);\n      while ( !(unsigned int)mu_iterator_is_done(v24) )\n      {\n        mu_iterator_current_kv(v24, &v25, &v26);\n        mu_stream_printf(a1, (int)\"%04zu: %s: %zu\\n\", v27, v25, *v26, v17, v21);\n        mu_iterator_next(v24);\n        ++v27;\n      }\n    }\n    mu_iterator_destroy(&v24);\n  }\n  mu_stream_printf(a1, (int)\"END IDENT STAT\\n\", v9, v10, v11, v12, v21);\n  return __readfsqword(0x28u) ^ v28;\n}\n",
    "function_name": "mu_ident_stat",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nvoid __cdecl mu_ident_stat(mu_stream_t str)\n{\n  const char *v1; // rax\n  unsigned int rc; // [rsp+1Ch] [rbp-34h]\n  size_t count; // [rsp+20h] [rbp-30h] BYREF\n  mu_iterator_t itr; // [rsp+28h] [rbp-28h] BYREF\n  const char *key; // [rsp+30h] [rbp-20h] BYREF\n  mu_ident_ref *ref; // [rsp+38h] [rbp-18h] BYREF\n  size_t i; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  ((void (__fastcall *)(mu_stream_t, const char *))mu_stream_printf)(str, \"BEGIN IDENT STAT\\n\");\n  ((void (__fastcall *)(mu_assoc_t, size_t *))mu_assoc_count)(nametab, &count);\n  ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"N=%zu\\n\", count);\n  if ( count )\n  {\n    rc = ((__int64 (__fastcall *)(mu_assoc_t, mu_iterator_t *))mu_assoc_get_iterator)(nametab, &itr);\n    if ( rc )\n    {\n      v1 = (const char *)((__int64 (__fastcall *)(_QWORD))mu_strerror)(rc);\n      ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"mu_assoc_get_iterator: %s\\n\", v1);\n    }\n    else\n    {\n      i = 0LL;\n      ((void (__fastcall *)(mu_iterator_t))mu_iterator_first)(itr);\n      while ( !(unsigned int)((__int64 (__fastcall *)(mu_iterator_t))mu_iterator_is_done)(itr) )\n      {\n        ((void (__fastcall *)(mu_iterator_t, const char **, mu_ident_ref **))mu_iterator_current_kv)(itr, &key, &ref);\n        ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n        ((void (__fastcall *)(mu_iterator_t))mu_iterator_next)(itr);\n        ++i;\n      }\n    }\n    ((void (__fastcall *)(mu_iterator_t *))mu_iterator_destroy)(&itr);\n  }\n  ((void (__fastcall *)(mu_stream_t, const char *))mu_stream_printf)(str, \"END IDENT STAT\\n\");\n}\n",
    "source_code": "  \nvoid\nmu_ident_stat (mu_stream_t str)\n{\n  size_t count, i;\n  mu_iterator_t itr;\n  \n  mu_stream_printf (str, \"BEGIN IDENT STAT\\n\");\n\n  mu_assoc_count (nametab, &count);\n  mu_stream_printf (str, \"N=%zu\\n\", count);\n\n  if (count > 0)\n    {\n      int rc = mu_assoc_get_iterator (nametab, &itr);\n      if (rc)\n\tmu_stream_printf (str, \"mu_assoc_get_iterator: %s\\n\",\n\t\t\t  mu_strerror (rc));\n      else\n\t{\n\t  i = 0;\n\t  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);\n\t       mu_iterator_next (itr), i++)\n\t    {\n\t      const char *key;\n\t      struct mu_ident_ref *ref;\n\t      \n\t      mu_iterator_current_kv (itr,\n\t\t\t\t      (const void **)&key, (void **)&ref);  \n\t      mu_stream_printf (str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n\t    }\n\t}\n      mu_iterator_destroy (&itr);\n    }\n  mu_stream_printf (str, \"END IDENT STAT\\n\");\n}",
    "comment": "Outputs the count and details of identifiers from a name table to a specified stream, including key-value pairs and their associated counts.",
    "hext5_sum": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
    "bint5_sum": "Identifies and prints file status information , including permissions , ownership , size , and modification time , from a specified directory stream .\n",
    "cpbcs_sum": "Saves a transport stream to a specified mailbox with the provided name and optional identifier, handling stream creation and errors.\n",
    "misum_sum": "Prints the details of a sieve machine with optional tag by iterating through a filter stream, iterating when the operation fails.\n",
    "decom_sum": "Outputs identification statistics by counting entries in an association, iterating over key-value pairs, and printing formatted results to the provided stream.",
    "cfg_sum": "Outputs identification statistics by counting and iterating over an association list, reporting entries or iterator errors, and ensuring stack integrity before returning.",
    "work_score": {
        "decom": {
            "summary": "Outputs identification statistics by counting entries in an association, iterating over key-value pairs, and printing formatted results to the provided stream.",
            "score": [
                1.0,
                0.4,
                0.8
            ],
            "reason": [
                "The summary correctly describes the function's behavior: it counts entries in an association, iterates over key-value pairs, and outputs formatted results to the provided stream. These claims directly match the source code, with no inaccuracies or irrelevant information, yielding a high proportion of accurate statements.",
                "The summary accurately describes the core purpose \u2014 producing identification statistics by counting entries, iterating over key-value pairs, and printing them \u2014 which matches the source code\u2019s domain-semantic behavior. However, it omits secondary behavior-critical details such as printing BEGIN/END markers, handling the case of zero entries, reporting iterator creation errors, and displaying error messages. Coverage of secondary semantics is minimal.",
                "The summary accurately describes the core behavior: it counts entries in an association, iterates over key-value pairs, and prints formatted results to the provided stream. These claims align with the source code's primary purpose and key I/O without introducing contradictions. The description is essentially a single GOLD-level claim with low noise, but it is relatively generic, omitting details such as printing error messages when the iterator fails or the specific formatting of indexes and counts. The worst failure mode is absent; no FATAL is present, and accuracy is high, though the informational gain is moderate due to lack of finer specifics."
            ]
        },
        "cfg": {
            "summary": "Outputs identification statistics by counting and iterating over an association list, reporting entries or iterator errors, and ensuring stack integrity before returning.",
            "score": [
                0.6,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function outputs identification statistics by counting and iterating over an association list, and that it reports either the entries or an iterator error, which matches the source code. However, it inaccurately claims that the function ensures stack integrity before returning, a behavior not present in the source code. This introduces an incorrect semantic detail, reducing the proportion of accurate claims to between 50% and 80%.",
                "The summary correctly states that the function outputs identification statistics by counting and iterating over an association list and reports entries or iterator errors, which matches the code's counting of nametab entries, handling of iterator acquisition errors, and printing of each entry's key and count. However, it introduces an inaccurate claim about ensuring stack integrity before returning, which is not present in the code. The core purpose of printing identification statistics is covered, but coverage of secondary details such as BEGIN/END markers and exact formatting is minimal and includes a false detail, reducing completeness.",
                "The summary correctly describes counting and iterating over an association list, reporting entries, and handling iterator errors, which matches the source code's behavior. However, it inaccurately adds a claim about ensuring stack integrity before returning, which is not present in the implementation. This extra claim is unrelated to the code semantics and constitutes noise. While the accurate parts are specific to the function\u2019s output, the noise reduces overall clarity and trustworthiness."
            ]
        },
        "comment": {
            "summary": "Outputs the count and details of identifiers from a name table to a specified stream, including key-value pairs and their associated counts.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures the core function behavior: retrieving the count of identifiers from the name table and outputting each key along with its associated count to a provided stream. This aligns closely with the source code, which uses an iterator to print formatted key-value pairs and counts. No contradictory or irrelevant claims are present, and the description is specific to the code\u2019s actual output process.",
                "The summary accurately captures the core purpose of reporting the count and details of identifiers from the name table to a stream, which matches the code's iteration over key-value pairs with associated counts. However, it omits secondary behaviors such as printing BEGIN/END markers, handling the case of zero entries, and reporting iterator initialization errors, so coverage of secondary semantics is limited.",
                "The summary correctly states that the function outputs the count and details of identifiers from a name table to a given stream, including keys and their associated counts, which matches the source code's usage of mu_assoc_count, mu_iterator_current_kv, and mu_stream_printf. No contradictory or irrelevant claims are present, but the description is generic and omits specifics such as error handling, iteration format, and stream messages, resulting in only low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581103152,
    "strip_function_name": "sub_FFFFFFFF81227430",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81227430(\n        __int64 a1,\n        _DWORD *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  _DWORD *v13; // rax\n  __int64 *v14; // rdx\n  __int64 v15; // rcx\n  int v16; // r8d\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r13d\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  int v23; // r8d\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  _DWORD *v28; // [rsp+0h] [rbp-68h] BYREF\n  _DWORD *v29; // [rsp+8h] [rbp-60h]\n  _QWORD v30[3]; // [rsp+10h] [rbp-58h] BYREF\n  int v31; // [rsp+28h] [rbp-40h]\n  _QWORD v32[7]; // [rsp+30h] [rbp-38h] BYREF\n\n  v30[0] = a1 - 448;\n  v32[3] = 0LL;\n  v32[0] = &unk_FFFFFFFF81C484A8;\n  v30[1] = a2 - 112;\n  v30[2] = *(_QWORD *)(a3 + 8);\n  v31 = *(_DWORD *)(a3 + 4);\n  v32[1] = v30;\n  v32[2] = &v28;\n  v29 = (_DWORD *)sub_FFFFFFFF81217C20(a4, a5, a6, a7, a8, a9, a10, a11);\n  v13 = (_DWORD *)sub_FFFFFFFF81217C20(a4, a5, a6, a7, v11, v12, a10, a11);\n  v28 = v13;\n  if ( v29 && v13 )\n  {\n    v20 = sub_FFFFFFFF81226DE0(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL) + 40LL), (__int64)v32);\n    sub_FFFFFFFF812192A0((__int64)a2, v28);\n    a2 = v29;\n    sub_FFFFFFFF812192A0(a1, v29);\n    v13 = v28;\n  }\n  else\n  {\n    v20 = -12;\n  }\n  sub_FFFFFFFF8112DCD0((unsigned __int64)v13, a4, a5, a6, a7, v18, v19, a10, a11, (__int64)a2, v14, v15, v16, v17);\n  sub_FFFFFFFF8112DCD0((unsigned __int64)v29, a4, a5, a6, a7, v25, v26, a10, a11, (__int64)a2, v21, v22, v23, v24);\n  return v20;\n}\n",
    "function_name": "nfs3_proc_link",
    "decompiled_code": "__int64 __fastcall nfs3_proc_link(\n        __int64 a1,\n        _DWORD *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 *v13; // rax\n  __int64 *v14; // rdx\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int v17; // r13d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 *v22; // rdx\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 *v26; // [rsp+0h] [rbp-68h] BYREF\n  __int64 *v27; // [rsp+8h] [rbp-60h]\n  _QWORD v28[3]; // [rsp+10h] [rbp-58h] BYREF\n  int v29; // [rsp+28h] [rbp-40h]\n  _QWORD v30[7]; // [rsp+30h] [rbp-38h] BYREF\n\n  v28[0] = a1 - 448;\n  v30[3] = 0LL;\n  v30[0] = &unk_FFFFFFFF81C484A8;\n  v28[1] = a2 - 112;\n  v28[2] = *(_QWORD *)(a3 + 8);\n  v29 = *(_DWORD *)(a3 + 4);\n  v30[1] = v28;\n  v30[2] = &v26;\n  v27 = nfs_alloc_fattr(a4, a5, a6, a7, a8, a9, a10, a11);\n  v13 = nfs_alloc_fattr(a4, a5, a6, a7, v11, v12, a10, a11);\n  v26 = v13;\n  if ( v27 && v13 )\n  {\n    v17 = nfs3_rpc_wrapper_constprop_9(\n            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL) + 40LL),\n            (__int64)v30,\n            a4,\n            a5,\n            a6,\n            a7,\n            v15,\n            v16,\n            a10,\n            a11);\n    nfs_post_op_update_inode((__int64)a2, v26, a4, a5, a6, a7, v18, v19, a10, a11);\n    a2 = v27;\n    nfs_post_op_update_inode(a1, v27, a4, a5, a6, a7, v20, v21, a10, a11);\n    v13 = v26;\n  }\n  else\n  {\n    v17 = -12;\n  }\n  kfree(v13, a4, a5, a6, a7, v15, v16, a10, a11, (__int64)a2, v14);\n  kfree(v27, a4, a5, a6, a7, v23, v24, a10, a11, (__int64)a2, v22);\n  return v17;\n}\n",
    "source_code": "\nstatic int\nnfs3_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs3_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct nfs3_linkres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tres.fattr = nfs_alloc_fattr();\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.fattr == NULL || res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_post_op_update_inode(inode, res.fattr);\nout:\n\tnfs_free_fattr(res.dir_attr);\n\tnfs_free_fattr(res.fattr);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}",
    "comment": "Links a source inode to a target directory inode with a specified name using an NFS procedure and updates their attributes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Renames a file in an NFS directory by sending a rename RPC request and updating directory inodes with the response .\n",
    "cpbcs_sum": "Renames a directory entry on an NFS server and updates the directory's inode attributes based on the new response.\n",
    "misum_sum": "Renames a file in an NFS directory by sending a rename RPC request and updating the directory's inode attributes.\n",
    "decom_sum": "Generates two computation results from input doubles, processes them through callback operations, updates both targets, and returns a status code.",
    "cfg_sum": "Processes two computed data sets, validates their creation, updates associated structures, performs cleanup operations, and returns a status code indicating success or failure.",
    "work_score": {
        "decom": {
            "summary": "Generates two computation results from input doubles, processes them through callback operations, updates both targets, and returns a status code.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes operations on input doubles, callbacks, and target updates, which do not match the domain or behavior of the source code. The code performs an NFS link operation between inodes, constructs RPC arguments, allocates attributes, makes an RPC call, updates inode attributes, frees resources, and returns status. None of the claims in the summary accurately reflect the actual procedure, making all claims inaccurate.",
                "The summary's claims about generating computation results from doubles and processing via callbacks are completely unrelated to the source code, which performs an NFSv3 link operation by creating symbolic link arguments, making an RPC call, updating inode attributes, and returning a status. The core purpose is not mentioned and no accurate secondary details are provided.",
                "The summary's claims about generating computation results from input doubles and processing through callbacks are entirely inaccurate, as the source code is an NFSv3 link operation that prepares link arguments, performs an RPC call, updates inode attributes, and handles memory allocation. This constitutes a severe FATAL error targeting the primary purpose and I/O of the function, making the description unusable."
            ]
        },
        "cfg": {
            "summary": "Processes two computed data sets, validates their creation, updates associated structures, performs cleanup operations, and returns a status code indicating success or failure.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary vaguely describes generic steps like processing data sets, validating, updating structures, and cleanup, but it omits key domain-specific details from the source code, such as handling NFS link arguments, making an RPC call, and managing file attributes. While 'updates associated structures' and 'performs cleanup operations' loosely align with post-op inode updates and freeing resources, the 'computed data sets' phrasing is inaccurate for NFS file attributes, reducing precision. Most claims are generic or slightly mismatched to the actual implementation, resulting in less than half being accurate.",
                "The summary fails to mention the core domain-specific purpose of the function, which is performing an NFSv3 link operation to link an inode into a directory with a given name via an RPC call. While it generically describes handling data sets, validation, updates, cleanup, and status return, these are vague and boilerplate, lacking accurate coverage of the specific NFS link semantics. Secondary behaviors such as attribute allocation, RPC messaging, and post-operation inode updates are omitted or overly generalized.",
                "The summary is overly generic and does not accurately convey the primary purpose of the function, which is to perform an NFSv3 link operation between two inodes via an RPC call. While it mentions validation, updates, cleanup, and returning a status, these are generic and vague, lacking specific domain semantics such as NFS link arguments, RPC message handling, and inode attribute updates. This results in high noise and very low informational gain, with no specific GOLD claims."
            ]
        },
        "comment": {
            "summary": "Links a source inode to a target directory inode with a specified name using an NFS procedure and updates their attributes.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately describes the function's purpose: linking a source inode to a target directory inode with a specified name, using an NFS procedure, and updating their attributes. These claims directly match the code, which constructs link arguments, calls the NFS link procedure, and updates both inodes' attributes. No inaccuracies or irrelevant details are present, resulting in a high purity of accurate claims.",
                "The summary accurately states the core purpose of linking a source inode to a target directory inode with a specified name via an NFS procedure and mentions attribute updates, which matches the core domain operation in the code. However, it omits secondary behavior-critical details such as allocation and freeing of fattr structures, handling of memory allocation failure, synchronous RPC call specifics, and debug logging, resulting in incomplete coverage of the code's semantics beyond the core action.",
                "The summary accurately captures the core purpose of the function: linking a source inode to a target directory inode by name via an NFS procedure and updating their attributes. These points match the source code behavior, with no contradictions or irrelevant noise. The claim is concise and domain-specific, though it is somewhat high-level without detailing the specific NFS3 link arguments, RPC call, or post-operation updates, making the gain moderate rather than maximal."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578882688,
    "strip_function_name": "sub_FFFFFFFF81009280",
    "strip_decompiled_code": "unsigned __int64 sub_FFFFFFFF81009280()\n{\n  unsigned __int64 v0; // rax\n  int v1; // r8d\n  int v2; // r9d\n  unsigned __int64 v3; // rcx\n  unsigned __int64 v4; // r12\n  unsigned __int64 v5; // rdi\n  unsigned __int64 v6; // rcx\n  unsigned int v7; // ecx\n  unsigned __int64 result; // rax\n  unsigned __int64 v9; // rbx\n  unsigned __int64 v10[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( dword_FFFFFFFF81CB4F64 )\n    goto LABEL_14;\n  if ( qword_FFFFFFFF81C12640 != -1 )\n  {\n    v0 = sub_FFFFFFFF81009120((__int64 *)v10, dword_FFFFFFFF81DCE588);\n    v3 = v10[0];\n    if ( qword_FFFFFFFF81DCE580 == v10[0] || qword_FFFFFFFF81C12640 == -1 || v0 == -1LL )\n      goto LABEL_14;\n    v4 = 1000000 * (v0 - qword_FFFFFFFF81C12640);\n    if ( dword_FFFFFFFF81DCE588 )\n    {\n      if ( qword_FFFFFFFF81DCE580 > v10[0] )\n        v3 = v10[0] + 0x100000000LL;\n      v9 = v3 - qword_FFFFFFFF81DCE580;\n      LODWORD(v6) = v9 * (unsigned int)sub_FFFFFFFF8102BA50(4LL) / 0xF4240;\n    }\n    else\n    {\n      v5 = -1LL;\n      if ( !(v10[0] | qword_FFFFFFFF81DCE580) )\n      {\nLABEL_12:\n        v7 = dword_FFFFFFFF81CB4F68;\n        if ( (__int64)abs64((unsigned int)dword_FFFFFFFF81CB4F68 - v5) > dword_FFFFFFFF81CB4F68 / 0x64u )\n          return sub_FFFFFFFF81087030(&off_FFFFFFFF81C12700, 1000LL, v7);\n        dword_FFFFFFFF81CB4F68 = v5;\n        sub_FFFFFFFF8178A70F(\n          (unsigned int)&unk_FFFFFFFF81989760,\n          (unsigned int)v5 / 0x3E8,\n          (unsigned int)v5 % 0x3E8,\n          1000,\n          v1,\n          v2);\nLABEL_14:\n        v7 = dword_FFFFFFFF81CB4F68;\n        return sub_FFFFFFFF81087030(&off_FFFFFFFF81C12700, 1000LL, v7);\n      }\n      if ( qword_FFFFFFFF81DCE580 > v10[0] )\n        v3 = v10[0] + 0x1000000;\n      v6 = 1000000000 * (v3 - qword_FFFFFFFF81DCE580) / 0x369E99;\n    }\n    v5 = v4 / (unsigned int)v6;\n    goto LABEL_12;\n  }\n  dword_FFFFFFFF81DCE588 = sub_FFFFFFFF8102AD70();\n  sub_FFFFFFFF81058CD0(64LL, qword_FFFFFFFF81CB6E38, &dword_FFFFFFFF81C12660, 1000LL);\n  result = sub_FFFFFFFF81009120(&qword_FFFFFFFF81DCE580, dword_FFFFFFFF81DCE588);\n  qword_FFFFFFFF81C12640 = result;\n  return result;\n}\n",
    "function_name": "tsc_refine_calibration_work",
    "decompiled_code": "unsigned __int64 __fastcall tsc_refine_calibration_work(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned __int64 refs; // rax\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  unsigned __int64 v11; // rcx\n  unsigned __int64 v12; // r12\n  unsigned __int64 v13; // rdi\n  unsigned __int64 v14; // rcx\n  unsigned int v15; // ecx\n  unsigned __int64 result; // rax\n  unsigned __int64 v17; // rbx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  unsigned __int64 v22[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( tsc_unstable )\n    goto LABEL_14;\n  if ( tsc_start_23383 != -1 )\n  {\n    refs = tsc_read_refs((__int64 *)v22, hpet_23385);\n    v11 = v22[0];\n    if ( ref_start_23384 == v22[0] || tsc_start_23383 == -1 || refs == -1LL )\n      goto LABEL_14;\n    v12 = 1000000 * (refs - tsc_start_23383);\n    if ( hpet_23385 )\n    {\n      if ( ref_start_23384 > v22[0] )\n        v11 = v22[0] + 0x100000000LL;\n      v17 = v11 - ref_start_23384;\n      LODWORD(v14) = v17 * (unsigned int)hpet_readl(4u) / 0xF4240;\n    }\n    else\n    {\n      v13 = -1LL;\n      if ( !(v22[0] | ref_start_23384) )\n      {\nLABEL_12:\n        v15 = tsc_khz;\n        if ( (__int64)abs64((unsigned int)tsc_khz - v13) > tsc_khz / 0x64u )\n          return _clocksource_register_scale((__int64)&clocksource_tsc, 0x3E8u, v15);\n        tsc_khz = v13;\n        printk(\n          (__int64)&unk_FFFFFFFF81989760,\n          a1,\n          a2,\n          a3,\n          a4,\n          v9,\n          v10,\n          a7,\n          a8,\n          (unsigned int)v13 / 0x3E8,\n          (unsigned int)v13 % 0x3E8);\nLABEL_14:\n        v15 = tsc_khz;\n        return _clocksource_register_scale((__int64)&clocksource_tsc, 0x3E8u, v15);\n      }\n      if ( ref_start_23384 > v22[0] )\n        v11 = v22[0] + 0x1000000;\n      v14 = 1000000000 * (v11 - ref_start_23384) / 0x369E99;\n    }\n    v13 = v12 / (unsigned int)v14;\n    goto LABEL_12;\n  }\n  hpet_23385 = is_hpet_enabled();\n  queue_delayed_work_on(0x40u, system_wq, tsc_irqwork, 1000LL, a1, a2, a3, a4, v20, v21, a7, a8, v18, v19);\n  result = tsc_read_refs(&ref_start_23384, hpet_23385);\n  tsc_start_23383 = result;\n  return result;\n}\n",
    "source_code": "static void tsc_refine_calibration_work(struct work_struct *work)\n{\n\tstatic u64 tsc_start = -1, ref_start;\n\tstatic int hpet;\n\tu64 tsc_stop, ref_stop, delta;\n\tunsigned long freq;\n\n\t/* Don't bother refining TSC on unstable systems */\n\tif (check_tsc_unstable())\n\t\tgoto out;\n\n\t/*\n\t * Since the work is started early in boot, we may be\n\t * delayed the first time we expire. So set the workqueue\n\t * again once we know timers are working.\n\t */\n\tif (tsc_start == -1) {\n\t\t/*\n\t\t * Only set hpet once, to avoid mixing hardware\n\t\t * if the hpet becomes enabled later.\n\t\t */\n\t\thpet = is_hpet_enabled();\n\t\tschedule_delayed_work(&tsc_irqwork, HZ);\n\t\ttsc_start = tsc_read_refs(&ref_start, hpet);\n\t\treturn;\n\t}\n\n\ttsc_stop = tsc_read_refs(&ref_stop, hpet);\n\n\t/* hpet or pmtimer available ? */\n\tif (ref_start == ref_stop)\n\t\tgoto out;\n\n\t/* Check, whether the sampling was disturbed by an SMI */\n\tif (tsc_start == ULLONG_MAX || tsc_stop == ULLONG_MAX)\n\t\tgoto out;\n\n\tdelta = tsc_stop - tsc_start;\n\tdelta *= 1000000LL;\n\tif (hpet)\n\t\tfreq = calc_hpet_ref(delta, ref_start, ref_stop);\n\telse\n\t\tfreq = calc_pmtimer_ref(delta, ref_start, ref_stop);\n\n\t/* Make sure we're within 1% */\n\tif (abs(tsc_khz - freq) > tsc_khz/100)\n\t\tgoto out;\n\n\ttsc_khz = freq;\n\tpr_info(\"Refined TSC clocksource calibration: %lu.%03lu MHz\\n\",\n\t\t(unsigned long)tsc_khz / 1000,\n\t\t(unsigned long)tsc_khz % 1000);\n\nout:\n\tclocksource_register_khz(&clocksource_tsc, tsc_khz);\n}",
    "comment": "Refines TSC clocksource calibration by measuring timer frequencies and adjusting the TSC frequency if within 1% accuracy after initial readings.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Enables HPET by configuring the PCI device and setting the appropriate registers if certain conditions are met .\n",
    "cpbcs_sum": "Calculates the current scheduler clock time based on clock frequency, and user context, ensuring it corresponds to a 32-bit factor during the operation.\n",
    "misum_sum": "Calculates and returns the maximum idle time when dividing is below the current clock time.\n",
    "decom_sum": "Calculates system clock frequency using timestamp counters and updates global timing values, returning results via a 1000\u202fHz rate callback.",
    "cfg_sum": "Calculates timing intervals from hardware counters, verifies deviations, updates stored values, and triggers callbacks or returns results based on validation.",
    "work_score": {
        "decom": {
            "summary": "Calculates system clock frequency using timestamp counters and updates global timing values, returning results via a 1000\u202fHz rate callback.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function returns results via a 1000\u202fHz rate callback, which is inaccurate since the code does not implement or call any callback; it schedules delayed work once per HZ (which may be 1000 on some systems) but that's not a return mechanism. While it correctly states that the function calculates system clock frequency using timestamp counters and updates global timing values, the callback detail is incorrect. With one of two claims inaccurate, accuracy proportion is below 50%.",
                "The summary incorrectly describes a 1000\u202fHz rate callback, which is not present in the source code, and fails to cover the core purpose of refining the TSC calibration using HPET or pmtimer references early in boot, adjusting tsc_khz if within tolerance. It omits branching for unstable TSC checks, SMI disturbance handling, and workqueue rescheduling, providing only a vague and partly inaccurate description of clock frequency calculation.",
                "The summary inaccurately describes the function\u2019s behavior. It claims the function returns results via a 1000\u202fHz rate callback, which is not present in the source; instead, it schedules a delayed work once and updates a global TSC frequency. While it does compute the clock frequency using timestamp counters and update a global timing variable (tsc_khz), the incorrect callback detail is a FATAL error affecting core I/O semantics. The rest of the description is sparse and generic, offering low informational gain."
            ]
        },
        "cfg": {
            "summary": "Calculates timing intervals from hardware counters, verifies deviations, updates stored values, and triggers callbacks or returns results based on validation.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly generic descriptions such as calculating timing intervals and verifying deviations, which loosely match the function's use of hardware counters and validation steps. However, it omits key specifics like handling unstable TSC, using HPET or PMTimer, scheduling delayed work, checking for SMI disturbances, and registering the clock source. It also introduces inaccurate concepts like triggering callbacks or returning results, which are not present in the source code. Overall, less than half of the claims are precise and aligned with the code.",
                "The summary gives a generic description of calculating from hardware counters and validation but does not accurately state the core action of refining TSC clocksource calibration early in boot using HPET or PM timer references. It omits specifics like checking TSC stability, handling initial and subsequent runs, frequency comparison tolerance, and registering the clocksource. The core purpose of refining and possibly updating tsc_khz is not clearly covered, and secondary behaviors such as branch conditions, delays, and hardware source decisions are missing.",
                "The summary contains mostly generic statements and omits key details of the function's purpose and I/O semantics. It vaguely mentions calculating timing intervals and verifying deviations, which loosely aligns with the code's TSC calibration refinement using HPET or PMTimer references. However, it inaccurately states that the function triggers callbacks or returns results\u2014there are no such callbacks, and the function is void, only updates `tsc_khz` and registers the clocksource. The inaccuracies are not on the primary purpose, but the noise from broad, low-info claims outweighs specific gains, resulting in low net benefit."
            ]
        },
        "comment": {
            "summary": "Refines TSC clocksource calibration by measuring timer frequencies and adjusting the TSC frequency if within 1% accuracy after initial readings.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function refines the TSC clocksource calibration, measures timer frequencies, and adjusts the TSC frequency only if the result is within 1% of the original value. These details match the source code\u2019s logic, which reads reference timers, calculates a frequency using either HPET or PM timer, and only updates TSC if the deviation is within 1%. There are no misleading or incorrect claims, though the summary omits some conditions like skipping refinement for unstable TSC and scheduling delayed work on first run.",
                "The summary correctly states the core purpose of refining the TSC clocksource calibration and mentions adjusting the TSC frequency within 1% accuracy, which aligns with the main function behavior. However, it omits critical secondary details such as the checks for unstable TSC, handling delays at boot, use of HPET or PM timer references, avoidance of SMI disturbances, and the registration of the clocksource at the end. These omissions limit coverage of important behavior-specific semantics beyond the primary purpose.",
                "The summary correctly states that the function refines TSC clocksource calibration by measuring timer frequencies and adjusting the TSC frequency when within 1% accuracy, which aligns with the core behavior in the code. However, it omits several specific operational details such as checking TSC stability, handling hpet detection, using delayed work scheduling, and selecting between HPET or pmtimer references. There are no inaccurate claims, but the coverage is generic and lacks the richer specifics the code provides, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581809888,
    "strip_function_name": "sub_FFFFFFFF812D3CE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812D3CE0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // r13\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 (__fastcall *v14)(__int64); // rax\n  unsigned int v15; // ebx\n  __int64 result; // rax\n\n  v9 = *(_QWORD *)(a1 + 144);\n  v10 = a1 - 152;\n  if ( !v9 )\n  {\n    if ( !(unsigned __int8)sub_FFFFFFFF812D3760(\n                             *(_WORD *)(a1 - 92),\n                             *(_WORD *)(a1 - 90),\n                             *(_QWORD **)(a1 - 64),\n                             a2,\n                             a3,\n                             a4,\n                             a5,\n                             a6,\n                             a7,\n                             a8,\n                             a9) )\n    {\nLABEL_10:\n      if ( !*(_QWORD *)(a1 - 128) )\n        sub_FFFFFFFF812D1F30(v10);\n      goto LABEL_6;\n    }\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  }\n  v11 = *(_QWORD *)(v9 + 104);\n  if ( (unsigned __int8)sub_FFFFFFFF812D3760(\n                          *(_WORD *)(a1 - 92),\n                          *(_WORD *)(a1 - 90),\n                          *(_QWORD **)(a1 - 64),\n                          a2,\n                          a3,\n                          a4,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9) )\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( !v11 )\n    goto LABEL_10;\n  *(_BYTE *)(a1 + 1067) &= ~1u;\n  v14 = *(__int64 (__fastcall **)(__int64))(v11 + 48);\n  if ( !v14 || (v15 = v14(a1), sub_FFFFFFFF813F7A40(\"pci_pm_poweroff\", *(_QWORD *)(v11 + 48), v15), (result = v15) == 0) )\n  {\nLABEL_6:\n    sub_FFFFFFFF812DB930(5LL, v10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "pci_pm_poweroff",
    "decompiled_code": "__int64 __fastcall pci_pm_poweroff(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // r13\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 (__fastcall *v14)(__int64); // rax\n  unsigned int v15; // ebx\n  __int64 v16; // rcx\n  int v17; // r8d\n  int v18; // r9d\n  __int64 result; // rax\n\n  v9 = *(_QWORD *)(a1 + 144);\n  v10 = a1 - 152;\n  if ( !v9 )\n  {\n    if ( !(unsigned __int8)pci_has_legacy_pm_support_isra_13(\n                             *(_WORD *)(a1 - 92),\n                             *(_WORD *)(a1 - 90),\n                             *(_QWORD **)(a1 - 64),\n                             a2,\n                             a3,\n                             a4,\n                             a5,\n                             a6,\n                             a7,\n                             a8,\n                             a9) )\n    {\nLABEL_10:\n      if ( !*(_QWORD *)(a1 - 128) )\n        pci_disable_enabled_device(v10);\n      goto LABEL_6;\n    }\n    return pci_legacy_suspend(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  }\n  v11 = *(_QWORD *)(v9 + 104);\n  if ( (unsigned __int8)pci_has_legacy_pm_support_isra_13(\n                          *(_WORD *)(a1 - 92),\n                          *(_WORD *)(a1 - 90),\n                          *(_QWORD **)(a1 - 64),\n                          a2,\n                          a3,\n                          a4,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9) )\n    return pci_legacy_suspend(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( !v11 )\n    goto LABEL_10;\n  *(_BYTE *)(a1 + 1067) &= ~1u;\n  v14 = *(__int64 (__fastcall **)(__int64))(v11 + 48);\n  if ( !v14\n    || (v15 = v14(a1),\n        _suspend_report_result((int)\"pci_pm_poweroff\", *(_QWORD *)(v11 + 48), v15, v16, v17, v18),\n        (result = v15) == 0) )\n  {\nLABEL_6:\n    pci_fixup_device(5LL, v10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n Fixup:\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}",
    "comment": "Handles the power-off process for PCI devices, utilizing legacy support or device-specific power management operations, and fixes up device state afterward.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Suspends a PCI device by invoking the driver 's suspend function or performing a default suspension , while handling legacy power management support .\n",
    "cpbcs_sum": "Freezes the PCI device without IRQ, saves its state, and handles specific BIOS quirks for USB EHCI host controllers.\n",
    "misum_sum": "Freezes the PCI device by invoking the driver's freeze routine or defaults to legacy suspension if legacy support is available.\n",
    "decom_sum": "Handles PCI device poweroff by invoking a power management callback or fallback routine after validating parameters and device state.",
    "cfg_sum": "Handles PCI device power-off by validating parameters, invoking callbacks, updating flags, and performing fallback shutdown if initial checks or operations fail.",
    "work_score": {
        "decom": {
            "summary": "Handles PCI device poweroff by invoking a power management callback or fallback routine after validating parameters and device state.",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary claims the function validates parameters and device state before invoking callbacks, but the source code does not show explicit parameter or state validation beyond checking for legacy PM support and presence of callbacks. It correctly notes use of a PM callback or fallback suspend routine, but omits key specifics such as legacy support check, default suspend, fixups, and error handling. Due to the presence of at least one inaccurate claim and missing detail, only about half of the claims are accurate.",
                "The summary gives a generic description of PCI device poweroff using a callback or fallback routine, but it lacks the core specificity from the source code, which is transitioning a PCI device into hibernate state via legacy suspend or driver-provided poweroff, followed by fixup operations. It omits key details such as the legacy PM support check, default suspend, state_saved reset, error handling, and the pci_fixup_device call, and does not explicitly mention hibernate or fixup semantics. Thus the core domain operation is not adequately covered and secondary behaviors are missing.",
                "The summary correctly identifies that the function handles PCI device poweroff through either a power management callback or a fallback routine, which matches the code. However, it inaccurately claims validation of parameters and device state, which is not present in the source. This is a NOISE issue rather than a FATAL error, and the rest of the content is generic with limited detail, leading to low net benefit."
            ]
        },
        "cfg": {
            "summary": "Handles PCI device power-off by validating parameters, invoking callbacks, updating flags, and performing fallback shutdown if initial checks or operations fail.",
            "score": [
                0.3,
                0.3,
                0.5
            ],
            "reason": [
                "The summary includes partially accurate elements, such as invoking callbacks and updating flags, but it introduces inaccuracies by stating parameter validation, which is not present in the source code, and describing a fallback shutdown triggered solely by failures, while the code follows a structured sequence of legacy support check, default suspend, optional poweroff, and device fixup. These mismatches reduce alignment with the source semantics, yielding under 50% accurate claims.",
                "The summary claims the function validates parameters, which is not evident in the source code, making that part inaccurate. It correctly notes invoking callbacks (pm->poweroff) and updating a flag (state_saved = false) but misrepresents core flow as a generic 'fallback shutdown'. The core purpose\u2014handling PCI device power-off with legacy support check, default suspend, driver-specific poweroff, and fixups\u2014is not clearly or specifically covered. Secondary details like legacy path, fixup, error handling, and suspend reporting are omitted, leading to poor coverage.",
                "The summary correctly states that the function handles PCI device power-off and invokes callbacks, updates flags, and has a fallback path, which aligns with the code. However, it inaccurately claims parameter validation, which is not explicitly present, and misstates the fallback condition \u2014 the code falls back if legacy support is absent or pm is NULL, not generically 'if initial checks or operations fail.' This introduces noise but no severe contradictions about the primary purpose. The accurate claims are mostly generic, offering limited insight."
            ]
        },
        "comment": {
            "summary": "Handles the power-off process for PCI devices, utilizing legacy support or device-specific power management operations, and fixes up device state afterward.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately describes the main behavior of the function: it manages the power-off process for PCI devices, either using legacy support routines or device-specific power management callbacks, and performs a fix-up afterward. These claims directly align with the source code\u2019s logic, with no contradictory or irrelevant statements, indicating a high accuracy rate.",
                "The summary accurately identifies that the function powers off PCI devices using either legacy support or device-specific PM methods and then fixes the device state, which matches the core purpose and main operational flow in the source code. However, it omits key secondary details such as handling the absence of a PM struct via default suspend, the explicit state_saved reset, error handling for poweroff, and the use of constants like PMSG_HIBERNATE. These omissions limit completeness.",
                "The summary correctly identifies the primary purpose of the function\u2014powering off PCI devices\u2014and notes the use of legacy support and device-specific power management operations, which align with the code's conditional logic using `pci_has_legacy_pm_support` and `pm->poweroff`. It also accurately mentions fixing up the device state afterward via `pci_fixup_device`. There are no inaccurate or contradictory claims, and although the description is somewhat generic, it covers the essential semantic behavior without noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582451776,
    "strip_function_name": "sub_FFFFFFFF81370840",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF81370840(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 v14; // rbx\n  unsigned __int64 v16; // rdi\n  int v17; // r12d\n  int i; // r12d\n  __int64 v19; // rax\n\n  v14 = a2;\n  if ( *(_DWORD *)(a2 + 16) )\n  {\n    if ( *(int *)(a2 + 16) <= 0 )\n    {\n      v16 = *(_QWORD *)(a2 + 24);\n    }\n    else\n    {\n      v16 = *(_QWORD *)(a2 + 24);\n      v17 = 0;\n      do\n      {\n        a2 = *(_QWORD *)(v16 + 8LL * v17);\n        if ( a2 )\n        {\n          sub_FFFFFFFF8137CAD0(a1);\n          v16 = *(_QWORD *)(v14 + 24);\n        }\n        ++v17;\n      }\n      while ( *(_DWORD *)(v14 + 16) > v17 );\n    }\n    sub_FFFFFFFF8112DCD0(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);\n    *(_DWORD *)(v14 + 16) = 0;\n  }\n  if ( *(_DWORD *)(v14 + 4) )\n  {\n    for ( i = 0; i < *(_DWORD *)(v14 + 4); ++i )\n    {\n      v19 = i;\n      sub_FFFFFFFF8112DCD0(\n        *(_QWORD *)(*(_QWORD *)(v14 + 8) + 88 * v19 + 80),\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14,\n        a2,\n        *(__int64 **)(v14 + 8),\n        a4,\n        a5,\n        a6);\n    }\n    sub_FFFFFFFF8112DCD0(*(_QWORD *)(v14 + 8), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);\n    *(_DWORD *)(v14 + 4) = 0;\n  }\n}\n",
    "function_name": "drm_cleanup_buf_error",
    "decompiled_code": "void __fastcall drm_cleanup_buf_error(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        __int64 a5,\n        unsigned __int64 a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 v14; // rbx\n  __int64 *v16; // rdi\n  int v17; // r12d\n  int i; // r12d\n  __int64 v19; // rax\n\n  v14 = a2;\n  if ( *(_DWORD *)(a2 + 16) )\n  {\n    if ( *(int *)(a2 + 16) <= 0 )\n    {\n      v16 = *(__int64 **)(a2 + 24);\n    }\n    else\n    {\n      v16 = *(__int64 **)(a2 + 24);\n      v17 = 0;\n      do\n      {\n        a2 = v16[v17];\n        if ( a2 )\n        {\n          drm_pci_free(a1, (__int64 *)a2, (__int64)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);\n          v16 = *(__int64 **)(v14 + 24);\n        }\n        ++v17;\n      }\n      while ( *(_DWORD *)(v14 + 16) > v17 );\n    }\n    kfree(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3);\n    *(_DWORD *)(v14 + 16) = 0;\n  }\n  if ( *(_DWORD *)(v14 + 4) )\n  {\n    for ( i = 0; i < *(_DWORD *)(v14 + 4); ++i )\n    {\n      v19 = i;\n      kfree(\n        *(__int64 **)(*(_QWORD *)(v14 + 8) + 88 * v19 + 80),\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14,\n        a2,\n        *(__int64 **)(v14 + 8));\n    }\n    kfree(*(__int64 **)(v14 + 8), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3);\n    *(_DWORD *)(v14 + 4) = 0;\n  }\n}\n",
    "source_code": "static void drm_cleanup_buf_error(struct drm_device * dev,\n\t\t\t\t  struct drm_buf_entry * entry)\n{\n\tint i;\n\n\tif (entry->seg_count) {\n\t\tfor (i = 0; i < entry->seg_count; i++) {\n\t\t\tif (entry->seglist[i]) {\n\t\t\t\tdrm_pci_free(dev, entry->seglist[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(entry->seglist);\n\n\t\tentry->seg_count = 0;\n\t}\n\n\tif (entry->buf_count) {\n\t\tfor (i = 0; i < entry->buf_count; i++) {\n\t\t\tkfree(entry->buflist[i].dev_private);\n\t\t}\n\t\tkfree(entry->buflist);\n\n\t\tentry->buf_count = 0;\n\t}\n}",
    "comment": "Cleans up allocated buffer memory and frees associated resources in a DRM device's buffer entry structure.",
    "hext5_sum": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
    "bint5_sum": "The function frees a DRM memory management structure and its associated pages , ensuring proper cleanup of resources .\n",
    "cpbcs_sum": "Frees memory allocated for each baud mapping in the DRM device's resources and the device's resources appropriately.\n",
    "misum_sum": "Frees memory associated with a DRM property, including gamma ranges and their associated gamma ensuring proper cleanup of resources.\n",
    "decom_sum": "Processes and flushes queued and indexed data entries by invoking a transformation routine on each before resetting their respective counters to zero.",
    "cfg_sum": "Processes linked and arrayed data structures by invoking computation routines, then resets related counters and state fields to prepare for subsequent operations.",
    "work_score": {
        "decom": {
            "summary": "Processes and flushes queued and indexed data entries by invoking a transformation routine on each before resetting their respective counters to zero.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes processing and flushing of queued data with a transformation routine, which is not reflected in the source code. The code actually frees memory allocations for segments and buffers, then resets counters. None of the claims about invoking transformation routines or processing entries match the function\u2019s semantics, resulting in all claims being inaccurate.",
                "The summary does not accurately reflect the source code's core purpose, which is cleaning up buffer and segment memory allocations related to a DRM device after an error. It incorrectly describes processing and flushing data entries with a transformation routine, which is absent in the code. The core is not covered, and there is no mention of the specific memory freeing functions, segment/buffer lists, or defensive checks present in the implementation.",
                "The summary incorrectly describes the function as processing and flushing data entries via a transformation routine, which is a FATAL error about the primary purpose; the actual code deallocates memory for buffer and segment lists using drm_pci_free and kfree, then resets counts. No accurate claims are present, and the core behavior is misrepresented."
            ]
        },
        "cfg": {
            "summary": "Processes linked and arrayed data structures by invoking computation routines, then resets related counters and state fields to prepare for subsequent operations.",
            "score": [
                0.1,
                0.2,
                0.4
            ],
            "reason": [
                "The summary is overly generic and lacks specific, verifiable details about the function's actual behavior in the source code. It does not mention freeing memory for seglist and buflist entries, the use of drm_pci_free and kfree, or the conditional checks on seg_count and buf_count. The described operations like 'invoking computation routines' do not align with the actual cleanup routines in the code, resulting in almost entirely inaccurate claims.",
                "The summary offers a vague description of processing data structures and resetting counters, but it does not accurately capture the core purpose of the function, which is to free allocated segment and buffer memory in a DRM device when an error occurs. It omits key specifics such as conditional checks on seg_count and buf_count, the freeing of PCI and private buffer resources, and the resetting of associated counts. The lack of domain-specific detail means the core action is not covered, and no secondary behavior-critical semantics are addressed.",
                "The summary is overly generic and fails to mention specific details from the source code such as freeing allocated memory via drm_pci_free and kfree for segment and buffer lists, and clearing seg_count and buf_count. These omissions result in noise outweighing accuracy, as no clear domain-specific behavior is described, and the core purpose of memory cleanup is not explicitly captured."
            ]
        },
        "comment": {
            "summary": "Cleans up allocated buffer memory and frees associated resources in a DRM device's buffer entry structure.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures the core functionality of the function: it frees allocated buffer memory and related resources for a DRM device's buffer entry. This aligns with the source code, which iterates over segment and buffer lists, frees memory, and resets counters. The claim is accurate, but it is generic and low on detail, lacking specifics about the conditional checks, loops, and reset actions. Since it is still aligned with the source code semantics, it is considered accurate, resulting in a high proportion of accurate claims.",
                "The summary correctly identifies that the function cleans up allocated buffer memory and related resources for a DRM device buffer entry, which matches the core purpose of freeing segments and buffers from the source code. However, it lacks detail on important secondary behaviors such as iterating through segment and buffer lists, freeing device-private memory, and resetting counters, resulting in incomplete coverage of behavior-critical semantics.",
                "The summary correctly captures the primary purpose of the function, which is to clean up allocated buffer memory and free associated resources within a DRM device's buffer entry. This aligns with the source code, which frees both segment and buffer lists and resets their counts. The claim is accurate but generic, lacking detail such as the specific nature of allocations, the conditions under which they are freed, or the functions used for deallocation. There are no inaccurate claims or noise, but the gain is low due to minimal specificity."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4723024,
    "strip_function_name": "sub_481150",
    "strip_decompiled_code": "__int64 __fastcall sub_481150(__int64 a1, int a2, const char *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rbp\n  __int64 v5; // rcx\n  void *v7; // r15\n  __int64 v8; // r15\n  char **v9; // r14\n\n  result = 2LL;\n  v4 = *(_QWORD *)(a1 + 135592);\n  if ( v4 )\n  {\n    v5 = *(_QWORD *)(a1 + 135576);\n    result = 0LL;\n    if ( v5 )\n    {\n      if ( a2 >= 0 && *(_DWORD *)(a1 + 135560) > a2 )\n      {\n        v7 = *(void **)(v5 + 8LL * a2);\n        if ( v7 )\n        {\n          *(_QWORD *)(a1 + 135592) = v4 + strlen(*(const char **)(v5 + 8LL * a2)) + 1;\n          free(v7);\n          v4 = *(_QWORD *)(a1 + 135592);\n        }\n        v8 = (int)(strlen(a3) + 1);\n        if ( v8 >= v4 )\n        {\n          *(__m128i *)(a1 + 176644) = _mm_load_si128((const __m128i *)&xmmword_512970);\n          strcpy((char *)(a1 + 176708), \"t divided.\");\n          *(__m128i *)(a1 + 176660) = _mm_load_si128((const __m128i *)&xmmword_512980);\n          *(__m128i *)(a1 + 176676) = _mm_load_si128((const __m128i *)&xmmword_512990);\n          *(__m128i *)(a1 + 176692) = _mm_load_si128((const __m128i *)&xmmword_5129A0);\n          sub_4118F0((_DWORD *)a1, 0, (const char *)(a1 + 176644), 0, \"FAILURE\", 0);\n          *(_QWORD *)(a1 + 135592) = 0LL;\n          return 0LL;\n        }\n        else\n        {\n          v9 = (char **)(*(_QWORD *)(a1 + 135576) + 8LL * a2);\n          *v9 = strdup(a3);\n          if ( *(_QWORD *)(*(_QWORD *)(a1 + 135576) + 8LL * a2) )\n          {\n            result = 1LL;\n            *(_QWORD *)(a1 + 135592) = v4 - v8;\n          }\n          else\n          {\n            sub_40FA60(a1, 0LL, 0);\n            return 0xFFFFFFFFLL;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "Xorriso_register_node_target",
    "decompiled_code": "int __fastcall Xorriso_register_node_target(XorrisO *xorriso, int node_idx, char *disk_path, int flag)\n{\n  int result; // eax\n  off_t node_targets_availmem; // rbp\n  void **hln_targets; // rcx\n  void *v8; // r15\n  off_t v9; // r15\n  void **v10; // r14\n\n  result = 2;\n  node_targets_availmem = xorriso->node_targets_availmem;\n  if ( node_targets_availmem )\n  {\n    hln_targets = xorriso->hln_targets;\n    result = 0;\n    if ( hln_targets )\n    {\n      if ( node_idx >= 0 && xorriso->hln_count > node_idx )\n      {\n        v8 = hln_targets[node_idx];\n        if ( v8 )\n        {\n          xorriso->node_targets_availmem = node_targets_availmem + strlen((const char *)hln_targets[node_idx]) + 1;\n          free(v8);\n          node_targets_availmem = xorriso->node_targets_availmem;\n        }\n        v9 = (int)(strlen(disk_path) + 1);\n        if ( v9 >= node_targets_availmem )\n        {\n          *(__m128i *)xorriso->info_text = _mm_load_si128((const __m128i *)&xmmword_512970);\n          strcpy(&xorriso->info_text[64], \"t divided.\");\n          *(__m128i *)&xorriso->info_text[16] = _mm_load_si128((const __m128i *)&xmmword_512980);\n          *(__m128i *)&xorriso->info_text[32] = _mm_load_si128((const __m128i *)&xmmword_512990);\n          *(__m128i *)&xorriso->info_text[48] = _mm_load_si128((const __m128i *)&xmmword_5129A0);\n          Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, severity, 0);\n          xorriso->node_targets_availmem = 0LL;\n          return 0;\n        }\n        else\n        {\n          v10 = &xorriso->hln_targets[node_idx];\n          *v10 = strdup(disk_path);\n          if ( xorriso->hln_targets[node_idx] )\n          {\n            result = 1;\n            xorriso->node_targets_availmem = node_targets_availmem - v9;\n          }\n          else\n          {\n            Xorriso_no_malloc_memory(xorriso, 0LL, 0);\n            return -1;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "int Xorriso_register_node_target(struct XorrisO *xorriso, int node_idx,\n                                 char *disk_path, int flag)\n{\n int l;\n\n if(xorriso->node_targets_availmem == 0)\n   return(2);\n if(xorriso->hln_targets == NULL || node_idx < 0 ||\n    node_idx >= xorriso->hln_count)\n   return(0);\n if(xorriso->hln_targets[node_idx] != NULL) {\n   xorriso->node_targets_availmem+= strlen(xorriso->hln_targets[node_idx]) +1;\n   free(xorriso->hln_targets[node_idx]);\n }\n l= strlen(disk_path);\n if(xorriso->node_targets_availmem <= l + 1) {\n   sprintf(xorriso->info_text,\n \"Hardlink target buffer exceeds -temp_mem_limit. Hardlinks may get divided.\");\n   Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, \"FAILURE\", 0);\n   xorriso->node_targets_availmem= 0;\n   return(0);\n }\n xorriso->hln_targets[node_idx]= strdup(disk_path);\n if(xorriso->hln_targets[node_idx] == NULL) {\n   Xorriso_no_malloc_memory(xorriso, NULL, 0);\n   return(-1);\n }\n xorriso->node_targets_availmem-= (l + 1);\n return(1);\n}",
    "comment": "Registers a hardlink target for a specified node index in the Xorriso structure, managing memory and error handling accordingly.",
    "hext5_sum": "push a floating point type.",
    "bint5_sum": "Adds a new IsoNode to the IsoImage 's directory list , updating the list and managing memory for the node 's ID and type .\n",
    "cpbcs_sum": "Frees allocated memory for an ISO image, including its PID and managing memory and semaphore registers accordingly.\n",
    "misum_sum": "The function manages HFS+ file creator and optional contexts, returning an error if the file name is invalid or memory allocation fails.\n",
    "decom_sum": "Replaces an indexed stored string with a new one, updating remaining buffer size or logging a \u201cFAILURE\u201d message if space is insufficient.",
    "cfg_sum": "Updates an indexed string in a managed array, reallocating space if needed, logs a failure when oversized, and adjusts remaining buffer capacity accordingly.",
    "work_score": {
        "decom": {
            "summary": "Replaces an indexed stored string with a new one, updating remaining buffer size or logging a \u201cFAILURE\u201d message if space is insufficient.",
            "score": [
                0.9,
                0.3,
                0.7
            ],
            "reason": [
                "The summary captures the core behavior: it describes replacing a stored string at a specific index and updating available buffer space, and notes that a 'FAILURE' message is logged when space is insufficient. These points match the source code logic of freeing any existing string, checking available memory, logging a failure if too little space remains, and adjusting the memory counter. While the summary omits certain aspects like early returns for invalid indices or null pointers, the claims it does make are accurate and grounded in the code.",
                "The summary accurately notes replacing an indexed stored string and updating buffer size, as well as logging a FAILURE when space is insufficient, which matches the source code\u2019s handling of node_targets_availmem and error messaging. However, it fails to cover the core domain purpose of registering a hardlink target for a given node index within the xorriso context, omitting details about specific checks on hln_targets array bounds, freeing existing entries, handling allocation failures, and returning distinct status codes. Coverage of secondary behaviors is limited.",
                "The summary accurately captures the core behavior: replacing a string at a specified index, updating available buffer size, and logging a failure if insufficient space. It omits some secondary details such as freeing existing memory before replacement, specific return values for different error conditions, and handling of invalid indices, but these omissions do not contradict the code. Noise is minimal and no fatal inaccuracies are present, though the gain is moderate as the summary focuses on the primary purpose without extensive specifics."
            ]
        },
        "cfg": {
            "summary": "Updates an indexed string in a managed array, reallocating space if needed, logs a failure when oversized, and adjusts remaining buffer capacity accordingly.",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly notes updating an indexed string in a managed array and logging a failure when oversized, as well as adjusting buffer capacity. However, it inaccurately describes the process as 'reallocating space if needed,' whereas the code frees any existing entry and uses strdup without actual reallocation mechanics. Most claims align with the code except the reallocation detail, resulting in high but not perfect accuracy.",
                "The summary correctly notes updating an element in an array, logging failures on oversize, and adjusting buffer capacity, which aligns with the code's behavior. However, it misses the core purpose: registering a hardlink target in the xorriso context, including specific conditions for early returns, freeing old targets, and handling allocation failures. The coverage of secondary behaviors is partial, with no mention of error codes, freeing old memory, or the exact domain of 'hardlink' handling.",
                "The summary captures some accurate elements such as updating a stored string at an index and adjusting remaining buffer capacity, aligning with the code\u2019s logic. However, it omits crucial precondition checks like available memory and valid index range, and inaccurately implies reallocation rather than the code\u2019s explicit free/strdup sequence. It also oversimplifies error handling, not distinguishing between different return codes (-1, 0, 1, 2). These inaccuracies on the primary purpose and side effects introduce noise without being outright fatal for core semantics, resulting in low net benefit."
            ]
        },
        "comment": {
            "summary": "Registers a hardlink target for a specified node index in the Xorriso structure, managing memory and error handling accordingly.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function registers a hardlink target for a given node index and handles memory and errors accordingly. These are accurate reflections of the source code\u2019s semantics, though the description is general and omits specific conditions such as the limits on node index, available memory checks, and possible return codes. The claims present are accurate but low-detail, so the proportion of accurate claims is high.",
                "The summary correctly identifies the core purpose as registering a hardlink target for a given node index in the Xorriso structure, which matches the function\u2019s main behavior. It also notes memory management and error handling, reflecting the allocation, freeing, and limit checks present in the code. However, it omits specific secondary details such as the handling of existing targets, the mechanism for updating available memory, the distinct return codes for various conditions, and the generation of failure messages when limits are exceeded. Coverage is therefore solid for the core but lacks breadth in describing branch conditions and side effects.",
                "The summary accurately captures the core purpose of the function: registering a hardlink target for a given node index and handling memory management and errors. No inaccurate claims are present, but the description is generic and lacks specific details such as conditions for returns (0, 1, 2, -1), buffer limit checks, and freeing previous targets. The gain is low because while correct, it omits many precise conditions implemented in the function."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4223072,
    "strip_function_name": "sub_407060",
    "strip_decompiled_code": "char *__fastcall sub_407060(__int64 a1, unsigned int a2)\n{\n  char *result; // rax\n  __int16 v3; // dx\n  char *v4; // rax\n\n  result = \"ABS\";\n  if ( a2 == -15 )\n    return result;\n  result = \"COM\";\n  if ( a2 == -14 )\n    return result;\n  result = \"UND\";\n  if ( !a2 )\n    return result;\n  v3 = *(_WORD *)(a1 + 82);\n  if ( a2 == -256 )\n  {\n    if ( v3 == 50 )\n    {\n      result = \"ANSI_COM\";\n      if ( *(_BYTE *)(a1 + 31) == 1 )\n        return result;\n    }\n    else\n    {\n      result = \"SCOM\";\n      if ( v3 == 140 )\n        return result;\n    }\n    goto LABEL_10;\n  }\n  if ( (unsigned __int16)(v3 - 180) > 1u && v3 != 62 || (result = \"LARGE_COM\", a2 != -254) )\n  {\n    if ( a2 == -253 )\n    {\n      result = \"SCOM\";\n      if ( v3 == 8 )\n        return result;\n      goto LABEL_10;\n    }\n    if ( a2 != -252 || (result = \"SUND\", v3 != 8) )\n    {\n      if ( a2 + 256 > 0x1F )\n      {\n        if ( a2 + 224 <= 0x1F )\n        {\n          sprintf(byte_68E680, \"OS [0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else if ( a2 > 0xFFFFFEFF )\n        {\n          sprintf(byte_68E680, \"RSV[0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else\n        {\n          if ( a2 >= *(_DWORD *)(a1 + 100) )\n          {\n            v4 = dcgettext(0LL, \"bad section index[%3d]\", 5);\n            sprintf(byte_68E680, v4, a2);\n          }\n          else\n          {\n            sprintf(byte_68E680, \"%3d\", a2);\n          }\n          return byte_68E680;\n        }\n      }\nLABEL_10:\n      sprintf(byte_68E680, \"PRC[0x%04x]\", (unsigned __int16)a2);\n      return byte_68E680;\n    }\n  }\n  return result;\n}\n",
    "function_name": "get_symbol_index_type",
    "decompiled_code": "const char *__fastcall get_symbol_index_type(Filedata *filedata, unsigned int type)\n{\n  const char *result; // rax\n  unsigned __int16 e_machine; // dx\n  char *v4; // rax\n\n  result = \"ABS\";\n  if ( type == -15 )\n    return result;\n  result = file + 1849;\n  if ( type == -14 )\n    return result;\n  result = file + 1864;\n  if ( !type )\n    return result;\n  e_machine = filedata->file_header.e_machine;\n  if ( type == -256 )\n  {\n    if ( e_machine == 50 )\n    {\n      result = file + 1839;\n      if ( filedata->file_header.e_ident[7] == 1 )\n        return result;\n    }\n    else\n    {\n      result = file + 1848;\n      if ( e_machine == 140 )\n        return result;\n    }\n    goto LABEL_10;\n  }\n  if ( (unsigned __int16)(e_machine - 180) > 1u && e_machine != 62 || (result = file + 1853, type != -254) )\n  {\n    if ( type == -253 )\n    {\n      result = file + 1848;\n      if ( e_machine == 8 )\n        return result;\n      goto LABEL_10;\n    }\n    if ( type != -252 || (result = file + 1863, e_machine != 8) )\n    {\n      if ( type + 256 > 0x1F )\n      {\n        if ( type + 224 <= 0x1F )\n        {\n          sprintf((char *)&buff_17235.file_header.e_version, &file[1880], (unsigned __int16)type);\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n        else if ( type > 0xFFFFFEFF )\n        {\n          sprintf((char *)&buff_17235.file_header.e_version, &file[1892], (unsigned __int16)type);\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n        else\n        {\n          if ( type >= filedata->file_header.e_shnum )\n          {\n            v4 = dcgettext(0LL, &file[1904], 5);\n            sprintf((char *)&buff_17235.file_header.e_version, v4, type);\n          }\n          else\n          {\n            sprintf((char *)&buff_17235.file_header.e_version, &file[1927], type);\n          }\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n      }\nLABEL_10:\n      sprintf((char *)&buff_17235.file_header.e_version, &file[1868], (unsigned __int16)type);\n      return (const char *)&buff_17235.file_header.e_version;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic const char *\nget_symbol_index_type (Filedata * filedata, unsigned int type)\n{\n  static char buff[32];\n\n  switch (type)\n    {\n    case SHN_UNDEF:\treturn \"UND\";\n    case SHN_ABS:\treturn \"ABS\";\n    case SHN_COMMON:\treturn \"COM\";\n    default:\n      if (type == SHN_IA_64_ANSI_COMMON\n\t  && filedata->file_header.e_machine == EM_IA_64\n\t  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)\n\treturn \"ANSI_COM\";\n      else if ((filedata->file_header.e_machine == EM_X86_64\n\t\t|| filedata->file_header.e_machine == EM_L1OM\n\t\t|| filedata->file_header.e_machine == EM_K1OM)\n\t       && type == SHN_X86_64_LCOMMON)\n\treturn \"LARGE_COM\";\n      else if ((type == SHN_MIPS_SCOMMON\n\t\t&& filedata->file_header.e_machine == EM_MIPS)\n\t       || (type == SHN_TIC6X_SCOMMON\n\t\t   && filedata->file_header.e_machine == EM_TI_C6000))\n\treturn \"SCOM\";\n      else if (type == SHN_MIPS_SUNDEFINED\n\t       && filedata->file_header.e_machine == EM_MIPS)\n\treturn \"SUND\";\n      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)\n\tsprintf (buff, \"PRC[0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LOOS && type <= SHN_HIOS)\n\tsprintf (buff, \"OS [0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LORESERVE)\n\tsprintf (buff, \"RSV[0x%04x]\", type & 0xffff);\n      else if (type >= filedata->file_header.e_shnum)\n\tsprintf (buff, _(\"bad section index[%3d]\"), type);\n      else\n\tsprintf (buff, \"%3d\", type);\n      break;\n    }\n\n  return buff;\n}",
    "comment": "Returns a string representation of a symbol index type based on the provided type and file header information.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Maps specific C++ error codes to their corresponding string representations for terminal and terminal error handling in the provided handle data .\n",
    "cpbcs_sum": "Retrieves a string representation of the symbol type based on the provided section type and file type identifier from the ELF header structure.\n",
    "misum_sum": "Retrieves a string representation of the ELF section based on the provided section header and file name.\n",
    "decom_sum": "Returns a descriptive string label for a given section code based on specific numeric values and structure fields, formatting custom labels when not predefined.",
    "cfg_sum": "Maps section type codes and header fields to specific label strings or formatted text for display, including ABS, COM, UND, SCOM, and error messages.",
    "work_score": {
        "decom": {
            "summary": "Returns a descriptive string label for a given section code based on specific numeric values and structure fields, formatting custom labels when not predefined.",
            "score": [
                0.9,
                0.4,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function returns a descriptive string label for a given section code based on numeric values and structure fields, and that it formats custom labels when the section code is not predefined. These are accurate high-level descriptions of the source code's behavior. Although the summary lacks specific examples of the predefined labels and conditions, its claims align with the code's actual operation and there are no contradictions.",
                "The summary generically states that the function returns a descriptive string for a section code based on values and structure fields, which aligns with the core behavior of mapping specific numeric type constants to labels. However, it lacks coverage of many critical secondary details such as the exact constant cases handled (UND, ABS, COM, ANSI_COM, LARGE_COM, SCOM, SUND), architecture and OS-specific conditions, range-based formatting for processor, OS, and reserved values, and handling of invalid indices. As a result, while the core is present, secondary semantics are weak.",
                "The summary correctly states that the function returns a descriptive string based on numeric values and structure fields, which aligns with the source code's switch cases and conditional checks. However, it is very generic and omits critical specifics such as the distinct labels ('UND', 'ABS', etc.), machine-specific conditions, and formatting patterns. There are no inaccurate claims, but the low level of detail yields only minimal insight, making overall gain low despite accurate core purpose coverage. The worst failure mode is low gain from generic SAFE claims."
            ]
        },
        "cfg": {
            "summary": "Maps section type codes and header fields to specific label strings or formatted text for display, including ABS, COM, UND, SCOM, and error messages.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function maps section type codes to label strings such as ABS, COM, UND, and SCOM, and produces error-like messages for invalid indices. These claims align with the source code's handling of SHN_ABS, SHN_COMMON, SHN_UNDEF, SCOM variants, and the 'bad section index' case. However, the summary omits other specific mappings like ANSI_COM, LARGE_COM, SUND, and OS/PRC/RSV formats, indicating incomplete coverage though most stated claims are accurate.",
                "The summary accurately notes that the function maps section type codes and header fields to specific string labels, and mentions some correct examples like ABS, COM, UND, and SCOM, plus error message handling. This covers the core purpose of translating type codes into human-readable labels for display. However, it omits other important mappings present in the source such as ANSI_COM, LARGE_COM, SUND, PRC, OS, RSV, and numeric formatting for valid indices, meaning secondary coverage is incomplete.",
                "The summary accurately conveys that the function maps section type codes to labels such as ABS, COM, UND, and SCOM, and also generates error messages or formatted text for other cases. These claims align with the code's behavior and target its core output mapping without introducing contradictions. However, the summary is generic and omits more specific cases like ANSI_COM, LARGE_COM, SUND, and precise conditions, resulting in low informational gain despite correctness. Noise is minimal and no fatal errors are present, but the gain remains limited."
            ]
        },
        "comment": {
            "summary": "Returns a string representation of a symbol index type based on the provided type and file header information.",
            "score": [
                0.9,
                0.4,
                0.5
            ],
            "reason": [
                "The summary accurately conveys that the function returns a string representation of a symbol index type based on the provided type and file header data. This matches the core semantic behavior of the source code, though it is generic and does not capture specific conditional mappings or exact output formats. No inaccurate claims are present, and the single fact-based claim aligns with the code, making the purity high despite low detail.",
                "The summary accurately conveys the core purpose of returning a string representation based on type and header info, matching the main function behavior. However, it is very generic, omitting key secondary details such as special constant cases (e.g., SHN_UNDEF mapping to 'UND'), machine/OSABI-specific conditions, and various formatted outputs for ranges and error cases. This lack of coverage of critical branches and constants reduces completeness.",
                "The summary is broadly accurate in stating that the function returns a string describing a symbol index type using the type and file header data, but it is generic and omits critical specifics. It fails to mention any of the detailed conditional cases, exact return strings, or formatting logic present in the code. There are no incorrect claims, but the low-information nature of the summary means the gain is minimal, and there is no noise or fatal error impacting trustworthiness."
            ]
        }
    }
}
{
    "project_name": "grep",
    "function_addr": 38112,
    "strip_function_name": "sub_94E0",
    "strip_decompiled_code": "struct obstack **__fastcall sub_94E0(struct obstack *src, struct obstack *a2)\n{\n  struct obstack *v2; // r15\n  struct obstack *v3; // rbp\n  struct obstack *v4; // r12\n  char *v5; // rbx\n  size_t v6; // r13\n  char v7; // cl\n  struct obstack *v8; // rsi\n  __int64 v9; // rbx\n  struct obstack **result; // rax\n  char *v11; // [rsp+0h] [rbp-68h]\n  char v12; // [rsp+Fh] [rbp-59h]\n  _QWORD v14[9]; // [rsp+20h] [rbp-48h] BYREF\n\n  v2 = src;\n  v3 = 0LL;\n  v14[0] = 0LL;\n  v14[1] = __readfsqword(0x28u);\n  v4 = (struct obstack *)sub_BB00(1LL);\n  v11 = (char *)a2 + (_QWORD)src;\n  do\n  {\n    v5 = (char *)rawmemchr(v2, 10);\n    v6 = v5 - (char *)v2;\n    if ( byte_246CC5 )\n    {\n      v7 = byte_2467A0;\n      if ( v2 > src && byte_2467A0 == 10 )\n      {\n        v2 = (struct obstack *)((char *)v2 - 1);\n      }\n      else\n      {\n        if ( (__int64)(v6 + 1) >= v14[0] )\n        {\n          sub_14930(v3);\n          v14[0] = v5 - (char *)v2;\n          v3 = (struct obstack *)sub_2A3B0(0LL, v14, 2LL, -1LL, 1LL);\n          LOBYTE(v3->chunk_size) = byte_2467A0;\n          v7 = byte_2467A0;\n        }\n        v8 = v2;\n        v12 = v7;\n        v2 = v3;\n        memcpy((char *)&v3->chunk_size + 1, v8, v6);\n        *((_BYTE *)&v3->chunk_size + v6 + 1) = v12;\n      }\n      v6 += 2LL;\n    }\n    sub_AB00(v4, v2, v6);\n    v2 = (struct obstack *)(v5 + 1);\n  }\n  while ( v5 + 1 <= v11 );\n  sub_14930(v3);\n  v9 = sub_B040(v4);\n  sub_B050(v4);\n  result = (struct obstack **)sub_2A1C0(40LL);\n  *result = v4;\n  result[1] = (struct obstack *)v9;\n  result[2] = src;\n  result[4] = 0LL;\n  result[3] = a2;\n  return result;\n}\n",
    "function_name": "Fcompile",
    "decompiled_code": "void *__fastcall Fcompile(char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  char *v4; // r15\n  _BYTE *v5; // rbp\n  kwset *v6; // r12\n  char *v7; // rbx\n  size_t v8; // r13\n  char v9; // cl\n  char *v10; // rsi\n  idx_t v11; // rbx\n  void *result; // rax\n  char *retaddr; // [rsp+68h] [rbp+0h]\n  char v14; // [rsp+77h] [rbp+Fh]\n  idx_t v16; // [rsp+88h] [rbp+20h] BYREF\n  unsigned __int64 v17; // [rsp+90h] [rbp+28h]\n\n  v4 = pattern;\n  v5 = 0LL;\n  v16 = 0LL;\n  v17 = __readfsqword(0x28u);\n  v6 = kwsinit(1);\n  retaddr = &pattern[size];\n  do\n  {\n    v7 = (char *)rawmemchr(v4, 10);\n    v8 = v7 - v4;\n    if ( match_lines )\n    {\n      v9 = eolbyte[0];\n      if ( v4 > pattern && eolbyte[0] == 10 )\n      {\n        --v4;\n      }\n      else\n      {\n        if ( (__int64)(v8 + 1) >= v16 )\n        {\n          rpl_free(v5);\n          v16 = v7 - v4;\n          v5 = xpalloc(0LL, &v16, 2LL, -1LL, 1LL);\n          *v5 = eolbyte[0];\n          v9 = eolbyte[0];\n        }\n        v10 = v4;\n        v14 = v9;\n        v4 = v5;\n        memcpy(v5 + 1, v10, v8);\n        v5[v8 + 1] = v14;\n      }\n      v8 += 2LL;\n    }\n    kwsincr(v6, v4, v8);\n    v4 = v7 + 1;\n  }\n  while ( v7 + 1 <= retaddr );\n  rpl_free(v5);\n  v11 = kwswords(v6);\n  kwsprep(v6);\n  result = xmalloc(0x28uLL);\n  *(_QWORD *)result = v6;\n  *((_QWORD *)result + 1) = v11;\n  *((_QWORD *)result + 2) = pattern;\n  *((_QWORD *)result + 4) = 0LL;\n  *((_QWORD *)result + 3) = size;\n  return result;\n}\n",
    "source_code": "\nvoid *\nFcompile (char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  kwset_t kwset;\n  char *buf = NULL;\n  idx_t bufalloc = 0;\n\n  kwset = kwsinit (true);\n\n  char const *p = pattern;\n  do\n    {\n      char const *sep = rawmemchr (p, '\\n');\n      idx_t len = sep - p;\n\n      if (match_lines)\n        {\n          if (eolbyte == '\\n' && pattern < p)\n            p--;\n          else\n            {\n              if (bufalloc < len + 2)\n                {\n                  free (buf);\n                  bufalloc = len;\n                  buf = xpalloc (NULL, &bufalloc, 2, -1, 1);\n                  buf[0] = eolbyte;\n                }\n              memcpy (buf + 1, p, len);\n              buf[len + 1] = eolbyte;\n              p = buf;\n            }\n          len += 2;\n        }\n      kwsincr (kwset, p, len);\n\n      p = sep + 1;\n    }\n  while (p <= pattern + size);\n\n  free (buf);\n\n  idx_t words = kwswords (kwset);\n  kwsprep (kwset);\n\n  struct kwsearch *kwsearch = xmalloc (sizeof *kwsearch);\n  kwsearch->kwset = kwset;\n  kwsearch->words = words;\n  kwsearch->pattern = pattern;\n  kwsearch->size = size;\n  kwsearch->re = NULL;\n  return kwsearch;\n}",
    "comment": "Processes a pattern string, initializes a keyword set, and returns a structure containing the keyword set and its associated properties.",
    "hext5_sum": "| this will initialize various tables for pattern match and compiles some | | regexps. | '",
    "bint5_sum": "Concatenates two string buffers into a single output array , freeing the first string and returning the combined result .\n",
    "cpbcs_sum": "Appends a new word to a hash table of text, allocating memory and handling potential stack overflow based on the operation's parameter.\n",
    "misum_sum": "Constructs a formatted error message with a specified name and line number, formatting it as a string buffer with optional HTML and priority details.\n",
    "decom_sum": "Processes newline-delimited data from a source buffer, conditionally replaces line endings, stores chunks in an obstack, and returns a structured result.",
    "cfg_sum": "Processes input buffer line-by-line, conditionally modifies segments, stores them in obstacks, and returns a structured result containing processed and original data references.",
    "work_score": {
        "decom": {
            "summary": "Processes newline-delimited data from a source buffer, conditionally replaces line endings, stores chunks in an obstack, and returns a structured result.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary includes fact-based claims about processing newline-delimited data and conditionally replacing line endings, which align with the code\u2019s loop over newline separators and conditional eolbyte handling. However, it inaccurately states that chunks are stored in an obstack, which is not present in the source code; the code uses a buffer and kwset instead. This incorrect detail reduces the proportion of accurate claims to below half.",
                "The summary claims the function processes newline-delimited data, which is true, but inaccurately states that it stores chunks in an obstack\u2014a data structure not used in the source code. It omits the core purpose of compiling the pattern into a keyword set for searching (via kwsinit, kwsincr, kwsprep) and returning a kwsearch struct. No accurate claim fully covers the primary purpose, and most key behaviors such as keyword set preparation, conditional line ending handling with eolbyte, memory allocation strategy, and struct field initialization are missing or misrepresented.",
                "The summary contains multiple inaccurate claims: it mentions storing chunks in an obstack, which is not present in the code (the function uses xpalloc and memcpy, not obstacks), and refers to a generic 'source buffer' without correctly noting that 'pattern' and its newline segments are processed. It also misstates the return type, calling it a 'structured result' without specifying the actual kwsearch struct fields derived from kwset. These inaccuracies target the core behavior and data handling but do not fatally contradict the primary purpose. Accurate elements include noting newline-delimited data processing and conditional line ending changes, but these are somewhat generic and overshadowed by noise from unrelated details."
            ]
        },
        "cfg": {
            "summary": "Processes input buffer line-by-line, conditionally modifies segments, stores them in obstacks, and returns a structured result containing processed and original data references.",
            "score": [
                0.3,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function stores segments in obstacks, but the source code shows no use of obstacks; instead, it allocates memory via xpalloc and xmalloc. The summary omits key accurate details like the use of a keyword set to process input lines and modify them when match_lines is true. While it correctly notes line-by-line processing and returning a structured result with both processed and original data references, substantial inaccuracies such as the 'obstacks' claim reduce precision to below half of the claims.",
                "The summary incorrectly states that the function stores segments in obstacks, which is unsupported by the source code. Instead, the code uses dynamic memory allocation (xpalloc/xmalloc) and operates on a keyword set via kwsinit/kwsincr/kwsprep, which is not mentioned. The core purpose\u2014compiling a keyword set from a newline-delimited pattern with optional line-boundary modifications\u2014is absent, and the described behavior is vague and inaccurate in relation to actual side effects and data structures used. No accurate claims cover the core domain action.",
                "The summary contains a severe inaccuracy about the primary purpose: it claims the function stores data in obstacks, which is not present in the code, and misstates core behavior by omitting the kwset construction and preparation. While it mentions line-by-line processing and conditional modification, it fails to accurately describe the actual data structures used (no obstacks, uses kwset) and the main compilation flow, making it unreliable for understanding key semantics."
            ]
        },
        "comment": {
            "summary": "Processes a pattern string, initializes a keyword set, and returns a structure containing the keyword set and its associated properties.",
            "score": [
                0.9,
                0.4,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function processes a pattern string, initializes a keyword set, and returns a structure with associated properties, which aligns with the code\u2019s behavior. However, it omits key specifics such as splitting by newline, handling of match_lines and eolbyte, and preparation of the keyword set before returning. The claims present are accurate but generic, without misrepresentation, resulting in a high proportion of accurate statements despite low detail.",
                "The summary correctly states that the function processes a pattern string, initializes a keyword set, and returns a structure containing it, which matches the core purpose of preparing and returning a keyword search structure. However, it lacks detail about critical secondary behaviors such as splitting the pattern by newline, handling match_lines and eolbyte adjustments, dynamic buffer allocation, keyword length adjustments, and preparation steps via kwsprep. The coverage of the core is present but secondary semantics are very thin.",
                "The summary is broadly accurate in stating that the function processes a pattern string, initializes a keyword set, and returns a structure with associated properties. However, it omits key domain-specific behaviors such as handling newline-separated patterns, conditional byte prepending/appending based on match_lines and eolbyte, memory allocation details, and preparation of the keyword set via kwswords/kwsprep. The claims are accurate but generic and low-detail, with no evident incorrect or fatal information; nonetheless, the low informational gain limits usefulness."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583015424,
    "strip_function_name": "sub_FFFFFFFF813FA200",
    "strip_decompiled_code": "__int64 sub_FFFFFFFF813FA200()\n{\n  __int64 v0; // rax\n  bool v1; // bl\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  __int64 result; // rax\n  _QWORD *v6; // r12\n  int v7; // edx\n  char *v8; // rbx\n  _UNKNOWN **v9; // rax\n\n  v0 = sub_FFFFFFFF817928D0(&unk_FFFFFFFF81EA423C);\n  if ( byte_FFFFFFFF81CB8EB8 )\n  {\n    v1 = (_WORD)dword_FFFFFFFF81EA4244 != 0 || dword_FFFFFFFF81EA4240 != HIWORD(dword_FFFFFFFF81EA4244);\n    byte_FFFFFFFF81CB8EB8 = !v1;\n    sub_FFFFFFFF81792660(&unk_FFFFFFFF81EA423C, v0);\n    result = 0LL;\n    if ( v1 )\n    {\n      v6 = 0LL;\n      v7 = 0;\n      v8 = (char *)off_FFFFFFFF81C66FC0 - 8;\n      if ( off_FFFFFFFF81C66FC0 != (_UNKNOWN *)&off_FFFFFFFF81C66FC0 )\n      {\n        do\n        {\n          if ( (v8[200] & 1) != 0 )\n          {\n            sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819C382C, *(_QWORD *)v8, v7, v2, v3, v4);\n            v7 = 1;\n          }\n          else if ( v7 )\n          {\n            v7 = 1;\n          }\n          else if ( v6 )\n          {\n            if ( *((_QWORD *)v8 + 17) > v6[17] )\n              v6 = v8;\n          }\n          else\n          {\n            v6 = v8;\n          }\n          v9 = (_UNKNOWN **)*((_QWORD *)v8 + 1);\n          v8 = (char *)(v9 - 1);\n        }\n        while ( v9 != &off_FFFFFFFF81C66FC0 );\n        if ( !v7 )\n        {\n          if ( v6 )\n            sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819E6C88, *v6, 0, v2, v3, v4);\n        }\n      }\n      return 1LL;\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF81792660(&unk_FFFFFFFF81EA423C, v0);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "pm_wakeup_pending",
    "decompiled_code": "__int64 __fastcall pm_wakeup_pending(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  bool v8; // bl\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  __int64 result; // rax\n  _QWORD *v12; // r12\n  __int64 v13; // rdx\n  char *v14; // rbx\n  _UNKNOWN **v15; // rax\n\n  raw_spin_lock_irqsave(events_lock);\n  if ( events_check_enabled )\n  {\n    v8 = (_WORD)combined_event_count != 0 || saved_count != HIWORD(combined_event_count);\n    events_check_enabled = !v8;\n    raw_spin_unlock_irqrestore(events_lock);\n    result = 0LL;\n    if ( v8 )\n    {\n      v12 = 0LL;\n      v13 = 0LL;\n      v14 = (char *)wakeup_sources - 8;\n      if ( wakeup_sources != (_UNKNOWN *)&wakeup_sources )\n      {\n        do\n        {\n          if ( (v14[200] & 1) != 0 )\n          {\n            printk((__int64)&unk_FFFFFFFF819C382C, a1, a2, a3, a4, v9, v10, a7, a8, *(_QWORD *)v14, v13);\n            v13 = 1LL;\n          }\n          else if ( (_DWORD)v13 )\n          {\n            v13 = 1LL;\n          }\n          else if ( v12 )\n          {\n            if ( *((_QWORD *)v14 + 17) > v12[17] )\n              v12 = v14;\n          }\n          else\n          {\n            v12 = v14;\n          }\n          v15 = (_UNKNOWN **)*((_QWORD *)v14 + 1);\n          v14 = (char *)(v15 - 1);\n        }\n        while ( v15 != &wakeup_sources );\n        if ( !(_DWORD)v13 )\n        {\n          if ( v12 )\n            printk((__int64)&unk_FFFFFFFF819E6C88, a1, a2, a3, a4, v9, v10, a7, a8, *v12);\n        }\n      }\n      return 1LL;\n    }\n  }\n  else\n  {\n    raw_spin_unlock_irqrestore(events_lock);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "bool pm_wakeup_pending(void)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&events_lock, flags);\n\tif (events_check_enabled) {\n\t\tunsigned int cnt, inpr;\n\n\t\tsplit_counters(&cnt, &inpr);\n\t\tret = (cnt != saved_count || inpr > 0);\n\t\tevents_check_enabled = !ret;\n\t}\n\tspin_unlock_irqrestore(&events_lock, flags);\n\n\tif (ret)\n\t\tprint_active_wakeup_sources();\n\n\treturn ret;\n}",
    "comment": "Checks if a wakeup event is pending by comparing counters and prints active wakeup sources if there is a pending event.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "The function checks and updates the power save state of devices that are busy , returning an error if any device is busy .\n",
    "cpbcs_sum": "Flushes the deferred flush command by writing the status to the event list if the offset is active and the current thread.\n",
    "misum_sum": "Checks if the system core is busy and updates the last CPU's mode signal based on the current mode and reference counts.\n",
    "decom_sum": "Checks hardware state flags, updates global status, and triggers specific handler calls for the first active or most recently updated device in a linked list.",
    "cfg_sum": "Evaluates hardware state flags, updates control variables, iterates device list to trigger specific handlers, and returns status indicating whether any device action was performed.",
    "work_score": {
        "decom": {
            "summary": "Checks hardware state flags, updates global status, and triggers specific handler calls for the first active or most recently updated device in a linked list.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains several domain-specific claims that contradict the source code. It incorrectly describes checking hardware state flags, updating a global status, and handling linked list devices, none of which appear in the function. The function instead checks event counters under a spinlock, updates a flag, optionally prints active wakeup sources, and returns a boolean. All claims are inaccurate, resulting in 0% accuracy.",
                "The summary's claims about hardware state flags, global status updates, and triggering handlers for devices in a linked list are inaccurate relative to the source code, which checks event counters under a spinlock to detect pending wakeups, updates a flag, and optionally prints active wakeup sources. The summary fails to cover the core purpose of detecting pending wakeup events and contains domain elements (linked list devices) not present in the code.",
                "The summary's claims about checking hardware state flags, updating global status, and triggering handler calls for a device in a linked list are inaccurate in relation to the source code. The function actually locks events, checks counters against a saved count, may update a flag, prints active wakeup sources, and returns a boolean, with no linked list or device-specific handler logic. These mismatches represent FATAL errors in describing the core purpose and side effects, making the description unreliable."
            ]
        },
        "cfg": {
            "summary": "Evaluates hardware state flags, updates control variables, iterates device list to trigger specific handlers, and returns status indicating whether any device action was performed.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "Most claims are inaccurate: the function does not iterate a device list or trigger specific handlers, nor does it evaluate generic hardware state flags. It locks events_lock, checks event counters against saved_count, updates events_check_enabled, optionally prints active wakeup sources, and returns whether a wakeup is pending. Only the part about updating control variables and returning a status is loosely accurate, so the proportion of accurate claims is well below half.",
                "The summary does not accurately capture the core purpose of the function, which checks if a power management wakeup is pending by comparing event counters under a spinlock and optionally printing active wakeup sources. Claims such as evaluating hardware state flags, iterating a device list, and triggering handlers are inaccurate and do not align with the actual code behavior. The core domain action is missing and no correct secondary details are provided.",
                "The summary contains multiple inaccurate claims about the function's behavior. It incorrectly states that it evaluates hardware state flags, iterates over a device list, and triggers specific handlers, none of which are present in the source code. The function actually checks event counters under a spinlock, updates a control flag, optionally prints active wakeup sources, and returns whether a wakeup is pending. These inaccuracies target the core purpose and key side effects, making them severe (FATAL). There are no accurate, domain-specific claims, resulting in a net negative benefit."
            ]
        },
        "comment": {
            "summary": "Checks if a wakeup event is pending by comparing counters and prints active wakeup sources if there is a pending event.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function checks for a pending wakeup event by comparing counters and that it prints active wakeup sources when an event is pending. These claims align with the source code behavior, though the summary omits certain internal details such as the locking mechanism and the events_check_enabled flag manipulation. Both extracted claims are accurate and specific to the code's semantics, leading to a high proportion of accurate statements.",
                "The summary correctly describes the core purpose: determining if a wakeup event is pending by comparing counters, and notes the behavior of printing active wakeup sources when such an event exists, which matches the source code's logic. However, it omits secondary details such as the use of spin locks for thread safety, the role of 'events_check_enabled' in gating checks, the modification of that flag when an event is detected, and the specific conditions based on 'saved_count' and 'inpr'. These omissions limit completeness despite accurate core coverage.",
                "The summary correctly captures the core purpose of the function: determining if a wakeup event is pending by comparing counters and indicating that it prints active wakeup sources when an event is pending. These are specific and accurate reflections of the code's behavior, with no evident inaccuracies or irrelevant noise. While it omits minor implementation details such as locking, counter splitting, and state updates, the provided claims are still precise and directly tied to the code\u2019s primary purpose, yielding clear and useful information."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4331184,
    "strip_function_name": "sub_4216B0",
    "strip_decompiled_code": "char *__fastcall sub_4216B0(const char *a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  char *v7; // rax\n  char *chunk_limit; // rcx\n  char *object_base; // r13\n  char *v10; // rdi\n  char *v11; // rsi\n  char v12; // dl\n  __int64 v13; // rdi\n  char *v15; // [rsp+8h] [rbp-30h]\n\n  ++qword_7E5280;\n  v7 = sub_421280(a1);\n  chunk_limit = stru_7EA840.chunk_limit;\n  if ( (char *)(stru_7EA840.chunk_limit - stru_7EA840.next_free) <= (char *)0x27 )\n  {\n    v15 = v7;\n    obstack_newchunk(&stru_7EA840, 40LL);\n    object_base = stru_7EA840.object_base;\n    chunk_limit = stru_7EA840.chunk_limit;\n    v7 = v15;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  else\n  {\n    object_base = stru_7EA840.object_base;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  *((_BYTE *)&stru_7EA840 + 80) |= 2u;\nLABEL_3:\n  v11 = (char *)(~*(_QWORD *)&stru_7EA840.alignment_mask & (unsigned __int64)&v10[*(_QWORD *)&stru_7EA840.alignment_mask]);\n  stru_7EA840.next_free = v11;\n  if ( (char *)(v11 - (char *)stru_7EA840.chunk) > (char *)(chunk_limit - (char *)stru_7EA840.chunk) )\n  {\n    stru_7EA840.next_free = chunk_limit;\n    v11 = chunk_limit;\n  }\n  v12 = *object_base;\n  v13 = qword_7E5288;\n  stru_7EA840.object_base = v11;\n  *((_QWORD *)object_base + 3) = a4;\n  *((_QWORD *)object_base + 1) = a2;\n  *((_QWORD *)object_base + 4) = a3;\n  *((_QWORD *)object_base + 2) = v7;\n  *object_base = v12 & 0xFA | 1;\n  sub_411620(v13, v7, (__int64)object_base);\n  return object_base;\n}\n",
    "function_name": "local_symbol_make",
    "decompiled_code": "local_symbol *__fastcall local_symbol_make(const char *name, __int64 a2, __int64 a3, __int64 a4)\n{\n  char *v7; // rax\n  char *chunk_limit; // rcx\n  char *object_base; // r13\n  char *v10; // rdi\n  char *v11; // rsi\n  char v12; // dl\n  hash_control *v13; // rdi\n  char *v15; // [rsp+8h] [rbp-30h]\n\n  ++local_symbol_count;\n  v7 = save_symbol_name(name);\n  chunk_limit = notes.chunk_limit;\n  if ( (char *)(notes.chunk_limit - notes.next_free) <= (char *)0x27 )\n  {\n    v15 = v7;\n    obstack_newchunk((__int64)&notes, 0x28uLL);\n    object_base = notes.object_base;\n    chunk_limit = notes.chunk_limit;\n    v7 = v15;\n    v10 = notes.next_free + 40;\n    if ( notes.next_free + 40 != notes.object_base )\n      goto LABEL_3;\n  }\n  else\n  {\n    object_base = notes.object_base;\n    v10 = notes.next_free + 40;\n    if ( notes.next_free + 40 != notes.object_base )\n      goto LABEL_3;\n  }\n  *((_BYTE *)&notes + 80) |= 2u;\nLABEL_3:\n  v11 = (char *)(~notes.alignment_mask & (unsigned __int64)&v10[notes.alignment_mask]);\n  notes.next_free = v11;\n  if ( (char *)(v11 - (char *)notes.chunk) > (char *)(chunk_limit - (char *)notes.chunk) )\n  {\n    notes.next_free = chunk_limit;\n    v11 = chunk_limit;\n  }\n  v12 = *object_base;\n  v13 = local_hash;\n  notes.object_base = v11;\n  *((_QWORD *)object_base + 3) = a4;\n  *((_QWORD *)object_base + 1) = a2;\n  *((_QWORD *)object_base + 4) = a3;\n  *((_QWORD *)object_base + 2) = v7;\n  *object_base = v12 & 0xFA | 1;\n  hash_jam((__int64)v13, v7, object_base);\n  return (local_symbol *)object_base;\n}\n",
    "source_code": "\nstruct local_symbol *\nlocal_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n{\n  const char *name_copy;\n  struct local_symbol *ret;\n\n  ++local_symbol_count;\n\n  name_copy = save_symbol_name (name);\n\n  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n  ret->lsy_flags.sy_local_symbol = 1;\n  ret->lsy_flags.sy_resolved = 0;\n  ret->lsy_name = name_copy;\n  ret->lsy_section = section;\n  local_symbol_set_frag (ret, frag);\n  ret->lsy_value = val;\n\n  hash_jam (local_hash, name_copy, (void *) ret);\n\n  return ret;\n}",
    "comment": "Creates and initializes a local symbol structure, copying its name, setting properties, and storing it in a hash table.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Adds a symbol name to a memory chunk , allocating memory if necessary , and ensuring it does not exceed the maximum chunk size .\n",
    "cpbcs_sum": "Appends a new field operation to a structured header field if the symbol class is greater than one otherwise returns a cloning pointer.\n",
    "misum_sum": "Appends a new normal extension to a linked list of text, initializing its properties and managing memory appropriately.\n",
    "decom_sum": "Allocates a new 40\u2011byte object in an obstack, populates its fields with given parameters, and registers it via a callback.",
    "cfg_sum": "Allocates or realigns space in an obstack, stores provided parameters in the new object, sets status flags, and registers the object for tracking.",
    "work_score": {
        "decom": {
            "summary": "Allocates a new 40\u2011byte object in an obstack, populates its fields with given parameters, and registers it via a callback.",
            "score": [
                0.5,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly notes that the function allocates a new object in an obstack, populates its fields with given parameters, and registers it via a callback-like function (hash_jam). However, it inaccurately specifies the object size as 40 bytes, which is not derived from the source code and may be incorrect, and omits relevant initialization details such as setting specific flags and copying the symbol name. This lowers accuracy, resulting in mixed reliability where only part of the claims fully align with the code.",
                "The summary notes object allocation in an obstack and setting fields from parameters, which is partially accurate. However, it misstates the size as 40 bytes (not evident from the source), uses vague wording like 'registers via a callback' instead of the specific hash insertion (hash_jam) into local_hash, and omits the core purpose: creating and initializing a local_symbol with specific flags and storing it in a hash table. Secondary behaviors like incrementing local_symbol_count, saving the symbol name, setting flags, and associating the frag are also missing or imprecisely covered.",
                "The summary correctly notes allocation in an obstack, setting fields from parameters, and registering the symbol, which matches the source code's creation and initialization of a local_symbol and adding it to a hash. However, the claim of a fixed 40-byte size is inaccurate because the structure size is not specified in the code and could vary; this is a semantic error related to the implementation details but not the primary purpose. The rest of the claims are accurate but somewhat generic, offering limited insight beyond obvious allocation and registration steps. Noise is minimal, but the 40-byte size detail reduces trust slightly."
            ]
        },
        "cfg": {
            "summary": "Allocates or realigns space in an obstack, stores provided parameters in the new object, sets status flags, and registers the object for tracking.",
            "score": [
                0.8,
                0.2,
                0.4
            ],
            "reason": [
                "The summary correctly notes allocation in an obstack, storage of provided parameters in the new object, setting of status flags, and registration for tracking, all of which match the source code\u2019s behavior. However, the phrase 'realigns space' is inaccurate since the code only allocates memory without mention of realignment. Most claims are accurate, but the minor semantic deviation reduces precision slightly.",
                "The summary vaguely describes allocation in an obstack and storing parameters, but it fails to state the core primary purpose of creating and registering a local_symbol with specific attributes. It omits key domain-specific details such as copying the symbol name, setting section and value, associating a frag, and using hash_jam for registration. The coverage of secondary semantics is minimal and generic, with no mention of name handling or symbol count increment. Overall, the core action is not explicitly covered, and important behavior-critical details are missing.",
                "The summary contains mostly generic and vague claims, such as allocating space, storing parameters, setting flags, and registering for tracking, without accurately capturing the core semantics like incrementing `local_symbol_count`, copying the name, setting specific flag values, or adding to `local_hash`. The phrase 'realigns space in an obstack' is misleading and not evident from the code, introducing noise. While no severe factual contradiction of the primary purpose is present, the lack of specific detail and presence of vague/misleading elements results in low net benefit."
            ]
        },
        "comment": {
            "summary": "Creates and initializes a local symbol structure, copying its name, setting properties, and storing it in a hash table.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately reflects the core behavior of the function: creating and initializing a local symbol, copying its name, setting properties using flags and provided arguments, and storing it in a hash table. All details align with the source code\u2019s semantics without introducing contradictions or irrelevant information, yielding a high proportion of accurate claims.",
                "The summary accurately describes creating and initializing a local symbol, name copying, property setting, and insertion into a hash table, all of which align with the source code. It covers the core purpose\u2014constructing and registering a local_symbol in the hash table\u2014and includes key secondary aspects like copying the name and setting flags. However, it omits specifics such as incrementing the local_symbol_count, using obstack_alloc for memory allocation, and calling local_symbol_set_frag, which are also behavior-critical.",
                "The summary correctly identifies that the function creates and initializes a local symbol, copies its name, sets various properties, and stores it in a hash table, all of which align with the source code. There are no inaccurate claims or noise, but the description is generic and lacks specific details such as the exact flags set, the increment of the symbol count, or the functions used for allocation and hashing. This results in low gain despite no errors."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586119824,
    "strip_function_name": "sub_FFFFFFFF816F0090",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816F0090(\n        __int64 a1,\n        void (__fastcall *a2)(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10),\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r12\n  __int64 v11; // r14\n  __int64 v12; // r15\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 v15; // rax\n  unsigned __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = *(_QWORD *)(a1 + 568);\n  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL);\n  v12 = v10 + 32;\n  while ( 1 )\n  {\n    sub_FFFFFFFF81792900(v10 + 200);\n    v15 = *(_QWORD *)(v10 + 32);\n    v16 = v15 - 56;\n    if ( v12 == v15 )\n      break;\n    while ( *(_QWORD *)(v15 - 48) != v16 + 8 )\n    {\n      v15 = *(_QWORD *)(v16 + 56);\n      v16 = v15 - 56;\n      if ( v12 == v15 )\n        goto LABEL_7;\n    }\n    *(_DWORD *)(v16 + 48) = -32;\n    _InterlockedIncrement((volatile signed __int32 *)v16);\n    sub_FFFFFFFF816EE8D0(v16, a3, a4, a5, a6, v13, v14, a9, a10);\n    ++*(_BYTE *)(v10 + 200);\n    sub_FFFFFFFF816EF9B0(v16, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n  }\nLABEL_7:\n  ++*(_BYTE *)(v10 + 200);\n  return sub_FFFFFFFF816EF2F0(v11);\n}\n",
    "function_name": "gss_pipe_release",
    "decompiled_code": "__int64 __fastcall gss_pipe_release(\n        __int64 a1,\n        void (__fastcall *a2)(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, int a13, int a14),\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r12\n  __int64 v11; // r14\n  __int64 v12; // r15\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 v15; // rax\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = *(_QWORD *)(a1 + 568);\n  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL);\n  v12 = v10 + 32;\n  while ( 1 )\n  {\n    raw_spin_lock((volatile signed __int16 *)(v10 + 200));\n    v15 = *(_QWORD *)(v10 + 32);\n    v16 = v15 - 56;\n    if ( v12 == v15 )\n      break;\n    while ( *(_QWORD *)(v15 - 48) != v16 + 8 )\n    {\n      v15 = *(_QWORD *)(v16 + 56);\n      v16 = v15 - 56;\n      if ( v12 == v15 )\n        goto LABEL_7;\n    }\n    *(_DWORD *)(v16 + 48) = -32;\n    _InterlockedIncrement((volatile signed __int32 *)v16);\n    _gss_unhash_msg(v16, a3, a4, a5, a6, v13, v14, a9, a10);\n    ++*(_BYTE *)(v10 + 200);\n    gss_release_msg((__int64 *)v16, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n  }\nLABEL_7:\n  ++*(_BYTE *)(v10 + 200);\n  return put_pipe_version(v11);\n}\n",
    "source_code": "\nstatic void\ngss_pipe_release(struct inode *inode)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tstruct gss_upcall_msg *gss_msg;\n\nrestart:\n\tspin_lock(&pipe->lock);\n\tlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\n\n\t\tif (!list_empty(&gss_msg->msg.list))\n\t\t\tcontinue;\n\t\tgss_msg->msg.errno = -EPIPE;\n\t\tatomic_inc(&gss_msg->count);\n\t\t__gss_unhash_msg(gss_msg);\n\t\tspin_unlock(&pipe->lock);\n\t\tgss_release_msg(gss_msg);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&pipe->lock);\n\n\tput_pipe_version(net);\n}",
    "comment": "Releases GSS upcall messages in a pipe by unhashing and incrementing the error count for empty message lists before freeing resources.",
    "hext5_sum": "returns the maximum of all the values returned by handle_file, or exit_trouble if trouble is encountered in opening files. compare the contents of two directories named in cmp. this is a top-level routine; it does everything necessary for diff on two directories. cmp->file[0].desc == -1 says directory cmp->file[0] doesn't exist, but pretend it is empty. likewise for cmp->file[1]. handle_file is a caller-provided subroutine called to handle each file. it gets three operands: cmp, name of file in dir 0, name of file in dir 1. these names are relative to the original working directory. for a file that appears in",
    "bint5_sum": "Releases resources and cleans up a GSS message , ensuring no pending requests are processed before freeing associated memory .\n",
    "cpbcs_sum": "Releases the RPC client associated with a task, removing it from the client's task list and freeing the client memory.\n",
    "misum_sum": "Releases resources associated with an RPC client by iterating through the RPC client and invoking the appropriate protocol's function.\n",
    "decom_sum": "Iterates through a linked list of objects, updates state, invokes two processing callbacks with parameters, and finalizes by executing a rendering-related operation.",
    "cfg_sum": "Iterates through linked memory structures, updates status and counters, processes data via callbacks, and finalizes by invoking a cleanup routine.",
    "work_score": {
        "decom": {
            "summary": "Iterates through a linked list of objects, updates state, invokes two processing callbacks with parameters, and finalizes by executing a rendering-related operation.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about iterating a linked list are partially accurate since the function does iterate over 'pipe->in_downcall'. However, it inaccurately describes the invoked operations as 'two processing callbacks with parameters' and a 'rendering-related operation', which do not match the actual source code semantics of setting errno, incrementing count, unhashing & releasing messages, and putting pipe version. Most claims misrepresent the domain and the final step, leading to less than half being accurate.",
                "The summary's claims about iterating a linked list, updating state, invoking processing callbacks, and performing a rendering-related operation do not match the source code's actual domain semantics, which involve processing GSS upcall messages, setting an error code, unhashing and releasing messages, and updating pipe version in a networking/security context. The core purpose is entirely missed, and the details are inaccurate, with no coverage of error handling, message reference counting, or lock management present in the code.",
                "The summary contains multiple inaccurate claims about the function's purpose and operations. It incorrectly describes invoking 'two processing callbacks with parameters' and a 'rendering-related operation', which are not present in the source code. The core action is to iterate through gss_upcall_msg entries, update error state, unhash and release messages, and update the pipe version, with no rendering or generic callback processing. These inaccuracies target the primary purpose and key side effects, constituting a severe FATAL error. No accurate, high-gain claims are present, and noise dominates."
            ]
        },
        "cfg": {
            "summary": "Iterates through linked memory structures, updates status and counters, processes data via callbacks, and finalizes by invoking a cleanup routine.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary captures some generic aspects of the function, such as iteration over structures and invoking a cleanup routine, which aligns loosely with the code\u2019s loop over `pipe->in_downcall` and final `put_pipe_version(net)`. However, most claims are vague or inaccurate: 'updates status and counters' is only partially correct (errno and count changes), 'processes data via callbacks' does not match the code\u2019s use of internal helper calls rather than callbacks, and the summary omits critical domain-specific details like lock handling, condition checks, and restarting the loop. Overall accuracy is below half, with high reliance on generic statements.",
                "The summary gives a vague, generic description of iteration, status updates, counters, callbacks, and cleanup but does not identify the core action of releasing pending GSS upcall messages in an RPC pipe with specific locking, error setting, and re-looping. No [ACCURATE] claim matches the concrete domain semantics of the source. Secondary details like restart loop, EPIPE assignment, unhashing messages, or put_pipe_version call are omitted, leaving the core purpose uncovered.",
                "The summary makes generic claims about iteration and cleanup, but omits key specifics from the source code, such as handling of gss_upcall_msg structures, setting errno to -EPIPE, atomic counter updates, and lock management. There are no direct contradictions (no FATAL), but the generalized 'processes data via callbacks' is not supported by the code and qualifies as noise. Overall, the description provides only low-value, boilerplate insight with noticeable noise."
            ]
        },
        "comment": {
            "summary": "Releases GSS upcall messages in a pipe by unhashing and incrementing the error count for empty message lists before freeing resources.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function releases GSS upcall messages from a pipe, and it captures the checks for empty message lists and resource freeing steps. It also notes unhashing and incrementing a count, though it labels the count as an 'error count' rather than accurately describing it as incrementing the message's reference counter, which is a minor inaccuracy. Most claims align with the source code behavior, with only slight mislabeling, so accuracy is high.",
                "The summary correctly describes that the function releases GSS upcall messages and mentions unhashing, incrementing count, and freeing resources, which align with the code\u2019s actions for messages with empty lists. However, it inaccurately refers to 'incrementing the error count' instead of setting an errno value to -EPIPE, and it omits key details such as the loop/restart mechanism, locking, and the final call to put_pipe_version, leading to incomplete coverage of secondary behaviors.",
                "The summary correctly captures the primary purpose: releasing GSS upcall messages by unhashing them, incrementing a counter, and setting an error for empty message lists before freeing resources. This matches the code's behavior (checking for empty list, setting errno to -EPIPE, incrementing count, unhashing, releasing). There is no inaccurate or contradictory claim, and noise is minimal. However, the summary is somewhat generic and omits specific details such as the restart loop mechanism, locking, and the final call to put_pipe_version, limiting its informational gain."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6106942,
    "strip_function_name": "sub_5D2F3E",
    "strip_decompiled_code": "__int64 *__fastcall sub_5D2F3E(\n        __int64 a1,\n        __int64 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  const __m128i *v10; // r13\n  __int64 v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // rax\n  __int64 v15; // r12\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rsi\n  __int64 v20; // rcx\n  __m128i *v21; // rax\n  __int64 *result; // rax\n\n  v10 = (const __m128i *)a2;\n  if ( !a2 )\n    v10 = (const __m128i *)&unk_67933B;\n  LODWORD(v11) = sub_455F70(v10);\n  v14 = sub_51812F((const char *)(v11 + 32), a2, a3, a4, a5, a6, v12, v13, a9, a10);\n  v15 = *(_QWORD *)(a1 + 8);\n  v16 = v14;\n  *(_QWORD *)v14 = v15;\n  *(_QWORD *)(v14 + 8) = *(_QWORD *)a1;\n  *(_BYTE *)(v14 + 24) = (*(_DWORD *)(a1 + 24) & 0xF000) == 0x4000;\n  sub_400520(v14 + 25, v10);\n  v19 = qword_899E98;\n  LODWORD(v20) = v15;\n  if ( !qword_899E98 )\n  {\n    v21 = sub_51816D((const char *)0x9B8, 0LL, a3, a4, a5, a6, v17, v18, a9, a10);\n    v20 = *(_QWORD *)(a1 + 8);\n    qword_899E98 = (__int64)v21;\n    v19 = (__int64)v21;\n  }\n  result = (__int64 *)(v19 + 8LL * ((unsigned int)v20 % 0x137));\n  *(_QWORD *)(v16 + 16) = *result;\n  *result = v16;\n  return result;\n}\n",
    "function_name": "add_to_ino_dev_hashtable",
    "decompiled_code": "__int64 *__fastcall add_to_ino_dev_hashtable(\n        __int64 a1,\n        __int64 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  const __m128i *v10; // r13\n  __int64 v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  __int64 v15; // rax\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rsi\n  __int64 v20; // rcx\n  __m128i *v21; // rax\n  __int64 *result; // rax\n\n  v10 = (const __m128i *)a2;\n  if ( !a2 )\n    v10 = (const __m128i *)&byte_67933B;\n  LODWORD(v11) = strlen(v10);\n  xmalloc(v11 + 32, a2, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = *(_QWORD *)(a1 + 8);\n  v16 = v15;\n  *(_QWORD *)v15 = v14;\n  *(_QWORD *)(v15 + 8) = *(_QWORD *)a1;\n  *(_BYTE *)(v15 + 24) = (*(_DWORD *)(a1 + 24) & 0xF000) == 0x4000;\n  strcpy((char *)(v15 + 25), v10->m128i_i8);\n  v19 = ino_dev_hashtable;\n  LODWORD(v20) = v14;\n  if ( !ino_dev_hashtable )\n  {\n    v21 = xzalloc(0x9B8uLL, 0LL, a3, a4, a5, a6, v17, v18, a9, a10);\n    v20 = *(_QWORD *)(a1 + 8);\n    ino_dev_hashtable = (__int64)v21;\n    v19 = (__int64)v21;\n  }\n  result = (__int64 *)(v19 + 8LL * ((unsigned int)v20 % 0x137));\n  *(_QWORD *)(v16 + 16) = *result;\n  *result = v16;\n  return result;\n}\n",
    "source_code": "void FAST_FUNC add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name)\n{\n\tint i;\n\tino_dev_hashtable_bucket_t *bucket;\n\n\tif (!name)\n\t\tname = \"\";\n\tbucket = xmalloc(sizeof(ino_dev_hashtable_bucket_t) + strlen(name));\n\tbucket->ino = statbuf->st_ino;\n\tbucket->dev = statbuf->st_dev;\n\tbucket->isdir = !!S_ISDIR(statbuf->st_mode);\n\tstrcpy(bucket->name, name);\n\n\tif (!ino_dev_hashtable)\n\t\tino_dev_hashtable = xzalloc(HASH_SIZE * sizeof(*ino_dev_hashtable));\n\n\ti = hash_inode(statbuf->st_ino);\n\tbucket->next = ino_dev_hashtable[i];\n\tino_dev_hashtable[i] = bucket;\n}",
    "comment": "Adds a new entry to the inode-device hashtable using the provided stat structure and name, allocating memory for the bucket dynamically.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Creates and initializes a new ` grecs_txtacc ` structure , setting its properties and linking it to a specified file or standard output .\n",
    "cpbcs_sum": "Adds a new file to the server list after validating the old and duplicating the new file path.\n",
    "misum_sum": "Adds a new file to the global log list and updates the corresponding variable in the structured data structure.\n",
    "decom_sum": "Initializes a new linked entry with provided parameters and inserts it into a global hash table bucket based on an identifier modulo 0x137.",
    "cfg_sum": "Sets up a linked data entry from input parameters, initializes global storage if needed, and inserts it into a hash table by computed index.",
    "work_score": {
        "decom": {
            "summary": "Initializes a new linked entry with provided parameters and inserts it into a global hash table bucket based on an identifier modulo 0x137.",
            "score": [
                0.3,
                0.4,
                0.2
            ],
            "reason": [
                "The summary contains one main claim: that the function uses an identifier modulo 0x137 to determine the bucket. This is inaccurate because the code uses `hash_inode(statbuf->st_ino)` and does not reveal a modulo operation or the constant 0x137. While the rest of the claim about initializing a new entry and inserting it into a global hash table reflects actual behavior, the incorrect bucket calculation makes the overall precision low, with less than half of the claim content being accurate.",
                "The summary correctly notes creating a new entry and inserting it into a global hash table, which aligns with the core purpose of adding a bucket to ino_dev_hashtable based on hashed inode. However, the claim about using an identifier modulo 0x137 is inaccurate\u2014the code uses hash_inode(statbuf->st_ino) and does not reference 0x137. The summary omits several key details such as using statbuf's ino/dev/mode fields, handling NULL names, allocating memory, and initialization of the global table. The core is partially covered but with an inaccuracy and limited secondary detail.",
                "The summary contains a key inaccuracy: it claims the bucket index is determined by an identifier modulo 0x137, but the source code uses the result of hash_inode(statbuf->st_ino) with no visible modulo value given, making this a FATAL error about the core hash insertion logic. While it correctly notes initializing a new linked entry and inserting into a global hash table, the incorrect modulo detail undermines trust in the primary purpose. This severe semantic error on key I/O outweighs the accurate but generic elements."
            ]
        },
        "cfg": {
            "summary": "Sets up a linked data entry from input parameters, initializes global storage if needed, and inserts it into a hash table by computed index.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function creates a data entry from parameters, initializes global storage if it is not yet allocated, and inserts it into a hash table at a computed index, all of which match the source code behavior. There are no inaccurate or irrelevant claims, though the description is somewhat generic and omits details like inode/device handling and directory flag setting. Overall, claims are accurate and aligned with the code semantics.",
                "The summary correctly captures the core behavior of creating a new entry from inputs, initializing global storage if null, and inserting it into a hash table by index, which aligns with the source code's domain purpose. However, it omits important specifics such as extracting inode and device values from the stat structure, determining if the entry is a directory, handling empty name substitution, and memory allocation details. These missing secondary details reduce completeness.",
                "The summary correctly states that the function creates an entry from input parameters, checks and initializes global storage if needed, and inserts it into a hash table using a computed index. These are accurate reflections of the code\u2019s behavior with no contradictory claims. However, the description is generic, omitting specifics such as storing inode/device values, detecting directories, or how memory allocation occurs, resulting in low informational gain. Noise is minimal and there are no fatal inaccuracies."
            ]
        },
        "comment": {
            "summary": "Adds a new entry to the inode-device hashtable using the provided stat structure and name, allocating memory for the bucket dynamically.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function adds a new entry to the inode-device hashtable using the provided stat structure and name, and that it allocates memory dynamically for the bucket. These are directly supported by the code: the 'bucket' is allocated with xmalloc, fields are set from 'statbuf' and 'name', and it is inserted into the appropriate hashtable bucket. The summary omits some implementation details (e.g., directory flag handling or initialization of hashtable memory) but all included claims are accurate and clearly relate to code semantics.",
                "The summary correctly states that the function adds a new entry to the inode-device hashtable using the provided stat structure and name, and that it allocates memory for the bucket dynamically. This matches the core purpose from the source code, which is inserting a statbuf/name-based bucket into the hashtable. However, it omits several important secondary details, such as handling a NULL name by substituting an empty string, determining if the entry is a directory, initializing the hashtable if it is NULL, computing the hash index from the inode, and linking the bucket into the list. This results in partial coverage of the behavior-critical semantics.",
                "The summary correctly states that the function adds a new entry to the inode-device hashtable using data from the provided stat structure and name, and that memory for the bucket is allocated dynamically. These are accurate descriptions of the core behavior matching the source code. However, the summary omits several specific details such as handling a NULL name, derivation of the isdir flag from st_mode, initialization of the hashtable if uninitialized, and linking the new bucket into the existing bucket list. No inaccurate claims are present, but gain is limited due to the generic and incomplete nature of the summary."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5933504,
    "strip_function_name": "sub_5A89C0",
    "strip_decompiled_code": "__int64 __fastcall sub_5A89C0(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v10; // rax\n  _BYTE *v11; // r12\n  unsigned int v12; // r13d\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 v19; // rbx\n  __int64 v20; // rbp\n  __int16 v21; // ax\n  char v23[2]; // [rsp+0h] [rbp-138h] BYREF\n  __int16 v24; // [rsp+2h] [rbp-136h]\n  _WORD v25[148]; // [rsp+10h] [rbp-128h] BYREF\n\n  v10 = sub_51812F((const char *)0x100, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  if ( *(_QWORD *)(a10 + 8) )\n    sub_516747(256LL, a10);\n  v11 = (_BYTE *)v10;\n  v12 = sub_5D081B(*(double *)a1.m128_u64);\n  sub_5D9D86(0LL, v11, 7LL);\n  if ( !sub_5170F0(v11, \"bkeymap\") )\n    sub_51797B(\n      \"not a valid binary keymap\",\n      (__int64)\"bkeymap\",\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8,\n      v23[0]);\n  v19 = 0LL;\n  sub_5D9D86(0LL, v11, 256LL);\n  do\n  {\n    if ( v11[v19] == 1 )\n    {\n      v20 = 0LL;\n      sub_5D9D86(0LL, v25, 256LL);\n      do\n      {\n        v21 = v25[v20];\n        v23[1] = v20++;\n        v23[0] = v19;\n        v24 = v21;\n        sub_4AF0E0(v12, 0x4B47u, (unsigned __int64)v23);\n      }\n      while ( v20 != 128 );\n    }\n    ++v19;\n  }\n  while ( v19 != 256 );\n  return 0LL;\n}\n",
    "function_name": "loadkmap_main",
    "decompiled_code": "__int64 __fastcall loadkmap_main(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  char *v10; // rax\n  __int64 v11; // rdx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  char *v14; // r12\n  unsigned int console_fd_or_die; // r13d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  __int64 v20; // r8\n  __int64 v21; // r9\n  __m128 v22; // xmm4\n  __m128 v23; // xmm5\n  __int64 v24; // rbx\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 v27; // rbp\n  __int16 v28; // ax\n  char v30[2]; // [rsp+0h] [rbp-138h] BYREF\n  __int16 v31; // [rsp+2h] [rbp-136h]\n  _WORD v32[148]; // [rsp+10h] [rbp-128h] BYREF\n\n  xmalloc(0x100uLL, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  if ( *(_QWORD *)(a10 + 8) )\n    bb_show_usage((const char *)0x100, a1, a2, a3, a4, v12, v13, a7, a8);\n  v14 = v10;\n  console_fd_or_die = get_console_fd_or_die(a1, a2, a3, a4, v12, v13, a7, a8, 256LL, a10, v11);\n  xread(0, v14, 7LL, a1, a2, a3, a4, v16, v17, a7, a8);\n  if ( !is_prefixed_with(v14, \"bkeymap\") )\n    bb_error_msg_and_die(\n      (const __m128i *)\"not a valid binary keymap\",\n      (__int64)\"bkeymap\",\n      v18,\n      v19,\n      v20,\n      v21,\n      a1,\n      a2,\n      a3,\n      a4,\n      v22,\n      v23,\n      a7,\n      a8,\n      v30[0]);\n  v24 = 0LL;\n  xread(0, v14, 256LL, a1, a2, a3, a4, *(double *)v22.m128_u64, *(double *)v23.m128_u64, a7, a8);\n  do\n  {\n    if ( v14[v24] == 1 )\n    {\n      v27 = 0LL;\n      xread(0, (char *)v32, 256LL, a1, a2, a3, a4, v25, v26, a7, a8);\n      do\n      {\n        v28 = v32[v27];\n        v30[1] = v27++;\n        v30[0] = v24;\n        v31 = v28;\n        ioctl(console_fd_or_die, 0x4B47u, (unsigned __int64)v30);\n      }\n      while ( v27 != 128 );\n    }\n    ++v24;\n  }\n  while ( v24 != 256 );\n  return 0LL;\n}\n",
    "source_code": "int loadkmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct kbentry ke;\n\tint i, j, fd;\n\tuint16_t ibuff[NR_KEYS];\n/*\tconst char *tty_name = CURRENT_TTY; */\n\tRESERVE_CONFIG_BUFFER(flags, MAX_NR_KEYMAPS);\n\n\t/* When user accidentally runs \"loadkmap FILE\"\n\t * instead of \"loadkmap <FILE\", we end up waiting for input from tty.\n\t * Let's prevent it: */\n\tif (argv[1])\n\t\tbb_show_usage();\n/* bb_warn_ignoring_args(argv[1]); */\n\n\tfd = get_console_fd_or_die();\n/* or maybe:\n\topt = getopt32(argv, \"C:\", &tty_name);\n\tfd = xopen_nonblocking(tty_name);\n*/\n\n\txread(STDIN_FILENO, flags, 7);\n\tif (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))\n\t\tbb_error_msg_and_die(\"not a valid binary keymap\");\n\n\txread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);\n\n\tfor (i = 0; i < MAX_NR_KEYMAPS; i++) {\n\t\tif (flags[i] != 1)\n\t\t\tcontinue;\n\t\txread(STDIN_FILENO, ibuff, NR_KEYS * sizeof(uint16_t));\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tke.kb_index = j;\n\t\t\tke.kb_table = i;\n\t\t\tke.kb_value = ibuff[j];\n\t\t\t/*\n\t\t\t * Note: table[idx:0] can contain special value\n\t\t\t * K_ALLOCATED (marks allocated tables in kernel).\n\t\t\t * dumpkmap saves the value as-is; but attempts\n\t\t\t * to load it here fail, since it isn't a valid\n\t\t\t * key value: it is K(KT_SPEC,126) == 2<<8 + 126,\n\t\t\t * whereas last valid KT_SPEC is\n\t\t\t * K_BARENUMLOCK == K(KT_SPEC,19).\n\t\t\t * So far we just ignore these errors:\n\t\t\t */\n\t\t\tioctl(fd, KDSKBENT, &ke);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t\tRELEASE_CONFIG_BUFFER(flags);\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "comment": "Loads a binary keymap from standard input and updates the keyboard mapping using ioctl calls for each valid keymap.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Executes an ioctl system call and handles errors by logging a message and terminating the program if the call fails .\n",
    "cpbcs_sum": "Displays terminal type information using the provided termios structure and handles both standard and standard input processing each set.\n",
    "misum_sum": "Sets the CPU affinity of a network interface, optionally using ioctl system calls based on command-line arguments and specified flags.\n",
    "decom_sum": "Parses a binary keymap file labeled \"bkeymap\" and registers all active keycode mappings using a provided device identifier.",
    "cfg_sum": "Processes a binary keymap file, validates its format, and maps key codes by iterating through 256-byte and 128-word lookup tables.",
    "work_score": {
        "decom": {
            "summary": "Parses a binary keymap file labeled \"bkeymap\" and registers all active keycode mappings using a provided device identifier.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function parses a binary keymap file labeled 'bkeymap' and registers mappings using a provided device identifier. The source code does load and process a binary keymap from standard input and applies active mappings via ioctl, which is partially accurate. However, there is no reference to a file labeled 'bkeymap' or the use of a provided device identifier; the code instead obtains a console file descriptor internally. This introduces significant inaccuracies, making the claim less than half accurate.",
                "The summary claims the function parses a binary keymap file labeled \"bkeymap\" and registers mappings using a provided device identifier, but the source code does not mention a file label \"bkeymap\" or use a provided device identifier; it reads from STDIN and opens the console directly. While it does register active key mappings via ioctl, the misstatement of file label and device parameter makes the core domain action inaccurately described, so the primary purpose is not correctly covered.",
                "The summary contains a FATAL inaccuracy regarding the primary purpose: it claims parsing of a file labeled 'bkeymap' and use of a provided device identifier, but the source code actually reads binary keymap data from standard input without any filename handling, and obtains the console file descriptor internally rather than using a provided identifier. This misstates core I/O behavior, making the description unreliable. There are no accurate GOLD details present to offset this error."
            ]
        },
        "cfg": {
            "summary": "Processes a binary keymap file, validates its format, and maps key codes by iterating through 256-byte and 128-word lookup tables.",
            "score": [
                0.3,
                0.3,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function processes a binary keymap file and validates its format, which matches the code's use of `is_prefixed_with` on `BINARY_KEYMAP_MAGIC`. However, the claim about iterating through '256-byte and 128-word lookup tables' is inaccurate; the code iterates over `MAX_NR_KEYMAPS` flags and `NR_KEYS` entries reading `NR_KEYS * sizeof(uint16_t)`, not fixed 256-byte or 128-word tables. This introduces a significant semantic error, reducing the proportion of accurate claims to below half.",
                "The summary states processing a binary keymap file and validating its format, which aligns with reading from stdin, checking for a magic prefix, and processing keymap tables. However, the core purpose of loading the keymap into the kernel via ioctl per table/key index is omitted. Additionally, the numbers '256-byte' and '128-word' lookup tables are inaccurate\u2014the actual code uses MAX_NR_KEYMAPS and NR_KEYS*sizeof(uint16_t) constants rather than fixed byte sizes. While validation is correctly mentioned, key operational details such as handling invalid key values and prevention of incorrect usage are missing.",
                "The summary correctly identifies the binary keymap processing and validation of format, but the claim about iterating through '256-byte and 128-word lookup tables' is inaccurate for this code. The function reads MAX_NR_KEYMAPS bytes for flags and NR_KEYS (likely 128) 16-bit values, but there is no 256-byte table involved. This constitutes a factual error about key I/O details, which is central to understanding the data layout. While part of the purpose is accurately captured, the key specificity is wrong, so the benefit is low and the error is significant."
            ]
        },
        "comment": {
            "summary": "Loads a binary keymap from standard input and updates the keyboard mapping using ioctl calls for each valid keymap.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function loads a binary keymap from standard input and updates the keyboard mapping using ioctl calls, which matches the source code behavior. It omits minor details such as validation of the binary magic, handling flags, skipping non-active keymaps, and resource cleanup, but the claims that are present are accurate and directly map to code semantics. Given that all stated claims are accurate, the proportion of accurate claims is over 80%.",
                "The summary accurately states that the function loads a binary keymap from standard input and uses ioctl calls to update keyboard mappings, which covers the core purpose of applying key mappings from a binary keymap to the console. However, it omits important secondary details from the source code, such as the validation via BINARY_KEYMAP_MAGIC, handling argument misuse, looping through multiple keymaps and keys, ignoring invalid key values like K_ALLOCATED, and resource cleanup. These omissions limit completeness despite correct core coverage.",
                "The summary correctly captures the primary purpose: reading a binary keymap from standard input and applying it using ioctl for each valid keymap entry. This is an accurate and specific reflection of the source code's core behavior with minimal noise. However, it omits some details like validation of the binary magic header and iteration conditions, which limits informational depth but does not introduce inaccuracies."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582628544,
    "strip_function_name": "sub_FFFFFFFF8139BAC0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8139BAC0(\n        _QWORD *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int v13; // r14d\n  unsigned int v14; // ebx\n  __int64 v15; // rdx\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // [rsp+4h] [rbp-2Ch] BYREF\n\n  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 16LL) + 456LL) + 840LL);\n  if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v9 + 16) + 5LL) - 6) <= 1u )\n  {\n    result = sub_FFFFFFFF8178F4A0(v9 + 8880);\n    if ( !(_DWORD)result )\n    {\n      sub_FFFFFFFF81155B50(\n        a1,\n        (__int64)\"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n      v13 = *(unsigned __int8 *)(v9 + 8743);\n      v14 = 50 * v13;\n      if ( *(_BYTE *)(v9 + 8744) >= *(_BYTE *)(v9 + 8743) )\n      {\n        do\n        {\n          v18 = v13++;\n          sub_FFFFFFFF813DA900(v9, 9LL, &v18);\n          v15 = v14;\n          v14 += 50;\n          sub_FFFFFFFF81155B50(\n            a1,\n            (__int64)\"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n            a2,\n            a3,\n            a4,\n            a5,\n            v16,\n            v17,\n            a8,\n            a9,\n            v15,\n            100 * (unsigned int)(unsigned __int8)v18,\n            100 * (unsigned int)BYTE1(v18));\n        }\n        while ( *(unsigned __int8 *)(v9 + 8744) >= v13 );\n      }\n      sub_FFFFFFFF8178F1B0(v9 + 8880);\n      return 0LL;\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF81155B50(a1, (__int64)\"unsupported on this chipset\\n\", a2, a3, a4, a5, a6, a7, a8, a9);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "i915_ring_freq_table",
    "decompiled_code": "__int64 __fastcall i915_ring_freq_table(\n        _QWORD *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  int v15; // r9d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // r14d\n  unsigned int v19; // ebx\n  __int64 v20; // rdx\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  int v23; // [rsp+4h] [rbp-2Ch] BYREF\n\n  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 16LL) + 456LL) + 840LL);\n  if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v9 + 16) + 5LL) - 6) <= 1u )\n  {\n    result = mutex_lock_interruptible(v9 + 8880);\n    if ( !(_DWORD)result )\n    {\n      seq_printf(\n        a1,\n        (__int64)\"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n      v18 = *(unsigned __int8 *)(v9 + 8743);\n      v19 = 50 * v18;\n      if ( *(_BYTE *)(v9 + 8744) >= *(_BYTE *)(v9 + 8743) )\n      {\n        do\n        {\n          v23 = v18++;\n          sandybridge_pcode_read(v9, 9u, (unsigned int *)&v23, v13, v14, v15, a2, a3, a4, a5, v16, v17, a8, a9);\n          v20 = v19;\n          v19 += 50;\n          seq_printf(\n            a1,\n            (__int64)\"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n            a2,\n            a3,\n            a4,\n            a5,\n            v21,\n            v22,\n            a8,\n            a9,\n            v20,\n            100 * (unsigned int)(unsigned __int8)v23,\n            100 * (unsigned int)BYTE1(v23));\n        }\n        while ( *(unsigned __int8 *)(v9 + 8744) >= v18 );\n      }\n      mutex_unlock(v9 + 8880);\n      return 0LL;\n    }\n  }\n  else\n  {\n    seq_printf(a1, (__int64)\"unsupported on this chipset\\n\", a2, a3, a4, a5, a6, a7, a8, a9);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int i915_ring_freq_table(struct seq_file *m, void *unused)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tint ret;\n\tint gpu_freq, ia_freq;\n\n\tif (!(IS_GEN6(dev) || IS_GEN7(dev))) {\n\t\tseq_printf(m, \"unsupported on this chipset\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->rps.hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\tfor (gpu_freq = dev_priv->rps.min_delay;\n\t     gpu_freq <= dev_priv->rps.max_delay;\n\t     gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsandybridge_pcode_read(dev_priv,\n\t\t\t\t       GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t\t       &ia_freq);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   gpu_freq * GT_FREQUENCY_MULTIPLIER,\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tmutex_unlock(&dev_priv->rps.hw_lock);\n\n\treturn 0;\n}",
    "comment": "Retrieves and prints GPU, effective CPU, and effective Ring frequencies for Intel Gen6 and Gen7 chipsets, while protecting access with a mutex lock.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves and prints swizzle information for Intel graphics devices based on the generation of the Intel graphics device .\n",
    "cpbcs_sum": "Retrieves and displays information about the framebuffer, including size, depth, count, and status, in a sequence file for display.\n",
    "misum_sum": "Retrieves and displays the CPU frequency in a formatted output based on the specified display mode and total frequency values.\n",
    "decom_sum": "Prints GPU, effective CPU, and ring frequencies in MHz for supported chipsets, iterating through frequency steps and displaying formatted tabular output.",
    "cfg_sum": "Outputs GPU, CPU, and Ring frequency data for supported chipsets, iterating measurements, and reporting unsupported hardware when validation fails.",
    "work_score": {
        "decom": {
            "summary": "Prints GPU, effective CPU, and ring frequencies in MHz for supported chipsets, iterating through frequency steps and displaying formatted tabular output.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function prints GPU, effective CPU, and ring frequencies in MHz, iterates through frequency steps, and outputs them in a formatted table. These are verifiable from the source code and directly align with the function\u2019s semantics. The summary omits some details such as the chipset check (Gen6 or Gen7) and mutex locking, but the claims it does make are accurate, leading to a high proportion of accurate statements.",
                "The summary accurately captures the core purpose: printing GPU, CPU, and ring frequencies in MHz for supported chipsets, iterating over frequency steps, and producing tabular output. This matches the source code's main behavior, including the restriction to supported chipsets and frequency iteration. However, it omits secondary details such as the GEN6/GEN7 check specifics, use of mutex locking to protect hardware access, and pcode read operations to fetch effective frequencies. These omissions reduce coverage of important implementation semantics beyond the core purpose.",
                "The summary correctly states the core purpose: printing GPU, effective CPU, and ring frequencies for supported chipsets in MHz, and that it iterates through frequency steps to produce tabular output. These align with the code's logic of looping through min to max GPU frequency, reading corresponding IA and ring frequencies, and using seq_printf to display them in a table. No inaccurate claims are present, and the description captures the primary purpose and key I/O, but the detail level is moderate rather than deeply specific about formulae or chipset check conditions."
            ]
        },
        "cfg": {
            "summary": "Outputs GPU, CPU, and Ring frequency data for supported chipsets, iterating measurements, and reporting unsupported hardware when validation fails.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function outputs GPU, CPU, and Ring frequency data, iterates to collect measurements, and reports unsupported hardware for certain chipsets, all of which are supported by the source code. It slightly generalizes 'validation fails' instead of explicitly naming the generation check, but this is a minor imprecision; overall, the majority of claims align with the function's behavior.",
                "The summary correctly notes that the function outputs GPU, CPU, and Ring frequencies, iterates through measurements, and reports unsupported chipsets, which aligns with the core purpose of generating a frequency table for supported Gen6/Gen7 hardware. However, it omits secondary details such as the locking mechanism via mutex, reading data using sandybridge_pcode_read, use of specific frequency multipliers, and the exact loop bounds based on min/max delay values. These missing elements reduce completeness despite core coverage.",
                "The summary correctly states that the function outputs GPU, CPU, and Ring frequency data, performs iteration, and reports unsupported hardware for unsupported chipsets. These are accurate and specific to the source code's behavior, with no contradictory statements or irrelevant noise. While the claims are correct, they are fairly concise and lack deeper detail on iteration specifics, computation of frequencies, and locking behavior, so the gain is moderate rather than high."
            ]
        },
        "comment": {
            "summary": "Retrieves and prints GPU, effective CPU, and effective Ring frequencies for Intel Gen6 and Gen7 chipsets, while protecting access with a mutex lock.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function retrieves and prints GPU, effective CPU, and effective Ring frequencies, and that it operates only for Intel Gen6 and Gen7 chipsets. It also accurately notes the use of a mutex lock to protect access. All claims align with the source code's behavior, with no inaccuracies detected, yielding a high proportion of accurate claims.",
                "The summary accurately states that the function retrieves and prints GPU, effective CPU, and effective Ring frequencies, and specifies it applies to Intel Gen6 and Gen7 chipsets with mutex protection, which matches the core purpose and chipset check in the source. However, it omits secondary details such as output formatting, iteration over min to max GPU delay frequencies, invocation of `sandybridge_pcode_read` for fetching CPU/Ring data, and handling of unsupported chipsets with a printed message.",
                "The summary correctly identifies the function's purpose of printing GPU, effective CPU, and effective Ring frequencies and the chipset restriction to Gen6 and Gen7. It also accurately notes the use of a mutex lock to protect access. All claims match the source code with no contradictions or irrelevant noise, and they are specific to the core behavior and key I/O. The gain is moderate to high because the main operational detail is succinctly captured."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4270896,
    "strip_function_name": "sub_412B30",
    "strip_decompiled_code": "int __fastcall sub_412B30(__int64 a1)\n{\n  int result; // eax\n  unsigned int v2; // r8d\n  __int64 v3; // r10\n  __int64 v4; // rbx\n  char v5; // r11\n  char v6; // r9\n  int v7; // eax\n  int v8; // esi\n  int v9; // ecx\n  int v10; // edx\n  FILE *v11; // rdi\n\n  result = dword_7D7484;\n  if ( !dword_7E4F54 && dword_7E4F38 < (unsigned int)dword_7D7484 || !dword_7D7484 )\n    return result;\n  v2 = ++dword_7E4F50;\n  if ( !a1 )\n    goto LABEL_18;\n  v3 = qword_7E4F48;\n  v4 = qword_7E4F40;\n  v5 = 0;\n  v6 = 0;\n  v7 = 10;\n  v8 = 0;\n  v9 = 0;\n  do\n  {\n    v10 = *(_DWORD *)(a1 + 72);\n    if ( v10 != 1 )\n    {\n      if ( v10 == 2 && !v8 )\n      {\n        v3 = *(_QWORD *)(a1 + 80);\n        v5 = 1;\n        v8 = 1;\n      }\nLABEL_9:\n      --v7;\n      a1 = *(_QWORD *)(a1 + 32);\n      if ( !v7 )\n        break;\n      continue;\n    }\n    if ( v9 )\n      goto LABEL_9;\n    --v7;\n    v4 = *(_QWORD *)(a1 + 80);\n    v6 = 1;\n    v9 = 1;\n    a1 = *(_QWORD *)(a1 + 32);\n    if ( !v7 )\n      break;\n  }\n  while ( a1 );\n  if ( v6 )\n    qword_7E4F40 = v4;\n  if ( v5 )\n    qword_7E4F48 = v3;\nLABEL_18:\n  v11 = qword_7E4F68;\n  if ( v2 > 1 )\n  {\n    fputc(12, qword_7E4F68);\n    v2 = dword_7E4F50;\n    v11 = qword_7E4F68;\n  }\n  fprintf(v11, \"%s %s \\t\\t\\tpage %d\\n\", \"GAS LISTING\", (const char *)qword_7E4F58, v2);\n  fprintf(qword_7E4F68, \"%s\\n\", (const char *)qword_7E4F48);\n  result = fprintf(qword_7E4F68, \"%s\\n\", (const char *)qword_7E4F40);\n  dword_7E4F38 = 3;\n  dword_7E4F54 = 0;\n  return result;\n}\n",
    "function_name": "listing_page",
    "decompiled_code": "void __fastcall listing_page(list_info_type *list)\n{\n  __int64 v1; // r8\n  char *edict_arg; // r10\n  char *v3; // rbx\n  char v4; // r11\n  char v5; // r9\n  int v6; // eax\n  int v7; // esi\n  int v8; // ecx\n  edict_enum edict; // edx\n  FILE *v10; // rdi\n\n  if ( !eject && on_page < paper_height || !paper_height )\n    return;\n  v1 = ++page;\n  if ( !list )\n    goto LABEL_18;\n  edict_arg = (char *)title;\n  v3 = (char *)subtitle;\n  v4 = 0;\n  v5 = 0;\n  v6 = 10;\n  v7 = 0;\n  v8 = 0;\n  do\n  {\n    edict = list->edict;\n    if ( edict != edict_enum::EDICT_SBTTL )\n    {\n      if ( edict == edict_enum::EDICT_TITLE && !v7 )\n      {\n        edict_arg = list->edict_arg;\n        v4 = 1;\n        v7 = 1;\n      }\nLABEL_9:\n      --v6;\n      list = list->next;\n      if ( !v6 )\n        break;\n      continue;\n    }\n    if ( v8 )\n      goto LABEL_9;\n    --v6;\n    v3 = list->edict_arg;\n    v5 = 1;\n    v8 = 1;\n    list = list->next;\n    if ( !v6 )\n      break;\n  }\n  while ( list );\n  if ( v5 )\n    subtitle = v3;\n  if ( v4 )\n    title = edict_arg;\nLABEL_18:\n  v10 = list_file;\n  if ( (unsigned int)v1 > 1 )\n  {\n    fputc(12, list_file);\n    v1 = page;\n    v10 = list_file;\n  }\n  fprintf(v10, &byte_4F2711[18], 5187351LL, fn, v1);\n  fprintf(list_file, &byte_4F2711[47], title);\n  fprintf(list_file, &byte_4F2711[47], subtitle);\n  on_page = 3;\n  eject = 0;\n}\n",
    "source_code": "\nstatic void\nlisting_page (list_info_type *list)\n{\n  /* Grope around, see if we can see a title or subtitle edict coming up\n     soon.  (we look down 10 lines of the page and see if it's there)  */\n  if ((eject || (on_page >= (unsigned int) paper_height))\n      && paper_height != 0)\n    {\n      unsigned int c = 10;\n      int had_title = 0;\n      int had_subtitle = 0;\n\n      page++;\n\n      while (c != 0 && list)\n\t{\n\t  if (list->edict == EDICT_SBTTL && !had_subtitle)\n\t    {\n\t      had_subtitle = 1;\n\t      subtitle = list->edict_arg;\n\t    }\n\t  if (list->edict == EDICT_TITLE && !had_title)\n\t    {\n\t      had_title = 1;\n\t      title = list->edict_arg;\n\t    }\n\t  list = list->next;\n\t  c--;\n\t}\n\n      if (page > 1)\n\t{\n\t  fprintf (list_file, \"\\f\");\n\t}\n\n      fprintf (list_file, \"%s %s \\t\\t\\tpage %d\\n\", LISTING_HEADER, fn, page);\n      fprintf (list_file, \"%s\\n\", title);\n      fprintf (list_file, \"%s\\n\", subtitle);\n      on_page = 3;\n      eject = 0;\n    }\n}",
    "comment": "The function checks for titles and subtitles in a list before printing the current page header, title, and subtitle to a file.",
    "hext5_sum": "dump the symbol table.",
    "bint5_sum": "Outputs the source file name and line number for a given line record , while managing buffer states and handling various output conditions .\n",
    "cpbcs_sum": "Identifies the end of the search request in the search structure, returning the first fragment or the best matching physical data.\n",
    "misum_sum": "Displays the usage of a command-line input stream, highlighting the current word, and managing buffer counts for debugging, and writing.\n",
    "decom_sum": "Generates a \u201cGAS LISTING\u201d page header and prints stored listing title and source lines to the output file, updating pagination counters.",
    "cfg_sum": "Generates a formatted \u201cGAS LISTING\u201d page header and associated section content, updating stored pointers and page counters before writing output to a file.",
    "work_score": {
        "decom": {
            "summary": "Generates a \u201cGAS LISTING\u201d page header and prints stored listing title and source lines to the output file, updating pagination counters.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains one claim: it generates a 'GAS LISTING' page header and prints stored listing title and source lines to the output file, updating pagination counters. While the header generation and title printing align partially with the code, the function does not explicitly print source lines\u2014it only prints header, title, and subtitle. This makes part of the claim inaccurate. Given that less than half of the claim is fully accurate to the source code, alignment is low.",
                "The summary claims the function prints source lines, which is inaccurate since the code only prints a header, title, and subtitle, not arbitrary source lines. The core purpose\u2014starting a new listing page by scanning upcoming lines for title/subtitle edicts and formatting the header\u2014is not explicitly covered, and the preprocessing logic that checks conditions before pagination is omitted. While pagination counters are mentioned, the description lacks the key behavior of scanning for specific edicts and writing only relevant header components.",
                "The summary claims the function prints stored listing title and source lines, but the source code shows it only fetches a title and subtitle from the list and prints them along with a page header\u2014no source lines are printed. This is a FATAL inaccuracy affecting the primary purpose. While the header generation and pagination update are accurate, the core output is misrepresented, making the summary unreliable."
            ]
        },
        "cfg": {
            "summary": "Generates a formatted \u201cGAS LISTING\u201d page header and associated section content, updating stored pointers and page counters before writing output to a file.",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function generates a formatted page header and updates stored pointers and page counters before writing output to a file, which matches the code behavior. However, it inaccurately specifies the header as 'GAS LISTING', which is not confirmed in the provided code (the header comes from the LISTING_HEADER variable). Additionally, the summary omits important details such as the conditional logic for detecting title/subtitle and the context of eject/paper_height control, but all included claims are generally accurate about the function's semantics.",
                "The summary correctly states that the function generates a formatted page header and writes it to a file, matching the core purpose of producing a listing page with title and subtitle. However, it omits key specifics from the source code such as scanning up to 10 lines ahead for EDICT_TITLE and EDICT_SBTTL, conditional execution based on `eject` and `on_page` vs `paper_height`, specific initialization of `on_page` and `eject`, and the inclusion of form feed for pages after the first. It also inaccurately describes 'updating stored pointers', which is not present in the code, and fails to acknowledge when titles/subtitles are set or the header content composition using constants and variables.",
                "The summary captures the general action of generating a formatted page header and writing it to a file, which matches the code\u2019s behavior, but it is overly generic and omits key specifics like scanning up to 10 lines for title/subtitle edicts, handling page ejection logic, and resetting state variables. There are no contradictory or FATAL claims, but the low level of detail limits usefulness and the gain is minimal, making this mostly broad, SAFE content."
            ]
        },
        "comment": {
            "summary": "The function checks for titles and subtitles in a list before printing the current page header, title, and subtitle to a file.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function checks for titles and subtitles before printing the page header, title, and subtitle to a file, which matches the source code\u2019s logic of scanning ahead in the list for EDICT_TITLE and EDICT_SBTTL entries and then writing them along with the page header to list_file. Although the summary omits certain control conditions like page increment, eject flag handling, and the 10-line lookahead, it does not contain inaccuracies, so the claims are predominantly accurate but somewhat generic.",
                "The summary correctly describes that the function searches for titles and subtitles and prints them in the page header to a file, matching the core behavior. However, it omits important triggers and conditions such as checking 'eject' or 'on_page' against 'paper_height', the loop over 10 items, updating the page count, and handling form feed for pages beyond the first. These omissions reduce coverage of secondary, behavior-critical details.",
                "The summary correctly captures the core purpose: scanning the list for title/subtitle and then printing them along with a page header to a file. It omits conditional details such as the check for page boundaries and the fact it looks ahead up to 10 lines, but these omissions are not contradictory. There are no inaccurate (FATAL) claims; the statement is accurate but fairly generic, providing limited detail beyond the overall flow. The gain is therefore low due to lack of specifics, but noise is minimal."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1098480,
    "strip_function_name": "gsl_multifit_fdfsolver_test",
    "strip_decompiled_code": "__int64 __fastcall gsl_multifit_fdfsolver_test(_QWORD *a1, _DWORD *a2, double a3, double a4)\n{\n  __int64 result; // rax\n  __int64 *v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // r8\n  double v10; // xmm1_8\n  __int64 v11; // rdi\n  __int64 v12; // rcx\n  double *v13; // rdx\n  __int64 v14; // rsi\n  double *v15; // rcx\n  __int64 v16; // rax\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm0_8\n\n  *a2 = 0;\n  result = gsl_multifit_test_delta(a1[4], a1[2], a3 * a3, a3);\n  if ( (_DWORD)result )\n  {\n    (*(void (__fastcall **)(_QWORD, _QWORD))(*a1 + 40LL))(a1[8], a1[5]);\n    v7 = (__int64 *)a1[2];\n    v8 = a1[5];\n    v9 = *v7;\n    if ( *v7 )\n    {\n      v10 = 0.0;\n      v11 = 8 * v7[1];\n      v12 = *(_QWORD *)(v8 + 8);\n      v13 = *(double **)(v8 + 16);\n      v14 = 8 * v12;\n      v15 = (double *)v7[2];\n      v16 = 0LL;\n      do\n      {\n        v17 = *v15;\n        ++v16;\n        v15 = (double *)((char *)v15 + v11);\n        v18 = fmax(v17, 1.0) * *v13;\n        v13 = (double *)((char *)v13 + v14);\n        v10 = fmax(fabs(v18), v10);\n      }\n      while ( v9 != v16 );\n    }\n    else\n    {\n      v10 = 0.0;\n    }\n    v19 = gsl_blas_dnrm2(a1[3]);\n    v20 = v19 * (0.5 * v19);\n    if ( v20 > 1.0 )\n      a4 = v20 * a4;\n    if ( a4 < v10 )\n    {\n      return 4294967294LL;\n    }\n    else\n    {\n      *a2 = 2;\n      return 0LL;\n    }\n  }\n  else\n  {\n    *a2 = 1;\n  }\n  return result;\n}\n",
    "function_name": "gsl_multifit_fdfsolver_test",
    "decompiled_code": "__int64 __fastcall gsl_multifit_fdfsolver_test(\n        const gsl_multifit_fdfsolver *s,\n        double xtol,\n        double gtol,\n        const double ftol,\n        int *info)\n{\n  __int64 result; // rax\n  gsl_vector *g; // rsi\n  double *data; // rcx\n  gsl_vector *x; // rax\n  gsl_vector *v11; // rdx\n  size_t size; // r8\n  double v13; // xmm1_8\n  __int64 v14; // rdi\n  size_t stride; // rcx\n  __int64 v16; // rax\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm0_8\n\n  *info = 0;\n  result = ((__int64 (__fastcall *)(gsl_vector *, gsl_vector *, double, double))gsl_multifit_test_delta)(\n             s->dx,\n             s->x,\n             xtol * xtol,\n             xtol);\n  if ( (_DWORD)result )\n  {\n    g = s->g;\n    s->type->gradient(s->state, g);\n    x = s->x;\n    v11 = s->g;\n    size = x->size;\n    if ( x->size )\n    {\n      v13 = 0.0;\n      v14 = 8 * x->stride;\n      stride = v11->stride;\n      v11 = (gsl_vector *)v11->data;\n      g = (gsl_vector *)(8 * stride);\n      data = x->data;\n      v16 = 0LL;\n      do\n      {\n        v17 = *data;\n        ++v16;\n        data = (double *)((char *)data + v14);\n        v18 = fmax(v17, 1.0) * *(double *)&v11->size;\n        v11 = (gsl_vector *)((char *)v11 + (_QWORD)g);\n        v13 = fmax(fabs(v18), v13);\n      }\n      while ( size != v16 );\n    }\n    else\n    {\n      v13 = 0.0;\n    }\n    v19 = ((double (__fastcall *)(gsl_vector *, gsl_vector *, gsl_vector *, double *))gsl_blas_dnrm2)(\n            s->f,\n            g,\n            v11,\n            data);\n    v20 = v19 * (0.5 * v19);\n    if ( v20 > 1.0 )\n      gtol = v20 * gtol;\n    if ( gtol < v13 )\n    {\n      return 4294967294LL;\n    }\n    else\n    {\n      *info = 2;\n      return 0LL;\n    }\n  }\n  else\n  {\n    *info = 1;\n  }\n  return result;\n}\n",
    "source_code": "\nint\ngsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * s,\n                             const double xtol, const double gtol,\n                             const double ftol, int *info)\n{\n  int status;\n  double gnorm, fnorm, phi;\n\n  *info = 0;\n\n  status = gsl_multifit_test_delta(s->dx, s->x, xtol*xtol, xtol);\n  if (status == GSL_SUCCESS)\n    {\n      *info = 1;\n      return GSL_SUCCESS;\n    }\n\n  /* compute gradient g = J^T f */\n  (s->type->gradient) (s->state, s->g);\n\n  /* compute gnorm = max_i( g_i * max(x_i, 1) ) */\n  gnorm = scaled_infnorm(s->x, s->g);\n\n  /* compute fnorm = ||f|| */\n  fnorm = gsl_blas_dnrm2(s->f);\n  phi = 0.5 * fnorm * fnorm;\n\n  if (gnorm <= gtol * GSL_MAX(phi, 1.0))\n    {\n      *info = 2;\n      return GSL_SUCCESS;\n    }\n\n#if 0\n  if (dfnorm <= ftol * GSL_MAX(fnorm, 1.0))\n    {\n      *info = 3;\n      return GSL_SUCCESS;\n    }\n#endif\n\n  return GSL_CONTINUE;\n}",
    "comment": "Evaluates the convergence of a multifit solver by checking parameter changes, gradient norms, and function norms against specified tolerances.",
    "hext5_sum": "gsl_multifit_linear_l() compute discrete approximation to derivative operator of order k on a regular grid of p points, ie: l is (p-k)-by-p",
    "bint5_sum": "Evaluates convergence criteria for a fitting algorithm based on gradient and function norms , returning status codes for success or continuation .\n",
    "cpbcs_sum": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
    "misum_sum": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
    "decom_sum": "Tests GSL multifit solver convergence using delta and residual norms, updates status, and returns result codes based on tolerance thresholds.",
    "cfg_sum": "Checks solver convergence using GSL routines, adjusts tolerance, and returns a status code indicating success, continuation, or failure.",
    "work_score": {
        "decom": {
            "summary": "Tests GSL multifit solver convergence using delta and residual norms, updates status, and returns result codes based on tolerance thresholds.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately conveys the core function behavior: it tests convergence using delta and residual norms, applies tolerance thresholds, and updates status with corresponding return codes. These claims match the source code\u2019s use of gsl_multifit_test_delta, gradient norms, and tolerance comparisons, with no contradictory or irrelevant details. While concise, the description covers all key semantics, indicating a high proportion of accurate claims.",
                "The summary correctly identifies that the function tests convergence of a GSL multifit solver using delta and residual norms, updates the status via the info pointer, and returns codes based on tolerance checks. This covers the core purpose of detecting convergence criteria derived from the code. However, it omits secondary details such as the calculation of the gradient and scaled infinity norm, the computation of phi from fnorm, and the specific branching conditions when gnorm meets scaled gtol thresholds. These omissions leave secondary behavior coverage incomplete.",
                "The summary correctly states that the function tests solver convergence using delta and residual norms, updates an info/status indicator, and returns codes based on tolerance thresholds. All claims align with the source code and describe the core behavior without contradictions. However, the description is broad and omits specific implementation details such as gradient computation, gnorm scaling, and specific tolerance logic for each return path, resulting in low informational gain despite being accurate."
            ]
        },
        "cfg": {
            "summary": "Checks solver convergence using GSL routines, adjusts tolerance, and returns a status code indicating success, continuation, or failure.",
            "score": [
                0.6,
                0.4,
                0.2
            ],
            "reason": [
                "The summary contains a partially accurate description: it correctly notes that the function checks solver convergence and returns a status code, aligning with the code\u2019s use of GSL routines to test conditions and set `info`. However, it inaccurately claims the function adjusts tolerance, which is not present in the source\u2014it only uses provided tolerance values for checks without modifying them. The summary also omits important specifics about multiple convergence criteria and does not differentiate the possible return values tied to specific convergence cases, leading to less than full accuracy.",
                "The summary correctly identifies that the function checks solver convergence and returns a status code, which covers the core purpose. However, it is vague about the specific checks performed \u2013 it omits details such as using gsl_multifit_test_delta, computing gradient and norms, and setting the info flag based on multiple tolerance criteria. It also introduces 'adjusts tolerance', which is not a specific action in the code, making this partially inaccurate. Secondary coverage of key semantics like gradient calculation, scaling, and branching logic is lacking.",
                "The summary correctly notes that the function checks solver convergence and returns a status code, which matches the core purpose of the source. However, it inaccurately states that the function adjusts tolerance and can indicate failure, whereas the code does not modify tolerance values and only returns success or continuation (no failure branch). These inaccuracies target core I/O semantics, making them FATAL errors on primary purpose details and reducing trustworthiness despite partial accuracy."
            ]
        },
        "comment": {
            "summary": "Evaluates the convergence of a multifit solver by checking parameter changes, gradient norms, and function norms against specified tolerances.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly reflects the function\u2019s behavior of testing convergence by evaluating changes in parameters (via delta check), gradient norms, and function norms against given tolerances. These elements directly correspond to the checks in the source code (xtol, gtol, ftol) and are highly specific and accurate. No claims contradict the implementation, and all are relevant to the code\u2019s semantics, resulting in a very high proportion of accurate claims.",
                "The summary accurately describes the core purpose of the function as evaluating convergence for a multifit solver based on changes in parameters, gradient norms, and function norms against tolerances, which matches the code's checks using xtol, gtol, and ftol. However, it omits secondary details such as setting the *info flag to specific values, the computation of phi, and the specific comparison formulas used (scaled infinity norm, GSL_MAX), as well as the conditional return statuses (GSL_SUCCESS vs GSL_CONTINUE). These omissions limit completeness despite correctly covering the primary purpose.",
                "The summary accurately states the core purpose: assessing convergence based on changes in parameters, gradient norms, and function norms against tolerances. All elements are correctly grounded in the source code's logic without introducing contradictory or irrelevant claims. However, while factually correct, the description is somewhat generic and lacks specific implementation details (e.g., scaled infinity norm computation, phi calculation) that would offer higher informational value."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 177248,
    "strip_function_name": "sub_2B460",
    "strip_decompiled_code": "__m128i *__fastcall sub_2B460(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __int128 a7,\n        __int64 a8)\n{\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __m128i *v12; // rbx\n  void *v13; // rdi\n  unsigned int v14; // ecx\n  __m128i v15; // xmm0\n  __int64 v16; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n\n  if ( (_QWORD)a7 )\n  {\n    if ( !*((_QWORD *)&a7 + 1) )\n      return 0LL;\n  }\n  else\n  {\n    if ( *((_QWORD *)&a7 + 1) )\n      return 0LL;\n    a8 = 0LL;\n    *(_QWORD *)&a7 = sub_F2A0;\n    *((_QWORD *)&a7 + 1) = sub_F2B0;\n  }\n  v8 = sub_F2C0(200LL, a2, a3, a4, a5, a6, (__int64 (__fastcall *)(__int64, __int64))a7, SDWORD2(a7), a8);\n  v12 = (__m128i *)v8;\n  if ( v8 )\n  {\n    *(_QWORD *)v8 = 0LL;\n    *(_QWORD *)(v8 + 168) = 0LL;\n    v13 = (void *)((v8 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n    v14 = (unsigned int)(v8 - (_DWORD)v13 + 176) >> 3;\n    memset(v13, 0, 8LL * v14);\n    v15 = _mm_loadu_si128((const __m128i *)&a7);\n    *(_QWORD *)(v8 + 192) = a8;\n    *(__m128i *)(v8 + 176) = v15;\n    v16 = sub_28F50(\n            (__int64)v13 + 8 * v14,\n            a2,\n            v9,\n            0LL,\n            v10,\n            v11,\n            (__int64 (__fastcall *)(__int64, __int64))a7,\n            *((void (__fastcall **)(__int64, void *))&a7 + 1),\n            a8);\n    v12->m128i_i64[0] = v16;\n    if ( v16 )\n      return v12;\n    sub_2B3B0(v12, a2, v17, v18, v19, v20);\n  }\n  return 0LL;\n}\n",
    "function_name": "ZSTD_createCStream_advanced",
    "decompiled_code": "__m128i *__fastcall ZSTD_createCStream_advanced(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __int128 a7,\n        __int64 a8)\n{\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __m128i *v12; // rbx\n  void *v13; // rdi\n  unsigned int v14; // ecx\n  __m128i v15; // xmm0\n  __int64 CCtx_advanced; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n\n  if ( (_QWORD)a7 )\n  {\n    if ( !*((_QWORD *)&a7 + 1) )\n      return 0LL;\n  }\n  else\n  {\n    if ( *((_QWORD *)&a7 + 1) )\n      return 0LL;\n    a8 = 0LL;\n    *(_QWORD *)&a7 = ZSTD_defaultAllocFunction;\n    *((_QWORD *)&a7 + 1) = ZSTD_defaultFreeFunction;\n  }\n  v8 = ZSTD_malloc(200LL, a2, a3, a4, a5, a6, (__int64 (__fastcall *)(__int64, __int64))a7, SDWORD2(a7), a8);\n  v12 = (__m128i *)v8;\n  if ( v8 )\n  {\n    *(_QWORD *)v8 = 0LL;\n    *(_QWORD *)(v8 + 168) = 0LL;\n    v13 = (void *)((v8 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n    v14 = (unsigned int)(v8 - (_DWORD)v13 + 176) >> 3;\n    memset(v13, 0, 8LL * v14);\n    v15 = _mm_loadu_si128((const __m128i *)&a7);\n    *(_QWORD *)(v8 + 192) = a8;\n    *(__m128i *)(v8 + 176) = v15;\n    CCtx_advanced = ZSTD_createCCtx_advanced(\n                      (__int64)v13 + 8 * v14,\n                      a2,\n                      v9,\n                      0LL,\n                      v10,\n                      v11,\n                      (__int64 (__fastcall *)(__int64, __int64))a7,\n                      *((void (__fastcall **)(__int64, void *))&a7 + 1),\n                      a8);\n    v12->m128i_i64[0] = CCtx_advanced;\n    if ( CCtx_advanced )\n      return v12;\n    ZSTD_freeCStream(v12, a2, v17, v18, v19, v20);\n  }\n  return 0LL;\n}\n",
    "source_code": "\nZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem)\n{\n    ZSTD_CStream* zcs;\n\n    if (!customMem.customAlloc && !customMem.customFree) customMem = defaultCustomMem;\n    if (!customMem.customAlloc || !customMem.customFree) return NULL;\n\n    zcs = (ZSTD_CStream*)ZSTD_malloc(sizeof(ZSTD_CStream), customMem);\n    if (zcs==NULL) return NULL;\n    memset(zcs, 0, sizeof(ZSTD_CStream));\n    memcpy(&zcs->customMem, &customMem, sizeof(ZSTD_customMem));\n    zcs->cctx = ZSTD_createCCtx_advanced(customMem);\n    if (zcs->cctx == NULL) { ZSTD_freeCStream(zcs); return NULL; }\n    return zcs;\n}",
    "comment": "Creates and initializes a ZSTD_CStream object with custom memory allocation, returning NULL on failure or invalid parameters.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Creates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup .\n",
    "cpbcs_sum": "Creates and initializes a decompression context with custom memory management for advanced decompression context setup.\n",
    "misum_sum": "Allocates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup.\n",
    "decom_sum": "Allocates and initializes a 200-byte structure with callback functions and context, then creates an associated resource, cleaning up on failure.",
    "cfg_sum": "Allocates and initializes a 200-byte structured object with provided callbacks and parameters, invoking setup logic or cleanup if initialization fails.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a 200-byte structure with callback functions and context, then creates an associated resource, cleaning up on failure.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains inaccurate details: it specifies a fixed '200-byte' size which is not indicated in the source, making that claim incorrect. It correctly notes allocation, initialization with callback functions, creation of an associated resource, and cleanup on failure, which align with the code's behavior. However, the incorrect size detail reduces accuracy, resulting in mixed reliability overall.",
                "The summary misstates the core behavior by claiming a fixed 200-byte allocation, which is not in the source code, and fails to identify the actual primary purpose of creating and initializing a ZSTD_CStream with custom memory functions and an associated compression context. While it mentions initialization and cleanup on failure, the domain-specific operation and correct allocation details are missing or inaccurate.",
                "The summary makes an inaccurate, highly specific claim about allocating a 200-byte structure, which contradicts the source code since the size is determined by sizeof(ZSTD_CStream) and not fixed at 200 bytes. This is a FATAL error targeting core behavior (allocation details). While it correctly mentions initialization, callbacks, context creation, and cleanup on failure, the severe mismatch on structure size significantly undermines trust in the summary."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes a 200-byte structured object with provided callbacks and parameters, invoking setup logic or cleanup if initialization fails.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly specifies a fixed 200-byte size, which is not in the source code. It accurately notes allocation, initialization with provided callbacks, and cleanup on failure, but omits key details such as the memory size being determined by sizeof(ZSTD_CStream) and the handling of defaultCustomMem when callbacks are missing. The fixed size error makes one of the main claims inaccurate, resulting in mixed reliability.",
                "The summary is inaccurate because it specifies a fixed size of 200 bytes, which contradicts the source code\u2019s use of sizeof(ZSTD_CStream). It also omits the core primary purpose: creating and initializing a ZSTD_CStream object using provided custom memory functions, falling back to defaults if missing, and handling allocation/initialization errors. While it mentions allocation, initialization, and cleanup, it fails to identify the domain-specific nature of the object (ZSTD_CStream) and provides incorrect details, so the core is not covered.",
                "The summary incorrectly specifies the allocation size as 200 bytes, whereas the code allocates based on sizeof(ZSTD_CStream), which is not stated in the source. This is a FATAL error affecting a core detail of the function\u2019s primary behavior. While it correctly mentions initialization and cleanup on failure, the inaccurate size claim directly contradicts the source and undermines trust in the output. The remaining points are generic, providing limited additional insight."
            ]
        },
        "comment": {
            "summary": "Creates and initializes a ZSTD_CStream object with custom memory allocation, returning NULL on failure or invalid parameters.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function creates and initializes a ZSTD_CStream object using custom memory allocation and returns NULL on failure or invalid parameters. These details align with the source code, which handles default and custom allocators, performs initialization, and returns NULL if allocation fails or parameters are incomplete. No inaccurate claims are present, and the description is both specific and semantically accurate to the code behavior.",
                "The summary correctly captures the core purpose of creating and initializing a ZSTD_CStream with custom memory allocation, and mentions returning NULL on failure or invalid parameters, aligning with the code's NULL checks on improper customMem fields and allocation failures. However, it omits secondary details such as falling back to defaultCustomMem when both customAlloc and customFree are missing, zero-initializing the struct, copying the custom memory configuration, creating the compression context, and freeing the stream when cctx creation fails. This results in partial but not complete coverage of critical behaviors.",
                "The summary accurately states the core purpose of the function: creating and initializing a ZSTD_CStream with custom memory allocation and returning NULL on failure or invalid parameters. These are GOLD-level details directly reflected in the source code, with no inaccuracies or irrelevant noise. However, it omits secondary specifics such as the fallback to defaultCustomMem when both alloc and free are missing, and the internal allocation and cleanup steps, which slightly limits gain but noise is negligible."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 398289,
    "strip_function_name": "sub_613D1",
    "strip_decompiled_code": "__int64 __fastcall sub_613D1(int *a1, int a2, __int64 a3)\n{\n  unsigned __int8 *v4; // rax\n  __int64 v5; // rax\n  unsigned __int8 v7; // [rsp+1Fh] [rbp-39h]\n  unsigned __int64 i; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v9; // [rsp+28h] [rbp-30h]\n  unsigned __int8 *v10; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v11; // [rsp+40h] [rbp-18h]\n  __int64 v12; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v13; // [rsp+50h] [rbp-8h]\n\n  if ( !a2 )\n  {\n    *a1 = 0;\n    return 0LL;\n  }\n  if ( a2 == 1 )\n    return 0LL;\n  v10 = *(unsigned __int8 **)a3;\n  v11 = *(_QWORD *)(a3 + 8);\n  v12 = *(_QWORD *)(a3 + 16);\n  v13 = *(_QWORD *)(a3 + 24);\n  v9 = 0LL;\n  for ( i = 0LL; *a1 != 6 && i < v11 && v9 < v13; ++i )\n  {\n    v4 = v10++;\n    v7 = *v4;\n    if ( *v4 == 13 )\n    {\n      if ( v11 == i + 1 )\n        break;\n      *a1 = sub_61307(*a1, 13);\n      if ( *v10 != 10 )\n        goto LABEL_17;\n    }\n    else\n    {\n      if ( v7 != 46 || *a1 && *a1 != 3 )\n      {\n        *a1 = sub_61307(*a1, v7);\nLABEL_17:\n        v5 = v9++;\n        *(_BYTE *)(v5 + v12) = v7;\n        continue;\n      }\n      if ( v11 == i + 2 )\n        break;\n      *a1 = sub_61307(*a1, 46);\n      if ( *v10 == 13 )\n        goto LABEL_17;\n    }\n  }\n  if ( *a1 == 6 )\n  {\n    v9 -= 2LL;\n    *(_DWORD *)(a3 + 36) = 1;\n  }\n  *(_QWORD *)(a3 + 8) = i;\n  *(_QWORD *)(a3 + 24) = v9;\n  return 0LL;\n}\n",
    "function_name": "_crlfdot_decoder",
    "decompiled_code": "mu_filter_result __cdecl crlfdot_decoder(void *xd, mu_filter_command cmd, mu_filter_io *iobuf)\n{\n  unsigned __int8 *v4; // rax\n  size_t v5; // rax\n  unsigned __int8 c; // [rsp+1Fh] [rbp-39h]\n  size_t i; // [rsp+20h] [rbp-38h]\n  size_t j; // [rsp+28h] [rbp-30h]\n  const unsigned __int8 *iptr; // [rsp+30h] [rbp-28h]\n  size_t isize; // [rsp+40h] [rbp-18h]\n  char *optr; // [rsp+48h] [rbp-10h]\n  size_t osize; // [rsp+50h] [rbp-8h]\n\n  if ( cmd == mu_filter_command::mu_filter_init )\n  {\n    *(_DWORD *)xd = 0;\n    return 0;\n  }\n  if ( cmd == mu_filter_command::mu_filter_done )\n    return 0;\n  iptr = (const unsigned __int8 *)iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n  j = 0LL;\n  for ( i = 0LL; *(_DWORD *)xd != 6 && i < isize && j < osize; ++i )\n  {\n    v4 = (unsigned __int8 *)iptr++;\n    c = *v4;\n    if ( *v4 == 13 )\n    {\n      if ( isize == i + 1 )\n        break;\n      *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, 13);\n      if ( *iptr != 10 )\n        goto LABEL_17;\n    }\n    else\n    {\n      if ( c != 46 || *(_DWORD *)xd && *(_DWORD *)xd != 3 )\n      {\n        *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, c);\nLABEL_17:\n        v5 = j++;\n        optr[v5] = c;\n        continue;\n      }\n      if ( isize == i + 2 )\n        break;\n      *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, 46);\n      if ( *iptr == 13 )\n        goto LABEL_17;\n    }\n  }\n  if ( *(_DWORD *)xd == 6 )\n  {\n    j -= 2LL;\n    iobuf->eof = 1;\n  }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return 0;\n}\n",
    "source_code": "static enum mu_filter_result\n_crlfdot_decoder (void *xd,\n\t\t  enum mu_filter_command cmd,\n\t\t  struct mu_filter_io *iobuf)\n{\n  int *pstate = xd;\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n\n  switch (cmd)\n    {\n    case mu_filter_init:\n      *pstate = crlfdot_decode_init;\n      return mu_filter_ok;\n      \n    case mu_filter_done:\n      return mu_filter_ok;\n      \n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; *pstate != crlfdot_decode_end && i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n\n      if (c == '\\r')\n\t{\n\t  if (i + 1 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr == '\\n')\n\t    continue;\n\t}\n      else if (c == '.' &&\n\t       (*pstate == crlfdot_decode_init ||\n\t\t*pstate == crlfdot_decode_crlf))\n\t{\n\t  /* Make sure we have two more characters in the buffer */\n\t  if (i + 2 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr != '\\r')\n\t    continue;\n\t}\n      else\n\t*pstate = new_decode_state (*pstate, c);\n      optr[j++] = c;\n    }\n  \n  if (*pstate == crlfdot_decode_end)\n    {\n      j -= 2; /* remove the trailing .\\n */\n      iobuf->eof = 1;\n    }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "comment": "Decodes input data by processing CRLF sequences and dots, modifying the state and output buffer accordingly, until reaching the end condition.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes input bytes with specific state transitions , filtering out dots at the beginning of lines and marking end of data with EOF .\n",
    "cpbcs_sum": "Processes input data by mapping key-value pairs to output lines, managing state transitions, and handling errors appropriately.\n",
    "misum_sum": "Processes input data through a filter, transferring valid characters to output until reaching the end-of-file condition or exceeding buffer limits.\n",
    "decom_sum": "Parses input buffer into an output buffer while updating a parsing state machine and handling special cases for carriage return, line feed, and periods.",
    "cfg_sum": "Parses an input byte stream, updating state and buffering data while handling carriage return and period characters, and marking completion on specific state conditions.",
    "work_score": {
        "decom": {
            "summary": "Parses input buffer into an output buffer while updating a parsing state machine and handling special cases for carriage return, line feed, and periods.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly identifies that the function processes an input buffer into an output buffer, maintains a parsing state machine, and handles special cases involving carriage return, line feed, and periods\u2014matching the source code's handling of '\\r', '\\n', and '.' plus state transitions. All claims are accurate and aligned with the code semantics, with no irrelevant or contradictory content.",
                "The summary correctly notes parsing from input to output and updating a parsing state machine, as well as handling special cases for carriage return, line feed, and periods, which aligns with the code's core purpose of CRLF-dot sequence decoding. However, it does not mention important secondary behaviors such as initialization and completion commands, state transitions for specific sequences, breaking on partial matches, trimming the trailing '.\\n' at end state, setting EOF, and updating buffer sizes, so coverage of secondary details is limited.",
                "The summary correctly identifies that the function processes an input buffer into an output buffer while managing a parsing state machine and has special handling for carriage returns, line feeds, and periods. These are accurate GOLD claims aligned with the source code's core behavior. There are no inaccurate or noisy statements, but the description is broad and lacks detail on conditions and state transitions, resulting in only moderate informativeness."
            ]
        },
        "cfg": {
            "summary": "Parses an input byte stream, updating state and buffering data while handling carriage return and period characters, and marking completion on specific state conditions.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function processes an input byte stream, updates a decoding state, handles carriage return ('\\r') and period ('.') characters specially, and signals completion when a certain state is reached. These details align with the source code's loop logic and state handling, with no contradictory or irrelevant claims present. The description is concise and accurately reflects the function's core behavior.",
                "The summary accurately describes that the function parses an input byte stream, updates a state variable, buffers data, and treats carriage return and period characters specially, as well as marking completion when certain state conditions are met. This matches the core purpose of decoding CRLF-dot sequences and tracking completion. However, it omits several secondary details from the source code, such as initialization and cleanup commands handling, conditions that cause loop breaks when input buffer is insufficient, removal of trailing '.\\n' upon completion, and updating the iobuf structure fields like isize, osize, and eof signalling. These omissions reduce completeness of coverage.",
                "The summary correctly describes the core behavior of the function: processing an input byte stream, updating a decode state, buffering output, and handling carriage return and period characters, with completion marked when a specific state is reached. These are accurate GOLD claims aligned with the source code. There is no contradictory or irrelevant information (no FATAL or NOISE), but the description is moderately specific rather than exhaustively detailed\u2014key intricacies like skipping certain characters or removing the trailing '.\\n' are omitted, limiting gain."
            ]
        },
        "comment": {
            "summary": "Decodes input data by processing CRLF sequences and dots, modifying the state and output buffer accordingly, until reaching the end condition.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function decodes input by processing CRLF sequences and dots, updates the state and output buffer, and stops on an end condition. These are all behaviors explicitly reflected in the source code, with no contradictory or irrelevant claims, making the description highly precise and aligned with the function's semantics.",
                "The summary correctly identifies that the function decodes input data by handling CRLF sequences and dots with state changes, which matches the core purpose of processing dot-stuffed CRLF terminated data streams. However, it omits key secondary details such as the initialization and done command handling, break conditions when nearing buffer limits, removal of the trailing '.\\n' sequence, setting the EOF flag, and updating input/output sizes. Coverage of core is solid, but secondary aspects are sparse.",
                "The summary correctly captures the core purpose of the function, which is to decode input by handling CRLF sequences and dots, updating state and the output buffer until an end condition is met. It aligns with the source code\u2019s loop logic and state transitions, without contradicting any key I/O or side effects. However, the summary is quite generic and omits important specifics, such as the removal of the trailing '.\\n' and setting the EOF flag, making its informational value modest and limiting the gain."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4777712,
    "strip_function_name": "sub_48E6F0",
    "strip_decompiled_code": "__int64 __fastcall sub_48E6F0(const char *a1, __int64 a2, _DWORD *a3)\n{\n  void *v4; // rax\n  unsigned int (__fastcall *v5)(int *); // rax\n  __int64 result; // rax\n  __off_t v7; // rbx\n  int v8; // [rsp+Ch] [rbp-8Ch] BYREF\n  _BYTE v9[8]; // [rsp+10h] [rbp-88h] BYREF\n  int fd; // [rsp+18h] [rbp-80h]\n  __int64 v11; // [rsp+30h] [rbp-68h]\n  int v12; // [rsp+40h] [rbp-58h] BYREF\n  __int64 (*v13)(__int64, const char *, ...); // [rsp+48h] [rbp-50h]\n  int v14; // [rsp+50h] [rbp-48h]\n  __int64 (__fastcall *v15)(__int64); // [rsp+58h] [rbp-40h]\n  int v16; // [rsp+60h] [rbp-38h]\n  __int64 (__fastcall *v17)(__int64, int, __int64); // [rsp+68h] [rbp-30h]\n  int v18; // [rsp+70h] [rbp-28h]\n  int v19; // [rsp+78h] [rbp-20h]\n\n  *a3 = 0;\n  v4 = dlopen(a1, 2);\n  if ( !v4 )\n  {\n    dlerror();\n    sub_40CAD0((char *)\"%s\\n\");\n    return 0LL;\n  }\n  v5 = (unsigned int (__fastcall *)(int *))dlsym(v4, \"onload\");\n  if ( v5 )\n  {\n    v12 = 11;\n    v13 = sub_48E3E0;\n    v14 = 5;\n    v15 = sub_48E210;\n    v16 = 8;\n    v17 = sub_48E3A0;\n    v18 = 0;\n    v19 = 0;\n    if ( !v5(&v12) )\n    {\n      *a3 = 1;\n      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x20;\n      if ( qword_714B10 )\n      {\n        v8 = 0;\n        result = sub_48E600((_QWORD *)a2, (__int64)v9);\n        if ( !(_DWORD)result )\n          return result;\n        v11 = a2;\n        v7 = lseek(fd, 0LL, 1);\n        qword_714B10(v9, &v8);\n        lseek(fd, v7, 0);\n        if ( v8 )\n        {\n          *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x10;\n          return 1LL;\n        }\n      }\n    }\n  }\n  return 0LL;\n}\n",
    "function_name": "try_load_plugin",
    "decompiled_code": "__int64 __fastcall try_load_plugin(const char *pname, __int64 a2, bfd *a3)\n{\n  void *v4; // rax\n  unsigned int (__fastcall *v5)(ld_plugin_tv *); // rax\n  __int64 result; // rax\n  __off_t v7; // rbx\n  char *v8; // rax\n  int v9; // [rsp+Ch] [rbp-8Ch] BYREF\n  ld_plugin_input_file v10; // [rsp+10h] [rbp-88h] BYREF\n  ld_plugin_tv tv[4]; // [rsp+40h] [rbp-58h] BYREF\n\n  LODWORD(a3->filename) = 0;\n  v4 = dlopen(pname, 2);\n  if ( !v4 )\n  {\n    v8 = dlerror();\n    bfd_error_handler(\"%s\\n\", v8);\n    return 0LL;\n  }\n  v5 = (unsigned int (__fastcall *)(ld_plugin_tv *))dlsym(v4, &byte_4D3430[22]);\n  if ( v5 )\n  {\n    tv[0].tv_tag = ld_plugin_tag::LDPT_MESSAGE;\n    tv[0].tv_u.tv_string = (const char *)message;\n    tv[1].tv_tag = ld_plugin_tag::LDPT_REGISTER_CLAIM_FILE_HOOK;\n    tv[1].tv_u.tv_string = (const char *)register_claim_file;\n    tv[2].tv_tag = ld_plugin_tag::LDPT_ADD_SYMBOLS;\n    tv[2].tv_u.tv_string = (const char *)add_symbols;\n    tv[3].tv_tag = ld_plugin_tag::LDPT_NULL;\n    tv[3].tv_u.tv_val = 0;\n    if ( !v5(tv) )\n    {\n      LODWORD(a3->filename) = 1;\n      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x20;\n      if ( claim_file )\n      {\n        v9 = 0;\n        result = bfd_plugin_open_input((_QWORD *)a2, (__int64)&v10);\n        if ( !(_DWORD)result )\n          return result;\n        v10.handle = (void *)a2;\n        v7 = lseek(v10.fd, 0LL, 1);\n        claim_file(&v10, &v9);\n        lseek(v10.fd, v7, 0);\n        if ( v9 )\n        {\n          *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x10;\n          return 1LL;\n        }\n      }\n    }\n  }\n  return 0LL;\n}\n",
    "source_code": "\nstatic int\ntry_load_plugin (const char *pname, bfd *abfd, int *has_plugin_p)\n{\n  void *plugin_handle;\n  struct ld_plugin_tv tv[4];\n  int i;\n  ld_plugin_onload onload;\n  enum ld_plugin_status status;\n\n  *has_plugin_p = 0;\n\n  plugin_handle = dlopen (pname, RTLD_NOW);\n  if (!plugin_handle)\n    {\n      _bfd_error_handler (\"%s\\n\", dlerror ());\n      return 0;\n    }\n\n  onload = dlsym (plugin_handle, \"onload\");\n  if (!onload)\n    goto err;\n\n  i = 0;\n  tv[i].tv_tag = LDPT_MESSAGE;\n  tv[i].tv_u.tv_message = message;\n\n  ++i;\n  tv[i].tv_tag = LDPT_REGISTER_CLAIM_FILE_HOOK;\n  tv[i].tv_u.tv_register_claim_file = register_claim_file;\n\n  ++i;\n  tv[i].tv_tag = LDPT_ADD_SYMBOLS;\n  tv[i].tv_u.tv_add_symbols = add_symbols;\n\n  ++i;\n  tv[i].tv_tag = LDPT_NULL;\n  tv[i].tv_u.tv_val = 0;\n\n  status = (*onload)(tv);\n\n  if (status != LDPS_OK)\n    goto err;\n\n  *has_plugin_p = 1;\n\n  abfd->plugin_format = bfd_plugin_no;\n\n  if (!claim_file)\n    goto err;\n\n  if (!try_claim (abfd))\n    goto err;\n\n  abfd->plugin_format = bfd_plugin_yes;\n\n  return 1;\n\n err:\n  return 0;\n}",
    "comment": "Loads a plugin from a specified path, initializes it, and claims a file if successful, returning the status of the operation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Determines if a given file is a regular file and retrieves its status using the ` is_file ` function .\n",
    "cpbcs_sum": "Creates a Joliet file or deletes an ISO image, populating metadata and file information based on specified options and options.\n",
    "misum_sum": "Lists available data from a file in user-defined format and optionally adds the information to the specified file descriptor.\n",
    "decom_sum": "Loads a shared library, calls its \"onload\" function with predefined callbacks, and updates status flags based on returned results and file operations.",
    "cfg_sum": "Loads a shared library, calls its \"onload\" function, updates status flags, and performs optional file descriptor operations on successful initialization.",
    "work_score": {
        "decom": {
            "summary": "Loads a shared library, calls its \"onload\" function with predefined callbacks, and updates status flags based on returned results and file operations.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function loads a shared library using dlopen, calls its \"onload\" function with a set of callbacks, and changes internal status variables based on the onload function's return value and subsequent file handling operations. These details align well with the source code without containing incorrect or irrelevant information, making the claims both specific and accurate.",
                "The summary correctly identifies the loading of a shared library, invoking its 'onload' function with specific callbacks, and updating status based on results, which matches the core purpose of attempting to load and initialize a plugin via dlopen/dlsym and a tv-table of callbacks. However, it omits key details from the source, such as the error handling paths, verification of 'claim_file', invocation of 'try_claim', and the specific handling of 'plugin_format' and 'has_plugin_p'. Coverage of secondary, behavior-critical semantics is limited.",
                "The summary accurately captures the core behavior: loading a shared library, invoking its 'onload' function with predefined callbacks, and updating status flags according to results and file operations. All major steps in the source are represented without contradictions or irrelevant noise. The claims are generic but correct, with no FATAL inaccuracies and minimal noise, though the level of detail is limited and lacks finer points such as specific conditions for success or error handling."
            ]
        },
        "cfg": {
            "summary": "Loads a shared library, calls its \"onload\" function, updates status flags, and performs optional file descriptor operations on successful initialization.",
            "score": [
                0.8,
                0.5,
                0.4
            ],
            "reason": [
                "The summary correctly states that a shared library is loaded and its 'onload' function is called, which aligns with the dlopen and dlsym usage in the code. It also notes updating status flags, which is accurate given the function sets has_plugin_p and plugin_format. However, the claim about 'optional file descriptor operations' is inaccurate, as the code does not operate on file descriptors but instead invokes plugin hooks and tries to claim plugin capability via try_claim. Overall, most claims are accurate with one notable misleading detail, yielding a high proportion of ACCURATE statements.",
                "The summary correctly notes loading a shared library with dlopen and invoking its \"onload\" function, which aligns with the core purpose. However, it inaccurately describes 'updates status flags' and 'optional file descriptor operations'\u2014the code sets *has_plugin_p, adjusts abfd->plugin_format, and attempts to claim a bfd through specific hooks, not generic file descriptor operations. It omits key secondary details such as building the ld_plugin_tv table with multiple specific hooks and handling error cases via goto err branches, meaning important semantics are missing.",
                "The summary correctly states that the function loads a shared library and calls its \"onload\" function, which aligns with the source code. However, it inaccurately describes subsequent behavior: instead of merely updating status flags, the function sets plugin-related fields and attempts to claim a file via specific hooks. The mention of \"optional file descriptor operations\" is a NOISE claim that does not appear in the code, introducing misleading information. The core purpose is partially captured, but the inaccurate and vague post-onload description reduces precision and informational value. Worst failure mode is NOISE, with low gain from accurate claims."
            ]
        },
        "comment": {
            "summary": "Loads a plugin from a specified path, initializes it, and claims a file if successful, returning the status of the operation.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function loads a plugin from a given path, initializes it via an onload call, and attempts to claim a file if successful, returning a status. These are all accurate reflections of the source code\u2019s behavior, with no contradictory or irrelevant claims. All identified claims are consistent with the code logic, indicating a high proportion of accurate statements.",
                "The summary correctly states that the function loads a plugin from a path, initializes it, and attempts to claim a file, matching the core purpose of the source code. However, it omits key secondary details such as error handling via dlerror and early returns, the use of specific plugin initialization tags (LDPT_MESSAGE, LDPT_REGISTER_CLAIM_FILE_HOOK, LDPT_ADD_SYMBOLS, LDPT_NULL), conditional steps like verifying 'claim_file' and 'try_claim', and the plugin_format assignments. Coverage of the core is strong, but secondary semantics are minimal.",
                "The summary correctly states that the function loads a plugin from a given path, initializes it, attempts to claim a file, and returns a status indicating success or failure. These are aligned with the code's actual operations and primary purpose, with no inaccuracies about the core behavior. However, the claims are broad and omit key specifics such as error handling, the role of function pointers passed to the plugin, and changes to abfd->plugin_format. This makes the information low-detail and generic, yielding limited gain despite being accurate."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 333840,
    "strip_function_name": "sub_51810",
    "strip_decompiled_code": "__int64 __fastcall sub_51810(__int64 **a1, __int64 a2)\n{\n  __int64 v2; // r12\n  _QWORD *v4; // rbp\n  __int64 *v5; // rax\n  _QWORD *v6; // rbx\n  __int64 v7; // rdi\n  __int64 v8; // rsi\n  _QWORD *v10; // rax\n\n  if ( !a2 )\n    return 0LL;\n  v2 = a2;\n  if ( a2 != *(_QWORD *)(a2 + 64) )\n  {\n    while ( 1 )\n    {\n      if ( *(_DWORD *)(v2 + 8) == 1 )\n      {\n        v4 = *(_QWORD **)(v2 + 96);\n        if ( v4 )\n          break;\n      }\n      v2 = *(_QWORD *)(v2 + 40);\n      if ( !v2 )\n        return 0LL;\nLABEL_5:\n      if ( v2 == *(_QWORD *)(v2 + 64) )\n        return 0LL;\n    }\n    do\n    {\n      v5 = *a1;\n      if ( *a1 && (v6 = (_QWORD *)*v5) != 0LL )\n      {\n        while ( 1 )\n        {\n          v7 = v4[3];\n          v8 = *(_QWORD *)(v6[3] + 24LL);\n          if ( v7 == v8 || (unsigned int)xmlStrEqual(v7, v8) )\n            break;\n          v6 = (_QWORD *)*v6;\n          if ( !v6 )\n            goto LABEL_13;\n        }\n        v10 = sub_51530(a1, 0, 0LL, (__int64)v4, -1);\n        if ( !v10 )\n          return 0xFFFFFFFFLL;\n        *((_DWORD *)v10 + 8) = 0;\n      }\n      else\n      {\nLABEL_13:\n        if ( !sub_51530(a1, 0, 0LL, (__int64)v4, -1) )\n          return 0xFFFFFFFFLL;\n      }\n      v4 = (_QWORD *)*v4;\n    }\n    while ( v4 );\n    v2 = *(_QWORD *)(v2 + 40);\n    if ( v2 )\n      goto LABEL_5;\n  }\n  return 0LL;\n}\n",
    "function_name": "xmlDOMWrapNSNormGatherInScopeNs",
    "decompiled_code": "int __fastcall xmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map, xmlNodePtr node)\n{\n  xmlNodePtr v2; // r12\n  xmlNs *nsDef; // rbp\n  xmlNsMapPtr v5; // rax\n  _QWORD *p_next; // rbx\n  const xmlChar *prefix; // rdi\n  const xmlChar *v8; // rsi\n  xmlNsMapItemPtr v10; // rax\n\n  if ( !node )\n    return 0;\n  v2 = node;\n  if ( node != (xmlNodePtr)node->doc )\n  {\n    while ( 1 )\n    {\n      if ( v2->type == XML_ELEMENT_NODE )\n      {\n        nsDef = v2->nsDef;\n        if ( nsDef )\n          break;\n      }\n      v2 = v2->parent;\n      if ( !v2 )\n        return 0;\nLABEL_5:\n      if ( v2 == (xmlNodePtr)v2->doc )\n        return 0;\n    }\n    do\n    {\n      v5 = *map;\n      if ( *map && (p_next = &v5->first->next) != 0LL )\n      {\n        while ( 1 )\n        {\n          prefix = nsDef->prefix;\n          v8 = *(const xmlChar **)(p_next[3] + 24LL);\n          if ( prefix == v8 || xmlStrEqual__internal_alias(prefix, v8) )\n            break;\n          p_next = (_QWORD *)*p_next;\n          if ( !p_next )\n            goto LABEL_13;\n        }\n        v10 = xmlDOMWrapNsMapAddItem(map, 0, 0LL, nsDef, -1);\n        if ( !v10 )\n          return -1;\n        v10->shadowDepth = 0;\n      }\n      else\n      {\nLABEL_13:\n        if ( !xmlDOMWrapNsMapAddItem(map, 0, 0LL, nsDef, -1) )\n          return -1;\n      }\n      nsDef = nsDef->next;\n    }\n    while ( nsDef );\n    v2 = v2->parent;\n    if ( v2 )\n      goto LABEL_5;\n  }\n  return 0;\n}\n",
    "source_code": "static int\nxmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map,\n\t\t\t\txmlNodePtr node)\n{\n    xmlNodePtr cur;\n    xmlNsPtr ns;\n    xmlNsMapItemPtr mi;\n    int shadowed;\n\n    if ((map == NULL) || (*map != NULL))\n\treturn (-1);\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))\n        return (-1);\n    /*\n    * Get in-scope ns-decls of @parent.\n    */\n    cur = node;\n    while ((cur != NULL) && (cur != (xmlNodePtr) cur->doc)) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    if (cur->nsDef != NULL) {\n\t\tns = cur->nsDef;\n\t\tdo {\n\t\t    shadowed = 0;\n\t\t    if (XML_NSMAP_NOTEMPTY(*map)) {\n\t\t\t/*\n\t\t\t* Skip shadowed prefixes.\n\t\t\t*/\n\t\t\tXML_NSMAP_FOREACH(*map, mi) {\n\t\t\t    if ((ns->prefix == mi->newNs->prefix) ||\n\t\t\t\txmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n\t\t\t\tshadowed = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t    * Insert mapping.\n\t\t    */\n\t\t    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n\t\t\tns, XML_TREE_NSMAP_PARENT);\n\t\t    if (mi == NULL)\n\t\t\treturn (-1);\n\t\t    if (shadowed)\n\t\t\tmi->shadowDepth = 0;\n\t\t    ns = ns->next;\n\t\t} while (ns != NULL);\n\t    }\n\t}\n\tcur = cur->parent;\n    }\n    return (0);\n}",
    "comment": "Gathers in-scope namespace declarations from the given node's ancestors and updates the namespace mapping, avoiding shadowed prefixes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Traverses a linked list of XML nodes , returning the next valid node , or NULL if no further nodes exist .\n",
    "cpbcs_sum": "Deletes a specified element from the shared memory allocator, ensuring no conflicts with defined namespaces, and parameters.\n",
    "misum_sum": "Recursively frees a linked list of XML RelaxNG nodes, creating a new entity if no references remain.\n",
    "decom_sum": "Traverses XML nodes, matching element names and adding them to a list using xmlStrEqual, until all relevant linked structures are processed.",
    "cfg_sum": "Processes linked XML node structures, matching element names and inserting data entries, returning success or error codes based on traversal and insertion results.",
    "work_score": {
        "decom": {
            "summary": "Traverses XML nodes, matching element names and adding them to a list using xmlStrEqual, until all relevant linked structures are processed.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function traverses XML nodes, matches element names using xmlStrEqual, and adds them to a list until all relevant linked structures are processed. In reality, the code traverses from the given node up the parent chain, gathers in-scope XML namespace declarations, checks for shadowed prefixes using pointer comparison or xmlStrEqual, and adds namespace mappings to a map. The mention of matching element names and processing generic linked structures is inaccurate; the processing is specifically of namespace declarations. Thus, none of the claims are factually aligned with the source code semantics.",
                "The summary incorrectly describes the function as matching element names and adding them to a list, which contradicts the source code's actual purpose of gathering in-scope namespace declarations from ancestor XML elements and adding non-shadowed ones to a namespace map. It fails to cover the core purpose and omits key behavior such as handling shadowed prefixes, error returns for null inputs, and iterating namespace definitions. There is no accurate alignment with the core domain-specific operation.",
                "The summary claims the function matches element names and adds them to a list using xmlStrEqual. This is inaccurate because the code uses xmlStrEqual to compare namespace prefixes, not element names, and the list is a namespace map, not a general list of nodes. The core purpose\u2014gathering in-scope namespace declarations from XML elements\u2014is entirely missed, making this a fatal error about the primary purpose. No accurate or useful details are present, and noise dominates."
            ]
        },
        "cfg": {
            "summary": "Processes linked XML node structures, matching element names and inserting data entries, returning success or error codes based on traversal and insertion results.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes linked XML node structures, matches element names, and inserts data entries. While it correctly notes traversal and insertion of data entries, it inaccurately describes matching element names, which is not in the source code\u2014the function gathers namespace declarations, checks for shadowed prefixes, and adds them to a map. The return of success or error codes is accurate but generic. Overall, fewer than half of the claims are precise and faithful to the function's actual semantics.",
                "The summary makes generic claims about processing XML node structures, matching element names, and inserting data entries, but the source code\u2019s core purpose is specifically to gather in-scope namespace declarations from an XML node\u2019s parent hierarchy into a namespace map while skipping shadowed prefixes. This core domain action is not covered at all, and the summary\u2019s references to element names and generic insertion do not accurately describe namespace handling behavior. No additional behavior-critical semantics like error paths, shadowed prefix skipping, or mapping insertion specifics are captured.",
                "The summary inaccurately describes the function\u2019s core purpose, stating it matches element names and inserts data entries, whereas the code actually gathers in-scope XML namespace declarations from ancestor elements into a namespace mapping and skips shadowed prefixes. This is a FATAL error on the primary purpose. There are no accurate, specific claims about key I/O or side effects, and the noise from the incorrect description overwhelms any potential value."
            ]
        },
        "comment": {
            "summary": "Gathers in-scope namespace declarations from the given node's ancestors and updates the namespace mapping, avoiding shadowed prefixes.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately describes that the function gathers in-scope namespace declarations from the given node's ancestors, updates the namespace mapping, and avoids shadowed prefixes, all of which are reflected in the source code. There are no contradictory or irrelevant claims, and the statement is concise yet precise regarding the function's behavior.",
                "The summary accurately describes the core purpose of collecting in-scope namespace declarations from a node's ancestor elements and updating the namespace map while avoiding shadowed prefixes, matching the source code's loop through ancestor nodes and the shadow checking logic. However, it omits secondary details such as initial validation checks on parameters, handling of XML_NAMESPACE_DECL type, return values for error cases, and specifics about how mappings are inserted and shadow depth handled. Coverage of the core is strong but secondary semantics are sparse.",
                "The summary correctly captures the core purpose of the function: traversing the given node's ancestors to collect in-scope namespace declarations, adding them to the mapping, and avoiding shadowed prefixes. All claims align with the source code\u2019s behavior (e.g., checking nsDef of element nodes, skipping shadowed prefixes, and updating the mapping). No inaccuracies or noise are present, but the description is somewhat generic and lacks finer implementation details like error conditions or specific insertion logic, making the gain moderate rather than high."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584290608,
    "strip_function_name": "sub_FFFFFFFF81531730",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81531730(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        char *a11)\n{\n  __int64 v12; // r14\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // ebx\n  __int64 v16; // rdx\n  char *v17; // r12\n  _UNKNOWN **v18; // rax\n  unsigned __int8 **v19; // rax\n  __int64 v20; // r15\n  __int64 v22; // [rsp+0h] [rbp-38h]\n\n  v12 = sub_FFFFFFFF813F1610(a1);\n  sub_FFFFFFFF8178FDA0(qword_FFFFFFFF81C7B380);\n  sub_FFFFFFFF8178FDA0(v12 + 224);\n  if ( *(_QWORD *)(v12 + 256) )\n  {\n    strcpy(a11, \"none \");\n    v15 = 5;\n    v16 = 5LL;\n  }\n  else\n  {\n    v16 = 7LL;\n    v15 = 7;\n    *(_QWORD *)a11 = 0x205D656E6F6E5BLL;\n  }\n  v17 = (char *)off_FFFFFFFF81C7B360 - 48;\n  if ( off_FFFFFFFF81C7B360 != (_UNKNOWN *)&off_FFFFFFFF81C7B360 )\n  {\n    do\n    {\n      v19 = *(unsigned __int8 ***)(v12 + 256);\n      v20 = *(_QWORD *)v17;\n      if ( !v19 || (unsigned int)sub_FFFFFFFF812B4D60(*v19, *(_BYTE **)v17) )\n        v15 += sub_FFFFFFFF812B84F0((__int64)&a11[v15], -2120451181LL, a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      else\n        v15 += sub_FFFFFFFF812B84F0((__int64)&a11[v15], (__int64)\"[%s] \", a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      v18 = (_UNKNOWN **)*((_QWORD *)v17 + 6);\n      v17 = (char *)(v18 - 6);\n    }\n    while ( v18 != &off_FFFFFFFF81C7B360 );\n    v16 = v15;\n  }\n  v22 = v16;\n  sub_FFFFFFFF810644A0((volatile signed __int64 *)(v12 + 224));\n  sub_FFFFFFFF810644A0(qword_FFFFFFFF81C7B380);\n  *(_WORD *)&a11[v22] = 10;\n  return v15 + 1;\n}\n",
    "function_name": "led_trigger_show",
    "decompiled_code": "__int64 __fastcall led_trigger_show(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        const char *a10,\n        char *a11)\n{\n  __int64 drvdata; // r14\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // ebx\n  __int64 v16; // rdx\n  char *v17; // r12\n  _UNKNOWN **v18; // rax\n  unsigned __int8 **v19; // rax\n  __int64 v20; // r15\n  __int64 v22; // [rsp+0h] [rbp-38h]\n\n  drvdata = dev_get_drvdata(a1);\n  down_read(triggers_list_lock);\n  down_read((volatile signed __int64 *)(drvdata + 224));\n  if ( *(_QWORD *)(drvdata + 256) )\n  {\n    strcpy(a11, \"none \");\n    v15 = 5;\n    v16 = 5LL;\n  }\n  else\n  {\n    v16 = 7LL;\n    v15 = 7;\n    *(_QWORD *)a11 = 0x205D656E6F6E5BLL;\n  }\n  v17 = (char *)trigger_list - 48;\n  if ( trigger_list != (_UNKNOWN *)&trigger_list )\n  {\n    do\n    {\n      v19 = *(unsigned __int8 ***)(drvdata + 256);\n      v20 = *(_QWORD *)v17;\n      if ( v19 && !(unsigned int)strcmp(*v19, *(_BYTE **)v17) )\n      {\n        a10 = \"[%s] \";\n        v15 += sprintf((__int64)&a11[v15], (__int64)\"[%s] \", a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      }\n      else\n      {\n        a10 = \"  Type:   %s \" + 10;\n        v15 += sprintf((__int64)&a11[v15], -2120451181LL, a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      }\n      v18 = (_UNKNOWN **)*((_QWORD *)v17 + 6);\n      v17 = (char *)(v18 - 6);\n    }\n    while ( v18 != &trigger_list );\n    v16 = v15;\n  }\n  v22 = v16;\n  up_read((volatile signed __int64 *)(drvdata + 224), (__int64)a10);\n  up_read(triggers_list_lock, (__int64)a10);\n  *(_WORD *)&a11[v22] = 10;\n  return v15 + 1;\n}\n",
    "source_code": "\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_trigger *trig;\n\tint len = 0;\n\n\tdown_read(&triggers_list_lock);\n\tdown_read(&led_cdev->trigger_lock);\n\n\tif (!led_cdev->trigger)\n\t\tlen += sprintf(buf+len, \"[none] \");\n\telse\n\t\tlen += sprintf(buf+len, \"none \");\n\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\n\t\t\t\t\t\t\ttrig->name))\n\t\t\tlen += sprintf(buf+len, \"[%s] \", trig->name);\n\t\telse\n\t\t\tlen += sprintf(buf+len, \"%s \", trig->name);\n\t}\n\tup_read(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n\n\tlen += sprintf(len+buf, \"\\n\");\n\treturn len;\n}",
    "comment": "Retrieves the current LED trigger state and lists available triggers, marking the active trigger with brackets in the output buffer.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the name of the current LED device and formats it into the provided buffer , returning `` none '' if no LED exists .\n",
    "cpbcs_sum": "Handles CPU online and offline device wakeup functionality by retrieving device information and managing access with device resource management.\n",
    "misum_sum": "Retrieves and formats the names of active LED information for a USB HID device into a buffer for display.\n",
    "decom_sum": "Builds a status message in `a11` listing entries or \"none\", formats each item, appends newline, and returns the final string length.",
    "cfg_sum": "Formats a status string into the provided buffer based on memory state and iterates registered items with conditional validation before returning the final length.",
    "work_score": {
        "decom": {
            "summary": "Builds a status message in `a11` listing entries or \"none\", formats each item, appends newline, and returns the final string length.",
            "score": [
                0.8,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly notes that the function builds a status message listing entries or 'none', appends a newline, and returns the message length, which aligns with the code behavior. However, it inaccurately refers to the buffer as 'a11' instead of the actual parameter 'buf', and omits specific details such as marking the active trigger with brackets and the conditional formatting of 'none'. These omissions slightly reduce precision but most core claims match the code.",
                "The summary notes that the function builds a status message, lists entries or 'none', adds a newline, and returns the length, which are accurate observations. However, it fails to capture the core purpose: generating a string of LED trigger names with the active trigger bracketed, based on device-specific data and protected by read locks. It omits key domain details such as LED triggers, lock usage, handling of the active trigger distinctly, and the data source from device driver context, resulting in incomplete coverage of secondary behaviors.",
                "The summary accurately conveys that the function formats a list of entries or 'none', appends a newline, and returns the string length, which matches the source code\u2019s core purpose. However, it incorrectly refers to the buffer as 'a11' instead of 'buf', which is a minor but concrete inaccuracy targeting the function\u2019s parameter naming. This is not a fatal error for the primary semantics, and the rest of the claims are correct but generic, providing low informational gain."
            ]
        },
        "cfg": {
            "summary": "Formats a status string into the provided buffer based on memory state and iterates registered items with conditional validation before returning the final length.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary is overly generic and does not accurately capture the specific semantics of the source code. It refers vaguely to 'memory state' and 'conditional validation' without identifying the actual function purpose of listing LED triggers and marking the active one. While it mentions formatting into a buffer and iterating items, which loosely aligns with the code\u2019s iteration over triggers and writing to the buffer, it misses critical domain-specific details like the locking mechanisms and active trigger formatting, making most claims low-information or inaccurate regarding actual behavior.",
                "The summary is too vague and does not capture the core domain-specific purpose, which is to display the current LED trigger name alongside all available triggers in a formatted buffer. It incorrectly references 'memory state' and 'conditional validation' without specifying the LED trigger mechanism or interaction with device data structures. While it does note formatting a string and iterating registered items, it omits the key domain details and lock usage, resulting in poor coverage of primary purpose and critical behaviors.",
                "The summary gives a vague description that does not align closely with the source code's specific semantics. It inaccurately abstracts 'memory state' and 'conditional validation' instead of the actual LED trigger listing and selection logic, which is the core purpose. No specific mention of how triggers are retrieved, marked, or formatted in the buffer is made, leading to predominantly NOISE with no clear GOLD claims and very low positive gain."
            ]
        },
        "comment": {
            "summary": "Retrieves the current LED trigger state and lists available triggers, marking the active trigger with brackets in the output buffer.",
            "score": [
                1.0,
                0.5,
                0.9
            ],
            "reason": [
                "The summary accurately describes that the function retrieves the current LED trigger state, lists available triggers, and marks the active trigger with brackets in the output buffer. These details match the code's logic, which checks `led_cdev->trigger`, iterates over `trigger_list`, and formats active triggers with brackets. No contradictory or irrelevant claims are present, and all stated behavior is verifiable in the source.",
                "The summary accurately identifies the core purpose of the function: retrieving the current LED trigger and listing all available triggers, with the active one marked in brackets, which matches the source code's behavior. However, it omits secondary details such as handling the special \"none\" trigger vs. \"[none]\", as well as the locking mechanism used during access. These omissions mean the summary covers the core but lacks coverage of important side effects and branches.",
                "The summary correctly describes the function\u2019s core purpose: retrieving the current LED trigger state and listing available triggers, with the active one marked in brackets. These are accurate, specific claims matching the source code\u2019s behavior, including buffer output formatting. There is no contradictory or irrelevant information, and the claims provide high-value insight into the domain semantics. Noise is negligible and no fatal errors are present."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585574304,
    "strip_function_name": "sub_FFFFFFFF8166ADA0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8166ADA0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  unsigned __int64 v10; // r12\n  __int64 v11; // rdx\n  unsigned int v12; // r13d\n  int v13; // r14d\n  __int64 v14; // r15\n  __int64 v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  volatile signed __int32 *v18; // rsi\n  unsigned __int64 v19; // r12\n  volatile signed __int32 *v20; // rax\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n\n  v9 = *(_QWORD *)(a1 + 208);\n  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1000LL);\n  v11 = v9 + *(unsigned int *)(a1 + 188);\n  v12 = *(_DWORD *)(v11 + 12);\n  v13 = *(_DWORD *)(v11 + 16);\n  v14 = *(unsigned int *)(a1 + 184) + v9;\n  sub_FFFFFFFF815CE900(a1, *(_DWORD *)(a1 + 216) - v14);\n  v15 = sub_FFFFFFFF81669B20(v10, v12, v13, __ROL2__(*(_WORD *)(v14 + 4), 8), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 184LL));\n  if ( v15 )\n  {\n    v18 = (volatile signed __int32 *)&qword_20;\n    v19 = v15;\n    v20 = (volatile signed __int32 *)sub_FFFFFFFF815CF750(a1, 0x20u, a2, a3, a4, a5, v16, v17, a8, a9);\n    if ( v20 )\n    {\n      v18 = v20;\n      sub_FFFFFFFF81669C50(v19, v20, a2, a3, a4, a5, v25, v26, a8, a9);\n    }\n    if ( !_InterlockedDecrement((volatile signed __int32 *)(v19 + 76)) )\n      sub_FFFFFFFF815CA7D0(v19, v18, v21, v22, v23, v24, a2, a3, a4, a5, v25, v26, a8, a9);\n  }\n}\n",
    "function_name": "ping_rcv",
    "decompiled_code": "void __fastcall ping_rcv(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  unsigned __int64 v10; // r12\n  __int64 v11; // rdx\n  unsigned int v12; // r13d\n  int v13; // r14d\n  __int64 v14; // r15\n  __int64 v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  void (__fastcall *v18)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double); // rsi\n  __int64 v19; // r12\n  volatile signed __int32 *v20; // rax\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n\n  v9 = *(_QWORD *)(a1 + 208);\n  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1000LL);\n  v11 = v9 + *(unsigned int *)(a1 + 188);\n  v12 = *(_DWORD *)(v11 + 12);\n  v13 = *(_DWORD *)(v11 + 16);\n  v14 = *(unsigned int *)(a1 + 184) + v9;\n  skb_push(a1, *(_DWORD *)(a1 + 216) - v14, a2, a3, a4, a5, a6, a7, a8, a9);\n  v15 = ping_v4_lookup(v10, v12, v13, __ROL2__(*(_WORD *)(v14 + 4), 8), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 184LL));\n  if ( v15 )\n  {\n    v18 = (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))&qword_20;\n    v19 = v15;\n    v20 = (volatile signed __int32 *)skb_clone(a1, 0x20u, a2, a3, a4, a5, v16, v17, a8, a9);\n    if ( v20 )\n    {\n      v18 = (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))v20;\n      ping_queue_rcv_skb(v19, v20, a2, a3, a4, a5, v25, v26, a8, a9);\n    }\n    if ( !_InterlockedDecrement((volatile signed __int32 *)(v19 + 76)) )\n      sk_free(v19, v18, v21, v22, v23, v24, a2, a3, a4, a5, v25, v26, a8, a9);\n  }\n}\n",
    "source_code": "\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t__be32 saddr = iph->saddr;\n\t__be32 daddr = iph->daddr;\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),\n\t\t\t    skb->dev->ifindex);\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}",
    "comment": "Processes received ICMP packets, checks for an associated socket, and queues the packet for delivery if a corresponding socket is found.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes ICMP error messages for ping , updates socket error states , and notifies the appropriate socket if errors are relevant to the connection .\n",
    "cpbcs_sum": "Processes an IPv6 packet, updating its payload length and sending it to the appropriate socket buffer based on the specified source address and size.\n",
    "misum_sum": "Processes an IPv6 packet, updating its headers and potentially sending a processed or ICMP based on the provided socket buffer.\n",
    "decom_sum": "Processes object data using index offsets, performs resource lookup and initialization, then executes an operation and releases the resource with reference counting.",
    "cfg_sum": "Processes structured data from memory, performs computations, invokes related operations, manages reference counts, and cleans up resources when conditions are met.",
    "work_score": {
        "decom": {
            "summary": "Processes object data using index offsets, performs resource lookup and initialization, then executes an operation and releases the resource with reference counting.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary makes generic claims about processing data, performing a lookup, initialization, executing an operation, and releasing resources via reference counting. While 'resource lookup' and 'releasing with reference counting' align with the ping_v4_lookup and sock_put calls in the code, claims like 'object data using index offsets' and 'initialization' are vague and do not accurately reflect the specific ICMP handling or socket queuing shown. Overall, less than half of the claims are precise and verifiable against the actual source code behavior.",
                "The summary provides only generic statements about data processing, resource lookup, and reference counting without accurately reflecting the specific domain action of handling an incoming ICMP echo request, locating an associated ping socket, queuing the packet, and managing socket references. The core behavior tied to ICMP/ping reception is entirely missing, and there is no coverage of critical secondary details like header adjustments, conditional branches for found/not-found sockets, or packet drop behavior. Most claims are vague and non-distinguishing, failing to convey the actual network-specific semantics in the source code.",
                "The summary contains mostly generic, low-information claims such as processing data and resource lookup, which do broadly match the code's actions but lack specificity to the ICMP ping handling shown in the source. There are no clearly FATAL inaccuracies about core purpose or I/O; however, the vague description omits key domain-specific details like working with ICMP headers, socket lookup, and queuing packets, making the gain very low. Noise from generalities outweighs precise insights."
            ]
        },
        "cfg": {
            "summary": "Processes structured data from memory, performs computations, invokes related operations, manages reference counts, and cleans up resources when conditions are met.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary is overly generic and does not accurately capture the specific domain semantics of the function such as handling ICMP echo requests, looking up sockets, queueing received packets, and releasing references. While it mentions computations, operations, and managing reference counts, these are vague and not directly verifiable against the source code. Most claims do not target the precise behavior, resulting in low alignment with the evaluation steps.",
                "The summary is generic, describing broad programming operations like processing data, performing computations, and cleaning up resources, without mentioning the specific domain behavior of processing incoming ICMP echo requests and routing them to corresponding ping sockets. It fails to cover the core purpose or critical details such as matching sockets by identifiers, queuing packets, or handling packet drops.",
                "The summary contains only generic statements like processing data, performing computations, invoking operations, and managing resources, which are SAFE but low-info. It fails to mention specific domain semantics such as handling ICMP echo packets, looking up IPv4 ping sockets, or queueing received packets. No FATAL inaccuracies are present, but noise is high because the description is overly broad and omits the primary purpose, yielding minimal net benefit."
            ]
        },
        "comment": {
            "summary": "Processes received ICMP packets, checks for an associated socket, and queues the packet for delivery if a corresponding socket is found.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function processes received ICMP packets, checks for an associated socket, and queues the packet if a matching socket is found. These are specific and verifiable behaviors present in the source code. While it omits some minor details (like debug logging and packet dropping when no socket is found), all included claims align with the code, making the majority of claims accurate.",
                "The summary correctly identifies that the function processes received ICMP packets, checks for a matching socket, and queues the packet for delivery when found, which matches the core purpose of routing incoming ICMP echo messages to the appropriate socket. However, it omits several secondary details present in the code, such as pushing the ICMP header back onto the buffer, using ping_v4_lookup specifically, debug logging, index-based lookup, and noting that packet freeing is handled elsewhere. Coverage of secondary behavior is minimal.",
                "The summary accurately states that the function processes received ICMP packets, looks for an associated socket, and queues the packet if found, which matches the source code's core logic. There is no contradictory or irrelevant information (no FATAL or excessive NOISE). However, the summary is generic and omits lower-level specifics such as the use of `ping_v4_lookup`, pushing the ICMP header back, and debug logging, so its gain is low despite correctness."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584643232,
    "strip_function_name": "sub_FFFFFFFF815878A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815878A0(\n        unsigned __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  char *v10; // rax\n  __int64 v11; // r12\n  char *v12; // r13\n  __int64 v13; // rdx\n  _QWORD *v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  __int64 *v19; // rdx\n  __int64 v20; // rcx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  double (__fastcall *v25)(unsigned __int64); // rax\n\n  result = 4294967274LL;\n  if ( a1 )\n  {\n    v10 = sub_FFFFFFFF81587760((_BYTE *)(a1 + 12), 0, a2, a3, a4, a5, a6, a7, a8, a9);\n    v11 = (__int64)v10;\n    if ( v10 )\n    {\n      v12 = v10 + 88;\n      sub_FFFFFFFF8178F210(v10 + 88);\n      v13 = *(_QWORD *)(a1 + 160);\n      v14 = *(_QWORD **)(a1 + 168);\n      *(_QWORD *)(v13 + 8) = v14;\n      *v14 = v13;\n      *(_QWORD *)(a1 + 160) = 0xDEAD000000000100LL;\n      *(_QWORD *)(a1 + 168) = 0xDEAD000000000200LL;\n      --*(_DWORD *)(v11 + 80);\n      sub_FFFFFFFF8178F1B0(v12);\n      sub_FFFFFFFF81587620(a1, v11, v15, v16, v17, v18);\n      v25 = *(double (__fastcall **)(unsigned __int64))(a1 + 152);\n      if ( v25 )\n        a2 = v25(a1);\n      sub_FFFFFFFF8112DCD0(a1, a2, a3, a4, a5, v23, v24, a8, a9, v11, v19, v20, v21, v22);\n      sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C813E0);\n      --*(_DWORD *)(v11 + 36);\n      sub_FFFFFFFF8178F1B0(&unk_FFFFFFFF81C813E0);\n      return 0LL;\n    }\n    else\n    {\n      return 4294967290LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "snd_seq_device_free",
    "decompiled_code": "__int64 __fastcall snd_seq_device_free(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  char *driver; // rax\n  __int64 v11; // r12\n  __int64 v12; // r13\n  __int64 v13; // rdx\n  __int64 *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 *v17; // rdx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double (__fastcall *v20)(__int64 *); // rax\n\n  result = 4294967274LL;\n  if ( a1 )\n  {\n    driver = find_driver((__int64 *)((char *)a1 + 12), 0, a2, a3, a4, a5, a6, a7, a8, a9);\n    v11 = (__int64)driver;\n    if ( driver )\n    {\n      v12 = (__int64)(driver + 88);\n      mutex_lock((__int64)(driver + 88));\n      v13 = a1[20];\n      v14 = (__int64 *)a1[21];\n      *(_QWORD *)(v13 + 8) = v14;\n      *v14 = v13;\n      a1[20] = 0xDEAD000000000100LL;\n      a1[21] = 0xDEAD000000000200LL;\n      --*(_DWORD *)(v11 + 80);\n      mutex_unlock(v12);\n      free_device((__int64)a1, v11, a2, a3, a4, a5, v15, v16, a8, a9);\n      v20 = (double (__fastcall *)(__int64 *))a1[19];\n      if ( v20 )\n        a2 = v20(a1);\n      kfree(a1, a2, a3, a4, a5, v18, v19, a8, a9, v11, v17);\n      mutex_lock((__int64)&ops_mutex);\n      --*(_DWORD *)(v11 + 36);\n      mutex_unlock((__int64)&ops_mutex);\n      return 0LL;\n    }\n    else\n    {\n      return 4294967290LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "static int snd_seq_device_free(struct snd_seq_device *dev)\n{\n\tstruct ops_list *ops;\n\n\tif (snd_BUG_ON(!dev))\n\t\treturn -EINVAL;\n\n\tops = find_driver(dev->id, 0);\n\tif (ops == NULL)\n\t\treturn -ENXIO;\n\n\t/* remove the device from the list */\n\tmutex_lock(&ops->reg_mutex);\n\tlist_del(&dev->list);\n\tops->num_devices--;\n\tmutex_unlock(&ops->reg_mutex);\n\n\tfree_device(dev, ops);\n\tif (dev->private_free)\n\t\tdev->private_free(dev);\n\tkfree(dev);\n\n\tunlock_driver(ops);\n\n\treturn 0;\n}",
    "comment": "Frees a sequencer device by removing it from the list, releasing resources, and invoking the device's private cleanup function if defined.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Unregisters a synthesizer device from the system , updates the synth device list , and frees associated memory resources .\n",
    "cpbcs_sum": "Unregisters a sound sequence driver by removing it from the list, releasing resources, and removing it from the system.\n",
    "misum_sum": "Unregisters a sound card's audio driver, allocating resources and ensuring proper synchronization with resource management.\n",
    "decom_sum": "Initializes and links an object tied to a1, updates counters, invokes its callback, performs related processing, and cleans up synchronization structures.",
    "cfg_sum": "Validates the object pointer, initializes and updates linked structures, invokes an optional callback, adjusts counters, cleans up, and returns a status code.",
    "work_score": {
        "decom": {
            "summary": "Initializes and links an object tied to a1, updates counters, invokes its callback, performs related processing, and cleans up synchronization structures.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary is largely inaccurate: the function does not initialize or link an object, but instead frees a device, removes it from a list, decrements counters, calls optional cleanup callbacks, and unlocks synchronization structures. Most claims contradict the source code\u2019s semantics, with only the mention of updating counters and invoking a callback aligning partially with the actual operations.",
                "The summary incorrectly describes the core purpose as initializing and linking an object, whereas the source code shows it frees a sequencer device, removes it from a list, updates a device count, calls cleanup callbacks, and releases resources. It fails to cover the central action of device removal and memory deallocation, and misrepresents the operation type. Core functionality is absent, and secondary details such as error checks, mutex locking/unlocking, and freeing structures are not mentioned.",
                "The summary contains multiple inaccurate claims: it states the function initializes and links an object tied to a1, which is not present in the source code, and omits the primary purpose of freeing a snd_seq_device and associated resources. Instead of describing the removal from the list, decrementing the device count, freeing memory, and unlocking the driver, it mentions updates and synchronization cleanup in a misleading context. These are FATAL inaccuracies about the core domain action and semantics, making the description untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Validates the object pointer, initializes and updates linked structures, invokes an optional callback, adjusts counters, cleans up, and returns a status code.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary includes several accurate statements: it correctly notes pointer validation, linked list updates, optional callback invocation, counter adjustment, cleanup, and returning a status code. All these behaviors are present in the source code. However, the phrase 'initializes' is inaccurate since the function does not perform initialization\u2014it frees and removes structures instead. This introduces a minor error but the majority of claims align closely with actual code behavior.",
                "The summary generically mentions pointer validation, structure updates, counter adjustment, optional callback invocation, cleanup, and returning a status code, which broadly aligns with several operations in the source. However, it fails to accurately capture the core purpose: freeing a sequencer device by locating its driver operations, removing it from the registered devices list under mutex protection, decrementing the device count, freeing associated resources, and unlocking the driver. The absence of explicit details about finding the driver, mutex locking/unlocking, list removal, and driver unlocking means the core domain action is not covered, with only partial mention of secondary behaviors in vague terms.",
                "The summary makes several accurate, but mostly generic claims: it checks the object pointer (accurate), updates linked structures (accurate\u2014list removal), invokes an optional callback (accurate\u2014private_free), adjusts counters (accurate\u2014num_devices--), performs clean-up (accurate\u2014free_device, kfree), and returns a status code (accurate\u2014returns 0 or errors earlier). However, the phrasing 'initializes' is inaccurate since the code only modifies or deletes structures; no initialization occurs. This is minor noise and does not fatally misrepresent the primary purpose. Overall, the claims are correct but broad, with low informational gain and some non-specific language."
            ]
        },
        "comment": {
            "summary": "Frees a sequencer device by removing it from the list, releasing resources, and invoking the device's private cleanup function if defined.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately reflects the core semantics of the code: freeing a sequencer device, removing it from the list, releasing resources, and optionally invoking its private cleanup function. All these actions match the implementation, with no incorrect or irrelevant claims. The description captures the main responsibilities without introducing contradictions or extraneous information, resulting in very high alignment.",
                "The summary correctly identifies the core purpose of freeing a sequencer device and includes accurate details about removing it from the list, releasing resources, and calling a private cleanup function when defined. This matches the source code\u2019s core operation and a key secondary behavior. However, it omits other important aspects like input validation, specific error returns (-EINVAL, -ENXIO), mutex locking/unlocking, decrementing the device count, calling free_device, and unlocking the driver, leaving coverage incomplete.",
                "The summary contains accurate claims: it correctly states that the function frees a sequencer device, removes it from a list, releases resources, and calls the device's private cleanup if defined. These match the source code's core behavior, including `list_del`, `free_device`, conditional `private_free`, and final `kfree`. The description is concise but omits some implementation specifics like checking for null device, error returns, and mutex locking, making it less detailed. There is no inaccurate or irrelevant information, and the gain is moderate due to clear coverage of the primary purpose."
            ]
        }
    }
}
{
    "project_name": "gettext",
    "function_addr": 38736,
    "strip_function_name": "sub_9750",
    "strip_decompiled_code": "void __fastcall sub_9750(__int64 a1)\n{\n  int v1; // ebp\n  size_t v2; // r12\n  const void *v3; // r14\n  __int64 v4; // rax\n  __int64 v5; // r13\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  unsigned int v8; // esi\n\n  v1 = *(_DWORD *)(a1 + 24);\n  if ( v1 != 1 )\n  {\nLABEL_2:\n    if ( v1 == -1 )\n      return;\n    goto LABEL_3;\n  }\n  v8 = *(unsigned __int16 *)(a1 + 56);\n  if ( (_WORD)v8 )\n  {\n    sub_9650((_QWORD *)a1, v8);\n    v1 = *(_DWORD *)(a1 + 24);\n    *(_WORD *)(a1 + 56) = 0;\n    goto LABEL_2;\n  }\nLABEL_3:\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( v2 )\n  {\n    v3 = *(const void **)(a1 + 32);\n    v4 = xmalloc();\n    *(_BYTE *)v4 = v1;\n    *(_QWORD *)(v4 + 8) = v2;\n    v5 = v4;\n    memcpy((void *)(v4 + 16), v3, v2);\n    v6 = *(_QWORD *)(a1 + 8);\n    if ( v6 == *(_QWORD *)(a1 + 16) )\n    {\n      *(_QWORD *)(a1 + 16) = 2 * v6 + 1;\n      v7 = xrealloc();\n      v6 = *(_QWORD *)(a1 + 8);\n      *(_QWORD *)a1 = v7;\n    }\n    else\n    {\n      v7 = *(_QWORD *)a1;\n    }\n    *(_QWORD *)(a1 + 8) = v6 + 1;\n    *(_QWORD *)(v7 + 8 * v6) = v5;\n  }\n  *(_QWORD *)(a1 + 40) = 0LL;\n}\n",
    "function_name": "mixed_string_buffer_flush_curr",
    "decompiled_code": "void __fastcall mixed_string_buffer_flush_curr(mixed_string_buffer *bp_0)\n{\n  int curr_type; // ebp\n  size_t curr_buflen; // r12\n  char *curr_buffer; // r14\n  __int64 v5; // rax\n  mixed_string_segment *v6; // r13\n  size_t nsegments; // rdx\n  mixed_string_segment **v8; // rax\n  ucs4_t utf16_surr; // esi\n  size_t v10; // rsi\n  mixed_string_segment **segments; // rdi\n\n  curr_type = bp_0->curr_type;\n  if ( curr_type != 1 )\n  {\nLABEL_2:\n    if ( curr_type == -1 )\n      return;\n    goto LABEL_3;\n  }\n  utf16_surr = bp_0->utf16_surr;\n  if ( (_WORD)utf16_surr )\n  {\n    mixed_string_buffer_append_lone_surrogate(bp_0, utf16_surr);\n    curr_type = bp_0->curr_type;\n    bp_0->utf16_surr = 0;\n    goto LABEL_2;\n  }\nLABEL_3:\n  curr_buflen = bp_0->curr_buflen;\n  if ( curr_buflen )\n  {\n    curr_buffer = bp_0->curr_buffer;\n    v5 = ((__int64 (__fastcall *)(size_t))xmalloc)((curr_buflen + 23) & 0xFFFFFFFFFFFFFFF8LL);\n    *(_BYTE *)v5 = curr_type;\n    *(_QWORD *)(v5 + 8) = curr_buflen;\n    v6 = (mixed_string_segment *)v5;\n    memcpy((void *)(v5 + 16), curr_buffer, curr_buflen);\n    nsegments = bp_0->nsegments;\n    if ( nsegments == bp_0->nsegments_allocated )\n    {\n      v10 = 2 * nsegments + 1;\n      segments = bp_0->segments;\n      bp_0->nsegments_allocated = v10;\n      v8 = (mixed_string_segment **)((__int64 (__fastcall *)(mixed_string_segment **, size_t))xrealloc)(\n                                      segments,\n                                      8 * v10);\n      nsegments = bp_0->nsegments;\n      bp_0->segments = v8;\n    }\n    else\n    {\n      v8 = bp_0->segments;\n    }\n    bp_0->nsegments = nsegments + 1;\n    v8[nsegments] = v6;\n  }\n  bp_0->curr_buflen = 0LL;\n}\n",
    "source_code": "static void\nmixed_string_buffer_flush_curr (struct mixed_string_buffer *bp)\n{\n  if (bp->curr_type == utf8_encoded)\n    mixed_string_buffer_flush_utf16_surr (bp);\n  if (bp->curr_type != -1)\n    {\n      if (bp->curr_buflen > 0)\n        {\n          struct mixed_string_segment *segment =\n            segment_alloc (bp->curr_type, bp->curr_buffer, bp->curr_buflen);\n          mixed_string_buffer_add_segment (bp, segment);\n        }\n      bp->curr_buflen = 0;\n    }\n}",
    "comment": "Flushes the current buffer to segments based on its type, handling UTF-8 encoding and resetting the buffer length after addition.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Splits a word or segment from a node in a wordsplit structure , reallocating memory as needed , and clears the segment 's properties .\n",
    "cpbcs_sum": "Appends a unique lines to a dynamically allocated buffer, resizing it as necessary to accommodate the new entry from the stack.\n",
    "misum_sum": "Dynamically adds a new token to the end of a dynamic array, expanding memory if necessary, and handles memory allocation errors.\n",
    "decom_sum": "Packages the current state and associated data into a dynamically allocated entry and appends it to a growing list buffer.",
    "cfg_sum": "Processes pending data by allocating memory, copying its contents, and appending it to a dynamic list while updating state and clearing the source buffer.",
    "work_score": {
        "decom": {
            "summary": "Packages the current state and associated data into a dynamically allocated entry and appends it to a growing list buffer.",
            "score": [
                0.6,
                0.4,
                0.5
            ],
            "reason": [
                "The summary claims the function packages the current state into a dynamically allocated entry and appends it to a growing list buffer. While the source code does allocate a segment using `segment_alloc` and adds it to `bp` with `mixed_string_buffer_add_segment`, it also includes specific conditions on `curr_type`, UTF-16 surrogate flushing, and buffer length requirements that the summary ignores. The omission of these conditions and the generic framing reduces specificity and accuracy, though the central idea of allocation and appending matches the code.",
                "The summary correctly notes that data is packaged and appended to a buffer, which aligns with the code\u2019s allocation of a segment and adding it to the buffer, but it misses the core detail that the function flushes a current mixed-string buffer segment conditional on its type, including a UTF-16 surrogate flush for UTF-8 encoded data. No mention is made of type checks, buffer length validation, or resetting the buffer length, resulting in incomplete coverage of critical branch behaviors and side effects.",
                "The summary contains one main claim: that the function packages the current state and data into a dynamically allocated entry and appends it to a growing list buffer. This is partially accurate since the code allocates a segment from the current buffer and appends it to the mixed_string_buffer, but it omits conditional behavior based on curr_type (e.g., UTF-16 surrogate flushing) and resetting of buflen. The claim is generic and does not convey the key specifics or conditions driving core functionality. No FATAL contradiction is present, but the lack of specificity results in low gain and moderate noise."
            ]
        },
        "cfg": {
            "summary": "Processes pending data by allocating memory, copying its contents, and appending it to a dynamic list while updating state and clearing the source buffer.",
            "score": [
                0.6,
                0.3,
                0.5
            ],
            "reason": [
                "The summary claims the function allocates memory, copies its contents, appends to a dynamic list, updates state, and clears the source buffer. The source code does allocate a segment, add it to a buffer list, reset length, and conditionally flush UTF-16 surrogates \u2014 these align with allocation, appending, and clearing claims. However, there is no explicit copying of contents shown (segment_alloc may implicitly copy, but this is unstated in code) and 'dynamic list' is only inferred. Most claims are reasonably accurate but slightly imprecise or infer behavior not explicitly visible, leading to mixed reliability.",
                "The summary captures a generic idea of appending buffered data to a list and clearing the buffer, which loosely aligns with allocating a segment and adding it to the buffer's segment list. However, it fails to mention the core purpose of flushing segments of mixed string data, including the conditional handling for UTF-8 encoded data via UTF-16 surrogate flushing, and omits key branching conditions and type-specific behavior critical to the function's semantics. The coverage of secondary details such as type checks and length checks is absent, making the description incomplete in both core and secondary aspects.",
                "The summary correctly states that the function processes pending data and appends it to a list while updating state and clearing the buffer, which matches the segment allocation and addition logic in the code. However, it inaccurately claims that memory is copied, which is not explicitly shown in the source; the code allocates a segment and passes a pointer, with no evidence of copying. No FATAL errors about the primary purpose are present, but this introduces some noise through an imprecise claim. The accurate parts are relatively generic with low informational gain."
            ]
        },
        "comment": {
            "summary": "Flushes the current buffer to segments based on its type, handling UTF-8 encoding and resetting the buffer length after addition.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function flushes the current buffer to segments based on its type, handles UTF-8-specific logic via a helper, and resets the buffer length after adding a segment. These match the code\u2019s conditional handling for utf8_encoded, segment allocation, and resetting curr_buflen. No claims are inaccurate or unrelated to the source, indicating strong precision.",
                "The summary correctly captures the core purpose of flushing the current buffer into segments according to its type and notes handling UTF-8 surrogate cases and buffer reset, which aligns with the source code\u2019s domain-specific behavior. However, it omits details of the UTF-16 surrogate flush condition, the check for non -1 type, and the branch where a segment is only added if the buffer length is greater than zero. These missing edge conditions and control flow nuances limit completeness.",
                "The summary correctly states that the function flushes the current buffer into segments depending on its type, handles UTF-8-encoded data specifically by invoking a UTF-16 surrogate flush, and resets the buffer length after adding the segment. These are accurate reflections of the source code\u2019s primary purpose and key side effects. There is no contradictory or irrelevant noise, but the description is somewhat generic and lacks detailed mention of conditional checks and allocation steps, resulting in moderate informational gain rather than high specificity."
            ]
        }
    }
}
{
    "project_name": "a2ps",
    "function_addr": 4219952,
    "strip_function_name": "sub_406430",
    "strip_decompiled_code": "_QWORD *__fastcall sub_406430(char *src)\n{\n  _QWORD *v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rax\n  _QWORD *v4; // rbp\n  __int64 v5; // rax\n  __int64 v6; // r13\n  __int64 v7; // rax\n  _QWORD *v8; // rax\n  __int64 v9; // rax\n  __int64 v10; // r13\n  __int64 v11; // rax\n  _QWORD *v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // r13\n  __int64 v15; // rax\n  _QWORD *v16; // rax\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  __int64 v19; // rbp\n  __int64 v20; // rax\n  _QWORD *v21; // rax\n\n  v1 = sub_432EA0(32LL);\n  v2 = sub_405DD0(0LL, 0, qword_657768);\n  v3 = sub_438B00(src);\n  *v1 = sub_405CC0(v3, v2);\n  v1[1] = qword_657330;\n  v4 = sub_4061B0((__int64)\"C usual exceptions: strings\", (__int64)\"C usual exceptions: regexps\", 3LL, 3LL);\n  v5 = sub_438B00(\"\\\\'\");\n  v6 = sub_405DD0(v5, 0, qword_657330);\n  v7 = sub_438B00(\"\\\\'\");\n  v8 = sub_405CC0(v7, v6);\n  sub_434A00(*v4, v8);\n  v9 = sub_438B00(\"\\\\\\\\\");\n  v10 = sub_405DD0(v9, 0, qword_657330);\n  v11 = sub_438B00(\"\\\\\\\\\");\n  v12 = sub_405CC0(v11, v10);\n  sub_434A00(*v4, v12);\n  v13 = sub_438B00(\"\\\\\\\"\");\n  v14 = sub_405DD0(v13, 0, qword_657330);\n  v15 = sub_438B00(\"\\\\\\\"\");\n  v16 = sub_405CC0(v15, v14);\n  sub_434A00(*v4, v16);\n  sub_405930(v4);\n  v1[2] = v4;\n  v17 = sub_4061B0((__int64)\"C Close: strings\", (__int64)\"C Close: regex\", 5LL, 5LL);\n  v18 = qword_657768;\n  v1[3] = v17;\n  v19 = sub_405DD0(0LL, 0, v18);\n  v20 = sub_438B00(src);\n  v21 = sub_405CC0(v20, v19);\n  sub_434A00(*(_QWORD *)v1[3], v21);\n  sub_405930((_QWORD *)v1[3]);\n  return v1;\n}\n",
    "function_name": "new_C_string_sequence",
    "decompiled_code": "sequence *new_C_string_sequence()\n{\n  void *v0; // rbx\n  darray *v1; // rbp\n  unsigned __int8 *v2; // rax\n  darray *v3; // rdx\n  const char *v4; // rcx\n  size_t v5; // r8\n  words *v6; // rbp\n  char *v7; // rax\n  darray *v8; // r13\n  unsigned __int8 *v9; // rax\n  darray *v10; // rdx\n  const char *v11; // rcx\n  size_t v12; // r8\n  rule *v13; // rax\n  char *v14; // rax\n  darray *v15; // r13\n  unsigned __int8 *v16; // rax\n  darray *v17; // rdx\n  const char *v18; // rcx\n  size_t v19; // r8\n  rule *v20; // rax\n  char *v21; // rax\n  darray *v22; // r13\n  unsigned __int8 *v23; // rax\n  darray *v24; // rdx\n  const char *v25; // rcx\n  size_t v26; // r8\n  rule *v27; // rax\n  words *v28; // rax\n  const char *v29; // rdx\n  darray *v30; // rbp\n  unsigned __int8 *v31; // rax\n  darray *v32; // rdx\n  const char *v33; // rcx\n  size_t v34; // r8\n  rule *v35; // rax\n\n  v0 = xmalloc(0x20uLL);\n  v1 = rhs_new_single(0LL, da_growth::da_steady, *(const char **)&Plain_fface);\n  v2 = (unsigned __int8 *)xstrdup((const char *)v0);\n  *(_QWORD *)v0 = rule_new_0(v2, v1, v3, v4, v5);\n  *((fface_s *)v0 + 1) = String_fface;\n  v6 = words_new(0x43D522uLL, (da_growth)4445446, 3uLL, (const char *)3);\n  v7 = xstrdup((const char *)v0);\n  v8 = rhs_new_single((size_t)v7, da_growth::da_steady, *(const char **)&String_fface);\n  v9 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v13 = rule_new_0(v9, v8, v10, v11, v12);\n  da_append((darray *)v0, v13);\n  v14 = xstrdup((const char *)v0);\n  v15 = rhs_new_single((size_t)v14, da_growth::da_steady, *(const char **)&String_fface);\n  v16 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v20 = rule_new_0(v16, v15, v17, v18, v19);\n  da_append((darray *)v0, v20);\n  v21 = xstrdup((const char *)v0);\n  v22 = rhs_new_single((size_t)v21, da_growth::da_steady, *(const char **)&String_fface);\n  v23 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v27 = rule_new_0(v23, v22, v24, v25, v26);\n  da_append((darray *)v0, v27);\n  words_finalize(&v6->strings);\n  *((_QWORD *)v0 + 2) = v6;\n  v28 = words_new(0x43D556uLL, (da_growth)4445511, 5uLL, (const char *)5);\n  v29 = (const char *)Plain_fface;\n  *((_QWORD *)v0 + 3) = v28;\n  v30 = rhs_new_single(0LL, da_growth::da_steady, v29);\n  v31 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v35 = rule_new_0(v31, v30, v32, v33, v34);\n  da_append((darray *)v0, v35);\n  words_finalize(*((darray ***)v0 + 3));\n  return (sequence *)v0;\n}\n",
    "source_code": "\nstruct sequence *\nnew_C_string_sequence (const char * delimitor)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n  res->open = rule_new (xustrdup (delimitor), NULL,\n\t\t\trhs_new_single (NULL, 0, Plain_fface),\n\t\t\t__FILE__, __LINE__);\n  res->face = String_fface;\n  res->exceptions = new_C_exceptions ();\n  res->close = words_new (\"C Close: strings\", \"C Close: regex\", 5, 5);\n  words_add_string (res->close,\n\t\t    rule_new (xustrdup (delimitor), NULL,\n\t\t\t      rhs_new_single (NULL, 0, Plain_fface),\n\t\t\t      __FILE__, __LINE__));\n  words_finalize (res->close);\n  return res;\n}",
    "comment": "Creates and initializes a new string sequence structure with a specified delimiter and associated rules for processing strings.",
    "hext5_sum": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
    "bint5_sum": "Creates and initializes a new buffer state for reading input from a specified file .\n",
    "cpbcs_sum": "Initializes a new symbol table for a Debian rule and registers it for use in the ELF file.\n",
    "misum_sum": "Creates and initializes a new symbol table, linking various symbol tables, and managing memory for string variables and string encoding.\n",
    "decom_sum": "Builds C language parsing rules for strings and regex, including escape sequences, initializing related data structures with the provided source pattern.",
    "cfg_sum": "Builds and returns a structured set of C language string and regex patterns with defined escape sequences and closing rules based on the input.",
    "work_score": {
        "decom": {
            "summary": "Builds C language parsing rules for strings and regex, including escape sequences, initializing related data structures with the provided source pattern.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function builds C language parsing rules for strings and regex, including escape sequences, and uses the provided source pattern. While the code does create rules for C strings and regex and initializes related structures, there is no evidence of handling escape sequences specifically. The 'source pattern' part loosely aligns with using the delimiter argument, but 'including escape sequences' is inaccurate. This yields mixed accuracy with some semantic contradictions.",
                "The summary incorrectly states that the function builds C language parsing rules for strings, regex, and escape sequences, which is not supported by the code. The function actually creates a 'sequence' structure with open and close rules based on a provided delimiter, sets specific faces, and initializes exception handling. This core purpose is not clearly conveyed, and the mention of regex and escape sequences is inaccurate. Secondary details like initialization of related structures are mentioned vaguely but without precision or alignment to actual code behavior.",
                "The summary claims the function builds C language parsing rules for strings and regex, including escape sequences, but the source code does not indicate handling escape sequences or regex parsing logic; the term 'regex' in a string literal here is just a label. This is a FATAL inaccuracy affecting the core purpose. While the code does create data structures and rules involving a provided delimiter pattern, the misrepresentation of functionality severely undermines trust. No high-value, specific, accurate claims are present to offset this."
            ]
        },
        "cfg": {
            "summary": "Builds and returns a structured set of C language string and regex patterns with defined escape sequences and closing rules based on the input.",
            "score": [
                0.3,
                0.3,
                0.2
            ],
            "reason": [
                "The summary claims the function builds a structured set of C language string and regex patterns with defined escape sequences and closing rules. While the code does create a sequence object with string and regex closing rules, there is no indication in the source of 'defined escape sequences', and the description of 'C language string' semantics is overstated compared to the actual operations. Several elements of the summary are speculative or inaccurate, resulting in less than half of its claims being correct.",
                "The summary claims the function builds a set of C language string and regex patterns with defined escape sequences, but the source code shows it constructs a 'sequence' struct with open/close rules based on the provided delimiter, string-specific face constants, exceptions, and words lists. While it correctly touches on patterns and closing rules, it inaccurately introduces 'escape sequences' and language-specific regex not explicitly present in the code. The core purpose of creating a sequence of parsing rules from a delimiter is missing in specific domain terms, and coverage of other critical details like delimiter duplication, face assignments, and exception creation is poor.",
                "The summary introduces inaccurate semantics: it claims the function creates C language string and regex patterns with defined escape sequences, which is not evident in the source code. The code constructs a 'sequence' struct with rules based on the provided delimiter, sets specific faces, and defines closing rules, but there is no indication of processing escape sequences or general C language string/regex patterns. This is a FATAL issue targeting the primary purpose, as it misstates the core behavior. There are no clearly accurate, detailed claims to offset this error, resulting in very low net benefit."
            ]
        },
        "comment": {
            "summary": "Creates and initializes a new string sequence structure with a specified delimiter and associated rules for processing strings.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function creates and initializes a new string sequence struct and uses the provided delimiter to set up rules for processing strings, which matches the code where `res` is allocated, populated with rules using `xustrdup(delimitor)` and related functions. All claims are accurate and directly aligned with the source code\u2019s semantics, with no incorrect or irrelevant information present.",
                "The summary correctly states that the function creates and initializes a string sequence structure with a specified delimiter, which matches the core purpose of the code. However, it omits important secondary details such as setting specific faces (String_fface, Plain_fface), creating exceptions, initializing 'close' with predefined words, adding a rule to 'close', and finalizing it. Coverage of error handling, constants, and specific function calls is missing, making the secondary coverage weak.",
                "The summary correctly states the core purpose of the function: creating and initializing a new string sequence structure with a given delimiter and rules for string processing, which aligns with the source code's allocation, delimiter duplication, rule creation, and face assignments. It omits specifics about exception handling, the details of close rules ('C Close: strings', 'C Close: regex'), and finalization steps, but contains no inaccurate or contradictory claims. The claims are accurate but generic, giving low gain due to limited detail and insight."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5157392,
    "strip_function_name": "sub_4EB210",
    "strip_decompiled_code": "__int64 __fastcall sub_4EB210(_DWORD *a1, int *a2, _QWORD *a3, int *a4, _DWORD *a5, _DWORD *a6)\n{\n  int v6; // eax\n  unsigned int v7; // r10d\n  __int64 result; // rax\n  _BYTE *v13; // rdi\n  unsigned int v14; // [rsp+Ch] [rbp-3Ch]\n  int v15; // [rsp+14h] [rbp-34h] BYREF\n  void *ptr; // [rsp+18h] [rbp-30h] BYREF\n\n  v6 = a1[70];\n  ptr = 0LL;\n  if ( (v6 & 0xFFFFFFBF) == 0x11 || (v7 = v6 - 19, result = 0LL, v7 <= 2) )\n  {\n    result = sub_4EA980(a1, 0, 0LL, 16, 12, &ptr, &v15);\n    v13 = ptr;\n    if ( (int)result > 0 )\n    {\n      if ( v15 > 11 )\n      {\n        v13 = ptr;\n        result = 16LL * (*(_BYTE *)ptr >> 4);\n        *a2 = *(_BYTE *)ptr >> 4;\n        *a3 = result + 7804000;\n        *a4 = *v13 & 0xF;\n        *a5 = (((char)v13[2] >> 5) & 3) + 1;\n        *a6 = ((char)v13[11] | ((char)v13[10] << 8) | ((char)v13[9] << 16))\n            - ((char)v13[7] | ((char)v13[6] << 8) | ((char)v13[5] << 16))\n            + 1;\n        LODWORD(result) = 1;\nLABEL_6:\n        v14 = result;\n        free(v13);\n        return v14;\n      }\n      sub_4E28D0(qword_8182E0, -1, 2, 0x10000000, 0, \"READ DISC STRUCTURE format 10h: Less than 12 bytes\", 0, 0);\n      v13 = ptr;\n      result = 0LL;\n    }\n    if ( v13 )\n      goto LABEL_6;\n  }\n  return result;\n}\n",
    "function_name": "mmc_get_phys_format_info",
    "decompiled_code": "int __fastcall mmc_get_phys_format_info(\n        burn_drive *d,\n        int *disk_category,\n        char **book_name,\n        int *part_version,\n        int *num_layers,\n        int *num_blocks,\n        int flag)\n{\n  int current_profile; // eax\n  unsigned int v8; // r10d\n  int result; // eax\n  char *v14; // rdi\n  __int64 v15; // rax\n  int v16; // [rsp+Ch] [rbp-3Ch]\n  int reply_len; // [rsp+14h] [rbp-34h] BYREF\n  char *reply; // [rsp+18h] [rbp-30h] BYREF\n\n  current_profile = d->current_profile;\n  reply = 0LL;\n  if ( (current_profile & 0xFFFFFFBF) == 0x11 || (v8 = current_profile - 19, result = 0, v8 <= 2) )\n  {\n    result = mmc_read_disc_structure(d, 0, 0LL, 0x10u, 12, &reply, &reply_len);\n    v14 = reply;\n    if ( result > 0 )\n    {\n      if ( reply_len > 11 )\n      {\n        v14 = reply;\n        v15 = 16LL * ((unsigned __int8)*reply >> 4);\n        *disk_category = (unsigned __int8)*reply >> 4;\n        *book_name = (char *)(v15 + 7804000);\n        *part_version = *v14 & 0xF;\n        *num_layers = ((v14[2] >> 5) & 3) + 1;\n        *num_blocks = (v14[11] | (v14[10] << 8) | (v14[9] << 16)) - (v14[7] | (v14[6] << 8) | (v14[5] << 16)) + 1;\n        result = 1;\nLABEL_6:\n        v16 = result;\n        free(v14);\n        return v16;\n      }\n      libdax_msgs_submit(libdax_messenger, -1, 2, 0x10000000, 0, (const XorrisO *)&byte_523516[2618], 0, 0LL);\n      v14 = reply;\n      result = 0;\n    }\n    if ( v14 )\n      goto LABEL_6;\n  }\n  return result;\n}\n",
    "source_code": "int mmc_get_phys_format_info(struct burn_drive *d, int *disk_category,\n\t\t\tchar **book_name, int *part_version, int *num_layers,\n\t\t\tint *num_blocks, int flag)\n{\n\tint ret, reply_len, prf;\n\tchar *reply = NULL;\n\tstatic char book_names[][16] = {\n\t\t\"DVD-ROM\", \"DVD-RAM\", \"DVD-R\", \"DVD-RW\",\n\t\t\"HD DVD-ROM\", \"HD DVD-RAM\", \"HD DVD-R\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW\", \"DVD+R\", \"unknown\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW DL\", \"DVD+R DL\", \"unknown\"\n\t};\n\n\tprf = d->current_profile;\n\tif (!(prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15 ||\n\t      prf == 0x51))\n\t\treturn 0; /* Not a [HD] DVD-R[W] loaded */\n\tret = mmc_read_disc_structure(d, 0, 0, 0x10, 12, &reply,\n\t\t\t\t\t\t\t &reply_len, 0);\n\tif (ret <= 0)\n\t\tgoto ex;\n\tif(reply_len < 12) {\n\t\tlibdax_msgs_submit(libdax_messenger, -1, 0x00000002,\n\t\t\tLIBDAX_MSGS_SEV_DEBUG, LIBDAX_MSGS_PRIO_ZERO,\n\t\t\t\"READ DISC STRUCTURE format 10h: Less than 12 bytes\",\n\t\t\t0, 0);\n\t\t{ret = 0; goto ex;}\n\t}\n\t*disk_category = (reply[0] >> 4) & 0xf;\n\t*book_name = book_names[*disk_category];\n\t*part_version = reply[0] & 0xf;\n\t*num_layers = ((reply[2] >> 5) & 0x3) + 1;\n\t*num_blocks = ((reply[9] << 16) | (reply[10] << 8) | reply[11]) -\n\t              ((reply[5] << 16) | (reply[6] << 8) | reply[7]) + 1;\n\tret = 1;\nex:;\n\tif (reply != NULL)\n\t\tfree(reply);\n\treturn ret;\n}",
    "comment": "Retrieves physical format information of a disc in the drive, including disk category, book name, version, layer count, and block count.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the allocation and free block counts for a Blu-ray disc from the burn drive 's current profile .\n",
    "cpbcs_sum": "Extracts a UTF-16 encoded string from the UTF-16 encoded data, updating the output buffer and length based on the encoded signature type.\n",
    "misum_sum": "Retrieves a 64-bit block number from a burn drive, validating its size and updating the provided data pointer.\n",
    "decom_sum": "Parses and processes \u201cREAD DISC STRUCTURE\u201d format 0x10h data from a device, extracting fields and calculating values before freeing the allocated buffer.",
    "cfg_sum": "Reads and validates disc structure format 0x10, extracts specific header fields, computes related values, and cleans up allocated memory before returning results.",
    "work_score": {
        "decom": {
            "summary": "Parses and processes \u201cREAD DISC STRUCTURE\u201d format 0x10h data from a device, extracting fields and calculating values before freeing the allocated buffer.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary accurately captures the function's core behavior: reading disc structure format 0x10h, extracting various fields, computing values like layer count and block number, and freeing the allocated buffer. It omits some details such as profile checks and error handling but all stated claims match the source code without contradictions, resulting in a high proportion of accurate claims.",
                "The summary correctly identifies the core purpose of processing 'READ DISC STRUCTURE' format 0x10h data and freeing the buffer, which aligns with the main domain operation in the code. However, it omits key secondary details such as the profile check for supported DVD types, handling of errors and insufficient reply length, and the specific extracted fields like disk category, book name, part version, number of layers, and block calculation. The coverage of secondary behaviors is minimal.",
                "The summary accurately describes that the function processes \"READ DISC STRUCTURE\" format 0x10h data, extracts fields, and calculates values, which matches the source code's behavior of calling mmc_read_disc_structure and deriving disk category, book name, part version, layers, and block count before freeing the buffer. It omits some specifics like the profile check for supported formats and error handling, but contains no contradictory or irrelevant (NOISE) information. The claim is generic yet correct, offering low informational gain due to lack of detail."
            ]
        },
        "cfg": {
            "summary": "Reads and validates disc structure format 0x10, extracts specific header fields, computes related values, and cleans up allocated memory before returning results.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function reads disc structure format 0x10, extracts header fields, computes values, and frees allocated memory, all of which are supported by the code. It omits mention of the initial profile check that determines if a supported DVD type is loaded and the conditional checks on reply length and read result, but over 80% of the claims align with the actual behavior.",
                "The summary correctly notes reading and validating disc structure format 0x10, extracting header fields, computing values, and freeing memory, which aligns with the source code's actions. However, it does not explicitly cover the core purpose of determining and returning physical format information for certain DVD profiles, omitting specifics like profile checking, mapping disk category to book names, and early-return logic on unsupported media. Secondary behaviors such as error logging for short replies are also missing.",
                "The summary accurately reflects the core functionality: reading disc structure format 0x10, extracting header fields, computing derived values, and freeing allocated memory. All claims align with the source code's main logic without contradictions. However, while correct, the description is somewhat generic and omits specific details such as validation of reply length and restriction to certain disc profiles, limiting its informational value."
            ]
        },
        "comment": {
            "summary": "Retrieves physical format information of a disc in the drive, including disk category, book name, version, layer count, and block count.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary accurately describes the function's purpose and key outputs, including disk category, book name, version, layer count, and block count, all of which match the specific assignments in the source code. There are no inaccurate or irrelevant claims, and all are grounded in the function's semantics.",
                "The summary accurately states the core purpose of obtaining physical format information for a disc in the drive and correctly lists key outputs such as disk category, book name, version, layer count, and block count. However, it omits critical behavior-specific details from the source, such as the conditional profile check to ensure a [HD] DVD-R[W] is loaded, the call to mmc_read_disc_structure, handling of insufficient reply length, error logging, and memory cleanup. These omissions mean secondary semantics are minimally covered despite the core being correctly described.",
                "The summary is accurate regarding the primary purpose of retrieving physical format information and correctly identifies key outputs such as disk category, book name, version, layer count, and block count. There are no contradictions with the code, and no irrelevant noise is present. However, the claim is generic and lacks specific implementation details such as conditions for supported profiles or handling of read errors, resulting in only moderate informational gain."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5026800,
    "strip_function_name": "sub_4CB3F0",
    "strip_decompiled_code": "__int64 __fastcall sub_4CB3F0(char *s, unsigned int a2)\n{\n  __int16 v2; // bp\n  size_t v3; // rax\n  size_t v4; // rax\n  size_t v5; // rax\n  size_t v6; // rax\n  unsigned int v8[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  v8[0] = a2;\n  v2 = sub_4CAE00(s, v8, 1);\n  if ( (v2 & 0x24) == 0 )\n  {\n    v3 = strlen(s);\n    sprintf(\n      &s[v3],\n      \"user::%c%c%c\\n\",\n      (v8[0] & 0x100) == 0 ? 45 : 114,\n      (v8[0] & 0x80) == 0 ? 45 : 119,\n      (v8[0] & 0x40) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 0x412) == 0 )\n  {\n    v4 = strlen(s);\n    sprintf(\n      &s[v4],\n      \"group::%c%c%c\\n\",\n      (v8[0] & 0x20) == 0 ? 45 : 114,\n      (v8[0] & 0x10) == 0 ? 45 : 119,\n      (v8[0] & 8) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 9) == 0 )\n  {\n    v5 = strlen(s);\n    sprintf(\n      &s[v5],\n      \"other::%c%c%c\\n\",\n      (v8[0] & 4) == 0 ? 45 : 114,\n      (v8[0] & 2) == 0 ? 45 : 119,\n      (v8[0] & 1) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 0x180) != 0 && (v2 & 0x200) == 0 )\n  {\n    v6 = strlen(s);\n    sprintf(\n      &s[v6],\n      \"mask::%c%c%c\\n\",\n      (v8[0] & 0x20) == 0 ? 45 : 114,\n      (v8[0] & 0x10) == 0 ? 45 : 119,\n      (v8[0] & 8) == 0 ? 45 : 120);\n  }\n  return 1LL;\n}\n",
    "function_name": "aaip_add_acl_st_mode",
    "decompiled_code": "__int64 __fastcall aaip_add_acl_st_mode(char *a1, mode_t a2, int flag)\n{\n  __int16 v3; // bp\n  size_t v4; // rax\n  size_t v5; // rax\n  size_t v6; // rax\n  size_t v7; // rax\n  mode_t st_mode[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  st_mode[0] = a2;\n  v3 = aaip_cleanout_st_mode(a1, st_mode, 1);\n  if ( (v3 & 0x24) == 0 )\n  {\n    v4 = strlen(a1);\n    sprintf(\n      &a1[v4],\n      &byte_51F243[22],\n      (st_mode[0] & 0x100) == 0 ? 45 : 114,\n      (st_mode[0] & 0x80) == 0 ? 45 : 119,\n      (st_mode[0] & 0x40) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 0x412) == 0 )\n  {\n    v5 = strlen(a1);\n    sprintf(\n      &a1[v5],\n      &byte_51F243[36],\n      (st_mode[0] & 0x20) == 0 ? 45 : 114,\n      (st_mode[0] & 0x10) == 0 ? 45 : 119,\n      (st_mode[0] & 8) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 9) == 0 )\n  {\n    v6 = strlen(a1);\n    sprintf(\n      &a1[v6],\n      &byte_51F243[51],\n      (st_mode[0] & 4) == 0 ? 45 : 114,\n      (st_mode[0] & 2) == 0 ? 45 : 119,\n      (st_mode[0] & 1) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 0x180) != 0 && (v3 & 0x200) == 0 )\n  {\n    v7 = strlen(a1);\n    sprintf(\n      &a1[v7],\n      &byte_51F243[66],\n      (st_mode[0] & 0x20) == 0 ? 45 : 114,\n      (st_mode[0] & 0x10) == 0 ? 45 : 119,\n      (st_mode[0] & 8) == 0 ? 45 : 120);\n  }\n  return 1LL;\n}\n",
    "source_code": "int aaip_add_acl_st_mode(char *acl_text, mode_t st_mode, int flag)\n{\n char *wpt;\n int tag_types= 0;\n\n tag_types = aaip_cleanout_st_mode(acl_text, &st_mode, 1);\n if(!(tag_types & (4 | 32))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"user::%c%c%c\\n\",\n           st_mode & S_IRUSR ? 'r' : '-',\n           st_mode & S_IWUSR ? 'w' : '-',\n           st_mode & S_IXUSR ? 'x' : '-');\n }\n if(!(tag_types & (2 | 16 | 1024))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"group::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n if(!(tag_types & (1 | 8))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"other::%c%c%c\\n\",\n         st_mode & S_IROTH ? 'r' : '-',\n         st_mode & S_IWOTH ? 'w' : '-',\n         st_mode & S_IXOTH ? 'x' : '-');\n }\n if((tag_types & (128 | 256)) && !(tag_types & 512)) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"mask::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n return(1); \n}",
    "comment": "Adds entries for user, group, other, and mask permissions to an ACL string based on the provided `mode_t` and existing ACL tags.",
    "hext5_sum": "push a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Generates a formatted error message string with user , group , and file permissions based on the provided error code .\n",
    "cpbcs_sum": "Formats and prints a string representation of a specified value into a buffer, including its type and flags based on provided flags.\n",
    "misum_sum": "Formats and prints a time value in a XorrisO structure with optional time zone and additional flags for certain byte usage.\n",
    "decom_sum": "Formats and appends user, group, other, and mask permission strings to a buffer based on access control bits from the input.",
    "cfg_sum": "Formats and appends user, group, other, and mask permission strings to the buffer based on evaluated access control flag bits.",
    "work_score": {
        "decom": {
            "summary": "Formats and appends user, group, other, and mask permission strings to a buffer based on access control bits from the input.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly captures the primary behavior of the function: it formats and appends permission strings for user, group, other, and mask entries to the provided buffer based on the `st_mode` access bits, which matches the code's use of `sprintf` calls conditioned on tag bit checks. While the summary omits details about the conditional logic that prevents certain additions and the call to `aaip_cleanout_st_mode`, it contains no inaccuracies and all of its claims are aligned with the function's semantics. The proportion of accurate claims is very high.",
                "The summary accurately captures the core purpose: appending formatted permission strings for user, group, other, and mask based on the mode bits. This aligns with the function's conditional appends to acl_text according to tag_types and st_mode. Secondary details \u2014 such as the conditions that prevent adding certain entries, or the use of aaip_cleanout_st_mode to preprocess \u2014 are missing, so coverage is solid for the core action but lacks completeness on behavior-critical branches.",
                "The summary correctly captures the core purpose of the function: appending formatted user, group, other, and mask permission strings to a buffer depending on permission bits in the st_mode. This aligns with the source code, which conditionally appends each ACL entry based on tag_types and st_mode flags. Although the summary omits the specific conditions for when each string is appended and the role of aaip_cleanout_st_mode, it is fully accurate and focused with no misleading or irrelevant claims, yielding moderate gain due to being concise but not deeply detailed."
            ]
        },
        "cfg": {
            "summary": "Formats and appends user, group, other, and mask permission strings to the buffer based on evaluated access control flag bits.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately captures the function's behavior of formatting and appending permission strings for user, group, other, and mask entries based on specific tag bit checks and mode flags. There are no contradictory or irrelevant claims, and the description aligns well with the source code's logic and output construction without omitting key behaviors.",
                "The summary accurately describes the core functionality: appending formatted user, group, other, and mask permission strings to the ACL text based on flag bits from st_mode and tag_types, which matches the source code logic. It covers the main domain-specific purpose but omits secondary details such as the checks for specific tag type bit masks before appending, the use of aaip_cleanout_st_mode to update st_mode and tag_types, and the explicit permission character mapping (r/w/x) from mode bits. These omissions mean the coverage of other behavior-critical semantics is limited.",
                "The summary accurately captures the core purpose of the function: appending user, group, other, and mask permission strings to the ACL text based on evaluated tag bits from st_mode. It omits mention of the initial cleanup call and the specific conditions under which each string is appended, but there are no incorrect claims. The description is concise but somewhat generic, providing moderate insight without extraneous noise or fatal inaccuracies."
            ]
        },
        "comment": {
            "summary": "Adds entries for user, group, other, and mask permissions to an ACL string based on the provided `mode_t` and existing ACL tags.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function adds entries for user, group, other, and mask permissions to the ACL string depending on the provided mode_t and existing ACL tags. These elements match the code's behavior, where conditional checks on tag_types determine whether to append specific permission entries for each category. All claims are accurate and align closely with the source code semantics, with no contradictions or irrelevant content.",
                "The summary correctly identifies the core function of adding user, group, other, and mask ACL entries derived from the given mode and conditional on existing ACL tags, which matches the source code's primary purpose. It covers the main domain action with clear specificity but lacks mention of secondary aspects such as the specific bitmask checks used to decide when to append each ACL entry, the formatting of permissions into rwx strings, and the helper function call to clean out existing mode entries. These omissions mean the coverage of behavior-critical semantics is limited beyond the core purpose.",
                "The summary correctly captures the primary purpose of the function: appending user, group, other, and mask permission entries to an ACL string depending on the provided mode bits and the existing tag types. All claims are accurate and directly reflect the code's behavior, with no contradictions or irrelevant noise. The description is concise but lacks deeper detail, such as the specific conditions under which each entry is added. This results in moderate gain from correct but high-level coverage."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585619424,
    "strip_function_name": "sub_FFFFFFFF81675DE0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF81675DE0(unsigned int *a1, __int64 a2)\n{\n  int v2; // edx\n  unsigned __int64 result; // rax\n  unsigned int *v6; // r8\n  int *v7; // rdi\n  unsigned __int64 v8; // rcx\n  unsigned int v9; // esi\n  int v10; // eax\n  __int64 v11; // r9\n  __int64 v12; // rax\n  _QWORD *v13; // rax\n\n  v2 = -1;\nLABEL_2:\n  while ( 1 )\n  {\n    result = sub_FFFFFFFF812BE5D0((__int64)&qword_FFFFFFFF81CB6E08, 0x40uLL, v2 + 1);\n    v2 = result;\n    if ( dword_FFFFFFFF81CB7EA8 <= (unsigned int)result )\n      return result;\n    v6 = &a1[2 * (unsigned int)result];\n    v7 = (int *)(qword_FFFFFFFF81CB6720[(unsigned int)result] + 59696);\n    v8 = *((_QWORD *)v6 + 9);\n    if ( v8 < v8 + *a1 )\n    {\n      v9 = 0;\n      while ( 1 )\n      {\n        v10 = *v7;\n        if ( (*v7 & 1) != 0 )\n        {\nLABEL_9:\n          _mm_pause();\n        }\n        else\n        {\n          while ( 1 )\n          {\n            v11 = *(_QWORD *)(v8 + 96);\n            if ( *v7 != v10 )\n              break;\n            v12 = v9++;\n            v13 = (_QWORD *)(a2 + 16 * v12);\n            v13[1] += *(_QWORD *)(v8 + 104);\n            *v13 += v11;\n            v8 += *(unsigned __int16 *)(v8 + 90);\n            if ( v8 >= *((_QWORD *)v6 + 9) + (unsigned __int64)*a1 )\n              goto LABEL_2;\n            v10 = *v7;\n            if ( (*v7 & 1) != 0 )\n              goto LABEL_9;\n          }\n        }\n      }\n    }\n  }\n}\n",
    "function_name": "get_counters",
    "decompiled_code": "unsigned __int64 __fastcall get_counters(unsigned int *a1, __int64 a2)\n{\n  int v2; // edx\n  unsigned __int64 result; // rax\n  unsigned int *v6; // r8\n  int *v7; // rdi\n  unsigned __int64 v8; // rcx\n  unsigned int v9; // esi\n  int v10; // eax\n  __int64 v11; // r9\n  __int64 v12; // rax\n  _QWORD *v13; // rax\n\n  v2 = -1;\nLABEL_2:\n  while ( 1 )\n  {\n    result = find_next_bit((__int64)cpu_possible_mask, 0x40uLL, v2 + 1);\n    v2 = result;\n    if ( nr_cpu_ids <= (unsigned int)result )\n      return result;\n    v6 = &a1[2 * (unsigned int)result];\n    v7 = (int *)(_per_cpu_offset[(unsigned int)result] + 59696);\n    v8 = *((_QWORD *)v6 + 9);\n    if ( v8 < v8 + *a1 )\n    {\n      v9 = 0;\n      while ( 1 )\n      {\n        v10 = *v7;\n        if ( (*v7 & 1) != 0 )\n        {\nLABEL_9:\n          _mm_pause();\n        }\n        else\n        {\n          while ( 1 )\n          {\n            v11 = *(_QWORD *)(v8 + 96);\n            if ( *v7 != v10 )\n              break;\n            v12 = v9++;\n            v13 = (_QWORD *)(a2 + 16 * v12);\n            v13[1] += *(_QWORD *)(v8 + 104);\n            *v13 += v11;\n            v8 += *(unsigned __int16 *)(v8 + 90);\n            if ( v8 >= *((_QWORD *)v6 + 9) + (unsigned __int64)*a1 )\n              goto LABEL_2;\n            v10 = *v7;\n            if ( (*v7 & 1) != 0 )\n              goto LABEL_9;\n          }\n        }\n      }\n    }\n  }\n}\n",
    "source_code": "int get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint cpu = t->cpu_id;\n\tunsigned long long msr;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(stderr, \"Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tt->tsc = rdtsc();\t/* we are running on local CPU of interest */\n\n\tif (has_aperf) {\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\t\tif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\n\t\t\treturn -4;\n\t}\n\n\tif (do_smi) {\n\t\tif (get_msr(cpu, MSR_SMI_COUNT, &msr))\n\t\t\treturn -5;\n\t\tt->smi_count = msr & 0xFFFFFFFF;\n\t}\n\tif (extra_delta_offset32) {\n\t\tif (get_msr(cpu, extra_delta_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_delta32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_delta_offset64)\n\t\tif (get_msr(cpu, extra_delta_offset64, &t->extra_delta64))\n\t\t\treturn -5;\n\n\tif (extra_msr_offset32) {\n\t\tif (get_msr(cpu, extra_msr_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_msr32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_msr_offset64)\n\t\tif (get_msr(cpu, extra_msr_offset64, &t->extra_msr64))\n\t\t\treturn -5;\n\n\t/* collect core counters only for 1st thread in core */\n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\n\t\t\treturn -6;\n\t\tif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t}\n\n\tif (do_snb_cstates)\n\t\tif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\n\t\t\treturn -8;\n\n\tif (do_dts) {\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn -9;\n\t\tc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\n\n\t/* collect package counters only for 1st core in package */\n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\n\t\t\treturn -9;\n\t\tif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\treturn -10;\n\t}\n\tif (do_snb_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\n\t\t\treturn -11;\n\t\tif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\n\t\t\treturn -12;\n\t}\n\tif (do_c8_c9_c10) {\n\t\tif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\n\t\t\treturn -13;\n\t}\n\tif (do_rapl & RAPL_PKG) {\n\t\tif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_CORES) {\n\t\tif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\n\t\t\treturn -14;\n\t\tp->energy_cores = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\n\t\t\treturn -15;\n\t\tp->energy_dram = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->energy_gfx = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_PKG_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_dram_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_ptm) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn -17;\n\t\tp->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\treturn 0;\n}",
    "comment": "Aggregates packet and byte counters from multiple CPU entries into a single counter array based on the provided old counters.",
    "hext5_sum": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
    "bint5_sum": "Inserts an ` xfrm_state_afinfo ` structure into a hash table for each CPU in the specified network namespace .\n",
    "cpbcs_sum": "Updates the total number of sockets in the connection tracking map for a specified network context, incrementing the count for each online CPU.\n",
    "misum_sum": "Initializes the random number generator across network configurations across multiple CPUs while ensuring the hash is within the specified network namespace.\n",
    "decom_sum": "Iterates over indexed data blocks, accumulating values into an output array while synchronizing on a lock variable and skipping locked entries.",
    "cfg_sum": "Iterates through indexed data structures, aggregates numeric fields into an output buffer, and returns the next index when bounds or verification conditions are met.",
    "work_score": {
        "decom": {
            "summary": "Iterates over indexed data blocks, accumulating values into an output array while synchronizing on a lock variable and skipping locked entries.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes iteration over indexed data blocks with locking and skipping locked entries, which is entirely unrelated to the provided function. The source code deals with reading CPU and package MSR counters under various conditions, without any loop over data blocks or lock synchronization. All claims in the summary are inaccurate and do not reflect the actual semantics of the code.",
                "The summary describes iterating over data blocks with locking, which is unrelated to the source code's actual purpose of migrating to a specific CPU and reading various MSR counters for thread, core, and package data with conditional behaviors and error handling. No accurate claims match the core domain action, and the core purpose is completely uncovered.",
                "The summary describes iterating over data blocks with locking and skipping locked entries, which does not match the source code\u2019s actual behavior of migrating to a CPU and reading various MSR registers into thread, core, and package data structures. This is a complete mismatch with the primary purpose and I/O, making it a fatal inaccuracy on the core functionality."
            ]
        },
        "cfg": {
            "summary": "Iterates through indexed data structures, aggregates numeric fields into an output buffer, and returns the next index when bounds or verification conditions are met.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes iteration over indexed data structures, aggregation of numeric fields, and returning a next index when certain conditions are met, which does not match the actual function\u2019s behavior. The source code reads various hardware MSR counters based on flags, populates multiple structures, and returns specific error codes or zero without performing iteration over indexed structures or aggregation into an output buffer. All claims in the summary are inaccurate and unrelated to the function's actual semantics.",
                "The summary's claims about iterating through indexed data, aggregating numeric fields, and returning the next index do not match the source code's actual behavior of migrating to a specified CPU, reading various MSR registers to populate thread, core, and package counters, handling feature flags, and returning error codes or zero based on conditions. The core purpose of collecting CPU, core, and package performance/state counters is entirely missing, and no accurate claims are present.",
                "The summary makes inaccurate claims about iteration over indexed data structures, aggregation of numeric fields into an output buffer, and returning the next index, none of which match the source code\u2019s primary purpose of reading MSR registers for a specific CPU and populating struct fields with hardware counter and temperature data. These are severe FATAL inaccuracies concerning core domain semantics, leading to an unusable description."
            ]
        },
        "comment": {
            "summary": "Aggregates packet and byte counters from multiple CPU entries into a single counter array based on the provided old counters.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes aggregating packet and byte counters from multiple CPU entries, which is unrelated to the source code. The function in the source collects MSR-based CPU, core, and package counters and returns error codes under various conditions. None of the claims in the summary accurately reflect the actual semantics, resulting in a complete mismatch.",
                "The summary incorrectly describes the function as aggregating packet and byte counters from CPUs, which is unrelated to the actual code behavior. The source code collects various CPU, core, and package counters via MSR reads, handling multiple hardware-related metrics and conditional flags. No accurate claim in the summary covers the core purpose, leading to a complete mismatch with the function's semantics.",
                "The summary claims aggregation of packet and byte counters across CPUs, but the source code does not perform any packet/byte counting or aggregation. Instead, it reads various MSRs and stores CPU, core, and package counters for performance and energy metrics. This is a severe factual contradiction about the primary purpose and I/O, making the description unusable."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 491552,
    "strip_function_name": "sub_78020",
    "strip_decompiled_code": "__int64 __fastcall sub_78020(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, int a6)\n{\n  __int64 v6; // rax\n  double *v7; // rax\n  int v8; // r8d\n  int v9; // edi\n  __int64 result; // rax\n  _DWORD *v11; // rdx\n  int v12; // esi\n  int v13; // esi\n  __int64 i; // rdx\n  __int64 v15; // [rsp+10h] [rbp-18h]\n  _DWORD *v16; // [rsp+18h] [rbp-10h]\n\n  v6 = a1 + 48;\n  if ( *(char *)a1 < 0 )\n  {\n    v16 = a4;\n    v15 = a3;\n    v6 = ALTVEC_DATAPTR_OR_NULL(a1);\n    a4 = v16;\n    a3 = v15;\n  }\n  if ( v6 )\n    Rf_error((unsigned int)\"method should only handle unexpanded vectors\", a2, a3, (_DWORD)a4, a5, a6);\n  v7 = *(double **)(a1 + 32);\n  v8 = (int)v7[8];\n  v9 = (int)v7[7];\n  result = (unsigned int)(int)v7[6] - a2;\n  if ( result > a3 )\n    result = a3;\n  if ( v8 == 1 )\n  {\n    if ( result > 0 )\n    {\n      v13 = v9 + a2;\n      for ( i = 0LL; i != result; ++i )\n        a4[i] = v13 + i;\n    }\n  }\n  else\n  {\n    if ( v8 != -1 )\n      Rf_error((unsigned int)\"compact sequences with increment %d not supported yet\", v8, a3, (_DWORD)a4, v8, a6);\n    if ( result > 0 )\n    {\n      v11 = &a4[result];\n      v12 = v9 - a2;\n      do\n        *a4++ = v12--;\n      while ( a4 != v11 );\n    }\n  }\n  return result;\n}\n",
    "function_name": "compact_intseq_Get_region",
    "decompiled_code": "__int64 __fastcall compact_intseq_Get_region(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        _DWORD *a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14)\n{\n  __int64 v14; // rax\n  double *v15; // rax\n  __int64 v16; // r8\n  int v17; // edi\n  __int64 result; // rax\n  _DWORD *v19; // rdx\n  int v20; // esi\n  int v21; // esi\n  __int64 i; // rdx\n  __int64 v23; // [rsp+10h] [rbp-18h]\n  _DWORD *v24; // [rsp+18h] [rbp-10h]\n\n  v14 = a1 + 48;\n  if ( *(char *)a1 < 0 )\n  {\n    v24 = a4;\n    v23 = a3;\n    v14 = ALTVEC_DATAPTR_OR_NULL(a1);\n    a4 = v24;\n    a3 = v23;\n  }\n  if ( v14 )\n    Rf_error(\n      (unsigned int)\"method should only handle unexpanded vectors\",\n      a2,\n      a3,\n      (__int64)a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      a12,\n      a13,\n      a14);\n  v15 = *(double **)(a1 + 32);\n  v16 = (unsigned int)(int)v15[8];\n  v17 = (int)v15[7];\n  result = (unsigned int)(int)v15[6] - a2;\n  if ( result > a3 )\n    result = a3;\n  if ( (_DWORD)v16 == 1 )\n  {\n    if ( result > 0 )\n    {\n      v21 = v17 + a2;\n      for ( i = 0LL; i != result; ++i )\n        a4[i] = v21 + i;\n    }\n  }\n  else\n  {\n    if ( (_DWORD)v16 != -1 )\n      Rf_error(\n        (unsigned int)\"compact sequences with increment %d not supported yet\",\n        (unsigned int)v16,\n        a3,\n        (__int64)a4,\n        v16,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14);\n    if ( result > 0 )\n    {\n      v19 = &a4[result];\n      v20 = v17 - a2;\n      do\n        *a4++ = v20--;\n      while ( a4 != v19 );\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic R_xlen_t\ncompact_intseq_Get_region(SEXP sx, R_xlen_t i, R_xlen_t n, int *buf)\n{\n    /* should not get here if x is already expanded */\n    CHECK_NOT_EXPANDED(sx);\n\n    SEXP info = COMPACT_SEQ_INFO(sx);\n    R_xlen_t size = COMPACT_INTSEQ_INFO_LENGTH(info);\n    R_xlen_t n1 = COMPACT_INTSEQ_INFO_FIRST(info);\n    int inc = COMPACT_INTSEQ_INFO_INCR(info);\n\n    R_xlen_t ncopy = size - i > n ? n : size - i;\n    if (inc == 1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 + k + i);\n\treturn ncopy;\n    }\n    else if (inc == -1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 - k - i);\n\treturn ncopy;\n    }\n    else\n\terror(\"compact sequences with increment %d not supported yet\", inc);\n}",
    "comment": "Extracts a specified region from a compact integer sequence into a buffer, handling both increasing and decreasing increments.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Retrieves a specified number of sequential double values from a compact sequence in R , based on starting index and increment .\n",
    "cpbcs_sum": "Generates a specified number of sequential integers from a buffer using the provided command, handling negative values and updating the stream's position.\n",
    "misum_sum": "Retrieves a range of double values from a compact sequence and stores it in the provided buffer if not supported by its data.\n",
    "decom_sum": "Generates a sequence of integer indices from vector metadata, supporting increments of 1 or -1, and throws errors for unsupported or expanded vectors.",
    "cfg_sum": "Generates a sequence of integer indices from vector metadata, validating constraints and raising errors for unsupported increments or unexpanded vectors.",
    "work_score": {
        "decom": {
            "summary": "Generates a sequence of integer indices from vector metadata, supporting increments of 1 or -1, and throws errors for unsupported or expanded vectors.",
            "score": [
                0.6,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly captures that the function generates integer sequences using metadata and supports increments of 1 or -1, and that it throws errors for unsupported increments. However, it inaccurately states that it throws errors for expanded vectors; in the source code, expanded vectors are prevented by a check, not handled with an error. This introduces one clear inaccuracy, with most other claims being correct, placing accuracy between 50-80%.",
                "The summary correctly identifies that the function generates integer sequences from vector metadata and supports increments of 1 or -1, and notes the error for unsupported increments, which aligns with the code's semantics. However, it inaccurately claims the function throws errors for expanded vectors \u2014 in reality, expanded vectors are prevented via a check macro rather than triggering an error here. The core purpose of retrieving a region of a compact integer sequence is covered with reasonable specificity, but secondary coverage misses details like calculation of ncopy and direct population of the provided buffer.",
                "The summary correctly captures the function\u2019s purpose of generating integer sequences from metadata and supporting increments of 1 or -1, with errors for unsupported increments. However, it inaccurately states that it throws errors for expanded vectors, whereas the code uses a `CHECK_NOT_EXPANDED` macro likely to assert that the vector is not expanded, which is not the same as throwing an error for being expanded. This is a minor semantic mismatch, and the rest of the claims are accurate but fairly generic, offering moderate value. Noise is minimal and no fatal errors target the core purpose."
            ]
        },
        "cfg": {
            "summary": "Generates a sequence of integer indices from vector metadata, validating constraints and raising errors for unsupported increments or unexpanded vectors.",
            "score": [
                1.0,
                0.3,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function generates a sequence of integers based on vector metadata and raises an error for unsupported increments, which matches the code's behavior for non-\u00b11 increments. It also accurately notes that it checks a constraint (unexpanded vectors) using CHECK_NOT_EXPANDED. All these points align with the source code, with no inaccurate or irrelevant claims present.",
                "The summary correctly identifies that the function uses vector metadata to generate an integer sequence and that it validates constraints by checking expansion status, raising an error for unsupported increments, which matches the code's error branch. However, it lacks the specific core detail that the function fills a provided buffer with part of the compact integer sequence starting at a given index and up to a specified length. Without explicitly covering the buffer population and index-based region logic, coverage of the core purpose is incomplete despite some accurate secondary behavior mention.",
                "The summary captures the primary purpose accurately, noting it uses vector metadata to generate integer sequences and raises errors for unsupported increments or when the vector is unexpanded. These are specific and correct observations grounded in the code: it validates expansion state, extracts size, first element, and increment from metadata, and handles inc == 1 or inc == -1. However, the phrase 'integer indices' is slightly generalized compared to the code's integer values, and 'validating constraints' is vague. There is no clear inaccurate or contradictory claim, and noise level is low, but detail is limited, so the gain is moderate."
            ]
        },
        "comment": {
            "summary": "Extracts a specified region from a compact integer sequence into a buffer, handling both increasing and decreasing increments.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function extracts a specified region from a compact integer sequence into a buffer and supports both increasing and decreasing increments. These claims align with the source code, which calculates the number of elements to copy and handles increments of 1 or -1. Although the summary omits the unsupported increment case error handling, all stated claims are accurate and verifiable against the code.",
                "The summary accurately captures the core purpose of retrieving a specified range from a compact integer sequence into a buffer and notes handling of both increment values 1 and -1, which aligns with the code's branching for increasing and decreasing sequences. However, it omits secondary details such as the explicit check to ensure the sequence is not expanded, the calculation of the number of elements to copy, and the error case when an unsupported increment is encountered. These missing error-handling and limit-computation details reduce completeness.",
                "The summary correctly captures the core function behavior: it extracts a region from a compact integer sequence into a buffer and supports both increasing and decreasing increments. This matches the source code logic for handling inc == 1 and inc == -1 cases, and returning the number copied. No inaccuracies are present, and while the description is accurate, it is fairly generic and lacks details such as bounds calculation or error handling for unsupported increments, limiting the information gain."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 427568,
    "strip_function_name": "sub_68630",
    "strip_decompiled_code": "_BOOL8 __fastcall sub_68630(__int64 a1, int a2)\n{\n  if ( !a1 || (*(_BYTE *)(a1 + 172) & 4) == 0 )\n  {\n    if ( (a2 & 0xFFFFFFDF) - 65 > 0x19\n      && a2 != 95\n      && a2 != 58\n      && (unsigned int)(a2 - 192) > 0x16\n      && (unsigned int)(a2 - 216) > 0x1E\n      && (unsigned int)(a2 - 248) > 0x207\n      && (unsigned int)(a2 - 880) > 0xD\n      && (unsigned int)(a2 - 895) > 0x1C80\n      && (unsigned int)(a2 - 8204) > 1\n      && (unsigned int)(a2 - 8304) > 0x11F\n      && (unsigned int)(a2 - 11264) > 0x3EF\n      && (unsigned int)(a2 - 12289) > 0xA7FE\n      && (unsigned int)(a2 - 63744) > 0x4CF\n      && (unsigned int)(a2 - 65008) > 0x20D )\n    {\n      return (unsigned int)(a2 - 0x10000) <= 0xDFFFF;\n    }\n    return 1LL;\n  }\n  if ( a2 <= 255 )\n  {\n    if ( (a2 & 0xFFFFFFDF) - 65 > 0x19\n      && (unsigned int)(a2 - 192) > 0x16\n      && (unsigned int)(a2 - 216) > 0x1E\n      && a2 <= 247 )\n    {\n      return (a2 == 58) | (unsigned __int8)(a2 == 95);\n    }\n    return 1LL;\n  }\n  return (unsigned int)xmlCharInRange((unsigned int)a2, &xmlIsBaseCharGroup)\n      || (unsigned int)(a2 - 19968) <= 0x51A5\n      || a2 == 12295\n      || (unsigned int)(a2 - 12321) <= 8;\n}\n",
    "function_name": "xmlIsDocNameStartChar",
    "decompiled_code": "int __fastcall xmlIsDocNameStartChar(xmlDocPtr doc, int c)\n{\n  __int64 v2; // rax\n\n  if ( !doc || (doc->properties & 4) == 0 )\n  {\n    if ( (c & 0xFFFFFFDF) - 65 > 0x19\n      && c != 95\n      && c != 58\n      && (unsigned int)(c - 192) > 0x16\n      && (unsigned int)(c - 216) > 0x1E\n      && (unsigned int)(c - 248) > 0x207\n      && (unsigned int)(c - 880) > 0xD\n      && (unsigned int)(c - 895) > 0x1C80\n      && (unsigned int)(c - 8204) > 1\n      && (unsigned int)(c - 8304) > 0x11F\n      && (unsigned int)(c - 11264) > 0x3EF\n      && (unsigned int)(c - 12289) > 0xA7FE\n      && (unsigned int)(c - 63744) > 0x4CF\n      && (unsigned int)(c - 65008) > 0x20D )\n    {\n      return (unsigned int)(c - 0x10000) <= 0xDFFFF;\n    }\n    goto LABEL_24;\n  }\n  if ( c <= 255 )\n  {\n    if ( (c & 0xFFFFFFDF) - 65 > 0x19 && (unsigned int)(c - 192) > 0x16 && (unsigned int)(c - 216) > 0x1E && c <= 247 )\n    {\n      LODWORD(v2) = c == 58 || c == 95;\n      return v2;\n    }\nLABEL_24:\n    LODWORD(v2) = 1;\n    return v2;\n  }\n  if ( xmlCharInRange__internal_alias(c, &xmlIsBaseCharGroup) || (unsigned int)(c - 19968) <= 0x51A5 || c == 12295 )\n    LODWORD(v2) = 1;\n  else\n    return (unsigned int)(c - 12321) <= 8;\n  return v2;\n}\n",
    "source_code": "\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}",
    "comment": "Determines if a character is a valid starting character for an XML document name based on XML-1.0 specifications or old document properties.",
    "hext5_sum": "returns true iff pnote1 overlaps or adjoins pnote2.",
    "bint5_sum": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties .\n",
    "cpbcs_sum": "Validates whether a character can be the start of an XML name based on the defined document and defined character ranges.\n",
    "misum_sum": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties.\n",
    "decom_sum": "Checks if a given Unicode codepoint is a valid XML name character, considering ASCII, extended ranges, and XML base character rules.",
    "cfg_sum": "Checks whether a given character code is valid as a base name character according to ASCII and Unicode ranges, considering specific context flags.",
    "work_score": {
        "decom": {
            "summary": "Checks if a given Unicode codepoint is a valid XML name character, considering ASCII, extended ranges, and XML base character rules.",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function checks for a valid XML name character rather than specifically a valid XML name *start* character, which is the function\u2019s purpose. While it correctly mentions Unicode codepoint ranges, ASCII, and extended ranges, this misclassification of the character type is a critical semantic error. Only about half of the content aligns accurately with the source code\u2019s actual logic.",
                "The summary correctly describes checking a Unicode codepoint against XML naming rules, which matches the core purpose of determining if a character is a valid start character for an XML name. However, it inaccurately generalizes to \"XML name character\" rather than \"XML name start character\" and omits key conditional logic tied to document properties (XML_DOC_OLD10) and distinct rule sets. Secondary details like separate old/new checks and specific character class handling are missing.",
                "The summary inaccurately states that the function checks for any valid XML name character, whereas the source code specifically checks for valid *start* characters of an XML name. This is a FATAL error affecting the primary purpose. While the summary generically mentions ASCII, extended ranges, and XML base character rules, which loosely align with the code's checks, the misrepresentation of the core behavior severely undermines trustworthiness and usability."
            ]
        },
        "cfg": {
            "summary": "Checks whether a given character code is valid as a base name character according to ASCII and Unicode ranges, considering specific context flags.",
            "score": [
                0.5,
                0.4,
                0.2
            ],
            "reason": [
                "The summary captures the general idea of checking a character code against ASCII and Unicode ranges, but it inaccurately describes the function's purpose as validating a 'base name character'. The code specifically checks for valid starting characters of a document name per XML 1.0 rules, with different ranges depending on a property flag. Mention of 'specific context flags' is reasonable, but lacks precision in describing the XML_DOC_OLD10 property behavior. Overall, while partially accurate, the summary omits key semantic detail and mislabels the purpose, leading to mixed reliability.",
                "The summary correctly identifies that the function checks a character code against certain ASCII and Unicode ranges with conditional logic based on context flags, which aligns with the source code\u2019s purpose. However, it misstates the domain specificity: the function checks for valid start characters for XML document names per XML 1.0 rules, not generic 'base name characters.' It omits important details such as the explicit difference in checks depending on whether a document uses old XML-1.0 rules and the exact conditions for returning 1 or 0. Core purpose coverage is partial due to vague and slightly inaccurate terminology, and secondary behaviors (branching, XML-specific rules) are minimally captured.",
                "The summary incorrectly states that the function checks for a 'base name character', while the source code logic specifically tests for valid starting characters for a document name per XML specification. This is a FATAL in the primary purpose since the starting character constraint is fundamental to the code's domain behavior. Though it vaguely notes ASCII/Unicode ranges and context flags, these are generic and low-info, with no accurate, detailed coverage of the precise XML character production rules. The most severe issue is the incorrect primary purpose description."
            ]
        },
        "comment": {
            "summary": "Determines if a character is a valid starting character for an XML document name based on XML-1.0 specifications or old document properties.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function checks if a character is a valid starting character for an XML document name and that it uses XML-1.0 specifications or an older check based on document properties. These descriptions align closely with the code's semantics, and there are no inaccurate or irrelevant claims. The only shortcoming is that it omits specific Unicode range checks, but all given claims are accurate.",
                "The summary accurately describes the core purpose: checking if a character is a valid starting character for an XML name according to XML-1.0 rules or old document property rules based on the doc pointer and conditions. It captures the distinction between updated and old XML-1.0 checks, covering the primary domain action. However, it omits detailed conditions such as specific character ranges, the use of IS_LETTER in the old rules, and exact character categories. These omissions reduce coverage of secondary behavior-critical details.",
                "The summary captures the primary purpose of determining if a character is a valid start for an XML name and mentions XML-1.0 specifications and a distinction for old document properties, which aligns with the code\u2019s conditional paths. However, it inaccurately states 'XML document name' rather than 'XML name' (e.g., element or attribute names) and omits key detail that the check depends on specific character ranges or IS_LETTER macro. This is mostly accurate but lacks depth and specificity, providing only low informational value."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578947024,
    "strip_function_name": "sub_FFFFFFFF81018DD0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81018DD0(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // r13\n  __int64 result; // rax\n  _QWORD *v4; // rax\n  __int64 v5; // rdx\n  int v6; // edx\n  int v7; // eax\n  __int64 v8; // rcx\n  __int64 v9; // rax\n\n  v1 = sub_FFFFFFFF813F1610(a1 + 152);\n  v2 = *(_QWORD *)(v1 + 264);\n  result = *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 208LL);\n  if ( dword_FFFFFFFF81C19640[result] == *(_DWORD *)v1 )\n  {\n    sub_FFFFFFFF813F1880(a1 + 152, 0LL);\n    sub_FFFFFFFF81792900(&byte_FFFFFFFF81DCE870);\n    v4 = *(_QWORD **)(v1 + 376);\n    v5 = *(_QWORD *)(v1 + 368);\n    *(_QWORD *)(v5 + 8) = v4;\n    *v4 = v5;\n    *(_QWORD *)(v1 + 368) = 0xDEAD000000000100LL;\n    *(_QWORD *)(v1 + 376) = 0xDEAD000000000200LL;\n    ++byte_FFFFFFFF81DCE870;\n    v6 = -1;\n    while ( 1 )\n    {\n      v7 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E08, 64LL, v6 + 1);\n      v6 = v7;\n      if ( v7 >= dword_FFFFFFFF81CB7EA8 )\n        break;\n      v8 = *(_QWORD *)(v2 + 224);\n      v9 = qword_FFFFFFFF81CB6720[v7];\n      if ( *(_QWORD *)(v8 + v9) == v1 )\n      {\n        *(_QWORD *)(v9 + v8) = 0LL;\n        _InterlockedDecrement((volatile signed __int32 *)(v1 + 24));\n      }\n    }\n    if ( *(_DWORD *)(v1 + 24) != 1 && !byte_FFFFFFFF81CAC4FC )\n    {\n      sub_FFFFFFFF8103BB80(\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3253LL);\n      byte_FFFFFFFF81CAC4FC = 1;\n    }\n    return sub_FFFFFFFF8112DCD0(v1);\n  }\n  else if ( !byte_FFFFFFFF81CAC4FD )\n  {\n    result = sub_FFFFFFFF8103BB80(\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3237LL);\n    byte_FFFFFFFF81CAC4FD = 1;\n  }\n  return result;\n}\n",
    "function_name": "uncore_pci_remove",
    "decompiled_code": "void __fastcall uncore_pci_remove(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  unsigned __int64 drvdata; // rbx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // r13\n  _QWORD *v17; // rax\n  __int64 *v18; // rdx\n  __int64 v19; // rsi\n  unsigned int next_bit; // eax\n  __int64 v21; // rcx\n  __int64 v22; // r8\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  __int64 v26; // rcx\n  __int64 v27; // rax\n\n  drvdata = dev_get_drvdata(a1 + 152);\n  v16 = *(_QWORD *)(drvdata + 264);\n  if ( pcibus_to_physid[*(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 208LL)] == *(_DWORD *)drvdata )\n  {\n    dev_set_drvdata(a1 + 152, 0LL, a2, a3, a4, a5, v14, v15, a8, a9);\n    raw_spin_lock((volatile signed __int16 *)&uncore_box_lock);\n    v17 = *(_QWORD **)(drvdata + 376);\n    v18 = *(__int64 **)(drvdata + 368);\n    v18[1] = (__int64)v17;\n    *v17 = v18;\n    *(_QWORD *)(drvdata + 368) = 0xDEAD000000000100LL;\n    *(_QWORD *)(drvdata + 376) = 0xDEAD000000000200LL;\n    ++uncore_box_lock;\n    LODWORD(v18) = -1;\n    while ( 1 )\n    {\n      v19 = 64LL;\n      next_bit = find_next_bit((__int64)cpu_possible_mask, 0x40uLL, (int)v18 + 1);\n      v18 = (__int64 *)next_bit;\n      if ( (int)next_bit >= nr_cpu_ids )\n        break;\n      v26 = *(_QWORD *)(v16 + 224);\n      v27 = _per_cpu_offset[next_bit];\n      if ( *(_QWORD *)(v26 + v27) == drvdata )\n      {\n        *(_QWORD *)(v27 + v26) = 0LL;\n        _InterlockedDecrement((volatile signed __int32 *)(drvdata + 24));\n      }\n    }\n    if ( *(_DWORD *)(drvdata + 24) != 1 && !_warned_29878 )\n    {\n      v19 = 3253LL;\n      warn_slowpath_null((__int64)\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3253, next_bit, v21, v22, v23);\n      _warned_29878 = 1;\n    }\n    kfree(drvdata, a2, a3, a4, a5, v24, v25, a8, a9, v19, v18, v21, v22, v23);\n  }\n  else if ( !_warned_29862 )\n  {\n    warn_slowpath_null((__int64)\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3237, v9, v10, v12, v13);\n    _warned_29862 = 1;\n  }\n}\n",
    "source_code": "\nstatic void uncore_pci_remove(struct pci_dev *pdev)\n{\n\tstruct intel_uncore_box *box = pci_get_drvdata(pdev);\n\tstruct intel_uncore_pmu *pmu = box->pmu;\n\tint cpu, phys_id = pcibus_to_physid[pdev->bus->number];\n\n\tif (WARN_ON_ONCE(phys_id != box->phys_id))\n\t\treturn;\n\n\tpci_set_drvdata(pdev, NULL);\n\n\traw_spin_lock(&uncore_box_lock);\n\tlist_del(&box->list);\n\traw_spin_unlock(&uncore_box_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (*per_cpu_ptr(pmu->box, cpu) == box) {\n\t\t\t*per_cpu_ptr(pmu->box, cpu) = NULL;\n\t\t\tatomic_dec(&box->refcnt);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&box->refcnt) != 1);\n\tkfree(box);\n}",
    "comment": "Removes an uncore PCI device, updates reference counts, and frees associated resources while ensuring proper synchronization in a multi-CPU environment.",
    "hext5_sum": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Removes a PCI device from its bus if it is the only user , otherwise drops the device .\n",
    "cpbcs_sum": "Disables a specified CPU's PMU if it is not currently active and removes the associated device.\n",
    "misum_sum": "Unregisters a hardware performance monitoring unit if it is not currently present and unregisters the associated driver link.\n",
    "decom_sum": "Unregisters and cleans up an Intel uncore performance event, updating related structures and logging errors if state inconsistencies are detected.",
    "cfg_sum": "Validates Intel uncore performance event data, unlinks and cleans related structures, updates diagnostic flags, and finalizes state restoration based on verification results.",
    "work_score": {
        "decom": {
            "summary": "Unregisters and cleans up an Intel uncore performance event, updating related structures and logging errors if state inconsistencies are detected.",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly captures the cleanup process for Intel uncore structures and notes error logging via WARN_ON_ONCE when inconsistencies occur. While it uses general terms like 'unregisters and cleans up an Intel uncore performance event,' these map to the removal of driver data, list deletion, and freeing of the box in the source code. No contradictory or irrelevant claims are present, making all statements accurate, though they are somewhat generic.",
                "The summary correctly states that the function unregisters and cleans up Intel uncore performance monitoring resources, and it notes the detection of state inconsistencies, which aligns with the WARN_ON_ONCE checks. However, it misses the core specific action: removing the PCI device's associated uncore box from driver data, deleting it from a global list under a spinlock, updating per-CPU pointers, and adjusting the reference count. Mention of 'performance event' is vague compared to the code\u2019s concrete domain operation. It covers the core purpose loosely but lacks detailed secondary behaviors such as list operations, locking, CPU iteration, and memory freeing.",
                "The summary correctly notes that the function unregisters and cleans up an Intel uncore-related structure and detects inconsistencies via warnings. These align with the code's behavior of removing the box from lists, nullifying references, decrementing refcount, and using WARN_ON_ONCE for state checks. However, the summary inaccurately describes this as a performance event unregistration, omitting key specifics like PCI device removal, driver data clearing, and per-CPU pointer handling. This represents moderate noise but no fatal errors, with gain limited by its generality."
            ]
        },
        "cfg": {
            "summary": "Validates Intel uncore performance event data, unlinks and cleans related structures, updates diagnostic flags, and finalizes state restoration based on verification results.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains multiple claims that do not align well with the source code. While it correctly notes unlinking and cleaning related structures, most claims\u2014such as validating Intel uncore performance event data, updating diagnostic flags, and finalizing state restoration\u2014are not supported by the code, which instead handles removal of a PCI device, detaches driver data, removes it from a list, updates CPU-specific structures, decrements ref counts, and frees memory. Less than half the claims are accurate, with several being domain-irrelevant or incorrect.",
                "The summary largely misrepresents the function's core purpose. The source code removes an Intel uncore PCI device by clearing driver data, unlinking the box from a list under a spinlock, nullifying CPU references, decrementing a reference counter, verifying final reference count, and freeing memory. The summary incorrectly focuses on validating performance event data, updating diagnostic flags, and restoring state, none of which is reflected in the code. It fails to capture the actual removal/unlinking process and cleanup actions, and does not cover the core domain operation.",
                "The summary contains multiple inaccurate claims about the code's core function. It incorrectly states that the function validates Intel uncore performance event data, updates diagnostic flags, and finalizes state restoration, none of which are present in the source code. The actual code removes a PCI device's uncore box from internal structures, clears driver data, updates per-CPU pointers, and frees memory. These mismatches constitute FATAL errors affecting the primary purpose, meaning the description is misleading and unusable for understanding the function."
            ]
        },
        "comment": {
            "summary": "Removes an uncore PCI device, updates reference counts, and frees associated resources while ensuring proper synchronization in a multi-CPU environment.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function removes an uncore PCI device, updates reference counts, frees resources, and uses synchronization for a multi-CPU environment, all of which are present in the source code (device removal via pci_set_drvdata, refcount manipulation, kfree, spinlocks, and per-CPU pointer handling). The description is accurate though somewhat high-level, with no incorrect or irrelevant claims noted.",
                "The summary correctly states that the function removes an uncore PCI device, manipulates reference counts, frees resources, and uses synchronization for multi-CPU conditions, aligning with the source code's behavior. The core purpose of removing an uncore PCI device is clearly covered, but secondary details such as the WARN_ON_ONCE checks, verification of phys_id, per-CPU pointer clearing, and specific use of spin locks and list deletion are not mentioned. This limits completeness despite an accurate core description.",
                "The summary correctly states the primary purpose of removing an uncore PCI device, adjusting reference counts, and freeing resources, which matches the core semantics in the code. It also notes synchronization for a multi-CPU environment, aligning with the use of raw_spin_lock/unlock and per-CPU data handling. There are no inaccurate or contradictory claims and no overwhelming noise, but the statements are relatively generic and lack finer details such as the WARN_ON checks and list removal specifics. This yields moderate net benefit with low noise."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5511035,
    "strip_function_name": "sub_54177B",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_54177B(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  unsigned int v17; // ebp\n  __int64 v18; // rcx\n  char *v19; // rdx\n  unsigned __int64 result; // rax\n  char v21; // [rsp+0h] [rbp-28h]\n  int v22[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  while ( 1 )\n  {\n    v10 = sub_518073(v22);\n    v17 = v10;\n    if ( v10 <= 0 )\n      break;\n    if ( HIDWORD(qword_89A670) )\n      sub_54218B((unsigned int)v10);\n    if ( DWORD1(xmmword_89A678) )\n      --DWORD1(xmmword_89A678);\n    if ( (_DWORD)qword_89A670 )\n    {\n      if ( (v22[0] & 0x7F) != 0 )\n      {\n        v13 = (v22[0] & 0x7Fu) + 1;\n        v18 = v22[0] & 0x7F;\n        v19 = \"?exit\";\n        LOBYTE(v13) = (char)((v22[0] & 0x7F) + 1) >> 1;\n        if ( (char)v13 > 0 )\n          v19 = \"signal\";\n        else\n          v18 = 0LL;\n      }\n      else\n      {\n        v18 = BYTE1(v22[0]);\n        v19 = \"?exit\" + 1;\n      }\n      a10 = v17;\n      sub_517A10(\"end %d %s %d\", v17, (__int64)v19, v18, v13, v14, a1, a2, a3, a4, v15, v16, a7, a8, v21);\n    }\n  }\n  result = (unsigned int)qword_89A670;\n  if ( (_DWORD)qword_89A670 )\n    return sub_54173A(a1, a2, a3, a4, v15, v16, a7, a8, (__int64)v22, a10, v11, v12, v13, v14, v21);\n  return result;\n}\n",
    "function_name": "sig_child_handler",
    "decompiled_code": "unsigned __int64 __fastcall sig_child_handler(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  unsigned int v17; // ebp\n  __int64 v18; // rcx\n  char *v19; // rdx\n  unsigned __int64 result; // rax\n  char v21; // [rsp+0h] [rbp-28h]\n  int v22[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  while ( 1 )\n  {\n    v10 = wait_any_nohang(v22);\n    v17 = v10;\n    if ( v10 <= 0 )\n      break;\n    if ( *(_DWORD *)&bb_common_bufsiz1[4] )\n      ipsvd_perhost_remove(\n        v10,\n        *(double *)a1.m128_u64,\n        *(double *)a2.m128_u64,\n        *(double *)a3.m128_u64,\n        *(double *)a4.m128_u64,\n        *(double *)v15.m128_u64,\n        *(double *)v16.m128_u64,\n        *(double *)a7.m128_u64,\n        *(double *)a8.m128_u64);\n    if ( HIDWORD(xmmword_89A678) )\n      --HIDWORD(xmmword_89A678);\n    if ( *(_DWORD *)bb_common_bufsiz1 )\n    {\n      if ( (v22[0] & 0x7F) != 0 )\n      {\n        v13 = (v22[0] & 0x7Fu) + 1;\n        v18 = v22[0] & 0x7F;\n        v19 = \"?exit\";\n        LOBYTE(v13) = (char)((v22[0] & 0x7F) + 1) >> 1;\n        if ( (char)v13 > 0 )\n          v19 = \"signal\";\n        else\n          v18 = 0LL;\n      }\n      else\n      {\n        v18 = BYTE1(v22[0]);\n        v19 = \"?exit\" + 1;\n      }\n      a10 = v17;\n      bb_error_msg(\n        (const __m128i *)\"end %d %s %d\",\n        v17,\n        (__int64)v19,\n        v18,\n        v13,\n        v14,\n        a1,\n        a2,\n        a3,\n        a4,\n        v15,\n        v16,\n        a7,\n        a8,\n        v21);\n    }\n  }\n  result = *(unsigned int *)bb_common_bufsiz1;\n  if ( *(_DWORD *)bb_common_bufsiz1 )\n    return connection_status(a1, a2, a3, a4, v15, v16, a7, a8, (__int64)v22, a10, v11, v12, v13, v14, v21);\n  return result;\n}\n",
    "source_code": "\nstatic void sig_child_handler(int sig_no UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint l;\n\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"child\");\n\twhile ((pid = wait_any_nohang(&wstat)) > 0) {\n\t\tfor (l = 0; l < dirn; ++l) {\n\t\t\tif (dir[l].ppid == pid) {\n\t\t\t\tdir[l].ppid = 0;\n\t\t\t\tprocessorstop(&dir[l]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "comment": "Handles SIGCHLD signals by cleaning up and processing terminated child processes that match entries in the directory.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reaps child processes , logs their exit statuses or signals , and updates the process list accordingly .\n",
    "cpbcs_sum": "Updates the receive window with new size, manages previous settings, and logs the received data if it differs from the current one.\n",
    "misum_sum": "Displays the status of active jobs in a formatted manner, allowing signal handling and preventing recursive mode settings.\n",
    "decom_sum": "Processes incoming event codes, logs termination or signal messages, and triggers final handling when the global session flag is set.",
    "cfg_sum": "Processes incoming event codes, logs an \u201cend\u201d message with details, decrements state counters, and triggers final processing if active session data exists.",
    "work_score": {
        "decom": {
            "summary": "Processes incoming event codes, logs termination or signal messages, and triggers final handling when the global session flag is set.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains inaccurate claims: it mentions processing event codes and a global session flag, neither of which appear in the source code. The function specifically handles SIGCHLD signals, logs a message when verbose mode is enabled, waits for terminated child processes, and triggers processorstop for matching entries. Only the logging of messages aligns loosely with the code, meaning most claims are not accurate per the source's semantics.",
                "The summary fails to accurately capture the core purpose of the function, which is handling SIGCHLD signals, reaping terminated child processes, identifying matching entries in a global array, and stopping associated processors. The description is vague, introduces unrelated concepts like 'incoming event codes' and 'global session flag', and omits references to wait operations, pid matching, and processor stopping. No accurate claim covers the main signal-handling and child cleanup behavior, leading to a lack of alignment with the source code.",
                "The summary introduces inaccurate claims unrelated to the code, such as processing event codes and a global session flag, which are not present. The function actually handles SIGCHLD signals, logs if verbose, waits for child termination, and stops associated processors. The key primary purpose is misrepresented, resulting in a severe FATAL error on core behavior. Minimal accurate detail is provided, so net benefit is near zero."
            ]
        },
        "cfg": {
            "summary": "Processes incoming event codes, logs an \u201cend\u201d message with details, decrements state counters, and triggers final processing if active session data exists.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about processing event codes, logging an 'end' message, decrementing state counters, and triggering final processing based on session data do not match the source code, which handles a SIGCHLD signal, logs a specific 'child' signal message if verbose, waits for terminated child processes, clears their tracking, and stops associated processors. None of the summary's claims are accurate with respect to the function's actual semantics, resulting in 0% accurate claims.",
                "The summary does not capture the core purpose of handling SIGCHLD signals by waiting for terminated child processes and stopping processors tied to them. Instead, it inaccurately describes unrelated concepts such as event codes, end messages, state counters, and session data, none of which appear in the source code. No accurate claims align with the function\u2019s actual semantics, so the core domain action is entirely missing and no correct secondary details are provided.",
                "The summary is entirely inaccurate with respect to the source code. The function handles SIGCHLD signals, logs a message when received, waits for any terminated child processes, and stops associated processors. The summary instead mentions processing event codes, logging an 'end' message, decrementing state counters, and triggering final processing based on session data, none of which align with the actual semantics. This represents a severe FATAL error on the core purpose, rendering the description unusable."
            ]
        },
        "comment": {
            "summary": "Handles SIGCHLD signals by cleaning up and processing terminated child processes that match entries in the directory.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately states that the function handles SIGCHLD signals, performs cleanup, and processes terminated child processes matching entries in a directory-like structure. These details align with the code\u2019s signal handling, non-blocking wait for child processes, and matching of `ppid` in `dir[l]` before calling `processorstop`. All claims target the actual semantics and are correct, with no inaccuracies detected.",
                "The summary correctly identifies that the function handles SIGCHLD signals and deals with terminated child processes matching directory entries, which matches the core purpose. It omits secondary details such as use of wait_any_nohang to avoid blocking, the resetting of the ppid to zero, calling processorstop on matching entries, iterating through dirn, and the verbose logging behavior when verbose is enabled. These omissions limit coverage of notable implementation specifics and side effects.",
                "The summary correctly states that the function handles SIGCHLD signals and processes terminated child processes matching entries in a directory-like structure, aligning with the code's loop over 'dir' entries and 'processorstop' calls. This is a specific and accurate reflection of the core functionality, with no contradictory or irrelevant claims, and minimal noise. While broadly stated, it captures the primary purpose without errors, providing moderate gain."
            ]
        }
    }
}
{
    "project_name": "bash",
    "function_addr": 947520,
    "strip_function_name": "rl_arrow_keys",
    "strip_decompiled_code": "__int64 __fastcall rl_arrow_keys(const char *a1)\n{\n  unsigned int v1; // ebp\n  int key; // eax\n  unsigned int v3; // ebx\n  const unsigned __int16 *v4; // rdx\n  __int32_t v5; // eax\n  bool v6; // cc\n\n  rl_readline_state |= 0x40uLL;\n  v1 = 1;\n  key = rl_read_key();\n  rl_readline_state &= ~0x40uLL;\n  if ( key < 0 )\n    return v1;\n  v3 = key;\n  v4 = *__ctype_b_loc();\n  v5 = v3;\n  if ( (v4[(unsigned __int8)v3] & 0x200) == 0 )\n  {\n    v6 = (int)v3 <= 66;\n    if ( v3 != 66 )\n      goto LABEL_4;\nLABEL_12:\n    rl_get_next_history((unsigned int)a1, v3);\n    return 0LL;\n  }\n  v5 = (*__ctype_toupper_loc())[(unsigned __int8)v3];\n  v6 = v5 <= 66;\n  if ( v5 == 66 )\n    goto LABEL_12;\nLABEL_4:\n  if ( v6 )\n  {\n    if ( v5 == 65 )\n    {\n      rl_get_previous_history((unsigned int)a1, v3);\n      return 0LL;\n    }\n  }\n  else\n  {\n    if ( v5 == 67 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v1 = rl_byte_oriented) != 0 )\n      {\n        rl_forward_byte((int)a1);\n        return 0;\n      }\n      else\n      {\n        rl_forward_char((const char *)(unsigned int)a1, v3);\n      }\n      return v1;\n    }\n    if ( v5 == 68 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v1 = rl_byte_oriented) != 0 )\n      {\n        v1 = 0;\n        rl_backward_byte((const char *)(unsigned int)a1);\n      }\n      else\n      {\n        rl_backward_char((const char *)(unsigned int)a1, v3);\n      }\n      return v1;\n    }\n  }\n  rl_ding(a1);\n  return 0LL;\n}\n",
    "function_name": "rl_arrow_keys",
    "decompiled_code": "int __fastcall rl_arrow_keys(int count, int key)\n{\n  int v2; // ebp\n  int v3; // eax\n  int v4; // ebx\n  const unsigned __int16 *v5; // rdx\n  __int32_t v6; // eax\n  bool v7; // cc\n\n  rl_readline_state |= 0x40uLL;\n  v2 = 1;\n  v3 = rl_read_key();\n  rl_readline_state &= ~0x40uLL;\n  if ( v3 < 0 )\n    return v2;\n  v4 = v3;\n  v5 = *__ctype_b_loc();\n  v6 = v4;\n  if ( (v5[(unsigned __int8)v4] & 0x200) == 0 )\n  {\n    v7 = v4 <= 66;\n    if ( v4 != 66 )\n      goto LABEL_4;\nLABEL_12:\n    rl_get_next_history(count, v4);\n    return 0;\n  }\n  v6 = (*__ctype_toupper_loc())[(unsigned __int8)v4];\n  v7 = v6 <= 66;\n  if ( v6 == 66 )\n    goto LABEL_12;\nLABEL_4:\n  if ( v7 )\n  {\n    if ( v6 == 65 )\n    {\n      rl_get_previous_history(count, v4);\n      return 0;\n    }\n  }\n  else\n  {\n    if ( v6 == 67 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v2 = rl_byte_oriented) != 0 )\n      {\n        rl_forward_byte(count, v4);\n        return 0;\n      }\n      else\n      {\n        rl_forward_char(count, v4);\n      }\n      return v2;\n    }\n    if ( v6 == 68 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v2 = rl_byte_oriented) != 0 )\n      {\n        v2 = 0;\n        rl_backward_byte(count, v4);\n      }\n      else\n      {\n        rl_backward_char(count, v4);\n      }\n      return v2;\n    }\n  }\n  rl_ding();\n  return 0;\n}\n",
    "source_code": "\nint\nrl_arrow_keys (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (ch < 0)\n    return (1);\n\n  switch (_rl_to_upper (ch))\n    {\n    case 'A':\n      rl_get_previous_history (count, ch);\n      break;\n\n    case 'B':\n      rl_get_next_history (count, ch);\n      break;\n\n    case 'C':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, ch);\n      else\n\trl_forward_byte (count, ch);\n      break;\n\n    case 'D':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_backward_char (count, ch);\n      else\n\trl_backward_byte (count, ch);\n      break;\n\n    default:\n      rl_ding ();\n    }\n\n  return 0;\n}",
    "comment": "Handles arrow key inputs to navigate command history or move the cursor forward/backward, depending on the key pressed and character encoding.",
    "hext5_sum": "get a pointer to struct dis386 with a valid name.",
    "bint5_sum": "Handles arrow keys input , converting them to uppercase or lowercase , and retrieves the corresponding key while managing state transitions .\n",
    "cpbcs_sum": "Processes a key input, validates it against a key, and checks for conflicts with a key sequence or retrieves the corresponding key sequence if not found.\n",
    "misum_sum": "Reads a character from a multibyte string, handling multibyte characters and returning the corresponding character value.\n",
    "decom_sum": "Handles arrow key input in Readline, navigating history or moving the cursor byte- or character-wise based on the pressed key and locale settings.",
    "cfg_sum": "Processes arrow key input from the user and executes corresponding history navigation or cursor movement operations, handling both byte-oriented and multibyte character modes.",
    "work_score": {
        "decom": {
            "summary": "Handles arrow key input in Readline, navigating history or moving the cursor byte- or character-wise based on the pressed key and locale settings.",
            "score": [
                1.0,
                0.7,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function handles arrow key input in Readline, navigates history for certain keys, and moves the cursor either byte-wise or character-wise depending on locale settings (MB_CUR_MAX and rl_byte_oriented). These behaviors align with the source code\u2019s switch cases and conditional checks. No inaccurate or irrelevant claims are present, indicating a high proportion of accurate statements.",
                "The summary correctly identifies that the function processes arrow key input in Readline, with actions for navigating history or moving the cursor in either byte- or character-wise mode based on locale (MB_CUR_MAX) and rl_byte_oriented settings, matching the core purpose and key branches in the source. However, it omits mention of important details such as reading a key via rl_read_key, handling invalid input (ch < 0), the specific mapping of keys ('A', 'B', 'C', 'D') to actions, and the default case that triggers rl_ding, which means the coverage of secondary semantics is incomplete.",
                "The summary correctly states the core purpose of handling arrow key input in Readline and describes navigation through history for up/down keys as well as cursor movement byte- or character-wise for left/right keys depending on locale settings. These are specific and accurate to the source code. There is minimal noise and no factual errors, indicating a high net benefit due to precise coverage of primary behavior."
            ]
        },
        "cfg": {
            "summary": "Processes arrow key input from the user and executes corresponding history navigation or cursor movement operations, handling both byte-oriented and multibyte character modes.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function processes arrow key input and triggers either history navigation or cursor movement depending on the key pressed. It also accurately notes the distinction between byte-oriented and multibyte modes, which matches the conditional logic in the source code. All claims are specific, aligned with the function's behavior, and verifiable against the code, with no irrelevant or incorrect statements.",
                "The summary correctly identifies the function's purpose as processing arrow key input for history navigation and cursor movement, and notes handling of both byte-oriented and multibyte modes, which matches the core domain behavior. However, it omits secondary details such as the initial state setting/unsetting, reading the next key, handling invalid key reads with a return value, and the default ding action for unrecognized keys. The coverage of the core is solid, but key secondary semantics are missing.",
                "The summary correctly captures the primary purpose of the function \u2014 handling arrow key input \u2014 and accurately describes the two main outcomes: history navigation and cursor movement, with the distinction between byte-oriented and multibyte modes. There are no inaccuracies or irrelevant noise, but the claims are broad and lack specifics such as which keys map to which actions or that unsupported inputs trigger a ding. The gain is modest due to the generic nature of the description."
            ]
        },
        "comment": {
            "summary": "Handles arrow key inputs to navigate command history or move the cursor forward/backward, depending on the key pressed and character encoding.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately captures the function\u2019s purpose of handling arrow key inputs for navigating command history and moving the cursor, and correctly notes the dependence on character encoding. These details align closely with the source code\u2019s switch cases for 'A', 'B', 'C', and 'D' as well as the conditional checks for multi-byte character handling. All claims are specific, verifiable, and directly tied to the code semantics, with no inaccuracies.",
                "The summary correctly identifies that the function handles arrow key inputs to navigate command history (up/down) or move the cursor forward/backward (left/right), and notes that cursor movement depends on character encoding, matching the MB_CUR_MAX and byte-oriented checks in the code. This covers the core purpose and includes a key secondary behavior detail. However, it omits mention of reading the input character, handling invalid keys with a ding, and the return values, leaving the coverage incomplete.",
                "The summary correctly identifies that the function processes arrow key inputs to navigate command history for up/down keys and to move the cursor forward/backward for left/right keys, with behavior dependent on multibyte character encoding. All claims are accurate, specific enough to reflect core behavior in the source code, and there is no contradictory or irrelevant information. Noise is minimal and gain is moderately high due to accurate description of primary purpose and conditional handling."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584059008,
    "strip_function_name": "sub_FFFFFFFF814F8E80",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814F8E80(\n        __int64 a1,\n        int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rdx\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  unsigned __int64 v21; // rax\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  unsigned int v24; // [rsp+2Ch] [rbp-44h]\n  __int64 v25; // [rsp+34h] [rbp-3Ch] BYREF\n\n  result = sub_FFFFFFFF8178F4A0(a1 + 480);\n  if ( !(_DWORD)result )\n  {\n    if ( *(_DWORD *)(a1 + 840) != a2 )\n    {\n      v16 = *(unsigned int *)(a1 + 984);\n      if ( (_DWORD)v16 )\n      {\n        LODWORD(result) = -22;\n      }\n      else if ( a2 )\n      {\n        sub_FFFFFFFF814F8710((_QWORD *)a1, a1 + 472, (__int64)&v25);\n        v21 = sub_FFFFFFFF814F7990(a1, (int)a1 + 472, v17, v18, v19, v20, v25);\n        *(_QWORD *)(a1 + 832) = 1000000000LL;\n        *(_QWORD *)(a1 + 824) = v21 + 1000000000;\n        LODWORD(result) = sub_FFFFFFFF814F8A70(a1, a1 + 784, a3, a4, a5, a6, v22, v23, a9, a10);\n      }\n      else\n      {\n        sub_FFFFFFFF814F8C00((_QWORD *)a1, a1 + 784, v16, v11, v12, v13, a3, a4, a5, a6, v14, v15, a9, a10);\n        LODWORD(result) = 0;\n      }\n    }\n    v24 = result;\n    sub_FFFFFFFF8178F1B0(a1 + 480);\n    return v24;\n  }\n  return result;\n}\n",
    "function_name": "rtc_update_irq_enable",
    "decompiled_code": "__int64 __fastcall rtc_update_irq_enable(\n        __int64 a1,\n        int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int v13; // edx\n  int v14; // ecx\n  int v15; // r8d\n  int v16; // r9d\n  __int64 v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // [rsp+2Ch] [rbp-44h]\n  __int64 v21; // [rsp+34h] [rbp-3Ch] BYREF\n\n  result = mutex_lock_interruptible(a1 + 480);\n  if ( !(_DWORD)result )\n  {\n    if ( *(_DWORD *)(a1 + 840) != a2 )\n    {\n      if ( *(_DWORD *)(a1 + 984) )\n      {\n        LODWORD(result) = -22;\n      }\n      else if ( a2 )\n      {\n        _rtc_read_time_isra_3((_QWORD *)a1, a1 + 472, (__int64)&v21);\n        v17 = rtc_tm_to_ktime(a1, (int)a1 + 472, v13, v14, v15, v16, v21);\n        *(_QWORD *)(a1 + 832) = 1000000000LL;\n        *(_QWORD *)(a1 + 824) = v17 + 1000000000;\n        LODWORD(result) = rtc_timer_enqueue((_QWORD *)a1, a1 + 784, a3, a4, a5, a6, v18, v19, a9, a10);\n      }\n      else\n      {\n        rtc_timer_remove((_QWORD *)a1, a1 + 784, a3, a4, a5, a6, v11, v12, a9, a10);\n        LODWORD(result) = 0;\n      }\n    }\n    v20 = result;\n    mutex_unlock(a1 + 480);\n    return v20;\n  }\n  return result;\n}\n",
    "source_code": "\nint rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tif (enabled == 0 && rtc->uie_irq_active) {\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, 0);\n\t}\n#endif\n\t/* make sure we're changing state */\n\tif (rtc->uie_rtctimer.enabled == enabled)\n\t\tgoto out;\n\n\tif (rtc->uie_unsupported) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (enabled) {\n\t\tstruct rtc_time tm;\n\t\tktime_t now, onesec;\n\n\t\t__rtc_read_time(rtc, &tm);\n\t\tonesec = ktime_set(1, 0);\n\t\tnow = rtc_tm_to_ktime(tm);\n\t\trtc->uie_rtctimer.node.expires = ktime_add(now, onesec);\n\t\trtc->uie_rtctimer.period = ktime_set(1, 0);\n\t\terr = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);\n\t} else\n\t\trtc_timer_remove(rtc, &rtc->uie_rtctimer);\n\nout:\n\tmutex_unlock(&rtc->ops_lock);\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\t/*\n\t * Enable emulation if the driver did not provide\n\t * the update_irq_enable function pointer or if returned\n\t * -EINVAL to signal that it has been configured without\n\t * interrupts or that are not available at the moment.\n\t */\n\tif (err == -EINVAL)\n\t\terr = rtc_dev_update_irq_enable_emul(rtc, enabled);\n#endif\n\treturn err;\n\n}",
    "comment": "Updates the RTC interrupt state, enabling or disabling the timer based on the provided flag, while handling potential emulation requirements.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Disables a specified RTC timer , disables it , and sets the next alarm if available , while ensuring thread safety with a mutex lock .\n",
    "cpbcs_sum": "Sets the alarm timer for an evdev client, validating the new timer and timer before unlocking the new timer mutex.\n",
    "misum_sum": "Manages the RTC timer for a real-time clock timer while ensuring it is ready and adjusting for thread safety.\n",
    "decom_sum": "Updates the device state when the mode changes, initializing or resetting timing parameters and invoking relevant configuration or shutdown routines.",
    "cfg_sum": "Updates device state based on mode change, reinitializing timers or resetting parameters, and calls helper routines before returning a success or error code.",
    "work_score": {
        "decom": {
            "summary": "Updates the device state when the mode changes, initializing or resetting timing parameters and invoking relevant configuration or shutdown routines.",
            "score": [
                0.6,
                0.2,
                0.5
            ],
            "reason": [
                "The summary makes a generic claim about updating the device state, initializing/resetting timing parameters, and invoking configuration or shutdown routines, which loosely matches the source code\u2019s behavior when enabling or disabling the RTC update interrupt and adjusting timers. However, it omits critical domain-specific details such as mutex locking, emulation handling, and error return codes, and does not explicitly reference RTC-specific semantics. The alignment is partial, with over half of the claims being broadly accurate but lacking specificity.",
                "The summary vaguely mentions updating device state and timing parameters but does not explicitly identify the core purpose of enabling or disabling RTC update interrupts via a timer mechanism. While it touches on mode changes and initialization/reset of timing, it misses key specific semantics like handling unsupported cases, conditional emulation paths, mutex locking, and enqueue/remove of the RTC timer. Thus, the core domain action is not clearly covered and secondary behaviors are absent.",
                "The summary makes a generic claim about updating device state on mode change and adjusting timing parameters, which loosely aligns with the code's enable/disable behavior for UIE RTC timer and associated configurations. However, it omits critical specifics such as mutex locking, error handling, unsupported mode checks, and conditional emulation, and does not contain any clear FATAL inaccuracies. The claims are safe but low-information, providing minimal engineering value, with no overwhelming noise present."
            ]
        },
        "cfg": {
            "summary": "Updates device state based on mode change, reinitializing timers or resetting parameters, and calls helper routines before returning a success or error code.",
            "score": [
                0.6,
                0.2,
                0.4
            ],
            "reason": [
                "The summary provides a generic description of mode-based state updates, timer reinitialization, and helper calls, which loosely aligns with the source code's behavior of enabling or disabling UIE interrupts, adjusting timers, and invoking helper functions. However, it omits specific error-handling paths, mutex locking/unlocking, conditional emulation, and does not clearly differentiate modes beyond a generic 'mode change'. Most claims are safe but low-information and not contradictory, resulting in moderate alignment.",
                "The summary vaguely describes updating device state and handling timers, but it does not accurately convey the core purpose of enabling or disabling RTC update interrupts via the uie_rtctimer with specific handling for unsupported cases and emulation. While 'reinitializing timers' loosely matches enabling behavior, it lacks mention of interrupt configuration, reading the current time, expiration/period setup, or the conditional branches for unsupported or emulated operations, leaving the core semantic action uncovered.",
                "The summary offers only a vague, generic description without specific details tied to the source code's actual behavior. It misses key elements such as handling of mutex locking, conditional emulation for UIE, checking unsupported features, and precise timer setup/removal. No statements are factually wrong, but the noise is high and accuracy is minimal, resulting in very low informational gain."
            ]
        },
        "comment": {
            "summary": "Updates the RTC interrupt state, enabling or disabling the timer based on the provided flag, while handling potential emulation requirements.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures the core behavior of the function\u2014enabling or disabling the RTC update interrupt based on the input flag\u2014and notes the handling of potential emulation, which aligns with the CONFIG_RTC_INTF_DEV_UIE_EMUL conditional logic in the code. It omits implementation specifics such as mutex locking, error handling for unsupported features, and timer configuration, but these omissions do not contradict the source. All extracted claims are accurate and domain-relevant, yielding a high proportion of correct statements.",
                "The summary correctly identifies the core purpose as updating the RTC interrupt state with enable/disable logic and mentions emulation handling, aligning with the function\u2019s primary behavior. However, it omits key secondary details such as locking via mutex, checking for unchanged state, handling unsupported cases with -EINVAL, computing expiration and period times, and removing/enqueuing timers. The coverage of secondary semantics is minimal beyond the high-level purpose.",
                "The summary correctly captures the primary purpose of the function: updating the RTC interrupt state according to an enable flag, and notes handling of potential emulation requirements, aligning with the conditional CONFIG_RTC_INTF_DEV_UIE_EMUL branches in the code. However, it is generic and low-info, lacking specific details such as mutex locking, timer setup/removal, and error handling conditions (like -EINVAL for unsupported cases). There are no inaccurate or contradictory claims, but the description's broadness limits its gain."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 359616,
    "strip_function_name": "sub_57CC0",
    "strip_decompiled_code": "__int64 __fastcall sub_57CC0(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rax\n  char *v5; // rax\n  int v6; // edx\n  unsigned int v7; // eax\n  socklen_t optlen; // [rsp+Ch] [rbp-8Ch] BYREF\n  _BYTE optval[68]; // [rsp+10h] [rbp-88h] BYREF\n  int v11; // [rsp+54h] [rbp-44h]\n  int v12; // [rsp+58h] [rbp-40h]\n  int v13; // [rsp+60h] [rbp-38h]\n  int v14; // [rsp+70h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+78h] [rbp-20h]\n\n  v15 = __readfsqword(0x28u);\n  v4 = *(_QWORD *)(a1 + 8);\n  optlen = 104;\n  if ( getsockopt(*(_DWORD *)(v4 + 24), 6, 11, optval, &optlen) == -1 )\n  {\n    *(_BYTE *)(a2 + 3) |= 0x40u;\n    return 0LL;\n  }\n  else\n  {\n    v5 = (char *)ngx_pnalloc(*(_QWORD **)(a1 + 88), 0xBuLL);\n    *(_QWORD *)(a2 + 8) = v5;\n    if ( v5 )\n    {\n      if ( a3 == 1 )\n      {\n        v6 = v12;\n      }\n      else if ( a3 )\n      {\n        if ( a3 == 2 )\n        {\n          v6 = v13;\n        }\n        else if ( a3 == 3 )\n        {\n          v6 = v14;\n        }\n        else\n        {\n          v6 = 0;\n        }\n      }\n      else\n      {\n        v6 = v11;\n      }\n      v7 = ((unsigned int)ngx_sprintf(v5, \"%uD\", v6) - *(_DWORD *)(a2 + 8)) & 0xFFFFFFF | *(_DWORD *)a2 & 0xF0000000;\n      *(_DWORD *)a2 = v7;\n      *(_BYTE *)(a2 + 3) = HIBYTE(v7) & 0x8F | 0x10;\n      return 0LL;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n}\n",
    "function_name": "ngx_http_variable_tcpinfo",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n  ngx_connection_t *connection; // rax\n  u_char *v5; // rax\n  uint32_t tcpi_rttvar; // edx\n  unsigned int v7; // eax\n  socklen_t len; // [rsp+Ch] [rbp-8Ch] BYREF\n  tcp_info ti; // [rsp+10h] [rbp-88h] BYREF\n  unsigned __int64 v11; // [rsp+78h] [rbp-20h]\n\n  v11 = __readfsqword(0x28u);\n  connection = r->connection;\n  len = 104;\n  if ( getsockopt(connection->fd, 6, 11, &ti, &len) == -1 )\n  {\n    *((_BYTE *)v + 3) |= 0x40u;\n    return 0LL;\n  }\n  else\n  {\n    v5 = (u_char *)ngx_pnalloc(r->pool, 0xBuLL);\n    v->data = v5;\n    if ( v5 )\n    {\n      if ( data == 1 )\n      {\n        tcpi_rttvar = ti.tcpi_rttvar;\n      }\n      else if ( data )\n      {\n        if ( data == 2 )\n        {\n          tcpi_rttvar = ti.tcpi_snd_cwnd;\n        }\n        else if ( data == 3 )\n        {\n          tcpi_rttvar = ti.tcpi_rcv_space;\n        }\n        else\n        {\n          tcpi_rttvar = 0;\n        }\n      }\n      else\n      {\n        tcpi_rttvar = ti.tcpi_rtt;\n      }\n      v7 = ((unsigned int)ngx_sprintf(v5, \"%uD\", tcpi_rttvar) - LODWORD(v->data)) & 0xFFFFFFF | *(_DWORD *)v & 0xF0000000;\n      *(_DWORD *)v = v7;\n      *((_BYTE *)v + 3) = HIBYTE(v7) & 0x8F | 0x10;\n      return 0LL;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n}\n",
    "source_code": "\nstatic ngx_int_t\nngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)\n{\n    struct tcp_info  ti;\n    socklen_t        len;\n    uint32_t         value;\n\n    len = sizeof(struct tcp_info);\n    if (getsockopt(r->connection->fd, IPPROTO_TCP, TCP_INFO, &ti, &len) == -1) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    switch (data) {\n    case 0:\n        value = ti.tcpi_rtt;\n        break;\n\n    case 1:\n        value = ti.tcpi_rttvar;\n        break;\n\n    case 2:\n        value = ti.tcpi_snd_cwnd;\n        break;\n\n    case 3:\n        value = ti.tcpi_rcv_space;\n        break;\n\n    /* suppress warning */\n    default:\n        value = 0;\n        break;\n    }\n\n    v->len = ngx_sprintf(v->data, \"%uD\", value) - v->data;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}",
    "comment": "Retrieves TCP connection statistics like RTT, RTT variance, send window size, or receive space and stores the result in an HTTP variable.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Checks for connection errors on a socket to an upstream server , handling both kqueue and standard socket error retrieval methods .\n",
    "cpbcs_sum": "Creates a socket for reading from a specified server, ensuring it is not already created and handling errors appropriately.\n",
    "misum_sum": "Retrieves the number of connections from an upstream server and stores it in the variable structure for future use.\n",
    "decom_sum": "Retrieves TCP congestion control stats via getsockopt and stores the selected metric as a formatted string in the provided output buffer.",
    "cfg_sum": "Retrieves TCP congestion control socket parameters, formats a selected value into allocated memory, updates connection flags, and handles errors on retrieval or allocation failure.",
    "work_score": {
        "decom": {
            "summary": "Retrieves TCP congestion control stats via getsockopt and stores the selected metric as a formatted string in the provided output buffer.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary contains one main claim: that the function retrieves TCP congestion control stats via getsockopt and stores the selected metric as a formatted string in the output buffer. This aligns well with the code, which calls getsockopt for TCP_INFO, selects a metric based on the `data` parameter, and formats it into the buffer. While the summary omits specific metrics available (rtt, rttvar, snd_cwnd, rcv_space) and some error-handling details, the core behavior is correctly captured, making the claim accurate.",
                "The summary correctly captures the core purpose of retrieving a specific TCP statistic via getsockopt and formatting it into the output buffer, which aligns with the code\u2019s logic for obtaining metrics like RTT, RTT variance, send congestion window, or receive space. However, it omits secondary details such as handling allocation failure, the case-based selection among four metrics, setting valid/not_found flags, and default value handling for unrecognized data identifiers. These omissions limit coverage of other critical behaviors.",
                "The summary accurately states that the function uses getsockopt to retrieve TCP-related statistics and stores a selected metric as a formatted string in the provided output buffer. It omits specific details like the exact tcp_info fields handled (rtt, rttvar, snd_cwnd, rcv_space) and conditions for 'not_found', but contains no inaccurate claims. The gain is modest due to the generic wording, yet noise is minimal, yielding a clear, correct high-level description."
            ]
        },
        "cfg": {
            "summary": "Retrieves TCP congestion control socket parameters, formats a selected value into allocated memory, updates connection flags, and handles errors on retrieval or allocation failure.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly describes that the function retrieves TCP socket parameters using getsockopt, selects a specific value based on the input, formats it into allocated memory, and updates flags accordingly. It also mentions handling errors for retrieval and allocation failures. All these claims align closely with the source code semantics, with no contradictory or irrelevant statements, indicating a high proportion of accurate claims.",
                "The summary accurately reflects the function\u2019s core purpose: obtaining TCP socket info via getsockopt and returning a selected metric based on the data argument, with error handling for retrieval and allocation. It covers allocation, formatting into memory, and status flag updates. However, it generalizes the parameters as 'congestion control' values, which is slightly imprecise since the metrics include RTT, RTT variance, send congestion window, and receive space. Secondary details like specific metric selection cases and default handling are omitted, leaving the coverage of edge cases incomplete.",
                "The summary accurately captures the function's core purpose of retrieving TCP socket parameters via getsockopt, selecting a specific metric, formatting it into allocated memory, and handling errors for retrieval or allocation failures. All claims align with the source code's semantics, including the mention of connection flags updates corresponding to v->valid, v->no_cacheable, and v->not_found. No inaccurate or irrelevant statements are present, and the coverage includes the primary purpose and key I/O behavior with specific detail, ensuring high gain."
            ]
        },
        "comment": {
            "summary": "Retrieves TCP connection statistics like RTT, RTT variance, send window size, or receive space and stores the result in an HTTP variable.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly identifies that the function retrieves TCP statistics such as RTT, RTT variance, send window size, and receive space, which matches the switch cases in the source code. It also accurately notes that these values are stored in an HTTP variable via the ngx_http_variable_value_t structure. All fact-based claims align with the code, showing high precision and no inaccuracies.",
                "The summary accurately reflects the core purpose of the function: retrieving specific TCP connection parameters (RTT, RTT variance, send window size, receive space) and placing them into an HTTP variable. This matches the source code's `getsockopt` call for `TCP_INFO` and subsequent switch on `data` to select a field. While the core is well covered, the summary omits secondary details such as error handling when `getsockopt` fails, memory allocation via `ngx_pnalloc`, the formatting of the value as a string, and setting of variable metadata flags. Thus, the coverage of secondary semantics is limited.",
                "The summary correctly identifies the core purpose of the function: retrieving TCP metrics (RTT, RTT variance, send congestion window size, receive space) and storing them in an HTTP variable. All claims align with the source code behavior and are accurate. The statement is concise and focuses on primary purpose without introducing noise or inaccuracies, though it is fairly generic and lacks deeper implementation specifics such as error handling or how the variable is formatted."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5042992,
    "strip_function_name": "sub_4CF330",
    "strip_decompiled_code": "__int64 __fastcall sub_4CF330(__int64 a1)\n{\n  const char *v2; // rdi\n  FILE *v3; // rax\n  FILE *v4; // rax\n  __int64 result; // rax\n  int *v6; // rax\n  __int64 v7; // rbp\n  int *v8; // rax\n\n  v2 = *(const char **)(a1 + 16);\n  if ( !v2 || !*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 32) )\n  {\n    *(__m128i *)(a1 + 188) = _mm_load_si128((const __m128i *)&xmmword_51F490);\n    strcpy((char *)(a1 + 236), \" or outfile.\");\n    *(__m128i *)(a1 + 204) = _mm_load_si128((const __m128i *)&xmmword_51F4A0);\n    *(__m128i *)(a1 + 220) = _mm_load_si128((const __m128i *)&xmmword_51F4B0);\n    sub_4CFBA0(a1, a1 + 188, 0LL);\n    return 0LL;\n  }\n  v3 = fopen(v2, \"wb\");\n  *(_QWORD *)(a1 + 48) = v3;\n  if ( !v3 )\n  {\n    v6 = __errno_location();\n    v7 = a1 + 188;\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 16),\n      (unsigned int)*v6);\nLABEL_12:\n    sub_4CFBA0(a1, v7, 0LL);\n    return 0LL;\n  }\n  v4 = fopen(*(const char **)(a1 + 24), \"wb\");\n  *(_QWORD *)(a1 + 40) = v4;\n  if ( !v4 )\n  {\n    v8 = __errno_location();\n    v7 = a1 + 188;\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 24),\n      (unsigned int)*v8);\n    goto LABEL_12;\n  }\n  result = sub_4D0600(a1, *(_QWORD *)(a1 + 48), v4);\n  if ( (int)result > 0 )\n    return 1LL;\n  return result;\n}\n",
    "function_name": "libjte_write_header",
    "decompiled_code": "__int64 __fastcall libjte_write_header(__int64 a1)\n{\n  const char *v2; // rdi\n  FILE *v3; // rax\n  FILE *v4; // rax\n  __int64 result; // rax\n  int *v6; // rax\n  const char *v7; // rbp\n  int *v8; // rax\n\n  v2 = *(const char **)(a1 + 16);\n  if ( !v2 || !*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 32) )\n  {\n    *(__m128i *)(a1 + 188) = _mm_load_si128((const __m128i *)&xmmword_51F490);\n    strcpy((char *)(a1 + 236), \" or outfile.\");\n    *(__m128i *)(a1 + 204) = _mm_load_si128((const __m128i *)&xmmword_51F4A0);\n    *(__m128i *)(a1 + 220) = _mm_load_si128(xmmword_51F4B0);\n    libjte_add_msg_entry(a1, (const char *)(a1 + 188), 0);\n    return 0LL;\n  }\n  v3 = fopen(v2, byte_51F41B);\n  *(_QWORD *)(a1 + 48) = v3;\n  if ( !v3 )\n  {\n    v6 = __errno_location();\n    v7 = (const char *)(a1 + 188);\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 16),\n      (unsigned int)*v6);\nLABEL_12:\n    libjte_add_msg_entry(a1, v7, 0);\n    return 0LL;\n  }\n  v4 = fopen(*(const char **)(a1 + 24), byte_51F41B);\n  *(_QWORD *)(a1 + 40) = v4;\n  if ( !v4 )\n  {\n    v8 = __errno_location();\n    v7 = (const char *)(a1 + 188);\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 24),\n      (unsigned int)*v8);\n    goto LABEL_12;\n  }\n  result = write_jt_header(a1, *(FILE **)(a1 + 48), v4);\n  if ( (int)result > 0 )\n    return 1LL;\n  return result;\n}\n",
    "source_code": "\nint libjte_write_header(struct libjte_env *o)\n{\n    int ret;\n\n    if (o->jtemplate_out == NULL || o->jjigdo_out == NULL ||\n        o->outfile == NULL || o->jmd5_list == NULL) {\n        sprintf(o->message_buffer,\n               \"Undefined: template_path, jigdo_path, md5_paths, or outfile.\");\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    \n    o->jttemplate = fopen(o->jtemplate_out, \"wb\");\n    if (o->jttemplate == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n                o->jtemplate_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    o->jtjigdo = fopen(o->jjigdo_out, \"wb\");\n    if (o->jtjigdo == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n                o->jjigdo_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n\n    ret = write_jt_header(o, o->jttemplate, o->jtjigdo);\n    if (ret <= 0)\n        return ret;\n    return 1;\n}",
    "comment": "Initializes output files for a template and jigdo, checks for errors, and writes the header using the provided environment structure.",
    "hext5_sum": "add the prefix to the client.",
    "bint5_sum": "Writes a GNU tar long filename to a specified file or stdout if no filename is provided , ensuring proper initialization and error handling .\n",
    "cpbcs_sum": "Opens a directory for reading and writing at the first file for the specified path if not already created.\n",
    "misum_sum": "Clones a dynamic library structure, initializes its properties, and manages its state and attributes while ensuring proper resource management and mutex handling.\n",
    "decom_sum": "Opens specified template and jigdo output files for writing, reports detailed errors if either fails, and processes them if successful.",
    "cfg_sum": "Opens specified template and jigdo files for writing, reports detailed errors if unsuccessful, and processes them to generate output status.",
    "work_score": {
        "decom": {
            "summary": "Opens specified template and jigdo output files for writing, reports detailed errors if either fails, and processes them if successful.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly identifies that the function opens template and jigdo output files for writing and reports detailed errors if they fail, which matches the source code behavior. It also notes that processing occurs if successful, aligning with the call to write_jt_header. However, it omits the initial null checks on multiple fields and the specific return values, making the description slightly incomplete but still mostly accurate.",
                "The summary accurately captures the core purpose of opening the template and jigdo files for writing and reporting detailed errors on failure, which matches the source code\u2019s specific domain action. It also notes processing if successful, covering the function\u2019s call to write_jt_header. However, it omits other critical conditions, like initial null-pointer checks for required paths/files before attempting to open, and does not mention return values or message logging details. Thus, while the core is covered, secondary semantics are incomplete.",
                "The summary accurately captures the primary purpose of the function: opening the specified template and jigdo output files for writing, handling errors if opening fails, and proceeding to process them on success. It omits some details such as the initial validation of multiple required pointers before attempting to open files, and the specific return values, but these omissions are minor and do not contradict the source code. No inaccurate or noisy claims are present, and the main function behavior is represented correctly, though the gain is moderate as the description is fairly generic."
            ]
        },
        "cfg": {
            "summary": "Opens specified template and jigdo files for writing, reports detailed errors if unsuccessful, and processes them to generate output status.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function opens template and jigdo files for writing and reports detailed errors if opening fails, which matches the code. However, the claim about 'processing them to generate output status' is vague and partially inaccurate since the function delegates header writing to write_jt_header and then returns success or error codes, not a generalized output status. While the majority of claims align with the source code, the last one reduces precision.",
                "The summary correctly captures the core purpose \u2014 opening the template and jigdo files for writing and reporting detailed errors \u2014 which matches the source\u2019s primary operation. The claim about processing them to generate output status loosely corresponds to calling write_jt_header and returning a status, but it is vague and omits several secondary details, such as the initial check for null paths, producing specific error messages for missing inputs, and the precise return values used for error handling. Secondary coverage is therefore limited.",
                "The summary correctly states that the function opens specified template and jigdo files for writing and reports detailed errors if unsuccessful. It omits some specifics like checking for null input pointers before attempting to open files, and the fact that processing is done by calling `write_jt_header` with its return value determining success. The phrase 'generate output status' is vague but not inaccurate\u2014it loosely covers returning status codes. There are no contradictory or irrelevant claims; accuracy is acceptable though information depth is low."
            ]
        },
        "comment": {
            "summary": "Initializes output files for a template and jigdo, checks for errors, and writes the header using the provided environment structure.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary captures the core actions in the function: it opens the template and jigdo output files, performs error checking, and invokes a header-writing routine using the environment structure. These are accurate reflections of the source code. It omits minor details such as the initial null-pointer checks for multiple required paths and the use of specific messaging via libjte_add_msg_entry, but the claims made are correct and aligned with code behavior, resulting in a high proportion of accurate statements.",
                "The summary correctly identifies the core purpose as initializing output files for template and jigdo, handling errors, and writing the header using the provided environment structure, which matches the function\u2019s main operation. However, it omits specific secondary behavior details such as the explicit null checks of multiple required paths, the use of message buffers and libjte_add_msg_entry to log errors, the fopen mode ('wb'), and returned values indicating success or failure. These omissions reduce the completeness of coverage beyond the core action.",
                "The summary correctly states that the function initializes output files for a template and jigdo, checks for errors, and writes the header using the environment structure. These are accurate reflections of the source code's logic, including file opening, error messages, and the call to write_jt_header. It omits some specifics (like checking for null inputs before opening files) but contains no inaccurate or irrelevant claims, providing a concise yet correct primary purpose description. The gain is modest due to lack of detailed error handling specifics, but noise is minimal."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585972544,
    "strip_function_name": "sub_FFFFFFFF816CC140",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816CC140(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // ecx\n  int v3; // edx\n  int v4; // edx\n  unsigned __int8 v5; // dl\n\n  if ( (*(_DWORD *)a1 & 0xE0) == 0 || (result = 917505LL, (*(_DWORD *)a1 & 0xE0) == 0xE0) )\n  {\n    if ( (unsigned __int8)*(_DWORD *)a1 == 255 )\n    {\n      v5 = *(_BYTE *)(a1 + 1) & 0xF;\n      result = 131106LL;\n      if ( v5 != 2 )\n      {\n        result = 327746LL;\n        if ( v5 != 5 )\n        {\n          result = (__int64)&unk_10012;\n          if ( v5 != 1 )\n            return (v5 << 16) | 2u;\n        }\n      }\n    }\n    else\n    {\n      result = 131105LL;\n      v2 = *(_DWORD *)a1 & 0xC0FF;\n      if ( v2 != 33022 )\n      {\n        result = 327745LL;\n        if ( v2 != 49406 )\n        {\n          result = 917505LL;\n          if ( (*(_DWORD *)a1 & 0xFE) != 0xFC && !*(_QWORD *)a1 )\n          {\n            v3 = *(_DWORD *)(a1 + 8);\n            if ( v3 )\n            {\n              if ( v3 == -65536 )\n                return 921600LL;\n            }\n            else\n            {\n              v4 = *(_DWORD *)(a1 + 12);\n              result = 0LL;\n              if ( v4 )\n              {\n                result = 917633LL;\n                if ( v4 == 0x1000000 )\n                  return 131089LL;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "__ipv6_addr_type",
    "decompiled_code": "__int64 __fastcall _ipv6_addr_type(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // ecx\n  int v3; // edx\n  int v4; // edx\n  unsigned __int8 v5; // dl\n\n  if ( (*(_DWORD *)a1 & 0xE0) == 0 || (result = 917505LL, (*(_DWORD *)a1 & 0xE0) == 0xE0) )\n  {\n    if ( (unsigned __int8)*(_DWORD *)a1 == 255 )\n    {\n      v5 = *(_BYTE *)(a1 + 1) & 0xF;\n      result = 131106LL;\n      if ( v5 != 2 )\n      {\n        result = 327746LL;\n        if ( v5 != 5 )\n        {\n          result = (__int64)&unk_10012;\n          if ( v5 != 1 )\n            return (v5 << 16) | 2u;\n        }\n      }\n    }\n    else\n    {\n      result = 131105LL;\n      v2 = *(_DWORD *)a1 & 0xC0FF;\n      if ( v2 != 33022 )\n      {\n        result = 327745LL;\n        if ( v2 != 49406 )\n        {\n          result = 917505LL;\n          if ( (*(_DWORD *)a1 & 0xFE) != 0xFC && !*(_QWORD *)a1 )\n          {\n            v3 = *(_DWORD *)(a1 + 8);\n            if ( v3 )\n            {\n              if ( v3 == -65536 )\n                return 921600LL;\n            }\n            else\n            {\n              v4 = *(_DWORD *)(a1 + 12);\n              result = 0LL;\n              if ( v4 )\n              {\n                result = 917633LL;\n                if ( v4 == 0x1000000 )\n                  return 131089LL;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint __ipv6_addr_type(const struct in6_addr *addr)\n{\n\t__be32 st;\n\n\tst = addr->s6_addr32[0];\n\n\t/* Consider all addresses with the first three bits different of\n\t   000 and 111 as unicasts.\n\t */\n\tif ((st & htonl(0xE0000000)) != htonl(0x00000000) &&\n\t    (st & htonl(0xE0000000)) != htonl(0xE0000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\n\n\tif ((st & htonl(0xFF000000)) == htonl(0xFF000000)) {\n\t\t/* multicast */\n\t\t/* addr-select 3.1 */\n\t\treturn (IPV6_ADDR_MULTICAST |\n\t\t\tipv6_addr_scope2type(IPV6_ADDR_MC_SCOPE(addr)));\n\t}\n\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFE800000))\n\t\treturn (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFEC00000))\n\t\treturn (IPV6_ADDR_SITELOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_SITELOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFE000000)) == htonl(0xFC000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t\t\t/* RFC 4193 */\n\n\tif ((addr->s6_addr32[0] | addr->s6_addr32[1]) == 0) {\n\t\tif (addr->s6_addr32[2] == 0) {\n\t\t\tif (addr->s6_addr32[3] == 0)\n\t\t\t\treturn IPV6_ADDR_ANY;\n\n\t\t\tif (addr->s6_addr32[3] == htonl(0x00000001))\n\t\t\t\treturn (IPV6_ADDR_LOOPBACK | IPV6_ADDR_UNICAST |\n\t\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t/* addr-select 3.4 */\n\n\t\t\treturn (IPV6_ADDR_COMPATv4 | IPV6_ADDR_UNICAST |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t\t}\n\n\t\tif (addr->s6_addr32[2] == htonl(0x0000ffff))\n\t\t\treturn (IPV6_ADDR_MAPPED |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t}\n\n\treturn (IPV6_ADDR_UNICAST |\n\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.4 */\n}",
    "comment": "Determines the IPv6 address type (unicast, multicast, link-local, site-local, loopback, or any) based on the address structure and specific bit patterns.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Determines the IPv6 protocol type based on the provided socket address structure , returning specific constants for IPv4 and IPv6 protocols .\n",
    "cpbcs_sum": "Determines whether a remote address is a local address based on its type and address family, returning specific error codes for invalid inputs.\n",
    "misum_sum": "Validates the type of a given IPv6 address based on its type, returning a bitmask for various error types or unknown types.\n",
    "decom_sum": "Evaluates a 32-bit header at the given address and returns specific constant codes based on bit patterns and embedded 8- or 32-bit field values.",
    "cfg_sum": "Evaluates specific bitmask and memory patterns in a data block to return predefined status codes for hardware or protocol state identification.",
    "work_score": {
        "decom": {
            "summary": "Evaluates a 32-bit header at the given address and returns specific constant codes based on bit patterns and embedded 8- or 32-bit field values.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary states that the function evaluates a 32-bit header and returns codes based on bit patterns and field values, but this is misleading. The source code clearly shows it operates on an IPv6 address structure and classifies the address type and scope, not a generic header. While the mention of returning codes based on bit patterns is partly accurate, the summary omits key IPv6-specific semantics and mischaracterizes the data being inspected, resulting in most claims being inaccurate.",
                "The summary makes a generic statement about evaluating a 32-bit header and returning constants based on bit patterns, but it does not accurately describe the core purpose of identifying IPv6 address types and scopes from the address structure. The claim is vague, missing explicit reference to IPv6 address classification, and omits critical secondary details such as specific address categories (multicast, link-local, site-local, loopback, mapped) and RFC rules present in the code.",
                "The summary inaccurately describes the function: it does not evaluate a generic '32-bit header' but specifically examines parts of an IPv6 address to determine its type and scope, making this a FATAL error about the primary purpose. It omits key distinctions such as handling multicast, link-local, site-local, loopback, unspecified, compatible, and mapped addresses. While it mentions returning constants based on bit patterns, this is generic and fails to capture the domain semantics, resulting in negligible positive gain and a primary-purpose misrepresentation."
            ]
        },
        "cfg": {
            "summary": "Evaluates specific bitmask and memory patterns in a data block to return predefined status codes for hardware or protocol state identification.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary inaccurately describes the function as evaluating bitmask and memory patterns for hardware or protocol state identification, while the source code specifically classifies IPv6 addresses into types and scopes based on address bit patterns. None of the claims directly or correctly target the actual IPv6-specific semantics, resulting in no accurate claims.",
                "The summary is inaccurate because it does not mention the core purpose of determining IPv6 address type and scope based on specific bitmasks from the address structure. Instead, it vaguely references hardware or protocol state identification, which is not reflected in the source code. The core domain action of categorizing IPv6 addresses into unicast, multicast, link-local, site-local, loopback, etc., is completely missing, and no accurate secondary details are provided.",
                "The summary is inaccurate because it misrepresents the function\u2019s purpose: the source code determines IPv6 address types and scopes based on specific bitmask checks, not generic hardware or protocol state identification from a data block. This is a FATAL error affecting the primary purpose, as the described domain is wrong. No accurate claims are present, making the net benefit unusable."
            ]
        },
        "comment": {
            "summary": "Determines the IPv6 address type (unicast, multicast, link-local, site-local, loopback, or any) based on the address structure and specific bit patterns.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function determines the IPv6 address type and lists several types (unicast, multicast, link-local, site-local, loopback, any), which aligns with the source code\u2019s branching logic based on specific bit patterns in the address. However, it omits mention of certain address categories handled in the code such as IPv4-compatible, IPv4-mapped, and unique local addresses, so while most claims are accurate, some detail is missing.",
                "The summary accurately states the core purpose: determining the IPv6 address type based on bit patterns in the address structure, which matches the function\u2019s primary operation. It also lists several specific types returned, aligning with the code\u2019s handling of unicast, multicast, link-local, site-local, loopback, and any. However, it omits secondary details such as recognition of unique-local, IPv4-compatible, and IPv4-mapped addresses, and scope type tagging, which are also important behaviors in the code.",
                "The summary correctly conveys the primary purpose of the function \u2014 determining the IPv6 address type such as unicast, multicast, link-local, site-local, loopback, or unspecified \u2014 and notes that this is based on the address structure and bitmask checks. There are no contradictory statements, and noise is minimal. However, the gain is limited because the description is generic and omits key specifics, such as the exact bit patterns used, scope type calculations, and special address cases (e.g., mapped or IPv4-compatible addresses)."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581218960,
    "strip_function_name": "sub_FFFFFFFF81243890",
    "strip_decompiled_code": "_UNKNOWN **__fastcall sub_FFFFFFFF81243890(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  __int64 v6; // rax\n  void *v7; // r13\n  __int64 v8; // rbx\n  _QWORD *v9; // rdx\n  _UNKNOWN **result; // rax\n  void *v11; // rdx\n  _QWORD *v12; // rdx\n\n  v6 = *(_QWORD *)(a1 + 8);\n  v7 = (void *)(a1 + 8);\n  v8 = a2;\n  if ( a1 + 8 == v6 )\n  {\n    if ( _InterlockedIncrement((volatile signed __int32 *)a1) <= 1 && !byte_FFFFFFFF81CAC61F )\n    {\n      sub_FFFFFFFF8103BB80((__int64)\"include/linux/kref.h\", 47, a3, a4, a5, a6);\n      byte_FFFFFFFF81CAC61F = 1;\n    }\n  }\n  else\n  {\n    v9 = *(_QWORD **)(a1 + 16);\n    *(_QWORD *)(v6 + 8) = v9;\n    *v9 = v6;\n    *(_QWORD *)(a1 + 8) = v7;\n    *(_QWORD *)(a1 + 16) = v7;\n  }\n  result = &off_FFFFFFFF81C49EA0;\n  if ( a2 != -1 )\n  {\n    v8 = qword_FFFFFFFF81CC2000 + a2;\n    if ( qword_FFFFFFFF81CC2000 + a2 == -1 )\n      v8 = 0LL;\n    result = (_UNKNOWN **)off_FFFFFFFF81C49EA0;\n    if ( off_FFFFFFFF81C49EA0 != (_UNKNOWN *)&off_FFFFFFFF81C49EA0 )\n    {\n      do\n      {\n        v11 = result[7];\n        if ( v8 - (__int64)v11 < 0 )\n          break;\n        if ( v11 == (void *)-1LL )\n          break;\n        result = (_UNKNOWN **)*result;\n      }\n      while ( result != &off_FFFFFFFF81C49EA0 );\n    }\n  }\n  v12 = result[1];\n  result[1] = v7;\n  *(_QWORD *)(a1 + 8) = result;\n  *(_QWORD *)(a1 + 16) = v12;\n  *v12 = v7;\n  *(_QWORD *)(a1 + 64) = v8;\n  return result;\n}\n",
    "function_name": "nlmsvc_insert_block_locked",
    "decompiled_code": "_UNKNOWN **__fastcall nlmsvc_insert_block_locked(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rax\n  void *v11; // r13\n  __int64 v12; // rbx\n  _QWORD *v13; // rdx\n  _UNKNOWN **result; // rax\n  void *v15; // rdx\n  _QWORD *v16; // rdx\n\n  v10 = *(_QWORD *)(a1 + 8);\n  v11 = (void *)(a1 + 8);\n  v12 = a2;\n  if ( a1 + 8 == v10 )\n  {\n    if ( _InterlockedIncrement((volatile signed __int32 *)a1) <= 1 && !_warned_11206_2 )\n    {\n      warn_slowpath_null(\"include/linux/kref.h\", 0x2Fu, a3, a4, a5, a6, a7, a8, a9, a10);\n      _warned_11206_2 = 1;\n    }\n  }\n  else\n  {\n    v13 = *(_QWORD **)(a1 + 16);\n    *(_QWORD *)(v10 + 8) = v13;\n    *v13 = v10;\n    *(_QWORD *)(a1 + 8) = v11;\n    *(_QWORD *)(a1 + 16) = v11;\n  }\n  result = &nlm_blocked_0;\n  if ( a2 != -1 )\n  {\n    v12 = _vvar_beginning_hack + a2;\n    if ( _vvar_beginning_hack + a2 == -1 )\n      v12 = 0LL;\n    result = (_UNKNOWN **)nlm_blocked_0;\n    if ( nlm_blocked_0 != (_UNKNOWN *)&nlm_blocked_0 )\n    {\n      do\n      {\n        v15 = result[7];\n        if ( v12 - (__int64)v15 < 0 )\n          break;\n        if ( v15 == (void *)-1LL )\n          break;\n        result = (_UNKNOWN **)*result;\n      }\n      while ( result != &nlm_blocked_0 );\n    }\n  }\n  v16 = result[1];\n  result[1] = v11;\n  *(_QWORD *)(a1 + 8) = result;\n  *(_QWORD *)(a1 + 16) = v16;\n  *v16 = v11;\n  *(_QWORD *)(a1 + 64) = v12;\n  return result;\n}\n",
    "source_code": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
    "comment": "Inserts a network lock block into a sorted list based on its scheduled time, managing its reference count and handling the list initialization.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Inserts a new lock into a block list or updates an existing lock if the block is already in the list .\n",
    "cpbcs_sum": "Decreases the reference count of an NFS file and updates the expiration count if the count reaches zero.\n",
    "misum_sum": "Adds a new lock state to a linked list and updates its list based on its reference count and reference count.\n",
    "decom_sum": "Updates linked list pointers for an object, adjusts its reference count, and searches by offset while logging once using kref from include/linux/kref.h.",
    "cfg_sum": "Updates linked list node references, performs atomic reference counting with error logging, and reassigns state based on a computed offset value.",
    "work_score": {
        "decom": {
            "summary": "Updates linked list pointers for an object, adjusts its reference count, and searches by offset while logging once using kref from include/linux/kref.h.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function updates linked list pointers and adjusts the object's reference count, which match the use of list_add_tail, list_del_init/list_empty, and kref_get in the code. However, it inaccurately claims that it searches by offset \u2014 the code searches the list based on time values (b->b_when) \u2014 and omits several important behaviors such as conditional list removal, use of jiffies, and time ordering logic. Overall, fewer than half of the claims are accurate.",
                "The summary fails to cover the core purpose, which is inserting a lockd nlm_block into the blocked list at a position determined by its scheduled wake time (\u2018when\u2019). While it mentions linked list pointer updates and reference count changes, it incorrectly describes the search as \u2018by offset\u2019 and omits the time-based ordering logic, handling of NLM_NEVER, and the calculation using jiffies. It also adds irrelevant mention of kref include details rather than the function\u2019s actual semantics.",
                "The summary contains a key inaccurate claim: it says the function 'searches by offset,' which does not align with the source code\u2014actual search is based on a time value comparison of b->b_when and when. While it is correct about updating linked list pointers, adjusting reference count, and logging, the mention of searching by offset is a semantic error about the function\u2019s primary search logic, making it a FATAL error on core behavior. Other details, like using kref from include/linux/kref.h, are accurate but low-info, and noise further reduces the net benefit."
            ]
        },
        "cfg": {
            "summary": "Updates linked list node references, performs atomic reference counting with error logging, and reassigns state based on a computed offset value.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains mostly inaccurate claims relative to the source code. While it correctly notes updating linked list node references, it incorrectly mentions atomic reference counting, error logging, and reassigning state based on a computed offset value \u2014 none of which are present in the function. These errors mean less than half of the extracted claims are accurate.",
                "The summary fails to cover the core purpose of inserting an NLM block into a global blocked list in correct time order based on 'when' value. While it mentions linked list updates and reference counting, these are generic and do not reflect the specific domain context of NLM lock management. It inaccurately adds 'error logging' and 'computed offset value', which are not present in the source code, and omits key behavior such as handling NLM_NEVER, time comparisons, and ordering logic.",
                "The summary contains multiple inaccuracies. It correctly notes updates to linked list node references, but incorrectly describes 'atomic reference counting with error logging'\u2014the code uses kref_get but has no error logging\u2014and misrepresents 'reassigns state based on a computed offset value', which does not occur; instead it sets a time value based on jiffies and NLM_NEVER logic. These are semantic errors about the function\u2019s behavior, including key side effects, making them FATAL for trustworthiness. Accurate content is minimal and overshadowed by misinformation, resulting in low net benefit."
            ]
        },
        "comment": {
            "summary": "Inserts a network lock block into a sorted list based on its scheduled time, managing its reference count and handling the list initialization.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function inserts a lock block into a list based on scheduled time and manages reference counts, aligning with the code\u2019s behavior of calculating position via `when` and modifying `b_list` with `list_add_tail` after handling reference count via `kref_get`. The mention of sorted list is fairly accurate as the function iterates to find insertion point based on `b_when`. Though 'network lock block' is inferred from context (NLM = network lock manager), the claim is still relevant to code semantics. No significant inaccuracies present, giving this a high proportion of accurate claims.",
                "The summary correctly identifies that the function inserts a network lock block into a list ordered by scheduled time, handles list initialization, and manages reference count, which matches the core purpose and key behaviors in the source code. However, it omits certain details such as how the insertion point is determined using time comparison, special handling when 'when' equals NLM_NEVER, and adjustments involving jiffies, which are relevant secondary semantics.",
                "The summary correctly states that the function inserts a lock block into a list based on its scheduled time and handles reference count and initialization, which matches the source code\u2019s behavior of adjusting 'when', iterating to the right position, and managing kref or list deletion. However, it inaccurately claims the list is sorted explicitly \u2014 the code only ensures insertion before blocks scheduled after the given time or with NLM_NEVER, not a full sort. There is minor overstatement but no fatal contradiction about primary purpose or key I/O. The claims are mostly accurate but somewhat generic, offering moderate insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579976560,
    "strip_function_name": "sub_FFFFFFFF81114370",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81114370(__int64 a1)\n{\n  _QWORD *v1; // r13\n  _QWORD *v2; // rax\n  _QWORD *v3; // rbx\n  __int64 v4; // rdx\n  _QWORD *v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rbx\n\n  if ( sub_FFFFFFFF81064450((volatile signed __int64 *)(a1 + 112)) )\n    BUG();\n  if ( dword_FFFFFFFF81C3BE20 == 1 )\n    BUG();\n  v1 = *(_QWORD **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    do\n    {\n      if ( v1[17] )\n      {\n        v2 = (_QWORD *)v1[15];\n        v3 = v2 - 2;\n        if ( v1 + 15 != v2 )\n        {\n          do\n          {\n            v4 = v3[1];\n            if ( (*(_QWORD *)(*(_QWORD *)v4 + 48LL) & 1) != 0 )\n            {\n              if ( !_bittestandreset((signed __int32 *)(*(_QWORD *)v4 + 48LL), 0) )\n                BUG();\n              sub_FFFFFFFF810644C0((volatile signed __int64 *)(*(_QWORD *)v4 + 8LL));\n            }\n            v5 = (_QWORD *)v3[2];\n            v3 = v5 - 2;\n          }\n          while ( v1 + 15 != v5 );\n        }\n      }\n      v6 = v1[20];\n      if ( v6 )\n      {\n        v7 = *(_QWORD *)(v6 + 208);\n        if ( v7 )\n        {\n          if ( (*(_QWORD *)(v7 + 120) & 0x8000000) != 0 )\n          {\n            sub_FFFFFFFF8178F1B0(v7 + 56);\n            if ( !_interlockedbittestandreset((volatile signed __int32 *)(v7 + 120), 0x1Bu) )\n              BUG();\n          }\n        }\n      }\n      v1 = (_QWORD *)v1[2];\n    }\n    while ( v1 );\n  }\n  return sub_FFFFFFFF8178F1B0(&dword_FFFFFFFF81C3BE20);\n}\n",
    "function_name": "mm_drop_all_locks",
    "decompiled_code": "__int64 __fastcall mm_drop_all_locks(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // r13\n  _QWORD *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  _QWORD *v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rbx\n\n  if ( down_read_trylock((volatile signed __int64 *)(a1 + 112)) )\n    BUG();\n  if ( mm_all_locks_mutex == 1 )\n    BUG();\n  v2 = *(_QWORD **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    do\n    {\n      if ( v2[17] )\n      {\n        v3 = (_QWORD *)v2[15];\n        v4 = v3 - 2;\n        if ( v2 + 15 != v3 )\n        {\n          do\n          {\n            v5 = v4[1];\n            if ( (*(_QWORD *)(*(_QWORD *)v5 + 48LL) & 1) != 0 )\n            {\n              if ( !_bittestandreset((signed __int32 *)(*(_QWORD *)v5 + 48LL), 0) )\n                BUG();\n              up_write((volatile signed __int64 *)(*(_QWORD *)v5 + 8LL), a2);\n            }\n            v6 = (_QWORD *)v4[2];\n            v4 = v6 - 2;\n          }\n          while ( v2 + 15 != v6 );\n        }\n      }\n      v7 = v2[20];\n      if ( v7 )\n      {\n        v8 = *(_QWORD *)(v7 + 208);\n        if ( v8 )\n        {\n          if ( (*(_QWORD *)(v8 + 120) & 0x8000000) != 0 )\n          {\n            mutex_unlock(v8 + 56);\n            if ( !_interlockedbittestandreset((volatile signed __int32 *)(v8 + 120), 0x1Bu) )\n              BUG();\n          }\n        }\n      }\n      v2 = (_QWORD *)v2[2];\n    }\n    while ( v2 );\n  }\n  return mutex_unlock((__int64)&mm_all_locks_mutex);\n}\n",
    "source_code": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
    "comment": "Releases all locks on virtual memory areas and their associated anonymous virtual memory structures in the specified memory management structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases all virtual memory areas associated with a vmap_area , ensuring proper memory management during the process .\n",
    "cpbcs_sum": "The function waits for all active virtual memory areas in the given virtual memory area if any child processes are available.\n",
    "misum_sum": "Reschedules a virtual memory area by clearing notification info, verifying all active virtual memory areas and updating their status and memory mappings accordingly.\n",
    "decom_sum": "Traverses and cleans up linked kernel objects, releasing resources and resetting flags, then finalizes by updating a global synchronization variable.",
    "cfg_sum": "Validates linked objects\u2019 state flags, resets specific bits, performs cleanup operations, and triggers a system bug check if integrity conditions are violated.",
    "work_score": {
        "decom": {
            "summary": "Traverses and cleans up linked kernel objects, releasing resources and resetting flags, then finalizes by updating a global synchronization variable.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims it 'releases resources' which partially aligns with the code's function of unlocking anon_vma and mapping objects, but also mentions 'resetting flags' and 'updating a global synchronization variable' which are not present in the source. The code unlocks locks and releases associated mappings but does not perform flag resets, nor directly update a global sync variable\u2014only unlocks a global mutex. The vague 'traverses and cleans up linked kernel objects' is partially accurate but imprecise. Overall, less than half of the claims are accurate due to these incorrect or misleading elements.",
                "The summary makes generic claims about traversing kernel objects, releasing resources, and updating a synchronization variable, but it fails to accurately reflect the core purpose of the function, which is to drop all locks in the memory map of an mm_struct by unlocking anon_vma and file mapping locks and finally unlocking a specific global mutex. The summary omits these specific domain actions and mentions inaccurate elements like 'resetting flags', which are absent from the code.",
                "The summary contains mostly inaccurate claims: it describes 'cleaning up' linked kernel objects, 'releasing resources', 'resetting flags', and 'updating a global synchronization variable', none of which match the source code\u2019s actual semantics. The function iterates VMAs to unlock anon_vma and file mappings, and then releases a specific mutex. The incorrect claims target the core purpose of the function, misrepresenting its primary action and side effects, making them FATAL errors on key I/O and synchronization behavior."
            ]
        },
        "cfg": {
            "summary": "Validates linked objects\u2019 state flags, resets specific bits, performs cleanup operations, and triggers a system bug check if integrity conditions are violated.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function validates linked objects\u2019 state flags, resets bits, and performs generic cleanup, which are mostly inaccurate when compared to the source. The code specifically checks lock states via BUG_ON, iterates over vm_area_struct objects, and unlocks anon_vma and file mappings, but does not reset bits or validate arbitrary state flags. While it correctly mentions triggering a bug check under integrity violations, most other claims do not reflect the actual semantics, resulting in low alignment.",
                "The summary fails to identify the core purpose of iterating over VMAs in an mm_struct to drop locks on associated anonymous memory areas and file mappings while enforcing mutex and semaphore conditions. It instead describes vague validation, resetting bits, and generic cleanup, none of which are explicitly supported by the source code. While it loosely mentions a bug check for integrity violations, it doesn't specify the actual BUG_ON conditions present. Key secondary behaviors like unlocking anon_vma and file mappings, as well as mutex unlocking, are also missing.",
                "The summary introduces inaccurate claims about validating state flags and resetting bits, which do not appear in the source code. The function iterates VMAs to unlock anonymous VMAs and file mappings, then releases a mutex, with BUG_ON checks ensuring certain locks are held, but no flag resets or generic cleanup beyond unlocking operations. These inaccuracies misrepresent the primary purpose, causing severe factual errors about core behavior. The noise from unrelated statements outweighs any accurate elements, yielding minimal net benefit."
            ]
        },
        "comment": {
            "summary": "Releases all locks on virtual memory areas and their associated anonymous virtual memory structures in the specified memory management structure.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function releases all locks on virtual memory areas and related anonymous virtual memory structures of the given memory management structure, which matches the code's iteration over VMAs unlocking anon_vma and file mappings. However, it omits mention of specific checks (BUG_ON calls) and unlocking of file mappings, making it incomplete but still accurate for the primary semantics.",
                "The summary states that the function releases all locks on virtual memory areas and their associated anonymous virtual memory structures, which aligns with the core operation of iterating through VMAs to unlock associated anon_vma structures and file mappings. This covers the primary purpose but lacks mention of other critical details from the source code, such as unlocking file mappings tied to vm_file, the initial BUG_ON checks for lock states, and the final mutex unlock step. Secondary coverage is thus weak despite an accurate core description.",
                "The summary correctly states that the function releases locks on virtual memory areas and their associated anonymous virtual memory structures in the given mm_struct, which aligns with the code\u2019s loop over VMAs and calls to vm_unlock_anon_vma. However, it omits mention of also unlocking file-backed mappings via vm_unlock_mapping and the initial BUG_ON checks that enforce locking preconditions. There are no inaccurate claims targeting core semantics, but the summary provides only a partial and somewhat generic view of the function\u2019s behavior, limiting its informational value."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584964832,
    "strip_function_name": "sub_FFFFFFFF815D60E0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815D60E0(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  __int64 *v14; // rdx\n  __int64 v16; // rsi\n  unsigned __int64 v17; // rdi\n  int v18; // eax\n  __int64 v19; // rdi\n  __int64 v21; // rdi\n\n  v14 = (__int64 *)a1[2];\n  if ( v14 )\n  {\n    a12 = a1[1];\n    *(_WORD *)v14 = *(_WORD *)(a12 + 208) + *(_DWORD *)(a12 + 196) - (_WORD)v14;\n  }\n  v16 = *((unsigned int *)a1 + 6);\n  if ( (_DWORD)v16 && (unsigned int)sub_FFFFFFFF812C91D0((_DWORD *)a1[1], v16, 40LL, a1 + 6) )\n  {\n    v17 = a1[4];\n  }\n  else\n  {\n    v16 = *((unsigned int *)a1 + 7);\n    v17 = a1[4];\n    if ( !(_DWORD)v16\n      || !v17\n      || (v18 = sub_FFFFFFFF812C91D0((_DWORD *)a1[1], v16, *((unsigned int *)a1 + 10), (__int64 *)a1[4]),\n          v17 = a1[4],\n          !v18) )\n    {\n      sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, a6, a7, a8, a9, v16, v14, a12, a13, a14);\n      v19 = *a1;\n      a1[4] = 0LL;\n      *((_DWORD *)a1 + 10) = 0;\n      sub_FFFFFFFF81792870(v19);\n      return 0LL;\n    }\n  }\n  sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, a6, a7, a8, a9, v16, v14, a12, a13, a14);\n  v21 = *a1;\n  a1[4] = 0LL;\n  *((_DWORD *)a1 + 10) = 0;\n  sub_FFFFFFFF81792870(v21);\n  return 0xFFFFFFFFLL;\n}\n",
    "function_name": "gnet_stats_finish_copy",
    "decompiled_code": "__int64 __fastcall gnet_stats_finish_copy(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 *v9; // rdx\n  __int64 v11; // rsi\n  __int64 *v12; // rdi\n  int v13; // eax\n  _BYTE *v14; // rdi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  _BYTE *v20; // rdi\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n\n  v9 = (__int64 *)a1[2];\n  if ( v9 )\n    *(_WORD *)v9 = *(_WORD *)(a1[1] + 208) + *(_DWORD *)(a1[1] + 196) - (_WORD)v9;\n  v11 = *((unsigned int *)a1 + 6);\n  if ( (_DWORD)v11 && (unsigned int)nla_put((_DWORD *)a1[1], v11, 40, a1 + 6) )\n  {\n    v12 = (__int64 *)a1[4];\n  }\n  else\n  {\n    v11 = *((unsigned int *)a1 + 7);\n    v12 = (__int64 *)a1[4];\n    if ( !(_DWORD)v11\n      || !v12\n      || (v13 = nla_put((_DWORD *)a1[1], v11, *((_DWORD *)a1 + 10), (__int64 *)a1[4]), v12 = (__int64 *)a1[4], !v13) )\n    {\n      kfree(v12, a2, a3, a4, a5, a6, a7, a8, a9, v11, v9);\n      v14 = (_BYTE *)*a1;\n      a1[4] = 0LL;\n      *((_DWORD *)a1 + 10) = 0;\n      raw_spin_unlock_bh(v14, v11, v15, v16, v17, v18);\n      return 0LL;\n    }\n  }\n  kfree(v12, a2, a3, a4, a5, a6, a7, a8, a9, v11, v9);\n  v20 = (_BYTE *)*a1;\n  a1[4] = 0LL;\n  *((_DWORD *)a1 + 10) = 0;\n  raw_spin_unlock_bh(v20, v11, v21, v22, v23, v24);\n  return 0xFFFFFFFFLL;\n}\n",
    "source_code": "int\ngnet_stats_finish_copy(struct gnet_dump *d)\n{\n\tif (d->tail)\n\t\td->tail->nla_len = skb_tail_pointer(d->skb) - (u8 *)d->tail;\n\n\tif (d->compat_tc_stats)\n\t\tif (gnet_stats_copy(d, d->compat_tc_stats, &d->tc_stats,\n\t\t\tsizeof(d->tc_stats)) < 0)\n\t\t\treturn -1;\n\n\tif (d->compat_xstats && d->xstats) {\n\t\tif (gnet_stats_copy(d, d->compat_xstats, d->xstats,\n\t\t\td->xstats_len) < 0)\n\t\t\treturn -1;\n\t}\n\n\tspin_unlock_bh(d->lock);\n\treturn 0;\n}",
    "comment": "Finalizes the statistics copy process by updating lengths and copying compatible statistics into the provided structures before unlocking the spinlock.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Decreases the receive buffer count and frees the sk_buff structure if it is no longer in use .\n",
    "cpbcs_sum": "Releases resources associated with a socket buffer, including NAPI data and timeout data, and conditionally deallocates their memory.\n",
    "misum_sum": "Adds a dirty log to a sound structure, replacing existing log entries, and notifying the buffer and length of the packets.\n",
    "decom_sum": "Processes and validates object data, invokes a rendering routine with provided parameters, then clears resources and signals completion or failure.",
    "cfg_sum": "Processes and validates structure data, conditionally executes computation routines, handles failure by cleanup, and returns status indicating success or error.",
    "work_score": {
        "decom": {
            "summary": "Processes and validates object data, invokes a rendering routine with provided parameters, then clears resources and signals completion or failure.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary makes generic claims about processing object data, invoking a rendering routine, and clearing resources, which do not match or accurately describe the specific network statistics copying and lock handling behavior in the source code. All claims are unrelated to the code semantics, resulting in no accurate matches.",
                "The summary's claims about processing and validating object data, invoking a rendering routine, and clearing resources do not match the source code, which finalizes a network statistics dump by adjusting lengths, copying compatibility statistics, handling failures, and unlocking a spinlock. The core purpose of finishing and copying network stats is not covered, and all claims are inaccurate with respect to the code's actual behavior.",
                "The summary's claims about processing and validating object data, invoking a rendering routine, and clearing resources do not align with the source code, which finalizes statistic copying, adjusts lengths, performs conditional data copy operations, unlocks a spinlock, and returns a status code. All claims are NOISE as they do not target actual code semantics, resulting in no factual alignment and overwhelming inaccuracy."
            ]
        },
        "cfg": {
            "summary": "Processes and validates structure data, conditionally executes computation routines, handles failure by cleanup, and returns status indicating success or error.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary describes generic behavior such as processing data, validation, conditional computation, failure handling by cleanup, and returning a status, but it lacks specific and verifiable details from the source code. The function in the code updates a length field, conditionally copies statistics based on specific structure members, and unlocks a spinlock before returning. The summary omits these domain-specific semantics and introduces vague or inaccurate notions like 'validation' and 'cleanup' that aren't evident in the code, resulting in a low proportion of accurate claims.",
                "The summary offers generic phrasing about processing data, executing computations, handling failures, and returning status, but it does not specifically mention the core domain action of finalizing copied network statistics in a gnet_dump structure, adjusting length fields, performing conditional stats copy operations, or releasing the spinlock. While these generic statements align loosely with the notion of conditional execution and status return, the core domain-specific purpose is entirely missing and the secondary behaviors (specific structures, fields, and functions used) are absent.",
                "The summary contains mostly generic, low-information statements that do not accurately describe the specific semantics of the source code. Claims about processing and validating structure data and executing computation routines are too vague. The mention of handling failure by cleanup is inaccurate because the function handles failure by returning -1 without performing cleanup actions. There are no specific, verifiable details about key behaviors like updating nla_len or copying statistics. The worst failure mode is NOISE, as vague and misleading claims outweigh the accurate content."
            ]
        },
        "comment": {
            "summary": "Finalizes the statistics copy process by updating lengths and copying compatible statistics into the provided structures before unlocking the spinlock.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately identifies that the function finalizes the statistics copy process, updates the length field for the tail, copies compatible statistics into the provided structures, and unlocks the spinlock before returning. All these claims match the source code\u2019s logic without contradictions or irrelevant details, resulting in a high proportion of accurate claims.",
                "The summary correctly captures the core purpose of finalizing the statistics copy process by updating the tail length and performing compatibility-aware stats copying, followed by unlocking the spinlock. This aligns with the source code\u2019s primary operation and mentions key secondary behaviors like updating lengths and unlocking. However, it omits detail about handling two distinct compatibility copies separately and the conditional error returns when copy operations fail, leaving coverage of branches and error handling incomplete.",
                "The summary accurately captures the primary purpose: finalizing the statistics copy process by updating the `tail` length, performing compatibility copies for `tc_stats` and `xstats`, and unlocking the spinlock. All described actions align with the source code\u2019s control flow, with no contradictory or irrelevant statements. The claims are mostly correct but somewhat generic, offering limited technical detail beyond high-level steps, thus providing moderate gain and very low noise."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5660876,
    "strip_function_name": "sub_5660CC",
    "strip_decompiled_code": "_BOOL8 __fastcall sub_5660CC(__m128 a1, __m128 a2, __m128 a3, __m128 a4, double a5, double a6, __m128 a7, __m128 a8)\n{\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __m128 v11; // xmm4\n  __m128 v12; // xmm5\n  _BOOL8 result; // rax\n  signed int v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  char v25; // [rsp+0h] [rbp-B8h]\n  int v26; // [rsp+Ch] [rbp-ACh] BYREF\n  _QWORD v27[2]; // [rsp+10h] [rbp-A8h] BYREF\n  struct stat v28; // [rsp+20h] [rbp-98h] BYREF\n\n  if ( (unsigned int)sub_4AD1D0(1u, \"check\", &v28) == -1 )\n  {\n    result = 1LL;\n    if ( *(_DWORD *)qword_89A630 != 2 )\n    {\n      sub_5174F5(\n        (__int64)\"warning: can't stat %s/check\",\n        *(_QWORD *)xmmword_89A678,\n        qword_89A630,\n        v8,\n        v9,\n        v10,\n        a1,\n        a2,\n        a3,\n        a4,\n        v11,\n        v12,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v27[0] = \"./check\";\n    v27[1] = 0LL;\n    v14 = sub_5DC1ED(v27);\n    if ( v14 > 0 )\n    {\n      if ( (unsigned int)sub_518044(v14, &v26, 0) == -1 )\n      {\n        sub_5174F5(\n          (__int64)\"warning: can't %s child %s/check\",\n          (__int64)\"wait for\",\n          *(_QWORD *)xmmword_89A678,\n          v20,\n          v21,\n          v22,\n          a1,\n          a2,\n          a3,\n          a4,\n          v23,\n          v24,\n          a7,\n          a8,\n          v25);\n        return 0LL;\n      }\n      else\n      {\n        return BYTE1(v26) == 0;\n      }\n    }\n    else\n    {\n      sub_5174F5(\n        (__int64)\"warning: can't %s child %s/check\",\n        6757469LL,\n        *(_QWORD *)xmmword_89A678,\n        v15,\n        v16,\n        v17,\n        a1,\n        a2,\n        a3,\n        a4,\n        v18,\n        v19,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "checkscript",
    "decompiled_code": "_BOOL8 __fastcall checkscript(__m128 a1, __m128 a2, __m128 a3, __m128 a4, double a5, double a6, __m128 a7, __m128 a8)\n{\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __m128 v11; // xmm4\n  __m128 v12; // xmm5\n  _BOOL8 result; // rax\n  pid_t v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  char v25; // [rsp+0h] [rbp-B8h]\n  int v26; // [rsp+Ch] [rbp-ACh] BYREF\n  __int64 v27[2]; // [rsp+10h] [rbp-A8h] BYREF\n  struct stat v28; // [rsp+20h] [rbp-98h] BYREF\n\n  if ( (unsigned int)xstat(1u, \"check\", &v28) == -1 )\n  {\n    result = 1LL;\n    if ( *(_DWORD *)bb_errno != 2 )\n    {\n      bb_perror_msg(\n        \"warning: can't stat %s/check\",\n        *(_QWORD *)xmmword_89A678,\n        bb_errno,\n        v8,\n        v9,\n        v10,\n        a1,\n        a2,\n        a3,\n        a4,\n        v11,\n        v12,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v27[0] = (__int64)\"./check\";\n    v27[1] = 0LL;\n    v14 = spawn(v27, *(double *)a1.m128_u64);\n    if ( v14 > 0 )\n    {\n      if ( (unsigned int)safe_waitpid(v14, &v26, 0) == -1 )\n      {\n        bb_perror_msg(\n          \"warning: can't %s child %s/check\",\n          (__int64)\"wait for\",\n          *(_QWORD *)xmmword_89A678,\n          v20,\n          v21,\n          v22,\n          a1,\n          a2,\n          a3,\n          a4,\n          v23,\n          v24,\n          a7,\n          a8,\n          v25);\n        return 0LL;\n      }\n      else\n      {\n        return BYTE1(v26) == 0;\n      }\n    }\n    else\n    {\n      bb_perror_msg(\n        \"warning: can't %s child %s/check\",\n        6757469LL,\n        *(_QWORD *)xmmword_89A678,\n        v15,\n        v16,\n        v17,\n        a1,\n        a2,\n        a3,\n        a4,\n        v18,\n        v19,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int checkscript(void)\n{\n\tchar *prog[2];\n\tstruct stat s;\n\tint pid, w;\n\n\tif (stat(\"check\", &s) == -1) {\n\t\tif (errno == ENOENT) return 1;\n\t\tbb_perror_msg(WARN\"can't stat %s/check\", *service);\n\t\treturn 0;\n\t}\n\t/* if (!(s.st_mode & S_IXUSR)) return 1; */\n\tprog[0] = (char*)\"./check\";\n\tprog[1] = NULL;\n\tpid = spawn(prog);\n\tif (pid <= 0) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"run\", *service);\n\t\treturn 0;\n\t}\n\twhile (safe_waitpid(pid, &w, 0) == -1) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"wait for\", *service);\n\t\treturn 0;\n\t}\n\treturn WEXITSTATUS(w) == 0;\n}",
    "comment": "Checks for the existence of the \"check\" script, executes it, and returns true if it exits successfully.",
    "hext5_sum": "returns true upon success, false otherwise. copy object file ibfd onto obfd.",
    "bint5_sum": "The function manages signal traps by setting , resetting , or displaying handlers for specified signals based on command-line arguments .\n",
    "cpbcs_sum": "Executes a specified command with arguments, checks for errors, and handles interrupt states and errors related to process file operations.\n",
    "misum_sum": "Waits for a child process to change state or removal of files, returning true if no devices are found.\n",
    "decom_sum": "Checks for the existence of the \"./check\" file, executes it as a child process, waits for completion, and logs warnings on failure.",
    "cfg_sum": "Checks for the existence of the \"./check\" file, executes it, waits for completion, and returns success if it exits without errors.",
    "work_score": {
        "decom": {
            "summary": "Checks for the existence of the \"./check\" file, executes it as a child process, waits for completion, and logs warnings on failure.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function checks for the existence of './check', runs it as a child process, waits for it to complete, and logs warnings upon failure, all of which directly match the source code's behavior. No contradictory or irrelevant claims are present, indicating high alignment with the code semantics.",
                "The summary correctly captures the core purpose of checking for the \"./check\" file, executing it as a child process, and waiting for completion, which matches the function\u2019s main domain behavior. It also notes that warnings are logged on failure, covering secondary error handling. However, it omits specific branches like returning 1 when the file is missing (ENOENT), returning 0 on stat/spawn/wait errors, and interpreting the exit status to decide success. These omissions reduce completeness despite accurate core coverage.",
                "The summary accurately states the main behavior: it checks for the existence of the \"./check\" file, executes it as a child process, waits for its completion, and logs warnings on failure. These are specific and verifiable against the source code with no contradictions. The claims are mostly GOLD and directly describe the core purpose and key I/O handling, with no noise present, providing solid insight into the function's domain semantics."
            ]
        },
        "cfg": {
            "summary": "Checks for the existence of the \"./check\" file, executes it, waits for completion, and returns success if it exits without errors.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function checks for the existence of the './check' file, executes it, waits for completion, and returns success if the exit status is zero. These points reflect the actual behavior in the source code, including the use of stat to check existence, running via spawn, waiting via safe_waitpid, and returning true on exit status 0. Minor omission includes how non-existent files return 1, but overall all claims align with the code semantics.",
                "The summary accurately captures the core purpose of verifying the presence of the './check' script, executing it, waiting for its completion, and returning a success indicator if it exits cleanly. This matches the primary domain action in the source code. However, it omits secondary details such as handling of ENOENT versus other stat errors, PID spawn failure handling, and waitpid error handling, all of which are explicitly coded and relevant to behavior-critical semantics.",
                "The summary accurately describes the main function behavior: it checks for the './check' file, runs it, waits for its completion, and returns success if the exit status is zero. There are no contradictory or irrelevant claims, and the core primary purpose and I/O handling are correctly captured. The claims are broad but consistent with the source, giving modest positive gain without notable noise or fatal errors."
            ]
        },
        "comment": {
            "summary": "Checks for the existence of the \"check\" script, executes it, and returns true if it exits successfully.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary accurately reflects the core behavior: it checks for the 'check' script, runs it, and returns true (nonzero) only if it exits successfully. These claims align with the source code's flow: checking with stat, executing via spawn, and checking WEXITSTATUS. No contradictory or irrelevant statements are present, and all claims are domain-relevant, making the summary highly precise.",
                "The summary correctly captures the core purpose: verifying the existence of the 'check' script, executing it, and returning success based on its exit status. However, it omits secondary, behavior-critical details such as handling the ENOENT case by returning 1, logging warnings via bb_perror_msg for various failure scenarios, using spawn and safe_waitpid for process control, and returning 0 for errors in stat, spawn, or wait operations. These omissions limit coverage beyond the core domain action.",
                "The summary correctly captures the function\u2019s core purpose: it verifies if the \"check\" script exists, runs it, and returns success if the exit status is 0. There are no contradictory or irrelevant statements, and all claims directly map to the source code\u2019s behavior. However, the description is generic and omits specific details such as error handling for stat/spawn failures, making the informational gain modest rather than high."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586474832,
    "strip_function_name": "sub_FFFFFFFF81746B50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81746B50(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rdx\n  unsigned int v11; // ecx\n  __int64 result; // rax\n  __int64 v13; // rax\n\n  v10 = *(_QWORD *)(a2 + 48);\n  v11 = *(_DWORD *)(v10 + 2136);\n  if ( *(_BYTE *)(v10 + 2374) )\n  {\n    if ( v11 == 2 )\n      return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n    if ( v11 == 3 )\n    {\n      BYTE1(v13) = 2;\nLABEL_12:\n      if ( (v13 & 0x200) == 0 )\n        return 4294967201LL;\n      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 464) + 144LL) + 168LL) )\n        return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\nLABEL_7:\n      if ( !*(_QWORD *)(v10 + 1192) || (*(_BYTE *)(a1 + 57) & 1) != 0 && (*(_BYTE *)(a2 + 32) & 4) != 0 )\n        return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n      return 4294967201LL;\n    }\n  }\n  result = 4294967201LL;\n  if ( v11 > 0xA )\n    return result;\n  v13 = 1LL << v11;\n  if ( ((1LL << v11) & 0x586) == 0 )\n  {\n    if ( (v13 & 8) != 0 )\n      goto LABEL_7;\n    goto LABEL_12;\n  }\n  return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n",
    "function_name": "ieee80211_scan",
    "decompiled_code": "__int64 __fastcall ieee80211_scan(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rdx\n  unsigned int v11; // ecx\n  __int64 result; // rax\n  __int64 v13; // rax\n\n  v10 = *(_QWORD *)(a2 + 48);\n  v11 = *(_DWORD *)(v10 + 2136);\n  if ( *(_BYTE *)(v10 + 2374) )\n  {\n    if ( v11 == 2 )\n      return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n    if ( v11 == 3 )\n    {\n      BYTE1(v13) = 2;\nLABEL_12:\n      if ( (v13 & 0x200) == 0 )\n        return 4294967201LL;\n      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 464) + 144LL) + 168LL) )\n        return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\nLABEL_7:\n      if ( !*(_QWORD *)(v10 + 1192) || (*(_BYTE *)(a1 + 57) & 1) != 0 && (*(_BYTE *)(a2 + 32) & 4) != 0 )\n        return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n      return 4294967201LL;\n    }\n  }\n  result = 4294967201LL;\n  if ( v11 > 0xA )\n    return result;\n  v13 = 1LL << v11;\n  if ( ((1LL << v11) & 0x586) == 0 )\n  {\n    if ( (v13 & 8) != 0 )\n      goto LABEL_7;\n    goto LABEL_12;\n  }\n  return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n",
    "source_code": "\nstatic int ieee80211_scan(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = IEEE80211_WDEV_TO_SUB_IF(req->wdev);\n\n\tswitch (ieee80211_vif_type_p2p(&sdata->vif)) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (sdata->local->ops->hw_scan)\n\t\t\tbreak;\n\t\t/*\n\t\t * FIXME: implement NoA while scanning in software,\n\t\t * for now fall through to allow scanning only when\n\t\t * beaconing hasn't been configured yet\n\t\t */\n\tcase NL80211_IFTYPE_AP:\n\t\t/*\n\t\t * If the scan has been forced (and the driver supports\n\t\t * forcing), don't care about being beaconing already.\n\t\t * This will create problems to the attached stations (e.g. all\n\t\t * the  frames sent while scanning on other channel will be\n\t\t * lost)\n\t\t */\n\t\tif (sdata->u.ap.beacon &&\n\t\t    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||\n\t\t     !(req->flags & NL80211_SCAN_FLAG_AP)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ieee80211_request_scan(sdata, req);\n}",
    "comment": "Handles scanning requests for various Wi-Fi interface types, ensuring appropriate conditions are met before initiating a scan.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Manages TDLS operations for peer stations , enabling links , disabling links , and rejecting unsupported setups or discoveries based on station type .\n",
    "cpbcs_sum": "Initiates connection-related actions for a station based on specified conditions and security checks, enforcing conditions on transmission and conditions accordingly.\n",
    "misum_sum": "Handles TDLS operations for association and supported Intel uncore station based on supported conditions received and conditions in a wireless environment.\n",
    "decom_sum": "Evaluates object type and state flags to decide if a lower-level handler should process it, otherwise returns an error code 4294967201.",
    "cfg_sum": "Validates object state and type flags, then either executes the main processing routine or returns an error code based on specific conditions.",
    "work_score": {
        "decom": {
            "summary": "Evaluates object type and state flags to decide if a lower-level handler should process it, otherwise returns an error code 4294967201.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary states that the function evaluates object type and state flags to decide if a lower-level handler should process it, which matches the code's switch over interface types, conditional checks, and eventual call to ieee80211_request_scan. However, it incorrectly describes the error code as 4294967201, which is an unsigned representation of -EOPNOTSUPP; this is a misleading detail and not clearly aligned with the signed return values in context. The claim about the lower-level handler is generally accurate, but the numeric error code claim is inaccurate, resulting in mixed reliability.",
                "The summary generically mentions evaluating object type and state flags and returning an error, which loosely aligns with the function's switch-based interface type checks and EOPNOTSUPP returns. However, it fails to cover the core primary purpose of initiating an IEEE 802.11 scan via ieee80211_request_scan, omits specifics about supported interface types, AP beacon restrictions, forced scan flags, and hardware scan checks. Additionally, the error code given as 4294967201 is misleading, as the actual code is -EOPNOTSUPP. Thus, core coverage is missing and some claims are inaccurate.",
                "The summary contains one specific claim about returning an error code 4294967201, which is inaccurate because the source code returns -EOPNOTSUPP on unsupported conditions, not that numeric value. This is a FATAL error impacting the primary purpose of the function, which is deciding whether to perform a scan or return an error. While the claim about evaluating object type and state flags loosely matches the function\u2019s conditional logic, the core I/O behavior is misrepresented, making the description untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Validates object state and type flags, then either executes the main processing routine or returns an error code based on specific conditions.",
            "score": [
                0.5,
                0.3,
                0.5
            ],
            "reason": [
                "The summary contains only generic claims about validating state/flags, executing a routine, or returning an error based on conditions. While these broadly describe the flow, they omit specific, verifiable details present in the source code such as the distinct interface types handled, the AP beacon conditions, and specific error cases. As a result, the claims are safe but low-information, with minimal coverage of domain-specific behaviour, making the alignment only partial.",
                "The summary generically states that the function validates state and type flags and runs a routine or returns an error based on conditions, but it fails to mention the core domain-specific purpose of performing an IEEE 802.11 scan request and checking interface types. While the claims are broadly accurate, they are too vague to cover the core primary purpose or the specific branching logic for AP, P2P, and error cases in the source code.",
                "The summary contains mostly generic SAFE claims, noting validation of object state and type flags and conditional execution or returning an error code. These are broadly correct but lack specific, domain-relevant details from the source code, such as the handling of different interface types or scan request conditions. No FATAL inaccuracies are present, but the low specificity results in weak gain, with noise from the generic phrasing outweighing actionable detail."
            ]
        },
        "comment": {
            "summary": "Handles scanning requests for various Wi-Fi interface types, ensuring appropriate conditions are met before initiating a scan.",
            "score": [
                0.8,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function processes scan requests for different Wi-Fi interface types and applies conditions before initiating a scan. However, it is generic and omits important specifics such as the exact interface types handled, special cases for AP and P2P_GO, and the conditions under which scanning is denied. While it is broadly accurate and aligned with the high-level behavior, the lack of detail reduces precision, making it a low-information but correct statement.",
                "The summary gives a generic description of handling scan requests and checking conditions, which loosely aligns with the source code\u2019s purpose of initiating scans for specific Wi-Fi interface types based on conditions. However, it lacks the core primary purpose in specific domain terms, such as the function\u2019s role in invoking ieee80211_request_scan after selectively permitting or rejecting requests depending on interface type, hardware scan capability, beaconing state, and AP scan flags. It omits critical details like the different interface type handling and error returns, so coverage of secondary behavior is minimal.",
                "The summary is broadly correct in stating that the function handles scanning requests and checks conditions before initiating a scan, which matches the control flow over interface types and conditional returns in the source code. However, it is generic and lacks specific detail on the different interface types handled, the conditions for AP or P2P modes, and error handling, resulting in low informational gain. There are no inaccurate statements, but the gain is minimal due to the high-level nature of the summary."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580367808,
    "strip_function_name": "sub_FFFFFFFF81173BC0",
    "strip_decompiled_code": "char __fastcall sub_FFFFFFFF81173BC0(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _WORD *v10; // rdx\n  __int64 v11; // rax\n  __int64 v13; // r13\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  _QWORD *v16; // rsi\n  _QWORD *v17; // rcx\n  __int64 v18; // rdi\n  __int64 *v19; // rdx\n  __int64 v20; // rcx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n\n  v10 = *(_WORD **)(a1 + 32);\n  LOWORD(v11) = *v10 & 0xF000;\n  if ( (_WORD)v11 == 0x4000 )\n  {\n    v11 = sub_FFFFFFFF81172A10(qword_FFFFFFFF81CB89F0, (__int64)v10);\n    v13 = v11;\n    if ( v11 )\n    {\n      sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C3FC40);\n      sub_FFFFFFFF81792900(v13 + 32);\n      v16 = *(_QWORD **)(v13 + 112);\n      v17 = (_QWORD *)(v13 + 112);\n      if ( v16 )\n      {\n        while ( v16[3] != a2 || a1 != v16[2] )\n        {\n          v17 = v16;\n          v16 = (_QWORD *)*v16;\n          if ( !v16 )\n            goto LABEL_9;\n        }\n        v18 = qword_FFFFFFFF81CB8A00;\n        *v17 = *v16;\n        sub_FFFFFFFF8112DAA0(v18, (unsigned __int64)v16, a3, a4, a5, a6, v14, v15, a9, a10);\n        sub_FFFFFFFF81173AB0(v13);\n      }\nLABEL_9:\n      ++*(_BYTE *)(v13 + 32);\n      if ( !*(_QWORD *)(v13 + 112) )\n      {\n        v16 = (_QWORD *)qword_FFFFFFFF81CB89F0;\n        sub_FFFFFFFF81173110(v13, qword_FFFFFFFF81CB89F0);\n      }\n      sub_FFFFFFFF8178F1B0(&unk_FFFFFFFF81C3FC40);\n      LOBYTE(v11) = sub_FFFFFFFF81172E40(v13, (__int64)v16, v19, v20, v21, v22, a3, a4, a5, a6, v23, v24, a9, a10);\n    }\n  }\n  return v11;\n}\n",
    "function_name": "dnotify_flush",
    "decompiled_code": "char __fastcall dnotify_flush(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _WORD *v10; // rdx\n  __int64 inode_mark; // rax\n  __int64 v13; // r13\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 *v16; // rsi\n  __int64 *v17; // rcx\n  __int64 v18; // rdi\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n\n  v10 = *(_WORD **)(a1 + 32);\n  LOWORD(inode_mark) = *v10 & 0xF000;\n  if ( (_WORD)inode_mark == 0x4000 )\n  {\n    inode_mark = fsnotify_find_inode_mark(dnotify_group, (__int64)v10);\n    v13 = inode_mark;\n    if ( inode_mark )\n    {\n      mutex_lock((__int64)&dnotify_mark_mutex);\n      raw_spin_lock((volatile signed __int16 *)(v13 + 32));\n      v16 = *(__int64 **)(v13 + 112);\n      v17 = (__int64 *)(v13 + 112);\n      if ( v16 )\n      {\n        while ( v16[3] != a2 || a1 != v16[2] )\n        {\n          v17 = v16;\n          v16 = (__int64 *)*v16;\n          if ( !v16 )\n            goto LABEL_9;\n        }\n        v18 = dnotify_struct_cache;\n        *v17 = *v16;\n        kmem_cache_free(v18, v16, a3, a4, a5, a6, v14, v15, a9, a10);\n        dnotify_recalc_inode_mask(v13);\n      }\nLABEL_9:\n      ++*(_BYTE *)(v13 + 32);\n      if ( !*(_QWORD *)(v13 + 112) )\n      {\n        v16 = (__int64 *)dnotify_group;\n        fsnotify_destroy_mark(v13, dnotify_group, a3, a4, a5, a6, v14, v15, a9, a10);\n      }\n      mutex_unlock((__int64)&dnotify_mark_mutex);\n      LOBYTE(inode_mark) = fsnotify_put_mark(v13, (__int64)v16, v19, a3, a4, a5, a6, v20, v21, a9, a10);\n    }\n  }\n  return inode_mark;\n}\n",
    "source_code": "void dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_mark_mutex */\n\tif (dn_mark->dn == NULL)\n\t\tfsnotify_destroy_mark(fsn_mark, dnotify_group);\n\n\tmutex_unlock(&dnotify_mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n}",
    "comment": "Removes a dnotify structure associated with a file if the owner ID matches, and cleans up the corresponding fsnotify mark if no more notifications exist.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Removes an inotify mark from a group , updating flags and freeing associated resources if the mark is no longer in use .\n",
    "cpbcs_sum": "Releases a sysfs file system by decrementing its reference count and freeing its associated resources if it reaches zero and Releases locks.\n",
    "misum_sum": "Removes a node from a red-black tree and frees the associated memory if it matches the specified node and is not empty.\n",
    "decom_sum": "Removes a matching entry from an internal linked list, processes it with provided parameters, updates related state, and triggers subsequent handling routines.",
    "cfg_sum": "Removes a matching entry from a linked list, updates related counters, performs cleanup operations, and triggers follow-up processing based on verification results.",
    "work_score": {
        "decom": {
            "summary": "Removes a matching entry from an internal linked list, processes it with provided parameters, updates related state, and triggers subsequent handling routines.",
            "score": [
                0.6,
                0.2,
                0.5
            ],
            "reason": [
                "The summary identifies that the function removes a matching entry from a linked list and updates state, which aligns with the code's removal of a dnotify_struct matching given parameters and updating the inode mask. However, it omits key domain-specific conditions such as operating only on directories, the locking mechanisms, and cleanup of marks when the list is empty. While generally correct, it is too generic and lacks several important details, making it only partially accurate.",
                "The summary vaguely describes removing an entry from a linked list, updating state, and triggering routines, but it does not identify the core domain purpose of flushing a dnotify mark for a directory inode based on file and owner parameters. While these actions loosely correspond to parts of the code, they lack specificity about dnotify, fsnotify marks, locking, and cleanup behavior, and thus fail to capture the primary purpose or critical branch/error conditions.",
                "The summary captures that the function removes a matching entry from an internal linked list and updates related state, which is broadly accurate. However, it omits critical specifics: it only applies to directory inodes, locks and unlocks mutex/spinlocks, uses `id` and `filp` to find the match, frees the entry's memory, recalculates the inode mask, and may destroy the mark. The claim 'triggers subsequent handling routines' is vague and not clearly supported, and overall the summary is generic with low informational value. There is no outright contradiction, but the lack of detail means positive gain is low and noise is noticeable."
            ]
        },
        "cfg": {
            "summary": "Removes a matching entry from a linked list, updates related counters, performs cleanup operations, and triggers follow-up processing based on verification results.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly generic statements that do not accurately reflect the specific semantics of the source code. While 'removes a matching entry from a linked list' aligns with the loop removing the matching dnotify_struct, the claims about 'updates related counters' and 'triggers follow-up processing based on verification results' are inaccurate, as the code adjusts an inode mask and conditionally destroys marks, not counters or generic verification-based processing. The cleanup operations are partially correct, but overall less than half of the claims are precise and verifiable against the code.",
                "The summary vaguely mentions removing an entry from a linked list and cleanup, which loosely aligns with freeing a matching `dnotify_struct` and updating state. However, it does not identify the core purpose of flushing dnotify marks for a specific file/inode in a directory, omitting critical domain context and accuracy. The 'updates related counters' claim is inaccurate since the code recalculates masks rather than counters, and 'triggers follow-up processing based on verification results' is unsupported. Missing coverage of domain-specific actions, locks, condition checks, and mark destruction results in poor alignment.",
                "The summary claims the function updates related counters and triggers follow-up processing based on verification results, which are inaccurate for the given code. The code removes a matching entry from a linked list only if directory-type inode and mark match, frees its memory, recalculates an inode mask, and cleans up marks; there is no explicit counter handling or verification-result-based branching. While the linked list removal and cleanup aspects are correct, the misleading claims about counters and verification add noise without providing specific accurate insight, resulting in low overall benefit."
            ]
        },
        "comment": {
            "summary": "Removes a dnotify structure associated with a file if the owner ID matches, and cleans up the corresponding fsnotify mark if no more notifications exist.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function removes a dnotify structure when the owner ID matches and that it cleans up the fsnotify mark if no more notifications exist, which aligns with the code's conditional checks, list removal, and cleanup call to fsnotify_destroy_mark. It omits minor implementation details, such as the requirement that the target inode must be a directory, mutex/spinlock usage, and exact matching of the file pointer, but these omissions do not contradict the code. The proportion of accurate claims is high, with no incorrect or irrelevant statements present.",
                "The summary correctly states that the function removes a dnotify structure tied to a file when the owner ID matches and cleans up the fsnotify mark if no notifications remain, which matches the core domain behavior of the code. However, it omits several key secondary details such as the initial check that the inode is a directory, the use of locks (mutex and spinlock) to protect structures, and freeing memory from a cache. These omissions limit the completeness of coverage of critical behavior beyond the core purpose.",
                "The summary correctly captures the primary purpose: removing a dnotify structure for a file when the owner ID matches and cleaning up the fsnotify mark if no notifications remain. It omits technical details like directory-only checks, specific locking mechanisms, and how the match requires both owner ID and the same file pointer, but there are no inaccuracies. The claims are accurate and specific to core behavior, offering moderate insight with low noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578918368,
    "strip_function_name": "sub_FFFFFFFF81011DE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81011DE0(__int64 a1)\n{\n  unsigned __int64 v1; // r12\n  __int64 *v2; // r13\n  unsigned int v3; // r14d\n  signed int v4; // ebx\n  unsigned __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v8; // [rsp+8h] [rbp-B8h]\n  _BYTE v9[32]; // [rsp+10h] [rbp-B0h] BYREF\n  __int64 v10; // [rsp+30h] [rbp-90h]\n  __int64 v11; // [rsp+50h] [rbp-70h]\n  __int64 v12; // [rsp+58h] [rbp-68h]\n  __int64 v13; // [rsp+68h] [rbp-58h]\n  __int64 v14; // [rsp+70h] [rbp-50h]\n  __int64 v15; // [rsp+78h] [rbp-48h]\n  __int64 v16; // [rsp+80h] [rbp-40h]\n  __int64 v17; // [rsp+88h] [rbp-38h]\n  __int64 v18; // [rsp+90h] [rbp-30h]\n\n  v1 = __readgsqword(0xBC08u) + 43488;\n  ((void (__fastcall *)(__int64, __int64))off_FFFFFFFF81CB6AB8[37])(832LL, 1024LL);\n  if ( dword_FFFFFFFF81CB550C <= 0 )\n  {\n    return 0;\n  }\n  else\n  {\n    v2 = (__int64 *)v1;\n    v3 = 0;\n    v4 = 0;\n    do\n    {\n      if ( _bittest((const signed __int32 *)(v1 + 512), v4) )\n      {\n        v8 = *v2;\n        v5 = sub_FFFFFFFF81010A60(*v2);\n        if ( !_bittest64((const __int64 *)&v5, (unsigned int)(dword_FFFFFFFF81CB5514 - 1)) )\n        {\n          ++v3;\n          v10 = 0LL;\n          v13 = 0LL;\n          v14 = 0LL;\n          v15 = 0LL;\n          v16 = 0LL;\n          v6 = *(_QWORD *)(v8 + 384);\n          v17 = 0LL;\n          v18 = 0LL;\n          v12 = 0LL;\n          v11 = v6;\n          if ( (unsigned int)sub_FFFFFFFF81011590(v8) )\n          {\n            if ( (unsigned int)sub_FFFFFFFF810E2950(v8, v9, a1) )\n              sub_FFFFFFFF81010AE0(v8, 0);\n          }\n        }\n      }\n      else\n      {\n        v3 -= (_bittestandreset((signed __int32 *)(v1 + 520), v4) == 0) - 1;\n      }\n      ++v4;\n      ++v2;\n    }\n    while ( dword_FFFFFFFF81CB550C > v4 );\n    if ( v3 )\n      __incgsdword(0xEB1Cu);\n  }\n  return v3;\n}\n",
    "function_name": "x86_pmu_handle_irq",
    "decompiled_code": "__int64 __fastcall x86_pmu_handle_irq(__int64 a1)\n{\n  unsigned __int64 v1; // r12\n  _BYTE *v2; // rsi\n  __int64 *v3; // r13\n  unsigned int v4; // r14d\n  signed int v5; // ebx\n  unsigned __int64 v6; // rax\n  __int64 v7; // r8\n  int v8; // r9d\n  unsigned __int64 v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  __int64 v15; // [rsp+8h] [rbp-B8h]\n  _BYTE v16[32]; // [rsp+10h] [rbp-B0h] BYREF\n  __int64 v17; // [rsp+30h] [rbp-90h]\n  __int64 v18; // [rsp+50h] [rbp-70h]\n  __int64 v19; // [rsp+58h] [rbp-68h]\n  __int64 v20; // [rsp+68h] [rbp-58h]\n  __int64 v21; // [rsp+70h] [rbp-50h]\n  __int64 v22; // [rsp+78h] [rbp-48h]\n  __int64 v23; // [rsp+80h] [rbp-40h]\n  __int64 v24; // [rsp+88h] [rbp-38h]\n  __int64 v25; // [rsp+90h] [rbp-30h]\n\n  v1 = __readgsqword(0xBC08u) + 43488;\n  v2 = (_BYTE *)&unk_400;\n  (*((void (__fastcall **)(__int64, __int64))apic + 37))(832LL, 1024LL);\n  if ( dword_FFFFFFFF81CB550C <= 0 )\n  {\n    return 0;\n  }\n  else\n  {\n    v3 = (__int64 *)v1;\n    v4 = 0;\n    v5 = 0;\n    do\n    {\n      if ( _bittest((const signed __int32 *)(v1 + 512), v5) )\n      {\n        v15 = *v3;\n        v6 = x86_perf_event_update(*v3);\n        v9 = (unsigned int)(dword_FFFFFFFF81CB5514 - 1);\n        if ( !_bittest64((const __int64 *)&v6, v9) )\n        {\n          ++v4;\n          v17 = 0LL;\n          v20 = 0LL;\n          v21 = 0LL;\n          v22 = 0LL;\n          v23 = 0LL;\n          v10 = *(_QWORD *)(v15 + 384);\n          v24 = 0LL;\n          v25 = 0LL;\n          v19 = 0LL;\n          v18 = v10;\n          if ( (unsigned int)x86_perf_event_set_period(\n                               v15,\n                               (__int64)v2,\n                               v9,\n                               (unsigned int)dword_FFFFFFFF81CB5514,\n                               v7,\n                               v8) )\n          {\n            v2 = v16;\n            if ( (unsigned int)perf_event_overflow(v15, (__int64)v16, a1, v11, v12, v13) )\n            {\n              v2 = 0LL;\n              x86_pmu_stop(v15, 0);\n            }\n          }\n        }\n      }\n      else\n      {\n        v4 -= (_bittestandreset((signed __int32 *)(v1 + 520), v5) == 0) - 1;\n      }\n      ++v5;\n      ++v3;\n    }\n    while ( dword_FFFFFFFF81CB550C > v5 );\n    if ( v4 )\n      __incgsdword(0xEB1Cu);\n  }\n  return v4;\n}\n",
    "source_code": "\nint x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
    "comment": "Handles performance monitoring unit interrupts by checking active counters, updating event values, and managing event overflows, while ensuring proper NMI handling.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Captures the user-space call chain by traversing the stack frames from the current register state while enforcing stack depth limits .\n",
    "cpbcs_sum": "Handles machine check events by scheduling error codes and invoking a message to each active CPU in the Linux kernel.\n",
    "misum_sum": "Drains and frees all active performance monitoring events for a given CPU while handling interrupts and managing event synchronization.\n",
    "decom_sum": "Iterates over active entries, checks and processes them with validation routines, updates counters, and conditionally triggers a system status increment.",
    "cfg_sum": "Iterates over system entries, checks specific status bits, processes eligible entries, updates a global counter, and returns the count of successfully processed items.",
    "work_score": {
        "decom": {
            "summary": "Iterates over active entries, checks and processes them with validation routines, updates counters, and conditionally triggers a system status increment.",
            "score": [
                0.8,
                0.2,
                0.5
            ],
            "reason": [
                "The summary correctly notes iteration over entries, conditional processing, counter updates, and conditional status increments, which align with the source code's loop over counters, event handling, and irq stat increment. However, it omits key specifics such as distinction between active and inactive counters, overflow handling, and details of validation routines, making the description very generic. Most claims are accurate but low-information, with no major inaccuracies present.",
                "The summary is vague and omits the core purpose, which is handling x86 PMU interrupt events, including unmasking the LVTPC, detecting spurious interrupts, processing event overflows, updating sample data, setting periods, and potentially stopping events. While it notes iteration, checks, and counter updates, these are generic and lack the specific domain semantics, resulting in minimal accurate coverage of the source code\u2019s unique logic.",
                "The summary\u2019s claims are generally accurate but very generic: it notes iteration over entries, validation, counter updates, and a conditional system status increment. These loosely align with the code\u2019s looping through counters, calling event update/period routines, incrementing the handled count, and possibly calling inc_irq_stat. However, the summary omits key specifics like handling inactive counters, detecting overflows, unmasking LVTPC, and stopping events, resulting in low informational value. No claims contradict the code, but the broad, low\u2011detail nature yields only limited net benefit."
            ]
        },
        "cfg": {
            "summary": "Iterates over system entries, checks specific status bits, processes eligible entries, updates a global counter, and returns the count of successfully processed items.",
            "score": [
                0.3,
                0.3,
                0.4
            ],
            "reason": [
                "The summary captures the iterative traversal and conditional processing aspects of the function loosely, but inaccurately generalizes the domain-specific details. The source code explicitly handles hardware performance counters, tests active and running bitmasks, updates event data, and increments a global IRQ statistic for handled overflows. The summary\u2019s 'system entries' and 'status bits' are generic approximations, and 'successfully processed items' omits the distinction between spurious and overflow events. While the loop and counter aspects are correct, the lack of accuracy in core semantics means less than half of the extracted claims are precise.",
                "The summary gives a generic description of iteration, status checks, processing, and counting, but does not mention the core purpose of handling x86 PMU interrupt events in response to performance counter overflows. It omits critical domain-specific semantics such as unmasking the LVTPC, handling spurious interrupts, updating performance counters, reloading event periods, and stopping events after overflow. While some basic loop and counter-update behavior matches the code, the main domain action and key branch/error details are missing.",
                "The summary makes several domain-semantic claims: iterating over system entries, checking status bits, processing eligible entries, updating a global counter, and returning a count. While the loop and bit checks are accurate to the source code, the summary omits critical context about handling hardware performance monitoring unit IRQs, unmasking APIC LVTPC, and handling event overflow. It reframes the code generically as \"system entries\" and \"successfully processed items,\" which loses key semantics of the primary purpose, but does not introduce contradictory or false statements. The claims are mostly SAFE but low-information, with noise overtaking specific gains, leading to weak alignment."
            ]
        },
        "comment": {
            "summary": "Handles performance monitoring unit interrupts by checking active counters, updating event values, and managing event overflows, while ensuring proper NMI handling.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function handles PMU interrupts, checks active counters, updates event values, and manages overflows, which are all visible in the code. It also correctly mentions NMI handling at the start. However, the summary is slightly general and omits finer details such as handling spurious interrupts, counter unmasking specifics, and incrementing IRQ stats, but these omissions do not make the claims inaccurate. Nearly all claims align with the code semantics, showing high precision.",
                "The summary correctly states that the function handles PMU interrupts, checks active counters, updates event values, manages overflows, and handles NMIs, which aligns with the core purpose of processing x86 PMU interrupts and overflow handling. However, it lacks mention of several important secondary behaviors such as spurious interrupt detection, clearing counters, setting periods for events, stopping events on overflow, and incrementing performance IRQ statistics. These omissions mean the coverage of secondary key points is incomplete.",
                "The summary captures the core purpose accurately: it describes handling PMU interrupts, checking active counters, updating values, and managing overflows, all of which are present in the source. It also mentions ensuring proper NMI handling, which aligns with the APIC_LVTPC write at the start. The claims are specific to the source code behavior and free of contradictions, though the description is broad and lacks detailed operational specifics like spurious interrupt handling or counter period resetting, indicating low informational gain but no noise or fatal errors."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4229088,
    "strip_function_name": "sub_4087E0",
    "strip_decompiled_code": "__int64 __fastcall sub_4087E0(__int64 a1, const char *a2, char a3)\n{\n  char *v4; // rax\n  char *v5; // rbx\n  int v6; // ebp\n  int v8; // r13d\n  __int64 v9; // rbp\n  char *v10; // rax\n  regex_t *v11; // r13\n  char *v12; // rax\n\n  v4 = (char *)calloc(1uLL, 0x2002uLL);\n  if ( !v4 )\n    return (unsigned int)-1;\n  v5 = v4;\n  v6 = 0;\n  if ( strlen(a2) <= 0xFFF )\n  {\n    v6 = sub_408140(a1, 0);\n    if ( v6 > 0 )\n    {\n      v8 = a3 & 3;\n      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 96LL);\n      switch ( v8 )\n      {\n        case 1:\n          *(_DWORD *)(v9 + 12) = 13;\n          break;\n        case 2:\n          *(_DWORD *)(v9 + 12) = 16;\n          break;\n        case 3:\n          *(_DWORD *)(v9 + 12) = 20;\n          v12 = strdup(a2);\n          *(_QWORD *)(v9 + 16) = v12;\n          if ( v12 )\n          {\n            v6 = 1;\n            goto LABEL_3;\n          }\n          goto LABEL_15;\n        default:\n          *(_DWORD *)(v9 + 12) = 1;\n          break;\n      }\n      v10 = strdup(a2);\n      *(_QWORD *)(v9 + 16) = v10;\n      if ( v10 )\n      {\n        v11 = (regex_t *)calloc(1uLL, 0x40uLL);\n        if ( v11 )\n        {\n          sub_40E8D0(a2, v5, 0LL);\n          if ( regcomp(v11, v5, 0) )\n          {\n            v6 = 0;\n            free(v11);\n          }\n          else\n          {\n            *(_QWORD *)(v9 + 24) = v11;\n            v6 = 1;\n          }\n          goto LABEL_3;\n        }\n      }\nLABEL_15:\n      v6 = -1;\n    }\n  }\nLABEL_3:\n  free(v5);\n  return (unsigned int)v6;\n}\n",
    "function_name": "Findjob_set_name_expr",
    "decompiled_code": "__int64 __fastcall Findjob_set_name_expr(FindjoB *a1, char *a2, char a3)\n{\n  char *v4; // rax\n  char *v5; // rbx\n  int v6; // ebp\n  int v8; // r13d\n  ExprtesT *test; // rbp\n  char *v10; // rax\n  regex_t *v11; // r13\n  char *v12; // rax\n\n  v4 = (char *)calloc(1uLL, 0x2002uLL);\n  if ( !v4 )\n    return (unsigned int)-1;\n  v5 = v4;\n  v6 = 0;\n  if ( strlen(a2) <= 0xFFF )\n  {\n    v6 = Findjob_default_and(a1, 0);\n    if ( v6 > 0 )\n    {\n      v8 = a3 & 3;\n      test = a1->cursor->test;\n      switch ( v8 )\n      {\n        case 1:\n          test->test_type = 13;\n          break;\n        case 2:\n          test->test_type = 16;\n          break;\n        case 3:\n          test->test_type = 20;\n          v12 = strdup(a2);\n          test->arg1 = v12;\n          if ( v12 )\n          {\n            v6 = 1;\n            goto LABEL_3;\n          }\n          goto LABEL_15;\n        default:\n          test->test_type = 1;\n          break;\n      }\n      v10 = strdup(a2);\n      test->arg1 = v10;\n      if ( v10 )\n      {\n        v11 = (regex_t *)calloc(1uLL, 0x40uLL);\n        if ( v11 )\n        {\n          Xorriso__bourne_to_reg(a2, v5, 0);\n          if ( regcomp(v11, v5, 0) )\n          {\n            v6 = 0;\n            free(v11);\n          }\n          else\n          {\n            test->arg2 = v11;\n            v6 = 1;\n          }\n          goto LABEL_3;\n        }\n      }\nLABEL_15:\n      v6 = -1;\n    }\n  }\nLABEL_3:\n  free(v5);\n  return (unsigned int)v6;\n}\n",
    "source_code": "int Findjob_set_name_expr(struct FindjoB *o, char *name_expr, int flag)\n{\n char *regexpr= NULL;\n regex_t *name_re;\n struct ExprtesT *t;\n int ret;\n\n regexpr= TSOB_FELD(char, 2*SfileadrL+2);\n if(regexpr == NULL)\n   {ret= -1; goto ex;}\n if(strlen(name_expr)>=SfileadrL)\n   {ret= 0; goto ex;};\n\n ret= Findjob_default_and(o, 0);\n if(ret <= 0)\n   goto ex;\n t= o->cursor->test;\n t->test_type= 1;\n if ((flag & 3) == 1)\n   t->test_type= 13;\n else if((flag & 3) == 2)\n   t->test_type= 16;\n else if((flag & 3) == 3)\n   t->test_type= 20;\n t->arg1= strdup(name_expr);\n if(t->arg1 == NULL)\n   {ret= -1; goto ex;};\n\n if((flag & 3) == 3)\n   {ret= 1; goto ex;}\n\n name_re= (regex_t *) calloc(1, sizeof(regex_t));\n if(name_re == NULL)\n   {ret= -1; goto ex;};\n Xorriso__bourne_to_reg(name_expr, regexpr, 0);\n if(regcomp(name_re, regexpr, 0) != 0) {\n   free((char *) name_re);\n   {ret= 0; goto ex;};\n }\n t->arg2= name_re;\n ret= 1;\nex:;\n Xorriso_free_meM(regexpr);\n return(ret);\n}",
    "comment": "Constructs a regex from a given name expression and updates a job's testing criteria based on a specified flag, returning success status.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a pattern to exclusion lists in a filesystem based on specified flags and conditions , allocating memory for the new pattern .\n",
    "cpbcs_sum": "Sets the application type and corresponding objects in a FindjoB structure based on provided flags, ensuring valid boot file paths.\n",
    "misum_sum": "Sets the file name in a structure based on the provided file name, caching the mode and managing memory allocation and errors.\n",
    "decom_sum": "Compiles a regular expression from the given pattern, stores it with associated mode settings, and returns success or error status.",
    "cfg_sum": "Compiles a regular expression from the given pattern, stores it with associated settings, and returns success or failure after proper memory management.",
    "work_score": {
        "decom": {
            "summary": "Compiles a regular expression from the given pattern, stores it with associated mode settings, and returns success or error status.",
            "score": [
                0.5,
                0.5,
                0.5
            ],
            "reason": [
                "The summary captures some accurate elements, such as compiling a regular expression from the provided pattern and returning a success or error status, which are directly reflected in the code. However, it omits several critical, specific behaviors\u2014like conditional test_type assignment based on the flag, handling of different error conditions, and storing the compiled regex in a particular struct field\u2014which means it is incomplete. With only about half of its claims accurate and domain-specific, the reliability is mixed.",
                "The summary accurately notes the compilation of a regular expression and storing it with related mode settings, which reflects part of the code's behavior. However, it does not mention the core purpose of setting up a Findjob test structure with specific test types based on the flag, nor the allocation and handling of regexpr buffers, length checks, and conditional bypasses. Coverage of secondary details like input validation and early exits is missing, making the description incomplete despite some correct points.",
                "The summary contains a broad, generic claim that the function compiles a regex from a given pattern, stores it with mode settings, and returns success or error. This is partially accurate \u2014 the code does compile a regex and return a status, but it also has conditional logic where regex compilation is skipped under certain flags, memory allocation checks, and specific handling of test types, which are not captured. The omission of these conditions reduces specificity and informational value, but there are no outright contradictions to the source code. The worst failure mode is low-info NOISE, as the summary lacks key operational details and does not misrepresent core behavior."
            ]
        },
        "cfg": {
            "summary": "Compiles a regular expression from the given pattern, stores it with associated settings, and returns success or failure after proper memory management.",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function compiles a regular expression from the provided pattern, stores it, and returns a success or failure status, which matches the source code. However, it omits important specifics such as the handling of the 'flag' parameter affecting 'test_type', early return cases for certain flags and errors, and the initial call to 'Findjob_default_and'. The memory management aspect is mentioned but not detailed, reducing completeness. Overall, most claims are accurate but lack detail, resulting in only moderately high alignment.",
                "The summary correctly mentions compiling a regular expression from the given pattern and handling memory, which matches the code's regex compilation and cleanup steps. However, it omits the core action of setting the test type and arguments in the Findjob's test structure based on the flag, which is central to the function's purpose. It also lacks mention of input validation, various error/return conditions, and the branching logic that bypasses regex compilation for certain flag values.",
                "The summary correctly notes regular expression compilation, storage, and success/failure return with memory management, which matches the code\u2019s creation of a regex from `name_expr`, allocation and cleanup of buffers. However, it omits key conditional logic based on `flag` that changes `test_type` and skips compilation in one case, and it does not mention input length checks or early returns. These omissions reduce specificity and are mildly misleading because they imply regex compilation always runs. The inaccuracies are minor and consist mainly of noise from generic phrasing rather than fatal errors on primary purpose."
            ]
        },
        "comment": {
            "summary": "Constructs a regex from a given name expression and updates a job's testing criteria based on a specified flag, returning success status.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function constructs a regex from the provided name expression, updates the job's testing criteria based on the flag, and returns a success status. These claims align with the source code: the regex is built via Xorriso__bourne_to_reg and regcomp, the flag determines test_type values, and the function returns status codes. No inaccurate or irrelevant claims are present, so the proportion of accurate claims is very high.",
                "The summary accurately captures the core purpose: creating a regex from the provided name expression and updating the job's test criteria based on the flag, with return status indicating success. However, it omits several secondary details such as memory allocation and cleanup, handling of string length limits, different test_type values corresponding to flag cases, early returns for certain flags, and regex compilation failure handling. These omissions reduce completeness despite correct core coverage.",
                "The summary correctly identifies the core behavior of constructing a regex from the provided name expression and updating the job's testing criteria based on the flag, which matches the source code's use of regex creation and test_type assignment. It omits finer details such as the conditions under which regex compilation is skipped, handling of memory allocation failures, and specific flag-to-test_type mappings, but there are no contradictory or irrelevant claims. The claims are accurate but somewhat generic, providing only a broad overview without deeper specifics, resulting in moderate information gain and minimal noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583342224,
    "strip_function_name": "sub_FFFFFFFF81449E90",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81449E90(__int64 a1, char a2)\n{\n  __int64 result; // rax\n  int v4; // esi\n  unsigned __int16 v5; // cx\n  unsigned __int16 v6; // cx\n  unsigned int v7; // ecx\n  int v8; // [rsp+0h] [rbp-18h] BYREF\n  unsigned int v9[5]; // [rsp+4h] [rbp-14h] BYREF\n\n  result = *(_QWORD *)(a1 + 3024);\n  if ( (result & 0x40) != 0 )\n  {\n    result = *(unsigned int *)(a1 + 3412);\n    if ( (*(_QWORD *)(a1 + 3024) & 0x2000LL) == 0 || (result & 0x20) == 0 )\n    {\n      if ( (result & 0x40) != 0 )\n      {\n        result = sub_FFFFFFFF81448B00(a1, *(unsigned __int8 *)(a1 + 3404), 31, &v8);\n        if ( !(_DWORD)result )\n        {\n          HIBYTE(v6) = BYTE1(v8);\n          LOBYTE(v6) = v8 | 0x80;\n          sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 31, v6);\n          if ( !(unsigned int)sub_FFFFFFFF81448B00(a1, *(unsigned __int8 *)(a1 + 3404), 27, v9) )\n          {\n            if ( a2 )\n              v7 = v9[0] | 0x20;\n            else\n              v7 = v9[0] & 0xFFFFFFDF;\n            v9[0] = v7;\n            sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 27, v7);\n          }\n          return sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 31, v8);\n        }\n      }\n      else\n      {\n        v4 = *(unsigned __int8 *)(a1 + 3404);\n        if ( *(_DWORD *)(a1 + 3232) >> 12 == 22404 && a2 )\n        {\n          sub_FFFFFFFF81448910(a1, v4, 28, 0x941Du);\n          v5 = -22495;\n        }\n        else\n        {\n          sub_FFFFFFFF81448910(a1, v4, 28, 0x941Fu);\n          v5 = a2 == 0 ? -22527 : -22495;\n        }\n        return sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 28, v5);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "tg3_phy_toggle_apd",
    "decompiled_code": "__int64 __fastcall tg3_phy_toggle_apd(__int64 a1, char a2)\n{\n  __int64 result; // rax\n  int v4; // esi\n  unsigned __int16 v5; // cx\n  unsigned __int16 v6; // cx\n  unsigned int v7; // ecx\n  int v8; // [rsp+0h] [rbp-18h] BYREF\n  unsigned int v9[5]; // [rsp+4h] [rbp-14h] BYREF\n\n  result = *(_QWORD *)(a1 + 3024);\n  if ( (result & 0x40) != 0 )\n  {\n    result = *(unsigned int *)(a1 + 3412);\n    if ( (*(_QWORD *)(a1 + 3024) & 0x2000LL) == 0 || (result & 0x20) == 0 )\n    {\n      if ( (result & 0x40) != 0 )\n      {\n        result = _tg3_readphy(a1, *(unsigned __int8 *)(a1 + 3404), 31, &v8);\n        if ( !(_DWORD)result )\n        {\n          HIBYTE(v6) = BYTE1(v8);\n          LOBYTE(v6) = v8 | 0x80;\n          _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 31, v6);\n          if ( !(unsigned int)_tg3_readphy(a1, *(unsigned __int8 *)(a1 + 3404), 27, v9) )\n          {\n            if ( a2 )\n              v7 = v9[0] | 0x20;\n            else\n              v7 = v9[0] & 0xFFFFFFDF;\n            v9[0] = v7;\n            _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 27, v7);\n          }\n          return _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 31, v8);\n        }\n      }\n      else\n      {\n        v4 = *(unsigned __int8 *)(a1 + 3404);\n        if ( *(_DWORD *)(a1 + 3232) >> 12 == 22404 && a2 )\n        {\n          _tg3_writephy(a1, v4, 28, 0x941Du);\n          v5 = -22495;\n        }\n        else\n        {\n          _tg3_writephy(a1, v4, 28, 0x941Fu);\n          v5 = a2 == 0 ? -22527 : -22495;\n        }\n        return _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 28, v5);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)\n{\n\tu32 reg;\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    (tg3_flag(tp, 5717_PLUS) &&\n\t     (tp->phy_flags & TG3_PHYFLG_MII_SERDES)))\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\ttg3_phy_fet_toggle_apd(tp, enable);\n\t\treturn;\n\t}\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_SCR5_SEL |\n\t      MII_TG3_MISC_SHDW_SCR5_LPED |\n\t      MII_TG3_MISC_SHDW_SCR5_DLPTLM |\n\t      MII_TG3_MISC_SHDW_SCR5_SDTL |\n\t      MII_TG3_MISC_SHDW_SCR5_C125OE;\n\tif (tg3_asic_rev(tp) != ASIC_REV_5784 || !enable)\n\t\treg |= MII_TG3_MISC_SHDW_SCR5_DLLAPD;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_APD_SEL |\n\t      MII_TG3_MISC_SHDW_APD_WKTM_84MS;\n\tif (enable)\n\t\treg |= MII_TG3_MISC_SHDW_APD_ENABLE;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n}",
    "comment": "Toggles the APD feature of a PHY interface based on device flags and configurations, writing appropriate values to the hardware registers.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Configures the MAC mode for a network device based on specific conditions and flags , ensuring compatibility with hardware specifications .\n",
    "cpbcs_sum": "Toggles the auxiliary control register based on the current PHY register in the tg3 device, writing or power-down bit accordingly.\n",
    "misum_sum": "Configures the PHY auto-negotiation settings based on the power management capabilities and auto-negotiation mask, adjusting for link status and link speed accordingly.\n",
    "decom_sum": "Configures device registers based on status flags and input parameter to enable or disable specific hardware features during operation.",
    "cfg_sum": "Updates device register values based on memory flags and input byte, modifying specific bitfields and issuing configuration commands when conditions are met.",
    "work_score": {
        "decom": {
            "summary": "Configures device registers based on status flags and input parameter to enable or disable specific hardware features during operation.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function configures registers based on flags and an input parameter to enable or disable hardware features, which aligns with the code's conditional checks and register writes. However, it omits specific details such as the handling for different PHY types, special cases for ASIC revisions, and the precise nature of the features toggled (APD). The claims are generic but accurate in describing the overall behavior, with no clear inaccuracies.",
                "The summary gives a generic description of configuring registers based on flags and a parameter, which loosely aligns with the code\u2019s behavior but fails to state the core purpose: toggling the PHY\u2019s Auto Power Down feature for certain tg3 devices with specific hardware conditions. It omits critical domain-specific aspects such as conditional early exits for certain chip revisions, handling FET-type PHYs via a different function, and programming specific shadow registers. While the claim is accurate at a high level, it lacks coverage of the core primary purpose and other key semantics.",
                "The summary makes a single broad claim that the function configures device registers based on flags and an input parameter to enable or disable hardware features. This is generally accurate but very generic, lacking specifics about the PHY type checks, ASIC revision condition, and particular APD-related features the function toggles. There are no contradictory statements (no FATAL), but the gain is low because the summary omits detailed domain semantics from the code, leaving mostly boilerplate utility. Noise is minimal, accuracy is present but shallow."
            ]
        },
        "cfg": {
            "summary": "Updates device register values based on memory flags and input byte, modifying specific bitfields and issuing configuration commands when conditions are met.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary is inaccurate because it misstates key aspects of the function's behavior. The source code operates on PHY register values using constants, flags, and boolean input, not generic 'memory flags' or an 'input byte'. It involves specific chip revision checks, PHY flag conditions, and calls to hardware-specific helper functions, none of which are explicitly or correctly described. The wording is too generic, omitting critical domain-semantic details and introducing incorrect terminology, resulting in less than half of the claims aligning with the source code.",
                "The summary fails to capture the core purpose, which is toggling the PHY's Auto Power Down functionality for certain Broadcom tg3 hardware variants, including early returns based on specific flags and specialized handling for FET PHYs. While it generically mentions updating registers based on flags and input, it omits the APD toggling context and specific branch conditions critical to the source code's semantics. Secondary details like two distinct register writes and ASIC revision checks are also missing.",
                "The summary contains inaccuracies: it describes updating device registers based on 'memory flags' and an 'input byte', which contradicts the code that uses specific struct fields, feature flags, and a boolean 'enable' parameter. This misrepresents the core purpose and key I/O, making it a FATAL error regarding the primary behavior. While it vaguely notes modifying bitfields and issuing configuration commands, these generic claims lack specificity and do not offset the severe inaccuracy."
            ]
        },
        "comment": {
            "summary": "Toggles the APD feature of a PHY interface based on device flags and configurations, writing appropriate values to the hardware registers.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly reflects the core semantics of the function: it toggles the APD feature depending on device flags/configuration and writes to hardware registers. It aligns well with the source code, which checks specific flags and conditions before composing register values and calling tg3_writephy. The summary omits certain details like special handling for FET PHYs and specific register bit manipulations, but these omissions don't introduce inaccuracies. Nearly all claims are accurate and domain-relevant.",
                "The summary accurately states the core purpose of toggling the APD feature on a PHY interface and mentions hardware register writes, aligning with the function\u2019s main domain action. However, it omits important specifics such as distinct handling for FET-type PHYs, conditional early returns based on tg3_flag checks, special treatment for ASIC_REV_5784, and detailed register field configurations. These missing details reduce coverage of secondary behavior-critical semantics.",
                "The summary accurately captures the primary purpose of the function: toggling the APD feature for a PHY interface depending on device flags and configuration, and performing hardware register writes to enact this. It is factually correct and directly reflects the code's domain semantics without contradictions or irrelevant noise. However, it remains fairly generic, lacking detail about specific flag checks, conditional flows for different PHY types, and register field manipulation, so the informational gain is modest."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581900960,
    "strip_function_name": "sub_FFFFFFFF812EA0A0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF812EA0A0(\n        unsigned int a1,\n        unsigned int a2,\n        unsigned int a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  unsigned int v18; // eax\n  unsigned int v19; // eax\n  __int64 *v20; // rdx\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n\n  v14 = (unsigned int *)sub_FFFFFFFF8112CA50(\n                          (_QWORD *)qword_FFFFFFFF81E8C710,\n                          0x80D0u,\n                          160LL,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9,\n                          a10,\n                          a11,\n                          a12);\n  if ( v14 )\n  {\n    v17 = v14;\n    *v14 = a1;\n    v14[1] = a2;\n    sub_FFFFFFFF812E9D70(257, a3, v14, 0LL, a5, a6, a7, a8, v15, v16, a11, a12);\n    *(_DWORD *)(a4 + 12) = a1;\n    *(_DWORD *)(a4 + 16) = a2;\n    v18 = v17[25];\n    *(_DWORD *)(a4 + 8) = a3;\n    *(_DWORD *)(a4 + 20) = v18;\n    *(_DWORD *)(a4 + 24) = v17[26];\n    *(_DWORD *)(a4 + 28) = v17[27];\n    *(_DWORD *)(a4 + 32) = v17[28];\n    *(_DWORD *)(a4 + 36) = v17[29];\n    *(_DWORD *)(a4 + 40) = v17[30];\n    v19 = v17[31];\n    *(_DWORD *)(a4 + 52) = 0;\n    *(_QWORD *)(a4 + 44) = v19;\n    sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a5, a6, a7, a8, v24, v25, a11, a12, a3, v20, v21, v22, v23);\n  }\n}\n",
    "function_name": "calc_mode_timings",
    "decompiled_code": "void __fastcall calc_mode_timings(\n        unsigned int a1,\n        unsigned int a2,\n        unsigned int a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  unsigned int v18; // eax\n  unsigned int v19; // eax\n  __int64 *v20; // rdx\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n\n  v14 = (unsigned int *)kmem_cache_alloc_trace(\n                          (__int64 *)qword_FFFFFFFF81E8C710,\n                          32976LL,\n                          160LL,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9,\n                          a10,\n                          a11,\n                          a12);\n  if ( v14 )\n  {\n    v17 = v14;\n    *v14 = a1;\n    v14[1] = a2;\n    fb_get_mode(257, a3, v14, 0LL, a5, a6, a7, a8, v15, v16, a11, a12);\n    *(_DWORD *)(a4 + 12) = a1;\n    *(_DWORD *)(a4 + 16) = a2;\n    v18 = v17[25];\n    *(_DWORD *)(a4 + 8) = a3;\n    *(_DWORD *)(a4 + 20) = v18;\n    *(_DWORD *)(a4 + 24) = v17[26];\n    *(_DWORD *)(a4 + 28) = v17[27];\n    *(_DWORD *)(a4 + 32) = v17[28];\n    *(_DWORD *)(a4 + 36) = v17[29];\n    *(_DWORD *)(a4 + 40) = v17[30];\n    v19 = v17[31];\n    *(_DWORD *)(a4 + 52) = 0;\n    *(_QWORD *)(a4 + 44) = v19;\n    kfree((__int64 *)v17, a5, a6, a7, a8, v21, v22, a11, a12, a3, v20);\n  }\n}\n",
    "source_code": "\nstatic void calc_mode_timings(int xres, int yres, int refresh,\n\t\t\t      struct fb_videomode *mode)\n{\n\tstruct fb_var_screeninfo *var;\n\n\tvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\n\n\tif (var) {\n\t\tvar->xres = xres;\n\t\tvar->yres = yres;\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,\n\t\t\t    refresh, var, NULL);\n\t\tmode->xres = xres;\n\t\tmode->yres = yres;\n\t\tmode->pixclock = var->pixclock;\n\t\tmode->refresh = refresh;\n\t\tmode->left_margin = var->left_margin;\n\t\tmode->right_margin = var->right_margin;\n\t\tmode->upper_margin = var->upper_margin;\n\t\tmode->lower_margin = var->lower_margin;\n\t\tmode->hsync_len = var->hsync_len;\n\t\tmode->vsync_len = var->vsync_len;\n\t\tmode->vmode = 0;\n\t\tmode->sync = 0;\n\t\tkfree(var);\n\t}\n}",
    "comment": "Calculates video mode timings based on resolution and refresh rate, populating the provided fb_videomode structure with these settings.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Allocates and initializes a framebuffer console structure with specified dimensions , display modes , and character widths , handling memory allocation failures .\n",
    "cpbcs_sum": "Schedules a deferred execution of a framebuffer helper device by allocating memory and copying data between the specified port and port.\n",
    "misum_sum": "Adds a new PCI device to the bus's state, allocating memory and setting up linked lists for the specified device list.\n",
    "decom_sum": "Allocates and initializes a 160-byte structure with provided parameters, updates related output fields, and finalizes it through a secondary processing routine.",
    "cfg_sum": "Initializes a data structure with provided parameters, processes it through helper routines, updates output fields, and releases resources upon successful allocation.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a 160-byte structure with provided parameters, updates related output fields, and finalizes it through a secondary processing routine.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes allocation of a structure and updating output fields, which aligns with the code creating and filling an fb_var_screeninfo and fb_videomode. However, it introduces an inaccurate claim about the structure size being 160 bytes (not stated or implied in code) and a vague 'secondary processing routine' that does not clearly map to fb_get_mode's specific timing retrieval. These inaccuracies reduce the proportion of precise, verifiable claims to below half.",
                "The summary incorrectly specifies allocation of a 160-byte structure, which is not evident from the code and contradicts the actual use of kzalloc with sizeof(struct fb_var_screeninfo). It fails to cover the core purpose, which is to compute and fill framebuffer mode timing parameters using fb_get_mode based on resolution and refresh rate. While it mentions allocation and updating fields, it omits the key timing computation and critical details such as copying specific margins and sync lengths, and freeing the allocated memory, resulting in missing core and secondary semantics.",
                "The summary contains a key inaccuracy: it states that the function allocates and initializes a 160-byte structure, but the source code allocates a struct whose size is dependent on fb_var_screeninfo and is not explicitly 160 bytes. This is a FATAL error on the primary purpose since it misrepresents a core allocation detail. While the summary mentions updating output fields and a secondary processing routine (fb_get_mode), these points are vaguely correct but lack specificity. The severe inaccuracy on a core action greatly undermines trust in the summary."
            ]
        },
        "cfg": {
            "summary": "Initializes a data structure with provided parameters, processes it through helper routines, updates output fields, and releases resources upon successful allocation.",
            "score": [
                0.9,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly captures the allocation of a structure, setting of parameters, use of a helper function to process it, updating output fields, and freeing resources, which matches the code's behavior. All claims are accurately tied to the source code semantics without contradictions or unrelated noise.",
                "The summary correctly notes allocation, parameter initialization, use of helper functions, updating of output fields, and freeing resources, which are accurate observations from the code. However, it fails to capture the core purpose of computing framebuffer video mode timings based on x/y resolution and refresh rate, omitting critical specifics like copying detailed timing margins and sync lengths from the computed mode. Coverage is generic and lacks domain-specific detail, leaving the primary purpose unaddressed despite some accurate secondary information.",
                "The summary correctly notes initialization of a structure with given parameters, use of a helper function, updating output fields, and freeing resources, which aligns with the code\u2019s allocation of fb_var_screeninfo, populating fields, calling fb_get_mode, transferring values to mode, and kfree. However, it is generic and omits key specifics such as exact fields set (xres, yres, margins, sync lengths), function names, and specific constants used, resulting in low informational gain. No inaccurate or contradictory statements are present, so there is no FATAL, but the gain is minimal."
            ]
        },
        "comment": {
            "summary": "Calculates video mode timings based on resolution and refresh rate, populating the provided fb_videomode structure with these settings.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary accurately describes the function\u2019s core purpose: computing video mode timings from resolution and refresh rate and setting fields in the provided fb_videomode struct. This matches the source code behavior, which allocates a temporary fb_var_screeninfo, computes timings via fb_get_mode, and copies relevant fields to the mode structure before freeing the temporary variable. There are no contradictory or irrelevant claims, and the coverage of functionality is correct though it omits specific details like margins and sync lengths.",
                "The summary correctly states that the function calculates video mode timings from resolution and refresh rate and fills the provided fb_videomode structure, which matches the core domain purpose in the source code. However, it omits multiple secondary details such as usage of a temporary fb_var_screeninfo structure, invocation of fb_get_mode with specific flags, assignment of individual timing parameters like margins and sync lengths, and the freeing of allocated memory. Coverage is accurate but limited to the core with minimal secondary information.",
                "The summary correctly states the core purpose of the function: calculating video mode timings using resolution and refresh rate, and filling the given fb_videomode structure with the results. This matches the source code's behavior, which allocates a temporary fb_var_screeninfo, sets xres, yres, calls fb_get_mode, and copies timing fields into mode before freeing var. There are no incorrect or noisy claims, but the description is generic and lacks detailed specifics (e.g., mention of margins, sync lengths, pixclock fields), so the informational gain is low."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4810656,
    "strip_function_name": "sub_4967A0",
    "strip_decompiled_code": "__int64 __fastcall sub_4967A0(_QWORD *a1, _DWORD *a2, int a3)\n{\n  _DWORD *v4; // rbp\n  void *v6; // rdi\n  __int64 result; // rax\n  void *v8; // rax\n  unsigned int v9; // [rsp+Ch] [rbp-2Ch]\n  _QWORD *v10; // [rsp+10h] [rbp-28h] BYREF\n  __int64 v11[4]; // [rsp+18h] [rbp-20h] BYREF\n\n  v4 = a2;\n  v10 = 0LL;\n  if ( a2 )\n  {\n    v6 = (void *)a1[629];\n    if ( v6 )\n      goto LABEL_3;\nLABEL_14:\n    v8 = calloc(0x8000uLL, 1uLL);\n    a1[629] = v8;\n    if ( !v8 )\n      return 4029743098LL;\nLABEL_17:\n    v11[0] = (__int64)v4;\n    result = sub_4957F0(a1 + 629, a1 + 630, (__int64)v4);\n    if ( (int)result < 0 )\n      return result;\n    goto LABEL_4;\n  }\n  v4 = (_DWORD *)a1[1];\n  v6 = (void *)a1[629];\n  if ( !v6 )\n    goto LABEL_14;\nLABEL_3:\n  if ( (a3 & 1) == 0 )\n  {\n    memset(v6, 0, 0x8000uLL);\n    goto LABEL_17;\n  }\nLABEL_4:\n  result = sub_490240(v4, &v10);\n  if ( (int)result >= 0 )\n  {\n    while ( (unsigned int)sub_490300((__int64 (__fastcall ***)(_QWORD))v10, (__int64)v11) == 1 )\n    {\n      result = sub_4957F0(a1 + 629, a1 + 630, v11[0]);\n      if ( (int)result >= 0 )\n      {\n        if ( (unsigned int)sub_48FF60(v11[0]) )\n          continue;\n        result = sub_4967A0(a1, v11[0], a3 | 1u);\n        if ( (int)result >= 0 )\n          continue;\n      }\n      goto LABEL_10;\n    }\n    result = 1LL;\nLABEL_10:\n    if ( v10 )\n    {\n      v9 = result;\n      sub_490D40(v10);\n      return v9;\n    }\n  }\n  return result;\n}\n",
    "function_name": "img_collect_inos",
    "decompiled_code": "int __fastcall img_collect_inos(__int64 a1, IsoDir *a2, int a3)\n{\n  IsoDir *v4; // rbp\n  void *v6; // rdi\n  int result; // eax\n  void *v8; // rax\n  int v9; // [rsp+Ch] [rbp-2Ch]\n  IsoDirIter *iter; // [rsp+10h] [rbp-28h] BYREF\n  IsoNode *node; // [rsp+18h] [rbp-20h] BYREF\n\n  v4 = a2;\n  iter = 0LL;\n  if ( a2 )\n  {\n    v6 = *(void **)(a1 + 5032);\n    if ( v6 )\n      goto LABEL_3;\nLABEL_14:\n    v8 = calloc(0x8000uLL, 1uLL);\n    *(_QWORD *)(a1 + 5032) = v8;\n    if ( !v8 )\n      return -265224198;\nLABEL_17:\n    node = &v4->node;\n    result = img_register_ino((IsoImage *)(a1 + 5032), (IsoNode *)(a1 + 5040), &v4->node);\n    if ( result < 0 )\n      return result;\n    goto LABEL_4;\n  }\n  v4 = *(IsoDir **)(a1 + 8);\n  v6 = *(void **)(a1 + 5032);\n  if ( !v6 )\n    goto LABEL_14;\nLABEL_3:\n  if ( (a3 & 1) == 0 )\n  {\n    memset(v6, 0, 0x8000uLL);\n    goto LABEL_17;\n  }\nLABEL_4:\n  result = iso_dir_get_children(v4, &iter);\n  if ( result >= 0 )\n  {\n    while ( iso_dir_iter_next(iter, &node) == 1 )\n    {\n      result = img_register_ino((IsoImage *)(a1 + 5032), (IsoNode *)(a1 + 5040), node);\n      if ( result >= 0 )\n      {\n        if ( iso_node_get_type(node) )\n          continue;\n        result = img_collect_inos(a1, (IsoDir *)node, a3 | 1);\n        if ( result >= 0 )\n          continue;\n      }\n      goto ex;\n    }\n    result = 1;\nex:\n    if ( iter )\n    {\n      v9 = result;\n      iso_dir_iter_free(iter);\n      return v9;\n    }\n  }\n  return result;\n}\n",
    "source_code": "int img_collect_inos(IsoImage *image, IsoDir *dir, int flag)\n{\n    int ret, register_dir = 1;\n    IsoDirIter *iter = NULL;\n    IsoNode *node;\n    IsoDir *subdir;\n\n    if (dir == NULL)\n        dir = image->root;\n    if (image->used_inodes == NULL) {\n        image->used_inodes = calloc(ISO_USED_INODE_RANGE / 8, 1);\n        if (image->used_inodes == NULL)\n            return ISO_OUT_OF_MEM;\n    } else if(!(flag & 1)) {\n        memset(image->used_inodes, 0, ISO_USED_INODE_RANGE / 8);\n    } else {\n        register_dir = 0;\n    }\n    if (register_dir) {\n        node = (IsoNode *) dir;\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            return ret;\n    }\n\n    ret = iso_dir_get_children(dir, &iter);\n    if (ret < 0)\n        return ret;\n    while (iso_dir_iter_next(iter, &node) == 1 ) {\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            goto ex;\n        if (iso_node_get_type(node) == LIBISO_DIR) {\n            subdir = (IsoDir *) node;\n            ret = img_collect_inos(image, subdir, flag | 1);\n            if (ret < 0)\n                goto ex;\n        }\n    }\n    ret = 1;\nex:;\n    if (iter != NULL)\n        iso_dir_iter_free(iter);\n    return ret;\n}",
    "comment": "Registers inodes for an ISO image and its subdirectories, initializing used inode tracking if necessary.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Sets the unique identifier for an ISO image , allocating memory for it and optionally updating it with the provided IsoNode .\n",
    "cpbcs_sum": "Recursively traverses ISO nodes based on LBA entries, devices, and symbolic them into a dynamically allocated result for further processing.\n",
    "misum_sum": "Updates the `IsoNode` pointers and volume time of an ISO image, managing memory and filesystem pointers based on the specified conditions.\n",
    "decom_sum": "Recursively processes and clears 32KB data buffers, allocating them if needed, and traverses linked items through helper calls for further processing.",
    "cfg_sum": "Allocates or resets a 32KB buffer, processes provided or default data through iterative subroutine calls, and recursively handles nested structures before cleanup.",
    "work_score": {
        "decom": {
            "summary": "Recursively processes and clears 32KB data buffers, allocating them if needed, and traverses linked items through helper calls for further processing.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains multiple inaccurate claims relative to the source code. It incorrectly describes '32KB data buffers' being processed and cleared, which is not present; the code instead manages a bitmap of used inodes. The claim about 'linked items' is vaguely aligned with traversing directory children, but lacks specificity and mixes in unrelated buffer terminology. Overall, most claims contradict or fail to target the actual semantics, with only minimal partial alignment to recursive traversal behavior.",
                "The summary inaccurately describes the core behavior, referring to '32KB data buffers' which are not present in the code, and omits the actual primary purpose of recursively registering used inodes for directories and their children in an ISO image. It also misidentifies the nature of the traversal, calling them 'linked items' rather than directory entries, and fails to mention error handling, flag behavior, or allocation specifics tied to inode tracking. No [ACCURATE] claim matches the true core purpose.",
                "The summary contains multiple inaccurate claims about the source code. It wrongly states that the function processes and clears 32KB data buffers, which is not reflected in the code \u2014 the code deals with inode tracking via a bitmap of ISO_USED_INODE_RANGE, not generic data buffers. It also misattributes traversal to 'linked items' rather than iterating directory children and registering inodes, missing the primary purpose. These misinterpretations are FATAL because they misrepresent the core action (recursive inode registration and directory traversal), making the summary untrustworthy. No accurate domain-specific claims are present to offer positive gain."
            ]
        },
        "cfg": {
            "summary": "Allocates or resets a 32KB buffer, processes provided or default data through iterative subroutine calls, and recursively handles nested structures before cleanup.",
            "score": [
                0.6,
                0.3,
                0.3
            ],
            "reason": [
                "The summary contains some accurate elements, such as allocating or resetting a buffer and recursively handling nested structures, which align with the code's use of calloc/memset for `used_inodes` and recursive calls for subdirectories. However, the buffer size detail of 32KB is inaccurate\u2014the code uses `ISO_USED_INODE_RANGE/8`, whose value is not specified in the source. Additionally, the description of processing 'provided or default data through iterative subroutine calls' is vague and does not concretely reflect the inode registration and directory iteration logic, resulting in mixed precision with less than 80% accuracy.",
                "The summary's claim about allocating or resetting a 32KB buffer loosely corresponds to initializing or clearing `image->used_inodes`, but the size detail is speculative and not in the code. It generically mentions processing data and recursively handling nested structures, which vaguely aligns with iterating over directory nodes and recursing into subdirectories. However, it fails to cover the core purpose: registering inodes for all nodes in a directory tree within an ISO image. Critical behavior like conditional buffer initialization, inode registration via `img_register_ino`, error handling, and iteration specifics are omitted or too vague, resulting in incomplete coverage of key semantics.",
                "The summary contains several inaccuracies: it misstates the buffer size as 32KB instead of matching the code\u2019s calloc/memset of ISO_USED_INODE_RANGE/8, and vaguely refers to 'provided or default data' rather than directories and inode tracking. The description of iterative subroutine calls and recursive handling of nested structures is somewhat aligned to the code\u2019s iteration over directory children and recursion into subdirectories, but lacks specificity about inode registration and the flag logic. These shortcomings include significant noise and a key factual error about the buffer, reducing trust in the core behavioral description."
            ]
        },
        "comment": {
            "summary": "Registers inodes for an ISO image and its subdirectories, initializing used inode tracking if necessary.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function registers inodes for an ISO image and its subdirectories, and initializes tracking if needed, which matches the source code\u2019s behavior of setting up used_inodes, registering the root if required, iterating through children, and recursively handling subdirectories. While brief, it is factually accurate and aligned with the core semantics.",
                "The summary accurately mentions registering inodes for the ISO image and its subdirectories and initializing the used inode tracking, which covers the core domain purpose shown in the source code. However, it omits critical secondary details such as handling a null directory by defaulting to the root, conditional clearing of the used inode array based on flags, recursion flag handling, traversal via iso_dir_get_children and iso_dir_iter_next, type checks for directories, and memory allocation error handling. The coverage of these important behaviors is minimal, limiting completeness.",
                "The summary accurately states the primary purpose of the function, which is registering inodes for an ISO image and its subdirectories, and mentions initialization of used inode tracking if needed. There are no incorrect claims contradicting the code, and while the information is correct, it is generic and lacks detail on specific control flow, error handling, and recursive traversal logic. The gain is low due to minimal specificity, but noise is absent."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 705888,
    "strip_function_name": "sub_AC560",
    "strip_decompiled_code": "__int64 __fastcall sub_AC560(__int64 a1, _BYTE *a2, __int64 a3)\n{\n  int v4; // edx\n  void *v5; // rax\n  __int64 v6; // rbp\n  __int64 v7; // rcx\n  int v8; // edx\n  __int64 v9; // rax\n  __int64 result; // rax\n  int v11; // edx\n\n  v4 = *(_DWORD *)(a1 + 72);\n  if ( v4 )\n  {\n    v6 = *(int *)(a1 + 76);\n    v5 = *(void **)(a1 + 104);\n    if ( v4 > (int)v6 + 1 )\n      goto LABEL_4;\n    v11 = 2 * v4;\n    *(_DWORD *)(a1 + 72) = v11;\n    v5 = xmlRealloc(v5, 16LL * v11);\n    if ( v5 )\n    {\n      *(_QWORD *)(a1 + 104) = v5;\n      goto LABEL_3;\n    }\n    sub_ABCB0(0LL, (__int64)\"pushing input string\");\n    result = (unsigned int)(*(_DWORD *)(a1 + 72) / 2);\n    *(_DWORD *)(a1 + 72) = result;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 72) = 4;\n    v5 = xmlMalloc(0x40uLL);\n    *(_QWORD *)(a1 + 104) = v5;\n    if ( v5 )\n    {\nLABEL_3:\n      v6 = *(int *)(a1 + 76);\nLABEL_4:\n      *((_QWORD *)v5 + 2 * v6) = xmlStrdup(a2);\n      v7 = *(_QWORD *)(a1 + 104);\n      v8 = *(_DWORD *)(a1 + 76);\n      v9 = 16LL * v8;\n      *(_QWORD *)(v7 + v9 + 8) = a3;\n      result = v7 + v9 + 16;\n      *(_DWORD *)(a1 + 76) = v8 + 1;\n      *(_QWORD *)result = 0LL;\n      *(_QWORD *)(result + 8) = 0LL;\n      return result;\n    }\n    result = sub_ABCB0(0LL, (__int64)\"pushing input string\");\n    *(_DWORD *)(a1 + 72) = 0;\n  }\n  return result;\n}\n",
    "function_name": "xmlFARegExecSaveInputString",
    "decompiled_code": "void __fastcall xmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value, void *data)\n{\n  int inputStackMax; // edx\n  xmlRegInputTokenPtr inputStack; // rax\n  __int64 inputStackNr; // rbp\n  xmlRegInputTokenPtr v7; // rcx\n  int v8; // edx\n  __int64 v9; // rax\n  xmlRegInputToken *v10; // rax\n  int v11; // edx\n\n  inputStackMax = exec->inputStackMax;\n  if ( inputStackMax )\n  {\n    inputStackNr = exec->inputStackNr;\n    inputStack = exec->inputStack;\n    if ( inputStackMax > (int)inputStackNr + 1 )\n      goto LABEL_4;\n    v11 = 2 * inputStackMax;\n    exec->inputStackMax = v11;\n    inputStack = (xmlRegInputTokenPtr)xmlRealloc(inputStack, 16LL * v11);\n    if ( inputStack )\n    {\n      exec->inputStack = inputStack;\n      goto LABEL_3;\n    }\n    xmlRegexpErrMemory(0LL, \"pushing input string\");\n    exec->inputStackMax /= 2;\n  }\n  else\n  {\n    exec->inputStackMax = 4;\n    inputStack = (xmlRegInputTokenPtr)xmlMalloc(0x40uLL);\n    exec->inputStack = inputStack;\n    if ( inputStack )\n    {\nLABEL_3:\n      inputStackNr = exec->inputStackNr;\nLABEL_4:\n      inputStack[inputStackNr].value = xmlStrdup__internal_alias(value);\n      v7 = exec->inputStack;\n      v8 = exec->inputStackNr;\n      v9 = v8;\n      v7[v9].data = data;\n      v10 = &v7[v9 + 1];\n      exec->inputStackNr = v8 + 1;\n      v10->value = 0LL;\n      v10->data = 0LL;\n      return;\n    }\n    xmlRegexpErrMemory(0LL, \"pushing input string\");\n    exec->inputStackMax = 0;\n  }\n}\n",
    "source_code": "\nstatic void\nxmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value,\n\t                    void *data) {\n#ifdef DEBUG_PUSH\n    printf(\"saving value: %d:%s\\n\", exec->inputStackNr, value);\n#endif\n    if (exec->inputStackMax == 0) {\n\texec->inputStackMax = 4;\n\texec->inputStack = (xmlRegInputTokenPtr)\n\t    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (exec->inputStack == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax = 0;\n\t    return;\n\t}\n    } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {\n\txmlRegInputTokenPtr tmp;\n\n\texec->inputStackMax *= 2;\n\ttmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,\n\t\t\texec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (tmp == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax /= 2;\n\t    return;\n\t}\n\texec->inputStack = tmp;\n    }\n    exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);\n    exec->inputStack[exec->inputStackNr].data = data;\n    exec->inputStackNr++;\n    exec->inputStack[exec->inputStackNr].value = NULL;\n    exec->inputStack[exec->inputStackNr].data = NULL;\n}",
    "comment": "Stores an input string and associated data in a dynamically expanding stack within the xmlRegExecCtxt structure.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Pushes a new step onto the parser context 's stack , reallocating memory if necessary , and initializes it with the provided name and namespace .\n",
    "cpbcs_sum": "Pushes a new xmlNode pointer onto the stack while managing memory allocation and incrementing the size of the regex atom list.\n",
    "misum_sum": "Pushes a new node onto the context's state, reallocating memory if necessary, and updates the current token accordingly.\n",
    "decom_sum": "Adds a duplicated XML string and associated metadata to a dynamically resized array in the provided parser context.",
    "cfg_sum": "Pushes a duplicated XML string and associated data into a dynamically resized array, allocating or expanding memory as needed and handling allocation failures.",
    "work_score": {
        "decom": {
            "summary": "Adds a duplicated XML string and associated metadata to a dynamically resized array in the provided parser context.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly describes that the function duplicates an XML string and stores it along with associated metadata in a dynamically resized array within the parser context. This matches the code\u2019s behavior: it duplicates the string using xmlStrdup, stores both value and data in the inputStack, and resizes the stack as needed. The claim is accurate, specific, and targets the code semantics with no contradictions.",
                "The summary correctly captures the core purpose: duplicating an XML string along with associated metadata and storing it in a dynamically resized array within the parser context. This aligns with the function\u2019s main behavior in managing the input stack, including memory allocation and resizing. However, it omits secondary details such as initial allocation size, conditional resizing logic, error handling when memory allocation fails, and debug output. The coverage of core purpose is strong but lacks breadth on these additional semantics.",
                "The summary accurately captures the core functionality: it duplicates the provided XML string, stores it with associated metadata, and handles dynamic resizing of the array within the parser context. There is no contradictory information, and noise is minimal. The claim is specific to the code\u2019s semantics, though somewhat concise without deeper implementation details like error handling specifics."
            ]
        },
        "cfg": {
            "summary": "Pushes a duplicated XML string and associated data into a dynamically resized array, allocating or expanding memory as needed and handling allocation failures.",
            "score": [
                1.0,
                0.8,
                0.9
            ],
            "reason": [
                "The summary contains several fact-based claims that align with the source code: it correctly states that the function pushes a duplicated XML string and associated data, uses dynamic resizing of an array, allocates or expands memory when required, and handles allocation failures. Each of these claims matches the function's actual operations, and no inaccuracies are present, resulting in high precision.",
                "The summary correctly identifies the core function \u2014 duplicating an XML string along with associated data and pushing it into a dynamically resized array while handling memory allocation and expansion failures \u2014 which matches the primary purpose of storing input tokens in exec's stack. It covers key secondary behaviors like allocation/expansion logic and error handling, though it omits minor details such as initial capacity setup, specific NULL assignments to the next slot, and the DEBUG_PUSH print. Overall, it captures the main domain-specific action and most critical semantics.",
                "The summary accurately captures the core functionality: duplicating the input XML string, storing it with associated data, dynamically allocating or expanding the array, and handling allocation failures. All claims align with the source code, with no inaccuracies or extraneous noise. While the summary is concise, it provides a clear, specific GOLD-level description of the function\u2019s primary purpose and key side effects, giving high net benefit."
            ]
        },
        "comment": {
            "summary": "Stores an input string and associated data in a dynamically expanding stack within the xmlRegExecCtxt structure.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function stores an input string and associated data in a dynamically expanding stack within the xmlRegExecCtxt structure, which matches the code\u2019s behavior of storing `value` and `data` in `exec->inputStack` and expanding `inputStackMax` via allocation/reallocation. This is a highly specific and accurate reflection of the code\u2019s semantics, with no incorrect or irrelevant claims present.",
                "The summary accurately captures the core purpose: storing an input string and associated data into a dynamically expanding stack in the xmlRegExecCtxt structure. This matches the function\u2019s main behavior of saving the value/data pair and resizing the stack as needed. However, it omits secondary details such as initialization when the stack is empty, handling memory allocation failures with xmlRegexpErrMemory, specific doubling logic for resizing, and setting terminal NULL entries after insertion. Coverage of the core is strong but missing several important operational details.",
                "The summary correctly captures the core behavior of the function: storing an input string and associated data in a stack that can expand dynamically within the xmlRegExecCtxt structure. This aligns with the source code's logic, which allocates or reallocates memory for the stack and adds the given value/data. There are no inaccurate or noisy claims, though the description is somewhat generic and lacks detail on memory handling or error cases, limiting its informational gain."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 256800,
    "strip_function_name": "sub_3EB20",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_3EB20(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  unsigned __int64 result; // rax\n  int v6; // edx\n  _DWORD *v7; // rcx\n  _DWORD *v8; // rdx\n  __int64 v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rsi\n  __int64 v12; // rcx\n  int v13; // edx\n\n  v4 = sub_3EAC0(*(_QWORD *)a3);\n  result = sub_265E0(*(unsigned __int8 **)(a3 + 8));\n  v6 = *(_DWORD *)v4;\n  if ( *(_DWORD *)v4 )\n  {\n    if ( (int)result > 0 )\n    {\n      v7 = *(_DWORD **)(v4 + 24);\n      v8 = v7 + 1;\n      v9 = (__int64)&v7[(unsigned int)(result - 1) + 1];\n      while ( 1 )\n      {\n        ++*v7;\n        v7 = v8;\n        if ( v8 == (_DWORD *)v9 )\n          break;\n        ++v8;\n      }\n    }\n    if ( (int)result < *(_DWORD *)(v4 + 8) )\n    {\n      v10 = *(_QWORD *)(v4 + 32);\n      v11 = *(_QWORD *)(v4 + 24);\n      result = (int)result;\n      do\n      {\n        ++*(_DWORD *)(v10 + 4 * result);\n        *(_DWORD *)(v11 + 4 * result++) = 1;\n      }\n      while ( *(_DWORD *)(v4 + 8) > (int)result );\n    }\n  }\n  else\n  {\n    result = *(unsigned int *)(v4 + 8);\n    if ( (int)result <= 0 )\n      goto LABEL_10;\n    v12 = *(_QWORD *)(v4 + 24);\n    result = 1LL;\n    do\n    {\n      *(_DWORD *)(v12 + 4 * result - 4) = 1;\n      v13 = result++;\n    }\n    while ( *(_DWORD *)(v4 + 8) > v13 );\n  }\n  v6 = *(_DWORD *)v4;\nLABEL_10:\n  *(_DWORD *)v4 = v6 + 1;\n  return result;\n}\n",
    "function_name": "statPush",
    "decompiled_code": "void __fastcall statPush(sqlite3_context *context, int argc, sqlite3_value **argv)\n{\n  _QWORD *v4; // rbx\n  __int64 v5; // rax\n  int v6; // edx\n  _DWORD *v7; // rcx\n  _DWORD *v8; // rdx\n  __int64 v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rsi\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  int v14; // edx\n\n  v4 = sqlite3_value_blob(*argv);\n  LODWORD(v5) = sqlite3VdbeIntValue(argv[1]);\n  v6 = *(_DWORD *)v4;\n  if ( *(_DWORD *)v4 )\n  {\n    if ( (int)v5 > 0 )\n    {\n      v7 = (_DWORD *)v4[3];\n      v8 = v7 + 1;\n      v9 = (__int64)&v7[(unsigned int)(v5 - 1) + 1];\n      while ( 1 )\n      {\n        ++*v7;\n        v7 = v8;\n        if ( v8 == (_DWORD *)v9 )\n          break;\n        ++v8;\n      }\n    }\n    if ( (int)v5 < *((_DWORD *)v4 + 2) )\n    {\n      v10 = v4[4];\n      v11 = v4[3];\n      v5 = (int)v5;\n      do\n      {\n        ++*(_DWORD *)(v10 + 4 * v5);\n        *(_DWORD *)(v11 + 4 * v5++) = 1;\n      }\n      while ( *((_DWORD *)v4 + 2) > (int)v5 );\n    }\n  }\n  else\n  {\n    if ( *((int *)v4 + 2) <= 0 )\n      goto LABEL_10;\n    v12 = v4[3];\n    v13 = 1LL;\n    do\n    {\n      *(_DWORD *)(v12 + 4 * v13 - 4) = 1;\n      v14 = v13++;\n    }\n    while ( *((_DWORD *)v4 + 2) > v14 );\n  }\n  v6 = *(_DWORD *)v4;\nLABEL_10:\n  *(_DWORD *)v4 = v6 + 1;\n}\n",
    "source_code": "static void statPush(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i;\n\n  /* The three function arguments */\n  Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);\n  int iChng = sqlite3_value_int(argv[1]);\n\n  UNUSED_PARAMETER( argc );\n  UNUSED_PARAMETER( context );\n  assert( p->nCol>0 );\n  assert( iChng<p->nCol );\n\n  if( p->nRow==0 ){\n    /* This is the first call to this function. Do initialization. */\n    for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;\n  }else{\n    /* Second and subsequent calls get processed here */\n    samplePushPrevious(p, iChng);\n\n    /* Update anDLt[], anLt[] and anEq[] to reflect the values that apply\n    ** to the current row of the index. */\n    for(i=0; i<iChng; i++){\n      p->current.anEq[i]++;\n    }\n    for(i=iChng; i<p->nCol; i++){\n      p->current.anDLt[i]++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n      p->current.anLt[i] += p->current.anEq[i];\n#endif\n      p->current.anEq[i] = 1;\n    }\n  }\n  p->nRow++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n  if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){\n    sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));\n  }else{\n    sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),\n                                       sqlite3_value_blob(argv[2]));\n  }\n  p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;\n#endif\n\n#ifdef SQLITE_ENABLE_STAT4\n  {\n    tRowcnt nLt = p->current.anLt[p->nCol-1];\n\n    /* Check if this is to be a periodic sample. If so, add it. */\n    if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){\n      p->current.isPSample = 1;\n      p->current.iCol = 0;\n      sampleInsert(p, &p->current, p->nCol-1);\n      p->current.isPSample = 0;\n    }\n\n    /* Update the aBest[] array. */\n    for(i=0; i<(p->nCol-1); i++){\n      p->current.iCol = i;\n      if( i>=iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i]) ){\n        sampleCopy(p, &p->aBest[i], &p->current);\n      }\n    }\n  }\n#endif\n}",
    "comment": "Processes statistical data by updating counts and tracking samples based on input changes and row identifiers within a given dataset structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Converts an SQLite value to a JSON formatted string and returns it with a JSON subtype in the context .\n",
    "cpbcs_sum": "Converts an input string to a structured structure by assigning individual bits and handling back references as needed.\n",
    "misum_sum": "Inserts a new Lua stack into the Lua stack at the specified index and increments the stack count.\n",
    "decom_sum": "Updates array-based counters and flags for given index range, then increments the structure\u2019s main counter tracking processed entries.",
    "cfg_sum": "Updates indexed counters and status arrays based on input position with boundary checks, then increments a primary state value and returns the final index.",
    "work_score": {
        "decom": {
            "summary": "Updates array-based counters and flags for given index range, then increments the structure\u2019s main counter tracking processed entries.",
            "score": [
                0.6,
                0.3,
                0.5
            ],
            "reason": [
                "The summary contains one main claim: that the function updates array-based counters and flags for a given index range and increments a main counter tracking processed entries. This aligns with the source code\u2019s loops updating anEq, anDLt, anLt arrays and the increment of p->nRow, but it omits significant specific behaviors such as the conditional initialization on the first call, periodic sample insertion under STAT4, and rowid handling under STAT3/STAT4. The claim is accurate but overly generic, capturing part of the semantics without those details, resulting in mixed coverage.",
                "The summary correctly notes that the function updates array-based counters and a main counter, which matches the code\u2019s behavior of modifying anEq, anDLt, anLt arrays and incrementing nRow. However, it fails to capture the core purpose of processing statistical accumulation for index samples, including first-call initialization, conditional periodic sampling, and updating best sample arrays. It omits key domain-specific semantics tied to SQLite\u2019s STAT3/STAT4 statistics gathering, meaning the core primary purpose is not covered.",
                "The summary captures the general idea that the function updates counters for a given range and increments a main processed entry counter, which aligns with the loop logic and p->nRow increment in the source. However, it is very high-level and omits important specifics such as initialization on first call, conditional updates via samplePushPrevious, anLt/anEq/anDLt array roles, conditional rowid handling, and periodic sampling logic. The omission of these domain-specific behaviors limits the gain, but there is no contradictory or irrelevant noise present."
            ]
        },
        "cfg": {
            "summary": "Updates indexed counters and status arrays based on input position with boundary checks, then increments a primary state value and returns the final index.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly claims that the function returns a final index, whereas the source code is a void function that does not return any value. While it correctly mentions updating counters and arrays based on input position with boundary checks and incrementing a primary state variable (nRow), these accurate points are outweighed by the major inaccuracy about returning a value, making less than half of the claims accurate.",
                "The summary omits the core purpose of processing statistical samples for SQLite's analyzer, including initialization on first call, invoking samplePushPrevious, and handling periodic sampling with sampleInsert and aBest updates. While it mentions updating counters and boundary checks, it inaccurately states that the function returns a final index, which it does not. This means the core domain effect is missing and one claim contradicts the code, leaving coverage of critical behaviors and branches incomplete.",
                "The summary contains a critical inaccuracy: it claims the function returns the final index, but the source code has a void return type and performs no return operation. This is a FATAL error regarding the primary purpose and key output. While it mentions updating counters and arrays, which aligns with the code, the severe misstatement about returning data makes the description unreliable."
            ]
        },
        "comment": {
            "summary": "Processes statistical data by updating counts and tracking samples based on input changes and row identifiers within a given dataset structure.",
            "score": [
                0.4,
                0.5,
                0.5
            ],
            "reason": [
                "The summary captures a generic idea of updating counts and tracking samples but lacks specific details about the function's operations, such as initialization logic on the first call, differentiated handling of columns before and after `iChng`, conditional compilation behaviors, and periodic sample insertion. While it is generally accurate at a high level and refers to statistical data processing, it omits several key verifiable behaviors evident in the code, resulting in a low proportion of precise claims.",
                "The summary correctly notes that the function updates counts and tracks samples based on input changes and identifiers, which matches core behaviors like incrementing anEq/anDLt arrays and handling row IDs. However, it captures the primary purpose only in generic terms and lacks specifics such as initialization on first call, periodic sample insertion, conditional updates based on SQLite compile-time flags, and updating best sample arrays. These omissions limit coverage of critical secondary semantics.",
                "The summary provides a generic and broadly correct idea that the function updates counts and tracks samples based on changes and row identifiers, which aligns with the source code\u2019s core purpose. However, it lacks specificity about key operations such as initialization on the first call, the role of iChng in count updates, conditional sampling logic, and manipulation of specific arrays (anEq, anDLt, anLt). No inaccurate or contradictory claims are present, but the gain is low due to the absence of detailed domain semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582062956,
    "strip_function_name": "sub_FFFFFFFF8131196C",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8131196C(__int64 a1, __int16 a2, _BYTE *a3, unsigned __int8 a4)\n{\n  _BYTE *v5; // r15\n  unsigned int v6; // ebx\n  unsigned int i; // r12d\n  unsigned int v8; // r12d\n  char v9; // r15\n  int v10; // r8d\n  __int64 v11; // rdx\n  __int64 v12; // rsi\n  int v14; // [rsp+4h] [rbp-3Ch]\n  int v15; // [rsp+Ch] [rbp-34h] BYREF\n  _QWORD v16[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  if ( a2 == 10 )\n  {\n    v8 = 3;\n    if ( a4 != 1 )\n    {\n      v8 = 10;\n      if ( a4 != 4 )\n        v8 = 20;\n    }\n    v15 = 0;\n    v9 = 1;\n    v6 = 0;\n    do\n    {\n      v16[0] = a1;\n      v10 = 0;\n      do\n      {\n        v14 = v10;\n        sub_FFFFFFFF8132329F(v16[0], 10LL, v16, &v15);\n        v10 = v14 + 1;\n      }\n      while ( v14 + 1 < v8 );\n      if ( !v15 && v9 )\n      {\n        v9 = 1;\n      }\n      else\n      {\n        v11 = v6++;\n        a3[v11] = v15 + 48;\n        v9 = 0;\n      }\n      --v8;\n    }\n    while ( v8 );\n  }\n  else\n  {\n    if ( a2 != 16 )\n      return 0LL;\n    v5 = a3;\n    v6 = 2 * a4;\n    for ( i = v6 - 1; i != -1; --i )\n    {\n      v12 = 4 * i;\n      *v5++ = sub_FFFFFFFF813222E0(a1, v12);\n    }\n  }\n  if ( !v6 )\n  {\n    *a3 = 48;\n    v6 = 1;\n  }\n  a3[v6] = 0;\n  return v6;\n}\n",
    "function_name": "acpi_ex_convert_to_ascii",
    "decompiled_code": "__int64 __fastcall acpi_ex_convert_to_ascii(\n        unsigned __int64 a1,\n        __int16 a2,\n        char *a3,\n        unsigned __int8 a4,\n        __int64 a5,\n        int a6)\n{\n  char *v7; // r15\n  unsigned int v8; // ebx\n  unsigned int i; // r12d\n  unsigned int v10; // r12d\n  char v11; // r15\n  int v12; // r8d\n  __int64 v13; // rdx\n  char v14; // si\n  int v16; // [rsp+4h] [rbp-3Ch]\n  int v17; // [rsp+Ch] [rbp-34h] BYREF\n  unsigned __int64 v18[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  if ( a2 == 10 )\n  {\n    v10 = 3;\n    if ( a4 != 1 )\n    {\n      v10 = 10;\n      if ( a4 != 4 )\n        v10 = 20;\n    }\n    v17 = 0;\n    v11 = 1;\n    v8 = 0;\n    do\n    {\n      v18[0] = a1;\n      v12 = 0;\n      do\n      {\n        v16 = v12;\n        acpi_ut_short_divide(v18[0], 0xAu, v18, &v17, v12, a6);\n        v12 = v16 + 1;\n      }\n      while ( v16 + 1 < v10 );\n      if ( !v17 && v11 )\n      {\n        v11 = 1;\n      }\n      else\n      {\n        v13 = v8++;\n        a3[v13] = v17 + 48;\n        v11 = 0;\n      }\n      --v10;\n    }\n    while ( v10 );\n  }\n  else\n  {\n    if ( a2 != 16 )\n      return 0LL;\n    v7 = a3;\n    v8 = 2 * a4;\n    for ( i = v8 - 1; i != -1; --i )\n    {\n      v14 = 4 * i;\n      *v7++ = acpi_ut_hex_to_ascii_char(a1, v14);\n    }\n  }\n  if ( !v8 )\n  {\n    *a3 = 48;\n    v8 = 1;\n  }\n  a3[v8] = 0;\n  return v8;\n}\n",
    "source_code": "\nstatic u32\nacpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 data_width)\n{\n\tu64 digit;\n\tu32 i;\n\tu32 j;\n\tu32 k = 0;\n\tu32 hex_length;\n\tu32 decimal_length;\n\tu32 remainder;\n\tu8 supress_zeros;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tswitch (base) {\n\tcase 10:\n\n\t\t/* Setup max length for the decimal number */\n\n\t\tswitch (data_width) {\n\t\tcase 1:\n\t\t\tdecimal_length = ACPI_MAX8_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdecimal_length = ACPI_MAX32_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\tdefault:\n\t\t\tdecimal_length = ACPI_MAX64_DECIMAL_DIGITS;\n\t\t\tbreak;\n\t\t}\n\n\t\tsupress_zeros = TRUE;\t/* No leading zeros */\n\t\tremainder = 0;\n\n\t\tfor (i = decimal_length; i > 0; i--) {\n\n\t\t\t/* Divide by nth factor of 10 */\n\n\t\t\tdigit = integer;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t(void)acpi_ut_short_divide(digit, 10, &digit,\n\t\t\t\t\t\t\t   &remainder);\n\t\t\t}\n\n\t\t\t/* Handle leading zeros */\n\n\t\t\tif (remainder != 0) {\n\t\t\t\tsupress_zeros = FALSE;\n\t\t\t}\n\n\t\t\tif (!supress_zeros) {\n\t\t\t\tstring[k] = (u8) (ACPI_ASCII_ZERO + remainder);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 16:\n\n\t\t/* hex_length: 2 ascii hex chars per data byte */\n\n\t\thex_length = ACPI_MUL_2(data_width);\n\t\tfor (i = 0, j = (hex_length - 1); i < hex_length; i++, j--) {\n\n\t\t\t/* Get one hex digit, most significant digits first */\n\n\t\t\tstring[k] =\n\t\t\t    (u8) acpi_ut_hex_to_ascii_char(integer,\n\t\t\t\t\t\t\t   ACPI_MUL_4(j));\n\t\t\tk++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Since leading zeros are suppressed, we must check for the case where\n\t * the integer equals 0\n\t *\n\t * Finally, null terminate the string and return the length\n\t */\n\tif (!k) {\n\t\tstring[0] = ACPI_ASCII_ZERO;\n\t\tk = 1;\n\t}\n\n\tstring[k] = 0;\n\treturn ((u32) k);\n}",
    "comment": "Converts a given integer to its ASCII representation in either decimal or hexadecimal format based on specified parameters and returns the string length.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Converts an ACPI operand object to a buffer , handling integer and string types , while ensuring proper memory management and error checking .\n",
    "cpbcs_sum": "Converts single indirect data to a string representation of an embedded address, handling special cases for uninitialized and other environments.\n",
    "misum_sum": "Converts an AML buffer to an AML byte stream, extracting parameters like POSIX and node ID, and allocating memory for the data.\n",
    "decom_sum": "Formats numeric data from the source address into either decimal or hexadecimal ASCII string representation based on the specified type and length.",
    "cfg_sum": "Converts data from the input source into zero-padded ASCII representation based on mode and parameter, returning the resulting string length.",
    "work_score": {
        "decom": {
            "summary": "Formats numeric data from the source address into either decimal or hexadecimal ASCII string representation based on the specified type and length.",
            "score": [
                0.6,
                0.5,
                0.6
            ],
            "reason": [
                "The summary states that the function formats numeric data into decimal or hexadecimal ASCII based on type and length, which aligns with the code's logic using `base` to select decimal or hex output and `data_width` to determine length. However, the term 'source address' in the summary is inaccurate since the function actually formats an integer value passed as a parameter, not a memory address. This introduces a semantic error, resulting in mixed claim accuracy.",
                "The summary correctly identifies that the function formats numeric data into decimal or hexadecimal ASCII string representation depending on the specified base and data width, aligning with the core purpose of converting an integer to ASCII with base-specific formatting. However, it omits important secondary details from the code, such as suppression of leading zeros for decimal output, calculation loop structure, handling of the zero case, null termination, and return of string length. The mention of 'source address' is inaccurate since the function works on a given integer value, not a memory address.",
                "The summary correctly captures the core behavior of converting an integer into either decimal or hexadecimal ASCII format based on provided parameters, aligning with the switch-case handling of base values and data width in the source code. However, there is minor inaccuracy in stating 'source address'\u2014the function processes an integer value, not an address. This is a small NOISE issue, but there are no severe FATAL errors affecting primary purpose. The gain is moderate since the description is accurate but somewhat generic, lacking specific details like suppression of leading zeros or handling of zero values."
            ]
        },
        "cfg": {
            "summary": "Converts data from the input source into zero-padded ASCII representation based on mode and parameter, returning the resulting string length.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as producing a zero-padded ASCII representation, while the source code explicitly suppresses leading zeros for decimal output and only produces full-width hex output without padding logic. It also omits important specifics such as handling only base 10 and base 16, the data_width-dependent length computation, and returning 0 for unsupported bases. The only accurate part is that it returns the string length after conversion, leading to a low proportion of correct claims.",
                "The summary incorrectly states that the output is zero-padded, while the code explicitly suppresses leading zeros except when the integer is zero. It also fails to cover the core purpose of converting a numeric integer to an ASCII string in either decimal or hexadecimal format based on the specified base and data width. No accurate claim captures the distinction between decimal and hex handling, suppression of zeros, or null termination, resulting in the core domain behavior being missed.",
                "The summary incorrectly states that the function produces a zero-padded ASCII representation, while the source code shows it suppresses leading zeros except when the value is zero. This is a FATAL inaccuracy affecting the primary purpose. The rest of the summary is vague and lacks specifics about handling decimal and hexadecimal conversion or data_width logic, offering little net gain."
            ]
        },
        "comment": {
            "summary": "Converts a given integer to its ASCII representation in either decimal or hexadecimal format based on specified parameters and returns the string length.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function converts an integer to its ASCII representation in decimal or hexadecimal depending on parameters and returns the string length, which matches the source code\u2019s behavior. Although it omits details such as suppression of leading zeros and handling of zero values, all stated claims are accurate and align with the code\u2019s semantics, resulting in a high proportion of accurate claims.",
                "The summary accurately captures the core purpose of converting an integer into its ASCII representation in decimal or hexadecimal and returning the length, which matches the function's main operation. However, it omits important secondary details such as handling leading zeros suppression, null-terminating the string, differentiating decimal digit length based on data width, and base-specific processing steps. These missing elements reduce coverage of critical behavior in the source code.",
                "The summary is accurate about the core purpose: converting an integer to ASCII in decimal or hexadecimal and returning the length. There are no contradictory (FATAL) claims and minimal noise. However, the gain is low because the summary is generic and omits key specifics such as handling of leading zeros, data width constraints, and null termination logic, which are important to understanding the code\u2019s behavior."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 332016,
    "strip_function_name": "sub_510F0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_510F0(__int64 *a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdi\n  unsigned __int8 *v6; // r14\n  unsigned __int8 *v7; // rbp\n  __int64 v8; // r12\n  int v9; // r13d\n  unsigned int v10; // eax\n  unsigned __int8 *v11; // r15\n  __int64 *v13; // rax\n  __int64 v14; // r9\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  int v18; // [rsp+24h] [rbp-44h] BYREF\n  unsigned __int64 v19; // [rsp+28h] [rbp-40h]\n\n  v5 = *a3;\n  v19 = __readfsqword(0x28u);\n  v6 = (unsigned __int8 *)sub_3EA40(v5, 1);\n  v15 = sub_3EA40(a3[1], 1);\n  if ( v6 )\n  {\n    v7 = v6;\n    v8 = 0LL;\n    v9 = 3;\n    v17 = *(_QWORD *)(*a1 + 40);\n    if ( *v6 )\n    {\n      do\n      {\n        v10 = v8;\n        v11 = v7;\n        do\n        {\n          v11 += (int)v10;\n          v10 = sub_2AB80(v11, &v18);\n        }\n        while ( v18 == 162 );\n        if ( v18 == 122 || v18 == 107 )\n        {\n          v9 = 0;\n        }\n        else if ( ++v9 == 2 && (v18 == 74 || v18 == 137 || v18 == 5) )\n        {\n          v13 = sub_505E0(v17, \"%.*s\\\"%w\\\"%s\", v7 - v6, v6, v15, &v7[v8]);\n          sub_39D70(a1, v13, 0xFFFFFFFFLL, 1u, sub_17950, v14);\n          return __readfsqword(0x28u) ^ v19;\n        }\n        v7 = v11;\n        v8 = v10;\n      }\n      while ( *v11 );\n    }\n  }\n  return __readfsqword(0x28u) ^ v19;\n}\n",
    "function_name": "renameTriggerFunc",
    "decompiled_code": "void __fastcall renameTriggerFunc(sqlite3_context *context, int NotUsed, sqlite3_value **argv)\n{\n  sqlite3_value *v5; // rdi\n  const unsigned __int8 *v6; // r14\n  const unsigned __int8 *v7; // rbp\n  __int64 v8; // r12\n  int v9; // r13d\n  int v10; // eax\n  const unsigned __int8 *v11; // r15\n  char *v12; // rax\n  const void *v13; // [rsp+8h] [rbp-60h]\n  sqlite3 *db; // [rsp+18h] [rbp-50h]\n  int token; // [rsp+24h] [rbp-44h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v5 = *argv;\n  v17 = __readfsqword(0x28u);\n  v6 = (const unsigned __int8 *)sqlite3ValueText(v5, 1u);\n  v13 = sqlite3ValueText(argv[1], 1u);\n  if ( v6 )\n  {\n    v7 = v6;\n    v8 = 0LL;\n    v9 = 3;\n    db = context->pOut->db;\n    if ( *v6 )\n    {\n      do\n      {\n        v10 = v8;\n        v11 = v7;\n        do\n        {\n          v11 += v10;\n          v10 = sqlite3GetToken(v11, &token);\n        }\n        while ( token == 162 );\n        if ( token == 122 || token == 107 )\n        {\n          v9 = 0;\n        }\n        else if ( ++v9 == 2 && (token == 74 || token == 137 || token == 5) )\n        {\n          v12 = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", v7 - v6, v6, v13, &v7[v8]);\n          setResultStrOrError(context, v12, -1, 1u, (void (*)(void *))sqlite3MallocSize);\n          return;\n        }\n        v7 = v11;\n        v8 = (unsigned int)v10;\n      }\n      while ( *v11 );\n    }\n  }\n}\n",
    "source_code": "static void renameTriggerFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  int dist = 3;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TRIGGER \n  ** statement is that the table name is the first token that is immediately\n  ** preceded by either TK_ON or TK_DOT and immediately followed by one\n  ** of TK_WHEN, TK_BEGIN or TK_FOR.\n  */\n  if( zSql ){\n    do {\n\n      if( !*zCsr ){\n        /* Ran out of input before finding the table name. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      }while( token==TK_SPACE );\n      assert( len>0 );\n\n      /* Variable 'dist' stores the number of tokens read since the most\n      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN \n      ** token is read and 'dist' equals 2, the condition stated above\n      ** to be met.\n      **\n      ** Note that ON cannot be a database, table or column name, so\n      ** there is no need to worry about syntax like \n      ** \"CREATE TRIGGER ... ON ON.ON BEGIN ...\" etc.\n      */\n      dist++;\n      if( token==TK_DOT || token==TK_ON ){\n        dist = 0;\n      }\n    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );\n\n    /* Variable tname now contains the token that is the old table-name\n    ** in the CREATE TRIGGER statement.\n    */\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", (int)(((u8*)tname.z) - zSql),\n       zSql, zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}",
    "comment": "Replaces the old table name in a CREATE TRIGGER SQL statement with a new table name provided as an argument.",
    "hext5_sum": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
    "bint5_sum": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name , returning it as a string .\n",
    "cpbcs_sum": "Encodes a SQL CREATE TABLE into Base64 format and appends the result to a specified database file.\n",
    "misum_sum": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name, returning the result as a string.\n",
    "decom_sum": "Parses a byte stream for specific codes and formats a string incorporating quoted data before dispatching it through a callback handler.",
    "cfg_sum": "Parses a byte stream to detect specific control codes and, on match, formats and dispatches a structured message for further processing.",
    "work_score": {
        "decom": {
            "summary": "Parses a byte stream for specific codes and formats a string incorporating quoted data before dispatching it through a callback handler.",
            "score": [
                0.3,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about parsing a byte stream for specific codes and formatting a string with quoted data before dispatching via a callback are overly generic and partially inaccurate. While the function does parse tokens from SQL text and formats a result string, the summary omits critical, specific behavior like locating a table name based on token patterns in a CREATE TRIGGER statement. The 'byte stream' and 'specific codes' phrasing is too vague and not clearly aligned with the actual token processing logic, and the notion of a 'callback handler' misrepresents the use of sqlite3_result_text, which returns data to SQLite rather than invoking an external callback.",
                "The summary incorrectly describes the function as parsing a byte stream for specific codes and dispatching through a callback, which does not match the core purpose of the code. The actual code scans a CREATE TRIGGER SQL statement to locate the old table name based on token sequencing rules, then constructs a new SQL string with a quoted replacement table name and returns it via sqlite3_result_text. The central domain action and key token-processing logic are entirely missing, and no accurate claims align with the code\u2019s semantics.",
                "The summary is inaccurate regarding the core function purpose. The source code is not parsing a generic byte stream for unspecified codes; it specifically tokenizes a SQL CREATE TRIGGER statement to locate and replace the table name, then formats a new SQL string and returns it via sqlite3_result_text. The summary\u2019s mention of a 'callback handler' is incorrect, and it omits the SQL-specific context, making this a severe FATAL error on the primary purpose. No accurate GOLD claims are present, and noise dominates."
            ]
        },
        "cfg": {
            "summary": "Parses a byte stream to detect specific control codes and, on match, formats and dispatches a structured message for further processing.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function parses a byte stream for control codes and dispatches a structured message, which does not match the source code. The actual function processes SQL text to locate a table name in a CREATE TRIGGER statement and constructs new SQL with a renamed table. None of the claims accurately describe the code's semantics, so the proportion of accurate claims is effectively zero.",
                "The summary incorrectly describes the function as parsing a byte stream for control codes and dispatching messages, which does not align with the source code. The actual core purpose is to locate and replace the table name in a CREATE TRIGGER SQL statement using token parsing rules. No accurate claims from the summary cover this core behavior, and all statements in the summary are unrelated to the code\u2019s semantics.",
                "The summary incorrectly describes the function's primary purpose. The source code does not parse a generic byte stream to detect control codes or dispatch messages; it specifically parses a SQL CREATE TRIGGER statement to locate the table name and then formats a new statement with a replacement table name. This is a severe [FATAL] error targeting the core behavior (WHAT), making the summary misleading and untrustworthy despite having no accurate claims."
            ]
        },
        "comment": {
            "summary": "Replaces the old table name in a CREATE TRIGGER SQL statement with a new table name provided as an argument.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function replaces the old table name in a CREATE TRIGGER SQL statement with a new table name provided as an argument, which matches the core, verifiable behavior in the source code. However, it omits details about how the old table name is located (using token analysis around TK_ON/TK_DOT and TK_WHEN/TK_FOR/TK_BEGIN) and does not mention conditional handling or the NULL return case. Despite lacking nuance, the single claim is accurate and targets code semantics.",
                "The summary correctly identifies the core purpose of replacing the old table name in a CREATE TRIGGER SQL statement with a new table name, which is the primary domain-specific action in the code. However, it omits key secondary details such as how the table name is located using specific token sequence rules (preceded by TK_ON/TK_DOT and followed by TK_WHEN/TK_BEGIN/TK_FOR), handling of NULL or empty input, use of sqlite3MPrintf for constructing the output, and returning the result via sqlite3_result_text. These omissions limit coverage of important behavior-critical semantics.",
                "The summary accurately states the primary purpose of the function: replacing the old table name in a CREATE TRIGGER statement with a new one supplied as an argument. This aligns fully with the code\u2019s core logic, which locates the target table name in the SQL by token parsing and then reconstructs the statement with the new name before returning it. The claim is specific to the function\u2019s domain behavior and has no contradictions or irrelevant noise, although it is concise and lacks detailed mechanics of the token search process, making the gain moderate rather than high."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581578592,
    "strip_function_name": "sub_FFFFFFFF8129B560",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8129B560(__int64 a1, __int64 a2, __int64 a3)\n{\n  int v4; // eax\n  unsigned __int64 v5; // rbx\n  unsigned __int64 v6; // rax\n  __int64 v7; // rsi\n  unsigned __int64 v8; // rbx\n  __int64 v10; // r13\n  __int64 v11; // r12\n  __int64 v12; // rsi\n  __int64 v13; // rsi\n  unsigned int v14; // edx\n  __int64 result; // rax\n  unsigned int v16; // [rsp+10h] [rbp-40h] BYREF\n  int v17; // [rsp+14h] [rbp-3Ch] BYREF\n  __int64 v18; // [rsp+18h] [rbp-38h] BYREF\n  __int64 v19[6]; // [rsp+20h] [rbp-30h] BYREF\n\n  v4 = *(unsigned __int8 *)(a1 + 1404);\n  v5 = *(unsigned __int16 *)(a2 + 42);\n  v16 = 0;\n  v18 = 0LL;\n  v19[0] = 0LL;\n  v17 = v4;\n  v6 = *(unsigned __int16 *)(a2 + 40);\n  v7 = *(_QWORD *)(a2 + 88) + 16 * v5;\n  if ( v5 >= v6 )\n    return 0LL;\n  v8 = v5 + 1;\n  v10 = a2;\n  v11 = 16 * v8;\n  sub_FFFFFFFF8129B260(a1, v7, a3, &v18, v19, &v16, &v17);\n  while ( 1 )\n  {\n    v12 = v11;\n    v11 += 16LL;\n    v13 = *(_QWORD *)(v10 + 88) + v12;\n    if ( *(unsigned __int16 *)(v10 + 40) <= v8 )\n      break;\n    ++v8;\n    sub_FFFFFFFF8129B260(a1, v13, a3, &v18, v19, &v16, &v17);\n  }\n  if ( v19[0] )\n    *(_QWORD *)v19[0] = *(_QWORD *)v19[0] & 0xFFFFFFFFFFFFFFFCLL | 2;\n  v14 = *(_DWORD *)(v10 + 44);\n  result = v16;\n  if ( v14 )\n  {\n    if ( v14 < v16 )\n      BUG();\n  }\n  return result;\n}\n",
    "function_name": "blk_bio_map_sg",
    "decompiled_code": "__int64 __fastcall blk_bio_map_sg(__int64 a1, __int64 a2, __int64 a3)\n{\n  int v4; // eax\n  unsigned __int64 v5; // rbx\n  unsigned __int64 v6; // rax\n  __int64 v7; // rsi\n  unsigned __int64 v8; // rbx\n  __int64 v10; // r13\n  __int64 v11; // r12\n  __int64 v12; // rsi\n  __int64 v13; // rsi\n  unsigned int v14; // edx\n  __int64 result; // rax\n  unsigned int v16; // [rsp+10h] [rbp-40h] BYREF\n  int v17; // [rsp+14h] [rbp-3Ch] BYREF\n  __int64 v18; // [rsp+18h] [rbp-38h] BYREF\n  unsigned __int64 v19[6]; // [rsp+20h] [rbp-30h] BYREF\n\n  v4 = *(unsigned __int8 *)(a1 + 1404);\n  v5 = *(unsigned __int16 *)(a2 + 42);\n  v16 = 0;\n  v18 = 0LL;\n  v19[0] = 0LL;\n  v17 = v4;\n  v6 = *(unsigned __int16 *)(a2 + 40);\n  v7 = *(_QWORD *)(a2 + 88) + 16 * v5;\n  if ( v5 >= v6 )\n    return 0LL;\n  v8 = v5 + 1;\n  v10 = a2;\n  v11 = 16 * v8;\n  _blk_segment_map_sg(a1, v7, a3, &v18, v19, &v16, &v17);\n  while ( 1 )\n  {\n    v12 = v11;\n    v11 += 16LL;\n    v13 = *(_QWORD *)(v10 + 88) + v12;\n    if ( *(unsigned __int16 *)(v10 + 40) <= v8 )\n      break;\n    ++v8;\n    _blk_segment_map_sg(a1, v13, a3, &v18, v19, &v16, &v17);\n  }\n  if ( v19[0] )\n    *(_QWORD *)v19[0] = *(_QWORD *)v19[0] & 0xFFFFFFFFFFFFFFFCLL | 2;\n  v14 = *(_DWORD *)(v10 + 44);\n  result = v16;\n  if ( v14 )\n  {\n    if ( v14 < v16 )\n      BUG();\n  }\n  return result;\n}\n",
    "source_code": "int blk_bio_map_sg(struct request_queue *q, struct bio *bio,\n\t\t   struct scatterlist *sglist)\n{\n\tstruct bio_vec *bvec, *bvprv;\n\tstruct scatterlist *sg;\n\tint nsegs, cluster;\n\tunsigned long i;\n\n\tnsegs = 0;\n\tcluster = blk_queue_cluster(q);\n\n\tbvprv = NULL;\n\tsg = NULL;\n\tbio_for_each_segment(bvec, bio, i) {\n\t\t__blk_segment_map_sg(q, bvec, sglist, &bvprv, &sg,\n\t\t\t\t     &nsegs, &cluster);\n\t} /* segments in bio */\n\n\tif (sg)\n\t\tsg_mark_end(sg);\n\n\tBUG_ON(bio->bi_phys_segments && nsegs > bio->bi_phys_segments);\n\treturn nsegs;\n}",
    "comment": "Maps segments of a block I/O bio to a scatter-gather list, updating the number of segments and handling physical segment constraints.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Merges a bio into a request if the total sector count does not exceed the maximum allowed , updating segments and handling merge flags accordingly .\n",
    "cpbcs_sum": "Calculates and returns the number of free pages in a memory block for a given bio in a request structure.\n",
    "misum_sum": "Maps a bio into a scatter-gather table based on merging operator types and updates the position accordingly.\n",
    "decom_sum": "Processes consecutive 16-byte entries from a table, updates status fields via a helper, and enforces an upper limit constraint with error checking.",
    "cfg_sum": "Processes a sequence of indexed entries from a data structure, updates related counters and flags, and triggers an error if limits are exceeded.",
    "work_score": {
        "decom": {
            "summary": "Processes consecutive 16-byte entries from a table, updates status fields via a helper, and enforces an upper limit constraint with error checking.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about processing consecutive 16-byte entries from a table and updating status fields via a helper are not supported by the source code, which deals with mapping bio segments to a scatterlist structure in a block I/O context. The mention of an upper limit constraint with error checking is loosely related to the BUG_ON check but lacks accuracy about the actual variables and logic. Overall, the majority of claims misrepresent the function's semantics, resulting in very low accuracy.",
                "The summary's claims about processing 16-byte table entries and updating status fields do not align with the source code, which maps bio segments to a scatterlist for block I/O, clusters segments, marks the end of the list, and checks against a physical segment count. The core purpose of scatterlist mapping is completely missing, and no accurate claims match the code\u2019s semantics or domain context. All listed details are inaccurate, so there is neither core coverage nor relevant secondary information.",
                "The summary makes several claims unrelated to the actual source code. It describes processing consecutive 16-byte entries from a table and updating status fields, which is not present in the function; the code instead iterates over bio segments and maps them into a scatterlist. The claim about enforcing an upper limit with error checking loosely aligns with the BUG_ON check, but this is outweighed by the completely inaccurate primary purpose description. This is a severe FATAL targeting the core behavior, making the summary unusable."
            ]
        },
        "cfg": {
            "summary": "Processes a sequence of indexed entries from a data structure, updates related counters and flags, and triggers an error if limits are exceeded.",
            "score": [
                0.6,
                0.3,
                0.5
            ],
            "reason": [
                "The summary makes several generic claims about processing indexed entries, updating counters/flags, and triggering an error when limits are exceeded. While these loosely match aspects of the function (iterating through bio segments, updating segment count, marking end of scatterlist, and BUG_ON check), they are vague and omit key specifics such as working with bio and scatterlist structures or the clustering logic. Most claims are accurate at a generic level, but none are highly specific to the source code semantics, which reduces precision.",
                "The summary makes generic claims about processing entries, updating counters/flags, and triggering an error on limits exceeded, which partially matches aspects of the code such as iterating over bio segments, incrementing nsegs, and BUG_ON check. However, it fails to cover the core primary purpose of mapping bio segments into a scatterlist for a block request queue, missing domain-specific terms and concrete I/O semantics. Secondary details like sg_mark_end and use of blk_queue_cluster are also absent, resulting in incomplete coverage despite some accurate general behavior description.",
                "The summary correctly notes iteration over entries, updating counters, and triggering an error on exceeding limits, which matches the loop over bio segments, updating nsegs, and invoking BUG_ON when nsegs exceeds bi_phys_segments. However, it is generic and omits any domain-specific details such as scatterlist mapping, clustering, or marking the end of scatterlists, thus providing low informational gain. There are no factual contradictions, but the lack of specificity makes the net benefit weak."
            ]
        },
        "comment": {
            "summary": "Maps segments of a block I/O bio to a scatter-gather list, updating the number of segments and handling physical segment constraints.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly describes that the function maps segments of a block I/O bio to a scatter-gather list, updates the segment count, and enforces physical segment constraints, all of which match the source code behavior. There are no inaccurate or irrelevant claims, resulting in a high proportion of accurate statements.",
                "The summary accurately describes the core functionality of mapping segments from a block I/O bio to a scatter-gather list and notes the physical segment constraint check, which matches the BUG_ON clause. This covers the core primary purpose with reasonable specificity and mentions a secondary detail about segment counting, but omits other secondary behaviors such as clustering logic and marking the end of the scatterlist.",
                "The summary correctly states that the function maps segments of a bio to a scatter-gather list and updates the segment count, which aligns with the core loop and `__blk_segment_map_sg` calls in the source. It also notes handling physical segment constraints, matching the final `BUG_ON` check. All claims are accurate, specific to the primary purpose, with no contradictory or irrelevant noise. The gain is moderate since the summary captures key semantics without detailing all implementation steps."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4204144,
    "strip_function_name": "sub_402670",
    "strip_decompiled_code": "int __fastcall sub_402670(unsigned int sig)\n{\n  unsigned int v1; // ebx\n  __pid_t v2; // ebp\n  double v3; // xmm0_8\n  int result; // eax\n  int *v5; // rbp\n  int v6; // r12d\n  bool v7; // zf\n  __int64 v8; // rbp\n  char *v9; // rax\n  double v10; // [rsp+8h] [rbp-40h]\n  _BYTE v11[56]; // [rsp+10h] [rbp-38h] BYREF\n\n  v1 = sig;\n  if ( sig == 14 )\n  {\n    v1 = signo;\n    dword_60A534 = 1;\n  }\n  v2 = pid;\n  if ( !pid )\n    _exit(v1 + 128);\n  v3 = *(double *)&qword_60A528;\n  if ( *(double *)&qword_60A528 == 0.0 )\n  {\n    if ( !byte_60A520 )\n      goto LABEL_6;\n    goto LABEL_9;\n  }\n  v10 = *(double *)&qword_60A528;\n  v3 = *(double *)&qword_60A528;\n  v5 = __errno_location();\n  v6 = *v5;\n  signo = 9;\n  sub_4024F0(0, v10);\n  v7 = byte_60A520 == 0;\n  qword_60A528 = 0LL;\n  *v5 = v6;\n  if ( !v7 )\n  {\nLABEL_9:\n    if ( (unsigned int)sub_406510(v1, v11, v3) )\n      __snprintf_chk();\n    v8 = sub_404C70(qword_60A518);\n    v9 = dcgettext(0LL, \"sending signal %s to command %s\", 5);\n    error(0, 0, v9, v11, v8);\n  }\n  v2 = pid;\n  if ( !pid )\n    signal(v1, (__sighandler_t)1);\nLABEL_6:\n  result = kill(v2, v1);\n  if ( !byte_60A522 )\n  {\n    signal(v1, (__sighandler_t)1);\n    result = kill(0, v1);\n    if ( v1 != 9 && v1 != 18 )\n    {\n      if ( !v2 )\n        signal(18, (__sighandler_t)1);\n      kill(v2, 18);\n      signal(18, (__sighandler_t)1);\n      return kill(0, 18);\n    }\n  }\n  return result;\n}\n",
    "function_name": "cleanup",
    "decompiled_code": "void __fastcall cleanup(unsigned int a1, double a2, double a3)\n{\n  unsigned int v3; // ebx\n  __pid_t v4; // ebp\n  double v5; // xmm0_8\n  int *v6; // rbp\n  int v7; // r12d\n  bool v8; // zf\n  char *v9; // rsi\n  char *v10; // rbp\n  char *v11; // rax\n  double v12; // [rsp+8h] [rbp-40h]\n  char signame[56]; // [rsp+10h] [rbp-38h] BYREF\n\n  v3 = a1;\n  if ( a1 == 14 )\n  {\n    v3 = term_signal;\n    timed_out = 1;\n  }\n  v4 = monitored_pid;\n  if ( !monitored_pid )\n    _exit(v3 + 128);\n  v5 = kill_after;\n  if ( kill_after == 0.0 )\n  {\n    if ( !verbose )\n      goto LABEL_6;\n    goto LABEL_9;\n  }\n  v12 = kill_after;\n  v5 = kill_after;\n  v6 = __errno_location();\n  v7 = *v6;\n  term_signal = 9;\n  settimeout(v12, a3, 0);\n  v8 = !verbose;\n  kill_after = 0.0;\n  *v6 = v7;\n  if ( !v8 )\n  {\nLABEL_9:\n    v9 = signame;\n    if ( (unsigned int)sig2str((char *)v3, signame) )\n    {\n      v9 = (char *)19;\n      __snprintf_chk();\n    }\n    v10 = quote(command, v9);\n    v11 = dcgettext(0LL, &msgid[351], 5);\n    error(0, 0, v11, signame, v10, v5, a3);\n  }\n  v4 = monitored_pid;\n  if ( !monitored_pid )\n    signal(v3, (__sighandler_t)1);\nLABEL_6:\n  kill(v4, v3);\n  if ( !foreground )\n  {\n    signal(v3, (__sighandler_t)1);\n    kill(0, v3);\n    if ( v3 != 9 && v3 != 18 )\n    {\n      if ( !v4 )\n        signal(18, (__sighandler_t)1);\n      kill(v4, 18);\n      signal(18, (__sighandler_t)1);\n      kill(0, 18);\n    }\n  }\n}\n",
    "source_code": "\nstatic void\ncleanup (void)\n{\n  if (close (STDIN_FILENO) < 0)\n    die (EXIT_FAILURE, errno, _(\"closing input file %s\"), quoteaf (input_file));\n\n  /* Don't remove this call to close, even though close_stdout\n     closes standard output.  This close is necessary when cleanup\n     is called as part of a signal handler.  */\n  if (close (STDOUT_FILENO) < 0)\n    die (EXIT_FAILURE, errno,\n         _(\"closing output file %s\"), quoteaf (output_file));\n}",
    "comment": "Cleans up temporary nodes by unlinking their associated names and resets the temporary head pointer to NULL.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Handles SIGINT or SIGTERM signals by executing corresponding actions , adjusting exit codes , and managing process states based on signal actions .\n",
    "cpbcs_sum": "The function handles termination signals in a child process by forking, managing signals and executing a specified termination signal.\n",
    "misum_sum": "Handles signals by writing the appropriate output to a child process based on the specified exit code, while managing interrupts and process group ID.\n",
    "decom_sum": "Sends a specified signal to a process and optionally logs \u201csending signal \u2026 to command \u2026\u201d before handling related termination or continuation signals.",
    "cfg_sum": "Sends specified signals to a process or command with retries and localized error messages, handling special cases for termination and continuation.",
    "work_score": {
        "decom": {
            "summary": "Sends a specified signal to a process and optionally logs \u201csending signal \u2026 to command \u2026\u201d before handling related termination or continuation signals.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes sending signals to a process and logging messages, which is unrelated to the actual function in the source code. The source code performs cleanup by closing standard input and output file descriptors and handling errors, with no signal sending or process control involved. All claims in the summary are inaccurate, resulting in 0% accuracy.",
                "The summary describes sending signals to a process and related logging, which is unrelated to the actual code that closes standard input and output with error handling in a cleanup routine. The core purpose of the source code\u2014closing file descriptors and terminating on error\u2014is completely absent, and no accurate claims align with the function\u2019s semantics.",
                "The summary claims the function sends a signal to a process and handles termination/continuation, which is entirely unrelated to the source code. The actual code performs cleanup by closing STDIN and STDOUT file descriptors and handles errors. This is a FATAL inaccuracy about the primary purpose, as it misstates the core action and I/O behavior, leaving no correct or relevant claims."
            ]
        },
        "cfg": {
            "summary": "Sends specified signals to a process or command with retries and localized error messages, handling special cases for termination and continuation.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function sends signals, retries, and handles termination/continuation cases, which are unrelated to the source code. The actual code only closes STDIN and STDOUT with error handling, and does not involve signals, retries, or process control. All extracted claims are inaccurate with respect to the code semantics, resulting in 0% accuracy.",
                "The summary talks about sending signals with retries and localized error messages, which is unrelated to the source code that performs cleanup by closing stdin and stdout with error handling. None of the claims in the summary accurately reflect the core purpose\u2014closing file descriptors for input and output, including a specific note about signal handler context\u2014so the core is entirely missing and the content is pure noise.",
                "The summary describes sending signals to processes with retries and localized error messages, which has no relation to the source code. The source code's primary purpose is cleaning up by closing stdin and stdout, with error handling. All claims in the summary are NOISE and misaligned, overwhelming accuracy since no ACCURATE claims are present. The worst failure mode is incorrect domain semantics (FATAL on core purpose)."
            ]
        },
        "comment": {
            "summary": "Cleans up temporary nodes by unlinking their associated names and resets the temporary head pointer to NULL.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function unlinks associated names of temporary nodes and resets a temporary head pointer to NULL, which is unrelated to the actual code. The source code performs cleanup by closing standard input and output file descriptors with error handling, and no node operations or pointer resetting occur. All claims are inaccurate, resulting in 0% accuracy.",
                "The summary describes unlinking temporary nodes and resetting a head pointer, which does not align at all with the source code\u2019s actual behavior of closing standard input and output file descriptors with error handling in a cleanup function. The core operation of closing files is completely missing, and none of the claims are accurate with respect to the given code.",
                "The summary claims the function cleans up temporary nodes and resets a head pointer to NULL, which is entirely unrelated to the actual source code. The code instead closes STDIN and STDOUT file descriptors and reports errors if these operations fail. This is a severe factual inaccuracy targeting the primary purpose of the function, making the description unusable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579215456,
    "strip_function_name": "sub_FFFFFFFF8105A660",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8105A660(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r13\n  int v11; // r15d\n  volatile signed __int32 *v12; // rcx\n  volatile signed __int32 *v13; // rdx\n  __int64 v14; // rsi\n  signed int v15; // eax\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  int v20; // ebx\n  int v21; // eax\n\n  v9 = sub_FFFFFFFF81104FD0(32LL, 8LL);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = -1;\n  sub_FFFFFFFF8103F360(32LL);\n  while ( 1 )\n  {\n    v15 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E00, 64LL, v11 + 1);\n    v11 = v15;\n    if ( v15 >= dword_FFFFFFFF81CB7EA8 )\n      break;\n    v12 = (volatile signed __int32 *)(qword_FFFFFFFF81CB6720[v15] + v10);\n    *(_QWORD *)v12 = 0xFFFFFFFE0LL;\n    v13 = v12;\n    v14 = qword_FFFFFFFF81CB6E38;\n    v12 += 2;\n    *((_QWORD *)v13 + 3) = a1;\n    *((_QWORD *)v13 + 1) = v12;\n    *((_QWORD *)v13 + 2) = v12;\n    sub_FFFFFFFF81058570(v15, v14, v13, a2, a3, a4, a5, v18, v19, a8, a9, (__int64)v12, v16, v17);\n  }\n  v20 = -1;\n  while ( 1 )\n  {\n    v21 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E00, 64LL, v20 + 1);\n    v20 = v21;\n    if ( v21 >= dword_FFFFFFFF81CB7EA8 )\n      break;\n    sub_FFFFFFFF81058D70((unsigned __int64 *)(qword_FFFFFFFF81CB6720[v21] + v10));\n  }\n  sub_FFFFFFFF8103F3A0();\n  sub_FFFFFFFF811040F0(v10);\n  return 0LL;\n}\n",
    "function_name": "schedule_on_each_cpu",
    "decompiled_code": "__int64 __fastcall schedule_on_each_cpu(\n        unsigned __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r13\n  int v11; // r15d\n  unsigned __int64 *v12; // rcx\n  unsigned __int64 *v13; // rdx\n  __int64 v14; // rsi\n  signed int next_bit; // eax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // ebx\n  int v19; // eax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v9 = _alloc_percpu(0x20uLL, 8uLL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = -1;\n  get_online_cpus(32LL, 8LL);\n  while ( 1 )\n  {\n    next_bit = find_next_bit((__int64)cpu_online_mask[0], 0x40uLL, v11 + 1);\n    v11 = next_bit;\n    if ( next_bit >= nr_cpu_ids )\n      break;\n    v12 = (unsigned __int64 *)(_per_cpu_offset[next_bit] + v10);\n    *v12 = 0xFFFFFFFE0LL;\n    v13 = v12;\n    v14 = system_wq;\n    ++v12;\n    v13[3] = a1;\n    v13[1] = (unsigned __int64)v12;\n    v13[2] = (unsigned __int64)v12;\n    queue_work_on(next_bit, v14, v13, a2, a3, a4, a5, v16, v17, a8, a9);\n  }\n  v18 = -1;\n  while ( 1 )\n  {\n    v19 = find_next_bit((__int64)cpu_online_mask[0], 0x40uLL, v18 + 1);\n    v18 = v19;\n    if ( v19 >= nr_cpu_ids )\n      break;\n    flush_work((unsigned __int64 *)(_per_cpu_offset[v19] + v10), 64LL, a2, a3, a4, a5, v20, v21, a8, a9);\n  }\n  put_online_cpus(a2, a3, a4, a5, v20, v21, a8, a9);\n  free_percpu(v10, a2, a3, a4, a5, v22, v23, a8, a9);\n  return 0LL;\n}\n",
    "source_code": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
    "comment": "Schedules a specified work function on each online CPU and waits for their completion before freeing allocated resources.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Allocates and initializes a workqueue by finding a free workqueue associated with the given PID namespace .\n",
    "cpbcs_sum": "Adds a work item to a scheduling domain list and notifies the work queue if it exceeds a maximum of CPU stop reason.\n",
    "misum_sum": "Resizes the scheduling work count and schedules an work item to handle CPU in the system.\n",
    "decom_sum": "Initializes and configures per-index data structures with provided parameters, invokes setup routines, finalizes processing for each index, then releases allocated resources.",
    "cfg_sum": "Allocates a 32-byte buffer, initializes and processes indexed global entries with provided parameters, then cleans up allocated resources before returning success.",
    "work_score": {
        "decom": {
            "summary": "Initializes and configures per-index data structures with provided parameters, invokes setup routines, finalizes processing for each index, then releases allocated resources.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary uses vague, generic terms like 'per-index data structures' and 'setup routines' instead of accurately describing CPUs, work structures, and functions used in the source. It does mention initialization, invocation, finalization, and resource release, which loosely matches alloc_percpu, scheduling, flushing, and freeing in the code, but omits critical semantic details (CPU context, work scheduling) and gives no domain-specific accuracy. The claims are mostly generic and low-info, with little distinguishing fidelity to actual code behavior, so fewer than half are precise and factually aligned.",
                "The summary omits the core purpose, which is to schedule and execute a provided work function on each online CPU. While it vaguely mentions initialization, invocation, and cleanup across indices, it fails to specify CPUs, work scheduling, or flushing completion. This makes it generic and inaccurate regarding the domain-specific semantics, covering neither the primary operation nor critical side effects in the code.",
                "The summary uses vague, generic terms like 'per-index data structures' and 'setup routines' without accurately reflecting the CPU-specific scheduling and work flushing in the source code. This is NOISE, as it does not convey the primary purpose\u2014scheduling a work function on each online CPU\u2014nor key specifics such as allocating per-CPU work_struct instances, invoking INIT_WORK, and scheduling/flush operations. No FATAL contradictions are present, but the lack of precise alignment and reliance on generic phrasing yields very low informational gain."
            ]
        },
        "cfg": {
            "summary": "Allocates a 32-byte buffer, initializes and processes indexed global entries with provided parameters, then cleans up allocated resources before returning success.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about allocating a 32-byte buffer and processing indexed global entries are not supported by the source code, which instead allocates per-CPU work_struct instances, schedules work on each CPU, flushes them, and frees the structures. None of the stated actions in the summary match the actual domain-semantic behavior in the source, resulting in 0% accurate claims.",
                "The summary makes several claims unrelated to the actual source code, such as allocating a 32-byte buffer and processing indexed global entries, which are not present in the function. It misses the core purpose of scheduling and executing a work function on each online CPU. No accurate claim covers the main domain action or other critical semantics like per-CPU allocation, work initialization, scheduling, flushing, and cleanup.",
                "The summary contains multiple fact-based claims that do not match the source code semantics. It incorrectly describes allocating a 32-byte buffer, processing indexed global entries, and using provided parameters, none of which occur in the function. The actual code allocates per-CPU work structures, schedules work on each CPU, flushes those works, and frees resources. These are core purpose mismatches, making them FATAL errors concerning the primary behavior and inputs/outputs. There are no accurate or useful claims, resulting in severe negative impact."
            ]
        },
        "comment": {
            "summary": "Schedules a specified work function on each online CPU and waits for their completion before freeing allocated resources.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately reflects the source code\u2019s behavior: it mentions scheduling a specified work function on each online CPU, waiting for completion, and freeing allocated resources, all of which are clearly present in the code. There are no incorrect or irrelevant claims, making the claim list fully accurate.",
                "The summary accurately states that the function schedules a given work function on each online CPU, waits for completion, and frees resources, which matches the core purpose of coordinating work execution per CPU and ensuring completion before cleanup. It covers the main domain-specific behavior, including the loop over online CPUs and resource management. However, it omits secondary details such as allocation failure handling with -ENOMEM, and the explicit use of INIT_WORK, schedule_work_on, flush_work, and CPU online management via get_online_cpus/put_online_cpus.",
                "The summary correctly identifies the core purpose of the function (scheduling a provided work function across all online CPUs) and the sequence of key steps including waiting for completion and freeing resources. All claims are accurate, domain-specific, and match the source code's semantics, with no evidence of noise or inaccuracies. The description covers primary purpose, key I/O, and side effects precisely, providing high net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580409840,
    "strip_function_name": "sub_FFFFFFFF8117DFF0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8117DFF0(_DWORD *a1, __int64 a2)\n{\n  __int64 v2; // r11\n  __int64 v3; // r10\n  __int64 v4; // r9\n  __int64 v5; // rbx\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // rdx\n  __int64 result; // rax\n\n  v2 = *(_QWORD *)(a2 + 16);\n  v3 = *(_QWORD *)(a2 + 24);\n  v4 = *(_QWORD *)(a2 + 32);\n  v5 = *(_QWORD *)(a2 + 8);\n  v6 = *(_QWORD *)(a2 + 72);\n  if ( ((v6 | v5 | v4 | v3 | v2) & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v7 = *(_QWORD *)(a2 + 40);\n  if ( v7 != -1 && (v7 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v8 = *(_QWORD *)(a2 + 48);\n  if ( v8 != -1 && (v8 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  if ( (__PAIR128__(-(__int64)__CFADD__(a1, 64LL), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n      - (unsigned __int64)(a1 + 16)) >> 64 )\n    return 4294967282LL;\n  *a1 = *(_QWORD *)a2;\n  a1[1] = v5;\n  a1[2] = v2;\n  a1[3] = v3;\n  a1[4] = v4;\n  a1[5] = v7;\n  a1[6] = v8;\n  a1[9] = *(_QWORD *)(a2 + 64);\n  a1[7] = *(_DWORD *)(a2 + 56);\n  a1[8] = *(_DWORD *)(a2 + 60);\n  a1[10] = v6;\n  a1[11] = *(_QWORD *)(a2 + 80);\n  v9 = sub_FFFFFFFF812BA550(a1 + 12, 16LL);\n  result = 0LL;\n  if ( v9 )\n    return 4294967282LL;\n  return result;\n}\n",
    "function_name": "put_compat_statfs",
    "decompiled_code": "__int64 __fastcall put_compat_statfs(_DWORD *a1, __int64 a2)\n{\n  __int64 v2; // r11\n  __int64 v3; // r10\n  __int64 v4; // r9\n  __int64 v5; // rbx\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // rdx\n  __int64 result; // rax\n\n  v2 = *(_QWORD *)(a2 + 16);\n  v3 = *(_QWORD *)(a2 + 24);\n  v4 = *(_QWORD *)(a2 + 32);\n  v5 = *(_QWORD *)(a2 + 8);\n  v6 = *(_QWORD *)(a2 + 72);\n  if ( ((v6 | v5 | v4 | v3 | v2) & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v7 = *(_QWORD *)(a2 + 40);\n  if ( v7 != -1 && (v7 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v8 = *(_QWORD *)(a2 + 48);\n  if ( v8 != -1 && (v8 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  if ( (__PAIR128__(-(__int64)__CFADD__(a1, 64LL), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n      - (unsigned __int64)(a1 + 16)) >> 64 )\n    return 4294967282LL;\n  *a1 = *(_QWORD *)a2;\n  a1[1] = v5;\n  a1[2] = v2;\n  a1[3] = v3;\n  a1[4] = v4;\n  a1[5] = v7;\n  a1[6] = v8;\n  a1[9] = *(_QWORD *)(a2 + 64);\n  a1[7] = *(_DWORD *)(a2 + 56);\n  a1[8] = *(_DWORD *)(a2 + 60);\n  a1[10] = v6;\n  a1[11] = *(_QWORD *)(a2 + 80);\n  v9 = _clear_user((_QWORD *)a1 + 6, 0x10uLL);\n  result = 0LL;\n  if ( v9 )\n    return 4294967282LL;\n  return result;\n}\n",
    "source_code": "\nstatic int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\t\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tif (!access_ok(VERIFY_WRITE, ubuf, sizeof(*ubuf)) ||\n\t    __put_user(kbuf->f_type, &ubuf->f_type) ||\n\t    __put_user(kbuf->f_bsize, &ubuf->f_bsize) ||\n\t    __put_user(kbuf->f_blocks, &ubuf->f_blocks) ||\n\t    __put_user(kbuf->f_bfree, &ubuf->f_bfree) ||\n\t    __put_user(kbuf->f_bavail, &ubuf->f_bavail) ||\n\t    __put_user(kbuf->f_files, &ubuf->f_files) ||\n\t    __put_user(kbuf->f_ffree, &ubuf->f_ffree) ||\n\t    __put_user(kbuf->f_namelen, &ubuf->f_namelen) ||\n\t    __put_user(kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) ||\n\t    __put_user(kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]) ||\n\t    __put_user(kbuf->f_frsize, &ubuf->f_frsize) ||\n\t    __put_user(kbuf->f_flags, &ubuf->f_flags) ||\n\t    __clear_user(ubuf->f_spare, sizeof(ubuf->f_spare)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "comment": "Validates and transfers filesystem statistics from kernel to user space, ensuring no overflow occurs for 32-bit fields.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Converts a POSIX file lock request into an absolute lock range for a specified file , validating offsets and length constraints .\n",
    "cpbcs_sum": "Validates and updates the address for a kernel user and group IDs, ensuring security checks and checking for overflow conditions.\n",
    "misum_sum": "Copies data from a user-space compatible file to a user-space compatible `msghdr` structure, checking for access errors and updating the tail pointer.\n",
    "decom_sum": "Validates 64-bit structure fields for 32-bit range compliance, then copies them into a destination buffer and performs a final integrity check.",
    "cfg_sum": "Validates 64-bit to 32-bit field constraints of a structure, copies data into target buffer, and returns specific error codes on invalid values or size violations.",
    "work_score": {
        "decom": {
            "summary": "Validates 64-bit structure fields for 32-bit range compliance, then copies them into a destination buffer and performs a final integrity check.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately captures the key behavior: it validates that certain fields fit within 32-bit limits if appropriate and then copies them into the user-provided buffer. However, the phrase 'final integrity check' is slightly vague compared to the actual explicit error checks like access_ok, __put_user calls, and zeroing spare fields. Overall, the majority of the claims are correct and grounded in the source code, with only minor imprecision.",
                "The summary correctly captures the core purpose of the function: it validates that certain 64-bit fields fit within 32-bit limits and then copies them into the user-provided buffer. This aligns with the source code's overflow checks and subsequent __put_user calls. However, it omits important secondary details, such as the specific fields checked, the special handling of f_files and f_ffree values, the access_ok check, and the final __clear_user step. The phrase 'final integrity check' is vague and does not reflect the concrete EFAULT handling present.",
                "The summary correctly captures the primary purpose of the function: checking that certain 64-bit fields fit into 32-bit range (to avoid overflow) and then writing these to a user-provided buffer. However, it inaccurately describes the final step as an 'integrity check'; in the source code, the final checks are for write/access errors, not logical data integrity. This is a mild inaccuracy but does not fatally contradict the primary purpose. The gain is low-moderate since the first part is accurate and specific, while the last phrase introduces noise."
            ]
        },
        "cfg": {
            "summary": "Validates 64-bit to 32-bit field constraints of a structure, copies data into target buffer, and returns specific error codes on invalid values or size violations.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately captures the core semantics of the function: it checks for 64-bit to 32-bit constraints and potential overflow, copies multiple fields to the user buffer, and returns specific error codes (-EOVERFLOW for size violations, -EFAULT for copy failures). All claims are grounded in the source code without contradictions, showing high alignment with the evaluation steps.",
                "The summary correctly identifies the core purpose of the function: checking for overflow when converting 64-bit kstatfs fields to 32-bit compat_statfs fields and copying them to the user buffer. It also notes returning error codes for invalid values or size violations, aligning with the EOVERFLOW and EFAULT paths. However, it omits key secondary details such as the specific fields validated, handling of special -1 values for f_files and f_ffree, the access_ok check, and the clearing of spare fields, resulting in incomplete coverage of behavior-critical semantics.",
                "The summary accurately captures the core purpose: checking 64-bit to 32-bit field constraints, copying data into the target buffer, and returning error codes on violations, which matches the overflow checks and __put_user calls in the code. There is no contradictory claim and noise is minimal. However, the level of detail is low, as it omits specifics such as the EOVERFLOW vs EFAULT distinction and the access_ok verification step, limiting the potential gain."
            ]
        },
        "comment": {
            "summary": "Validates and transfers filesystem statistics from kernel to user space, ensuring no overflow occurs for 32-bit fields.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function validates and transfers filesystem statistics from kernel to user space, which matches the code's use of overflow checks and __put_user calls. The mention of ensuring no overflow for 32-bit fields aligns with the initial size and mask checks in the source code, and there are no inaccurate claims. All key details are accurate and semantically grounded in the code.",
                "The summary correctly captures the core purpose\u2014transferring filesystem statistics from kernel to user space and checking for overflow in 32-bit fields\u2014matching the code\u2019s domain-specific action. However, it omits secondary details like handling of special -1 values for f_files/f_ffree, performing access_ok verification, returning -EFAULT on write errors, and clearing spare fields, which limits completeness.",
                "The summary accurately states the primary function: transferring filesystem statistics from kernel to user space and checking for overflow in 32-bit fields. There are no incorrect claims, and while the summary is somewhat generic, it captures the core domain behavior without introducing noise. However, it lacks mention of other key aspects like access checks and error handling, limiting its informational value."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 174800,
    "strip_function_name": "sub_2AAD0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_2AAD0(_DWORD *a1, __int64 a2, unsigned __int64 a3, char *a4, size_t a5)\n{\n  unsigned __int64 v6; // rbx\n  int v8; // eax\n  unsigned __int64 v9; // r14\n  unsigned __int64 v10; // rbp\n  __int64 v11; // r12\n  _DWORD *v12; // r14\n  unsigned __int64 v13; // rbx\n  int v14; // eax\n\n  v6 = sub_2A570((__int64)a1, a2, a3, a4, a5, 1, 1u);\n  if ( sub_F240(v6) )\n    return v6;\n  v8 = a1[13];\n  v9 = -11LL;\n  if ( v8 )\n  {\n    v10 = a3 - v6;\n    v11 = v6 + a2;\n    if ( v8 == 1 )\n    {\n      v9 = sub_13AA0(v11, v10, a1[21], a1[28], a1[29], 0LL, 0);\n      if ( sub_F240(v9) )\n        goto LABEL_10;\n      v10 -= v9;\n      a1[13] = 2;\n      v12 = (_DWORD *)(v11 + v9);\n    }\n    else\n    {\n      v12 = (_DWORD *)(v6 + a2);\n      if ( v8 == 3 )\n        goto LABEL_8;\n    }\n    if ( v10 <= 3 )\n      goto LABEL_14;\n    *v12 = 1;\n    v10 -= 3LL;\n    v12 = (_DWORD *)((char *)v12 + 3);\nLABEL_8:\n    if ( !a1[29] )\n    {\nLABEL_9:\n      a1[13] = 0;\n      v9 = (unsigned __int64)v12 - v11;\n      goto LABEL_10;\n    }\n    v14 = sub_EFE0((__int64)(a1 + 40));\n    if ( v10 > 3 )\n    {\n      *v12++ = v14;\n      goto LABEL_9;\n    }\nLABEL_14:\n    v9 = -12LL;\n  }\nLABEL_10:\n  v13 = v9 + v6;\n  if ( sub_F240(v9) )\n    return v9;\n  return v13;\n}\n",
    "function_name": "ZSTD_compressEnd",
    "decompiled_code": "size_t __fastcall ZSTD_compressEnd(_DWORD *a1, __int64 a2, unsigned __int64 a3, char *a4, size_t a5)\n{\n  size_t v6; // rbx\n  int v8; // eax\n  unsigned __int64 v9; // r14\n  unsigned __int64 v10; // rbp\n  __int64 v11; // r12\n  _DWORD *v12; // r14\n  unsigned __int64 v13; // rbx\n  int v14; // eax\n\n  v6 = ZSTD_compressContinue_internal((__int64)a1, a2, a3, a4, a5, 1, 1u);\n  if ( ZSTD_isError(v6) )\n    return v6;\n  v8 = a1[13];\n  v9 = -11LL;\n  if ( v8 )\n  {\n    v10 = a3 - v6;\n    v11 = v6 + a2;\n    if ( v8 == 1 )\n    {\n      v9 = ZSTD_writeFrameHeader_isra_7(v11, v10, a1[21], a1[28], a1[29], 0LL, 0);\n      if ( ZSTD_isError(v9) )\n        goto LABEL_10;\n      v10 -= v9;\n      a1[13] = 2;\n      v12 = (_DWORD *)(v11 + v9);\n    }\n    else\n    {\n      v12 = (_DWORD *)(v6 + a2);\n      if ( v8 == 3 )\n        goto LABEL_8;\n    }\n    if ( v10 <= 3 )\n      goto LABEL_14;\n    *v12 = 1;\n    v10 -= 3LL;\n    v12 = (_DWORD *)((char *)v12 + 3);\nLABEL_8:\n    if ( !a1[29] )\n    {\nLABEL_9:\n      a1[13] = 0;\n      v9 = (unsigned __int64)v12 - v11;\n      goto LABEL_10;\n    }\n    v14 = ZSTD_XXH64_digest((__int64)(a1 + 40));\n    if ( v10 > 3 )\n    {\n      *v12++ = v14;\n      goto LABEL_9;\n    }\nLABEL_14:\n    v9 = -12LL;\n  }\nLABEL_10:\n  v13 = v9 + v6;\n  if ( ZSTD_isError(v9) )\n    return v9;\n  return v13;\n}\n",
    "source_code": "\n\nsize_t ZSTD_compressEnd (ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize)\n{\n    size_t endResult;\n    size_t const cSize = ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1, 1);\n    if (ZSTD_isError(cSize)) return cSize;\n    endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);\n    if (ZSTD_isError(endResult)) return endResult;\n    return cSize + endResult;\n}",
    "comment": "Compresses data using a continuation method, writes an epilogue, and returns the total compressed size or an error code if the process fails.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Compresses a data block using a specific compression strategy and returns the compressed size or an error code if unsuccessful .\n",
    "cpbcs_sum": "Reads data from a specified offset into an image buffer, handling offsets and managing buffer states.\n",
    "misum_sum": "Processes input data by checking for partial fields and adjusting the last block in the XorrisO structure based on the specified boundary type.\n",
    "decom_sum": "Processes a data buffer with staged state handling, injecting control bytes and device responses, then returns total processed length or an error code.",
    "cfg_sum": "Processes a data buffer with conditional transformation steps, updates state flags, and returns a status or byte count indicating operation success or specific errors.",
    "work_score": {
        "decom": {
            "summary": "Processes a data buffer with staged state handling, injecting control bytes and device responses, then returns total processed length or an error code.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about staged state handling, control bytes, and device responses are not present in the source code, which simply compresses input, writes an epilogue, and returns either the total compressed size or an error code. Only the final part about returning the total length or an error code aligns with the function semantics, making most claims inaccurate.",
                "The summary does not cover the core purpose of the function, which is to finish a compression operation using ZSTD by continuing compression and writing an epilogue, returning the combined size or an error. Instead, it inaccurately describes staged state handling, control bytes, and device responses, none of which are present in the source. It fails to mention ZSTD compression, continuation, or epilogue writing, and contains irrelevant details, so both the core and secondary semantics are missing.",
                "The summary introduces unrelated concepts like staged state handling, control bytes, and device responses, which are not present in the source code. The actual implementation compresses input data using ZSTD_compressContinue_internal, writes an epilogue, and returns the combined size or an error code. The only partially correct element is returning total processed length or an error code, but the rest is inaccurate noise that contradicts the function\u2019s actual compression behavior. The worst failure mode is FATAL on the primary purpose, misrepresenting the core operation."
            ]
        },
        "cfg": {
            "summary": "Processes a data buffer with conditional transformation steps, updates state flags, and returns a status or byte count indicating operation success or specific errors.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary makes vague claims about processing a data buffer, updating state flags, and returning either a status or byte count, but the source code shows a function that performs compression followed by an epilogue write, checking for errors. The summary's 'conditional transformation steps' and 'updates state flags' are unsupported by the code, while only the notion of returning a byte count or error code aligns. This results in mostly inaccurate claims with little direct match to the function's actual behavior.",
                "The summary inaccurately describes the core purpose: it does not mention ZSTD compression or the function\u2019s role in finalizing compression and writing the epilogue. Instead, it uses vague language like 'processes a data buffer' and 'updates state flags,' which is not present in the source code. It misses the core operation of completing compression with ZSTD_compressContinue_internal, handling possible errors, and appending the epilogue. No specific domain semantics from the source appear in the summary, resulting in no core coverage and very limited secondary details.",
                "The summary contains mostly inaccurate claims: it mentions 'conditional transformation steps' and 'updates state flags' which are not present in the source code. The function actually performs compression via ZSTD_compressContinue_internal, then writes an epilogue, and checks for errors\u2014there is no visible state flag update. The only partially accurate part is that it returns either a byte count (on success) or an error code, but the inaccuracies overwhelm the correct portions. The main failure mode is NOISE, as the description is generic and misaligned with the core semantics."
            ]
        },
        "comment": {
            "summary": "Compresses data using a continuation method, writes an epilogue, and returns the total compressed size or an error code if the process fails.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function compresses data using a continuation method, writes an epilogue, and returns the total compressed size or an error code if either step fails. These points align with the source code's calls to `ZSTD_compressContinue_internal`, `ZSTD_writeEpilogue`, and checks using `ZSTD_isError`. All claims are accurate and relevant to the code's semantics, with no contradictions or irrelevant noise.",
                "The summary correctly identifies that the function compresses data in a continuation mode, writes an epilogue, and returns either the total compressed size or an error code. This aligns with the core purpose of the source code, which is to complete compression using `ZSTD_compressContinue_internal`, append an epilogue with `ZSTD_writeEpilogue`, and handle errors by returning error codes from either stage. However, it omits details such as the specific parameters passed to `ZSTD_compressContinue_internal` and the calculation of the returned size, meaning secondary coverage is limited.",
                "The summary contains accurate, specific claims about the function's core behavior: using a continuation compression method, writing an epilogue, returning the total compressed size, and handling errors. All these elements match the source code with no contradictions or irrelevant noise. The claims target the primary purpose and key I/O correctly, providing clear insight into the function\u2019s operation."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581012544,
    "strip_function_name": "sub_FFFFFFFF81211240",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF81211240(__int64 a1, int a2, int a3, __int64 a4)\n{\n  unsigned int v4; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v6; // rcx\n\n  *(_DWORD *)(a1 + 24) = a4;\n  v4 = 1000 * a3 / 0xAu;\n  result = v4;\n  *(_QWORD *)a1 = v4;\n  if ( a2 != 17 )\n  {\n    if ( a2 != 256 && a2 != 6 )\n      BUG();\n    if ( (_DWORD)a4 )\n    {\n      a4 = (unsigned int)a4;\n      if ( !v4 )\n      {\nLABEL_7:\n        *(_QWORD *)a1 = 60000LL;\n        result = 60000LL;\nLABEL_8:\n        *(_QWORD *)(a1 + 16) = result;\n        v6 = result + result * a4;\n        if ( v6 > 0x927C0 )\n        {\n          *(_QWORD *)(a1 + 8) = 600000LL;\n        }\n        else\n        {\n          if ( v6 < result )\n            v6 = result;\n          *(_QWORD *)(a1 + 8) = v6;\n        }\n        *(_BYTE *)(a1 + 28) = 0;\n        return result;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 24) = 2;\n      a4 = 2LL;\n      if ( !v4 )\n        goto LABEL_7;\n    }\n    if ( v4 > 0x927C0 )\n    {\n      *(_QWORD *)a1 = 600000LL;\n      result = 600000LL;\n    }\n    goto LABEL_8;\n  }\n  if ( !(_DWORD)a4 )\n    *(_DWORD *)(a1 + 24) = 3;\n  if ( v4 )\n  {\n    if ( v4 > 0xEA60 )\n      *(_QWORD *)a1 = 60000LL;\n  }\n  else\n  {\n    *(_QWORD *)a1 = 1100LL;\n  }\n  *(_QWORD *)(a1 + 8) = 60000LL;\n  *(_BYTE *)(a1 + 28) = 1;\n  return result;\n}\n",
    "function_name": "nfs_init_timeout_values",
    "decompiled_code": "unsigned __int64 __fastcall nfs_init_timeout_values(__int64 a1, int a2, int a3, __int64 a4)\n{\n  unsigned int v4; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v6; // rcx\n\n  *(_DWORD *)(a1 + 24) = a4;\n  v4 = 1000 * a3 / 0xAu;\n  result = v4;\n  *(_QWORD *)a1 = v4;\n  if ( a2 != 17 )\n  {\n    if ( a2 != 256 && a2 != 6 )\n      BUG();\n    if ( (_DWORD)a4 )\n    {\n      a4 = (unsigned int)a4;\n      if ( !v4 )\n      {\nLABEL_7:\n        *(_QWORD *)a1 = 60000LL;\n        result = 60000LL;\nLABEL_8:\n        *(_QWORD *)(a1 + 16) = result;\n        v6 = result + result * a4;\n        if ( v6 > 0x927C0 )\n        {\n          *(_QWORD *)(a1 + 8) = 600000LL;\n        }\n        else\n        {\n          if ( v6 < result )\n            v6 = result;\n          *(_QWORD *)(a1 + 8) = v6;\n        }\n        *(_BYTE *)(a1 + 28) = 0;\n        return result;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 24) = 2;\n      a4 = 2LL;\n      if ( !v4 )\n        goto LABEL_7;\n    }\n    if ( v4 > 0x927C0 )\n    {\n      *(_QWORD *)a1 = 600000LL;\n      result = 600000LL;\n    }\n    goto LABEL_8;\n  }\n  if ( !(_DWORD)a4 )\n    *(_DWORD *)(a1 + 24) = 3;\n  if ( v4 )\n  {\n    if ( v4 > 0xEA60 )\n      *(_QWORD *)a1 = 60000LL;\n  }\n  else\n  {\n    *(_QWORD *)a1 = 1100LL;\n  }\n  *(_QWORD *)(a1 + 8) = 60000LL;\n  *(_BYTE *)(a1 + 28) = 1;\n  return result;\n}\n",
    "source_code": "void nfs_init_timeout_values(struct rpc_timeout *to, int proto,\n\t\t\t\t    unsigned int timeo, unsigned int retrans)\n{\n\tto->to_initval = timeo * HZ / 10;\n\tto->to_retries = retrans;\n\n\tswitch (proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_TCP_RETRANS;\n\t\tif (to->to_initval == 0)\n\t\t\tto->to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_TCP_TIMEOUT;\n\t\tto->to_increment = to->to_initval;\n\t\tto->to_maxval = to->to_initval + (to->to_increment * to->to_retries);\n\t\tif (to->to_maxval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_maxval = NFS_MAX_TCP_TIMEOUT;\n\t\tif (to->to_maxval < to->to_initval)\n\t\t\tto->to_maxval = to->to_initval;\n\t\tto->to_exponential = 0;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_UDP:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_UDP_RETRANS;\n\t\tif (!to->to_initval)\n\t\t\tto->to_initval = NFS_DEF_UDP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_UDP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_maxval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_exponential = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "comment": "Initializes timeout values for NFS RPC transport depending on the protocol type, setting retries, initial timeout, and limits accordingly.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Sets the expiration time for an NFS cache based on the specified type , ensuring it does not exceed the maximum cache size .\n",
    "cpbcs_sum": "Decodes a sector from a byte stream, verifying its type and length length, and ensuring valid cookie types and alignment.\n",
    "misum_sum": "Calculates a PCI power level based on specified source, pixel for a given byte size, and optional clock constraints.\n",
    "decom_sum": "Configures timing parameters and mode fields in a device control structure based on input type, duration, and mode identifiers, enforcing bounds and defaults.",
    "cfg_sum": "Configures timing parameters based on mode and input values, clamps them within limits, updates related fields, and triggers a system bug on invalid mode.",
    "work_score": {
        "decom": {
            "summary": "Configures timing parameters and mode fields in a device control structure based on input type, duration, and mode identifiers, enforcing bounds and defaults.",
            "score": [
                0.5,
                0.4,
                0.4
            ],
            "reason": [
                "The summary is overly generic and lacks specific, verifiable details from the source code. While it vaguely states that timing parameters and mode fields are configured based on inputs and bounds/defaults are enforced, it omits key domain-specific behaviors such as distinct handling for TCP vs UDP, the exact parameters initialized (to_initval, to_retries, etc.), and precise constants used. This results in most claims being low-information and only loosely accurate, with little clear linkage to the actual implementation semantics, leading to mixed reliability.",
                "The summary correctly notes that the function configures parameters in a structure based on input types, sets defaults, and enforces bounds, which aligns broadly with the code's behavior. However, it uses vague terms like 'device control structure', 'duration', and 'mode identifiers' instead of specifying NFS RPC timeout initialization for TCP/UDP transports, missing the core purpose. It also omits several key secondary details such as handling of exponential backoff for UDP, calculation of max values for TCP, and the specific constants used.",
                "The summary contains mostly generic statements about configuring parameters in a 'device control structure', which is inaccurate because the source code configures RPC/NFS timeout values, not a generic device control. It omits key specifics such as protocol-specific handling for TCP vs UDP, use of default constants, and the computation of max values. While it mentions enforcing bounds and defaults, these are presented in a vague way, failing to capture the core semantics. This mischaracterization is a form of noise rather than a direct fatal contradiction, but the lack of specificity means the gain is very low."
            ]
        },
        "cfg": {
            "summary": "Configures timing parameters based on mode and input values, clamps them within limits, updates related fields, and triggers a system bug on invalid mode.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly captures the core functionality: setting timing parameters based on protocol mode and inputs, enforcing upper limits, updating related struct fields, and calling BUG() for invalid modes. These are all accurate reflections of the code\u2019s semantics without introducing contradictions or irrelevant details. Almost every claim aligns closely with the source logic, showing high precision.",
                "The summary correctly states that the function configures timing parameters based on mode (protocol) and input values, clamps them within limits, updates related fields, and triggers a system bug on invalid mode, which aligns with the core purpose of initializing RPC timeout values for NFS using mode-specific logic. However, it lacks important secondary details such as handling TCP vs UDP differently, setting retries when unspecified, assigning exponential behavior for UDP, and computing max values based on increments for TCP. These omissions reduce coverage of critical branches and constants in the code.",
                "The summary correctly captures the core purpose of configuring timing parameters based on mode (TCP/UDP) and input values, the clamping within protocol-specific limits, updates to related fields, and the BUG() call on invalid mode. All claims are accurate\u2014no contradictions or irrelevant noise\u2014and they reflect the main semantics. However, the description is high-level and lacks specifics such as the exact defaults for retries and timeouts or the distinction in increment/exponential behavior between TCP and UDP, so the gain is moderate rather than high."
            ]
        },
        "comment": {
            "summary": "Initializes timeout values for NFS RPC transport depending on the protocol type, setting retries, initial timeout, and limits accordingly.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary accurately captures the core function behavior: it initializes timeout values for NFS RPC transport based on protocol type, configuring retries, initial timeout, and limits. While it omits specific constants, calculations, and some conditional logic, the claims made are aligned with the source code and free of errors, reflecting a high proportion of accurate statements.",
                "The summary accurately states that the function initializes timeout values for NFS RPC transport based on protocol type and sets retries, initial timeout, and limits, which matches the core purpose of configuring RPC timeout parameters for TCP and UDP. However, it lacks detail on protocol-specific behaviors such as exponential backoff for UDP, TCP increment and max value calculations, and conditional default values. These omissions mean secondary coverage is minimal despite correctly covering the core action.",
                "The summary correctly identifies the primary purpose\u2014initializing timeout values for NFS RPC transport based on protocol type\u2014and notes retries, initial timeout, and limits, which matches the code\u2019s core behavior for TCP and UDP cases. However, it is generic and lacks mention of specific values, conditional handling, and protocol-specific differences such as increments, exponential growth flag, and max value clamping, leading to low informational gain. There are no inaccurate or contradictory claims, so no FATAL issues are present, but the gain is low due to broadness."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4222432,
    "strip_function_name": "sub_406DE0",
    "strip_decompiled_code": "int __fastcall sub_406DE0(FILE *stream, unsigned __int64 a2)\n{\n  int result; // eax\n  unsigned __int64 v3; // rbx\n  __int64 v4; // rbp\n  unsigned __int64 v5; // rax\n  int v6; // eax\n  unsigned __int64 v7; // rbp\n  unsigned __int64 v8[517]; // [rsp+0h] [rbp-1028h] BYREF\n\n  result = 0;\n  if ( a2 )\n  {\n    v3 = a2;\n    v4 = sub_4073A0();\n    if ( v4 )\n    {\n      while ( 1 )\n      {\n        if ( sub_405D60(stream, v8) )\n        {\n          v5 = v8[0];\n          if ( v8[0] )\n          {\n            if ( v8[0] > v3 )\n              v5 = v3;\n            stream->_IO_read_ptr += v5;\n            v3 -= v5;\n            if ( !v3 )\n              return 0;\n            v4 -= v5;\n            if ( !v4 )\n              goto LABEL_16;\n          }\n        }\n        if ( fgetc(stream) == -1 )\n          return -(ferror(stream) != 0);\n        if ( !--v3 )\n          return 0;\n        if ( !--v4 )\n          goto LABEL_16;\n      }\n    }\n    else\n    {\nLABEL_16:\n      v6 = fileno(stream);\n      if ( v6 < 0 || lseek(v6, 0LL, 1) < 0 )\n      {\n        while ( 1 )\n        {\n          v7 = 4096LL;\n          if ( v3 <= 0x1000 )\n            v7 = v3;\n          if ( v7 > __fread_chk() )\n            break;\n          v3 -= v7;\n          if ( !v3 )\n            return 0;\n        }\n        return -(ferror(stream) != 0);\n      }\n      else\n      {\n        return sub_405D90(stream, v3, 1);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "freadseek",
    "decompiled_code": "int __fastcall freadseek(FILE *a1, unsigned __int64 a2)\n{\n  int result; // eax\n  unsigned __int64 v3; // rbx\n  size_t v4; // rbp\n  size_t v5; // rax\n  int v6; // eax\n  unsigned __int64 v7; // rbp\n  size_t buf[517]; // [rsp+0h] [rbp-1028h] BYREF\n\n  result = 0;\n  if ( a2 )\n  {\n    v3 = a2;\n    v4 = freadahead(a1);\n    if ( v4 )\n    {\n      while ( 1 )\n      {\n        if ( freadptr(a1, buf) )\n        {\n          v5 = buf[0];\n          if ( buf[0] )\n          {\n            if ( buf[0] > v3 )\n              v5 = v3;\n            a1->_IO_read_ptr += v5;\n            v3 -= v5;\n            if ( !v3 )\n              return 0;\n            v4 -= v5;\n            if ( !v4 )\n              goto LABEL_16;\n          }\n        }\n        if ( fgetc(a1) == -1 )\n          return -(ferror(a1) != 0);\n        if ( !--v3 )\n          return 0;\n        if ( !--v4 )\n          goto LABEL_16;\n      }\n    }\n    else\n    {\nLABEL_16:\n      v6 = fileno(a1);\n      if ( v6 < 0 || lseek(v6, 0LL, 1) < 0 )\n      {\n        while ( 1 )\n        {\n          v7 = 4096LL;\n          if ( v3 <= 0x1000 )\n            v7 = v3;\n          if ( v7 > __fread_chk() )\n            break;\n          v3 -= v7;\n          if ( !v3 )\n            return 0;\n        }\n        return -(ferror(a1) != 0);\n      }\n      else\n      {\n        return rpl_fseeko(a1, v3, 1);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint\nfreadseek (FILE *fp, size_t offset)\n{\n  size_t total_buffered;\n  int fd;\n\n  if (offset == 0)\n    return 0;\n\n  /* Seek over the already read and buffered input as quickly as possible,\n     without doing any system calls.  */\n  total_buffered = freadahead (fp);\n  /* This loop is usually executed at most twice: once for ungetc buffer (if\n     present) and once for the main buffer.  */\n  while (total_buffered > 0)\n    {\n      size_t buffered;\n\n      if (freadptr (fp, &buffered) != NULL && buffered > 0)\n        {\n          size_t increment = (buffered < offset ? buffered : offset);\n\n          freadptrinc (fp, increment);\n          offset -= increment;\n          if (offset == 0)\n            return 0;\n          total_buffered -= increment;\n          if (total_buffered == 0)\n            break;\n        }\n      /* Read one byte.  If we were reading from the ungetc buffer, this\n         switches the stream back to the main buffer.  */\n      if (fgetc (fp) == EOF)\n        goto eof;\n      offset--;\n      if (offset == 0)\n        return 0;\n      total_buffered--;\n    }\n\n  /* Test whether the stream is seekable or not.  */\n  fd = fileno (fp);\n  if (fd >= 0 && lseek (fd, 0, SEEK_CUR) >= 0)\n    {\n      /* FP refers to a regular file.  fseek is most efficient in this case.  */\n      return fseeko (fp, offset, SEEK_CUR);\n    }\n  else\n    {\n      /* FP is a non-seekable stream, possibly not even referring to a file\n         descriptor.  Read OFFSET bytes explicitly and discard them.  */\n      char buf[4096];\n\n      do\n        {\n          size_t count = (sizeof (buf) < offset ? sizeof (buf) : offset);\n          if (fread (buf, 1, count, fp) < count)\n            goto eof;\n          offset -= count;\n        }\n      while (offset > 0);\n\n      return 0;\n   }\n\n eof:\n  /* EOF, or error before or while reading.  */\n  if (ferror (fp))\n    return EOF;\n  else\n    /* Encountered EOF.  */\n    return 0;\n}",
    "comment": "The function efficiently skips a specified number of bytes in a FILE stream, handling buffered input and seeking on regular files when possible.",
    "hext5_sum": "| copy input file to output file, while encoding it. | '",
    "bint5_sum": "Reads a specified number of bytes from a file stream into a buffer , handling EOF and end-of-file conditions appropriately .\n",
    "cpbcs_sum": "Reads data from a file stream into a buffer, handling both buffered and binary formats while returning the number of bytes read.\n",
    "misum_sum": "Reads the contents of a file stream into a buffer, adjusting for zero if necessary, while handling specific error conditions.\n",
    "decom_sum": "Skips a specified number of bytes from a FILE stream using buffered reads, fgetc, or lseek, depending on buffer state and stream capabilities.",
    "cfg_sum": "Reads and discards a specified number of bytes from a FILE stream, using buffered or unbuffered methods, until completion or error.",
    "work_score": {
        "decom": {
            "summary": "Skips a specified number of bytes from a FILE stream using buffered reads, fgetc, or lseek, depending on buffer state and stream capabilities.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function skips a given number of bytes from a FILE stream and mentions the use of buffered reads, fgetc, and lseek, all of which are explicitly present in the source code. It aligns with the code's behavior that the method chosen depends on buffer state and whether the stream is seekable. No contradictory or irrelevant claims are present, making all statements accurate and grounded in the source.",
                "The summary accurately identifies the core purpose of the function as skipping a specified number of bytes from a FILE stream and mentions the methods involved (buffered reads, fgetc, lseek), which matches the code\u2019s branching logic. However, it omits important secondary behaviors such as the handling of ungetc buffer transitions, explicit discard reads for non-seekable streams, EOF and error checking, and the efficiency considerations described. Coverage of the core is strong, but secondary details are minimal.",
                "The summary correctly conveys the primary purpose of the function\u2014skipping a specified number of bytes from a FILE stream\u2014and accurately mentions the use of buffered reads, fgetc, or lseek based on buffer and stream conditions. It omits some implementation specifics like handling ungetc buffers, non-seekable streams via fread, and EOF/error behavior, but these omissions are moderate and do not contradict the source. There is low noise and no fatal inaccuracies, though the gain is limited by brevity."
            ]
        },
        "cfg": {
            "summary": "Reads and discards a specified number of bytes from a FILE stream, using buffered or unbuffered methods, until completion or error.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function reads and discards a specified number of bytes from a FILE stream and that it can use buffered or direct reading. These match the code\u2019s behavior of advancing through buffered input, performing fseek when possible, and reading/discarding bytes otherwise. However, it omits details like seeking for regular files and handling EOF cases, but does not introduce inaccuracies. Nearly all claims are accurate, making the precision high despite being somewhat generic.",
                "The summary accurately states that the function reads and discards a specified number of bytes from a FILE stream and distinguishes between buffered and unbuffered methods, which matches the core purpose of skipping bytes in the stream by efficiently consuming buffered data first, then using fseek or reading/discarding. However, it lacks secondary details such as handling seekable vs non-seekable streams, the use of fseeko for regular files, loop behavior specifics for buffers, and explicit EOF/error handling, making coverage of critical branches incomplete.",
                "The summary correctly states that the function reads and discards a specified number of bytes from a FILE stream, which matches its core purpose. It also correctly notes that the process can involve buffered and unbuffered methods. However, it omits important specific behaviors such as skipping already buffered data without system calls, special handling for seekable files using fseeko, and explicit error/EFO return values. The claims present are accurate but generic, providing low informational gain and minimal engineering acceleration. No inaccurate or fatal claims are present, but the lack of detail limits usefulness."
            ]
        },
        "comment": {
            "summary": "The function efficiently skips a specified number of bytes in a FILE stream, handling buffered input and seeking on regular files when possible.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function skips a specified number of bytes in a FILE stream and that it handles buffered input and seeks on regular files when possible. Both claims match the observed semantics in the source code: the implementation first advances through buffered data, then uses fseeko for regular files, and otherwise reads and discards bytes. No inaccurate or irrelevant claims are present, so the precision of fact-based content is high.",
                "The summary correctly identifies the core purpose of skipping a specified number of bytes in a FILE stream and mentions efficiency via buffered input and using seek on regular files. This matches the core domain action and part of the implementation detail. However, it omits important secondary behaviors such as handling non-seekable streams by reading and discarding data, the offset-zero early return, and EOF/error handling, resulting in incomplete coverage of critical branches and side effects.",
                "The summary correctly states that the function skips a specified number of bytes in a FILE stream and mentions its efficiency via buffered input and seeking on regular files when possible. These are accurate reflections of the source code's primary purpose and behavior. However, the summary is broad and omits specific details such as handling ungetc buffers, non-seekable streams, and EOF/error conditions, which reduces its informational gain. There is no inaccurate or contradictory claim, but the coverage is limited and generic."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 821280,
    "strip_function_name": "sub_C8820",
    "strip_decompiled_code": "char **__fastcall sub_C8820(char *s, const char *a2, int a3, int a4)\n{\n  char **v6; // rax\n  char **v7; // rbx\n  char *v8; // rax\n  char *v9; // rbp\n  size_t v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  unsigned int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n\n  v6 = (char **)malloc(0x1E8uLL);\n  if ( !v6 )\n  {\nLABEL_7:\n    v14 = (unsigned int)dcgettext(0LL, \"allocation of xzfile connection failed\", 5);\n    Rf_error(v14, (unsigned int)\"allocation of xzfile connection failed\", v15, v16, v17, v18);\n  }\n  v7 = v6;\n  v8 = (char *)malloc(7uLL);\n  v9 = v8;\n  *v7 = v8;\n  if ( !v8 )\n  {\nLABEL_6:\n    free(v7);\n    goto LABEL_7;\n  }\n  strcpy(v8, \"xzfile\");\n  v10 = strlen(s);\n  v11 = (char *)malloc(v10 + 1);\n  v7[1] = v11;\n  if ( !v11 )\n  {\n    free(v9);\n    goto LABEL_6;\n  }\n  Rf_init_con((__int64)v7, s, 0, a2);\n  *((_DWORD *)v7 + 12) = 0;\n  v7[8] = (char *)sub_C7D20;\n  v7[9] = (char *)sub_C4BF0;\n  v7[11] = (char *)dummy_vfprintf;\n  v7[13] = (char *)sub_C4B90;\n  v7[12] = (char *)dummy_fgetc;\n  v7[14] = (char *)sub_C2950;\n  v7[16] = (char *)sub_C2740;\n  v7[17] = (char *)sub_C4A30;\n  v7[18] = (char *)sub_C4920;\n  v12 = (char *)calloc(0x2840uLL, 1uLL);\n  v7[55] = v12;\n  *((_DWORD *)v12 + 38) = a3;\n  *((_DWORD *)v12 + 37) = a4;\n  return v7;\n}\n",
    "function_name": "newxzfile",
    "decompiled_code": "char **__fastcall newxzfile(\n        char *s,\n        const char *a2,\n        int a3,\n        int a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        __m128 a8,\n        double a9,\n        double a10,\n        __m128 a11,\n        __m128 a12)\n{\n  char **v14; // rax\n  char **v15; // rbx\n  char *v16; // rax\n  char *v17; // rbp\n  size_t v18; // rax\n  char *v19; // rax\n  char *v20; // rax\n  unsigned int v22; // eax\n  __int64 v23; // rdx\n  __int64 v24; // rcx\n  __int64 v25; // r8\n  __int64 v26; // r9\n  __m128 v27; // xmm4\n  __m128 v28; // xmm5\n\n  v14 = (char **)malloc(0x1E8uLL);\n  if ( !v14 )\n  {\nLABEL_7:\n    v22 = (unsigned int)dcgettext(0LL, \"allocation of xzfile connection failed\", 5);\n    Rf_error(\n      v22,\n      (__int64)\"allocation of xzfile connection failed\",\n      v23,\n      v24,\n      v25,\n      v26,\n      a5,\n      a6,\n      a7,\n      a8,\n      v27,\n      v28,\n      a11,\n      a12);\n  }\n  v15 = v14;\n  v16 = (char *)malloc(7uLL);\n  v17 = v16;\n  *v15 = v16;\n  if ( !v16 )\n  {\nLABEL_6:\n    free(v15);\n    goto LABEL_7;\n  }\n  strcpy(v16, \"xzfile\");\n  v18 = strlen(s);\n  v19 = (char *)malloc(v18 + 1);\n  v15[1] = v19;\n  if ( !v19 )\n  {\n    free(v17);\n    goto LABEL_6;\n  }\n  Rf_init_con((__int64)v15, s, 0, a2);\n  *((_DWORD *)v15 + 12) = 0;\n  v15[8] = (char *)xzfile_open;\n  v15[9] = (char *)xzfile_close;\n  v15[11] = (char *)dummy_vfprintf;\n  v15[13] = (char *)xzfile_fgetc_internal;\n  v15[12] = (char *)dummy_fgetc;\n  v15[14] = (char *)null_seek;\n  v15[16] = (char *)null_fflush;\n  v15[17] = (char *)xzfile_read;\n  v15[18] = (char *)xzfile_write;\n  v20 = (char *)calloc(0x2840uLL, 1uLL);\n  v15[55] = v20;\n  *((_DWORD *)v20 + 38) = a3;\n  *((_DWORD *)v20 + 37) = a4;\n  return v15;\n}\n",
    "source_code": "\nstatic Rconnection\nnewxzfile(const char *description, const char *mode, int type, int compress)\n{\n    Rconnection new;\n    new = (Rconnection) malloc(sizeof(struct Rconn));\n    if(!new) error(_(\"allocation of xzfile connection failed\"));\n    new->class = (char *) malloc(strlen(\"xzfile\") + 1);\n    if(!new->class) {\n\tfree(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    strcpy(new->class, \"xzfile\");\n    new->description = (char *) malloc(strlen(description) + 1);\n    if(!new->description) {\n\tfree(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    init_con(new, description, CE_NATIVE, mode);\n\n    new->canseek = FALSE;\n    new->open = &xzfile_open;\n    new->close = &xzfile_close;\n    new->vfprintf = &dummy_vfprintf;\n    new->fgetc_internal = &xzfile_fgetc_internal;\n    new->fgetc = &dummy_fgetc;\n    new->seek = &null_seek;\n    new->fflush = &null_fflush;\n    new->read = &xzfile_read;\n    new->write = &xzfile_write;\n    new->private = (void *) malloc(sizeof(struct xzfileconn));\n    memset(new->private, 0, sizeof(struct xzfileconn));\n    if(!new->private) {\n\tfree(new->description); free(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    ((Rxzfileconn) new->private)->type = type;\n    ((Rxzfileconn) new->private)->compress = compress;\n    return new;\n}",
    "comment": "Allocates and initializes a new xzfile connection, setting its properties and handling memory for class, description, and private data structures.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Creates and initializes an xzfile connection with specified description , mode , and compression level , allocating necessary resources .\n",
    "cpbcs_sum": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
    "misum_sum": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
    "decom_sum": "Initializes an xzfile connection structure, sets function pointers, and allocates buffers with specified parameters for compressed file I/O operations.",
    "cfg_sum": "Initializes an xzfile connection structure, assigns function pointers, copies parameters, and handles allocation errors with resource cleanup and R error reporting.",
    "work_score": {
        "decom": {
            "summary": "Initializes an xzfile connection structure, sets function pointers, and allocates buffers with specified parameters for compressed file I/O operations.",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function initializes an xzfile connection and sets function pointers, which matches the source code. It also notes allocation with parameters 'type' and 'compress', aligning with the code's handling. However, the term 'allocates buffers' is slightly imprecise since the code allocates structured memory rather than generic buffers, and 'for compressed file I/O operations' is an inferred purpose not explicitly stated in the code. Overall, most claims are accurate, with minor speculative phrasing.",
                "The summary correctly identifies that the function initializes an xzfile connection structure and sets function pointers, which aligns with the source code\u2019s primary purpose. It also notes allocation of buffers and mentions compressed file I/O, which is consistent with the type/compress parameters. However, it omits important secondary details such as multiple error checks, specific initialization of private data structures, disabling seeking, and assigning null/dummy functions. Coverage of the core is present but secondary behavioral aspects are only partially captured.",
                "The summary accurately conveys the primary purpose of the function by stating it initializes an xzfile connection and sets function pointers, which matches the source code. However, it incorrectly mentions allocating buffers, whereas the code allocates specific struct members for connection metadata and internal state, not generic I/O buffers. While this is minor noise rather than a fatal error, the description is otherwise generic and low-detail, providing limited insight into specific behavior such as error handling paths and the absence of seeking. The net gain is modest with no severe inaccuracies."
            ]
        },
        "cfg": {
            "summary": "Initializes an xzfile connection structure, assigns function pointers, copies parameters, and handles allocation errors with resource cleanup and R error reporting.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function initializes an xzfile connection structure, assigns function pointers, copies parameters, and handles allocation errors with cleanup and R error reporting \u2014 all of which are evident in the source code. It omits minor implementation specifics but all claims are accurate and grounded in the code\u2019s behavior, resulting in a very high proportion of accurate claims.",
                "The summary correctly identifies the core purpose as initializing an xzfile connection structure, along with accurate secondary details such as assigning function pointers, copying parameters, and handling allocation errors via cleanup and R error reporting. These align with the source code\u2019s semantics, including setup of members and error handling. However, it omits some specifics like setting canseek to FALSE, initializing with init_con, zeroing private data, and setting type and compress fields, so coverage of secondary behaviors is decent but incomplete.",
                "The summary correctly states the primary purpose of initializing an xzfile connection, assigning function pointers, copying parameters, and handling allocation errors with cleanup and R error reporting, all of which are evident in the source code. It does not introduce inaccuracies or irrelevant noise, but it provides only a generic overview without mentioning specific functions assigned, the struct types used, or the detailed allocation sequence, resulting in low informational gain."
            ]
        },
        "comment": {
            "summary": "Allocates and initializes a new xzfile connection, setting its properties and handling memory for class, description, and private data structures.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly captures the core behavior of the function, which allocates and initializes a new xzfile connection, sets various properties, and manages memory for the class, description, and private data structures. While it omits finer details like error handling conditions and specific function pointers being set, all stated claims align with the source code, making them accurate and relevant.",
                "The summary accurately states that the function allocates and initializes an xzfile connection and handles memory for class, description, and private data structures, which matches the core purpose of creating and configuring an xzfile connection object. However, it lacks specificity about critical secondary details such as setting function pointers for operations, initialization via init_con with specific arguments, error handling for allocation failures, and assignment of type and compression fields. This results in incomplete coverage of key behavior-critical semantics present in the source code.",
                "The summary correctly captures the core function: allocating and initializing a new xzfile connection and setting its properties, including memory handling for class, description, and private data structures. All claims are accurate, with no contradictions to the source code. While the claims are correct and target the primary purpose, they are somewhat generic and omit specific details like assignment of function pointers and error handling flow, limiting their informational value. There is no noise or fatal error, but the gain is moderate due to lack of specificity."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1108176,
    "strip_function_name": "gsl_multifit_linear_applyW",
    "strip_decompiled_code": "__int64 __fastcall gsl_multifit_linear_applyW(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)\n{\n  __int64 v5; // rbp\n  __int64 i; // r12\n  double v9; // xmm1_8\n  double *v10; // rbx\n  _QWORD *v12; // [rsp+0h] [rbp-78h]\n  double x; // [rsp+8h] [rbp-70h]\n  _BYTE v14[104]; // [rsp+10h] [rbp-68h] BYREF\n\n  v5 = *a3;\n  if ( *a3 == *a1 )\n  {\n    if ( a2 && v5 != *a2 )\n    {\n      gsl_error(\"weight vector does not match X\", \"multireg.c\", 90LL, 19LL);\n      return 19LL;\n    }\n    else if ( v5 == *a4 && a4[1] == a1[1] )\n    {\n      if ( v5 == *a5 )\n      {\n        if ( a1 != a4 )\n        {\n          v12 = a3;\n          gsl_matrix_memcpy(a4, a1);\n          a3 = v12;\n        }\n        if ( a3 != a5 )\n          gsl_vector_memcpy(a5, a3);\n        if ( a2 && v5 )\n        {\n          for ( i = 0LL; i != v5; ++i )\n          {\n            x = *(double *)(a2[2] + i * 8LL * a2[1]);\n            gsl_matrix_row(v14, a4, i);\n            v9 = 0.0;\n            v10 = (double *)(a5[2] + i * 8LL * a5[1]);\n            if ( x >= 0.0 )\n              v9 = sqrt(x);\n            gsl_vector_scale(v14, v9);\n            *v10 = v9 * *v10;\n          }\n        }\n        return 0LL;\n      }\n      else\n      {\n        gsl_error(\"Wy vector must be length n\", \"multireg.c\", 98LL, 19LL);\n        return 19LL;\n      }\n    }\n    else\n    {\n      gsl_error(\"WX matrix dimensions do not match X\", \"multireg.c\", 94LL, 19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    gsl_error(\"y vector does not match X\", \"multireg.c\", 86LL, 19LL);\n    return 19LL;\n  }\n}\n",
    "function_name": "gsl_multifit_linear_applyW",
    "decompiled_code": "__int64 __fastcall gsl_multifit_linear_applyW(\n        const gsl_matrix *X,\n        _QWORD *a2,\n        const gsl_vector *y,\n        const gsl_matrix *a4,\n        const gsl_vector *a5,\n        __int64 a6,\n        __int64 a7,\n        __int64 a8)\n{\n  size_t size; // rbp\n  __int64 v11; // r12\n  double v12; // xmm1_8\n  double *v13; // rbx\n  const gsl_vector *retaddr; // [rsp+78h] [rbp+0h]\n  double v16; // [rsp+80h] [rbp+8h]\n\n  size = y->size;\n  if ( y->size == X->size1 )\n  {\n    if ( a2 && size != *a2 )\n    {\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"weight vector does not match X\",\n        \"multireg.c\",\n        90LL,\n        19LL);\n      return 19LL;\n    }\n    else if ( size == a4->size1 && a4->size2 == X->size2 )\n    {\n      if ( size == a5->size )\n      {\n        if ( X != a4 )\n        {\n          retaddr = y;\n          ((void (__fastcall *)(const gsl_matrix *, const gsl_matrix *))gsl_matrix_memcpy)(a4, X);\n          y = retaddr;\n        }\n        if ( y != a5 )\n          ((void (__fastcall *)(const gsl_vector *, const gsl_vector *))gsl_vector_memcpy)(a5, y);\n        if ( a2 && size )\n        {\n          v11 = 0LL;\n          retaddr = (const gsl_vector *)&a8;\n          do\n          {\n            v16 = *(double *)(a2[2] + v11 * 8LL * a2[1]);\n            ((void (__fastcall *)(const gsl_vector *, const gsl_matrix *, __int64))gsl_matrix_row)(retaddr, a4, v11);\n            v12 = 0.0;\n            v13 = (double *)((char *)a5->data + v11 * 8 * a5->stride);\n            if ( v16 >= 0.0 )\n              v12 = sqrt(v16);\n            ++v11;\n            ((void (__fastcall *)(const gsl_vector *, double))gsl_vector_scale)(retaddr, v12);\n            *v13 = v12 * *v13;\n          }\n          while ( size != v11 );\n        }\n        return 0LL;\n      }\n      else\n      {\n        ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n          \"Wy vector must be length n\",\n          \"multireg.c\",\n          98LL,\n          19LL);\n        return 19LL;\n      }\n    }\n    else\n    {\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"WX matrix dimensions do not match X\",\n        \"multireg.c\",\n        94LL,\n        19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"y vector does not match X\",\n      \"multireg.c\",\n      86LL,\n      19LL);\n    return 19LL;\n  }\n}\n",
    "source_code": "\nint\ngsl_multifit_linear_applyW(const gsl_matrix * X,\n                           const gsl_vector * w,\n                           const gsl_vector * y,\n                           gsl_matrix * WX,\n                           gsl_vector * Wy)\n{\n  const size_t n = X->size1;\n  const size_t p = X->size2;\n\n  if (n != y->size)\n    {\n      GSL_ERROR(\"y vector does not match X\", GSL_EBADLEN);\n    }\n  else if (w != NULL && n != w->size)\n    {\n      GSL_ERROR(\"weight vector does not match X\", GSL_EBADLEN);\n    }\n  else if (n != WX->size1 || p != WX->size2)\n    {\n      GSL_ERROR(\"WX matrix dimensions do not match X\", GSL_EBADLEN);\n    }\n  else if (n != Wy->size)\n    {\n      GSL_ERROR(\"Wy vector must be length n\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i;\n\n      /* copy WX = X; Wy = y if distinct pointers */\n      if (WX != X)\n        gsl_matrix_memcpy(WX, X);\n      if (Wy != y)\n        gsl_vector_memcpy(Wy, y);\n\n      if (w != NULL)\n        {\n          /* construct WX = sqrt(W) X and Wy = sqrt(W) y */\n          for (i = 0; i < n; ++i)\n            {\n              double wi = gsl_vector_get(w, i);\n              double swi;\n              gsl_vector_view row = gsl_matrix_row(WX, i);\n              double *yi = gsl_vector_ptr(Wy, i);\n\n              if (wi < 0.0)\n                wi = 0.0;\n\n              swi = sqrt(wi);\n              gsl_vector_scale(&row.vector, swi);\n              *yi *= swi;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "comment": "Applies weighted transformations to input matrix X and vector y, storing results in WX and Wy, respectively, while handling potential dimension mismatches.",
    "hext5_sum": "apply weight matrix to (x,y) ls system inputs: x - least squares matrix n-by-p w - weight vector n-by-1 or null for w = i y - right hand side n-by-1 wx - (output) sqrt(w) x, n-by-p wy - (output) sqrt(w) y, n-by-1 notes: 1) if w = null, on output wx = x and wy = y 2) it is allowed for wx = x and wy = y for in-place transform",
    "bint5_sum": "Applies a weighted least squares fitting step to the input vector X , updating the solution vector Y based on the computed weight .\n",
    "cpbcs_sum": "Solves a linear system using singular value decomposition with provided L and V, singular values from the input vector x.\n",
    "misum_sum": "Calculates the generalized cross-validation (GCV) curve values for a linear model using its index and a permutation, storing the result in vector x.\n",
    "decom_sum": "Validates dimensions of input matrices/vectors and applies weight vector scaling to X and y using GSL matrix/vector operations.",
    "cfg_sum": "Validates vector and matrix dimension compatibility for weighted linear regression, copies data, scales rows by weight factors, and reports detailed errors on mismatches.",
    "work_score": {
        "decom": {
            "summary": "Validates dimensions of input matrices/vectors and applies weight vector scaling to X and y using GSL matrix/vector operations.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly captures the core functionality: the function validates the dimensions of the input matrices and vectors and applies weight vector scaling to X and y using GSL operations. These claims are specific to the source code behavior and match its implementation. There are no contradictory or irrelevant statements, and all extracted claims align with the code's semantics, indicating high accuracy.",
                "The summary accurately reflects the core purpose: checking dimensions and applying weighted scaling to X and y, which matches the function\u2019s main domain-specific behavior. It also notes the use of GSL operations, which is correct. However, it omits secondary details such as the handling of NULL weight vectors, copying when pointers differ, clamping negative weight values to zero, and explicit error conditions returned when dimensions mismatch. These omissions limit completeness.",
                "The summary correctly states that the function checks dimensions of the inputs and applies weight scaling to X and y using GSL operations, which aligns with the code's behavior. It omits details like handling NULL weights, copying when pointers differ, and treating negative weights as zero, but these omissions do not contradict the source. The claims are accurate yet fairly generic, providing low informational gain without introducing noise or fatal errors."
            ]
        },
        "cfg": {
            "summary": "Validates vector and matrix dimension compatibility for weighted linear regression, copies data, scales rows by weight factors, and reports detailed errors on mismatches.",
            "score": [
                1.0,
                0.8,
                0.9
            ],
            "reason": [
                "The summary correctly identifies that the function validates vector and matrix dimensions, copies data, scales rows by weight factors, and reports errors on mismatches, all of which match the source code behavior for weighted linear regression data preparation. Each claim is accurate and directly supported by the implementation, with no contradictory or irrelevant statements.",
                "The summary correctly identifies the core purpose as preparing matrices and vectors for weighted linear regression by validating dimensions, copying data, and scaling rows with weight factors, which aligns with the source code\u2019s construction of WX = sqrt(W) X and Wy = sqrt(W) y. It also notes detailed error reporting on mismatches, matching the multiple GSL_ERROR checks. However, it omits minor specifics such as handling NULL weight vector cases, setting negative weights to zero, and performing copies only when pointers differ. Overall, coverage of the primary purpose is strong with decent secondary detail but not exhaustive.",
                "The summary correctly captures the core functionality: checking matrix/vector dimension compatibility, copying input data to output when pointers differ, scaling rows by weight factors, and reporting errors when mismatches occur. All claims are accurate and specific to the source code, with no contradictory or off-topic statements. The description provides clear, high-value insight into the primary purpose and key I/O behavior with minimal noise."
            ]
        },
        "comment": {
            "summary": "Applies weighted transformations to input matrix X and vector y, storing results in WX and Wy, respectively, while handling potential dimension mismatches.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function applies weighted transformations to X and y, storing results in WX and Wy, and it notes the handling of dimension mismatches, which matches the code\u2019s validation checks. However, it omits important specifics: the transformation only occurs if w is provided, weights are square-rooted and applied element-wise, and negative weights are reset to 0. While accurate in broad strokes, the lack of these details reduces precision but does not introduce inaccuracies, so the majority of claims are still accurate though somewhat generic.",
                "The summary accurately captures the core purpose of applying weights to X and y and placing results into WX and Wy, and notes dimension mismatch handling. It omits some implementation specifics like copying when pointers differ, zeroing negative weights, and scaling by the square root of weights, but the core weighted transformation and dimension-checking behavior are clearly reflected.",
                "The summary correctly states the primary purpose of applying weighted transformations to X and y, and notes handling of dimension mismatches, which matches the code's logic. However, it omits specific details such as conditional behavior when pointers differ, the use of sqrt(w) for scaling, and the handling of NULL weights. These omissions mean the gain is moderate with no inaccurate claims present, resulting in limited but accurate coverage."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 1837504,
    "strip_function_name": "sub_1C09C0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_1C09C0(\n        __int64 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  int v9; // edx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // [rsp+8h] [rbp-130h] BYREF\n  char s[128]; // [rsp+10h] [rbp-128h] BYREF\n  char addr[136]; // [rsp+90h] [rbp-A8h] BYREF\n  unsigned __int64 v23; // [rsp+118h] [rbp-20h]\n\n  v9 = *(_DWORD *)(a1 + 8);\n  v23 = __readfsqword(0x28u);\n  switch ( v9 )\n  {\n    case 2:\n      (*(void (__fastcall **)(__int64, __int64 *, __int64, _QWORD))(a1 + 24))(a1, &v20, 8LL, 0LL);\n      break;\n    case 3:\n      *(double *)a2.m128_u64 = (*(double (__fastcall **)(__int64, char *, __int64, _QWORD))(a1 + 24))(\n                                 a1,\n                                 addr,\n                                 8LL,\n                                 0LL);\n      sub_1B2D70(addr, a2, a3, a4, a5, v11, v12, a8, a9);\n      break;\n    case 1:\n      sub_1C0900(a1, (__int64)s, a2, a3, a4, a5, a6, a7, a8, a9);\n      if ( sscanf(s, \"%127s\", addr) != 1\n        || strcmp(addr, \"NA\")\n        && strcmp(addr, \"NaN\")\n        && (a2 = (__m128)*(unsigned __int64 *)&R_PosInf, strcmp(addr, \"Inf\"))\n        && strcmp(addr, \"-Inf\")\n        && sscanf(addr, \"%lg\", &v20) != 1 )\n      {\n        v13 = (unsigned int)dcgettext(0LL, \"read error\", 5);\n        Rf_error(v13, (__int64)\"read error\", v14, v15, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9);\n      }\n      break;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "function_name": "InReal",
    "decompiled_code": "unsigned __int64 __fastcall InReal(\n        __int64 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  int v9; // edx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // [rsp+8h] [rbp-130h] BYREF\n  char s[128]; // [rsp+10h] [rbp-128h] BYREF\n  char addr[136]; // [rsp+90h] [rbp-A8h] BYREF\n  unsigned __int64 v23; // [rsp+118h] [rbp-20h]\n\n  v9 = *(_DWORD *)(a1 + 8);\n  v23 = __readfsqword(0x28u);\n  switch ( v9 )\n  {\n    case 2:\n      (*(void (__fastcall **)(__int64, __int64 *, __int64, _QWORD, double, double, double, double, double, double, double, double))(a1 + 24))(\n        a1,\n        &v20,\n        8LL,\n        0LL,\n        *(double *)a2.m128_u64,\n        *(double *)a3.m128_u64,\n        *(double *)a4.m128_u64,\n        *(double *)a5.m128_u64,\n        a6,\n        a7,\n        *(double *)a8.m128_u64,\n        *(double *)a9.m128_u64);\n      break;\n    case 3:\n      *(double *)a2.m128_u64 = (*(double (__fastcall **)(__int64, char *, __int64, _QWORD, double, double, double, double, double, double, double, double))(a1 + 24))(\n                                 a1,\n                                 addr,\n                                 8LL,\n                                 0LL,\n                                 *(double *)a2.m128_u64,\n                                 *(double *)a3.m128_u64,\n                                 *(double *)a4.m128_u64,\n                                 *(double *)a5.m128_u64,\n                                 a6,\n                                 a7,\n                                 *(double *)a8.m128_u64,\n                                 *(double *)a9.m128_u64);\n      R_XDRDecodeDouble(addr, a2, a3, a4, a5, v11, v12, a8, a9);\n      break;\n    case 1:\n      InWord_constprop_30(a1, (__int64)s, a2, a3, a4, a5, a6, a7, a8, a9);\n      if ( sscanf(s, \"%127s\", addr) != 1\n        || strcmp(addr, \"NA\")\n        && strcmp(addr, \"NaN\")\n        && (a2 = (__m128)*(unsigned __int64 *)&R_PosInf, strcmp(addr, \"Inf\"))\n        && strcmp(addr, \"-Inf\")\n        && sscanf(addr, \"%lg\", &v20) != 1 )\n      {\n        v13 = (unsigned int)dcgettext(0LL, \"read error\", 5);\n        Rf_error(v13, (__int64)\"read error\", v14, v15, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9);\n      }\n      break;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "source_code": "\nstatic double InReal(R_inpstream_t stream)\n{\n    char word[128];\n    char buf[128];\n    double d;\n\n    switch (stream->type) {\n    case R_pstream_ascii_format:\n\tInWord(stream, word, sizeof(word));\n\tif(sscanf(word, \"%127s\", buf) != 1) error(_(\"read error\"));\n\tif (strcmp(buf, \"NA\") == 0)\n\t    return NA_REAL;\n\telse if (strcmp(buf, \"NaN\") == 0)\n\t    return R_NaN;\n\telse if (strcmp(buf, \"Inf\") == 0)\n\t    return R_PosInf;\n\telse if (strcmp(buf, \"-Inf\") == 0)\n\t    return R_NegInf;\n\telse\n\t    if(\n#ifdef Win32\n\t\ttrio_sscanf(buf, \"%lg\", &d)\n#else\n\t\tsscanf(buf, \"%lg\", &d)\n#endif\n\t\t!= 1) error(_(\"read error\"));\n\treturn d;\n    case R_pstream_binary_format:\n\tstream->InBytes(stream, &d, sizeof(double));\n\treturn d;\n    case R_pstream_xdr_format:\n\tstream->InBytes(stream, buf, R_XDR_DOUBLE_SIZE);\n\treturn R_XDRDecodeDouble(buf);\n    default:\n\treturn NA_REAL;\n    }\n}",
    "comment": "Reads a double value from a specified input stream format (ASCII, binary, or XDR) and handles special cases like NA, NaN, and infinity.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reads an integer from a given input stream in ASCII , binary , or XDR format , returning NA_INTEGER for `` NA '' or on error .\n",
    "cpbcs_sum": "Reads a string from a file, handling special cases for \"NA\" and MPFR floats based on the read parameter.\n",
    "misum_sum": "Reads a double from a connection, handling special cases like integers, and MPFR floats differently and replacing invalid ones on error.\n",
    "decom_sum": "Parses numeric or special string values from input, validates against \"NA\"/\"NaN\"/\"Inf\" cases, and reports a localized \"read error\" on invalid data.",
    "cfg_sum": "Parses formatted input into numeric values with special-case string handling, performs callbacks for specific modes, and raises a localized error on invalid data.",
    "work_score": {
        "decom": {
            "summary": "Parses numeric or special string values from input, validates against \"NA\"/\"NaN\"/\"Inf\" cases, and reports a localized \"read error\" on invalid data.",
            "score": [
                0.8,
                0.4,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function parses numeric or special string values from input, handles special cases for NA, NaN, and Inf variants, and reports a localized read error on invalid data. These behaviors are explicitly implemented in the ASCII format branch of the source code. However, it omits mention of handling binary and XDR formats, which are important domain-semantic behaviors reflected in the code, slightly reducing completeness. Most claims are accurate, with minor incompleteness.",
                "The summary accurately mentions parsing numeric or special string values, handling \"NA\"/\"NaN\"/\"Inf\", and producing a localized read error for invalid input, which aligns with behaviors in the ASCII format branch. However, it omits the core purpose of reading a double value from different stream types, including binary and XDR formats, and does not cover other branches, constants like R_PosInf/R_NegInf, or fallback behavior for unsupported formats. As the core is only partially covered and secondary coverage is minimal, the alignment is limited.",
                "The summary captures part of the function\u2019s purpose for ASCII input\u2014parsing numeric and special values like \"NA\", \"NaN\", and infinities, and reporting a localized read error on invalid data\u2014which is accurate for one branch of the switch. However, it omits other major behaviors, including handling binary and XDR formats, and always returning NA_REAL for unknown types. There are no factually wrong statements about the code, but the omission means coverage is incomplete, reducing usefulness. The gain from the accurate claims is low because they are generic and ignore substantial portions of the function\u2019s semantics."
            ]
        },
        "cfg": {
            "summary": "Parses formatted input into numeric values with special-case string handling, performs callbacks for specific modes, and raises a localized error on invalid data.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function parses formatted input into numeric values and handles special-case strings like 'NA', 'NaN', 'Inf', and '-Inf'. It correctly notes that errors are raised on invalid data, and acknowledges different modes (ASCII, binary, XDR), which matches the switch cases in the source code. The term 'callbacks' is slightly misleading since the function performs direct data reads rather than invoking external callback functions. Overall, over 80% of the claims align with the source code semantics, with only a minor inaccuracy.",
                "The summary accurately notes that the function parses formatted input into numeric values and handles special-case strings such as NA, NaN, and Inf, as well as raising a localized error on invalid input. This covers the core purpose of reading numeric data from the input stream with format-specific handling. However, it omits several important secondary details such as the presence of multiple stream formats (ASCII, binary, XDR), the handling of platform-specific parsing on Win32, and the mapping to constants like R_PosInf and R_NegInf. These omissions limit completeness despite correct coverage of the main action.",
                "The summary correctly captures that the function parses input into numeric values and handles special case strings (e.g., 'NA', 'NaN', infinities). It also notes mode-specific behavior through callbacks such as InBytes, and mentions localized error handling, all of which align with the source code. However, the summary is generic and omits specifics such as the distinct handling of ASCII, binary, and XDR formats, as well as the exact mapping of special strings to constants. No inaccurate or contradictory claims are present, but the lack of detailed enumeration limits the gain to moderate."
            ]
        },
        "comment": {
            "summary": "Reads a double value from a specified input stream format (ASCII, binary, or XDR) and handles special cases like NA, NaN, and infinity.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly describes that the function reads a double from an input stream and supports three formats (ASCII, binary, XDR) while handling special cases NA, NaN, and infinity. These elements match the source code's control flow and special-case handling. It omits minor implementation specifics but does not introduce inaccuracies, resulting in all claims being accurate.",
                "The summary accurately describes the core purpose of reading a double from various input stream formats and includes mention of handling special cases like NA, NaN, and infinity. This matches the core domain action and covers key branch behavior for ASCII input. However, it omits other secondary details such as error handling on failed parsing, use of platform-specific parsing functions, and default case behavior returning NA_REAL, resulting in incomplete coverage of non-core semantics.",
                "The summary correctly identifies that the function reads a double from multiple stream formats (ASCII, binary, XDR) and handles NA, NaN, and infinity cases, which matches the primary purpose and key conditional logic in the source code. It omits minor implementation details such as error handling when parsing fails, but contains no incorrect or irrelevant claims. The gain is moderate due to brevity and lack of specific decoding behavior, but noise is negligible."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581761552,
    "strip_function_name": "sub_FFFFFFFF812C8010",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812C8010(\n        _QWORD *a1,\n        __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        unsigned int a5,\n        int a6)\n{\n  __int64 v6; // rdx\n  _QWORD *v7; // rax\n  __int64 result; // rax\n  int v11; // ecx\n  int v12; // r8d\n  int v13; // r9d\n  _QWORD *v14; // rdx\n  __int64 v15; // rdx\n  int v16; // edx\n  int v17; // ecx\n  int v18; // r8d\n  int v19; // r9d\n\n  v6 = ((a2 + 0x160000000000LL) >> 6 << 12) + a3;\n  if ( a5 == 3 )\n    BUG();\n  v7 = (_QWORD *)a1[33];\n  if ( v7 && *v7 >= v6 + a4 - 1 && !dword_FFFFFFFF81E9B810 )\n    return v6;\n  result = sub_FFFFFFFF812C79B0((__int64)a1, qword_FFFFFFFF81E9B850, v6, a4, a5, a6);\n  if ( result == -1 )\n  {\n    LODWORD(v15) = -2120450907;\n    if ( a1 )\n    {\n      v15 = a1[10];\n      if ( !v15 )\n        v15 = a1[2];\n    }\n    sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819B4830, a4, v15, v11, v12, v13);\n    if ( a4 > 0x8000 )\n    {\n      switch ( a5 )\n      {\n        case 0u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA accessed\\n\", a4, v16, v17, v18, v19);\n        case 2u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA written\\n\", a4, v16, v17, v18, v19);\n        case 1u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA read\\n\", a4, v16, v17, v18, v19);\n      }\n    }\n    return qword_FFFFFFFF81E9B838;\n  }\n  v14 = (_QWORD *)a1[33];\n  if ( !v14 || result + a4 - 1 > *v14 )\n  {\n    sub_FFFFFFFF812C7C70((__int64)a1, result, a4, a5);\n    return qword_FFFFFFFF81E9B838;\n  }\n  return result;\n}\n",
    "function_name": "swiotlb_map_page",
    "decompiled_code": "__int64 __fastcall swiotlb_map_page(\n        _QWORD *a1,\n        __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        unsigned int a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  __int64 v13; // rdx\n  _QWORD *v14; // rax\n  __int64 result; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  _QWORD *v20; // rdx\n  char *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v13 = ((a2 + 0x160000000000LL) >> 6 << 12) + a3;\n  if ( a5 == 3 )\n    BUG();\n  v14 = (_QWORD *)a1[33];\n  if ( v14 && *v14 >= v13 + a4 - 1 && !swiotlb_force )\n    return v13;\n  result = swiotlb_tbl_map_single((__int64)a1, io_tlb_start, v13, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( result == -1 )\n  {\n    v21 = \"?\";\n    if ( a1 )\n    {\n      v21 = (char *)a1[10];\n      if ( !v21 )\n        v21 = (char *)a1[2];\n    }\n    printk((__int64)&unk_FFFFFFFF819B4830, a6, a7, a8, a9, v18, v19, a12, a13, a4, v21);\n    if ( a4 > 0x8000 )\n    {\n      switch ( a5 )\n      {\n        case 0u:\n          panic((__int64)\"DMA: Random memory could be DMA accessed\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n        case 2u:\n          panic((__int64)\"DMA: Random memory could be DMA written\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n        case 1u:\n          panic((__int64)\"DMA: Random memory could be DMA read\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n      }\n    }\n    return io_tlb_overflow_buffer;\n  }\n  v20 = (_QWORD *)a1[33];\n  if ( !v20 || result + a4 - 1 > *v20 )\n  {\n    swiotlb_tbl_unmap_single((__int64)a1, result, a4, a5);\n    return io_tlb_overflow_buffer;\n  }\n  return result;\n}\n",
    "source_code": "dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    struct dma_attrs *attrs)\n{\n\tphys_addr_t map, phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (dma_capable(dev, dev_addr, size) && !swiotlb_force)\n\t\treturn dev_addr;\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\tmap = map_single(dev, phys, size, dir);\n\tif (map == SWIOTLB_MAP_ERROR) {\n\t\tswiotlb_full(dev, size, dir, 1);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\tdev_addr = phys_to_dma(dev, map);\n\n\t/* Ensure that the address returned is DMA'ble */\n\tif (!dma_capable(dev, dev_addr, size)) {\n\t\tswiotlb_tbl_unmap_single(dev, map, size, dir);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\treturn dev_addr;\n}",
    "comment": "Maps a page of memory for DMA access, handling bounce buffers if the device cannot directly access the address.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Allocates memory for a resource within a specified range , ensuring alignment and checking for existing resources before returning the new address .\n",
    "cpbcs_sum": "Maps a physical address to a device, checking for valid range conflicts with existing PCI IDs and handling errors accordingly.\n",
    "misum_sum": "Checks if an NFS page is within allowed for the specified address range in NFS pages, checking for resource availability and memory allocation errors.\n",
    "decom_sum": "Validates DMA access permissions for a given memory range, logging warnings and invoking allocation or handling routines when access conditions are not met.",
    "cfg_sum": "Validates DMA address range, allocates or adjusts mapping if needed, logs access violations for excessive transfers, and returns the mapped address or error code.",
    "work_score": {
        "decom": {
            "summary": "Validates DMA access permissions for a given memory range, logging warnings and invoking allocation or handling routines when access conditions are not met.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function validates DMA access permissions, logs warnings, and invokes allocation or handling routines when conditions are not met. While the function does check DMA capability and allocate bounce buffers when necessary, there is no evidence in the code of logging warnings. The summary omits key details like the use of swiotlb_force, map_single, and overflow buffer handling, and introduces an inaccurate logging aspect. Approximately half of the claims are accurate, with notable inaccuracies regarding logging behavior.",
                "The summary inaccurately describes the function\u2019s core purpose. The core domain operation is mapping a page for DMA, using bounce buffers when necessary, with handling for errors and capability checks. The summary does not mention DMA mapping or bounce buffer usage, instead referring vaguely to access permission validation and warnings, which do not appear in the code. This omits the primary mapping logic and most other behavior-critical semantics.",
                "The summary claims the function validates DMA access permissions and logs warnings, but the source code does not perform logging\u2014it enforces a BUG_ON for invalid direction and uses bounce buffering when the device is not DMA-capable. While it does check DMA capability and allocate handling routines, the logging assertion is inaccurate. This is a FATAL error as it misstates a core side effect, reducing trustworthiness. Remaining details are generic and provide low informational gain."
            ]
        },
        "cfg": {
            "summary": "Validates DMA address range, allocates or adjusts mapping if needed, logs access violations for excessive transfers, and returns the mapped address or error code.",
            "score": [
                0.3,
                0.3,
                0.4
            ],
            "reason": [
                "The summary correctly mentions validating DMA address range, adjusting mapping if needed, and returning a mapped address, which aligns with the function's checks via dma_capable and mapping logic. However, it inaccurately claims that the function logs access violations for excessive transfers and returns an error code\u2014neither behavior exists in the source code. Instead, the code handles failures by using a fallback buffer without logging or error codes. This mix means less than half of the claims are accurate.",
                "The summary correctly mentions validating DMA address range and adjusting mapping, which aligns with the code\u2019s check for dma_capable and bounce buffer allocation. However, it introduces inaccurate elements such as logging access violations for excessive transfers and returning an error code, neither of which appear in the source code. The core purpose\u2014mapping a page for DMA with bounce buffering when necessary\u2014is only partially covered, and several key behaviors such as handling SWIOTLB_MAP_ERROR, use of overflow buffer, and cleanup on capability failure are missing.",
                "The summary includes one accurate claim about validating DMA address range and adjusting mapping if needed, which matches the code's dma_capable check and bounce buffer allocation. However, it inaccurately states that the function logs access violations for excessive transfers and returns an error code, neither of which occurs in the source (the code handles allocation failures and returns a fallback buffer, not logging or explicit error codes). This introduces significant noise, with the logging claim being a strong mismatch to the actual behavior, and the return value description misleading regarding core output semantics. The worst failure mode is NOISE overwhelming the accurate parts, resulting in low net benefit."
            ]
        },
        "comment": {
            "summary": "Maps a page of memory for DMA access, handling bounce buffers if the device cannot directly access the address.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately captures the core functionality of the function: mapping a memory page for DMA and using bounce buffers when direct device access is not possible. It correctly reflects the conditional logic in the code checking device capability and handling buffer allocation. The claim is specific to the code\u2019s DMA mapping semantics and contains no contradictions or irrelevant details.",
                "The summary accurately states the core function of mapping a memory page for DMA and mentions the use of bounce buffers when direct access is not possible, which matches the primary purpose in the source. However, it omits important secondary details such as the DMA direction validation, conditions using the device's DMA window, error handling on mapping failure, use of an overflow buffer, and the final capability check with unmap operations. This results in only partial coverage of behavior-critical semantics.",
                "The summary accurately captures the primary purpose of the function: mapping a page for DMA and handling bounce buffers if the device cannot access the address directly. This is a specific, correct GOLD claim about core behavior and I/O, with no contradictory statements or irrelevant noise. However, the description is somewhat generic and omits error handling details and conditions like swiotlb_force, resulting in moderate informational gain rather than high detail."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578866352,
    "strip_function_name": "sub_FFFFFFFF810052B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810052B0(int a1, __int64 a2, void *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v4; // rbx\n  __int64 v5; // r14\n  __int64 v6; // r15\n  void *v7; // rax\n  int v8; // eax\n  __int64 v9; // r14\n  unsigned __int64 v10; // r13\n\n  if ( a1 == 1 )\n    return sub_FFFFFFFF81004E80(a2, (__int64)a3, 1);\n  if ( a1 > 1 )\n  {\n    if ( a1 != 2 )\n    {\n      if ( a1 == 17 )\n        return sub_FFFFFFFF81004E80(a2, (__int64)a3, 0);\n      return 4294967258LL;\n    }\n    v4 = 128LL;\n    if ( (unsigned __int64)a3 <= 0x80 )\n      v4 = (unsigned __int64)a3;\n    if ( !sub_FFFFFFFF812BA5B0(a2, v4) )\n      return (unsigned int)v4;\n    return 4294967282LL;\n  }\n  if ( a1 )\n    return 4294967258LL;\n  v5 = *(_QWORD *)(__readgsqword(0xA7C0u) + 616);\n  result = 0LL;\n  if ( *(_DWORD *)(v5 + 744) )\n  {\n    v6 = v5 + 752;\n    v7 = &unk_10000;\n    if ( a3 <= &unk_10000 )\n      v7 = a3;\n    v4 = (unsigned __int64)v7;\n    sub_FFFFFFFF8178F210(v5 + 752);\n    v8 = *(_DWORD *)(v5 + 744);\n    v9 = *(_QWORD *)(v5 + 736);\n    v10 = 8 * v8;\n    if ( v10 > v4 )\n      v10 = v4;\n    sub_FFFFFFFF81790F30();\n    if ( (unsigned int)sub_FFFFFFFF812B8AE0(a2, v9, (unsigned int)v10) )\n    {\n      sub_FFFFFFFF8178F1B0(v6);\n    }\n    else\n    {\n      sub_FFFFFFFF8178F1B0(v6);\n      if ( v10 == v4 )\n        return (unsigned int)v4;\n      if ( !sub_FFFFFFFF812BA5B0(a2 + v10, v4 - v10) )\n        return (unsigned int)v4;\n    }\n    return 4294967282LL;\n  }\n  return result;\n}\n",
    "function_name": "sys_modify_ldt",
    "decompiled_code": "__int64 __fastcall sys_modify_ldt(\n        int a1,\n        _QWORD *a2,\n        void *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  void *v14; // rbx\n  __int64 v15; // r14\n  __int64 v16; // r15\n  void *v17; // rax\n  __int64 v18; // rdi\n  int v19; // eax\n  __int64 v20; // r14\n  unsigned __int64 v21; // r13\n\n  if ( a1 == 1 )\n    return write_ldt((__int64)a2, (__int64)a3, 1, a4, a5, a6, a7, a8, a9, a10, a11);\n  if ( a1 > 1 )\n  {\n    if ( a1 != 2 )\n    {\n      if ( a1 == 17 )\n        return write_ldt((__int64)a2, (__int64)a3, 0, a4, a5, a6, a7, a8, a9, a10, a11);\n      return 4294967258LL;\n    }\n    v14 = &unk_80;\n    if ( (unsigned __int64)a3 <= 0x80 )\n      v14 = a3;\n    if ( !clear_user(a2, (unsigned __int64)v14) )\n      return (unsigned int)v14;\n    return 4294967282LL;\n  }\n  if ( a1 )\n    return 4294967258LL;\n  v15 = *(_QWORD *)(__readgsqword(0xA7C0u) + 616);\n  result = 0LL;\n  if ( *(_DWORD *)(v15 + 744) )\n  {\n    v16 = v15 + 752;\n    v17 = &unk_10000;\n    if ( a3 <= &unk_10000 )\n      v17 = a3;\n    v18 = v15 + 752;\n    v14 = v17;\n    mutex_lock(v15 + 752);\n    v19 = *(_DWORD *)(v15 + 744);\n    v20 = *(_QWORD *)(v15 + 736);\n    v21 = 8 * v19;\n    if ( v21 > (unsigned __int64)v14 )\n      v21 = (unsigned __int64)v14;\n    cond_resched(v18, (__int64)a3);\n    if ( (unsigned int)copy_to_user((__int64)a2, v20, (unsigned int)v21) )\n    {\n      mutex_unlock(v16);\n    }\n    else\n    {\n      mutex_unlock(v16);\n      if ( (void *)v21 == v14 )\n        return (unsigned int)v14;\n      if ( !clear_user((_QWORD *)((char *)a2 + v21), (unsigned __int64)v14 - v21) )\n        return (unsigned int)v14;\n    }\n    return 4294967282LL;\n  }\n  return result;\n}\n",
    "source_code": "\nasmlinkage int sys_modify_ldt(int func, void __user *ptr,\n\t\t\t      unsigned long bytecount)\n{\n\tint ret = -ENOSYS;\n\n\tswitch (func) {\n\tcase 0:\n\t\tret = read_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 1:\n\t\tret = write_ldt(ptr, bytecount, 1);\n\t\tbreak;\n\tcase 2:\n\t\tret = read_default_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 0x11:\n\t\tret = write_ldt(ptr, bytecount, 0);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "comment": "The function modifies the local descriptor table (LDT) by reading or writing its entries based on the specified operation code.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sets the floating-point registers of a target task based on the CPU 's FPU capability and copies them to user space .\n",
    "cpbcs_sum": "Sets the CPU affinity for a specified task if the provided value is a valid and the conditions are met.\n",
    "misum_sum": "Retrieves the program counter for a specified task and copies it to user space, handling both system call and stack unwinding.\n",
    "decom_sum": "Handles various command codes to transfer data between a buffer and a destination, performing length checks and returning status codes for success or errors.",
    "cfg_sum": "Handles command codes to transfer data buffers, validate system state, and return status based on device interaction and memory read/write operations.",
    "work_score": {
        "decom": {
            "summary": "Handles various command codes to transfer data between a buffer and a destination, performing length checks and returning status codes for success or errors.",
            "score": [
                0.3,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function handles command codes and transfers data between a buffer and a destination, which aligns loosely with the code\u2019s switch cases calling read/write functions. However, it inaccurately adds details about performing length checks, which are not present, and does not correctly specify that the destination is the LDT or default LDT. The claim about returning status codes is generic and safe, but overall less than half of the claims are precise and fully accurate to the source.",
                "The summary does not accurately capture the core purpose of the function, which is to handle specific func codes for reading or writing entries to the local descriptor table (LDT). It incorrectly generalizes the operation as data transfer to a destination, omits mention of LDT or the distinct cases (0, 1, 2, 0x11), and introduces unsupported details like length checks. No accurate claim matches the source code's primary domain-specific action, and secondary behaviors such as error codes or branching logic are only vaguely mentioned.",
                "The summary introduces inaccurate claims about length checks and transferring data between a buffer and a destination, which are not reflected in the source code. The code switches on a function code and calls specific read/write LDT functions, returning their results. The 'length checks' detail is a FATAL inaccuracy about core behavior, as it misstates the primary purpose. Accurate elements are minimal and generic, with noise outweighing any true insight."
            ]
        },
        "cfg": {
            "summary": "Handles command codes to transfer data buffers, validate system state, and return status based on device interaction and memory read/write operations.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary includes claims about transferring data buffers, validating system state, and device interaction, which are not reflected in the source code. The function actually switches on \u2018func\u2019 to read or write the LDT as per specific codes, with no device interaction or system state validation. All claims are therefore inaccurate as they contradict or misrepresent the code semantics.",
                "The summary's claims about transferring data buffers, validating system state, device interaction, and general memory operations do not accurately reflect the source code, which specifically handles different function codes to read or write the Local Descriptor Table. The core purpose of managing LDT entries based on the func parameter is missing, and none of the claims align with the concrete behavior of calling read_ldt, write_ldt, or read_default_ldt. The description is too generic and introduces incorrect concepts like device interaction, leading to no coverage of the actual core or secondary semantics.",
                "The summary's claims about handling command codes are loosely aligned with the `switch` over `func` in the source, but it inaccurately frames the purpose as device interaction and system state validation, which are not present in the code. The function specifically reads or writes the LDT depending on the `func` value, not generic device buffers. These mismatches constitute noise overshadowing the limited accurate aspect, with no specific GOLD details extracted from the code."
            ]
        },
        "comment": {
            "summary": "The function modifies the local descriptor table (LDT) by reading or writing its entries based on the specified operation code.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function operates on the local descriptor table and reads or writes based on an operation code, which matches the switch-case handling of func values calling read_ldt, write_ldt, and read_default_ldt. There are no contradictory or irrelevant claims; however, the summary omits mention of specific func codes handled and defaults to ENOSYS, making it slightly generic. Overall, the claims are accurate but not highly detailed.",
                "The summary correctly identifies the core behavior of the function\u2014reading or writing the LDT based on an operation code\u2014matching the source code's switch over 'func' with calls to read_ldt, write_ldt, and read_default_ldt. However, it omits secondary specifics such as the exact operation codes handled (0, 1, 2, 0x11), distinctions between writing with or without a flag, and the default ENOSYS return when codes are unrecognized, resulting in incomplete coverage of critical details.",
                "The summary correctly identifies that the function deals with reading or writing the Local Descriptor Table based on an operation code, which aligns with the switch cases in the source code. However, it generalizes the behavior as 'modifying' the LDT without noting specific modes (e.g., different cases for reading current/default LDT or writing with flags) and omits the fact that unsupported opcodes return -ENOSYS. There are no contradictory or irrelevant claims, but the information provided is generic and lacks detailed specifics, resulting in low but positive net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583707408,
    "strip_function_name": "sub_FFFFFFFF814A3110",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814A3110(\n        __int64 a1,\n        int a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v12; // eax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n\n  if ( a2 != 1 )\n  {\n    if ( a2 != 2 )\n    {\n      sub_FFFFFFFF813EE640(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        \"usb_set_lpm_timeout\");\n      return 4294967274LL;\n    }\n    v12 = sub_FFFFFFFF814A2E70(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            0x18u);\n    if ( v12 >= 0 )\n    {\n      *(_DWORD *)(a1 + 1028) = a3;\n      return 0LL;\n    }\n    goto LABEL_8;\n  }\n  if ( a3 != 255 && (int)a3 > 127 )\n  {\n    sub_FFFFFFFF813EE640(\n      (_QWORD *)(a1 + 136),\n      (__int64)\"Failed to set %s timeout to 0x%x, which is a reserved value.\\n\",\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      \"U1\",\n      a3);\n    return 4294967274LL;\n  }\n  else\n  {\n    v12 = sub_FFFFFFFF814A2E70(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            0x17u);\n    if ( v12 < 0 )\n    {\nLABEL_8:\n      sub_FFFFFFFF813EE640(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"Failed to set %s timeout to 0x%x,error code %i\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        v13,\n        v14,\n        a10,\n        a11,\n        off_FFFFFFFF81889200[a2],\n        a3,\n        (unsigned int)v12);\n      return 4294967280LL;\n    }\n    *(_DWORD *)(a1 + 1012) = a3;\n    return 0LL;\n  }\n}\n",
    "function_name": "usb_set_lpm_timeout",
    "decompiled_code": "__int64 __fastcall usb_set_lpm_timeout(\n        __int64 a1,\n        int a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v12; // eax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n\n  if ( a2 != 1 )\n  {\n    if ( a2 != 2 )\n    {\n      dev_warn(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        \"usb_set_lpm_timeout\");\n      return 4294967274LL;\n    }\n    v12 = set_port_feature(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            24,\n            a4,\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11);\n    if ( v12 >= 0 )\n    {\n      *(_DWORD *)(a1 + 1028) = a3;\n      return 0LL;\n    }\n    goto LABEL_8;\n  }\n  if ( a3 != 255 && (int)a3 > 127 )\n  {\n    dev_warn(\n      (_QWORD *)(a1 + 136),\n      (__int64)\"Failed to set %s timeout to 0x%x, which is a reserved value.\\n\",\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      \"U1\",\n      a3);\n    return 4294967274LL;\n  }\n  else\n  {\n    v12 = set_port_feature(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            23,\n            a4,\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11);\n    if ( v12 < 0 )\n    {\nLABEL_8:\n      dev_warn(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"Failed to set %s timeout to 0x%x,error code %i\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        v13,\n        v14,\n        a10,\n        a11,\n        usb3_lpm_names[a2],\n        a3,\n        (unsigned int)v12);\n      return 4294967280LL;\n    }\n    *(_DWORD *)(a1 + 1012) = a3;\n    return 0LL;\n  }\n}\n",
    "source_code": "\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}",
    "comment": "Sets the low power mode timeout for a USB device based on the specified USB 3.0 link state, validating the timeout value before applying it.",
    "hext5_sum": "one. do not maintain a hash table. (it will be regenerated if this run of deflate switches away from z_rle.) =========================================================================== for z_rle, simply look for runs of bytes, generate matches only of distance",
    "bint5_sum": "Sets the LPM timeout for USB devices in U1 or U2 states while adjusting the device 's timeout value accordingly .\n",
    "cpbcs_sum": "Configures a USB interface by enabling or disabling it based on the specified port type and handles errors for invalid devices.\n",
    "misum_sum": "Sets the USB interface descriptor and flag in the OHCI controller, handling errors if the device is already set.\n",
    "decom_sum": "Sets USB U1 or U2 link power management timeout, validating values, sending control requests, updating state, and logging errors for invalid or failed operations.",
    "cfg_sum": "Sets USB U1 or U2 power state LPM timeout, validating parameters and invoking hardware command, with error logging and status code returns on failure.",
    "work_score": {
        "decom": {
            "summary": "Sets USB U1 or U2 link power management timeout, validating values, sending control requests, updating state, and logging errors for invalid or failed operations.",
            "score": [
                1.0,
                0.8,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function sets USB U1 or U2 link power management timeouts, performs validation of values, sends control requests, updates the device state, and logs errors for invalid or failed operations, all of which are explicitly reflected in the source code logic. All claims are accurate and relevant to the function's behavior, resulting in a high alignment with the evaluation steps.",
                "The summary accurately captures the core purpose of setting USB U1 or U2 link power management timeout and includes secondary details such as validation of values, sending a control request via set_port_feature, updating the timeout state, and logging warnings for invalid or failed operations. These align with the source code\u2019s domain semantics, covering both the primary functionality and multiple critical behaviors.",
                "The summary correctly identifies that the function handles U1 or U2 LPM timeouts, performs validation, issues control requests (`set_port_feature`), updates timeout state, and logs errors. All claims map directly to code behavior with no contradictions or irrelevant noise. While accurate, the description is somewhat high-level and lacks specifics like reserved value handling for U1, exact feature selection, and return codes, limiting the informational gain to moderate."
            ]
        },
        "cfg": {
            "summary": "Sets USB U1 or U2 power state LPM timeout, validating parameters and invoking hardware command, with error logging and status code returns on failure.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function sets the USB U1 or U2 low-power mode timeout, performs parameter validation, invokes a hardware command, logs errors, and returns status codes on failure. All these claims are directly supported by the source code\u2019s handling of U1/U2 states, timeout validation, calls to set_port_feature, and use of dev_warn with appropriate return values. No inaccuracies or irrelevant statements are present, so the claims are highly accurate and aligned with the code semantics.",
                "The summary accurately captures the core operation of setting the USB U1 or U2 LPM timeout and mentions parameter validation, hardware command invocation, error logging, and failure codes, aligning with the source code\u2019s behavior. However, it omits certain secondary details, such as the specific handling of invalid states, reserved timeout values for U1, the different status codes (-EINVAL vs. -EBUSY), and updating the corresponding udev timeout fields, which are important branches and side effects.",
                "The summary correctly states that the function sets the LPM timeout for USB U1 or U2 states, validates inputs, issues a hardware command, and logs errors with status codes, aligning with the source code behavior. All claims are accurate and focused on core semantics, with no contradictions or irrelevant noise. The gain is moderate as details like specific conditions for invalid input and field updates are omitted, but the main purpose and flow are captured clearly."
            ]
        },
        "comment": {
            "summary": "Sets the low power mode timeout for a USB device based on the specified USB 3.0 link state, validating the timeout value before applying it.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function sets a low power mode timeout for a USB device according to a USB 3.0 link state and validates the timeout before applying. This matches the code\u2019s behavior: selecting U1/U2 link states, checking timeout constraints for U1, and updating device parameters. While it is concise and omits some error-handling specifics, the claim is accurate and grounded in the source code, with no inaccuracies present.",
                "The summary accurately conveys the core purpose of setting the low power mode timeout based on the USB 3.0 link state and includes a note about validating the timeout, which matches the main function logic. However, it omits additional key semantics such as handling only U1 and U2 states, returning specific error codes for invalid values or failed operations, and updating the device's U1/U2 parameters. The coverage of secondary details is thin, focusing only on the validation and application aspects.",
                "The summary correctly describes the core function: it sets a low power mode timeout for a USB device based on the given USB 3.0 link state, and it notes validation before application. These claims are accurate and align with the source, specifically covering the primary purpose and a key behavior. However, the description is somewhat generic and omits details such as handling of invalid states, the reserved value check for U1, and updating device parameters. There is no inaccurate or contradictory statement, but the information gain is low due to its brevity and lack of specificities."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586047952,
    "strip_function_name": "sub_FFFFFFFF816DE7D0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816DE7D0(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r13\n  __int64 v11; // rax\n  __int64 v12; // rbx\n  __int64 v13; // rax\n  unsigned int v14; // edi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n\n  v10 = -12LL;\n  v11 = sub_FFFFFFFF8112CA50((_QWORD *)qword_FFFFFFFF81E8C710, 0x50u, 160LL, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( !v11 )\n    return v10;\n  v12 = v11;\n  v10 = v11;\n  sub_FFFFFFFF816DD6B0(v11, (unsigned int *)a2, a1, (__int64)&off_FFFFFFFF818D0040);\n  *(_QWORD *)(v12 + 72) = 2LL;\n  v13 = *(_QWORD *)(a2 + 8);\n  if ( !v13 )\n  {\n    v16 = 0LL;\n    *(_DWORD *)(v12 + 88) = *(_DWORD *)(a2 + 4);\n    goto LABEL_8;\n  }\n  v14 = *(_DWORD *)(v13 + 4);\n  *(_DWORD *)(v12 + 88) = *(_DWORD *)(a2 + 4);\n  if ( v14 <= 0x10 )\n  {\n    if ( v14 )\n      goto LABEL_5;\n    v16 = 0LL;\nLABEL_8:\n    *(_DWORD *)(v12 + 4 * v16 + 92) = -1;\n    return v10;\n  }\n  v14 = 16;\nLABEL_5:\n  v15 = 0LL;\n  LODWORD(v16) = 0;\n  do\n  {\n    v16 = (unsigned int)(v16 + 1);\n    *(_DWORD *)(v12 + v15 + 92) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 144LL) + v15);\n    v15 += 4LL;\n  }\n  while ( (unsigned int)v16 < v14 );\n  if ( (_DWORD)v16 != 16 )\n    goto LABEL_8;\n  return v10;\n}\n",
    "function_name": "unx_create_cred",
    "decompiled_code": "__int64 __fastcall unx_create_cred(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r13\n  __int64 *v11; // rax\n  __int64 *v12; // rbx\n  __int64 v13; // rax\n  unsigned int v14; // edi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n\n  v10 = -12LL;\n  v11 = kmem_cache_alloc_trace((__int64 *)qword_FFFFFFFF81E8C710, 80LL, 160LL, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( !v11 )\n    return v10;\n  v12 = v11;\n  v10 = (__int64)v11;\n  rpcauth_init_cred((__int64)v11, (unsigned int *)a2, a1, (__int64)&unix_credops);\n  v12[9] = 2LL;\n  v13 = *(_QWORD *)(a2 + 8);\n  if ( !v13 )\n  {\n    v16 = 0LL;\n    *((_DWORD *)v12 + 22) = *(_DWORD *)(a2 + 4);\n    goto LABEL_8;\n  }\n  v14 = *(_DWORD *)(v13 + 4);\n  *((_DWORD *)v12 + 22) = *(_DWORD *)(a2 + 4);\n  if ( v14 <= 0x10 )\n  {\n    if ( v14 )\n      goto LABEL_5;\n    v16 = 0LL;\nLABEL_8:\n    *((_DWORD *)v12 + v16 + 23) = -1;\n    return v10;\n  }\n  v14 = 16;\nLABEL_5:\n  v15 = 0LL;\n  LODWORD(v16) = 0;\n  do\n  {\n    v16 = (unsigned int)(v16 + 1);\n    *(_DWORD *)((char *)v12 + v15 + 92) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 144LL) + v15);\n    v15 += 4LL;\n  }\n  while ( (unsigned int)v16 < v14 );\n  if ( (_DWORD)v16 != 16 )\n    goto LABEL_8;\n  return v10;\n}\n",
    "source_code": "\nstatic struct rpc_cred *\nunx_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\n{\n\tstruct unx_cred\t*cred;\n\tunsigned int groups = 0;\n\tunsigned int i;\n\n\tdprintk(\"RPC:       allocating UNIX cred for uid %d gid %d\\n\",\n\t\t\tfrom_kuid(&init_user_ns, acred->uid),\n\t\t\tfrom_kgid(&init_user_ns, acred->gid));\n\n\tif (!(cred = kmalloc(sizeof(*cred), GFP_NOFS)))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpcauth_init_cred(&cred->uc_base, acred, auth, &unix_credops);\n\tcred->uc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\n\n\tif (acred->group_info != NULL)\n\t\tgroups = acred->group_info->ngroups;\n\tif (groups > NFS_NGROUPS)\n\t\tgroups = NFS_NGROUPS;\n\n\tcred->uc_gid = acred->gid;\n\tfor (i = 0; i < groups; i++)\n\t\tcred->uc_gids[i] = GROUP_AT(acred->group_info, i);\n\tif (i < NFS_NGROUPS)\n\t\tcred->uc_gids[i] = INVALID_GID;\n\n\treturn &cred->uc_base;\n}",
    "comment": "Allocates and initializes a UNIX credential structure with user and group identifiers based on provided authentication credentials.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Creates and initializes an RPC credential structure for RPC authentication using provided user and group credentials .\n",
    "cpbcs_sum": "Creates and initializes a GSS credential structure for IPv6 by allocating a socket and configuring the associated IP address and comparison functions.\n",
    "misum_sum": "Registers an RPC client with the specified network namespace and sets up the corresponding net sysctl table in the net namespace.\n",
    "decom_sum": "Allocates and initializes a 160-byte structure, copies configuration data from `a2`, and fills up to 16 related IDs into designated fields.",
    "cfg_sum": "Allocates and initializes a structured data block from input parameters, copies up to 16 configuration values, and sets default entries when none are provided.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a 160-byte structure, copies configuration data from `a2`, and fills up to 16 related IDs into designated fields.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary includes several specific claims that do not align with the source code. The claim about allocating and initializing a 160-byte structure is inaccurate, as the code allocates based on sizeof(*cred) without specifying its size. The statement about copying configuration data from `a2` is incorrect because the second parameter is `acred` and there is no reference to an `a2` symbol. The mention of filling up to 16 related IDs misrepresents the logic, which fills up to NFS_NGROUPS group IDs from `acred->group_info` and not necessarily 16. Only the generic idea of allocating and initializing a structure and populating IDs is broadly accurate, meaning less than half of the claims are correct.",
                "The summary correctly notes allocation and initialization as part of the function, and mentions populating IDs into fields, which aligns loosely with filling group IDs. However, it inaccurately refers to a fixed 160-byte size and uses vague 'configuration data from a2' instead of clearly identifying `acred` and its UID/GID specifics, thus missing the core purpose of creating and initializing a UNIX RPC credential with UID, GID, and up to NFS_NGROUPS group IDs. It fails to capture the domain-specific operation or other key behaviors such as limits, constants, and handling of INVALID_GID padding, leaving core coverage absent.",
                "The summary contains inaccurate details: it specifies a fixed 160-byte allocation and refers to copying configuration data from `a2`, which do not align with the source code. The function allocates memory using `kmalloc(sizeof(*cred), GFP_NOFS)` with size determined by the struct definition, and copies UID, GID, and group IDs from `acred`, not `a2`. It correctly notes initialization and filling IDs but misstates the limit as 16 rather than `NFS_NGROUPS`, introducing a FATAL error on core I/O behavior."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes a structured data block from input parameters, copies up to 16 configuration values, and sets default entries when none are provided.",
            "score": [
                0.7,
                0.3,
                0.4
            ],
            "reason": [
                "The summary correctly states that the function allocates and initializes a data structure from its input parameters, which aligns with the code's kmalloc call and rpcauth_init_cred usage. It also notes copying configuration values and setting defaults, which corresponds to copying group IDs and setting INVALID_GID for remaining slots. However, the claim of 'up to 16 configuration values' is inaccurate, as the code limits groups based on NFS_NGROUPS, whose value is not verified to be 16 in the provided code. This introduces a semantic inaccuracy, reducing overall precision.",
                "The summary captures generic allocation and initialization behavior and mentions copying values with defaults, loosely matching the group ID logic. However, it misses the core domain purpose of creating an RPC UNIX credential from authentication and authorization data, including specific fields for UID/GID. It omits key semantics such as limiting group count to NFS_NGROUPS, initializing credential flags, and handling memory allocation errors, resulting in incomplete and overly vague coverage.",
                "The summary correctly notes allocation and initialization from input parameters, and defaulting unused entries, which aligns loosely with the source code behavior. However, the claim of copying 'up to 16 configuration values' is inaccurate\u2014source code copies up to NFS_NGROUPS group IDs, not generic configuration values, and the maximum is determined by NFS_NGROUPS rather than an explicit '16'. The terminology is vague, providing low-info SAFE claims with notable NOISE and lacking any specific GOLD-level insight such as group ID handling or flag setting. The worst issue is NOISE from mislabeling the copied data and its limit, reducing clarity."
            ]
        },
        "comment": {
            "summary": "Allocates and initializes a UNIX credential structure with user and group identifiers based on provided authentication credentials.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately conveys that the function allocates and initializes a UNIX credential structure using user and group identifiers from the given authentication credentials, which matches the code's behavior of allocating 'unx_cred', initializing it via 'rpcauth_init_cred', and setting uid, gid, and gids based on 'acred'. While concise and generic, it is fully aligned with the source code semantics and contains no inaccuracies.",
                "The summary correctly states that the function allocates and initializes a UNIX credential structure using user and group identifiers from the provided authentication credentials, which matches the core purpose of creating and populating a UNIX RPC credential from acred and auth. However, it omits important secondary details such as the enforcement of NFS_NGROUPS limit, the setting of RPCAUTH_CRED_UPTODATE flag, handling of group_info NULL case, and the use of INVALID_GID for unused slots. Coverage of the core is adequate but secondary semantics are minimal.",
                "The summary accurately describes the core purpose of the function, which is to allocate and initialize a UNIX credential structure using user and group IDs from the provided authentication credentials. There are no inaccurate or noisy claims, but the statement is generic and lacks specific details such as handling maximum group count, setting flags, or initializing additional fields. The gain is low due to its broad and minimal nature."
            ]
        }
    }
}
{
    "project_name": "inetutils",
    "function_addr": 4228896,
    "strip_function_name": "sub_408720",
    "strip_decompiled_code": "void sub_408720()\n{\n  struct sockaddr *v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // [rsp-8h] [rbp-10h]\n\n  sub_408600(211, \"%s FTP server status:\", (const char *)qword_624A28);\n  if ( !dword_624EC4 )\n    printf(\"     ftpd (%s) %s\\r\\n\", \"GNU inetutils\", \"1.9.4\");\n  printf(\"     Connected to %s\", ptr);\n  getnameinfo(&unk_624A40, addr_len, host, 0x401u, 0LL, 0, 1);\n  if ( ((*__ctype_b_loc())[*ptr] & 0x800) == 0 )\n    printf(\" (%s)\", host);\n  puts(\"\\r\");\n  printf(\"     Session timeout is %d seconds\\r\\n\", seconds);\n  if ( dword_624F30 )\n  {\n    if ( (_DWORD)qword_624F28 )\n      puts(\"     Logged in anonymously\\r\");\n    else\n      printf(\"     Logged in as %s\\r\\n\", user);\n  }\n  else if ( dword_624504 )\n  {\n    puts(\"     Waiting for password\\r\");\n  }\n  else\n  {\n    puts(\"     Waiting for user name\\r\");\n  }\n  printf(\"     TYPE: %s\", (const char *)*(&off_624040 + SHIDWORD(qword_623FD0)));\n  if ( (unsigned int)(HIDWORD(qword_623FD0) - 1) <= 1 )\n  {\n    printf(\", FORM: %s\", (const char *)*(&off_624020 + (int)qword_623FD0));\n    if ( HIDWORD(qword_623FD0) != 4 )\n      goto LABEL_12;\n  }\n  else if ( HIDWORD(qword_623FD0) != 4 )\n  {\n    goto LABEL_12;\n  }\n  printf(\" %d\", 8);\nLABEL_12:\n  printf(\"; STRUcture: %s; transfer MODE: %s\\r\\n\", off_624008[0], off_623FE8[0]);\n  if ( dword_623FB8 == -1 )\n  {\n    if ( fd == -1 )\n    {\n      if ( dword_623FBC )\n      {\n        puts(\"     No data connection\\r\");\n        goto LABEL_16;\n      }\n      printf(\"     PORT\");\n      v0 = &unk_6249A0;\n    }\n    else\n    {\n      printf(\"     in Passive mode\");\n      v0 = &stru_624620;\n    }\n    printf(\n      \" (%d,%d,%d,%d,%d,%d)\\r\\n\",\n      (unsigned __int8)v0->sa_data[2],\n      (unsigned __int8)v0->sa_data[3],\n      (unsigned __int8)v0->sa_data[4],\n      (unsigned __int8)v0->sa_data[5],\n      (unsigned __int8)v0->sa_data[0],\n      (unsigned __int8)v0->sa_data[1]);\n    v1 = v2;\n  }\n  else\n  {\n    puts(\"     Data connection open\\r\");\n  }\nLABEL_16:\n  sub_4082C0(211, \"End of status\", v1);\n}\n",
    "function_name": "statcmd",
    "decompiled_code": "void __cdecl statcmd()\n{\n  sockaddr_storage *v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // [rsp-8h] [rbp-10h]\n\n  lreply(211, &byte_41D254[115], hostname);\n  if ( !no_version )\n    printf(&byte_41D254[157], 4313827LL, 4313821LL);\n  printf(\"     Connected to %s\", cred.remotehost);\n  getnameinfo((const struct sockaddr *)&his_addr, his_addrlen, addrstr, 0x401u, 0LL, 0, 1);\n  if ( ((*__ctype_b_loc())[*cred.remotehost] & 0x800) == 0 )\n    printf(\" (%s)\", addrstr);\n  puts(s);\n  printf(\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if ( cred.logged_in )\n  {\n    if ( cred.guest )\n      puts(\"     Logged in anonymously\\r\");\n    else\n      printf(\"     Logged in as %s\\r\\n\", cred.name);\n  }\n  else if ( askpasswd )\n  {\n    puts(aWaitingForPass);\n  }\n  else\n  {\n    puts(&s[2]);\n  }\n  printf(&s[30], typenames[type]);\n  if ( (unsigned int)(type - 1) <= 1 )\n  {\n    printf(&s[44], formnames[form]);\n    if ( type != 4 )\n      goto LABEL_12;\n  }\n  else if ( type != 4 )\n  {\n    goto LABEL_12;\n  }\n  printf(&s[55], 8LL);\nLABEL_12:\n  printf(\"; STRUcture: %s; transfer MODE: %s\\r\\n\", strunames[1], modenames[1]);\n  if ( data == -1 )\n  {\n    if ( pdata == -1 )\n    {\n      if ( usedefault )\n      {\n        puts(&s[140]);\n        goto LABEL_16;\n      }\n      printf(&s[107]);\n      v0 = &data_dest;\n    }\n    else\n    {\n      printf(&s[86]);\n      v0 = &pasv_addr;\n    }\n    printf(\n      &s[117],\n      (unsigned __int8)v0->__ss_padding[2],\n      (unsigned __int8)v0->__ss_padding[3],\n      (unsigned __int8)v0->__ss_padding[4],\n      (unsigned __int8)v0->__ss_padding[5],\n      (unsigned __int8)v0->__ss_padding[0],\n      (unsigned __int8)v0->__ss_padding[1]);\n    v1 = v2;\n  }\n  else\n  {\n    puts(&s[59]);\n  }\nLABEL_16:\n  reply(211, &s[165], v1);\n}\n",
    "source_code": "\nvoid\nstatcmd (void)\n{\n  struct sockaddr_storage *sin;\n  unsigned char *a, *p;\n\n  lreply (211, \"%s FTP server status:\", hostname);\n  if (!no_version)\n    printf (\"     ftpd (%s) %s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n  printf (\"     Connected to %s\", cred.remotehost);\n  (void) getnameinfo ((struct sockaddr *) &his_addr, his_addrlen,\n\t\t      addrstr, sizeof (addrstr), NULL, 0, NI_NUMERICHOST);\n  if (!isdigit (cred.remotehost[0]))\n    printf (\" (%s)\", addrstr);\n  printf (\"\\r\\n\");\n  printf (\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if (cred.logged_in)\n    {\n      if (cred.guest)\n\tprintf (\"     Logged in anonymously\\r\\n\");\n      else\n\tprintf (\"     Logged in as %s\\r\\n\", cred.name);\n    }\n  else if (askpasswd)\n    printf (\"     Waiting for password\\r\\n\");\n  else\n    printf (\"     Waiting for user name\\r\\n\");\n  printf (\"     TYPE: %s\", typenames[type]);\n  if (type == TYPE_A || type == TYPE_E)\n    printf (\", FORM: %s\", formnames[form]);\n  if (type == TYPE_L)\n#ifdef CHAR_BIT\n    printf (\" %d\", CHAR_BIT);\n#else\n# if NBBY == 8\n    printf (\" %d\", NBBY);\n# else\n    printf (\" %d\", bytesize);\t/* need definition! */\n# endif\n#endif\n  printf (\"; STRUcture: %s; transfer MODE: %s\\r\\n\",\n\t  strunames[stru], modenames[stru_mode]);\n  if (data != -1)\n    printf (\"     Data connection open\\r\\n\");\n  else if (pdata != -1)\n    {\n      printf (\"     in Passive mode\");\n      sin = &pasv_addr;\n      goto printaddr;\n    }\n  else if (usedefault == 0)\n    {\n      printf (\"     PORT\");\n      sin = &data_dest;\n    printaddr:\n      a = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_addr;\n      p = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_port;\n#define UC(b) (((int) b) & 0xff)\n      printf (\" (%d,%d,%d,%d,%d,%d)\\r\\n\", UC (a[0]),\n\t      UC (a[1]), UC (a[2]), UC (a[3]), UC (p[0]), UC (p[1]));\n#undef UC\n    }\n  else\n    printf (\"     No data connection\\r\\n\");\n  reply (211, \"End of status\");\n}",
    "comment": "Displays the current status of the FTP server, including connection details, session timeout, user login status, data connection status, and transfer settings.",
    "hext5_sum": "print the first n statements in statement list s to stderr. if n == 0, nothing is printed. if n < 0, the entire list is printed. intended to be called from gdb.",
    "bint5_sum": "Displays the FTP server status , including server name , timeout information , and authentication details , while handling session management and error reporting .\n",
    "cpbcs_sum": "Handles unexpected characters by sending a signal to the appropriate stream or remote host based on client authentication and server configurations.\n",
    "misum_sum": "Displays a formatted error message with a formatted error message and status information, including usage details and received options.\n",
    "decom_sum": "Prints the current FTP server status, including connection details, login state, transfer settings, and data connection mode.",
    "cfg_sum": "Displays the current FTP server status, including connection details, session state, transfer settings, and data connection information based on server flags and variables.",
    "work_score": {
        "decom": {
            "summary": "Prints the current FTP server status, including connection details, login state, transfer settings, and data connection mode.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary captures the core functionality of the function accurately: it prints the FTP server status, showing connection details, login state, transfer settings, and data connection mode. All these elements are explicitly implemented in the source code, and no contradictory or irrelevant claims are present, resulting in a high proportion of accurate claims.",
                "The summary correctly captures the core purpose of reporting the FTP server status, aligning with the function's primary action of printing connection details, login state, transfer settings, and data connection mode. However, it omits key specifics present in the code such as handling passive/active modes with IP/port printing, session timeout, anonymous vs named login, waiting states for credentials, and type/form/structure/mode nuances. These omissions limit coverage of critical secondary behaviors, resulting in an incomplete representation.",
                "The summary accurately captures the primary purpose of the function, which is printing the FTP server status along with connection details, login state, transfer settings, and data connection mode. These are all consistent with the code's behavior. However, the claims are broad and generic, lacking specific details such as exact fields printed (hostname, timeout, anonymous/user login, type/form/structure/mode, passive/active data parameters). There is no inaccurate or contradictory content, but the informational gain is limited due to the absence of these specifics."
            ]
        },
        "cfg": {
            "summary": "Displays the current FTP server status, including connection details, session state, transfer settings, and data connection information based on server flags and variables.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly describes the function\u2019s purpose and major behaviors: it outputs FTP server status including connection details, session state, transfer settings, and data connection information, all of which align with the code\u2019s output logic using server variables and flags. While the summary is generic and lacks mention of specific conditional cases or printed formats, all of its claims target code semantics and are accurate.",
                "The summary correctly captures the core purpose of reporting the FTP server status with connection details, session state, transfer settings, and data connection info, aligning with the function\u2019s output flow. However, it lacks mention of several secondary specifics from the code such as version information printing, differentiated login states (anonymous, user, waiting for name/password), TYPE form and byte size details, passive/active mode address formatting, and explicit constants used. These omissions reduce completeness, though the core is covered accurately.",
                "The summary accurately describes the primary purpose and output of the function, noting its display of FTP server status, connection details, session state, transfer settings, and data connection information. These points match the code\u2019s behavior without contradicting it. However, the claims are generic and lack specifics like the exact conditions or formats shown, resulting in low informational gain despite no inaccuracies or noise."
            ]
        },
        "comment": {
            "summary": "Displays the current status of the FTP server, including connection details, session timeout, user login status, data connection status, and transfer settings.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly captures the overall purpose and key outputs of the function, such as showing FTP server status, connection details, session timeout, user login state, data connection info, and transfer settings. All these elements are directly reflected in the source code's print statements, with no contradictory or irrelevant claims. The coverage is broad but accurate, making nearly all extracted claims verifiable from the code.",
                "The summary accurately captures the core purpose of the function, which is to display the FTP server\u2019s current status including connection details, session timeout, user login state, data connection status, and transfer settings. However, it omits several secondary, behavior-critical details present in the source code, such as passive mode output, specific address/port formatting, TYPE form details, structure and mode values, conditional version display, and waiting-for-username/password messages. This results in incomplete coverage beyond the main purpose.",
                "The summary accurately describes the primary purpose and core functionality of the function, noting that it displays FTP server status with connection details, session timeout, user login status, data connection status, and transfer settings. All these points match the source code behavior without introducing contradictions. However, the claims are broad and generic, offering low informational gain by omitting specifics such as passive mode address display, TYPE formatting, or conditional login messages. Noise is minimal and there are no fatal inaccuracies."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584590896,
    "strip_function_name": "sub_FFFFFFFF8157AC30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8157AC30(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  __int64 v13; // r13\n  __int64 v14; // rax\n  unsigned __int64 v15; // rbx\n  void *v16; // r15\n  __int64 v17; // rdx\n  __int64 result; // rax\n  _QWORD v19[6]; // [rsp+8h] [rbp-30h] BYREF\n\n  v13 = *(_QWORD *)(a1 + 320);\n  v14 = *(_QWORD *)(v13 + 888);\n  if ( v14 )\n  {\n    v15 = (unsigned int)(*(_DWORD *)(v14 + 20) * *(_DWORD *)(v14 + 36)) >> 3;\n    if ( !a4 )\n    {\n      v16 = *(void **)(v13 + 832);\n      sub_FFFFFFFF81790F30(a1);\n      v17 = sub_FFFFFFFF812B8B10(v16, a2, (unsigned int)a3);\n      result = -14LL;\n      if ( v17 )\n        return result;\n      a2 = *(_QWORD *)(v13 + 832);\n    }\n    result = sub_FFFFFFFF8157D640(a1, a2, a3 / v15, v19);\n    if ( result >= 0 )\n    {\n      result = sub_FFFFFFFF8157D760(a1, v19[0], result);\n      if ( result > 0 )\n        result *= v15;\n    }\n  }\n  else\n  {\n    result = sub_FFFFFFFF8157AB50(\n               a1,\n               a2,\n               (__int64)(8 * a3) / *(unsigned int *)(v13 + 152),\n               a4,\n               a5,\n               a6,\n               a7,\n               a8,\n               a9,\n               a10,\n               a11,\n               a12);\n    if ( result > 0 )\n      return *(unsigned int *)(v13 + 152) * result / 8;\n  }\n  return result;\n}\n",
    "function_name": "snd_pcm_oss_write2",
    "decompiled_code": "__int64 __fastcall snd_pcm_oss_write2(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        __int64 a13,\n        int a14)\n{\n  __int64 v15; // r13\n  __int64 v16; // rax\n  unsigned __int64 v17; // rbx\n  __int64 v18; // r15\n  __int64 v19; // rdx\n  __int64 result; // rax\n  __int64 v21[6]; // [rsp+8h] [rbp-30h] BYREF\n\n  v15 = *(_QWORD *)(a1 + 320);\n  v16 = *(_QWORD *)(v15 + 888);\n  if ( v16 )\n  {\n    v17 = (unsigned int)(*(_DWORD *)(v16 + 20) * *(_DWORD *)(v16 + 36)) >> 3;\n    if ( !(_DWORD)a4 )\n    {\n      v18 = *(_QWORD *)(v15 + 832);\n      cond_resched(a1, a2);\n      v19 = copy_from_user(v18, a2, (unsigned int)a3);\n      result = -14LL;\n      if ( v19 )\n        return result;\n      a2 = *(_QWORD *)(v15 + 832);\n    }\n    result = snd_pcm_plug_client_channels_buf(a1, a2, a3 / v17, v21);\n    if ( result >= 0 )\n    {\n      result = snd_pcm_plug_write_transfer(a1, v21[0], result);\n      if ( result > 0 )\n        result *= v17;\n    }\n  }\n  else\n  {\n    result = snd_pcm_oss_write3(\n               a1,\n               a2,\n               (__int64)(8 * a3) / *(unsigned int *)(v15 + 152),\n               a4,\n               a5,\n               a6,\n               a7,\n               a8,\n               a9,\n               a10,\n               a11,\n               a12,\n               a13,\n               a14);\n    if ( result > 0 )\n      return *(unsigned int *)(v15 + 152) * result / 8;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic ssize_t snd_pcm_oss_write2(struct snd_pcm_substream *substream, const char *buf, size_t bytes, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t frames, frames1;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first) {\n\t\tstruct snd_pcm_plugin_channel *channels;\n\t\tsize_t oss_frame_bytes = (runtime->oss.plugin_first->src_width * runtime->oss.plugin_first->src_format.channels) / 8;\n\t\tif (!in_kernel) {\n\t\t\tif (copy_from_user(runtime->oss.buffer, (const char __force __user *)buf, bytes))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = runtime->oss.buffer;\n\t\t}\n\t\tframes = bytes / oss_frame_bytes;\n\t\tframes1 = snd_pcm_plug_client_channels_buf(substream, (char *)buf, frames, &channels);\n\t\tif (frames1 < 0)\n\t\t\treturn frames1;\n\t\tframes1 = snd_pcm_plug_write_transfer(substream, channels, frames1);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames1 * oss_frame_bytes;\n\t} else\n#endif\n\t{\n\t\tframes = bytes_to_frames(runtime, bytes);\n\t\tframes1 = snd_pcm_oss_write3(substream, buf, frames, in_kernel);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames_to_bytes(runtime, frames1);\n\t}\n\treturn bytes;\n}",
    "comment": "Writes audio data from a buffer to a PCM substream, handling potential OSS plugin processing and user-kernel memory copying.",
    "hext5_sum": "calculate the number of columns needed to represent the current set of files in the current display width.",
    "bint5_sum": "Reads audio data from a PCM substream , handling either user space or kernel space buffers with optional plugin processing .\n",
    "cpbcs_sum": "Reads audio data from a PCM substream, handling either user space or kernel space buffers with optional plugin processing.\n",
    "misum_sum": "Writes audio data to a PCM substream, handling user space and kernel space if allocation is available.\n",
    "decom_sum": "Processes a data request by selecting between two transfer routines, scaling result by element size, and handling optional pre-transfer initialization.",
    "cfg_sum": "Processes data size calculations and conditionally transforms or transfers buffers, adjusting output length based on format parameters and computed block size before returning the final result.",
    "work_score": {
        "decom": {
            "summary": "Processes a data request by selecting between two transfer routines, scaling result by element size, and handling optional pre-transfer initialization.",
            "score": [
                0.8,
                0.4,
                0.5
            ],
            "reason": [
                "The summary captures the high-level idea of choosing between two transfer routines and adjusting result size, which aligns with the code's selection between plugin-based and direct write paths and scaling bytes by frame size. However, it omits key specifics such as conditional handling based on `runtime->oss.plugin_first`, user-space data copying when not in kernel mode, and error return conditions. The mention of 'optional pre-transfer initialization' is loosely aligned with the plugin buffer preparation logic but remains generic. Overall, most claims are accurate but lack detailed semantic precision.",
                "The summary gives a generic description of selecting between two routines, scaling by element size, and pre-transfer initialization, but it does not specifically convey the core purpose of writing PCM audio data through either plugin-based transfer or direct write depending on runtime configuration. It omits key domain-specific details like conversion between bytes and frames, handling user-space buffer copying, invoking plugin channel setup, and error return paths. While the routine selection and scaling are generally accurate, the lack of audio/PCM context and omission of critical behaviors makes coverage of the core purpose weak.",
                "The summary\u2019s claims are mostly generic and loosely connected to the code. It correctly notes selecting between two routines and scaling output by element size, which matches the plugin versus non-plugin branches and byte/frame conversions. However, 'handling optional pre-transfer initialization' is vague and does not clearly align with the actual copy-from-user plugin-specific setup. The overall gain is low because details such as conditional plugin channel handling, user/kernel buffer copying, and conversion functions are omitted. Noise from broad phrasing outweighs the modest accuracy, but there is no fatal contradiction of core purpose."
            ]
        },
        "cfg": {
            "summary": "Processes data size calculations and conditionally transforms or transfers buffers, adjusting output length based on format parameters and computed block size before returning the final result.",
            "score": [
                0.9,
                0.2,
                0.6
            ],
            "reason": [
                "The summary correctly reflects core behaviors in the code, such as performing size calculations, conditional processing of buffers, transformations/transfers depending on conditions, and adjusting output length based on format parameters before returning the result. These align with the code\u2019s conditional handling of plugin presence, calculation of frame and byte counts, and final byte return. While it is somewhat generic and lacks mention of specific mechanisms like `copy_from_user` or function calls used, nearly all claims are accurate and grounded in the source code.",
                "The summary correctly describes general data size calculations and conditional buffer processing, which are [ACCURATE] but generic. It omits the core domain purpose: writing PCM audio data in OSS mode via plugin or direct path, including user-space copying, frame conversions, and invoking specific transfer functions. No mention of audio playback context, PCM frames, or error handling branches means the core is not covered and secondary details are sparse.",
                "The summary correctly captures that the function performs data size calculations and conditionally processes buffers, adjusting output length based on format parameters and block size. These are accurate and align with the code\u2019s handling of frame/byte conversions and plugin vs. non-plugin paths. However, the description is broad, lacks specifics such as the in-kernel check, user memory copy handling, and distinct paths for plugin vs. default processing, resulting in only generic, low-info gains and minimal noise."
            ]
        },
        "comment": {
            "summary": "Writes audio data from a buffer to a PCM substream, handling potential OSS plugin processing and user-kernel memory copying.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function writes audio data from a buffer to a PCM substream, and correctly notes handling of OSS plugin processing and user-to-kernel memory copying. These elements are clearly present in the source code, which includes logic for OSS plugins, user space copying via copy_from_user, and PCM buffer writing. There are no incorrect or irrelevant claims, and all points relate directly to the code's behavior.",
                "The summary accurately identifies that the function writes audio data from a buffer to a PCM substream, includes handling for OSS plugin processing, and mentions user-to-kernel memory copying, which matches the core domain action and some secondary behaviors in the code. However, it lacks detail on key secondary semantics such as frame size calculation, specific plugin channel handling, conditional compilation, branching for plugin vs non-plugin paths, and error/return code behavior. Coverage is limited beyond the core purpose.",
                "The summary correctly identifies the core purpose of the function\u2014writing audio data from a buffer to a PCM substream\u2014and notes key behaviors such as handling OSS plugin processing and user-to-kernel memory copying, both evident in the source. It omits finer details like frame size computation and conditional paths, but there are no inaccuracies or irrelevant noise. The claims are accurate yet generic, providing low-info gain beyond the obvious high-level operation."
            ]
        }
    }
}
{
    "project_name": "texinfo",
    "function_addr": 128992,
    "strip_function_name": "sub_1F7E0",
    "strip_decompiled_code": "__int64 __fastcall sub_1F7E0(__int64 a1, int a2)\n{\n  __int64 v2; // r12\n  unsigned int v3; // ebx\n  const char *v5; // rbx\n  const char *v6; // rdi\n  __int64 v7; // r12\n  __int64 v8; // rax\n  char *v10; // rax\n\n  v2 = *(_QWORD *)(a1 + 48);\n  v3 = *(_DWORD *)(v2 + 56) & 0x50;\n  if ( v3 )\n    return 1;\n  if ( a2 == 1 )\n    return (unsigned int)sub_1CEF0(\"Prev\", a1) == 0;\n  if ( a2 == 2 )\n  {\n    sub_1C2E0((__int64)\"%s\", (const char *)qword_24BF28);\n    return 1;\n  }\n  if ( a2 )\n    return v3;\n  v5 = *(const char **)(v2 + 72);\n  if ( v5 )\n  {\n    if ( strncasecmp(*(const char **)(v2 + 72), \"(dir)\", 5uLL) )\n    {\n      v6 = *(const char **)(v2 + 80);\n      if ( !v6 || !strcmp(v6, v5) )\n        return (unsigned int)sub_1CEF0(\"Up\", a1) == 0;\n      v7 = *(_QWORD *)(a1 + 296);\n      if ( (unsigned int)sub_1CEF0(\"Prev\", a1) )\n      {\n        v3 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 56LL) & 0x200;\n        if ( v3 )\n        {\n          return 0;\n        }\n        else\n        {\n          do\n            v8 = sub_1ABF0(a1, 0x30u);\n          while ( v8 && (unsigned int)sub_1EED0((const char ***)a1, v8) );\n          sub_1C940((__int64 *)(a1 + 288), (_QWORD *)(a1 + 296), v7, *(_DWORD *)(a1 + 296) - 1);\n        }\n        return v3;\n      }\n      return 1;\n    }\nLABEL_21:\n    v3 = 1;\n    v10 = dcgettext(0LL, \"No 'Prev' or 'Up' for this node within this document\", 5);\n    sub_1C2E0((__int64)\"%s\", v10);\n    return v3;\n  }\n  if ( !*(_QWORD *)(v2 + 80) )\n    goto LABEL_21;\n  return (unsigned int)sub_1CEF0(\"Prev\", a1) == 0;\n}\n",
    "function_name": "backward_move_node_structure",
    "decompiled_code": "int __fastcall backward_move_node_structure(WINDOW *window, int behaviour)\n{\n  NODE *node; // r12\n  int v3; // ebx\n  const char *up; // rbx\n  const char *prev; // rdi\n  size_t hist_index; // r12\n  REFERENCE *v8; // rax\n  char *v10; // rax\n\n  node = window->node;\n  v3 = node->flags & 0x50;\n  if ( v3 )\n    return 1;\n  if ( behaviour == 1 )\n    return info_handle_pointer(\"Prev\", window) == 0;\n  if ( behaviour == 2 )\n  {\n    info_error(\"%s\", msg_at_node_top);\n    return 1;\n  }\n  if ( behaviour )\n    return v3;\n  up = node->up;\n  if ( up )\n  {\n    if ( strncasecmp(node->up, \"(dir)\", 5uLL) )\n    {\n      prev = node->prev;\n      if ( !prev || !strcmp(prev, up) )\n        return info_handle_pointer(\"Up\", window) == 0;\n      hist_index = window->hist_index;\n      if ( info_handle_pointer(\"Prev\", window) )\n      {\n        v3 = window->node->flags & 0x200;\n        if ( v3 )\n          return 0;\n        do\n          v8 = select_menu_digit(window, 0x30u);\n        while ( v8 && info_select_reference(window, v8) );\n        cleanup_history((WINDOW *)&window->hist, &window->hist_index, hist_index, LODWORD(window->hist_index) - 1);\n        return v3;\n      }\n      return 1;\n    }\nLABEL_21:\n    v3 = 1;\n    v10 = dcgettext(0LL, \"No 'Prev' or 'Up' for this node within this document\", 5);\n    info_error(\"%s\", v10);\n    return v3;\n  }\n  if ( !node->prev )\n    goto LABEL_21;\n  return info_handle_pointer(\"Prev\", window) == 0;\n}\n",
    "source_code": "static int\nbackward_move_node_structure (WINDOW *window, int behaviour)\n{\n  if (window->node->flags & (N_IsInternal | N_IsManPage))\n    return 1;\n\n  switch (behaviour)\n    {\n    case IS_PageOnly:\n      info_error (\"%s\", msg_at_node_top);\n      return 1;\n\n    case IS_NextOnly:\n      return !info_handle_pointer (\"Prev\", window);\n      break;\n\n    case IS_Continuous:\n      if (window->node->up)\n        {\n          /* If up is the dir node, we are at the top node.\n             Don't do anything. */\n          if (!strncasecmp (window->node->up, \"(dir)\", strlen (\"(dir)\")))\n            {\n              info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n              return 1;\n            }\n          /* If 'Prev' and 'Up' are the same, we are at the first node\n             of the 'Up' node's menu. Go to up node. */\n          else if (window->node->prev\n              && !strcmp(window->node->prev, window->node->up))\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n          /* Otherwise, go to 'Prev' node and go down the last entry\n             in the menus as far as possible. */\n          else if (window->node->prev)\n            {\n              int starting_hist_index = window->hist_index;\n              if (!info_handle_pointer (\"Prev\", window))\n                return 1;\n              if (!(window->node->flags & N_IsIndex))\n                {\n                  while (1)\n                    {\n                      REFERENCE *entry = select_menu_digit (window, '0');\n                      if (!entry)\n                        break;\n                      if (!info_select_reference (window, entry))\n                        break;\n                    }\n                  /* Don't include intermediate nodes in the window's\n                     history.  */\n                  cleanup_history (window, starting_hist_index,\n                                   window->hist_index - 1);\n                }\n            }\n          else /* 'Up' but no 'Prev' */\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n        }\n      else if (window->node->prev) /* 'Prev' but no 'Up' */\n        {\n          if (!info_handle_pointer (\"Prev\", window))\n            return 1;\n        }\n      else\n        {\n          info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n          return 1;\n        }\n\n      break; /* case IS_Continuous: */\n    }\n  return 0;\n}",
    "comment": "Handles backward navigation in a document's node structure based on specified behavior, managing transitions to previous or upward nodes as necessary.",
    "hext5_sum": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
    "bint5_sum": "Processes the `` Prev '' and `` Next '' attributes of a given node , printing relevant messages based on specified string comparisons .\n",
    "cpbcs_sum": "Validates and updates the existence of a linked list based on its parent directory and current leaf depth status.\n",
    "misum_sum": "Sets file attributes for a specified job based on the provided mode and path type, sending a message if found.\n",
    "decom_sum": "Handles navigation commands to move to 'Prev' or 'Up' nodes or display an error message when no such navigation is available.",
    "cfg_sum": "Determines navigation to 'Prev' or 'Up' nodes based on file and directory attributes, updating state and displaying messages when navigation is unavailable.",
    "work_score": {
        "decom": {
            "summary": "Handles navigation commands to move to 'Prev' or 'Up' nodes or display an error message when no such navigation is available.",
            "score": [
                0.8,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function handles navigation to 'Prev' or 'Up' nodes and displays an error when such navigation is unavailable, which aligns with the code logic for IS_NextOnly and IS_Continuous behaviors. However, it omits specific details such as the handling of page-only behavior, conditions for skipping navigation when at the directory node, and the deeper menu traversal in the 'Prev' path. Despite these omissions, the claims made are accurate and grounded in the source code, making the majority of them correct.",
                "The summary accurately states that the function handles navigation to 'Prev' or 'Up' nodes and shows an error when navigation is unavailable, which matches the core behavior. However, it omits key specifics such as the conditional flows based on behaviour types (IS_PageOnly, IS_NextOnly, IS_Continuous), special cases like directory node top detection, history cleanup, and menu traversal logic. Coverage of secondary behavior-critical semantics is weak.",
                "The summary accurately reflects the core purpose of the function \u2014 handling navigation to 'Prev' or 'Up' nodes and issuing an error when such navigation is unavailable. It correctly captures the primary control flow without contradictions. However, it is generic and omits significant detailed behaviors such as the distinction between behaviours (IS_PageOnly, IS_NextOnly, IS_Continuous), handling of special node types, and the deeper continuous navigation logic. No inaccurate claims are present, but informational gain is low due to lack of specificity."
            ]
        },
        "cfg": {
            "summary": "Determines navigation to 'Prev' or 'Up' nodes based on file and directory attributes, updating state and displaying messages when navigation is unavailable.",
            "score": [
                0.5,
                0.3,
                0.5
            ],
            "reason": [
                "The summary captures the general idea of navigating to 'Prev' or 'Up' nodes and showing messages when navigation is unavailable, which matches the code's behavior in handling these pointers and errors. However, it inaccurately mentions 'file and directory attributes' as the basis for decisions, whereas the code relies on node flags and string comparisons to specific node names, not generic file system attributes. This introduces a notable inaccuracy, making the coverage only partially aligned with the source.",
                "The summary loosely references navigation to 'Prev' or 'Up' nodes and error messaging, which partially aligns to the core functionality. However, it inaccurately attributes decisions to file and directory attributes rather than the actual node flags and pointer relationships. It omits key conditional flows for different behaviours, handling of special cases like '(dir)' top node, continuous navigation through menus, history cleanup, and branching for various combinations of 'Prev' and 'Up'. The core purpose is only vaguely captured and lacks specificity about the node-pointer-driven logic.",
                "The summary correctly conveys that the function navigates to 'Prev' or 'Up' nodes and shows messages if navigation is unavailable, which aligns with the core behavior in the source code. However, it inaccurately adds 'based on file and directory attributes', which is not reflected in the code \u2014 the logic is based on node flags, names, and relationships, not general file/directory metadata. This is a semantic mismatch, but not a severe FATAL about the primary purpose. There is little detail on the conditions or branching logic, so the gain is low and noise is noticeable."
            ]
        },
        "comment": {
            "summary": "Handles backward navigation in a document's node structure based on specified behavior, managing transitions to previous or upward nodes as necessary.",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary contains a single generic claim that the function handles backward navigation based on specified behavior and moves to previous or upward nodes. This is broadly accurate according to the code, but it omits many specific and verifiable details such as distinct behavior cases (IS_PageOnly, IS_NextOnly, IS_Continuous) and error handling scenarios. The claim is correct but mostly generic, resulting in high accuracy but low informational depth.",
                "The summary correctly identifies the function\u2019s purpose as handling backward navigation in a document\u2019s node structure with transitions to previous or upward nodes, aligning with the core domain effect in the code. However, it omits several key secondary details such as special handling of internal/manpage nodes, distinct behaviours for IS_PageOnly, IS_NextOnly, and IS_Continuous, error messaging when no navigation is possible, menu traversal to the last entry, and history cleanup. The coverage of the core is present but lacks breadth of critical branches and side effects.",
                "The summary correctly identifies the function\u2019s general purpose of handling backward navigation in a document's node structure and mentions transitions to previous or upward nodes, which aligns with code behavior. However, it remains very high-level and omits key conditional logic, multiple distinct cases for different behaviours (IS_PageOnly, IS_NextOnly, IS_Continuous), and important error handling flows. No factual inaccuracies are present, but the lack of specificity limits informational gain, making the net benefit low."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1120848,
    "strip_function_name": "sub_111A50",
    "strip_decompiled_code": "__m128i *__fastcall sub_111A50(const __m128i *a1, __int64 a2, __int64 a3)\n{\n  __m128i *v4; // rbx\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __m128i v9; // xmm0\n  __int64 v10; // rax\n  __m128i v11; // xmm0\n\n  v4 = (__m128i *)calloc(1uLL, 0x98uLL);\n  if ( v4 )\n  {\n    v5 = gsl_vector_alloc(a3);\n    v4[1].m128i_i64[0] = v5;\n    if ( v5 )\n    {\n      v6 = gsl_vector_alloc(a3);\n      v4[1].m128i_i64[1] = v6;\n      if ( v6 )\n      {\n        v7 = gsl_vector_alloc(a3);\n        v4[4].m128i_i64[0] = v7;\n        if ( v7 )\n        {\n          v8 = gsl_vector_alloc(a2);\n          v4[4].m128i_i64[1] = v8;\n          if ( v8 )\n          {\n            v9 = _mm_loadu_si128(a1);\n            v10 = a1[4].m128i_i64[0];\n            v4->m128i_i64[0] = a2;\n            v4[5] = v9;\n            v4->m128i_i64[1] = a3;\n            v11 = _mm_loadu_si128(a1 + 1);\n            v4[9].m128i_i64[0] = v10;\n            v4[6] = v11;\n            v4[7] = _mm_loadu_si128(a1 + 2);\n            v4[8] = _mm_loadu_si128(a1 + 3);\n          }\n          else\n          {\n            v4 = 0LL;\n            gsl_error(\"failed to allocate space for workn\", \"dogleg.c\", 109LL, 8LL);\n          }\n        }\n        else\n        {\n          v4 = 0LL;\n          gsl_error(\"failed to allocate space for workp\", \"dogleg.c\", 103LL, 8LL);\n        }\n      }\n      else\n      {\n        v4 = 0LL;\n        gsl_error(\"failed to allocate space for dx_sd\", \"dogleg.c\", 97LL, 8LL);\n      }\n    }\n    else\n    {\n      v4 = 0LL;\n      gsl_error(\"failed to allocate space for dx_gn\", \"dogleg.c\", 91LL, 8LL);\n    }\n  }\n  else\n  {\n    gsl_error(\"failed to allocate dogleg state\", \"dogleg.c\", 85LL, 8LL);\n  }\n  return v4;\n}\n",
    "function_name": "dogleg_alloc",
    "decompiled_code": "__m128i *__fastcall dogleg_alloc(const __m128i *a1, __int64 a2, __int64 a3)\n{\n  __m128i *v4; // rbx\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __m128i v9; // xmm0\n  __int64 v10; // rax\n  __m128i v11; // xmm0\n\n  v4 = (__m128i *)calloc(1uLL, 0x98uLL);\n  if ( v4 )\n  {\n    v5 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n    v4[1].m128i_i64[0] = v5;\n    if ( v5 )\n    {\n      v6 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n      v4[1].m128i_i64[1] = v6;\n      if ( v6 )\n      {\n        v7 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n        v4[4].m128i_i64[0] = v7;\n        if ( v7 )\n        {\n          v8 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a2);\n          v4[4].m128i_i64[1] = v8;\n          if ( v8 )\n          {\n            v9 = _mm_loadu_si128(a1);\n            v10 = a1[4].m128i_i64[0];\n            v4->m128i_i64[0] = a2;\n            v4[5] = v9;\n            v4->m128i_i64[1] = a3;\n            v11 = _mm_loadu_si128(a1 + 1);\n            v4[9].m128i_i64[0] = v10;\n            v4[6] = v11;\n            v4[7] = _mm_loadu_si128(a1 + 2);\n            v4[8] = _mm_loadu_si128(a1 + 3);\n          }\n          else\n          {\n            v4 = 0LL;\n            ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n              \"failed to allocate space for workn\",\n              \"dogleg.c\",\n              109LL,\n              8LL);\n          }\n        }\n        else\n        {\n          v4 = 0LL;\n          ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n            \"failed to allocate space for workp\",\n            \"dogleg.c\",\n            103LL,\n            8LL);\n        }\n      }\n      else\n      {\n        v4 = 0LL;\n        ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n          \"failed to allocate space for dx_sd\",\n          \"dogleg.c\",\n          97LL,\n          8LL);\n      }\n    }\n    else\n    {\n      v4 = 0LL;\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"failed to allocate space for dx_gn\",\n        \"dogleg.c\",\n        91LL,\n        8LL);\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"failed to allocate dogleg state\",\n      \"dogleg.c\",\n      85LL,\n      8LL);\n  }\n  return v4;\n}\n",
    "source_code": "\nstatic void *\ndogleg_alloc (const void * params, const size_t n, const size_t p)\n{\n  dogleg_state_t *state;\n  \n  state = calloc(1, sizeof(dogleg_state_t));\n  if (state == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate dogleg state\", GSL_ENOMEM);\n    }\n\n  state->dx_gn = gsl_vector_alloc(p);\n  if (state->dx_gn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_gn\", GSL_ENOMEM);\n    }\n\n  state->dx_sd = gsl_vector_alloc(p);\n  if (state->dx_sd == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_sd\", GSL_ENOMEM);\n    }\n\n  state->workp1 = gsl_vector_alloc(p);\n  if (state->workp1 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp1\", GSL_ENOMEM);\n    }\n\n  state->workp2 = gsl_vector_alloc(p);\n  if (state->workp2 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp2\", GSL_ENOMEM);\n    }\n\n  state->workn = gsl_vector_alloc(n);\n  if (state->workn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workn\", GSL_ENOMEM);\n    }\n\n  state->n = n;\n  state->p = p;\n  state->params = *(const gsl_multilarge_nlinear_parameters *) params;\n\n  return state;\n}",
    "comment": "Allocates memory for a dogleg optimization state and its associated vectors, initializing parameters for nonlinear optimization.",
    "hext5_sum": "a := a + u b^h where u is upper triangular",
    "bint5_sum": "Allocates and initializes a trust_state_t structure and its associated vectors for nonlinear least squares fitting using provided parameters .\n",
    "cpbcs_sum": "Allocates memory for a Levenberg-Marquardt optimization state, including vectors for work, function values, velocity, and acceleration based on provided parameters.\n",
    "misum_sum": "Allocates and initializes a GSL multifit nonlinear workspace with memory for work, vectors and vectors for nonlinear least squares fitting\n",
    "decom_sum": "Allocates and initializes a GSL dogleg solver state with working vectors, copying initial parameters from the provided source structure.",
    "cfg_sum": "Initializes a dogleg state structure by allocating required GSL vectors, copying input data, and reporting allocation errors if any step fails.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a GSL dogleg solver state with working vectors, copying initial parameters from the provided source structure.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function allocates and initializes a GSL dogleg solver state and creates working vectors, which matches the code's calls to gsl_vector_alloc for various fields. It also accurately notes that it copies initial parameters from the provided structure into the state, as seen in the params assignment. All claims are specific, verifiable, and consistent with the source code, with no inaccuracies detected.",
                "The summary correctly identifies the function as allocating and initializing a GSL dogleg solver state and mentions working vectors and copying parameters, which matches the core purpose in the code. However, it omits important secondary details such as the multiple specific vectors allocated with dimensions p and n, and the explicit error handling for memory allocation failures via GSL_ERROR_NULL. Coverage of these behaviors is minimal beyond the core action.",
                "The summary correctly states the primary purpose: allocating and initializing a GSL dogleg solver state and setting up working vectors. It also accurately notes that parameters are copied from the provided structure. All claims align with the code; there are no inaccuracies or contradictions, and the information is specific enough to be useful. Noise is negligible, and the description matches core semantics, offering moderate detail."
            ]
        },
        "cfg": {
            "summary": "Initializes a dogleg state structure by allocating required GSL vectors, copying input data, and reporting allocation errors if any step fails.",
            "score": [
                0.7,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function initializes a dogleg state structure by allocating GSL vectors and reporting allocation errors, which matches the code. However, it inaccurately claims that the function copies input data \u2014 the code casts and dereferences the params pointer into a struct rather than performing a generic data copy. Most elements are accurate, but this incorrect statement reduces overall precision.",
                "The summary accurately captures the core purpose, which is allocating and initializing a dogleg_state_t with required GSL vectors and handling allocation errors. It covers the specific domain action (allocating vectors for dogleg algorithm state) and mentions error handling. However, it is somewhat vague about the exact copying of the parameters (type casting and field assignments) and does not enumerate the specific vectors or distinguish between sizes n and p. Secondary details such as the exact fields initialized and constants used are omitted, making coverage decent but not complete.",
                "The summary accurately states that the function initializes a dogleg state structure, allocates multiple GSL vectors, and reports allocation errors when any allocation fails, which matches the code. It also correctly notes copying input data, which corresponds to assigning the params struct and n/p values. There are no inaccurate claims, and noise is minimal. The claims are specific to the core behavior, providing solid insight into what the function does."
            ]
        },
        "comment": {
            "summary": "Allocates memory for a dogleg optimization state and its associated vectors, initializing parameters for nonlinear optimization.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function allocates memory for a dogleg optimization state and its associated vectors, and that it initializes parameters for nonlinear optimization. These claims match the source code's behavior, which shows allocation of multiple gsl_vector structures for optimization-related work arrays and assignment of parameters. No inaccuracies or irrelevant details are present, making all claims accurate and aligned with the code semantics.",
                "The summary correctly identifies the core purpose as allocating and initializing a dogleg optimization state and its vectors for nonlinear optimization, which matches the code\u2019s main function. However, it lacks mention of important secondary details such as specific vector names, dimensions (n and p), error handling via GSL_ERROR_NULL on allocation failures, and copying of provided parameters. The coverage is therefore limited to the core action with minimal additional behavioral specifics.",
                "The summary correctly states the core purpose: allocating memory for a dogleg optimization state and associated vectors, and initializing parameters, which matches the source code's primary function. It is accurate but generic, lacking specifics about the types and sizes of vectors allocated or the handling of allocation failures. No inaccurate claims are present, and noise is minimal, but the gain is low due to the lack of detailed, verifiable implementation insights."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 259168,
    "strip_function_name": "ngx_os_init",
    "strip_decompiled_code": "__int64 __fastcall ngx_os_init(\n        _QWORD *a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  int v11; // eax\n  unsigned __int64 v12; // rax\n  __int64 i; // rdx\n  __int64 v14; // rax\n  __int64 v15; // rax\n  int *v16; // rax\n  __int64 v17; // r8\n  __int64 v18; // r9\n  __m128 v19; // xmm4\n  __m128 v20; // xmm5\n\n  if ( ngx_os_specific_init() || ngx_init_setproctitle(a1, a2, a3, a4, a5, v9, v10, a8, a9) )\n    return -1LL;\n  v11 = getpagesize();\n  ngx_cacheline_size = 64LL;\n  ngx_pagesize = v11;\n  v12 = (unsigned __int64)v11 >> 1;\n  if ( v12 )\n  {\n    for ( i = ngx_pagesize_shift + 1; ; ++i )\n    {\n      v12 >>= 1;\n      if ( !v12 )\n        break;\n    }\n    ngx_pagesize_shift = i;\n  }\n  v14 = ngx_ncpu;\n  if ( !ngx_ncpu )\n  {\n    v14 = sysconf(84);\n    ngx_ncpu = v14;\n  }\n  if ( v14 <= 0 )\n    ngx_ncpu = 1LL;\n  v15 = sysconf(190);\n  if ( v15 > 0 )\n    ngx_cacheline_size = v15;\n  ngx_cpuinfo();\n  if ( getrlimit64(RLIMIT_NOFILE, &rlmt) == -1 )\n  {\n    if ( *a1 > 1uLL )\n    {\n      v16 = __errno_location();\n      ngx_log_error_core(\n        2uLL,\n        (__int64)a1,\n        *v16,\n        (unsigned int)\"getrlimit(RLIMIT_NOFILE) failed\",\n        v17,\n        v18,\n        a2,\n        a3,\n        a4,\n        a5,\n        v19,\n        v20,\n        a8,\n        a9);\n    }\n    return -1LL;\n  }\n  ngx_inherited_nonblocking = 1LL;\n  ngx_max_sockets = rlmt.rlim_cur;\n  srandom(*(_DWORD *)(ngx_cached_time + 8) ^ *(_DWORD *)ngx_cached_time ^ (ngx_pid << 16));\n  return 0LL;\n}\n",
    "function_name": "ngx_os_init",
    "decompiled_code": "ngx_int_t __fastcall ngx_os_init(ngx_log_t *log)\n{\n  int v1; // eax\n  unsigned __int64 v2; // rax\n  ngx_uint_t i; // rdx\n  __int64 v4; // rax\n  __int64 v5; // rax\n  int *v6; // rax\n\n  if ( ngx_os_specific_init(log) || ngx_init_setproctitle(log) )\n    return -1LL;\n  v1 = getpagesize();\n  ngx_cacheline_size = 64LL;\n  ngx_pagesize = v1;\n  v2 = (unsigned __int64)v1 >> 1;\n  if ( v2 )\n  {\n    for ( i = ngx_pagesize_shift + 1; ; ++i )\n    {\n      v2 >>= 1;\n      if ( !v2 )\n        break;\n    }\n    ngx_pagesize_shift = i;\n  }\n  v4 = ngx_ncpu;\n  if ( !ngx_ncpu )\n  {\n    v4 = sysconf(84);\n    ngx_ncpu = v4;\n  }\n  if ( v4 <= 0 )\n    ngx_ncpu = 1LL;\n  v5 = sysconf(190);\n  if ( v5 > 0 )\n    ngx_cacheline_size = v5;\n  ngx_cpuinfo();\n  if ( getrlimit64(__rlimit_resource::RLIMIT_NOFILE, (struct rlimit64 *)&rlmt) == -1 )\n  {\n    if ( log->log_level > 1 )\n    {\n      v6 = __errno_location();\n      ngx_log_error_core(2uLL, log, *v6, \"getrlimit(RLIMIT_NOFILE) failed\");\n    }\n    return -1LL;\n  }\n  ngx_inherited_nonblocking = 1LL;\n  ngx_max_sockets = rlmt.rlim_cur;\n  srandom(LODWORD(ngx_cached_time->msec) ^ LODWORD(ngx_cached_time->sec) ^ (ngx_pid << 16));\n  return 0LL;\n}\n",
    "source_code": "\n\nngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    ngx_time_t  *tp;\n    ngx_uint_t   n;\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    long         size;\n#endif\n\n#if (NGX_HAVE_OS_SPECIFIC_INIT)\n    if (ngx_os_specific_init(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_init_setproctitle(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_pagesize = getpagesize();\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n    if (ngx_ncpu == 0) {\n        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n#endif\n\n    if (ngx_ncpu < 1) {\n        ngx_ncpu = 1;\n    }\n\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n    if (size > 0) {\n        ngx_cacheline_size = size;\n    }\n#endif\n\n    ngx_cpuinfo();\n\n    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, errno,\n                      \"getrlimit(RLIMIT_NOFILE) failed\");\n        return NGX_ERROR;\n    }\n\n    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n\n#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n    ngx_inherited_nonblocking = 1;\n#else\n    ngx_inherited_nonblocking = 0;\n#endif\n\n    tp = ngx_timeofday();\n    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}",
    "comment": "Initializes operating system parameters, retrieves CPU information, sets process title, and configures resource limits for a server application.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the OS library , sets environment variables , and prepares for cache management in the NGINX framework .\n",
    "cpbcs_sum": "Initializes the system by allocating memory, setting up signal handling and registering system core operations.\n",
    "misum_sum": "Initializes the per-CPU memory management system by allocating memory for the current memory, setting defaults for processor management.\n",
    "decom_sum": "Initializes OS-specific settings for Nginx, determining page size, CPU/cache parameters, limits, and random seed, logging errors if resource queries fail.",
    "cfg_sum": "Initializes OS-specific settings, determines CPU and memory parameters, sets process title, configures file descriptor limits, and seeds randomness, aborting on failure.",
    "work_score": {
        "decom": {
            "summary": "Initializes OS-specific settings for Nginx, determining page size, CPU/cache parameters, limits, and random seed, logging errors if resource queries fail.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately captures the primary functionality: initializing OS-specific settings, determining page size, CPU and cache parameters, checking resource limits, setting a random seed, and logging errors if system queries fail. These details match the source code behavior, with no factual contradictions and no irrelevant noise. All claims are accurate and verifiable from the function\u2019s implementation.",
                "The summary accurately reflects the core purpose of the function\u2014initializing OS-specific settings for Nginx\u2014and captures key details such as determining page size, CPU/cache parameters, limits, and seeding the random number generator. It also mentions logging errors when system resource queries fail, consistent with the code's getrlimit error logging. However, it omits several secondary behaviors, such as conditional handling of OS-specific initialization, setting process title, determining processor count with defaults, adjusting cacheline size conditionally, setting inherited nonblocking mode, and calling ngx_cpuinfo. Overall, the core is covered, but secondary coverage is partial.",
                "The summary correctly captures the primary purpose of the function: initializing OS-specific settings in Nginx. It accurately mentions page size, CPU/cache parameters, resource limits, and random seed initialization, all reflected in the code. Error logging on resource query failure is also correct, referring to the getrlimit check. The claims are specific to the source code behavior without contradictions or irrelevant noise, though they are somewhat high-level and omit finer details like initializing process title and inherited nonblocking flag. Overall, gain is moderate with low noise and no factual errors."
            ]
        },
        "cfg": {
            "summary": "Initializes OS-specific settings, determines CPU and memory parameters, sets process title, configures file descriptor limits, and seeds randomness, aborting on failure.",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary captures multiple key behaviors from the source code accurately: it notes OS-specific initialization, process title setup, CPU and memory parameter determination (pagesize, cacheline size, processor count), file descriptor limit configuration, randomness seeding, and aborting on failure. All these claims directly correspond to operations in the function. There are no contradictory or irrelevant statements, yielding high alignment with the code\u2019s semantics.",
                "The summary correctly identifies the function\u2019s core purpose as initializing OS-specific settings and covers CPU/memory parameters, process title setting, file descriptor limits, and randomness seeding, which match the source code\u2019s behavior. It also notes aborting on failure, reflecting error handling. However, it omits mention of certain secondary details such as cache line size adjustment, page size shift calculation, inherited nonblocking configuration, and the explicit retrieval of CPU info, so coverage of secondary semantics is incomplete.",
                "The summary contains several accurate GOLD-level claims describing the function's core purpose and main operations, such as initializing OS-specific settings, determining CPU/memory parameters, setting the process title, configuring file descriptor limits, and seeding randomness. All these match the source code's behavior, including early returns on error (abort on failure). There is no inaccurate or noisy claim; the statements are specific and tightly aligned with the code, offering clear insight into its domain semantics."
            ]
        },
        "comment": {
            "summary": "Initializes operating system parameters, retrieves CPU information, sets process title, and configures resource limits for a server application.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures several core behaviors of the function, including initializing OS parameters, retrieving CPU information, setting the process title, and configuring resource limits, all of which are supported by the source code. However, it omits other specific steps present in the code, such as page size and cache line size retrieval, processor count handling, and random seeding. Thus, while most claims are accurate, the coverage is incomplete but still above 80% accurate.",
                "The summary correctly notes OS initialization, CPU info retrieval, process title setting, and resource limits configuration, which align with the function's operations. However, it omits the core specific purpose of initializing and configuring system-level parameters like page size, cache line size, processor count, inherited non-block mode, random seeding, and handling errors for system calls. While the core purpose of OS parameter initialization is mentioned, coverage of these numerous critical secondary behaviors is sparse.",
                "The summary contains mostly accurate, high-level claims: it correctly states that the function initializes OS parameters, retrieves CPU information, sets the process title, and configures resource limits. These are consistent with the source code, though they are generic and omit specifics such as page size, cache line size, random seeding, and inherited nonblocking settings. There are no inaccurate or contradictory statements, but the gain is low due to the lack of detailed GOLD information. Noise is minimal."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585363328,
    "strip_function_name": "sub_FFFFFFFF81637580",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81637580(__int64 a1, __int64 a2, int a3, int a4)\n{\n  int v4; // r8d\n  int v5; // ebx\n  __int64 result; // rax\n  __int64 v7; // r9\n  unsigned int v8; // r9d\n  unsigned int v9; // r8d\n  __int64 v10; // rdx\n\n  v4 = *(_DWORD *)(a2 + 64);\n  v5 = v4 - a3;\n  if ( v4 - a3 >= 0 )\n  {\n    result = 1LL;\n    if ( a4 - *(_DWORD *)(a2 + 68) >= 0 )\n      return result;\n  }\n  v7 = *(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200);\n  result = 0LL;\n  if ( *(unsigned __int16 *)(v7 + 4) <= 1u || a3 - *(_DWORD *)(a2 + 68) >= 0 )\n    return result;\n  v8 = *(unsigned __int16 *)(v7 + 2);\n  if ( v5 < 0 )\n  {\n    v9 = a3 - v4;\n    if ( v8 > v9 )\n    {\n      v10 = v8;\n      goto LABEL_12;\n    }\n  }\n  else\n  {\n    v9 = a4 - v4;\n    if ( v8 > v9 )\n      return 4294967274LL;\n  }\n  if ( v9 <= v8 )\n  {\n    v10 = v9;\nLABEL_12:\n    result = sub_FFFFFFFF81641390(a1, a2, v10, v8);\n    if ( (int)result >= 0 )\n      return v5 >= 0;\n    return result;\n  }\n  v10 = v8 * (v9 / v8);\n  if ( v5 >= 0 )\n    goto LABEL_12;\n  if ( v9 <= (unsigned int)v10 )\n    goto LABEL_12;\n  v10 = v8 + (unsigned int)v10;\n  result = 0LL;\n  if ( (unsigned int)v10 < *(_DWORD *)(a2 + 104) )\n    goto LABEL_12;\n  return result;\n}\n",
    "function_name": "tcp_match_skb_to_sack",
    "decompiled_code": "__int64 __fastcall tcp_match_skb_to_sack(\n        __int64 a1,\n        __int64 a2,\n        int a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  int v12; // r8d\n  int v13; // ebx\n  __int64 result; // rax\n  __int64 v15; // r9\n  unsigned int v16; // r9d\n  unsigned int v17; // ecx\n  __int64 v18; // r8\n  __int64 v19; // rdx\n  unsigned int v20; // edx\n\n  v12 = *(_DWORD *)(a2 + 64);\n  v13 = v12 - a3;\n  if ( v12 - a3 >= 0 )\n  {\n    result = 1LL;\n    if ( a4 - *(_DWORD *)(a2 + 68) >= 0 )\n      return result;\n  }\n  v15 = *(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200);\n  result = 0LL;\n  if ( *(unsigned __int16 *)(v15 + 4) <= 1u || a3 - *(_DWORD *)(a2 + 68) >= 0 )\n    return result;\n  v16 = *(unsigned __int16 *)(v15 + 2);\n  if ( v13 < 0 )\n  {\n    v20 = a3 - v12;\n    v18 = v20;\n    if ( v16 > v20 )\n    {\n      v19 = v16;\n      goto LABEL_12;\n    }\n  }\n  else\n  {\n    v17 = a4 - v12;\n    v18 = v17;\n    if ( v16 > v17 )\n      return 4294967274LL;\n  }\n  if ( (unsigned int)v18 <= v16 )\n  {\n    v19 = (unsigned int)v18;\nLABEL_12:\n    result = tcp_fragment(a1, a2, v19, v16, v18, v16, a5, a6, a7, a8, a9, a10, a11, a12);\n    if ( (int)result >= 0 )\n      return v13 >= 0;\n    return result;\n  }\n  v19 = v16 * ((unsigned int)v18 / v16);\n  if ( v13 >= 0 )\n    goto LABEL_12;\n  if ( (unsigned int)v18 <= (unsigned int)v19 )\n    goto LABEL_12;\n  v19 = v16 + (unsigned int)v19;\n  result = 0LL;\n  if ( (unsigned int)v19 < *(_DWORD *)(a2 + 104) )\n    goto LABEL_12;\n  return result;\n}\n",
    "source_code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}",
    "comment": "Determines if a TCP segment belongs to the SACK range and fragments it accordingly based on MSS and sequence numbers.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Validates TCP acknowledgment by checking sequence numbers , sequence numbers , and acknowledgment conditions in a socket buffer .\n",
    "cpbcs_sum": "Validates TCP MSS options in a packet against specified criteria and alignment, returning errors for invalid conditions.\n",
    "misum_sum": "Validates the TCP window size in a connection tracking table and adds it to the appropriate socket.\n",
    "decom_sum": "Determines positional offset validity and performs a block transfer operation based on alignment, boundary checks, and segment size constraints.",
    "cfg_sum": "Validates coordinate offsets against stored limits, processes aligned data blocks, conditionally updates state, and returns success, failure, or specific error codes based on threshold checks.",
    "work_score": {
        "decom": {
            "summary": "Determines positional offset validity and performs a block transfer operation based on alignment, boundary checks, and segment size constraints.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes generic concepts like positional offset validity, block transfer operations, and alignment checks, which do not directly map to the TCP SACK and packet fragmentation logic in the source code. It omits key domain-specific behaviors such as sequence number comparisons, MSS-based fragmentation, and returning error codes, and instead uses vague terminology unrelated to TCP semantics. This makes the claims inaccurate with respect to the actual code functionality.",
                "The summary does not convey the core purpose of checking whether a TCP packet (skb) falls within a SACK (Selective Acknowledgement) range and conditionally fragmenting it to match MSS boundaries. Instead, it vaguely mentions positional offset validity and block transfer operations, which misrepresents the actual network/TCP-specific semantics. No accurate claims in the summary capture the core domain effect or detail critical behaviors like SACK range checks, fragmentation logic, or error handling.",
                "The summary's claims are inaccurate: it describes a 'positional offset validity' check and a 'block transfer operation', which do not match the function's actual purpose of determining if a TCP segment is within a SACK range and possibly fragmenting the skb to align with MSS boundaries. There are no correct, specific domain claims; instead, the statements are generic and misleading about the core behavior. The worst failure mode is FATAL because the primary purpose is misrepresented, making the description unusable for understanding the function."
            ]
        },
        "cfg": {
            "summary": "Validates coordinate offsets against stored limits, processes aligned data blocks, conditionally updates state, and returns success, failure, or specific error codes based on threshold checks.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary makes generic claims about validating coordinate offsets, processing aligned data, and updating state based on thresholds, none of which directly match the function's actual TCP SACK-related logic for matching sequence numbers, fragmenting SKBs, and returning boolean or error values. The statements do not reflect the domain-specific behavior present in the source code, resulting in no accurate claims derived from the actual semantics.",
                "The summary's claims about validating coordinate offsets, processing aligned data blocks, and threshold checks do not correspond to the TCP SACK matching and possible fragmentation logic in the source code. None of the claims accurately reflect the core purpose of determining if a TCP segment fits within a SACK range and splitting it when needed, and no secondary behaviors such as MSS alignment, packet length adjustments, or error handling are correctly mentioned.",
                "The summary's claims about validating coordinate offsets, processing aligned data blocks, and threshold checks do not match the source code, which deals with TCP SACK matching and potential fragmentation of skb data. All listed claims are NOISE, as they target unrelated semantics rather than the function\u2019s actual primary purpose. There are no accurate statements providing insight into the core domain behavior, resulting in no positive gain and overwhelming inaccuracy."
            ]
        },
        "comment": {
            "summary": "Determines if a TCP segment belongs to the SACK range and fragments it accordingly based on MSS and sequence numbers.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary contains two key claims: (1) it determines if a TCP segment belongs to the SACK range, and (2) it fragments it accordingly based on MSS and sequence numbers. Both claims accurately reflect the source code's behavior, as the function checks whether the segment is within the SACK range using sequence comparisons and performs fragmentation logic using MSS and packet length calculations. No inaccuracies or irrelevant details are present.",
                "The summary correctly identifies the core purpose of checking whether a TCP segment falls within a specified SACK range and performing fragmentation based on MSS and sequence numbers, which matches the source code\u2019s primary domain behavior. However, it omits secondary details such as multi-packet segment handling, rounding packet lengths, specific error conditions like returning -EINVAL, and early returns when lengths exceed skb->len. These omissions reduce coverage of critical branch and edge case semantics.",
                "The summary correctly states the core purpose: checking if a TCP segment falls within the SACK range and performing fragmentation based on MSS and sequence numbers. These are accurate reflections of the code\u2019s main logic and inputs/outputs, with no contradicting or irrelevant claims. However, the description is broad and lacks deeper specifics, such as handling partial MSS coverage, return values, or exact fragmentation conditions, which limits informational gain. The absence of noise or fatal inaccuracies keeps it reliable but only moderately useful."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5729178,
    "strip_function_name": "sub_576B9A",
    "strip_decompiled_code": "__int64 __fastcall sub_576B9A(\n        __int64 a1,\n        int a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13)\n{\n  bool v14; // zf\n  __int64 v15; // rdi\n  int v16; // ebx\n  __int64 v17; // rbx\n  _QWORD *v18; // rax\n  int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // rax\n  _QWORD *v23; // r13\n\n  v14 = *(_BYTE *)(a1 + 21) == 0;\n  v15 = *(_QWORD *)a1;\n  if ( v14 )\n  {\n    LODWORD(v17) = *(_DWORD *)(a1 + 8) - ((8 * a2 + 120) & 0xFFFFFF80);\n    if ( (a2 & 0xF) == 0 )\n    {\n      v20 = *(_DWORD *)(a1 + 12);\n      v17 = (int)v17;\n      v21 = (unsigned int)(v20 + 128);\n      *(_DWORD *)(a1 + 12) = v21;\n      v22 = sub_51814E(v15, (const char *)(v20 + 129), v21, a12, a13, a3, a4, a5, a6, a7, a8, a9, a10);\n      *(_QWORD *)a1 = v22;\n      v23 = (_QWORD *)(v22 + 8LL * a2);\n      sub_4004F0(v23 + 16, v23);\n      *(_DWORD *)(a1 + 8) += 128;\n      v18 = v23;\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v16 = *(_DWORD *)(a1 + 8);\n    *(_BYTE *)(a1 + 21) = 0;\n    LODWORD(v17) = v16 - ((8 * a2 + 128) & 0xFFFFFF80);\n  }\n  v17 = (int)v17;\n  v18 = (_QWORD *)(v15 + 8LL * a2);\nLABEL_4:\n  *(_BYTE *)(a1 + 20) = 0;\n  *v18 = v17;\n  return (unsigned int)(a2 + 1);\n}\n",
    "function_name": "o_save_ptr_helper",
    "decompiled_code": "__int64 __fastcall o_save_ptr_helper(\n        __int64 a1,\n        int a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10,\n        __int64 a11,\n        __int64 a12,\n        unsigned __int64 a13)\n{\n  bool v14; // zf\n  const char *v15; // rdi\n  int v16; // ebx\n  __int64 v17; // rbx\n  char *v18; // rax\n  int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // rax\n  __int64 v23; // r13\n\n  v14 = *(_BYTE *)(a1 + 21) == 0;\n  v15 = *(const char **)a1;\n  if ( v14 )\n  {\n    LODWORD(v17) = *(_DWORD *)(a1 + 8) - ((8 * a2 + 120) & 0xFFFFFF80);\n    if ( (a2 & 0xF) == 0 )\n    {\n      v20 = *(_DWORD *)(a1 + 12);\n      v17 = (int)v17;\n      v21 = (unsigned int)(v20 + 128);\n      *(_DWORD *)(a1 + 12) = v21;\n      xrealloc(v15, v20 + 129, v21, a12, a13, a3, a4, a5, a6, a7, a8, a9, a10);\n      *(_QWORD *)a1 = v22;\n      v23 = v22 + 8LL * a2;\n      memmove((void *)(v23 + 128), (const void *)v23, (int)v17);\n      *(_DWORD *)(a1 + 8) += 128;\n      v18 = (char *)v23;\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v16 = *(_DWORD *)(a1 + 8);\n    *(_BYTE *)(a1 + 21) = 0;\n    LODWORD(v17) = v16 - ((8 * a2 + 128) & 0xFFFFFF80);\n  }\n  v17 = (int)v17;\n  v18 = (char *)&v15[8 * a2];\nLABEL_4:\n  *(_BYTE *)(a1 + 20) = 0;\n  *(_QWORD *)v18 = v17;\n  return (unsigned int)(a2 + 1);\n}\n",
    "source_code": "static int o_save_ptr_helper(o_string *o, int n)\n{\n\tchar **list = (char**)o->data;\n\tint string_start;\n\tint string_len;\n\n\tif (!o->has_empty_slot) {\n\t\tstring_start = ((n + 0xf) & ~0xf) * sizeof(list[0]);\n\t\tstring_len = o->length - string_start;\n\t\tif (!(n & 0xf)) { /* 0, 0x10, 0x20...? */\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (growing)\\n\", n, string_len, string_start);\n\t\t\t/* list[n] points to string_start, make space for 16 more pointers */\n\t\t\to->maxlen += 0x10 * sizeof(list[0]);\n\t\t\to->data = xrealloc(o->data, o->maxlen + 1);\n\t\t\tlist = (char**)o->data;\n\t\t\tmemmove(list + n + 0x10, list + n, string_len);\n\t\t\to->length += 0x10 * sizeof(list[0]);\n\t\t} else {\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d\\n\",\n\t\t\t\t\tn, string_len, string_start);\n\t\t}\n\t} else {\n\t\t/* We have empty slot at list[n], reuse without growth */\n\t\tstring_start = ((n+1 + 0xf) & ~0xf) * sizeof(list[0]); /* NB: n+1! */\n\t\tstring_len = o->length - string_start;\n\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (empty slot)\\n\",\n\t\t\t\tn, string_len, string_start);\n\t\to->has_empty_slot = 0;\n\t}\n\to->has_quoted_part = 0;\n\tlist[n] = (char*)(uintptr_t)string_len;\n\treturn n + 1;\n}",
    "comment": "Reallocates string storage for a list, handles empty slots, and updates the length and state of the string data structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adjusts the position of a pipe or retrieves its current position , ensuring it remains within valid boundaries for reading or writing .\n",
    "cpbcs_sum": "Allocates a buffer, copies a character from a linked list, and resets buffer sizes in an HTTP caching state.\n",
    "misum_sum": "Allocates a new nameserver buffer, dynamically resizing the next URB if necessary, and updates the last segment position accordingly.\n",
    "decom_sum": "Allocates or updates an entry in a table, initializes its contents, and records a size-adjusted offset before incrementing the entry index.",
    "cfg_sum": "Updates structured buffer state by recalculating aligned offsets, conditionally reinitializing entries, clearing flags, and storing updated values before returning the next index.",
    "work_score": {
        "decom": {
            "summary": "Allocates or updates an entry in a table, initializes its contents, and records a size-adjusted offset before incrementing the entry index.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function allocates or updates a table entry, initializes its contents, records a size-adjusted offset, and increments the index. While the function does update entries in a pointer list and may reallocate space (allocation when growing), it does not initialize 'contents' in the typical sense\u2014rather, it shifts memory and sets a pointer value to a length. The 'size-adjusted offset' description is vague and only loosely aligns with computing string_start and string_len. Overall, only some elements are accurate; others are generic or imprecise, making the claim partially aligned with the code.",
                "The summary gives a vague, generic description of adding or updating a table entry but fails to capture the core operation: managing a list of string pointers in an o_string structure with conditional growth or reuse depending on has_empty_slot, adjusting memory layout via realloc and memmove, and setting specific flags. It misses the conditional branch logic, pointer arithmetic for offsets, and debug logging present in the source. Secondary details such as memory expansion by blocks of 16 pointers and flag resets are also absent.",
                "The summary is mostly inaccurate regarding the core function's behavior. The source code shows logic for managing a list of string pointers in an o_string structure, with conditional growth or reuse of slots, handling offsets and lengths, and setting flags. The summary's claims about initializing contents and recording a size-adjusted offset are vague and misleading; 'allocates or updates an entry in a table' does not capture the specific domain of growing/reusing pointer slots tied to string storage. This misrepresentation affects the primary purpose and I/O, making it a FATAL error with minimal accurate detail and low net benefit."
            ]
        },
        "cfg": {
            "summary": "Updates structured buffer state by recalculating aligned offsets, conditionally reinitializing entries, clearing flags, and storing updated values before returning the next index.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary includes several claims: recalculating aligned offsets [ACCURATE], conditionally reinitializing entries [INACCURATE, since the code grows or reuses slots rather than reinitializing], clearing flags [ACCURATE for has_empty_slot and has_quoted_part], storing updated values [ACCURATE as list[n] is set], and returning the next index [ACCURATE]. Four out of five claims accurately reflect the code, leading to a high accuracy proportion.",
                "The summary correctly describes recalculating aligned offsets and clearing flags, which matches parts of the function logic, but it misses the core primary purpose of expanding or reusing the pointer list within an o_string structure depending on whether an empty slot exists. It omits critical details like conditional memory reallocation, pointer shifting via memmove, adjustments to maxlen/length, and specific branch handling, resulting in incomplete coverage of key secondary semantics.",
                "The summary captures some generic behavior such as recalculating aligned offsets and updating values before returning the next index, which broadly aligns with the code. However, it omits specific and critical details like the conditional growth of the pointer list, handling of empty slots without growth, and the use of reallocation and memmove. No claims are outright incorrect (no FATAL), but the statements are overly generic (SAFE) and lack the higher specificity that would aid an engineer. The main shortcoming is low informational gain, with noise/generic phrasing outweighing precise GOLD insights."
            ]
        },
        "comment": {
            "summary": "Reallocates string storage for a list, handles empty slots, and updates the length and state of the string data structure.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures core behaviors: reallocating storage for the list, handling empty slots, and updating length/state, all of which are present in the source code. However, it is quite generic and omits specifics such as the condition-based growth by fixed increments, pointer shifting via memmove, and resetting certain flags. Still, the majority of its claims are accurate and relevant to the function\u2019s semantics.",
                "The summary correctly notes that the function reallocates string storage, handles empty slots, and updates length/state, which aligns with the core purpose of expanding and managing the pointer list in the `o_string` structure. However, it lacks specificity about the 16-pointer growth increments, the calculated `string_start` offsets, and the use of memmove to reposition existing elements. Important branch details and exact conditions triggering growth versus reuse are omitted, reducing coverage of behavior-critical semantics.",
                "The summary accurately captures the primary purpose: reallocating storage when needed, handling empty slots, and updating the structure's state. These are supported by the code\u2019s logic, which conditionally grows the pointer list using xrealloc, reuses empty slots, and modifies fields like length and has_empty_slot/has_quoted_part. The claims are generic and omit specifics such as alignment to multiples of 16, pointer shifting with memmove, and exact changes to maxlen. There is no inaccurate or contradictory detail (no FATAL), but the gain is low due to broadness and lack of mention of key implementation specifics."
            ]
        }
    }
}
{
    "project_name": "datamash",
    "function_addr": 31920,
    "strip_function_name": "sub_7CB0",
    "strip_decompiled_code": "void __fastcall sub_7CB0(void *ptr)\n{\n  __int64 v1; // r12\n  unsigned __int64 v2; // rbp\n  void *v4; // rdi\n  bool v5; // zf\n  __int64 v6; // r12\n  unsigned __int64 v7; // rbp\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  void *v10; // r13\n  void **v11; // rbp\n  void **v12; // r12\n  void *v13; // rdi\n\n  if ( !ptr )\n    __assert_fail(\"p != NULL\", \"src/op-parser.c\", 0x319u, \"datamash_ops_free\");\n  v1 = 0LL;\n  v2 = 0LL;\n  while ( *((_QWORD *)ptr + 2) > v2 )\n  {\n    ++v2;\n    v4 = *(void **)(*((_QWORD *)ptr + 1) + v1 + 16);\n    v1 += 24LL;\n    free(v4);\n  }\n  free(*((void **)ptr + 1));\n  v5 = *((_QWORD *)ptr + 5) == 0LL;\n  *((_QWORD *)ptr + 1) = 0LL;\n  if ( !v5 )\n  {\n    v6 = 0LL;\n    v7 = 0LL;\n    do\n    {\n      ++v7;\n      v8 = v6 + *((_QWORD *)ptr + 4);\n      v6 += 192LL;\n      sub_96F0(v8);\n    }\n    while ( *((_QWORD *)ptr + 5) > v7 );\n  }\n  free(*((void **)ptr + 4));\n  v9 = qword_222938;\n  *((_QWORD *)ptr + 4) = 0LL;\n  v10 = qword_222948;\n  if ( v9 )\n  {\n    v11 = (void **)((char *)qword_222948 + 16);\n    v12 = (void **)((char *)qword_222948 + 32 * v9 + 16);\n    do\n    {\n      v13 = *v11;\n      v11 += 4;\n      free(v13);\n    }\n    while ( v12 != v11 );\n  }\n  free(v10);\n  qword_222948 = 0LL;\n  qword_222940 = 0LL;\n  qword_222938 = 0LL;\n  free(qword_222930);\n  qword_222928 = 0LL;\n  qword_222920 = 0LL;\n  free(ptr);\n}\n",
    "function_name": "datamash_ops_free",
    "decompiled_code": "void __fastcall datamash_ops_free(datamash_ops *p)\n{\n  __int64 v1; // r12\n  size_t i; // rbp\n  char *name; // rdi\n  bool v5; // zf\n  __int64 v6; // r12\n  size_t v7; // rbp\n  fieldop *v8; // rdi\n  size_t v9; // rax\n  parser_field_t *v10; // r13\n  char **p_name; // rbp\n  char **v12; // r12\n  char *v13; // rdi\n\n  if ( p )\n  {\n    v1 = 0LL;\n    for ( i = 0LL; p->num_grps > i; ++i )\n    {\n      name = p->grps[v1++].name;\n      ((void (__fastcall *)(char *))unk_28E0)(name);\n    }\n    ((void (__fastcall *)(group_column_t *))unk_28E0)(p->grps);\n    v5 = p->num_ops == 0;\n    p->grps = 0LL;\n    if ( !v5 )\n    {\n      v6 = 0LL;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        v8 = &p->ops[v6++];\n        field_op_free(v8);\n      }\n      while ( p->num_ops > v7 );\n    }\n    ((void (__fastcall *)(fieldop *))unk_28E0)(p->ops);\n    v9 = fields_used;\n    p->ops = 0LL;\n    v10 = fields;\n    if ( v9 )\n    {\n      p_name = &fields->name;\n      v12 = &fields[v9].name;\n      do\n      {\n        v13 = *p_name;\n        p_name += 4;\n        ((void (__fastcall *)(char *))unk_28E0)(v13);\n      }\n      while ( v12 != p_name );\n    }\n    ((void (__fastcall *)(parser_field_t *))unk_28E0)(v10);\n    fields = 0LL;\n    fields_alloc = 0LL;\n    fields_used = 0LL;\n    ((void (__fastcall *)(parser_param_t *))unk_28E0)(params);\n    params_alloc = 0LL;\n    params_used = 0LL;\n    JUMPOUT(0x28E0LL);\n  }\n  __assert_fail(\"p != NULL\", \"src/op-parser.c\", 0x319u, \"datamash_ops_free\");\n}\n",
    "source_code": "\nvoid\ndatamash_ops_free ( struct datamash_ops* p )\n{\n  assert (p != NULL);                            /* LCOV_EXCL_LINE */\n  for (size_t i=0; i<p->num_grps; ++i)\n    free (p->grps[i].name);\n  free (p->grps);\n  p->grps = NULL;\n\n  #ifndef _STANDALONE_\n  for (size_t i=0; i<p->num_ops; ++i)\n    field_op_free (&p->ops[i]);\n  #endif\n\n  free (p->ops);\n  p->ops = NULL;\n\n  for  (size_t i=0; i<_fields_used; ++i) {\n    free (_fields[i].name);\n  }\n  free (_fields);\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  free (_params);\n  _params_alloc = 0;\n  _params_used = 0;\n\n  free (p);\n}",
    "comment": "Frees allocated memory for operation groups, fields, parameters, and the datamash_ops structure while ensuring no memory leaks occur.",
    "hext5_sum": "add a value (from input) to the current field operation.",
    "bint5_sum": "Frees all allocated memory associated with the ` datamash_ops ` structure and its associated data structures .\n",
    "cpbcs_sum": "Frees all allocated memory for a DFA structure and its associated variables in a thread-safe manner.\n",
    "misum_sum": "Frees all memory allocated for all types and their associated resources when the count exceeds the defined limit.\n",
    "decom_sum": "Frees all dynamically allocated structures and global buffers associated with datamash operations, including nested elements, then releases the main operation parser object.",
    "cfg_sum": "Frees all dynamically allocated structures related to operation parsing, resets associated pointers and counters, and clears relevant global state variables.",
    "work_score": {
        "decom": {
            "summary": "Frees all dynamically allocated structures and global buffers associated with datamash operations, including nested elements, then releases the main operation parser object.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function frees all dynamically allocated structures related to datamash operations, including nested elements, and then frees the main struct, which matches the code's freeing of group names, ops, global buffers, and the final struct. These claims are accurate and directly align with the code behavior, with no incorrect or irrelevant information present.",
                "The summary accurately captures the core purpose of the function, which is to free all dynamically allocated structures, including nested elements, global buffers, and ultimately the main datamash_ops object. It aligns with the code\u2019s core behavior of releasing group names, groups, operation fields, parameters, and the main struct. However, it does not mention specific secondary behaviors like setting pointers to NULL, resetting counters (_fields_alloc/_fields_used/_params_alloc/_params_used), the conditional freeing of ops via field_op_free when not standalone, or the assert check for non-null input, leading to incomplete coverage of behavior-critical semantics.",
                "The summary correctly states that the function frees dynamically allocated structures and global buffers related to datamash operations, matches the freeing of nested elements like group names and ops, and indicates that it releases the main struct at the end. All claims are accurate and aligned with the code\u2019s domain semantics, with no contradictory or irrelevant statements. While the summary is high-level and generic, it still captures the core purpose and main steps without noise or errors."
            ]
        },
        "cfg": {
            "summary": "Frees all dynamically allocated structures related to operation parsing, resets associated pointers and counters, and clears relevant global state variables.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly captures the essential behavior of the function: it frees dynamically allocated memory for groups, operations, and associated fields, resets pointers to NULL, and clears relevant counters and global state variables. These details align closely with the source code\u2019s operations, indicating that all claims are accurate and specific to the code\u2019s semantics.",
                "The summary accurately describes the core purpose of the function, which is freeing dynamically allocated structures related to operations and resetting pointers, counters, and global state. This matches the code\u2019s behavior of releasing memory for groups, operations, global fields, and parameters, and setting related pointers and counters to null or zero. However, it lacks detail on specific entities freed (like grps, ops, _fields, _params) and conditional freeing via field_op_free, thus secondary coverage is only moderate.",
                "The summary accurately reflects the core behavior: it describes freeing allocated structures related to operations, resetting pointers and counters, and clearing relevant global state, which matches the code's repeated freeing of group and operation arrays, setting them to NULL, and resetting global fields and params state variables. There are no incorrect (FATAL) claims, and no overwhelming noise; however, the gain is moderate because the description is general and lacks explicit details of specific fields or data members freed."
            ]
        },
        "comment": {
            "summary": "Frees allocated memory for operation groups, fields, parameters, and the datamash_ops structure while ensuring no memory leaks occur.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function frees memory for operation groups, fields, parameters, and the datamash_ops structure, matching the source code\u2019s explicit calls to free() and setting pointers to NULL. The mention of preventing memory leaks is slightly interpretive but consistent with the code\u2019s clearing of pointers and counters. All claims align with the code\u2019s semantics, making them accurate.",
                "The summary accurately conveys the core purpose of the function: freeing allocated memory for operation groups, fields, parameters, and the main datamash_ops structure. This matches the code\u2019s main domain action. However, it omits secondary specifics such as setting pointers to NULL, resetting allocation/usage counters, the conditional freeing of field operations under the _STANDALONE_ guard, and the assert check for a non-NULL pointer. These omissions reduce coverage of behavior-critical details.",
                "The summary correctly states that the function frees allocated memory for operation groups, fields, parameters, and the datamash_ops structure, which matches the source code's behavior. However, the claim about 'ensuring no memory leaks occur' is generic and boilerplate rather than a verifiable specific guarantee; it's implied rather than explicitly enforced by additional checks in the code. No inaccurate statements or contradictions are present, but the description lacks deeper detail about conditional freeing logic or resetting of related state variables. Gains are low due to its general wording and absence of nuanced specifics."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4524560,
    "strip_function_name": "sub_450A10",
    "strip_decompiled_code": "__int64 __fastcall sub_450A10(__int64 a1)\n{\n  __int64 v1; // rbp\n  __int64 v2; // r8\n  char v3; // al\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int v6; // eax\n  __int64 v7; // [rsp+8h] [rbp-30h]\n  __int64 v8[4]; // [rsp+18h] [rbp-20h] BYREF\n\n  v1 = *(_QWORD *)(a1 + 40);\n  v8[0] = 0LL;\n  v2 = *(_QWORD *)(v1 + 296);\n  if ( !v2 )\n    return 1LL;\n  if ( *(char ***)(v2 + 104) == &off_70B6D0 )\n    goto LABEL_12;\n  v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n  if ( !v3 )\n    goto LABEL_12;\n  if ( v3 != 64 )\n  {\nLABEL_5:\n    if ( v3 == (char)0x80 )\n    {\n      v7 = v2;\n      v6 = sub_4509B0(a1);\n      v2 = v7;\n      if ( !v6 )\n        goto LABEL_12;\n    }\n    result = sub_490F80(a1, *(_QWORD *)(a1 + 80), (int)\"__GNU_EH_FRAME_HDR\", 1, v2, 0, 0LL, 0, 0, (__int64)v8);\n    if ( !(_DWORD)result )\n      return result;\n    v5 = v8[0];\n    *(_BYTE *)(v8[0] + 99) |= 2u;\n    *(_BYTE *)(v5 + 97) = 2;\n    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8LL) + 864LL)\n                                                      + 432LL))(\n      a1,\n      v5,\n      1LL);\n    if ( !*(_DWORD *)(v1 + 308) )\n      *(_DWORD *)(v1 + 324) = 1;\n    return 1LL;\n  }\n  if ( (unsigned int)sub_450950(a1) )\n  {\n    v2 = *(_QWORD *)(v1 + 296);\n    v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n    goto LABEL_5;\n  }\n  v2 = *(_QWORD *)(v1 + 296);\nLABEL_12:\n  *(_DWORD *)(v2 + 32) |= 0x8000u;\n  result = 1LL;\n  *(_QWORD *)(v1 + 296) = 0LL;\n  return result;\n}\n",
    "function_name": "_bfd_elf_maybe_strip_eh_frame_hdr",
    "decompiled_code": "bfd_boolean __fastcall bfd_elf_maybe_strip_eh_frame_hdr(bfd_link_info *info)\n{\n  bfd_link_hash_table *hash; // rbp\n  __int64 newfunc; // r8\n  char v3; // al\n  bfd_boolean result; // eax\n  bfd_link_hash_entry *v5; // rsi\n  bfd_boolean v6; // eax\n  __int64 v7; // [rsp+8h] [rbp-30h]\n  bfd_link_hash_entry *bh_0; // [rsp+18h] [rbp-20h] BYREF\n\n  hash = info->hash;\n  bh_0 = 0LL;\n  newfunc = (__int64)hash[4].table.newfunc;\n  if ( !newfunc )\n    return 1;\n  if ( *(_QWORD *)(newfunc + 104) == 7386832LL )\n    goto LABEL_12;\n  v3 = *((_BYTE *)info + 3) & 0xC0;\n  if ( !v3 )\n    goto LABEL_12;\n  if ( v3 != 64 )\n  {\nLABEL_5:\n    if ( v3 == (char)0x80 )\n    {\n      v7 = newfunc;\n      v6 = bfd_elf_eh_frame_entry_present(info);\n      newfunc = v7;\n      if ( !v6 )\n        goto LABEL_12;\n    }\n    result = bfd_generic_link_add_one_symbol(\n               (__int64)info,\n               (__int64)info->output_bfd,\n               &byte_4C719F[15],\n               1u,\n               newfunc,\n               0LL,\n               0LL,\n               0,\n               0LL,\n               &bh_0);\n    if ( !result )\n      return result;\n    v5 = bh_0;\n    BYTE3(bh_0[1].u.c.p) |= 2u;\n    BYTE1(v5[1].u.c.p) = 2;\n    (*((void (__fastcall **)(bfd_link_info *, bfd_link_hash_entry *, __int64))info->output_bfd->xvec->backend_data + 54))(\n      info,\n      v5,\n      1LL);\n    if ( !HIDWORD(hash[4].table.memory) )\n      *((_DWORD *)&hash[4].table + 9) = 1;\n    return 1;\n  }\n  if ( bfd_elf_eh_frame_present(info) )\n  {\n    newfunc = (__int64)hash[4].table.newfunc;\n    v3 = *((_BYTE *)info + 3) & 0xC0;\n    goto LABEL_5;\n  }\n  newfunc = (__int64)hash[4].table.newfunc;\nLABEL_12:\n  *(_DWORD *)(newfunc + 32) |= 0x8000u;\n  result = 1;\n  hash[4].table.newfunc = 0LL;\n  return result;\n}\n",
    "source_code": "\nbfd_boolean\n_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *htab;\n  struct eh_frame_hdr_info *hdr_info;\n  struct bfd_link_hash_entry *bh = NULL;\n  struct elf_link_hash_entry *h;\n\n  htab = elf_hash_table (info);\n  hdr_info = &htab->eh_info;\n  if (hdr_info->hdr_sec == NULL)\n    return TRUE;\n\n  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section)\n      || info->eh_frame_hdr_type == 0\n      || (info->eh_frame_hdr_type == DWARF2_EH_HDR\n\t  && !_bfd_elf_eh_frame_present (info))\n      || (info->eh_frame_hdr_type == COMPACT_EH_HDR\n\t  && !_bfd_elf_eh_frame_entry_present (info)))\n    {\n      hdr_info->hdr_sec->flags |= SEC_EXCLUDE;\n      hdr_info->hdr_sec = NULL;\n      return TRUE;\n    }\n\n  /* Add a hidden symbol so that systems without access to PHDRs can\n     find the table.  */\n  if (! (_bfd_generic_link_add_one_symbol\n\t (info, info->output_bfd, \"__GNU_EH_FRAME_HDR\", BSF_LOCAL,\n\t  hdr_info->hdr_sec, 0, NULL, FALSE, FALSE, &bh)))\n    return FALSE;\n\n  h = (struct elf_link_hash_entry *) bh;\n  h->def_regular = 1;\n  h->other = STV_HIDDEN;\n  get_elf_backend_data\n    (info->output_bfd)->elf_backend_hide_symbol (info, h, TRUE);\n\n  if (!hdr_info->frame_hdr_is_compact)\n    hdr_info->u.dwarf.table = TRUE;\n  return TRUE;\n}",
    "comment": "Modifies the header section flags and adds a hidden symbol if specific conditions for EH frame header presence are not met.",
    "hext5_sum": "returns the number of operands rather than calculating it every time.",
    "bint5_sum": "Determines if a relocation should be forcibly applied based on its type and associated flags in the ELF binary .\n",
    "cpbcs_sum": "Issues a critical operation on an ISO image if conditions are met, handling specific conditions for the specified drive.\n",
    "misum_sum": "Marks the immediate as dirty, updates its attributes based on the section of the specified ELF backend data.\n",
    "decom_sum": "Processes the `__GNU_EH_FRAME_HDR` section for an object, updating related flags and invoking a handler, or marks the section invalid if checks fail.",
    "cfg_sum": "Processes unwind frame header data, validates flags, updates related memory structures, triggers a callback, and marks completion status for the associated object.",
    "work_score": {
        "decom": {
            "summary": "Processes the `__GNU_EH_FRAME_HDR` section for an object, updating related flags and invoking a handler, or marks the section invalid if checks fail.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains one main claim: that the function processes the `__GNU_EH_FRAME_HDR` section, updates flags, invokes a handler, or marks it invalid if checks fail. While it touches on the function's general purpose and flag manipulation, it conflates the section being processed with a symbol name rather than the actual `hdr_sec` section, and does not accurately describe the multiple conditional checks involving section type and EH frame presence. It omits critical details, such as adding a hidden symbol and setting compact/dwarf table flags. The inaccuracy in naming and incomplete representation mean less than half of the claim is accurate.",
                "The core purpose\u2014conditionally stripping the .eh_frame_hdr section based on section type and EH header presence, or adding a hidden __GNU_EH_FRAME_HDR symbol so systems without PHDRs can locate the table\u2014is only vaguely addressed. The summary misrepresents the action as 'processing' the section and 'invoking a handler,' which is inaccurate and omits specificity about the checks, symbol creation, hidden visibility settings, and updates to hdr_info fields. Key branches and side effects are missing or distorted.",
                "The summary contains a key inaccuracy: it describes processing the `__GNU_EH_FRAME_HDR` section, but the code processes the section referenced in `hdr_info->hdr_sec`, only later adding a symbol named `__GNU_EH_FRAME_HDR`. It omits crucial control logic such as the conditional exclusion of the section based on several checks, and the behavior when adding a hidden symbol and modifying its properties. The 'invoking a handler' is vague and does not clearly map to the backend hide symbol call, introducing noise. Overall, inaccuracies affect the primary purpose, reducing trustworthiness."
            ]
        },
        "cfg": {
            "summary": "Processes unwind frame header data, validates flags, updates related memory structures, triggers a callback, and marks completion status for the associated object.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary contains mostly generic and inaccurate statements. While it vaguely references processing unwind frame header data, it incorrectly describes the function as triggering a callback and marking completion status, which are not present in the source code. It omits key accurate specifics like conditions for excluding the header section, adding a hidden symbol, and setting table flags. Most claims either do not target actual code semantics or contradict them, resulting in low accuracy.",
                "The summary does not capture the core purpose of conditionally stripping and setting up the ELF .eh_frame_hdr section including hiding symbols and marking table presence. It instead gives vague, generic language about processing data, validating flags, and triggering a callback without referencing ELF structures, section exclusion, symbol visibility changes, or compact/dwarf table handling. No accurate claim covers the specific domain operation or critical branching logic from the code.",
                "The summary contains mostly inaccurate or overly generic claims. It fails to capture the specific core logic in the source code, such as conditional exclusion of the header section, adding a hidden symbol, and managing section flags. Phrases like 'triggers a callback' and 'marks completion status' do not correspond to actual operations, making them NOISE. There are no specific GOLD-level details about the function\u2019s primary purpose, leading to low net benefit with noise outweighing accuracy."
            ]
        },
        "comment": {
            "summary": "Modifies the header section flags and adds a hidden symbol if specific conditions for EH frame header presence are not met.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary captures part of the function's behavior, specifically that it modifies the header section flags and adds a hidden symbol, but it inaccurately ties the hidden symbol addition to the absence of EH frame header conditions. In the source, the hidden symbol is added when certain conditions are not met regarding excluding the header section, not strictly based on EH frame header absence. Additionally, it omits other important logic, such as conditionally excluding the section and setting the dwarf table flag. Overall, fewer than half of the claims are precise and aligned with the code.",
                "The summary inaccurately describes the core behavior. The function's primary purpose is to determine whether to strip the EH frame header section based on specific conditions and, if retained, add a hidden symbol to allow lookup without PHDRs. The summary claims these actions occur when EH frame header presence conditions are not met, which reverses the actual logic\u2014modification and symbol addition happen when the header remains, not when it is absent. This misrepresents the core operation and omits several key details like the exclusion flag setting, handling compact vs. DWARF EH headers, and maintaining the DWARF table flag.",
                "The summary incorrectly states that the function adds a hidden symbol when conditions for EH frame header presence are not met, whereas in the source code, adding the hidden symbol occurs only when those conditions are met and the header section is retained. This is a FATAL error concerning the primary purpose and control flow of the function. The rest of the summary is too generic and omits crucial details such as the exact conditions checked and flag modifications, yielding low gain."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 39007,
    "strip_function_name": "sub_985F",
    "strip_decompiled_code": "__int64 __fastcall sub_985F(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+18h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+30h] [rbp-40h]\n  int v9[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v10[4]; // [rsp+50h] [rbp-20h] BYREF\n  int v11; // [rsp+54h] [rbp-1Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-18h]\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  sub_4EC0((__int64)v10, *(_QWORD *)(a1 + 8), abs32(*(_DWORD *)(a1 + 4)));\n  if ( ((v11 != 0) & (unsigned int)*v12) == 0 )\n    __assert_fail(\"mpz_odd_p (n)\", \"mini-gmp/mini-gmp.c\", 0xD88u, \"gmp_stronglucas\");\n  if ( sub_8DB1((int *)a2, (__int64)v10, 2uLL) )\n    return 0LL;\n  if ( *(_DWORD *)(a2 + 4) == 1 )\n    v3 = **(_QWORD **)(a2 + 8) - 1LL;\n  else\n    v3 = -1LL;\n  v7 = v3;\n  v6 = 3LL;\n  do\n  {\n    if ( v6 >= v7 )\n    {\n      if ( v6 == -1LL )\n        return 1LL;\n      else\n        return 2LL;\n    }\n    v6 += 2LL;\n    v8 = sub_74BB((__int64)v10, v6);\n    if ( !v8 )\n      return 0LL;\n  }\n  while ( (unsigned int)sub_92C2(v8, v6) == 1 );\n  sub_4834((__int64)v9);\n  v5 = sub_B280(v10, 0LL);\n  if ( (v6 & 2) != 0 )\n    v4 = (v6 >> 2) + 1;\n  else\n    v4 = -(__int64)(v6 >> 2);\n  if ( !sub_955F(v9, (int *)a2, v4, v5, (__int64)v10) )\n  {\n    while ( v9[1] )\n    {\n      if ( !--v5 )\n        break;\n      sub_94D4(v9, (int *)a2, (__int64)v10);\n    }\n  }\n  sub_48C3((__int64)v9);\n  return v5 != 0;\n}\n",
    "function_name": "gmp_stronglucas",
    "decompiled_code": "__int64 __fastcall gmp_stronglucas(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+18h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+30h] [rbp-40h]\n  int v9[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v10[4]; // [rsp+50h] [rbp-20h] BYREF\n  int v11; // [rsp+54h] [rbp-1Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-18h]\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  mpz_roinit_normal_n((__int64)v10, *(_QWORD *)(a1 + 8), abs32(*(_DWORD *)(a1 + 4)));\n  if ( ((v11 != 0) & (unsigned int)*v12) == 0 )\n    __assert_fail(\"mpz_odd_p (n)\", \"mini-gmp/mini-gmp.c\", 0xD88u, \"gmp_stronglucas\");\n  if ( mpz_root((int *)a2, (__int64)v10, 2uLL) )\n    return 0LL;\n  if ( *(_DWORD *)(a2 + 4) == 1 )\n    v3 = **(_QWORD **)(a2 + 8) - 1LL;\n  else\n    v3 = -1LL;\n  v7 = v3;\n  v6 = 3LL;\n  do\n  {\n    if ( v6 >= v7 )\n    {\n      if ( v6 == -1LL )\n        return 1LL;\n      else\n        return 2LL;\n    }\n    v6 += 2LL;\n    v8 = mpz_tdiv_ui((__int64)v10, v6);\n    if ( !v8 )\n      return 0LL;\n  }\n  while ( (unsigned int)gmp_jacobi_coprime(v8, v6) == 1 );\n  mpz_init((__int64)v9);\n  v5 = mpz_scan0(v10, 0LL);\n  if ( (v6 & 2) != 0 )\n    v4 = (v6 >> 2) + 1;\n  else\n    v4 = -(__int64)(v6 >> 2);\n  if ( !gmp_lucas_mod(v9, (int *)a2, v4, v5, (__int64)v10) )\n  {\n    while ( v9[1] )\n    {\n      if ( !--v5 )\n        break;\n      gmp_lucas_step_k_2k(v9, (int *)a2, (__int64)v10);\n    }\n  }\n  mpz_clear((__int64)v9);\n  return v5 != 0;\n}\n",
    "source_code": "static int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D; /* The absolute value is stored. */\n  long Q;\n  mp_limb_t tl;\n\n  /* Test on the absolute value. */\n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */\n  if (mpz_root (Qk, n, 2))\n    return 0; /* A square is composite. */\n\n  /* Check Ds up to square root (in case, n is prime)\n     or avoid overflows */\n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */\n  /* For those Ds we have (D/n) = (n/|D|) */\n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */\n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */\n  b0 = mpz_scan0 (n, 0);\n\n  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */\n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t/* If Ud != 0 */\n    while (V->_mp_size != 0 && --b0 != 0)\t/* while Vk != 0 */\n      /* V <- V ^ 2 - 2Q^k */\n      /* Q^{2k} = (Q^k)^2 */\n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}",
    "comment": "Determines if an odd integer is prime using the Lucas-Lehmer test and computes the Lucas sequence value based on specific parameters.",
    "hext5_sum": "parameters. assumes x > 0.",
    "bint5_sum": "Calculates the Hamming distance between two multi-precision integers by counting differing bits in their binary representations .\n",
    "cpbcs_sum": "Calculates the Lucas sequence modulo n using parameters U, V, and Q, returning a logical value indicating whether the result is zero.\n",
    "misum_sum": "Calculates the absolute difference between two arbitrary precision integers, returning special cases for zero and negative values.\n",
    "decom_sum": "Performs the GMP strong Lucas primality test on the given number and returns whether it passes as a probable prime.",
    "cfg_sum": "Performs strong Lucas primality testing on a given number, validating oddness and iterating parameters before returning the result status.",
    "work_score": {
        "decom": {
            "summary": "Performs the GMP strong Lucas primality test on the given number and returns whether it passes as a probable prime.",
            "score": [
                1.0,
                0.4,
                0.6
            ],
            "reason": [
                "The summary contains a single claim that the function performs the GMP strong Lucas primality test on the given number and returns whether it passes as a probable prime. This aligns with the source code, which implements the strong Lucas test logic using GMP functions and returns a result indicating probable primality, making the claim accurate. With only one, correctly targeted claim, accuracy is high.",
                "The summary correctly identifies that the function implements the GMP strong Lucas primality test, which matches the core domain action in the source code. However, it omits critical secondary details such as the initial checks for oddness, square numbers, calculation and search for suitable D values, Jacobi symbol checks, the Lucas sequence steps, and specific return conditions. As a result, while the core is covered, the description is very thin and lacks coverage of behavior-critical semantics beyond the core purpose.",
                "The summary correctly identifies that the function implements a form of the strong Lucas test and returns a boolean-like result indicating probable primality, which aligns with the core logic of the code. However, it is overly general and omits important specifics such as composite detection for squares, the search for a suitable D value using Jacobi symbols, and the iterative Lucas sequence steps. There are no outright inaccuracies or contradictions, but the low informational detail means the gain is minimal with moderate noise due to lack of precision."
            ]
        },
        "cfg": {
            "summary": "Performs strong Lucas primality testing on a given number, validating oddness and iterating parameters before returning the result status.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function performs strong Lucas primality testing and checks for oddness before iterating parameters to determine a result, which aligns with the code's operations such as asserting oddness, searching for suitable D values, and using Lucas sequences. However, it omits specific details like the square check for compositeness and the behavior of returning results based on these checks, making it broadly accurate but imprecise. The majority of claims are accurate, but their generic nature slightly reduces precision.",
                "The summary correctly identifies the core purpose as performing strong Lucas primality testing and mentions preliminary oddness validation and iteration over parameters, aligning with the function\u2019s operations in the source code. However, it lacks detail about key secondary behaviors such as the square root composite check, the search for a suitable D using Jacobi symbols, handling of special return cases, and the specific Lucas sequence computations. This results in only partial coverage of critical semantics beyond the core.",
                "The summary correctly identifies the primary purpose as performing a strong Lucas primality test and notes the oddness check and iterative parameter handling, which align with the code's assertions and D-search loop. However, it is very high-level and omits important specific logic such as square detection, the Jacobi symbol check, detailed handling of Q, and the loop/termination conditions. There is no inaccurate or contradictory claim, but the information is generic and low-detail, providing minimal gain."
            ]
        },
        "comment": {
            "summary": "Determines if an odd integer is prime using the Lucas-Lehmer test and computes the Lucas sequence value based on specific parameters.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function uses the Lucas-Lehmer test to determine primality, which is inaccurate; the source code uses a strong Lucas probable prime test, not the Lucas-Lehmer test. It also omits key details such as the pre-check for perfect squares, the process of selecting D based on Jacobi symbol conditions, and specific handling for composite detection. While it mentions computing Lucas sequence values, this is only partially accurate and lacks precise alignment with the code\u2019s actual algorithm. Overall, the majority of claims are either incorrect or misleading relative to the source.",
                "The summary claims the function uses the Lucas-Lehmer test for primality, which is inaccurate; the source code implements a strong Lucas probable prime test with specific handling for quadratic nonresidues D, special intermediate computations, and checks for squares. The core purpose\u2014performing a strong Lucas primality test on an odd integer\u2014is not correctly captured. No secondary accurate details from the code are mentioned, such as the search for suitable D values, jacobi checks, handling of Q, or loop logic. This makes both the core coverage and secondary coverage poor.",
                "The summary contains a FATAL inaccuracy: it claims the function uses the Lucas-Lehmer test, which is specifically for Mersenne primes, whereas the source implements a strong Lucas probable prime test with additional composite checks. This misidentifies the primary purpose. Although it notes that the function computes Lucas sequence values, the core test type is incorrectly named, making the description unreliable for its main role."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 660608,
    "strip_function_name": "ec_GFp_simple_group_get_curve",
    "strip_decompiled_code": "__int64 __fastcall ec_GFp_simple_group_get_curve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5)\n{\n  _DWORD *v9; // r8\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  int v12; // eax\n  _BYTE *v13; // rax\n  _DWORD *ptr; // [rsp+8h] [rbp-40h]\n  _DWORD *ptra; // [rsp+8h] [rbp-40h]\n\n  if ( a2 && !BN_copy(a2, a1 + 104) )\n    return 0LL;\n  if ( !a3 && !a4 )\n    return 1LL;\n  if ( *(_QWORD *)(*(_QWORD *)a1 + 288LL) )\n  {\n    v9 = 0LL;\n    if ( a5 )\n    {\nLABEL_8:\n      if ( !a3\n        || (ptr = v9,\n            LODWORD(v10) = 0,\n            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                    a1,\n                    a3,\n                    a1 + 152,\n                    a5),\n            v9 = ptr,\n            v11) )\n      {\n        LODWORD(v10) = 1;\n        if ( a4 )\n        {\n          ptra = v9;\n          v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                  a1,\n                  a4,\n                  a1 + 176,\n                  a5);\n          v9 = ptra;\n          v10 = v12 != 0;\n        }\n      }\n      if ( v9 )\n        BN_CTX_free(v9);\n      return v10;\n    }\n    v13 = BN_CTX_new();\n    a5 = v13;\n    if ( v13 )\n    {\n      v9 = v13;\n      goto LABEL_8;\n    }\n    return 0LL;\n  }\n  if ( a3 && !BN_copy(a3, a1 + 152) )\n    return 0LL;\n  if ( !a4 )\n    return 1LL;\n  return BN_copy(a4, a1 + 176) != 0;\n}\n",
    "function_name": "ec_GFp_simple_group_get_curve",
    "decompiled_code": "_BOOL8 __fastcall ec_GFp_simple_group_get_curve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5)\n{\n  _DWORD *v9; // r8\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  int v12; // eax\n  _BYTE *v13; // rax\n  _DWORD *ptr; // [rsp+8h] [rbp-40h]\n  _DWORD *ptra; // [rsp+8h] [rbp-40h]\n\n  if ( a2 && !BN_copy(a2, a1 + 104) )\n    return 0LL;\n  if ( !a3 && !a4 )\n    return 1LL;\n  if ( *(_QWORD *)(*(_QWORD *)a1 + 288LL) )\n  {\n    v9 = 0LL;\n    if ( a5 )\n    {\nLABEL_8:\n      if ( !a3\n        || (ptr = v9,\n            LODWORD(v10) = 0,\n            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                    a1,\n                    a3,\n                    a1 + 152,\n                    a5),\n            v9 = ptr,\n            v11) )\n      {\n        LODWORD(v10) = 1;\n        if ( a4 )\n        {\n          ptra = v9;\n          v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                  a1,\n                  a4,\n                  a1 + 176,\n                  a5);\n          v9 = ptra;\n          v10 = v12 != 0;\n        }\n      }\n      if ( v9 )\n        BN_CTX_free(v9);\n      return v10;\n    }\n    v13 = BN_CTX_new();\n    a5 = v13;\n    if ( v13 )\n    {\n      v9 = v13;\n      goto LABEL_8;\n    }\n    return 0LL;\n  }\n  if ( a3 && !BN_copy(a3, a1 + 152) )\n    return 0LL;\n  if ( !a4 )\n    return 1LL;\n  return BN_copy(a4, a1 + 176) != 0;\n}\n",
    "source_code": "\n\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret = 0;\n\tBN_CTX *new_ctx = NULL;\n\t\n\tif (p != NULL)\n\t\t{\n\t\tif (!BN_copy(p, &group->field)) return 0;\n\t\t}\n\n\tif (a != NULL || b != NULL)\n\t\t{\n\t\tif (group->meth->field_decode)\n\t\t\t{\n\t\t\tif (ctx == NULL)\n\t\t\t\t{\n\t\t\t\tctx = new_ctx = BN_CTX_new();\n\t\t\t\tif (ctx == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(a, &group->a)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(b, &group->b)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tret = 1;\n\t\n err:\n\tif (new_ctx)\n\t\tBN_CTX_free(new_ctx);\n\treturn ret;\n\t}",
    "comment": "Retrieves the elliptic curve parameters (field, a, and b) from the specified EC_GROUP structure into provided BIGNUM variables.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Extracts the elliptic curve parameters from a given group , including the field , a , and b , into the provided EC_GROUP structure .\n",
    "cpbcs_sum": "Extracts the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and manages a temporary BN_CTX context.\n",
    "misum_sum": "Retrieves the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and returns the result in the output structure.\n",
    "decom_sum": "Retrieves the elliptic curve prime field parameters and copies them into provided BIGNUMs, optionally using a BN_CTX for calculations.",
    "cfg_sum": "Retrieves elliptic curve parameters from a group, copying BIGNUM values with optional BN_CTX allocation and ensuring cleanup before returning success or failure.",
    "work_score": {
        "decom": {
            "summary": "Retrieves the elliptic curve prime field parameters and copies them into provided BIGNUMs, optionally using a BN_CTX for calculations.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves elliptic curve prime field parameters and copies them into provided BIGNUMs, aligning with the code\u2019s handling of p, a, and b from the EC_GROUP structure. It also accurately notes the optional use of a BN_CTX for calculations, which corresponds to the code\u2019s creation and use of BN_CTX when needed. All claims are specific to the function\u2019s semantics and are consistent with the source code.",
                "The summary correctly identifies that the function retrieves elliptic curve prime field parameters and copies them into provided BIGNUMs, which matches the core purpose of returning p, a, and b from the EC_GROUP. It also mentions optionally using a BN_CTX, aligning with the code's creation of a new context when needed. However, it omits important branching behavior: the distinction between raw copying and field decoding via group->meth->field_decode, and error handling paths. While the core is covered and some secondary detail is present, coverage of these other critical semantics is limited.",
                "The summary accurately captures the primary purpose: retrieving EC prime field parameters and storing them in provided BIGNUMs, with optional BN_CTX usage. It omits mention of the coefficients 'a' and 'b' handling and conditional decoding logic based on the method, which reduces informational gain. There is no inaccurate or contradictory claim, but the detail level is low and somewhat generic."
            ]
        },
        "cfg": {
            "summary": "Retrieves elliptic curve parameters from a group, copying BIGNUM values with optional BN_CTX allocation and ensuring cleanup before returning success or failure.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves elliptic curve parameters from a group and copies BIGNUM values, which matches the use of BN_copy and field_decode in the source. It also accurately notes the optional allocation of a BN_CTX and the cleanup before returning success or failure, reflecting the creation and freeing of new_ctx and the return value logic. All claims are grounded in the code with no inaccuracies or irrelevant noise, giving high precision.",
                "The summary accurately states that the function retrieves elliptic curve parameters from a group, copies BIGNUM values, may allocate a BN_CTX, and cleans up before returning a success/failure indicator. This covers the core purpose (getting p, a, b from EC_GROUP with optional decoding and BN_CTX allocation) and mentions secondary behaviors like conditional allocation and cleanup. However, it omits specifics such as the use of field_decode when applicable, the detailed conditional logic for p, a, and b parameters, and the exact conditions leading to error returns. These omissions reduce completeness.",
                "The summary accurately describes the primary purpose of retrieving elliptic curve parameters from the EC_GROUP, notes the copying of BIGNUM values, and mentions optional BN_CTX allocation and cleanup. These match the source code's main actions without introducing contradictions. However, the description is somewhat generic, lacking specifics about conditional decoding via group->meth->field_decode depending on its presence, or the distinction between p, a, and b handling. No FATAL or major noise is present, but gain is low due to limited detail."
            ]
        },
        "comment": {
            "summary": "Retrieves the elliptic curve parameters (field, a, and b) from the specified EC_GROUP structure into provided BIGNUM variables.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves elliptic curve parameters (field, a, and b) from an EC_GROUP structure into provided BIGNUM variables, which matches the source code logic. It omits some implementation details such as conditional copying depending on whether pointers are non-null and the use of BN_copy or field_decode, but these are not essential to the core semantic. All claims in the summary are accurate and directly match the domain-specific behavior in the code.",
                "The summary correctly states that the function retrieves the elliptic curve parameters p (field), a, and b from an EC_GROUP into provided BIGNUM variables, matching the core domain purpose. However, it omits critical secondary details such as the conditional decoding via group->meth->field_decode, creation and cleanup of a BN_CTX when needed, handling of NULL arguments, and error paths. Thus, while the core is covered, coverage of important behavior-specific semantics is limited.",
                "The summary accurately reflects the core purpose of the function by stating it retrieves the elliptic curve parameters (field, a, and b) from the EC_GROUP into provided BIGNUM variables. This matches the source code\u2019s operations with BN_copy and field_decode. There are no inaccurate or irrelevant claims; however, the description is generic with minimal detail about conditional logic, context management, or decoding behavior, offering low informational gain beyond the basic purpose."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5338357,
    "strip_function_name": "sub_5174F5",
    "strip_decompiled_code": "__int64 __fastcall sub_5174F5(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  __int64 v17; // rdi\n  __int64 v18; // rax\n  _DWORD v20[2]; // [rsp+8h] [rbp-D0h] BYREF\n  char *v21; // [rsp+10h] [rbp-C8h]\n  char *v22; // [rsp+18h] [rbp-C0h]\n  char v23; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v24; // [rsp+28h] [rbp-B0h]\n  __int64 v25; // [rsp+30h] [rbp-A8h]\n  __int64 v26; // [rsp+38h] [rbp-A0h]\n  __int64 v27; // [rsp+40h] [rbp-98h]\n  __int64 v28; // [rsp+48h] [rbp-90h]\n  __m128 v29; // [rsp+50h] [rbp-88h]\n  __m128 v30; // [rsp+60h] [rbp-78h]\n  __m128 v31; // [rsp+70h] [rbp-68h]\n  __m128 v32; // [rsp+80h] [rbp-58h]\n  __m128 v33; // [rsp+90h] [rbp-48h]\n  __m128 v34; // [rsp+A0h] [rbp-38h]\n  __m128 v35; // [rsp+B0h] [rbp-28h]\n  __m128 v36; // [rsp+C0h] [rbp-18h]\n\n  v24 = a2;\n  v25 = a3;\n  v26 = a4;\n  v27 = a5;\n  v28 = a6;\n  if ( v15 )\n  {\n    v29 = a7;\n    v30 = a8;\n    v31 = a9;\n    v32 = a10;\n    v33 = a11;\n    v34 = a12;\n    v35 = a13;\n    v36 = a14;\n  }\n  v20[0] = 8;\n  v20[1] = 48;\n  v21 = &a15;\n  v22 = &v23;\n  v17 = *(unsigned int *)qword_89A630;\n  v18 = 0LL;\n  if ( (_DWORD)v17 )\n    v18 = sub_455D70(\n            v17,\n            *(double *)a7.m128_u64,\n            *(double *)a8.m128_u64,\n            *(double *)a9.m128_u64,\n            *(double *)a10.m128_u64,\n            *(double *)a11.m128_u64,\n            *(double *)a12.m128_u64,\n            *(double *)a13.m128_u64,\n            *(double *)a14.m128_u64);\n  return sub_5176F5(a1, v20, v18);\n}\n",
    "function_name": "bb_perror_msg",
    "decompiled_code": "unsigned __int64 __fastcall bb_perror_msg(\n        const char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  const __m128i *v16; // rax\n  _QWORD v18[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v19; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v20; // [rsp+28h] [rbp-B0h]\n  __int64 v21; // [rsp+30h] [rbp-A8h]\n  __int64 v22; // [rsp+38h] [rbp-A0h]\n  __int64 v23; // [rsp+40h] [rbp-98h]\n  __int64 v24; // [rsp+48h] [rbp-90h]\n  __m128 v25; // [rsp+50h] [rbp-88h]\n  __m128 v26; // [rsp+60h] [rbp-78h]\n  __m128 v27; // [rsp+70h] [rbp-68h]\n  __m128 v28; // [rsp+80h] [rbp-58h]\n  __m128 v29; // [rsp+90h] [rbp-48h]\n  __m128 v30; // [rsp+A0h] [rbp-38h]\n  __m128 v31; // [rsp+B0h] [rbp-28h]\n  __m128 v32; // [rsp+C0h] [rbp-18h]\n\n  v20 = a2;\n  v21 = a3;\n  v22 = a4;\n  v23 = a5;\n  v24 = a6;\n  if ( v15 )\n  {\n    v25 = a7;\n    v26 = a8;\n    v27 = a9;\n    v28 = a10;\n    v29 = a11;\n    v30 = a12;\n    v31 = a13;\n    v32 = a14;\n  }\n  v18[0] = 0x3000000008LL;\n  v18[1] = &a15;\n  v18[2] = &v19;\n  v16 = 0LL;\n  if ( *(_DWORD *)bb_errno )\n    v16 = (const __m128i *)strerror(\n                             *(_DWORD *)bb_errno,\n                             *(double *)a7.m128_u64,\n                             *(double *)a8.m128_u64,\n                             *(double *)a9.m128_u64,\n                             *(double *)a10.m128_u64,\n                             *(double *)a11.m128_u64,\n                             *(double *)a12.m128_u64,\n                             *(double *)a13.m128_u64,\n                             *(double *)a14.m128_u64);\n  return bb_verror_msg(\n           a1,\n           v18,\n           v16,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           *(double *)a11.m128_u64,\n           *(double *)a12.m128_u64,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "source_code": "\nvoid FAST_FUNC bb_perror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\t/* Guard against \"<error message>: Success\" */\n\tbb_verror_msg(s, p, errno ? strerror(errno) : NULL);\n\tva_end(p);\n}",
    "comment": "Logs an error message along with the string representation of the current errno value, using a variable argument list for additional context.",
    "hext5_sum": "push a pointer to the recorded location. this function gives unspecified results in multibyte locales.",
    "bint5_sum": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
    "cpbcs_sum": "Logs a message at a specified error level using a variable argument list to the `crondlog` function.\n",
    "misum_sum": "Logs a formatted message at level 4 using a variable argument list to pass the `crondlog` function.\n",
    "decom_sum": "Constructs a parameter block from input vectors, computes a derived value if enabled, and passes it to another routine for final processing.",
    "cfg_sum": "Prepares transformation parameters, optionally initializes vector data, computes a derived value, and calls a processing routine with the compiled arguments.",
    "work_score": {
        "decom": {
            "summary": "Constructs a parameter block from input vectors, computes a derived value if enabled, and passes it to another routine for final processing.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary describes unrelated operations like constructing a parameter block and computing a derived value, which are not present in the source code. The actual function initializes a variable argument list, calls `bb_verror_msg` with appropriate error handling, and ends the variable argument list. None of the claims in the summary match the code\u2019s semantics, resulting in 0% accurate claims.",
                "The summary does not match the source code's purpose at all. The function in the source formats and prints an error message using a variadic argument list, guarding against printing 'Success' when errno is zero. The summary instead describes constructing parameter blocks and computing derived values, which is unrelated and thus inaccurate. The core primary purpose of guarded error message formatting is not covered, and no accurate secondary details are provided.",
                "The summary's claims about constructing a parameter block, computing a derived value, and conditional enabling do not match the source code, which initializes a variadic argument list and calls bb_verror_msg with an error message or NULL based on errno. These are entirely unrelated and constitute NOISE without any accurate reflection of the function's semantics. Noise overwhelms and there is no factual gain, making the worst failure mode overwhelming NOISE."
            ]
        },
        "cfg": {
            "summary": "Prepares transformation parameters, optionally initializes vector data, computes a derived value, and calls a processing routine with the compiled arguments.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary makes claims about preparing transformation parameters, initializing vector data, and computing derived values, which do not correspond to the source code's actual behavior of handling variadic arguments, formatting an error message conditionally based on `errno`, and calling `bb_verror_msg`. None of the claims accurately target the semantics of this function, resulting in a complete mismatch.",
                "The summary's claims about preparing transformation parameters, vector initialization, and computing derived values are unrelated to the source code, which formats and outputs an error message using variadic arguments and conditionally appends the strerror of errno. The core purpose of the function\u2014printing a formatted error message with optional system error text\u2014is not mentioned at all, and none of the summary's claims are accurate with respect to the code's semantics.",
                "The summary's claims about preparing transformation parameters, initializing vector data, and computing derived values do not match the source code, which actually manages variadic arguments and error string handling. All claims are NOISE, with no accurate alignment to the function's actual purpose of printing error messages. The worst failure mode is overwhelming NOISE, resulting in no factual gain."
            ]
        },
        "comment": {
            "summary": "Logs an error message along with the string representation of the current errno value, using a variable argument list for additional context.",
            "score": [
                0.9,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly mentions logging an error message and including the string representation of the current errno value, as well as using a variable argument list for additional context. These details align with the function\u2019s behavior in the source code, including its call to bb_verror_msg with strerror(errno) when errno is nonzero. There are no contradictory or irrelevant claims, so the accuracy proportion is very high.",
                "The summary accurately identifies that the function logs an error message alongside the string version of errno and mentions the use of variadic arguments, matching the core purpose of wrapping bb_verror_msg with va_list handling. However, it omits a key behavioral detail: the function guards against printing misleading '...: Success' messages when errno is zero, by passing NULL instead of strerror(0). This missing edge-case handling and lack of mention of underlying call to bb_verror_msg reduces completeness.",
                "The summary correctly identifies that the function logs an error message and uses a variable argument list, which matches the source code. However, it inaccurately states that it always logs the string representation of the current errno value; the code only passes it if errno is nonzero, otherwise passing NULL. This is a FATAL error concerning the core behavior (what gets logged), significantly undermining trust in the description. Accurate elements are generic and offer low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581460656,
    "strip_function_name": "sub_FFFFFFFF8127E8B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8127E8B0(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 result; // rax\n  __int64 **v15; // r12\n  __int64 v16; // rsi\n  __int64 *v17; // rbx\n  __int64 *v18; // rdx\n  __int64 v19; // rcx\n  int v20; // r8d\n  int v21; // r9d\n  unsigned int v22; // r13d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 *v25; // rdx\n  __int64 v26; // rcx\n  int v27; // r8d\n  int v28; // r9d\n  double v29; // xmm4_8\n  double v30; // xmm5_8\n\n  if ( !LODWORD(dword_FFFFFFFF81E9AB00[0]) )\n    return 0LL;\n  v15 = (__int64 **)(a1 + 24);\n  v16 = *(_QWORD *)(a2 + 24);\n  v17 = (__int64 *)(a1 + 48);\n  v22 = sub_FFFFFFFF812709E0(a1 + 24, v16, a3, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6);\n  if ( v22\n    || (v16 = a1 + 24, v22 = sub_FFFFFFFF812707B0(v17, v15, a7, a8, a9, a10, v23, v24, a13, a14), result = 0LL, v22) )\n  {\n    sub_FFFFFFFF81270E80((__int64)v15, v16, v18, v19, v20, v21, a7, a8, a9, a10, v23, v24, a13, a14);\n    sub_FFFFFFFF81270E80((__int64)v17, v16, v25, v26, v27, v28, a7, a8, a9, a10, v29, v30, a13, a14);\n    return v22;\n  }\n  return result;\n}\n",
    "function_name": "mls_import_netlbl_cat",
    "decompiled_code": "__int64 __fastcall mls_import_netlbl_cat(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  __int64 **v12; // r12\n  __int64 v13; // rsi\n  __int64 **v14; // rbx\n  __int64 *v15; // rdx\n  unsigned int v16; // r13d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n\n  if ( !LODWORD(policydb[0]) )\n    return 0LL;\n  v12 = (__int64 **)(a1 + 24);\n  v13 = *(_QWORD *)(a2 + 24);\n  v14 = (__int64 **)(a1 + 48);\n  v16 = ebitmap_netlbl_import(a1 + 24, v13, a3, a4, a5, a6, a7, a8, a9, a10, a11);\n  if ( v16 || (v13 = a1 + 24, v16 = ebitmap_cpy(v14, v12, a4, a5, a6, a7, v17, v18, a10, a11), result = 0LL, v16) )\n  {\n    ebitmap_destroy((__int64)v12, v13, v15, a4, a5, a6, a7, v17, v18, a10, a11);\n    ebitmap_destroy((__int64)v14, v13, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    return v16;\n  }\n  return result;\n}\n",
    "source_code": "int mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t &context->range.level[0].cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\tebitmap_destroy(&context->range.level[1].cat);\n\treturn rc;\n}",
    "comment": "Imports and copies the MLS category attributes into the context structure if MLS is enabled, handling errors by destroying allocated resources.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Inserts a conditional type rule into the SELinux access vector table while ensuring no conflicting rules exist in the table .\n",
    "cpbcs_sum": "Exports the MLS category table by converting its name to the security attribute representation and handling potential errors during the process.\n",
    "misum_sum": "Exports a context identified by its name into the provided security context, detaching security attributes, and security attributes, while handling errors appropriately.\n",
    "decom_sum": "Processes two internal data structures with geometric parameters and updates them if initial checks pass, returning a status code.",
    "cfg_sum": "Checks a global initialization flag, performs two geometric or positional computations, updates related structures, and returns a status code based on results.",
    "work_score": {
        "decom": {
            "summary": "Processes two internal data structures with geometric parameters and updates them if initial checks pass, returning a status code.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary makes generic and vague claims about processing data structures with geometric parameters, which do not match the function's actual behavior of importing and copying MLS category bitmaps when policydb.mls_enabled is true. There is no accurate mention of specific domain semantics like 'netlabel', 'mls', or bitmap operations, making it largely inaccurate with respect to the source code.",
                "The summary fails to capture the core purpose of the function, which is to import MLS category bitmaps from a netlabel security attribute into a context when MLS is enabled, copy them to a second level, and handle cleanup on error. Instead, it describes unrelated 'geometric parameters' and generic processing of data structures, which is inaccurate. No accurate claims about the actual domain semantics or error handling are present.",
                "The summary's claim that the function processes two internal data structures with geometric parameters is inaccurate; the code manipulates MLS category bitmaps related to security attributes, not geometric parameters. Although it notes an initial check and a returned status code, the core purpose and domain semantics are misrepresented, constituting a fatal error on the primary purpose. This severe mismatch in WHAT the function does significantly reduces trustworthiness."
            ]
        },
        "cfg": {
            "summary": "Checks a global initialization flag, performs two geometric or positional computations, updates related structures, and returns a status code based on results.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains multiple inaccuracies: it incorrectly describes the operations as 'geometric or positional computations' instead of importing and copying MLS category bitmaps from the security attributes; it omits the specific nature of the global flag (policydb.mls_enabled) and misrepresents structure updates. Only the generic mention of checking a global flag and returning a status code is accurate, which constitutes less than half of the claims.",
                "The summary\u2019s claims about checking a global flag and returning a status code are generally accurate, but its description of performing 'geometric or positional computations' is incorrect and does not reflect the core purpose of importing MLS category bitmaps from a NetLabel security attribute into a context and duplicating them. The core operation of MLS bitmap import and copy is entirely missing, meaning the summary fails to cover the key domain-specific behavior and provides no correct secondary details beyond a vague flag and return mention.",
                "The summary contains multiple inaccuracies: it misrepresents the function\u2019s operations as 'geometric or positional computations' instead of importing and copying MLS category bitmaps, and it generically states 'updates related structures' without clearly identifying the specific context structure fields updated. While it correctly notes a global flag check and returning a status code, the noise from imprecise or irrelevant descriptions outweighs the few accurate points, resulting in low net benefit due to misleading core action representation (NOISE dominating)."
            ]
        },
        "comment": {
            "summary": "Imports and copies the MLS category attributes into the context structure if MLS is enabled, handling errors by destroying allocated resources.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately describes that the function imports and copies MLS category attributes into the context when MLS is enabled and correctly notes the error handling via resource destruction. These statements match the source code's logic and behavior, with no contradictory or irrelevant claims present, yielding a high proportion of accurate claims.",
                "The summary accurately describes the core function: importing MLS category attributes into the context when MLS is enabled, then copying them to the second level and handling errors by freeing resources. It captures the conditional MLS-enabled check, import, copy, and cleanup logic. This covers the core primary purpose and includes error handling details, though it omits mention of the specific use of netlabel attributes and exact data structures involved, making secondary coverage decent but not exhaustive.",
                "The summary accurately states the core behavior: it imports and copies MLS category attributes into the context if MLS is enabled, matching the code's logic with the calls to ebitmap_netlbl_import and ebitmap_cpy. It also correctly notes error handling that destroys allocated resources on failure. No claims are irrelevant or contradictory; all are specific and directly grounded in the source, giving a high informational value with minimal noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582734064,
    "strip_function_name": "sub_FFFFFFFF813B56F0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813B56F0(\n        _QWORD *a1,\n        unsigned int a2,\n        char a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  char v12; // r14\n  int v13; // r12d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 result; // rax\n  char *v17; // r9\n  char *v18; // r8\n\n  v12 = a3;\n  v13 = *(_DWORD *)(a1[a2 + 1065] + 2172LL);\n  if ( !a2 && (a1[947] & 1) != 0 )\n  {\n    if ( (unsigned __int8)sub_FFFFFFFF813D9840(*a1) >= (unsigned __int8)(v13 != 15) )\n    {\n      v12 = 1;\nLABEL_5:\n      result = sub_FFFFFFFF8138E6A0((__int64)a1, *(_DWORD *)a1[2] + (v13 << 12) + 458760);\n      if ( v12 == (int)result < 0 )\n        return result;\n      v18 = \"off\";\n      v17 = \"off\";\n      if ( (int)result < 0 )\n        v17 = \"on\";\n      if ( v12 )\n        v18 = \"on\";\n      return sub_FFFFFFFF8103BAE0(\n               (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n               1241,\n               (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n               a4,\n               a5,\n               a6,\n               a7,\n               v14,\n               v15,\n               a10,\n               a11,\n               a2 + 65,\n               v18,\n               v17);\n    }\n    goto LABEL_9;\n  }\n  result = sub_FFFFFFFF813D9840(*a1);\n  if ( (unsigned __int8)result >= (unsigned __int8)(v13 != 15) )\n    goto LABEL_5;\n  if ( a3 )\n  {\nLABEL_9:\n    v17 = \"off\";\n    v18 = \"on\";\n    return sub_FFFFFFFF8103BAE0(\n             (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n             1241,\n             (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n             a4,\n             a5,\n             a6,\n             a7,\n             v14,\n             v15,\n             a10,\n             a11,\n             a2 + 65,\n             v18,\n             v17);\n  }\n  return result;\n}\n",
    "function_name": "assert_pipe",
    "decompiled_code": "char __fastcall assert_pipe(\n        __int64 *a1,\n        unsigned int a2,\n        char a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  char v12; // r14\n  int v13; // r12d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  char *v17; // r9\n  char *v18; // r8\n\n  v12 = a3;\n  v13 = *(_DWORD *)(a1[a2 + 1065] + 2172);\n  if ( a2 || (a1[947] & 1) == 0 )\n  {\n    LOBYTE(v16) = intel_using_power_well(*a1);\n    if ( (unsigned __int8)v16 >= (unsigned __int8)(v13 != 15) )\n      goto LABEL_5;\n    if ( !a3 )\n      return v16;\nLABEL_9:\n    v17 = \"off\";\n    v18 = \"on\";\n    goto LABEL_14;\n  }\n  if ( (unsigned __int8)intel_using_power_well(*a1) < (unsigned __int8)(v13 != 15) )\n    goto LABEL_9;\n  v12 = 1;\nLABEL_5:\n  v16 = i915_read32((__int64)a1, *(_DWORD *)a1[2] + (v13 << 12) + 458760);\n  if ( v12 == v16 < 0 )\n    return v16;\n  v18 = \"off\";\n  v17 = \"off\";\n  if ( v16 < 0 )\n    v17 = \"on\";\n  if ( v12 )\n    v18 = \"on\";\nLABEL_14:\n  LOBYTE(v16) = warn_slowpath_fmt(\n                  \"drivers/gpu/drm/i915/intel_display.c\",\n                  0x4D9u,\n                  (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n                  a4,\n                  a5,\n                  a6,\n                  a7,\n                  v14,\n                  v15,\n                  a10,\n                  a11,\n                  a2 + 65,\n                  v18,\n                  v17);\n  return v16;\n}\n",
    "source_code": "\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum pipe pipe, bool state)\n{\n\tint reg;\n\tu32 val;\n\tbool cur_state;\n\tenum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,\n\t\t\t\t\t\t\t\t      pipe);\n\n\t/* if we need the pipe A quirk it must be always on */\n\tif (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)\n\t\tstate = true;\n\n\tif (!intel_using_power_well(dev_priv->dev) &&\n\t    cpu_transcoder != TRANSCODER_EDP) {\n\t\tcur_state = false;\n\t} else {\n\t\treg = PIPECONF(cpu_transcoder);\n\t\tval = I915_READ(reg);\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\t}\n\n\tWARN(cur_state != state,\n\t     \"pipe %c assertion failure (expected %s, current %s)\\n\",\n\t     pipe_name(pipe), state_string(state), state_string(cur_state));\n}",
    "comment": "Asserts the state of a specified display pipe in the Intel graphics driver, ensuring it matches the expected enablement state.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Enables or disables the PLL for a specified display plane and updates relevant PLL configurations based on the device generation and capabilities .\n",
    "cpbcs_sum": "Inserts a specified display port into the corresponding Northbridge pipe based on the provided value, ensuring valid port status and memory allocation.\n",
    "misum_sum": "Asserts the status of a specified register on an Intel i915 device, handling errors and conditions appropriately.\n",
    "decom_sum": "Checks an Intel GPU display pipe state against the expected value and logs an assertion failure with detailed status if mismatched.",
    "cfg_sum": "Validates Intel GPU display pipe state against expected configuration and triggers an assertion failure log if the current state does not match.",
    "work_score": {
        "decom": {
            "summary": "Checks an Intel GPU display pipe state against the expected value and logs an assertion failure with detailed status if mismatched.",
            "score": [
                0.9,
                0.4,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function checks an Intel GPU display pipe state against an expected value and logs an assertion failure with detailed status when mismatched. This aligns with the code's behavior, which reads the pipe's current state and compares it to the expected state, emitting a WARN if they differ. Although the summary omits minor implementation details like special handling for PIPE_A quirks and power well checks, the core functional description is accurate and focused on the relevant semantics.",
                "The summary accurately states that the function checks the Intel GPU display pipe state against an expected value and logs an assertion failure if mismatched, which matches the core purpose of the source. However, it omits secondary details such as the special handling for PIPE_A with QUIRK_PIPEA_FORCE, the conditions based on power well usage and transcoder type, and the exact method of reading and evaluating the PIPECONF register. This results in a thin coverage beyond the core action.",
                "The summary accurately captures the core purpose of the function: it compares the current Intel GPU display pipe state to an expected state and logs a detailed assertion failure if they differ. This is consistent with the source code\u2019s logic, including reading the pipe configuration and warning when states mismatch. There is no incorrect or irrelevant information, but the claim is generic and lacks mention of specific conditions handled, such as PIPE_A quirks or power well checks, limiting the informational gain."
            ]
        },
        "cfg": {
            "summary": "Validates Intel GPU display pipe state against expected configuration and triggers an assertion failure log if the current state does not match.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately describes the function's purpose: it checks the Intel GPU display pipe state against an expected state and logs a warning if they differ. This matches the code's logic involving `cur_state` vs. `state` and the `WARN` call. Although it omits minor implementation specifics like handling PIPE_A quirks and power well conditions, all claims it makes are correct and relevant to the function's semantics, yielding a high proportion of accurate statements.",
                "The summary accurately captures the core purpose of comparing the current pipe state to the expected configuration and logging a warning if mismatched, which aligns with the source\u2019s WARN invocation. However, it omits key secondary details such as handling of the PIPE_A quirk that forces it always on, conditions involving power wells and the TRANSCODER_EDP check, and reading hardware registers to determine state. These omissions reduce coverage beyond the core logic.",
                "The summary correctly states that the function validates the Intel GPU display pipe state against an expected configuration and logs an assertion failure if there's a mismatch, which aligns with the core purpose and behavior in the source code. There are no incorrect or irrelevant claims, but the description is generic and omits specific details such as the PIPE_A quirk handling and conditions related to power wells and transcoders, limiting informational gain."
            ]
        },
        "comment": {
            "summary": "Asserts the state of a specified display pipe in the Intel graphics driver, ensuring it matches the expected enablement state.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function asserts the state of a specified display pipe and checks it against an expected enablement state, which aligns with the actual code logic that reads the PIPECONF register and compares the current state to the expected one. No contradictory or irrelevant claims are present, and the description captures the domain-specific operation of state assertion within the Intel graphics driver.",
                "The summary correctly identifies that the function asserts the state of a specified display pipe and checks it against an expected enablement state, which matches the core purpose derived from the source code. However, it omits important secondary behaviors such as handling the PIPE_A quirk, conditions related to power wells and the TRANSCODER_EDP, and reading specific hardware registers to determine the current state. This results in only partial coverage of behavior-critical semantics beyond the core purpose.",
                "The summary correctly identifies the primary purpose of the function\u2014asserting that a specified display pipe's current enabled state matches the expected state in the Intel graphics driver. This is a specific and accurate GOLD claim about the code's core domain behavior. No claims contradict the source code, and there is no extraneous noise. However, the summary omits details about conditions such as quirks forcing Pipe A on and special handling for power wells and EDP transcoders, so the gain is moderate rather than high."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583666752,
    "strip_function_name": "sub_FFFFFFFF81499240",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81499240(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rbx\n  unsigned int v10; // r14d\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int v17; // r13d\n  unsigned int v18; // ebx\n  bool v19; // zf\n  __int64 v20; // rsi\n  int v22; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v23[100]; // [rsp+4h] [rbp-64h] BYREF\n\n  v9 = a1 + 488;\n  sub_FFFFFFFF8178F210(a1 + 488);\n  if ( !*(_BYTE *)(a1 + 344) )\n  {\n    v10 = -11;\n    sub_FFFFFFFF8178F1B0(v9);\n    return v10;\n  }\n  v10 = sub_FFFFFFFF8149AA70(a1);\n  if ( v10 )\n  {\n    sub_FFFFFFFF8178F1B0(v9);\n    return (unsigned int)-11;\n  }\n  sub_FFFFFFFF8178F1B0(v9);\n  if ( (unsigned int)sub_FFFFFFFF8149CC00(a1, &v22) || !v22 )\n    return 4294967277LL;\n  if ( (unsigned int)sub_FFFFFFFF8149D590(a1, 255LL, 6LL, v23) )\n  {\n    *(_WORD *)(a1 + 28) = 1;\n    sub_FFFFFFFF81498E40(a1, 0LL, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9);\n    return v10;\n  }\n  v17 = v23[0];\n  v18 = 0;\n  v19 = v23[0] == 0;\n  *(_WORD *)(a1 + 28) = v23[0];\n  if ( v19 )\n    return v10;\n  do\n  {\n    v20 = v18++;\n    sub_FFFFFFFF81498E40(a1, v20, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9);\n  }\n  while ( v17 > v18 );\n  return v10;\n}\n",
    "function_name": "pcmcia_card_add",
    "decompiled_code": "__int64 __fastcall pcmcia_card_add(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rbx\n  unsigned int v10; // r14d\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // r13d\n  unsigned int v22; // ebx\n  bool v23; // zf\n  int v24; // esi\n  unsigned int v26; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v27[100]; // [rsp+4h] [rbp-64h] BYREF\n\n  v9 = a1 + 488;\n  mutex_lock(a1 + 488);\n  if ( !*(_BYTE *)(a1 + 344) )\n  {\n    v10 = -11;\n    mutex_unlock(v9);\n    return v10;\n  }\n  v10 = pcmcia_validate_mem(a1);\n  if ( v10 )\n  {\n    mutex_unlock(v9);\n    return (unsigned int)-11;\n  }\n  mutex_unlock(v9);\n  if ( (unsigned int)pccard_validate_cis(a1, &v26, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9) || !v26 )\n    return 4294967277LL;\n  if ( (unsigned int)pccard_read_tuple(a1, 255LL, 6, (__int64)v27, a2, a3, a4, a5, v17, v18, a8, a9) )\n  {\n    *(_WORD *)(a1 + 28) = 1;\n    pcmcia_device_add(a1, 0, a2, a3, a4, a5, v19, v20, a8, a9);\n    return v10;\n  }\n  v21 = v27[0];\n  v22 = 0;\n  v23 = v27[0] == 0;\n  *(_WORD *)(a1 + 28) = v27[0];\n  if ( v23 )\n    return v10;\n  do\n  {\n    v24 = v22++;\n    pcmcia_device_add(a1, v24, a2, a3, a4, a5, v19, v20, a8, a9);\n  }\n  while ( v21 > v22 );\n  return 0LL;\n}\n",
    "source_code": "\n\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\n{\n\tcistpl_longlink_mfc_t mfc;\n\tunsigned int no_funcs, i, no_chains;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!(s->resource_setup_done)) {\n\t\tdev_dbg(&s->dev,\n\t\t\t   \"no resources available, delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\n\tif (pcmcia_validate_mem(s)) {\n\t\tdev_dbg(&s->dev, \"validating mem resources failed, \"\n\t\t       \"delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\tret = pccard_validate_cis(s, &no_chains);\n\tif (ret || !no_chains) {\n\t\tdev_dbg(&s->dev, \"invalid CIS or invalid resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\n\t\tno_funcs = mfc.nfn;\n\telse\n\t\tno_funcs = 1;\n\ts->functions = no_funcs;\n\n\tfor (i = 0; i < no_funcs; i++)\n\t\tpcmcia_device_add(s, i);\n\n\treturn ret;\n}",
    "comment": "Adds a PCMCIA card to the socket after validating resources and reading its function information from the card's CIS.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Enables a PCMCIA device by configuring its socket state , memory , I/O windows , and setting up necessary configuration registers .\n",
    "cpbcs_sum": "Sets the receive mode for a PCMCIA device by validating the provided value and ensuring no valid port is registered and previously registered.\n",
    "misum_sum": "Updates the PHY device configuration if it differs from the specified socket is present and the device is present in a network device.\n",
    "decom_sum": "Initializes a device context, checks readiness, retrieves configuration bytes, and executes a processing routine for each configured channel.",
    "cfg_sum": "Validates device readiness, retrieves configuration bytes, and executes iterative processing routines based on retrieved data, updating status and cleanup before returning the result code.",
    "work_score": {
        "decom": {
            "summary": "Initializes a device context, checks readiness, retrieves configuration bytes, and executes a processing routine for each configured channel.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes a device context, checks readiness, retrieves configuration bytes, and processes each configured channel. While the code does check readiness and iterates over functions to add devices, it does not explicitly initialize a device context in the generalized sense, nor does it retrieve generic 'configuration bytes'\u2014instead it reads a specific CIS tuple for functions. References to 'configured channel' are misleading given the context is PCMcia functions. This leads to a mix of partially correct and inaccurate statements, with less than half clearly accurate.",
                "The summary fails to capture the core purpose of adding PCMCIA card functions by validating resources and CIS, reading function count, and invoking pcmcia_device_add for each. While it mentions readiness checks and iterative processing, it inaccurately describes configuration retrieval as 'configuration bytes' and channels instead of the specific tuples and functions from the source. Critical details like handling EAGAIN/ENODEV error cases, mutex usage, and the CIS validation logic are missing, so the core domain operation is not covered.",
                "The summary contains mostly inaccurate and noisy claims. It wrongly states that the function initializes a device context and processes configured channels, while the code actually checks resource readiness, validates memory and CIS, determines the number of functions from a tuple, and adds PCMIA devices. The terms 'retrieves configuration bytes' and 'processing routine for each configured channel' do not align with the semantics in the source code, leading to misleading description of the primary purpose. No accurate, highly specific domain claims are present, and the inaccuracies target core behavior, making the output untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Validates device readiness, retrieves configuration bytes, and executes iterative processing routines based on retrieved data, updating status and cleanup before returning the result code.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly vague and generic statements that do not map well to the specific code semantics. While 'validates device readiness' loosely matches initial checks for resource setup and memory validation, other claims such as 'retrieves configuration bytes' and 'cleanup before returning' are either inaccurate or too generic; the code retrieves CIS tuple data, not arbitrary configuration bytes, and there is no explicit cleanup routine. The summary omits key domain-specific steps like function count determination and card device addition, resulting in less than half of the claims being accurate.",
                "The summary fails to capture the core purpose of adding a PCMCIA card by validating resources, checking the CIS, determining function count, and invoking pcmcia_device_add for each function. Its claims are overly generic (e.g., 'validates device readiness', 'retrieves configuration bytes') and do not align with the specific domain semantics in the source code. No accurate claims match the core operation, and important error handling and branching details are omitted.",
                "The summary contains mostly inaccurate statements. The function does check readiness via resource setup and memory validation, but it does not retrieve 'configuration bytes' nor perform cleanup operations before return, as claimed. The iterative processing is limited to adding devices for each function, not broad 'processing routines'. Several phrases are vague or incorrect, introducing noise that overwhelms the minimal accurate content. The worst failure mode is NOISE dominating over sparse accurate claims, with no severe fatal error on core purpose but low informational value."
            ]
        },
        "comment": {
            "summary": "Adds a PCMCIA card to the socket after validating resources and reading its function information from the card's CIS.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately describes the core behavior: the function adds a PCMCIA card to the socket, performs resource validation, and obtains function information from the card's CIS before adding devices. These steps align with the code's sequence of checking resources, validating the CIS, determining the number of functions, and invoking pcmcia_device_add. The claims are both domain-specific and supported by the source code, with no inaccuracies or irrelevant statements.",
                "The summary accurately describes the core purpose of adding a PCMCIA card to the socket after validating resources and reading function info from the CIS, matching the main operation in the code. However, it omits important secondary details such as the handling of delayed addition when resources are not ready, the distinction between validation failures returning -EAGAIN vs -ENODEV, the loop over multiple functions, and mutex locking/unlocking behavior.",
                "The summary correctly captures the primary purpose \u2014 adding a PCMCIA card after validating resources and reading function info from the card\u2019s CIS \u2014 with no contradictory statements. It omits some specifics such as handling retry conditions via return codes (-EAGAIN, -ENODEV) and iterating over functions to add devices, but these are secondary to the core purpose. There is no noise or fatal error, and the claim is a concise, accurate representation, although detail level is moderate."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 1219488,
    "strip_function_name": "cms_SignedData_final",
    "strip_decompiled_code": "__int64 __fastcall cms_SignedData_final(__int64 *a1, int *a2)\n{\n  int v2; // r12d\n  unsigned int *v3; // r13\n  __int64 v4; // rbx\n  int v6; // eax\n  _BYTE *v7; // rax\n  char *v8; // [rsp+18h] [rbp-D0h]\n  void *v9; // [rsp+18h] [rbp-D0h]\n  int v10; // [rsp+2Ch] [rbp-BCh] BYREF\n  void *v11[6]; // [rsp+30h] [rbp-B8h] BYREF\n  char v12[72]; // [rsp+60h] [rbp-88h] BYREF\n  unsigned __int64 v13; // [rsp+A8h] [rbp-40h]\n\n  v2 = 0;\n  v13 = __readfsqword(0x28u);\n  v3 = (unsigned int *)CMS_get0_SignerInfos(a1);\n  if ( (int)sk_num(v3) <= 0 )\n  {\nLABEL_16:\n    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16LL) = 0;\n    return 1LL;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = sk_value((__int64)v3, v2);\n      EVP_MD_CTX_init(v11);\n      if ( !*(_QWORD *)(v4 + 64) )\n        break;\n      if ( !(unsigned int)cms_DigestAlgorithm_find_ctx((__int64 *)v11, a2, *(_QWORD **)(v4 + 16)) )\n        goto LABEL_4;\n      if ( (int)CMS_signed_get_attr_count(v4) < 0 )\n      {\n        v6 = EVP_PKEY_size(*(_QWORD *)(v4 + 64));\n        v7 = CRYPTO_malloc(v6, (__int64)\"cms_sd.c\", 0x295u);\n        if ( !v7 )\n        {\n          ERR_put_error(0x2Eu, 150, 65, (__int64)\"cms_sd.c\", 665);\n          goto LABEL_4;\n        }\n        v9 = v7;\n        if ( !(unsigned int)EVP_SignFinal(v11, (__int64)v7, &v10, *(_QWORD *)(v4 + 64)) )\n        {\n          ERR_put_error(0x2Eu, 150, 139, (__int64)\"cms_sd.c\", 671);\n          CRYPTO_free(v9);\nLABEL_4:\n          EVP_MD_CTX_cleanup((__int64 *)v11);\n          return 0LL;\n        }\n        ASN1_STRING_set0(*(_QWORD *)(v4 + 40), (__int64)v9, v10);\n      }\n      else\n      {\n        v8 = **(char ***)(a1[1] + 16);\n        if ( !(unsigned int)EVP_DigestFinal_ex(v11, (__int64)v12, &v10)\n          || !CMS_signed_add1_attr_by_NID(v4, 0x33u, 4u, v12, v10)\n          || (int)CMS_signed_add1_attr_by_NID(v4, 0x32u, 6u, v8, -1) <= 0\n          || !(unsigned int)CMS_SignerInfo_sign(v4) )\n        {\n          goto LABEL_4;\n        }\n      }\n      ++v2;\n      EVP_MD_CTX_cleanup((__int64 *)v11);\n      if ( v2 >= (int)sk_num(v3) )\n        goto LABEL_16;\n    }\n    ERR_put_error(0x2Eu, 150, 133, (__int64)\"cms_sd.c\", 629);\n    return 0LL;\n  }\n}\n",
    "function_name": "cms_SignedData_final",
    "decompiled_code": "__int64 __fastcall cms_SignedData_final(__int64 *a1, int *a2)\n{\n  int v2; // r12d\n  unsigned int *v3; // r13\n  __int64 v4; // rbx\n  int v6; // eax\n  _BYTE *v7; // rax\n  char *v8; // [rsp+18h] [rbp-D0h]\n  void *v9; // [rsp+18h] [rbp-D0h]\n  int v10; // [rsp+2Ch] [rbp-BCh] BYREF\n  void *v11[6]; // [rsp+30h] [rbp-B8h] BYREF\n  char v12[72]; // [rsp+60h] [rbp-88h] BYREF\n  unsigned __int64 v13; // [rsp+A8h] [rbp-40h]\n\n  v2 = 0;\n  v13 = __readfsqword(0x28u);\n  v3 = (unsigned int *)CMS_get0_SignerInfos(a1);\n  if ( (int)sk_num(v3) <= 0 )\n  {\nLABEL_16:\n    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16LL) = 0;\n    return 1LL;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = sk_value((__int64)v3, v2);\n      EVP_MD_CTX_init(v11);\n      if ( !*(_QWORD *)(v4 + 64) )\n        break;\n      if ( !(unsigned int)cms_DigestAlgorithm_find_ctx((__int64 *)v11, a2, *(_QWORD **)(v4 + 16)) )\n        goto LABEL_4;\n      if ( (int)CMS_signed_get_attr_count(v4) < 0 )\n      {\n        v6 = EVP_PKEY_size(*(_QWORD *)(v4 + 64));\n        v7 = CRYPTO_malloc(v6, (__int64)\"cms_sd.c\", 0x295u);\n        if ( !v7 )\n        {\n          ERR_put_error(0x2Eu, 150, 65, (__int64)\"cms_sd.c\", 665);\n          goto LABEL_4;\n        }\n        v9 = v7;\n        if ( !(unsigned int)EVP_SignFinal((__int64 *)v11, (__int64)v7, &v10, *(_QWORD *)(v4 + 64)) )\n        {\n          ERR_put_error(0x2Eu, 150, 139, (__int64)\"cms_sd.c\", 671);\n          CRYPTO_free(v9);\nLABEL_4:\n          EVP_MD_CTX_cleanup((__int64 *)v11);\n          return 0LL;\n        }\n        ASN1_STRING_set0(*(_QWORD *)(v4 + 40), (__int64)v9, v10);\n      }\n      else\n      {\n        v8 = **(char ***)(a1[1] + 16);\n        if ( !(unsigned int)EVP_DigestFinal_ex(v11, (__int64)v12, &v10)\n          || !CMS_signed_add1_attr_by_NID(v4, 0x33u, 4u, v12, v10)\n          || (int)CMS_signed_add1_attr_by_NID(v4, 0x32u, 6u, v8, -1) <= 0\n          || !(unsigned int)CMS_SignerInfo_sign(v4) )\n        {\n          goto LABEL_4;\n        }\n      }\n      ++v2;\n      EVP_MD_CTX_cleanup((__int64 *)v11);\n      if ( v2 >= (int)sk_num(v3) )\n        goto LABEL_16;\n    }\n    ERR_put_error(0x2Eu, 150, 133, (__int64)\"cms_sd.c\", 629);\n    return 0LL;\n  }\n}\n",
    "source_code": "\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n\t{\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tCMS_SignerInfo *si;\n\tint i;\n\tsinfos = CMS_get0_SignerInfos(cms);\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tif (!cms_SignerInfo_content_sign(cms, si, chain))\n\t\t\treturn 0;\n\t\t}\n\tcms->d.signedData->encapContentInfo->partial = 0;\n\treturn 1;\n\t}",
    "comment": "Finalizes the signing process for all signer information in the CMS_ContentInfo structure by signing the content and marking it as complete.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Finalizes the signer information structure by generating a digital signature , encoding it , and storing it in the provided CMS_SignerInfo structure .\n",
    "cpbcs_sum": "Verifies the digital signature of a PKCS7 structure using the provided context and signature algorithm after validating the key.\n",
    "misum_sum": "Generates a temporary key of specified digest algorithms using the provided EVP_PKEY structure and stores it in an EVP_PKEY structure.\n",
    "decom_sum": "Generates and attaches digital signatures or message digests to all CMS signer infos, handling errors and finalizing the signed data structure.",
    "cfg_sum": "Finalizes CMS SignedData by processing each signer\u2019s information, generating or adding required signature attributes, signing, and returning success or failure status.",
    "work_score": {
        "decom": {
            "summary": "Generates and attaches digital signatures or message digests to all CMS signer infos, handling errors and finalizing the signed data structure.",
            "score": [
                0.8,
                0.6,
                0.2
            ],
            "reason": [
                "The summary accurately reflects that the function iterates through all CMS signer infos and calls a signing routine, and that it finalizes the signed data structure by setting the partial flag to 0. However, the claim of generating and attaching message digests is less precise, as the source code specifically invokes a signing helper without explicit digest generation logic. Overall, most claims are aligned with the code, with only minor overgeneralization.",
                "The summary correctly conveys that the function finalizes a CMS signed data structure and processes all signer infos with signing operations, which aligns with the core purpose of iterating over each signer and calling a signing routine. It also notes error handling through early return on failure. However, it inaccurately broadens the operation to \u2018generates and attaches message digests\u2019 without evidence in the source code, omitting specific details such as setting the `partial` flag to 0. Secondary coverage is moderate, addressing iteration and finalization but missing constants and explicit flag changes.",
                "The summary\u2019s core claim about generating and attaching digital signatures or message digests is inaccurate because the source shows the function finalizes existing signer infos by calling `cms_SignerInfo_content_sign` and updating the `partial` flag, not performing full generation/attachment from scratch. While it correctly notes handling errors and finalizing the signed data, the primary purpose is misstated, making this a severe factual error on core behavior."
            ]
        },
        "cfg": {
            "summary": "Finalizes CMS SignedData by processing each signer\u2019s information, generating or adding required signature attributes, signing, and returning success or failure status.",
            "score": [
                0.6,
                0.6,
                0.5
            ],
            "reason": [
                "The summary claims that the function generates or adds signature attributes, which is not shown in the source code, making that portion inaccurate. It correctly describes that the function processes each signer\u2019s information, attempts signing via cms_SignerInfo_content_sign, and returns success or failure, but the added behavior about signature attributes is unsupported. As a result, the majority of claims are accurate but with a notable inaccuracy reducing alignment.",
                "The summary correctly identifies that the function finalizes CMS SignedData by iterating through each signer\u2019s information and performing signing, which matches the core purpose in the source code. It also notes returning success or failure, which is accurate. However, it adds speculative details such as 'generating or adding required signature attributes' that are not explicitly supported in the source code. Additionally, it omits the detail that the 'partial' flag in encapContentInfo is set to 0, which is a notable side effect. This yields solid core coverage but incomplete secondary semantic coverage.",
                "The summary correctly states that the function processes each signer\u2019s information, signs, and returns a success/failure status, aligning with the loop over signer infos and return values in the code. However, the mention of generating or adding required signature attributes is not explicitly supported in the source, making this part speculative noise. No fatal inaccuracies about the core purpose or key I/O exist, but the extra unsupported detail reduces precision, yielding low informational gain."
            ]
        },
        "comment": {
            "summary": "Finalizes the signing process for all signer information in the CMS_ContentInfo structure by signing the content and marking it as complete.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly describes the function\u2019s behavior: it iterates through all signer infos in the CMS_ContentInfo, calls the signing routine for each, and marks the encapsulated content as complete. These claims directly correspond to the source code semantics and are accurate. There are no extraneous or incorrect statements, resulting in a high proportion of accurate claims.",
                "The summary correctly states the core purpose: finalizing the signing process for all signer infos in a CMS_ContentInfo by signing their content and marking it complete, which matches the loop over signer infos, the call to cms_SignerInfo_content_sign, and setting partial to 0. However, it omits secondary behavioral details such as returning 0 on a signing failure and returning 1 on success, and does not mention the iteration mechanism or data structures involved, resulting in limited coverage of other critical semantics.",
                "The summary correctly captures the core behavior: iterating over all signer infos in the CMS_ContentInfo, signing their content, and marking the content as complete, which directly aligns with the source code. There are no contradictory or irrelevant claims, and the main purpose is accurately represented. The gain is moderate, as the description is clear but generic and lacks details about specific structures or functions used."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585401680,
    "strip_function_name": "sub_FFFFFFFF81640B50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81640B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  unsigned int v6; // r12d\n  __int64 v7; // rcx\n  __int64 v8; // rcx\n  unsigned int v9; // edx\n  __int64 result; // rax\n\n  v6 = a3;\n  v7 = *(unsigned int *)(a2 + 200);\n  if ( (*(_BYTE *)(a2 + 124) & 2) == 0 )\n    goto LABEL_2;\n  v8 = *(_QWORD *)(a2 + 208) + v7;\n  if ( (unsigned __int16)*(_DWORD *)(v8 + 36) != 1 && !byte_FFFFFFFF81CAC6A7 )\n  {\n    sub_FFFFFFFF8103BB80((__int64)\"net/ipv4/tcp_output.c\", 993, a3, v8, a5, a6);\n    byte_FFFFFFFF81CAC6A7 = 1;\n    v7 = *(unsigned int *)(a2 + 200);\nLABEL_2:\n    v8 = *(_QWORD *)(a2 + 208) + v7;\n  }\n  v9 = *(_DWORD *)(a2 + 104);\n  if ( v9 > v6\n    && *(_DWORD *)(a1 + 304) << 16 == (*(_QWORD *)(a1 + 288) & (int)(*(_DWORD *)(a1 + 304) << 16))\n    && (*(_BYTE *)(a2 + 124) & 0xC) != 0 )\n  {\n    *(_WORD *)(v8 + 4) = (v9 + v6 - 1) / v6;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = v6;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = *(_DWORD *)(a1 + 304);\n  }\n  else\n  {\n    *(_WORD *)(v8 + 4) = 1;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = 0;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = 0;\n  }\n  return result;\n}\n",
    "function_name": "tcp_set_skb_tso_segs",
    "decompiled_code": "__int64 __fastcall tcp_set_skb_tso_segs(\n        __int64 a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v12; // rcx\n  __int64 v13; // rcx\n  unsigned int v14; // edx\n  __int64 result; // rax\n\n  v12 = *(unsigned int *)(a2 + 200);\n  if ( (*(_BYTE *)(a2 + 124) & 2) == 0 )\n    goto LABEL_2;\n  v13 = *(_QWORD *)(a2 + 208) + v12;\n  if ( (unsigned __int16)*(_DWORD *)(v13 + 36) != 1 && !_warned_45322 )\n  {\n    warn_slowpath_null(\"net/ipv4/tcp_output.c\", 0x3E1u, a4, a5, a6, a7, a8, a9, a10, a11);\n    _warned_45322 = 1;\n    v12 = *(unsigned int *)(a2 + 200);\nLABEL_2:\n    v13 = *(_QWORD *)(a2 + 208) + v12;\n  }\n  v14 = *(_DWORD *)(a2 + 104);\n  if ( v14 > a3\n    && *(_DWORD *)(a1 + 304) << 16 == (*(_QWORD *)(a1 + 288) & (int)(*(_DWORD *)(a1 + 304) << 16))\n    && (*(_BYTE *)(a2 + 124) & 0xC) != 0 )\n  {\n    *(_WORD *)(v13 + 4) = (v14 + a3 - 1) / a3;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = a3;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = *(_DWORD *)(a1 + 304);\n  }\n  else\n  {\n    *(_WORD *)(v13 + 4) = 1;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = 0;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = 0;\n  }\n  return result;\n}\n",
    "source_code": "static void tcp_set_skb_tso_segs(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int mss_now)\n{\n\tif (skb->len <= mss_now || !sk_can_gso(sk) ||\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\t/* Avoid the costly divide in the normal\n\t\t * non-TSO case.\n\t\t */\n\t\tskb_shinfo(skb)->gso_segs = 1;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t} else {\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss_now);\n\t\tskb_shinfo(skb)->gso_size = mss_now;\n\t\tskb_shinfo(skb)->gso_type = sk->sk_gso_type;\n\t}\n}",
    "comment": "Sets the TCP segmentation offload parameters for a socket buffer based on its length and the maximum segment size.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Calculates the TCP transmission unit ( PMTU ) for a given socket buffer based on its header and socket parameters .\n",
    "cpbcs_sum": "Copies TCP packets from the source socket to the destination buffer, ensuring the buffer is not fragmented and the specified socket.\n",
    "misum_sum": "Adds a TCP segment to a socket buffer, adjusting fragment sizes and timestamp based on the TCP segment and segment length.\n",
    "decom_sum": "Configures TCP segment header fields for output based on connection state, segment size, and flow control conditions in net/ipv4/tcp_output.c.",
    "cfg_sum": "Validates TCP segment data, logs anomalies once, and updates packet header fields based on buffer state and connection parameters before returning the offset.",
    "work_score": {
        "decom": {
            "summary": "Configures TCP segment header fields for output based on connection state, segment size, and flow control conditions in net/ipv4/tcp_output.c.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function configures TCP segment header fields based on connection state, segment size, and flow control conditions. While segment size is directly relevant and present in the code, the mention of connection state and flow control conditions is inaccurate as the function only checks specific criteria like MSS, GSO capability, and checksum state without general connection state or flow control logic. This makes less than half of the claims accurate, reducing the overall precision.",
                "The summary vaguely states that the function configures TCP segment header fields based on connection state, segment size, and flow control conditions, but it does not accurately capture the core purpose: setting GSO (Generic Segmentation Offload) parameters on the skb depending on MSS and checksum/GSO capability. The wording does not mention GSO-specific fields or the branch logic for non-TSO versus TSO cases, leading to a failure to cover the primary domain action and omitting critical secondary behaviors such as setting gso_segs, gso_size, and gso_type.",
                "The summary incorrectly describes the function as configuring TCP segment header fields and involving flow control conditions, which is not reflected in the source code. The actual function sets GSO segmentation-related fields (`gso_segs`, `gso_size`, `gso_type`) in the `skb_shinfo` based on packet length, MSS, and GSO capability, not header fields or flow control. This is a FATAL error targeting the primary purpose and core semantics, leaving no accurate or useful claims."
            ]
        },
        "cfg": {
            "summary": "Validates TCP segment data, logs anomalies once, and updates packet header fields based on buffer state and connection parameters before returning the offset.",
            "score": [
                0.2,
                0.1,
                0.1
            ],
            "reason": [
                "The summary contains multiple fact-based claims, but most are inaccurate relative to the source code. It incorrectly asserts that the function validates TCP segment data, logs anomalies once, and returns an offset \u2014 none of which occur in the code. The code sets GSO segment count, size, and type based on MSS, buffer state, and connection parameters, but does not perform logging or return a value. Only the part mentioning updating packet header fields based on buffer state and connection parameters is partially accurate, while the remainder is inaccurate, resulting in less than 50% accuracy.",
                "The summary's claims are inaccurate: the code does not perform validation of TCP segment data, logging, or returning an offset. The core purpose\u2014setting skb GSO segmentation fields based on conditions like length, MSS, GSO capability, and checksum state\u2014is entirely missing. No accurate coverage of branch logic, field assignments, or conditional behavior is present, so the core semantics are not reflected at all.",
                "The summary contains multiple inaccurate claims. It states that the function validates TCP segment data, logs anomalies once, and returns an offset, none of which are present in the source code. These are FATAL errors targeting the primary purpose and key outputs. The actual function sets gso_segs, gso_size, and gso_type based on buffer length, MSS, and GSO capability, with no logging or offset return. There are no accurate claims in the summary, making it unusable."
            ]
        },
        "comment": {
            "summary": "Sets the TCP segmentation offload parameters for a socket buffer based on its length and the maximum segment size.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly captures the key semantic of the function: it sets TCP segmentation offload parameters for a socket buffer depending on its length and the provided maximum segment size. While it does not mention all conditional checks such as sk_can_gso or ip_summed, it does not make any incorrect claims. The main claim aligns well with the source code\u2019s primary purpose, making it a highly accurate and concise description.",
                "The summary accurately states the core purpose of the function, which is setting TCP segmentation offload parameters for a socket buffer based on its length and MSS, matching the main operation in the source code. However, it omits important secondary details such as the conditional checks for GSO capability and checksum state, as well as the specific assignments to gso_size, gso_segs, and gso_type in both branches, which are behavior-critical. Coverage of the core is present but secondary semantics are weak.",
                "The summary correctly identifies the core purpose of the function: setting TCP segmentation offload parameters for a socket buffer, and notes the decision is based on the buffer length and maximum segment size. This matches the source code\u2019s logic without introducing inaccuracies. However, it is generic and omits specific implementation details such as conditions preventing TSO, the exact fields being set (gso_segs, gso_size, gso_type), and the calculation of segment count, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 450304,
    "strip_function_name": "sub_6DF00",
    "strip_decompiled_code": "__int64 __fastcall sub_6DF00(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v5; // rbp\n  __int64 v6; // rax\n  __int64 v7; // rdi\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  unsigned int v11; // eax\n  int v12; // edx\n  int v13; // ecx\n  int v14; // r8d\n  int v15; // r9d\n  unsigned int v16; // eax\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  char v21[8200]; // [rsp+0h] [rbp-2028h] BYREF\n  unsigned __int64 v22; // [rsp+2008h] [rbp-20h]\n\n  v22 = __readfsqword(0x28u);\n  Rf_checkArityCall(a2, a3, a1);\n  v5 = *(_QWORD *)(a3 + 32);\n  if ( (*(_BYTE *)v5 & 0x1F) != 0x10 || v5 == *(_QWORD *)&R_NilValue )\n    goto LABEL_13;\n  if ( *(char *)v5 < 0 )\n    v6 = ALTREP_LENGTH(*(_QWORD *)(a3 + 32));\n  else\n    v6 = *(_QWORD *)(v5 + 32);\n  if ( v6 > 0x7FFFFFFF )\n    R_BadLongVector(v5, \"Rdynload.c\", 960LL);\n  if ( (_DWORD)v6 != 1 )\n  {\nLABEL_13:\n    v11 = (unsigned int)dcgettext(0LL, \"character argument expected\", 5);\n    Rf_error(v11, (unsigned int)\"character argument expected\", v12, v13, v14, v15);\n  }\n  v7 = *(_QWORD *)(a3 + 32);\n  if ( *(char *)v7 < 0 )\n    v8 = ALTSTRING_ELT(v7, 0LL);\n  else\n    v8 = *(_QWORD *)(v7 + 48);\n  v9 = Rf_translateChar(v8);\n  (*((void (__fastcall **)(__int64, char *, __int64))off_512010 + 7))(a1, v21, v9);\n  if ( !(unsigned int)sub_6D7D0(v21) )\n  {\n    v16 = (unsigned int)dcgettext(0LL, \"shared object '%s' was not loaded\", 5);\n    Rf_error(v16, (unsigned int)v21, v17, v18, v19, v20);\n  }\n  return *(_QWORD *)&R_NilValue;\n}\n",
    "function_name": "do_dynunload",
    "decompiled_code": "__int64 __fastcall do_dynunload(\n        char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        double a11,\n        double a12,\n        __m128 a13,\n        __m128 a14)\n{\n  __int64 v17; // rsi\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n  __m128 v21; // xmm4\n  __m128 v22; // xmm5\n  __int64 v23; // rbp\n  __int64 v24; // rdx\n  __int64 v25; // rax\n  __int64 v26; // rdi\n  __int64 v27; // rdi\n  void *v28; // rax\n  unsigned int v30; // eax\n  __int64 v31; // rdx\n  __int64 v32; // rcx\n  __int64 v33; // r8\n  __int64 v34; // r9\n  __m128 v35; // xmm4\n  __m128 v36; // xmm5\n  unsigned int v37; // eax\n  __int64 v38; // rdx\n  __int64 v39; // rcx\n  __int64 v40; // r8\n  __int64 v41; // r9\n  __m128 v42; // xmm4\n  __m128 v43; // xmm5\n  char v44[8200]; // [rsp+0h] [rbp-2028h] BYREF\n  unsigned __int64 v45; // [rsp+2008h] [rbp-20h]\n\n  v17 = a3;\n  v45 = __readfsqword(0x28u);\n  Rf_checkArityCall(a2, a3, a1, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);\n  v23 = *(_QWORD *)(a3 + 32);\n  v24 = *(_BYTE *)v23 & 0x1F;\n  if ( (_BYTE)v24 != 16 || v23 == *(_QWORD *)&R_NilValue )\n    goto LABEL_13;\n  if ( *(char *)v23 < 0 )\n    v25 = ALTREP_LENGTH(*(_QWORD *)(a3 + 32));\n  else\n    v25 = *(_QWORD *)(v23 + 32);\n  if ( v25 > 0x7FFFFFFF )\n    R_BadLongVector(\n      a7,\n      a8,\n      a9,\n      a10,\n      *(double *)v21.m128_u64,\n      *(double *)v22.m128_u64,\n      a13,\n      a14,\n      v23,\n      (__int64)\"Rdynload.c\",\n      0x3C0u);\n  if ( (_DWORD)v25 != 1 )\n  {\nLABEL_13:\n    v30 = (unsigned int)dcgettext(0LL, \"character argument expected\", 5);\n    Rf_error(v30, (__int64)\"character argument expected\", v31, v32, v33, v34, a7, a8, a9, a10, v35, v36, a13, a14);\n  }\n  v26 = *(_QWORD *)(a3 + 32);\n  if ( *(char *)v26 < 0 )\n  {\n    v17 = 0LL;\n    v27 = ALTSTRING_ELT(v26, 0, v24, v18, v19, v20);\n  }\n  else\n  {\n    v27 = *(_QWORD *)(v26 + 48);\n  }\n  v28 = Rf_translateChar(v27, a7, a8, a9, a10, v21, v22, a13, a14, v17, v24, v18, v19, v20);\n  (*((void (__fastcall **)(char *, char *, void *))R_osDynSymbol + 7))(a1, v44, v28);\n  if ( !(unsigned int)DeleteDLL(v44) )\n  {\n    v37 = (unsigned int)dcgettext(0LL, \"shared object '%s' was not loaded\", 5);\n    Rf_error(v37, (__int64)v44, v38, v39, v40, v41, a7, a8, a9, a10, v42, v43, a13, a14);\n  }\n  return *(_QWORD *)&R_NilValue;\n}\n",
    "source_code": "\nSEXP attribute_hidden do_dynunload(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    char buf[2 * PATH_MAX];\n\n    checkArity(op,args);\n    if (!isString(CAR(args)) || LENGTH(CAR(args)) != 1)\n\terror(_(\"character argument expected\"));\n    GetFullDLLPath(call, buf, translateChar(STRING_ELT(CAR(args), 0)));\n    if(!DeleteDLL(buf))\n\terror(_(\"shared object '%s\\' was not loaded\"), buf);\n    return R_NilValue;\n}",
    "comment": "Unloads a shared object from memory by verifying the argument and deleting its associated DLL using the full path derived from the input.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Sets the error message in R to a specified character string , ensuring it is a single string argument .\n",
    "cpbcs_sum": "Sets the error message domain for a specified R environment using the provided arguments, ensuring it is a single string argument.\n",
    "misum_sum": "Reads environment variables from a specified file and returns a logical value indicating successful reading or failure.\n",
    "decom_sum": "Loads a named shared object in R, validating a single-character argument and raising an error if the object was not loaded.",
    "cfg_sum": "Validates that the input is a single character string, translates it, attempts to load the specified shared object, and raises errors if loading fails.",
    "work_score": {
        "decom": {
            "summary": "Loads a named shared object in R, validating a single-character argument and raising an error if the object was not loaded.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function loads a shared object, while the source code clearly attempts to unload one using DeleteDLL. Although it mentions validating a single-character argument and raising errors when the object is not loaded, the core semantic \u2014 loading vs. unloading \u2014 is inaccurate, making a critical functional claim wrong. This results in less than half the claims being accurate.",
                "The summary incorrectly states that the function loads a shared object, whereas the source code shows it performs dynamic unloading of a specified DLL. While it mentions validation of the argument and error handling, the core primary purpose \u2014 unloading a named shared object and erroring if it was not loaded \u2014 is not accurately covered. This contradiction means the main domain action is missing, leaving coverage of critical behavior incomplete.",
                "The summary contains a severe factual error about the primary purpose: it claims the function loads a named shared object, while the source code clearly performs unloading via DeleteDLL. Although it correctly notes validation of a single-character argument and an error when the object was not loaded, the core domain action is misrepresented, making it untrustworthy for understanding the function\u2019s purpose."
            ]
        },
        "cfg": {
            "summary": "Validates that the input is a single character string, translates it, attempts to load the specified shared object, and raises errors if loading fails.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function validates the input as a single character string, but it inaccurately claims that it attempts to load the specified shared object. The source code instead attempts to unload the shared object via DeleteDLL. This contradiction means a significant portion of the claims are inaccurate, with less than half matching the actual code behavior.",
                "The summary correctly mentions validation of a single character string and error handling, but it inaccurately describes the core functionality: the code unloads a shared object via DeleteDLL, not loads it. This misrepresentation means the CORE_PRIMARY_PURPOSE is not covered. While there is some accurate detail about input checking, the main operation is fundamentally wrong, and little secondary functionality is provided.",
                "The summary correctly notes that the function validates the input as a single character string and raises errors if conditions fail, but it inaccurately claims that it attempts to load a shared object. The source code clearly calls DeleteDLL, which performs unloading rather than loading. This is a FATAL inaccuracy targeting the core purpose of the function, making the description misleading about the main action performed."
            ]
        },
        "comment": {
            "summary": "Unloads a shared object from memory by verifying the argument and deleting its associated DLL using the full path derived from the input.",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function unloads a shared object from memory, verifies the argument, and deletes the DLL using a full path derived from input. These points align with the source code's checks for a single string argument, construction of the full DLL path via GetFullDLLPath, and deletion via DeleteDLL. No contradictory or irrelevant claims are present, making the content highly accurate.",
                "The summary correctly identifies the core purpose as unloading a shared object by validating the argument and deleting the DLL via its full path, which aligns with the source code's main sequence: checking argument type and length, deriving the DLL path, and deleting it. However, it omits secondary details such as the specific error handling messages when the argument is invalid or when deletion fails, as well as the use of PATH_MAX for buffer size.",
                "The summary correctly states that the function unloads a shared object by verifying the argument and deleting the associated DLL using the full path derived from the input, which aligns with the source code's logic of checking the argument type/length, constructing the path with GetFullDLLPath, and calling DeleteDLL. No inaccuracies or off-topic noise are present, and the claim is specific to the domain semantics, providing clear insight into the core purpose and I/O behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579563904,
    "strip_function_name": "sub_FFFFFFFF810AF780",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810AF780(__int64 a1)\n{\n  _QWORD *v2; // rbx\n  __int64 v3; // r13\n  int v4; // ebx\n  __int64 v5; // rax\n  int v6; // [rsp-2Ch] [rbp-2Ch] BYREF\n  _UNKNOWN **v7; // [rsp-28h] [rbp-28h]\n\n  if ( !dword_FFFFFFFF81E66B68 )\n    return 0LL;\n  v7 = (_UNKNOWN **)off_FFFFFFFF81C365F0;\n  v2 = off_FFFFFFFF81C365F0;\n  if ( off_FFFFFFFF81C365F0 == (_UNKNOWN *)&off_FFFFFFFF81C365F0 )\n  {\nLABEL_11:\n    v3 = 0LL;\n    v4 = 1;\n  }\n  else\n  {\n    while ( !(unsigned int)sub_FFFFFFFF810AD5F0(a1, v2 + 4, 0LL, 0LL, &v6, 1LL) )\n    {\n      v7 = (_UNKNOWN **)*v2;\n      v2 = v7;\n      if ( v7 == &off_FFFFFFFF81C365F0 )\n        goto LABEL_11;\n    }\n    v3 = 0LL;\n    if ( v6 == 2 )\n      v3 = sub_FFFFFFFF81100020(v2[39], 32LL);\n    v4 = v6;\n    if ( !v6 )\n      return 0LL;\n  }\n  v5 = sub_FFFFFFFF8112CA50(qword_FFFFFFFF81E8C750, 32976LL, 864LL);\n  if ( v5 )\n  {\n    *(_DWORD *)(v5 + 8) = v4;\n    *(_QWORD *)(v5 + 600) = v3;\n    *(_QWORD *)(v5 + 80) = -(__int64)(v4 == 2);\n    *(_QWORD *)(v5 + 760) = v5 + 760;\n    *(_QWORD *)(v5 + 768) = v5 + 760;\n    *(_QWORD *)(v5 + 584) = v5 + 584;\n    *(_QWORD *)(v5 + 592) = v5 + 584;\n    *(_QWORD *)(a1 + 1464) = v5;\n    _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a1 + 8) + 16LL), 0x80u);\n    return 0LL;\n  }\n  sub_FFFFFFFF8112DCD0(v3);\n  sub_FFFFFFFF810A8A10((int)\"out of memory in audit_alloc\", 32976LL);\n  return 4294967284LL;\n}\n",
    "function_name": "audit_alloc",
    "decompiled_code": "__int64 __fastcall audit_alloc(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  _QWORD *v10; // rbx\n  unsigned __int64 v11; // r13\n  int v12; // ebx\n  __int64 v13; // rax\n  __int64 *v14; // rdx\n  __int64 v15; // rcx\n  int v16; // r8d\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  int v22; // [rsp-2Ch] [rbp-2Ch] BYREF\n  _UNKNOWN **v23; // [rsp-28h] [rbp-28h]\n\n  if ( !audit_ever_enabled )\n    return 0LL;\n  v23 = (_UNKNOWN **)off_FFFFFFFF81C365F0;\n  v10 = off_FFFFFFFF81C365F0;\n  if ( off_FFFFFFFF81C365F0 == (_UNKNOWN *)&off_FFFFFFFF81C365F0 )\n  {\nLABEL_11:\n    v11 = 0LL;\n    v12 = 1;\n  }\n  else\n  {\n    while ( !(unsigned int)audit_filter_rules(a1, v10 + 4, 0LL, 0LL, &v22, 1LL) )\n    {\n      v23 = (_UNKNOWN **)*v10;\n      v10 = v23;\n      if ( v23 == &off_FFFFFFFF81C365F0 )\n        goto LABEL_11;\n    }\n    v11 = 0LL;\n    if ( v22 == 2 )\n      v11 = kstrdup(v10[39], 0x20u);\n    v12 = v22;\n    if ( !v22 )\n      return 0LL;\n  }\n  v13 = kmem_cache_alloc_trace((_QWORD *)qword_FFFFFFFF81E8C750, 0x80D0u, 864LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( v13 )\n  {\n    *(_DWORD *)(v13 + 8) = v12;\n    *(_QWORD *)(v13 + 600) = v11;\n    *(_QWORD *)(v13 + 80) = -(__int64)(v12 == 2);\n    *(_QWORD *)(v13 + 760) = v13 + 760;\n    *(_QWORD *)(v13 + 768) = v13 + 760;\n    *(_QWORD *)(v13 + 584) = v13 + 584;\n    *(_QWORD *)(v13 + 592) = v13 + 584;\n    *(_QWORD *)(a1 + 1464) = v13;\n    _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a1 + 8) + 16LL), 0x80u);\n    return 0LL;\n  }\n  kfree(v11, a2, a3, a4, a5, v18, v19, a8, a9, 32976LL, v14, v15, v16, v17);\n  audit_log_lost((__int64)\"out of memory in audit_alloc\", a2, a3, a4, a5, v20, v21, a8, a9);\n  return 4294967284LL;\n}\n",
    "source_code": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED)\n\t\treturn 0;\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "comment": "Allocates an audit context for a given task if auditing is enabled and filters the task based on its audit state.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Checks if a specified audit filter exists by comparing it against a list of valid audit filters .\n",
    "cpbcs_sum": "Initiates a system core dump for userspace registered devices by verifying their memory against the provided limit and updating flags accordingly.\n",
    "misum_sum": "Reserves memory for a memory type if the address space is not already set, updating the mapping list and mapping accordingly.\n",
    "decom_sum": "Allocates and initializes an audit structure for the given context, setting status fields and flags, or logs an out-of-memory error on failure.",
    "cfg_sum": "Allocates and initializes an audit data structure for the given context, setting type-specific fields and handling errors when memory allocation fails.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes an audit structure for the given context, setting status fields and flags, or logs an out-of-memory error on failure.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly conveys that the function allocates and initializes an audit structure for a given task, sets flags, and logs an out-of-memory error on failure, which matches the code behavior. However, it omits key control flow details such as early return when auditing is disabled or when `AUDIT_DISABLED` is assigned, making it less precise. Most claims are accurate but somewhat generic, missing some domain-specific specificity from the source.",
                "The summary correctly identifies that the function allocates and initializes an audit structure and sets status/flags, and mentions logging an out-of-memory error on allocation failure, which aligns with the code\u2019s behavior. However, it omits the core conditional logic: returning early when auditing is disabled or not enabled, and the task-based filtering step via audit_filter_task. These omissions mean the core primary purpose\u2014allocating and attaching an audit context to a task only when auditing is enabled and permitted\u2014is not fully covered.",
                "The summary correctly captures the primary purpose: allocating and initializing an audit context for the given task, and setting relevant flags. It also accurately mentions logging an out-of-memory error on allocation failure. However, it omits certain specific details from the code, such as checking whether auditing is enabled and freeing the key on failure, which limits informational gain. There are no contradictory claims, so no FATAL errors are present; overall accuracy is reasonable but with low detail depth."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes an audit data structure for the given context, setting type-specific fields and handling errors when memory allocation fails.",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary correctly notes allocation and initialization of an audit data structure and mentions error handling for memory allocation failures, both of which align with the source code. However, it inaccurately generalizes 'type-specific fields' without reflecting the actual details, such as setting the filter key and a task thread flag, and omits important audit-specific control flow like returning early if auditing is disabled or the state is AUDIT_DISABLED. This reduces the proportion of precise, code-grounded claims to around half.",
                "The summary correctly mentions allocation and error handling for memory failure, which matches behaviors in the source code. However, it does not capture the core primary purpose of deciding whether to audit a task by filtering it, allocating an audit_context, and attaching it to the task along with setting the syscall audit flag. The description is generic (\u2018audit data structure\u2019) and omits key domain-specific details such as checking audit_ever_enabled, handling AUDIT_DISABLED, storing a filter key, and setting TIF_SYSCALL_AUDIT. Consequently, the core operation is not covered and secondary points are minimal.",
                "The summary correctly notes that the function allocates and initializes an audit-related structure and handles errors on allocation failure, which matches the code's logic. However, it inaccurately states 'for the given context' when the code actually creates a new audit_context for the provided task_struct, and 'setting type-specific fields' is vague and does not reflect the specific field assignment to filterkey or setting task/thread flags. The inaccuracies are minor and generic, not contradicting core purpose, but the gain from the accurate parts is low due to lack of specific behavioral detail. Noise is present but not overwhelming, giving low net benefit."
            ]
        },
        "comment": {
            "summary": "Allocates an audit context for a given task if auditing is enabled and filters the task based on its audit state.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function allocates an audit context for a given task if auditing is enabled, which aligns with the check for `audit_ever_enabled` and subsequent allocation. It also mentions filtering the task based on its audit state, which matches the `audit_filter_task` call and state handling in the code. While concise, both claims are accurate reflections of the source code's domain semantics, resulting in high alignment.",
                "The summary correctly notes that the function allocates an audit context for a task when auditing is enabled and that it filters the task by audit state, aligning with the core purpose found in the code. However, it omits key secondary behaviors such as handling AUDIT_DISABLED by returning early, freeing the key on allocation failure, logging an out-of-memory error, setting the task\u2019s audit_context, and enabling the TIF_SYSCALL_AUDIT thread flag. This results in incomplete coverage beyond the core action.",
                "The summary correctly states that the function allocates an audit context for a task if auditing is enabled and that it filters the task based on its audit state, which matches the source code\u2019s logic. However, it omits key specific behaviors such as returning 0 when auditing is disabled or when the state is AUDIT_DISABLED, handling out-of-memory errors with logging and cleanup, and setting the TIF_SYSCALL_AUDIT flag. These omissions mean the gain is low, but there are no inaccurate claims\u2014noise is minimal and accuracy is preserved for the core purpose."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4306256,
    "strip_function_name": "sub_41B550",
    "strip_decompiled_code": "__int64 __fastcall sub_41B550(__int64 a1, const char *a2, int a3, int *a4, __int64 a5, __int64 *a6, char a7)\n{\n  __int64 v7; // rbx\n  unsigned int v8; // ebp\n  int v9; // eax\n  __int64 v10; // rdx\n  int v11; // eax\n  __int64 v12; // rdx\n  char *v14; // rax\n  __int64 v15; // rdx\n  const char *v16; // rbx\n  int v17; // eax\n\n  v7 = *a4;\n  v8 = a7 & 1;\n  if ( (a7 & 1) != 0 )\n  {\n    *a4 = v7 + 1;\n    v9 = strlen(a2) + 1;\n    v10 = v9;\n    v11 = v9 & 7;\n    v12 = *a6 + v10 + 8;\n    if ( v11 )\n      v12 = v12 + 8 - v11;\n    *a6 = v12;\n    return v8;\n  }\n  if ( a3 <= (int)v7 )\n  {\n    v16 = (const char *)(a1 + 176644);\n    sprintf((char *)(a1 + 176644), \"Number of matching files changed unexpectedly (> %d)\", a3);\n    if ( (a7 & 2) != 0 )\n    {\n      sub_4118F0((_DWORD *)a1, 0, v16, 0, \"FATAL\", 0);\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      sub_4118F0((_DWORD *)a1, 0, v16, 0, \"WARNING\", 0);\n      return a7 & 2;\n    }\n  }\n  else\n  {\n    v14 = strdup(a2);\n    v15 = *a4;\n    *(_QWORD *)(a5 + 8 * v7) = v14;\n    if ( !*(_QWORD *)(a5 + 8 * v15) )\n    {\n      v8 = -1;\n      v17 = strlen(a2);\n      sub_41B3D0(a1, v17 + 1);\n      return v8;\n    }\n    *a4 = v15 + 1;\n    return 1LL;\n  }\n}\n",
    "function_name": "Xorriso_register_matched_adr",
    "decompiled_code": "__int64 __fastcall Xorriso_register_matched_adr(\n        XorrisO *a1,\n        char *adr,\n        int count_limit,\n        int *filec,\n        char **filev,\n        off_t *mem,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        char flag)\n{\n  __int64 v11; // rbx\n  unsigned int v12; // ebp\n  int v13; // eax\n  __int64 v14; // rdx\n  int v15; // eax\n  off_t v16; // rdx\n  char *v18; // rax\n  __int64 v19; // rdx\n  char *info_text; // rbx\n  size_t v21; // rax\n\n  v11 = *filec;\n  v12 = flag & 1;\n  if ( (flag & 1) != 0 )\n  {\n    *filec = v11 + 1;\n    v13 = strlen(adr) + 1;\n    v14 = v13;\n    v15 = v13 & 7;\n    v16 = *mem + v14 + 8;\n    if ( v15 )\n      v16 = v16 + 8 - v15;\n    *mem = v16;\n    return v12;\n  }\n  if ( count_limit <= (int)v11 )\n  {\n    info_text = a1->info_text;\n    sprintf(a1->info_text, \"Number of matching files changed unexpectedly (> %d)\", count_limit);\n    if ( (flag & 2) != 0 )\n    {\n      Xorriso_msgs_submit(a1, 0, info_text, 0, dword_5000F4, 0);\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      Xorriso_msgs_submit(a1, 0, info_text, 0, &s[445], 0);\n      return flag & 2;\n    }\n  }\n  else\n  {\n    v18 = strdup(adr);\n    v19 = *filec;\n    filev[v11] = v18;\n    if ( !filev[v19] )\n    {\n      v12 = -1;\n      v21 = strlen(adr);\n      Xorriso_no_pattern_memory(a1, v21 + 1, 0, a7, a8, a9, a10);\n      return v12;\n    }\n    *filec = v19 + 1;\n    return 1LL;\n  }\n}\n",
    "source_code": "int Xorriso_register_matched_adr(struct XorrisO *xorriso,\n                                char *adr, int count_limit,\n                                int *filec, char **filev, off_t *mem, int flag)\n{\n int l;\n\n if(flag&1) {\n   (*filec)++;\n   l= strlen(adr)+1;\n   (*mem)+= sizeof(char *)+l;\n   if(l % sizeof(char *))\n     (*mem)+= sizeof(char *)-(l % sizeof(char *));\n } else {\n   if(*filec >= count_limit) {\n     sprintf(xorriso->info_text,\n         \"Number of matching files changed unexpectedly (> %d)\",\n         count_limit);\n     Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0,\n                         (flag&2 ? \"FATAL\" : \"WARNING\"), 0);\n     return(flag&2 ? -1 : 0);\n   }\n   filev[*filec]= strdup(adr);\n   if(filev[*filec]==NULL) {\n     Xorriso_no_pattern_memory(xorriso, (off_t) (strlen(adr)+1), 0);\n     return(-1);\n   }\n   (*filec)++;\n }\n return(1);\n}",
    "comment": "Registers a matched address by updating file count, allocating memory for the address, and handling errors based on a specified flag.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Formats a given string with appropriate quoting based on the specified flags , updating the position and size of the buffer accordingly .\n",
    "cpbcs_sum": "Retrieves the path of a specified path in an ISO image, populating the buffer with its length based on the provided results.\n",
    "misum_sum": "Processes command-line arguments to extract operations, copying the result into a buffer, and handles memory allocation and updating the accordingly.\n",
    "decom_sum": "Adds a matching filename to the list, updates counters, and logs a fatal or warning message if the count unexpectedly exceeds the limit.",
    "cfg_sum": "Manages a list of matching file names, updating counters and memory, and logs warnings or fatal errors when count limits are exceeded.",
    "work_score": {
        "decom": {
            "summary": "Adds a matching filename to the list, updates counters, and logs a fatal or warning message if the count unexpectedly exceeds the limit.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function adds a matching filename to the list, updates counters, and logs a fatal or warning message when the count exceeds the limit; all of these behaviors are clearly supported by the source code. There are no incorrect or irrelevant claims, making the content precise and domain-specific.",
                "The summary correctly identifies the core action \u2014 adding a matching filename to the list and updating counters \u2014 which matches the function\u2019s primary purpose of registering an address into the file list structure. It also accurately notes the conditional logging of fatal or warning messages when the count exceeds the limit. However, it omits other critical behaviors present in the code, such as the memory size adjustments when the flag is set, alignment handling, duplication of the string, and specific error handling for allocation failures. These omissions reduce coverage of secondary details.",
                "The summary correctly captures the core purpose \u2014 adding a matching filename to the list, updating counters, and logging fatal/warning if the count exceeds the limit \u2014 which matches the source code logic. It omits minor details like the handling when flag&1 updates memory size without adding to the list, but there are no inaccurate claims. The claims are accurate but fairly generic, offering low insight beyond the obvious flow from the code. Noise is minimal and no fatal inaccuracies are present, resulting in modest net benefit."
            ]
        },
        "cfg": {
            "summary": "Manages a list of matching file names, updating counters and memory, and logs warnings or fatal errors when count limits are exceeded.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function manages a list of matching file names, updates counters and memory usage, and logs warnings or fatal errors when the count limit is exceeded, all of which are directly reflected in the source code. It omits some minor specifics such as the branching based on the 'flag' value and certain memory alignment details, but the described claims are accurate and align with the function's behavior. The proportion of accurate claims is well above 80%.",
                "The summary accurately reflects that the function manages a list of file names, updates count and memory usage, and logs warnings or fatal errors when limits are exceeded, matching the core purpose from the code. However, it omits details on how additions differ based on the flag, the specific calculation for memory alignment, and the handling of memory allocation failures, resulting in incomplete coverage of secondary behaviors.",
                "The summary accurately captures the core purpose of the function: maintaining a list of matching file names, updating counters and memory usage, and logging warnings or fatal errors when limits are exceeded. There are no contradictory or irrelevant claims, and key behavioral aspects such as handling count limits and differentiating between warning and fatal conditions are correctly described. The gain is moderate, as the summary is clear but not highly detailed about specifics like alignment adjustments or memory allocation failures."
            ]
        },
        "comment": {
            "summary": "Registers a matched address by updating file count, allocating memory for the address, and handling errors based on a specified flag.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function updates the file count, allocates memory for the address, and includes error handling based on a flag, which matches the behavior in the source code. However, it omits specific conditional branches such as the count limit check and memory alignment adjustment, making it less precise but still mostly accurate. Overall, the majority of claims align with the function\u2019s semantics.",
                "The summary does cover the core purpose \u2014 registering a matched address by updating count, allocating memory, and handling errors \u2014 which matches the function\u2019s primary domain action. However, it is vague and misses important specifics from the code such as the conditional memory size adjustments when flag&1 is set, the count limit check and associated warning/fatal messaging via Xorriso_msgs_submit, and the specialized error handling with Xorriso_no_pattern_memory. These omissions weaken coverage of secondary behavior-critical semantics.",
                "The summary correctly captures the core purpose of the function: it registers a matched address, increments the file count, allocates memory, and handles errors influenced by a flag. These are accurate and grounded in the code with no contradictions. However, the summary is broad and omits important specifics such as the conditional handling when the count limit is exceeded, the precise memory accounting steps, and the different severity levels ('FATAL' vs 'WARNING') determined by the flag. The claims are safe but generic, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582889680,
    "strip_function_name": "sub_FFFFFFFF813DB6D0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813DB6D0(\n        __int64 a1,\n        unsigned __int16 *a2,\n        int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  unsigned int v11; // r13d\n  int v12; // r12d\n  _BYTE *v13; // r14\n  unsigned int v14; // r15d\n  unsigned int v15; // r12d\n  __int64 result; // rax\n  unsigned int v17; // eax\n  _BYTE *v18; // rdx\n  _BYTE *v19; // [rsp+8h] [rbp-38h]\n  int v20; // [rsp+10h] [rbp-30h]\n  unsigned int v21; // [rsp+14h] [rbp-2Ch]\n\n  v20 = a3 | 0x42000001;\n  v19 = (_BYTE *)*((_QWORD *)a2 + 1);\n  v21 = a2[2];\n  do\n  {\n    v11 = 256;\n    v12 = *(_DWORD *)(a1 + 4624);\n    if ( v21 <= 0x100 )\n      v11 = v21;\n    sub_FFFFFFFF8138EC40((__int64 *)a1, v12 + 20740, v20 | (2 * *a2) | (v11 << 16), a4, a5, a6, a7, a8, a9, a10, a11);\n    if ( v11 )\n    {\n      v13 = v19;\n      v14 = v11;\n      v15 = v12 + 20748;\nLABEL_6:\n      result = sub_FFFFFFFF813DB590((__int64 *)a1, 2048, 1u, a4, a5, a6, a7, a8, a9, a10, a11);\n      if ( (_DWORD)result )\n        return result;\n      v17 = sub_FFFFFFFF8138E6A0(a1, v15);\n      v18 = v13 + 4;\n      while ( 1 )\n      {\n        *v13++ = v17;\n        v17 >>= 8;\n        if ( !--v14 )\n          break;\n        if ( v13 == v18 )\n          goto LABEL_6;\n      }\n    }\n    v19 += v11;\n    v21 -= v11;\n  }\n  while ( v21 );\n  return 0LL;\n}\n",
    "function_name": "gmbus_xfer_read",
    "decompiled_code": "__int64 __fastcall gmbus_xfer_read(\n        __int64 a1,\n        unsigned __int16 *a2,\n        int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  unsigned int v11; // r13d\n  int v12; // r12d\n  _BYTE *v13; // r14\n  unsigned int v14; // r15d\n  unsigned int v15; // r12d\n  __int64 result; // rax\n  unsigned int v17; // eax\n  _BYTE *v18; // rdx\n  _BYTE *v19; // [rsp+8h] [rbp-38h]\n  int v20; // [rsp+10h] [rbp-30h]\n  unsigned int v21; // [rsp+14h] [rbp-2Ch]\n\n  v20 = a3 | 0x42000001;\n  v19 = (_BYTE *)*((_QWORD *)a2 + 1);\n  v21 = a2[2];\n  do\n  {\n    v11 = 256;\n    v12 = *(_DWORD *)(a1 + 4624);\n    if ( v21 <= 0x100 )\n      v11 = v21;\n    i915_write32(\n      (volatile signed __int16 *)a1,\n      v12 + 20740,\n      v20 | (2 * *a2) | (v11 << 16),\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11);\n    if ( v11 )\n    {\n      v13 = v19;\n      v14 = v11;\n      v15 = v12 + 20748;\nLABEL_6:\n      result = gmbus_wait_hw_status((__int64 *)a1, 2048, 1u, a4, a5, a6, a7, a8, a9, a10, a11);\n      if ( (_DWORD)result )\n        return result;\n      v17 = i915_read32(a1, v15);\n      v18 = v13 + 4;\n      while ( 1 )\n      {\n        *v13++ = v17;\n        v17 >>= 8;\n        if ( !--v14 )\n          break;\n        if ( v13 == v18 )\n          goto LABEL_6;\n      }\n    }\n    v19 += v11;\n    v21 -= v11;\n  }\n  while ( v21 );\n  return 0LL;\n}\n",
    "source_code": "\nstatic int\ngmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,\n\t\tu32 gmbus1_index)\n{\n\tint reg_offset = dev_priv->gpio_mmio_base;\n\tu16 len = msg->len;\n\tu8 *buf = msg->buf;\n\n\tI915_WRITE(GMBUS1 + reg_offset,\n\t\t   gmbus1_index |\n\t\t   GMBUS_CYCLE_WAIT |\n\t\t   (len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t   GMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\t\tu32 val, loop = 0;\n\n\t\tret = gmbus_wait_hw_status(dev_priv, GMBUS_HW_RDY,\n\t\t\t\t\t   GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = I915_READ(GMBUS3 + reg_offset);\n\t\tdo {\n\t\t\t*buf++ = val & 0xff;\n\t\t\tval >>= 8;\n\t\t} while (--len && ++loop < 4);\n\t}\n\n\treturn 0;\n}",
    "comment": "Reads data from a GMBUS device into a buffer, handling timing and status checks during the transfer process.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Transfers I2C messages by addressing the device , reading or writing bytes , and handling errors during the process .\n",
    "cpbcs_sum": "Writes a Display Information Packet (DIP) to a specified register and updates the control register based on the provided EDID structure.\n",
    "misum_sum": "Writes a DisplayPort infoframe value to the specified hardware register for the Intel graphics device, including I2C bus and channel counts.\n",
    "decom_sum": "Transfers data in chunks to a hardware device, issuing configuration commands and writing bytes fetched from a device register until all data is sent.",
    "cfg_sum": "Processes blocks of byte data from a buffer, writes them to device registers in chunks, and invokes subroutines for each transmitted segment.",
    "work_score": {
        "decom": {
            "summary": "Transfers data in chunks to a hardware device, issuing configuration commands and writing bytes fetched from a device register until all data is sent.",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function transfers data to a hardware device and sends data until all is sent, whereas the source code clearly implements a read operation from the hardware via GMBUS, fetching bytes from a device register into a buffer. This is a semantic contradiction, leading to a low proportion of accurate claims.",
                "The summary incorrectly describes the function as sending data to a device, while the source code clearly performs a read transfer over GMBUS from a hardware device into a buffer. Although it mentions issuing configuration commands and chunk-based processing, it fails to capture the core purpose of reading bytes from the device, making the core domain action absent and misleading.",
                "The summary inaccurately describes the core behavior: the function actually reads data from a hardware device into a buffer, not sends or transfers data to it. This is a severe factual error about the primary purpose (read vs write), making it a FATAL claim. While it mentions configuration commands and register access, the core direction of data flow is wrong, rendering the description unreliable."
            ]
        },
        "cfg": {
            "summary": "Processes blocks of byte data from a buffer, writes them to device registers in chunks, and invokes subroutines for each transmitted segment.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as writing data to device registers and transmitting segments, whereas the source code clearly reads data from device registers into a buffer via GMBUS for an I2C read operation. None of the claims accurately match the actual semantics, resulting in 0% accurate claims.",
                "The summary misrepresents the core operation. The source code reads byte data from device registers into a buffer via GMBUS during an I2C read operation, but the summary claims it writes to device registers and transmits segments. This contradicts the actual semantics, so the core purpose of performing a GMBUS/I2C read transfer is not covered, and no accurate secondary details are provided.",
                "The summary describes writing data to device registers in chunks and invoking subroutines for transmitted segments, but the source code performs a read from the device into a buffer using gmbus, not writing out the buffer contents. This is a FATAL inaccuracy about the primary purpose and key I/O direction (the core semantic is reading, summary asserts writing). As such, the main domain action is misrepresented, making the description untrustworthy. There are no accurate claims to offset this error."
            ]
        },
        "comment": {
            "summary": "Reads data from a GMBUS device into a buffer, handling timing and status checks during the transfer process.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function reads data from a GMBUS device into a buffer and handles timing/status checks, which matches the code's use of GMBUS registers, buffering logic, and hardware readiness checks. All claims are accurate, though the summary is somewhat generic and omits specifics such as loop limits and address handling. The proportion of accurate claims is over 80%, giving high precision.",
                "The summary correctly states that the function reads data from a GMBUS device into a buffer, which aligns with the core domain action in the code. However, it only vaguely mentions 'handling timing and status checks' without detailing the specific byte reading loop, hardware-ready status polling, or register interactions present in the source. Secondary behavior coverage such as shifting bytes, loop limits, and explicit constants is missing, making the description thin beyond the core action.",
                "The summary accurately captures the core purpose (reading from a GMBUS device into a buffer) and mentions handling timing/status checks, which aligns with the gmbus_wait_hw_status loop in the code. There are no incorrect statements, but the claims are generic and offer low informational detail beyond the obvious from the function name and flow. No FATAL errors are present, and noise is minimal, but the gain is limited due to lack of specifics such as register usage or byte transfer mechanism."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586514432,
    "strip_function_name": "sub_FFFFFFFF81750600",
    "strip_decompiled_code": "_QWORD *__fastcall sub_FFFFFFFF81750600(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // ebx\n  __int64 *i; // r12\n  __int64 *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  _QWORD *result; // rax\n  __int64 v16; // r14\n  __int64 *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v9 = 0;\n  for ( i = *(__int64 **)(a1 + 3280); (__int64 *)(a1 + 3280) != i; i = (__int64 *)*i )\n  {\n    if ( *((_DWORD *)i + 538) == 3 )\n    {\n      v11 = sub_FFFFFFFF815CD4F0((__int64)(i + 187));\n      if ( v11 )\n        sub_FFFFFFFF817319E0((_QWORD *)a1, (volatile signed __int32 *)v11, a2, a3, a4, a5, v12, v13, a8, a9);\n      v9 += *((_DWORD *)i + 378);\n    }\n  }\n  v14 = *(_QWORD **)(a1 + 600);\n  for ( result = (_QWORD *)(a1 + 600); v14 != (_QWORD *)(a1 + 600); v14 = (_QWORD *)*v14 )\n  {\n    v16 = (__int64)(v14 + 33);\n    while ( 1 )\n    {\n      v17 = sub_FFFFFFFF815CD4F0(v16);\n      v9 += *(_DWORD *)(v16 + 16);\n      if ( v17 )\n        break;\n      v16 -= 24LL;\n      if ( v14 + 21 == (_QWORD *)v16 )\n        goto LABEL_12;\n    }\n    sub_FFFFFFFF817319E0((_QWORD *)a1, (volatile signed __int32 *)v17, a2, a3, a4, a5, v18, v19, a8, a9);\nLABEL_12:\n    result = (_QWORD *)*v14;\n  }\n  *(_DWORD *)(a1 + 4032) = v9;\n  return result;\n}\n",
    "function_name": "purge_old_ps_buffers",
    "decompiled_code": "_QWORD *__fastcall purge_old_ps_buffers(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // ebx\n  __int64 *i; // r12\n  __int64 *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  _QWORD *result; // rax\n  __int64 v16; // r14\n  __int64 *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v9 = 0;\n  for ( i = *(__int64 **)(a1 + 3280); (__int64 *)(a1 + 3280) != i; i = (__int64 *)*i )\n  {\n    if ( *((_DWORD *)i + 538) == 3 )\n    {\n      v11 = skb_dequeue((__int64)(i + 187));\n      if ( v11 )\n        ieee80211_free_txskb(\n          (volatile signed __int16 *)a1,\n          (volatile signed __int32 *)v11,\n          a2,\n          a3,\n          a4,\n          a5,\n          v12,\n          v13,\n          a8,\n          a9);\n      v9 += *((_DWORD *)i + 378);\n    }\n  }\n  v14 = *(_QWORD **)(a1 + 600);\n  for ( result = (_QWORD *)(a1 + 600); v14 != (_QWORD *)(a1 + 600); v14 = (_QWORD *)*v14 )\n  {\n    v16 = (__int64)(v14 + 33);\n    while ( 1 )\n    {\n      v17 = skb_dequeue(v16);\n      v9 += *(_DWORD *)(v16 + 16);\n      if ( v17 )\n        break;\n      v16 -= 24LL;\n      if ( v14 + 21 == (_QWORD *)v16 )\n        goto LABEL_12;\n    }\n    ieee80211_free_txskb(\n      (volatile signed __int16 *)a1,\n      (volatile signed __int32 *)v17,\n      a2,\n      a3,\n      a4,\n      a5,\n      v18,\n      v19,\n      a8,\n      a9);\nLABEL_12:\n    result = (_QWORD *)*v14;\n  }\n  *(_DWORD *)(a1 + 4032) = v9;\n  return result;\n}\n",
    "source_code": "static void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}",
    "comment": "Purges old Power Save buffers from access points and stations, freeing memory and updating the total buffered frame count.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Updates the transmission queue for each active sub-interface after a scan completion event in the IEEE 802.11 local structure .\n",
    "cpbcs_sum": "Processes and submits IEEE 802.11 packets for each completed manager associated with a specified duration, managing state and list cleanup.\n",
    "misum_sum": "Cleans up and releases pending bitmap for active network devices, notifying network devices while managing interface state and list states.\n",
    "decom_sum": "Traverses two linked lists, processes specific entries via a helper routine, accumulates their counts, and stores the total into the object's field at offset 4032.",
    "cfg_sum": "Iterates two linked lists, processes matching entries with a helper routine, accumulates a total counter, updates a state field, and returns the final list pointer.",
    "work_score": {
        "decom": {
            "summary": "Traverses two linked lists, processes specific entries via a helper routine, accumulates their counts, and stores the total into the object's field at offset 4032.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes traversal of two linked lists and accumulation of counts, which matches the code's iteration over interfaces and stations and tallying buffer lengths. However, it inaccurately describes processing entries via a helper routine and specifies an 'offset 4032' field, which is not evidenced in the source code; the code directly dequeues and frees buffers and assigns to a named struct field. These inaccuracies reduce precision, yielding mixed reliability.",
                "The summary omits the core purpose of purging old power-save buffers for AP and mesh interfaces and stations, including de-queuing and freeing skb frames. While it notes traversal of two linked lists and updating a total count, it is vague and misleads with a generic 'processes specific entries via a helper' that does not reflect the actual domain semantics. Critical behaviors such as conditional interface handling, purging from broadcast and station queues, freeing memory via specific functions, branch logic over access categories, and logging are missing.",
                "The summary claims traversal of two linked lists and accumulation of counts, which aligns with the function iterating over local->interfaces and local->sta_list to purge buffers and count remaining frames. However, it inaccurately states that entries are processed via a helper routine and that the total is stored in a field at offset 4032; the code directly dequeues/skips buffers and assigns to local->total_ps_buffered without such an offset notion. The offset detail is domain-semantic and incorrect, making it a FATAL error about key output storage. This significantly reduces trust in the summary."
            ]
        },
        "cfg": {
            "summary": "Iterates two linked lists, processes matching entries with a helper routine, accumulates a total counter, updates a state field, and returns the final list pointer.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains mostly inaccurate claims. While it correctly mentions iteration over two linked lists and updating a state field, it incorrectly states that entries are processed with a helper routine and that the function returns a final list pointer\u2014there is no such return value in the code, as it is `void`. The function instead purges buffers, updates a counter, and logs output. These contradictions result in less than half of the claims being accurate.",
                "The summary does not capture the core purpose of freeing buffered frames from AP or mesh interfaces and from each station\u2019s lowest priority AC buffer, nor does it mention the purging of frames or hardware-related side effects. While it notes iterating lists and updating a counter, it inaccurately claims returning a final list pointer, which does not occur in the void function. The description is overly generic and omits key branch logic, buffer operations, and frame purging behavior.",
                "The summary contains multiple inaccurate claims: it incorrectly states that the function returns a final list pointer, but the source code is a void function with no return. It mentions using a helper routine to process entries, which is vague and does not capture the actual purging and freeing of buffers. Key core purpose details such as purging old power-save buffers for AP and mesh interfaces and stations are omitted, making this a FATAL error regarding the primary purpose. There are no accurate, specific claims that align with the code\u2019s actual mechanics, resulting in a net negative benefit."
            ]
        },
        "comment": {
            "summary": "Purges old Power Save buffers from access points and stations, freeing memory and updating the total buffered frame count.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary contains two main claims: that the function purges old Power Save buffers from access points and stations, and that it frees memory and updates the total buffered frame count. Both are accurate: the code iterates over AP and mesh interfaces as well as stations, dequeues and frees frames from their buffers, and updates the total count. These claims match the function's semantics and contain no contradictions, making the precision of fact-based claims very high.",
                "The summary correctly identifies the core purpose as purging old power save buffers from APs and stations and notes freeing memory, which matches the function\u2019s primary domain action and side effect. It also mentions updating the total buffered frame count, aligning with the assignment to local->total_ps_buffered. However, it omits key secondary details such as purging from broadcast/multicast buffers, dropping one frame per station from the lowest-priority access category, specific queue handling, and the debug logging. Coverage of critical branches and constants is minimal.",
                "The summary accurately conveys the primary purpose of the function \u2014 removing old Power Save buffers for APs and stations, freeing their memory, and updating the total buffered frame count \u2014 consistent with the code. It omits some internal details like dequeuing from specific queues or purging only one frame per station, but these are less critical. There are no false claims, and noise is minimal. The gain is modest due to the summary\u2019s brevity, but its correctness on core behavior yields a clear net positive."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585594224,
    "strip_function_name": "sub_FFFFFFFF8166FB70",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8166FB70(\n        __int64 a1,\n        __int64 a2,\n        __int16 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v14; // eax\n  bool v15; // cc\n  __int64 v16; // r13\n  int v17; // edi\n  volatile signed __int32 *v18; // rsi\n  int v19; // eax\n  char *v20; // rax\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  unsigned __int64 v27; // r15\n  signed int v28; // ebx\n\n  v14 = *(_DWORD *)(a1 + 3208);\n  v15 = *(_WORD *)(a2 + 24) <= 0x1Fu;\n  v16 = *(_QWORD *)(a1 + 16);\n  v17 = 52;\n  v18 = (volatile signed __int32 *)&qword_20;\n  v19 = 8 * v14 + 92;\n  if ( v15 )\n    v17 = v19;\n  v20 = (char *)sub_FFFFFFFF815CF830(v17, 0x20u, 0, 0xFFFFFFFF, a4, a5, a6, a7, a8, a9, a10, a11);\n  v27 = (unsigned __int64)v20;\n  if ( !v20 )\n  {\n    v28 = -105;\n    goto LABEL_5;\n  }\n  v18 = (volatile signed __int32 *)v20;\n  v28 = sub_FFFFFFFF8166FA00(a1, v20, 0, 0, (_DWORD *)a2, a3, 0);\n  if ( v28 < 0 )\n  {\nLABEL_5:\n    sub_FFFFFFFF815CFEE0(v27, v18, v21, v22, v23, v24, a4, a5, a6, a7, v25, v26, a10, a11);\n    return sub_FFFFFFFF815EA860(v16, 6u, v28);\n  }\n  return sub_FFFFFFFF815EA820(v27, v16, 0LL, 6LL, 0LL);\n}\n",
    "function_name": "mroute_netlink_event",
    "decompiled_code": "__int64 __fastcall mroute_netlink_event(\n        __int64 a1,\n        __int64 a2,\n        __int16 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v14; // eax\n  bool v15; // cc\n  __int64 v16; // r13\n  int v17; // edi\n  volatile signed __int32 *v18; // rsi\n  int v19; // eax\n  char *v20; // rax\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  volatile signed __int32 *v27; // r15\n  int v28; // ebx\n\n  v14 = *(_DWORD *)(a1 + 3208);\n  v15 = *(_WORD *)(a2 + 24) <= 0x1Fu;\n  v16 = *(_QWORD *)(a1 + 16);\n  v17 = 52;\n  v18 = (volatile signed __int32 *)&qword_20;\n  v19 = 8 * v14 + 92;\n  if ( v15 )\n    v17 = v19;\n  v20 = (char *)_alloc_skb(v17, 0x20u, 0, -1, a4, a5, a6, a7, a8, a9, a10, a11);\n  v27 = (volatile signed __int32 *)v20;\n  if ( !v20 )\n  {\n    v28 = -105;\n    goto LABEL_5;\n  }\n  v18 = (volatile signed __int32 *)v20;\n  v28 = ipmr_fill_mroute(a1, v20, 0, 0, (_DWORD *)a2, a3, a4, a5, a6, a7, v25, v26, a10, a11, 0);\n  if ( v28 < 0 )\n  {\nLABEL_5:\n    kfree_skb(v27, v18, v21, v22, v23, v24, a4, a5, a6, a7, v25, v26, a10, a11);\n    return rtnl_set_sk_err(v16, 6, v28);\n  }\n  return rtnl_notify((unsigned __int64)v27, v16, 0, 6LL, 0LL, 0x20u, a4, a5, a6, a7, v25, v26, a10, a11);\n}\n",
    "source_code": "\nstatic void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,\n\t\t\t\t int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mroute_msgsize(mfc->mfc_parent >= MAXVIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = ipmr_fill_mroute(mrt, skb, 0, 0, mfc, cmd);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE, err);\n}",
    "comment": "Notifies the kernel about multicast route changes by creating and sending a netlink message based on the provided mfc_cache and command.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Processes a netlink message for a routing table lookup and sends the result back to the originating socket .\n",
    "cpbcs_sum": "Sends a netlink message to a specified socket buffer after locking and sending a netlink message to the appropriate network device.\n",
    "misum_sum": "Sends a netlink message to a specified socket buffer using netlink message parameters.\n",
    "decom_sum": "Allocates and initializes a data buffer with parameters, processes it, frees on failure, and reports the result to the owning context.",
    "cfg_sum": "Allocates and initializes a data structure, processes it with input parameters, and returns a success or error code based on processing results.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a data buffer with parameters, processes it, frees on failure, and reports the result to the owning context.",
            "score": [
                0.9,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly captures that the function allocates a buffer, processes it, frees it on failure, and reports the result, aligning with the code's sequence of nlmsg_new allocation, ipmr_fill_mroute processing, kfree_skb in error paths, and rtnl_notify/rtnl_set_sk_err reporting. While the description is generic and omits specific details such as netlink message size calculation and multicast routing groups, all claims are accurate to the source code semantics.",
                "The summary gives a vague workflow and does not identify the core purpose of sending an IPv4 multicast routing event via netlink notifications. It omits specific domain semantics such as creating a netlink message sized for multicast routing, filling it with routing info, and notifying RTNLGRP_IPV4_MROUTE. While the generic mention of buffer allocation, processing, freeing, and reporting is accurate in a broad sense, it lacks the specificity required to cover the primary purpose and leaves out key error-handling and external interaction details.",
                "The summary contains mostly generic descriptions like 'allocates and initializes a data buffer' and 'reports the result to the owning context,' which are broadly accurate but lack specificity about the netlink message creation, multicast routing context, and rtnetlink notification in the source code. No incorrect or contradictory claims (no FATAL), but the information gain is low due to omission of key domain details, making the net benefit limited."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes a data structure, processes it with input parameters, and returns a success or error code based on processing results.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary is overly generic and misses key domain-specific behavior from the source code, such as interaction with netlink messaging (nlmsg_new), multicast routing table handling, notification via rtnl_notify, and error signaling through rtnl_set_sk_err. While it correctly notes allocation and processing with parameters, it inaccurately mentions returning a success or error code, as the function is void and signals errors through other means. Less than half of the claims align accurately with the actual semantics.",
                "The summary gives a vague description of allocating and processing a data structure but does not specifically cover the core purpose of the function, which is to send a multicast routing netlink notification using provided routing table and cache data via rtnetlink. It omits concrete domain details such as netlink message construction, population through ipmr_fill_mroute, and sending with rtnl_notify, as well as error handling via rtnl_set_sk_err. Its generic wording fails to capture the function's domain semantics or secondary behaviors.",
                "The summary's claims are mostly inaccurate: it states that the function 'returns a success or error code,' but the source shows it is a void function with side effects via rtnl_notify or rtnl_set_sk_err. It also generically says 'allocates and initializes a data structure, processes it with input parameters,' which is vague and not specific to the multicast routing netlink event logic in the code. The worst failure mode is a FATAL error regarding the primary purpose and output behavior, which severely misleads about the function\u2019s contract."
            ]
        },
        "comment": {
            "summary": "Notifies the kernel about multicast route changes by creating and sending a netlink message based on the provided mfc_cache and command.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly identifies that the function sends a netlink message related to multicast route changes using the provided mfc_cache and command. This aligns well with the source code, which constructs a netlink message via nlmsg_new, fills it with ipmr_fill_mroute, and sends it using rtnl_notify, handling errors appropriately. The summary omits details such as specific error handling and exact notification group, but the core claim is accurate and specific to the function\u2019s semantics, resulting in high claim accuracy.",
                "The summary correctly identifies that the function sends a netlink notification about multicast route changes using information from mfc_cache and a command, which matches the core purpose of notifying via rtnl_notify. However, it lacks coverage of key secondary details such as allocating the skb with specific sizing logic, handling allocation or fill errors, freeing the skb on failure, and signaling errors via rtnl_set_sk_err, resulting in incomplete coverage of critical behavior.",
                "The summary correctly identifies the function\u2019s core purpose as notifying about multicast route changes via a netlink message, which aligns with the code\u2019s creation of an skb, filling it with mroute data, and using rtnl_notify. However, it omits important error handling behavior such as freeing skb and setting socket error when message creation or filling fails. No claims are inaccurate or irrelevant, but the description is somewhat generic and lacks detail about the I/O contract and failure path, limiting its informativeness."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585332144,
    "strip_function_name": "sub_FFFFFFFF8162FBB0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8162FBB0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  unsigned __int64 v10; // r13\n  __int64 v11; // r12\n  unsigned int v12; // ebx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // r14d\n  __int64 v16; // rsi\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // [rsp+0h] [rbp-30h]\n\n  result = a1 - 16;\n  v10 = __readgsqword(0xA760u);\n  v22 = a1 - 16;\n  if ( *(_DWORD *)(a1 - 4) )\n  {\n    v11 = a1 - 368;\n    do\n    {\n      v12 = 0;\n      sub_FFFFFFFF81792930(v22);\n      do\n      {\n        while ( 1 )\n        {\n          v15 = 1 << v12;\n          if ( ((1 << v12) & *(_DWORD *)(a1 - 4)) != 0 )\n            break;\n          if ( ++v12 == 8 )\n            goto LABEL_10;\n        }\n        while ( 1 )\n        {\n          v16 = v12;\n          if ( !(unsigned int)sub_FFFFFFFF8162FA30(v11, v12, a2, a3, a4, a5, v13, v14, a8, a9) )\n            break;\n          while ( (*(_QWORD *)(v10 - 8136) & 8) != 0 )\n          {\n            sub_FFFFFFFF81792870(v22);\n            sub_FFFFFFFF81790B80(v22, v16, v17, v18, v19);\n            sub_FFFFFFFF81792930(v22);\n            v16 = v12;\n            if ( !(unsigned int)sub_FFFFFFFF8162FA30(v11, v12, a2, a3, a4, a5, v20, v21, a8, a9) )\n              goto LABEL_9;\n          }\n        }\nLABEL_9:\n        ++v12;\n        *(_DWORD *)(a1 - 4) &= ~v15;\n      }\n      while ( v12 != 8 );\nLABEL_10:\n      sub_FFFFFFFF81792870(v22);\n      result = *(unsigned int *)(a1 - 4);\n    }\n    while ( (_DWORD)result );\n  }\n  return result;\n}\n",
    "function_name": "inet_twdr_twkill_work",
    "decompiled_code": "__int64 __fastcall inet_twdr_twkill_work(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10)\n{\n  __int64 result; // rax\n  unsigned __int64 v11; // r13\n  __int64 v12; // r12\n  unsigned int v13; // ebx\n  __int64 v14; // rdx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rcx\n  int v20; // r14d\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  volatile signed __int16 *v26; // [rsp+0h] [rbp-30h]\n\n  result = a1 - 16;\n  v11 = __readgsqword(0xA760u);\n  v26 = (volatile signed __int16 *)(a1 - 16);\n  if ( *(_DWORD *)(a1 - 4) )\n  {\n    v12 = a1 - 368;\n    do\n    {\n      v13 = 0;\n      raw_spin_lock_bh(v26);\n      do\n      {\n        while ( 1 )\n        {\n          v19 = v13;\n          v20 = 1 << v13;\n          if ( ((1 << v13) & *(_DWORD *)(a1 - 4)) != 0 )\n            break;\n          if ( ++v13 == 8 )\n            goto LABEL_10;\n        }\n        while ( 1 )\n        {\n          a10 = v13;\n          if ( !(unsigned int)inet_twdr_do_twkill_work(v12, v13, a2, a3, a4, a5, v17, v18, a8, a9) )\n            break;\n          while ( (*(_QWORD *)(v11 - 8136) & 8) != 0 )\n          {\n            raw_spin_unlock_bh(v26, a10, v14, v19, v15, v16);\n            a2 = schedule(v26, a10, v21, v22, v23);\n            raw_spin_lock_bh(v26);\n            a10 = v13;\n            if ( !(unsigned int)inet_twdr_do_twkill_work(v12, v13, a2, a3, a4, a5, v24, v25, a8, a9) )\n              goto LABEL_9;\n          }\n        }\nLABEL_9:\n        ++v13;\n        *(_DWORD *)(a1 - 4) &= ~v20;\n      }\n      while ( v13 != 8 );\nLABEL_10:\n      raw_spin_unlock_bh(v26, a10, v14, v19, v15, v16);\n      result = *(unsigned int *)(a1 - 4);\n    }\n    while ( (_DWORD)result );\n  }\n  return result;\n}\n",
    "source_code": "\nvoid inet_twdr_twkill_work(struct work_struct *work)\n{\n\tstruct inet_timewait_death_row *twdr =\n\t\tcontainer_of(work, struct inet_timewait_death_row, twkill_work);\n\tint i;\n\n\tBUILD_BUG_ON((INET_TWDR_TWKILL_SLOTS - 1) >\n\t\t\t(sizeof(twdr->thread_slots) * 8));\n\n\twhile (twdr->thread_slots) {\n\t\tspin_lock_bh(&twdr->death_lock);\n\t\tfor (i = 0; i < INET_TWDR_TWKILL_SLOTS; i++) {\n\t\t\tif (!(twdr->thread_slots & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\twhile (inet_twdr_do_twkill_work(twdr, i) != 0) {\n\t\t\t\tif (need_resched()) {\n\t\t\t\t\tspin_unlock_bh(&twdr->death_lock);\n\t\t\t\t\tschedule();\n\t\t\t\t\tspin_lock_bh(&twdr->death_lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttwdr->thread_slots &= ~(1 << i);\n\t\t}\n\t\tspin_unlock_bh(&twdr->death_lock);\n\t}\n}",
    "comment": "Processes and removes active threads from the timewait death row while managing concurrency using spin locks and checking for rescheduling needs.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "The function waits for a socket to finish closing , handling interruptions and timeouts , while ensuring proper synchronization and memory management .\n",
    "cpbcs_sum": "Cleans up and unregisters IPv6 flow control tables for IPv6 addresses, including their IPv4 and IPv4 device information.\n",
    "misum_sum": "Processes socket events by locking and handling Duplicate Address Detection until the callback is received.\n",
    "decom_sum": "Processes active channels indicated by a bitmask, repeatedly invoking handlers until each channel is cleared or a processing condition is satisfied.",
    "cfg_sum": "Processes flagged entries in a data block, invoking computation and update routines until all flags are cleared, then returns the final status code.",
    "work_score": {
        "decom": {
            "summary": "Processes active channels indicated by a bitmask, repeatedly invoking handlers until each channel is cleared or a processing condition is satisfied.",
            "score": [
                0.7,
                0.2,
                0.5
            ],
            "reason": [
                "The summary correctly captures that the function uses a bitmask to identify active items and processes them repeatedly until a condition is met, aligning with the loop over thread_slots and repeated calls to inet_twdr_do_twkill_work. However, the term 'channels' is inaccurate for the code's concept of thread slots, and the mention of 'processing condition is satisfied' is vague compared to the explicit termination criteria in the source. These minor inaccuracies reduce precision but most of the core logic described is consistent with the code.",
                "The summary generically describes processing channels via a bitmask and invoking handlers, which loosely maps to iterating over thread slots and calling inet_twdr_do_twkill_work. However, it omits the core primary purpose: killing expired TCP time-wait sockets in death row slots. It also fails to mention critical behaviors such as locking (spin_lock_bh/spin_unlock_bh), rescheduling when needed, clearing slot bits, and looping until all slots are processed. This results in the core domain-specific semantics not being covered and minimal secondary details.",
                "The summary correctly notes the use of a bitmask to track active items and the repeated invocation of a handler until conditions are met, which aligns with the loop over thread_slots and calls to inet_twdr_do_twkill_work. However, it inaccurately generalizes these elements as 'channels' and a vague 'processing condition', omitting critical domain specifics: the bitmask represents thread slots for time-wait socket killing, and the condition involves need_resched scheduling. While the claim is broadly accurate at a generic level (SAFE), it lacks detailed, domain-specific GOLD insight and introduces mild NOISE by using non-domain terminology, limiting its utility."
            ]
        },
        "cfg": {
            "summary": "Processes flagged entries in a data block, invoking computation and update routines until all flags are cleared, then returns the final status code.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary misrepresents the source code: it claims returning a final status code, which the function does not do. It also vaguely describes processing flagged entries without mentioning critical details such as slot iteration, spin lock usage, and scheduling when rescheduling is needed. The only partially correct aspect is the notion of processing flagged items until cleared, but this omits key implementation semantics. Less than half of the claims align accurately with the source.",
                "The summary describes generic processing of flagged entries in a data block with computation and updates, but it does not accurately reflect the core purpose of the function, which is to iterate over thread slots in an inet_timewait_death_row structure and perform time-wait socket cleanup work. The mention of a final status code is incorrect as the function is void and returns nothing. No accurate claim covers the specific domain semantics or critical operations (locking, rescheduling, clearing slots) shown in the source.",
                "The summary incorrectly describes that the function returns a final status code, but the source code clearly has a void return type, making this a fatal error about core I/O semantics. It also generically refers to 'flagged entries in a data block' and 'computation/update routines', which misrepresents the actual domain-specific behavior of processing time-wait kill slots under a spinlock. These inaccuracies dominate, and there are no specific or precise GOLD claims to provide real value."
            ]
        },
        "comment": {
            "summary": "Processes and removes active threads from the timewait death row while managing concurrency using spin locks and checking for rescheduling needs.",
            "score": [
                0.3,
                0.3,
                0.2
            ],
            "reason": [
                "The summary accurately reflects some aspects of the function, such as managing concurrency via spin locks and checking for rescheduling. However, it incorrectly describes the function as processing and removing active threads, whereas the code operates on timewait sockets and thread slot bitmasks, not actual threads. This mismatch means that less than half of the claims are precise and domain-correct.",
                "The summary incorrectly describes the function as processing and removing active threads, whereas the source code specifically iterates over timewait death row slots to perform TCP/INET timewait socket cleanup work. This core purpose is not captured, making the main domain operation absent. While the summary notes spin lock usage and rescheduling checks, which are accurate secondary points, the primary semantic about killing timewait entries per slot is missing.",
                "The summary contains an inaccurate core claim: it states the function \"removes active threads\" from the timewait death row, but the code is actually iterating over timewait slots to perform cleanup of expired timewait sockets, not thread removal. This contradicts the primary purpose of the function and is a FATAL error on the core domain action. While the mention of managing concurrency with spin locks and checking for rescheduling is accurate, this correct detail cannot offset the severe inaccuracy about the main function behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585723248,
    "strip_function_name": "sub_FFFFFFFF8168F370",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8168F370(\n        __int64 a1,\n        __int64 a2,\n        _DWORD *a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned __int64 v14; // rbx\n  volatile signed __int32 *v15; // r12\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rsi\n  unsigned __int64 v23; // rdx\n  signed __int32 v24; // et0\n  unsigned int v25; // r12d\n  __int64 v27; // rax\n\n  v14 = *(_QWORD *)(a1 + 32);\n  if ( a4 )\n  {\n    v27 = sub_FFFFFFFF8168D550(*(_QWORD *)(a1 + 32));\n    v14 = v27;\n    if ( !v27 )\n      return (unsigned int)-107;\n    v15 = (volatile signed __int32 *)(v27 + 76);\n  }\n  else\n  {\n    v15 = (volatile signed __int32 *)(v14 + 76);\n    _InterlockedIncrement((volatile signed __int32 *)(v14 + 76));\n  }\n  sub_FFFFFFFF81792900(v14 + 728);\n  v22 = *(_QWORD *)(v14 + 632);\n  if ( v22 )\n  {\n    v23 = *(int *)(v22 + 4);\n    v22 += 12LL;\n    *a3 = v23;\n    sub_FFFFFFFF812B9E70(a2, (__int64 *)v22, v23);\n  }\n  else\n  {\n    *(_BYTE *)(a2 + 2) = 0;\n    *(_WORD *)a2 = 1;\n    *a3 = 2;\n  }\n  ++*(_BYTE *)(v14 + 728);\n  v24 = _InterlockedDecrement(v15);\n  v25 = 0;\n  if ( !v24 )\n    sub_FFFFFFFF815CA7D0(v14, (volatile signed __int32 *)v22, v16, v17, v18, v19, a5, a6, a7, a8, v20, v21, a11, a12);\n  return v25;\n}\n",
    "function_name": "unix_getname",
    "decompiled_code": "__int64 __fastcall unix_getname(\n        __int64 a1,\n        __int64 a2,\n        _DWORD *a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  __int64 v14; // rbx\n  volatile signed __int32 *v15; // r12\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rsi\n  unsigned __int64 v23; // rdx\n  signed __int32 v24; // et0\n  unsigned int v25; // r12d\n  __int64 v27; // rax\n\n  v14 = *(_QWORD *)(a1 + 32);\n  if ( a4 )\n  {\n    v27 = unix_peer_get(*(_QWORD *)(a1 + 32));\n    v14 = v27;\n    if ( !v27 )\n      return (unsigned int)-107;\n    v15 = (volatile signed __int32 *)(v27 + 76);\n  }\n  else\n  {\n    v15 = (volatile signed __int32 *)(v14 + 76);\n    _InterlockedIncrement((volatile signed __int32 *)(v14 + 76));\n  }\n  raw_spin_lock((volatile signed __int16 *)(v14 + 728));\n  v22 = *(_QWORD *)(v14 + 632);\n  if ( v22 )\n  {\n    v23 = *(int *)(v22 + 4);\n    v22 += 12LL;\n    *a3 = v23;\n    memcpy(a2, (__int64 *)v22, v23);\n  }\n  else\n  {\n    *(_BYTE *)(a2 + 2) = 0;\n    *(_WORD *)a2 = 1;\n    *a3 = 2;\n  }\n  ++*(_BYTE *)(v14 + 728);\n  v24 = _InterlockedDecrement(v15);\n  v25 = 0;\n  if ( !v24 )\n    sk_free(\n      v14,\n      (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))v22,\n      v16,\n      v17,\n      v18,\n      v19,\n      a5,\n      a6,\n      a7,\n      a8,\n      v20,\n      v21,\n      a11,\n      a12);\n  return v25;\n}\n",
    "source_code": "\n\nstatic int unix_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u;\n\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, uaddr);\n\tint err = 0;\n\n\tif (peer) {\n\t\tsk = unix_peer_get(sk);\n\n\t\terr = -ENOTCONN;\n\t\tif (!sk)\n\t\t\tgoto out;\n\t\terr = 0;\n\t} else {\n\t\tsock_hold(sk);\n\t}\n\n\tu = unix_sk(sk);\n\tunix_state_lock(sk);\n\tif (!u->addr) {\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tsunaddr->sun_path[0] = 0;\n\t\t*uaddr_len = sizeof(short);\n\t} else {\n\t\tstruct unix_address *addr = u->addr;\n\n\t\t*uaddr_len = addr->len;\n\t\tmemcpy(sunaddr, addr->name, *uaddr_len);\n\t}\n\tunix_state_unlock(sk);\n\tsock_put(sk);\nout:\n\treturn err;\n}",
    "comment": "Retrieves the Unix socket's address or initializes it as empty if not connected, handling peer connections appropriately.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Retrieves an xfrm_state for a given xfrm_usersa_id and sends an associated asynchronous event message through a netlink socket .\n",
    "cpbcs_sum": "Reads a string from the user, copies it to the user buffer, and updates the buffer if the buffer is successful.\n",
    "misum_sum": "Retrieves a message from a socket's socket, populating it with its associated state and notifies the user, and address.\n",
    "decom_sum": "Retrieves and processes a structure\u2019s data into a target buffer with reference counting, invoking cleanup when no references remain.",
    "cfg_sum": "Atomically manages a shared resource handle, updates associated state and data, invokes relevant processing routines, and returns success or an error code.",
    "work_score": {
        "decom": {
            "summary": "Retrieves and processes a structure\u2019s data into a target buffer with reference counting, invoking cleanup when no references remain.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary's claims are largely inaccurate. While the function does retrieve data from a structure into a provided buffer and uses reference counting via sock_hold and sock_put, it does not perform cleanup when no references remain. The summary omits key specifics like handling peer sockets, locking, address retrieval, and error handling, and instead introduces an incorrect cleanup behavior not found in the code. Less than half of the claims align accurately with the source code semantics.",
                "The summary fails to mention the core operation of retrieving a UNIX domain socket's address (local or peer) into a sockaddr_un structure and setting family/path accordingly. Its claims about generic data processing, reference counting, and cleanup are vague and do not align specifically with the source code's domain semantics, leading to missing the primary purpose and most critical behaviors.",
                "The summary's claim that the function retrieves and processes a structure\u2019s data into a target buffer is partially aligned with the code\u2019s behavior of obtaining a socket address and copying it into a provided buffer. However, it inaccurately states that cleanup is invoked when no references remain, which is not shown in the function\u2014the code uses reference counting with sock_hold and sock_put, but no explicit cleanup on reference count 0. The description is vague, omitting critical specifics such as handling peer sockets, address locking, and AF_UNIX empty path behavior. This vagueness introduces significant noise with limited accurate detail, resulting in low net benefit."
            ]
        },
        "cfg": {
            "summary": "Atomically manages a shared resource handle, updates associated state and data, invokes relevant processing routines, and returns success or an error code.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary is overly generic and fails to capture specific, verifiable behaviors from the source code, such as handling peer sockets, setting UNIX socket address structures, or locking/unlocking socket state. While it mentions resource management and returning an error code, these are boilerplate and not tailored to the actual semantics. Most claims do not directly target the code's unique operations, resulting in low alignment with the evaluation steps.",
                "The summary only gives a vague, generic description about managing a shared resource handle and returning a status, without accurately reflecting the code's specific core purpose of retrieving the local or peer UNIX domain socket address and length. No [ACCURATE] claim states the core action, and there is no mention of key operations like differentiating based on 'peer', handling absent addresses, filling sockaddr_un fields, or performing locking/unlocking. The lack of domain-specific details means the core purpose is not covered and secondary details are missing.",
                "The summary is highly generic and does not accurately reflect the specific domain semantics of the function. It fails to mention key purpose details such as retrieving a UNIX socket's local or peer address, managing peer connections, setting address values, and handling locking. The claims about 'shared resource handle' and 'invokes relevant processing routines' are vague NOISE rather than verifiable specifics from the source code. No FATAL contradictions are present, but the noise overwhelms any informative content, providing extremely low net benefit."
            ]
        },
        "comment": {
            "summary": "Retrieves the Unix socket's address or initializes it as empty if not connected, handling peer connections appropriately.",
            "score": [
                0.6,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly captures that the function retrieves a Unix socket's address and handles peer connections, aligning with the peer check and retrieval in the code. However, it inaccurately states that it initializes the address as empty 'if not connected', whereas the actual logic sets it empty when u->addr is NULL, which may occur independently of connection status. This misrepresentation makes one of the core claims partially inaccurate, resulting in mixed reliability.",
                "The summary correctly captures the core purpose of retrieving a Unix socket address and handling peer connections, which aligns with the source code's primary logic. However, it omits key implementation details such as locking the socket state, setting the address family to AF_UNIX, initializing sun_path[0], adjusting uaddr_len to sizeof(short) when no address exists, copying from addr->name when present, and error handling via -ENOTCONN. These secondary behaviors are critical for full semantic coverage but are absent from the summary.",
                "The summary correctly states that the function retrieves a Unix socket's address and can initialize it to empty when no address is set, which matches the code. However, it inaccurately uses 'not connected' instead of the actual condition of no bound address, conflating connection state with address presence. The handling of peer connections is generically mentioned and lacks specifics about the error handling and reference counting in the code. No severe fatal error on the primary purpose, but the description is low-info and slightly noisy due to vague terminology."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 303360,
    "strip_function_name": "sub_4A100",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_4A100(__int64 *a1, __int64 *a2)\n{\n  __int64 v3; // rbp\n  __int64 v4; // rax\n  __int64 v5; // rdi\n  __int64 v7; // r13\n  __int64 v8; // rsi\n  const void *v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rax\n  __m128i *v12; // rax\n  _QWORD *v13; // rsi\n  __int64 v15; // [rsp+0h] [rbp-78h] BYREF\n  _BYTE *v16; // [rsp+8h] [rbp-70h]\n  __int128 v17; // [rsp+10h] [rbp-68h]\n  __int128 v18; // [rsp+20h] [rbp-58h]\n  __int128 v19; // [rsp+30h] [rbp-48h]\n  __int64 v20; // [rsp+40h] [rbp-38h]\n  unsigned __int64 v21; // [rsp+48h] [rbp-30h]\n\n  v3 = *a1;\n  v21 = __readfsqword(0x28u);\n  v4 = a1[64];\n  v5 = *a2;\n  if ( v4 )\n  {\n    v7 = *(_QWORD *)(v4 + 8) + 32LL * *(__int16 *)(v4 + 66) - 32;\n    if ( (unsigned int)sub_27C40(v5, *(_BYTE *)(v3 + 169) + 4, 0) )\n    {\n      v8 = *(_QWORD *)(v7 + 8);\n      if ( v8 )\n        sub_2FF20(v3, v8);\n      v9 = (const void *)a2[1];\n      v10 = a2[2];\n      v20 = 0LL;\n      v15 = 161LL;\n      v17 = 0LL;\n      v18 = 0LL;\n      v19 = 0LL;\n      v16 = sub_220B0(v3, v9, (int)v10 - (int)v9);\n      v11 = *a2;\n      HIDWORD(v15) = 4096;\n      *(_QWORD *)&v17 = v11;\n      v12 = sub_2F030(v3, (__int64)&v15, 1u, 0LL);\n      v13 = v16;\n      *(_QWORD *)(v7 + 8) = v12;\n      sub_21060(v3, v13);\n      v5 = *a2;\n    }\n    else\n    {\n      sub_46EC0((__int64)a1, \"default value of column [%s] is not constant\", *(const char **)v7);\n      v5 = *a2;\n    }\n  }\n  if ( v5 )\n    sub_2FF20(v3, v5);\n  return __readfsqword(0x28u) ^ v21;\n}\n",
    "function_name": "sqlite3AddDefaultValue",
    "decompiled_code": "void __fastcall sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan)\n{\n  sqlite3 *db; // rbp\n  Table *pNewTable; // rax\n  Expr *pExpr; // rdi\n  __int64 v7; // r13\n  Expr *v8; // rsi\n  const char *zStart; // rsi\n  const char *zEnd; // rdx\n  Expr *v11; // rax\n  Expr *v12; // rax\n  char *zToken; // rsi\n  Expr x; // [rsp+0h] [rbp-78h] BYREF\n  unsigned __int64 v15; // [rsp+48h] [rbp-30h]\n\n  db = pParse->db;\n  v15 = __readfsqword(0x28u);\n  pNewTable = pParse->pNewTable;\n  pExpr = pSpan->pExpr;\n  if ( pNewTable )\n  {\n    v7 = (__int64)&pNewTable->aCol[pNewTable->nCol - 1];\n    if ( exprIsConst(pExpr, db->init.busy + 4, 0) )\n    {\n      v8 = *(Expr **)(v7 + 8);\n      if ( v8 )\n        sqlite3ExprDeleteNN(db, v8);\n      zStart = pSpan->zStart;\n      zEnd = pSpan->zEnd;\n      *(_QWORD *)&x.op = 161LL;\n      memset(&x.pLeft, 0, 56);\n      x.u.zToken = sqlite3DbStrNDup(db, zStart, (int)zEnd - (int)zStart);\n      v11 = pSpan->pExpr;\n      x.flags = 4096;\n      x.pLeft = v11;\n      v12 = exprDup(db, &x, 1, 0LL);\n      zToken = x.u.zToken;\n      *(_QWORD *)(v7 + 8) = v12;\n      sqlite3DbFree(db, zToken);\n      pExpr = pSpan->pExpr;\n    }\n    else\n    {\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\", *(const char **)v7);\n      pExpr = pSpan->pExpr;\n    }\n  }\n  if ( pExpr )\n    sqlite3ExprDeleteNN(db, pExpr);\n}\n",
    "source_code": "void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory. The 'span' of the expression\n      ** is required by pragma table_info.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                    (int)(pSpan->zEnd - pSpan->zStart));\n      x.pLeft = pSpan->pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  sqlite3ExprDelete(db, pSpan->pExpr);\n}",
    "comment": "Validates and sets a default value for the last column of a new table, ensuring it is a constant expression before storing it.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Parses a mangled D language identifier , extracting specific names and properties based on symbol kind , length , and predefined patterns .\n",
    "cpbcs_sum": "Finalizes SQLite statements by retrieving their values, checking for active connections and creating a new object for statement use.\n",
    "misum_sum": "Finalizes the logarithm of a CREATE VIRTUAL TABLE by calculating the corresponding register and symbol table size.\n",
    "decom_sum": "Validates a column's default value as constant, transforms and assigns it, otherwise logs an error and cleans up associated resources.",
    "cfg_sum": "Processes and validates a column\u2019s default value, ensuring it is constant, then updates related data structures and maintains stack integrity.",
    "work_score": {
        "decom": {
            "summary": "Validates a column's default value as constant, transforms and assigns it, otherwise logs an error and cleans up associated resources.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly notes that the function checks whether the default value for a column is constant and that it logs an error if not. It also accurately mentions transforming and assigning the value, and performing cleanup. These are all supported by the source code. There are no incorrect claims or unrelated statements, and all details are consistent with the code\u2019s flow, resulting in a very high proportion of accurate claims.",
                "The summary correctly captures the core operation of validating whether a column's default value is constant and assigning it if valid, which matches the source code's primary purpose. It also notes error logging and cleanup, covering key secondary behaviors like handling invalid defaults and resource cleanup. However, it omits specific implementation details such as duplicating expressions with TK_SPAN, copying the span tokens, and freeing allocated strings, so coverage of secondary behavior is decent but not comprehensive.",
                "The summary correctly states the core purpose: validating that the default value is constant, then assigning it or logging an error. It also notes resource cleanup. These match the source code's logic for constant check, error via sqlite3ErrorMsg, transformation via Expr duplication, and freeing memory. The claims are accurate and target key domain semantics with minimal noise, though the transformation detail is slightly compressed and lacks mention of span token handling, lowering specificity slightly."
            ]
        },
        "cfg": {
            "summary": "Processes and validates a column\u2019s default value, ensuring it is constant, then updates related data structures and maintains stack integrity.",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function processes and validates a column\u2019s default value and ensures it is constant, which matches the code\u2019s check using sqlite3ExprIsConstantOrFunction and error handling. It also notes that the function updates related data structures, aligning with the replacement of pCol->pDflt using sqlite3ExprDup. However, the mention of maintaining stack integrity is inaccurate, as there is no stack-related management in the code. This introduces some noise, reducing overall precision but keeping most claims accurate.",
                "The summary accurately states that the function validates a column\u2019s default value to ensure it is constant and updates data structures, matching the core behavior of checking constancy and setting the default expression. However, it omits critical details such as handling the case when the table pointer is null, error messaging for non-constant defaults, creating and copying a span expression for pragma table_info, freeing and deleting previous expressions, and memory duplication/freeing operations. The mention of 'maintains stack integrity' is inaccurate as there is no stack-related logic in the source.",
                "The summary correctly describes that the function processes and validates a column's default value and ensures it is constant, which matches the check via sqlite3ExprIsConstantOrFunction. It also notes updating related data structures, which aligns with modifying pCol->pDflt. However, the claim about maintaining stack integrity is inaccurate and unrelated to the source code's semantics, introducing NOISE. No FATAL errors are present, but the noise from the incorrect 'stack integrity' claim reduces clarity and limits net benefit, and the accurate claims are mostly generic."
            ]
        },
        "comment": {
            "summary": "Validates and sets a default value for the last column of a new table, ensuring it is a constant expression before storing it.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately describes the core behavior: it validates that the default value for the last column in a new table is constant before assigning it. This matches the source code steps, which check for constant expressions and set the default value accordingly. The summary omits minor implementation details, but all stated claims align with the function's semantics, resulting in a high accuracy proportion.",
                "The summary accurately identifies that the function operates on the last column of a newly created table and validates that its default value is constant before storing it, which matches the core purpose of adding a default constant expression for that column. However, it omits several secondary details, such as handling of error messaging when the expression is invalid, duplication of the expression with a TK_SPAN wrapper, memory cleanup of old default values, and use of pragma table_info specific span tokens. These omissions reduce completeness of coverage beyond the core action.",
                "The summary correctly identifies that the function validates and sets a default value for the last column of a new table, and enforces the requirement that the value be a constant expression before storing it. These are specific and accurate reflections of the core logic in the source code. There is no evidence of inaccurate or noisy claims, but the summary is fairly concise and lacks details about the expression duplication and memory handling steps. Overall, it captures the primary purpose accurately with minimal noise, providing moderate gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585524640,
    "strip_function_name": "sub_FFFFFFFF8165EBA0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8165EBA0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  int v10; // eax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  char v14; // al\n  __int64 v15; // r13\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  v9 = *(_QWORD *)a1;\n  if ( !*(_BYTE *)(a1 + 149) )\n  {\n    *(_BYTE *)(a1 + 149) = 1;\n    v15 = *(_QWORD *)v9;\n    if ( !(unsigned int)sub_FFFFFFFF81656380(*(_DWORD *)(a1 + 8), v18, *(_QWORD *)v9, 0) )\n      sub_FFFFFFFF815E3EF0(v15, v18, a2, a3, a4, a5, v16, v17, a8, a9);\n  }\n  if ( *(_DWORD *)(a1 + 8) != 16777440 && !*(_DWORD *)(v9 + 12) )\n  {\n    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 1000LL) + 552LL) + 72LL);\n    if ( v10 == 1\n      || (v11 = *(_DWORD *)(v9 + 320), v11 == 1)\n      || (v12 = *(_QWORD *)(v9 + 48)) != 0 && qword_FFFFFFFF81CC2000 - v12 < 0\n      || v11 == 2\n      || v10 == 2\n      || (v13 = *(_QWORD *)(v9 + 56)) != 0 && qword_FFFFFFFF81CC2000 - v13 < 0 )\n    {\n      sub_FFFFFFFF81792930(a1 + 144);\n      sub_FFFFFFFF8165E890(a1, 1u);\n      sub_FFFFFFFF81792870(a1 + 144);\n    }\n    else\n    {\n      v14 = *(_BYTE *)(v9 + 72);\n      if ( !v14 )\n        v14 = 2;\n      *(_BYTE *)(a1 + 151) = v14;\n      sub_FFFFFFFF8165E920(v9);\n    }\n  }\n}\n",
    "function_name": "igmp_group_added",
    "decompiled_code": "void __fastcall igmp_group_added(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  int v10; // eax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  char v14; // al\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  __int64 v19; // r13\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  v9 = *(_QWORD *)a1;\n  if ( !*(_BYTE *)(a1 + 149) )\n  {\n    *(_BYTE *)(a1 + 149) = 1;\n    v19 = *(_QWORD *)v9;\n    if ( !(unsigned int)arp_mc_map(*(_DWORD *)(a1 + 8), v22, *(_QWORD *)v9, 0) )\n      dev_mc_add(v19, v22, a2, a3, a4, a5, v20, v21, a8, a9);\n  }\n  if ( *(_DWORD *)(a1 + 8) != 16777440 && !*(_DWORD *)(v9 + 12) )\n  {\n    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 1000LL) + 552LL) + 72LL);\n    if ( v10 == 1\n      || (v11 = *(_DWORD *)(v9 + 320), v11 == 1)\n      || (v12 = *(_QWORD *)(v9 + 48)) != 0 && _vvar_beginning_hack - v12 < 0\n      || v11 == 2\n      || v10 == 2\n      || (v13 = *(_QWORD *)(v9 + 56)) != 0 && _vvar_beginning_hack - v13 < 0 )\n    {\n      raw_spin_lock_bh((volatile signed __int16 *)(a1 + 144));\n      igmp_start_timer(a1, 1u);\n      raw_spin_unlock_bh((_BYTE *)(a1 + 144), 1LL, v15, v16, v17, v18);\n    }\n    else\n    {\n      v14 = *(_BYTE *)(v9 + 72);\n      if ( !v14 )\n        v14 = 2;\n      *(_BYTE *)(a1 + 151) = v14;\n      igmp_ifc_event(v9);\n    }\n  }\n}\n",
    "source_code": "\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}",
    "comment": "The function processes the addition of an IGMP multicast group, initializing it and managing timers based on the interface's multicast version and state.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sends an IGMP report message to the multicast group and handles potential IGMP errors or cleanup based on the message type .\n",
    "cpbcs_sum": "Handles the removal of a multicast group, updating the interface state and sending an IGMP leave message if applicable.\n",
    "misum_sum": "Handles the expiration of a multicast group, updating the interface state and sending an IGMP leave message if necessary.\n",
    "decom_sum": "Initializes a device state and triggers hardware control actions based on status flags and timestamps, updating control bytes when conditions are met.",
    "cfg_sum": "Initializes object state, validates nested structure fields, and triggers appropriate update or event handlers based on configuration values and timing checks.",
    "work_score": {
        "decom": {
            "summary": "Initializes a device state and triggers hardware control actions based on status flags and timestamps, updating control bytes when conditions are met.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about initializing device state, triggering hardware control actions, and updating control bytes based on status flags and timestamps do not align with the source code. The function deals with adding an IGMP group, checking multicast-related conditions, and starting timers, but not with hardware control or timestamp handling. None of the claims directly reflect the actual semantics in the source code, resulting in no accurate matches.",
                "The summary does not mention the core purpose of handling IGMP multicast group addition, filtering, and initiating IGMP report timers. Its reference to device state, hardware control actions, and control bytes is inaccurate with respect to the source code semantics. It lacks coverage of all key domain-specific operations such as filtering by multiaddress, handling IGMP versions, and triggering unsolicited report events.",
                "The summary contains mainly inaccurate and noisy claims. It describes 'initializes a device state' and 'triggers hardware control actions based on status flags and timestamps' with 'updating control bytes', none of which match the source code's actual behavior of managing IGMP multicast group membership, setting flags, adding a multicast filter, and starting timers depending on protocol version. These claims miss the core purpose and I/O semantics entirely, making them FATAL errors on the primary function purpose and effects."
            ]
        },
        "cfg": {
            "summary": "Initializes object state, validates nested structure fields, and triggers appropriate update or event handlers based on configuration values and timing checks.",
            "score": [
                0.9,
                0.2,
                0.5
            ],
            "reason": [
                "The summary contains mostly generic statements that loosely align with the source code but omit key semantics and specifics. The claim about initializing object state corresponds to setting 'im->loaded = 1' and other initializations [ACCURATE], the 'validates nested structure fields' aligns with checking 'in_dev->dead' [ACCURATE], and 'triggers appropriate update or event handlers based on configuration values and timing checks' partially matches the IGMP version checks and function calls [ACCURATE but generic]. However, the description is vague, lacks direct reference to multicast address checks or IGMP version-specific behavior, and does not convey important conditions such as early returns on certain addresses. Overall, the claims are correct but high-level, with no evident inaccuracies, giving a high but not perfect score.",
                "The summary gives a vague, generic description of initializing state and triggering events, but does not clearly cover the core purpose of handling the addition of an IGMP multicast group, including version-specific logic and branch conditions. It misses key behavior such as adding the multicast address filter, skipping IGMP_ALL_HOSTS, handling dead interfaces, starting timers for IGMPv1/v2, and initiating unsolicited reports for v3. The description does not target the specific domain semantics of IGMP group management present in the source code.",
                "The summary contains mostly generic, safe claims about initialization, validation, and triggering handlers, but it lacks specific detail about IGMP group addition behavior, conditional returns for IGMP versions, or the actual functions called. There are no outright factual errors contradicting the source, but the content is high-level boilerplate with little domain-specific insight. Worst failure mode is NOISE, and the gain is low due to lack of specific, verifiable claims tied to the code's core semantics."
            ]
        },
        "comment": {
            "summary": "The function processes the addition of an IGMP multicast group, initializing it and managing timers based on the interface's multicast version and state.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function handles the addition of an IGMP multicast group, performs initialization, and manages timers depending on the interface's multicast version and state. These are direct and accurate reflections of the source code's behavior, with no incorrect or irrelevant claims. The description is generic but aligns closely with the actual control flow and conditions seen in the code, resulting in high claim accuracy.",
                "The summary correctly identifies that the function handles IGMP multicast group addition and that behavior depends on the interface\u2019s multicast version and state, which matches the core purpose of initializing and managing multicast group timers. However, it omits several key secondary details such as checking for IGMP_ALL_HOSTS, early returns for dead interfaces, the conditionally starting timers for IGMP v1/v2, the v3-specific counter setting, and calling igmp_ifc_event. This leads to incomplete coverage of important branch and side-effect semantics.",
                "The summary correctly identifies the core purpose of the function\u2014adding an IGMP multicast group and managing timers depending on the interface's multicast version and state\u2014matching the conditional flows for IGMPv1/v2 and v3 in the source. It omits some specific details like skipping operations for IGMP_ALL_HOSTS or dead interfaces and the initial filter addition when `loaded` is zero, but these omissions are minor. No inaccurate or contradictory claims are present, and while the claims are accurate, they are fairly high-level and lack fine-grained specifics, resulting in moderate informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580470048,
    "strip_function_name": "sub_FFFFFFFF8118CB20",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8118CB20(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // r12d\n  _UNKNOWN **v5; // rbx\n  _QWORD *v6; // rax\n  __int64 v7; // rdx\n  _QWORD *v8; // rax\n  _QWORD *v9; // rdx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rdx\n\n  if ( (unsigned int)*(_QWORD *)(a2 + 8) )\n  {\n    v4 = *(_QWORD *)(a2 + 8);\n    sub_FFFFFFFF81792900(&byte_FFFFFFFF81C04540);\n    v5 = off_FFFFFFFF81C40D78[0];\n    do\n    {\n      if ( v5 == &off_FFFFFFFF81C40D70 )\n        break;\n      v6 = *(v5 - 3);\n      if ( v6 )\n      {\n        v7 = (__int64)*(v5 - 4);\n        *v6 = v7;\n        if ( v7 )\n          *(_QWORD *)(v7 + 8) = v6;\n        *(v5 - 4) = 0LL;\n        *(v5 - 3) = 0LL;\n      }\n      v8 = *v5;\n      if ( v5 != (_UNKNOWN **)*v5 )\n      {\n        v9 = v5[1];\n        v8[1] = v9;\n        *v9 = v8;\n        *v5 = v5;\n        v10 = (unsigned int)dword_FFFFFFFF81CB8B04;\n        v5[1] = v5;\n        sub_FFFFFFFF812C76B0(&unk_FFFFFFFF81E93670, -1LL, v10);\n      }\n      sub_FFFFFFFF812C76B0(&unk_FFFFFFFF81E93648, -1LL, (unsigned int)dword_FFFFFFFF81CB8B04);\n      v11 = *(v5 - 1);\n      v12 = (__int64)*(v5 - 2);\n      *(_QWORD *)(v12 + 8) = v11;\n      *v11 = v12;\n      *(v5 - 2) = (_UNKNOWN *)0xDEAD000000000100LL;\n      *(v5 - 1) = (_UNKNOWN *)0xDEAD000000000200LL;\n      (*(void (__fastcall **)(_UNKNOWN **))(*((_QWORD *)v5[13] + 7) + 16LL))(v5 - 4);\n      --v4;\n      v5 = off_FFFFFFFF81C40D78[0];\n    }\n    while ( v4 );\n    ++byte_FFFFFFFF81C04540;\n  }\n  v2 = qword_FFFFFFFF81E93678;\n  if ( qword_FFFFFFFF81E93678 < 0 )\n    v2 = 0;\n  return v2 / 0x64 * dword_FFFFFFFF81CB88E0;\n}\n",
    "function_name": "shrink_dqcache_memory",
    "decompiled_code": "__int64 __fastcall shrink_dqcache_memory(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // r12d\n  _UNKNOWN **v5; // rbx\n  _QWORD *v6; // rax\n  __int64 v7; // rdx\n  _QWORD *v8; // rax\n  _QWORD *v9; // rdx\n  _QWORD *v10; // rax\n  __int64 v11; // rdx\n\n  if ( (unsigned int)*(_QWORD *)(a2 + 8) )\n  {\n    v4 = *(_QWORD *)(a2 + 8);\n    raw_spin_lock((volatile signed __int16 *)&dq_list_lock);\n    v5 = off_FFFFFFFF81C40D78[0];\n    do\n    {\n      if ( v5 == &free_dquots )\n        break;\n      v6 = *(v5 - 3);\n      if ( v6 )\n      {\n        v7 = (__int64)*(v5 - 4);\n        *v6 = v7;\n        if ( v7 )\n          *(_QWORD *)(v7 + 8) = v6;\n        *(v5 - 4) = 0LL;\n        *(v5 - 3) = 0LL;\n      }\n      v8 = *v5;\n      if ( v5 != (_UNKNOWN **)*v5 )\n      {\n        v9 = v5[1];\n        v8[1] = v9;\n        *v9 = v8;\n        *v5 = v5;\n        LODWORD(v9) = percpu_counter_batch;\n        v5[1] = v5;\n        _percpu_counter_add((__int64)&unk_FFFFFFFF81E93670, -1LL, (int)v9);\n      }\n      _percpu_counter_add((__int64)&unk_FFFFFFFF81E93648, -1LL, percpu_counter_batch);\n      v10 = *(v5 - 1);\n      v11 = (__int64)*(v5 - 2);\n      *(_QWORD *)(v11 + 8) = v10;\n      *v10 = v11;\n      *(v5 - 2) = (_UNKNOWN *)0xDEAD000000000100LL;\n      *(v5 - 1) = (_UNKNOWN *)0xDEAD000000000200LL;\n      (*(void (__fastcall **)(_UNKNOWN **))(*((_QWORD *)v5[13] + 7) + 16LL))(v5 - 4);\n      --v4;\n      v5 = off_FFFFFFFF81C40D78[0];\n    }\n    while ( v4 );\n    ++dq_list_lock;\n  }\n  v2 = qword_FFFFFFFF81E93678;\n  if ( qword_FFFFFFFF81E93678 < 0 )\n    v2 = 0;\n  return v2 / 0x64 * sysctl_vfs_cache_pressure;\n}\n",
    "source_code": "static int shrink_dqcache_memory(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tint nr = sc->nr_to_scan;\n\n\tif (nr) {\n\t\tspin_lock(&dq_list_lock);\n\t\tprune_dqcache(nr);\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\treturn ((unsigned)\n\t\tpercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS])\n\t\t/100) * sysctl_vfs_cache_pressure;\n}",
    "comment": "Releases disk quota cache memory by pruning unused entries based on the specified number of entries to scan and adjusts the cache pressure accordingly.",
    "hext5_sum": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
    "bint5_sum": "Transfers disk quotas from the current inode 's user and group to new user and group IDs specified in the inode 's attributes .\n",
    "cpbcs_sum": "Removes a dentry from the hash table if it is not empty, ensuring thread safety with mutexes and RCU synchronization.\n",
    "misum_sum": "The function removes a virtual memory area from a hash table and frees the associated memory management structure if available.\n",
    "decom_sum": "Cleans up and deallocates entries from a global linked list, invokes associated destructors, then returns a scaled percentage value from a global counter.",
    "cfg_sum": "The function iterates over and unlinks active objects from global lists, cleans their links, invokes destructors, updates a status flag, and returns a scaled state value.",
    "work_score": {
        "decom": {
            "summary": "Cleans up and deallocates entries from a global linked list, invokes associated destructors, then returns a scaled percentage value from a global counter.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The claim about cleaning up and deallocating entries from a global linked list is partially accurate, as the function does prune a dqcache under a lock, but there is no direct evidence of invoking destructors in the source code; that detail is speculative. The statement about returning a scaled percentage from a global counter is generally accurate, since it reads a positive per-CPU counter and multiplies by sysctl_vfs_cache_pressure. Overall, one claim is clearly accurate, one is partially accurate/speculative, resulting in mixed reliability around the 50% range.",
                "The summary asserts deallocation of entries from a global linked list and invocation of destructors, which are not supported by the source code, making these claims inaccurate. The actual core purpose from the code is to prune the dqcache using prune_dqcache under a spinlock and return a scaled value based on free dquots, but this specific domain action is not accurately described in the summary. While the return of a scaled percentage from a global counter is generally correct, the omission of the pruning of dqcache and locking mechanism, coupled with the incorrect destructor claim, results in poor coverage of core and secondary semantics.",
                "The summary contains a FATAL inaccuracy: it claims the function deallocates entries from a global linked list and invokes destructors, which is not shown in the source code \u2014 the code only locks, prunes dqcache, and unlocks, without explicit deallocation or destructor calls. The return value description is mostly accurate in that it derives from a global counter scaled by sysctl_vfs_cache_pressure, but the major inaccuracy about the core purpose significantly undermines trust."
            ]
        },
        "cfg": {
            "summary": "The function iterates over and unlinks active objects from global lists, cleans their links, invokes destructors, updates a status flag, and returns a scaled state value.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "Most claims in the summary are inaccurate when compared to the source code. The function does not iterate over or unlink active objects, clean links, invoke destructors, or update a status flag. It conditionally locks a global list, prunes the dqcache based on a count, and returns a scaled counter value, making only the final return-value-related part loosely accurate. Less than half of the claims match the actual implementation.",
                "The summary\u2019s claims about iterating over and unlinking active objects, cleaning links, invoking destructors, and updating a status flag do not align with the source code, which instead conditionally locks a list, prunes a quota cache, and returns a scaled counter value. The core purpose of pruning the dqcache under lock and computing the return metric is missing, and most claims are inaccurate relative to actual code semantics.",
                "The summary introduces multiple inaccurate claims about the function's behavior, such as iterating over and unlinking active objects, cleaning links, invoking destructors, and updating a status flag, none of which occur in the source code. The actual code prunes the dqcache under a lock and returns a scaled counter value. These inaccuracies target the core purpose and side effects, making them FATAL errors. While the return of a scaled value is somewhat aligned, it is overshadowed by the dominant misrepresentation of the main logic."
            ]
        },
        "comment": {
            "summary": "Releases disk quota cache memory by pruning unused entries based on the specified number of entries to scan and adjusts the cache pressure accordingly.",
            "score": [
                1.0,
                0.8,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function prunes disk quota cache entries based on the number of entries to scan, which aligns with the code's use of prune_dqcache after checking nr_to_scan. It also mentions adjusting cache pressure, which matches the return value calculation involving sysctl_vfs_cache_pressure. Both claims are accurate and grounded in the code, showing strong alignment.",
                "The summary accurately conveys the core purpose\u2014pruning disk quota cache entries based on the number requested to scan\u2014and mentions the return value adjusting cache pressure. It correctly reflects the lock-protected pruning and ties the count to sysctl_vfs_cache_pressure, covering both the main operation and significant secondary behavior. However, it omits explicit mention of the spin lock usage and the condition that pruning only happens when nr_to_scan is nonzero, which are relevant edge-case details.",
                "The summary accurately states that the function prunes disk quota cache entries based on the number to scan and involves cache pressure adjustments. This aligns with the source code\u2019s behavior of locking, calling prune_dqcache with nr_to_scan, and returning a value scaled by sysctl_vfs_cache_pressure. There are no contradictory claims, and noise is minimal, but the summary is somewhat generic and lacks specifics such as locking mechanisms or the exact calculation method, resulting in moderate gain rather than high gain."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 590960,
    "strip_function_name": "BN_CTX_end",
    "strip_decompiled_code": "__int64 __fastcall BN_CTX_end(__int64 a1)\n{\n  int v1; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  unsigned int v4; // ecx\n  __int64 result; // rax\n  int v6; // esi\n  int i; // edx\n\n  v1 = *(_DWORD *)(a1 + 52);\n  if ( v1 )\n  {\n    result = (unsigned int)(v1 - 1);\n    *(_DWORD *)(a1 + 52) = result;\n  }\n  else\n  {\n    v2 = *(_QWORD *)(a1 + 32);\n    v3 = (unsigned int)(*(_DWORD *)(a1 + 40) - 1);\n    *(_DWORD *)(a1 + 40) = v3;\n    v4 = *(_DWORD *)(v2 + 4 * v3);\n    result = *(unsigned int *)(a1 + 48);\n    if ( (unsigned int)result > v4 )\n    {\n      v6 = *(_DWORD *)(a1 + 24);\n      LODWORD(result) = result - v4;\n      *(_DWORD *)(a1 + 24) = v6 - result;\n      for ( i = ((_BYTE)v6 - 1) & 0xF; ; --i )\n      {\n        result = (unsigned int)(result - 1);\n        if ( (_DWORD)result == -1 )\n          break;\n        while ( !i )\n        {\n          result = (unsigned int)(result - 1);\n          *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 384LL);\n          i = 15;\n          if ( (_DWORD)result == -1 )\n            goto LABEL_7;\n        }\n      }\n    }\nLABEL_7:\n    *(_DWORD *)(a1 + 48) = v4;\n    *(_DWORD *)(a1 + 56) = 0;\n  }\n  return result;\n}\n",
    "function_name": "BN_CTX_end",
    "decompiled_code": "__int64 __fastcall BN_CTX_end(__int64 a1)\n{\n  int v1; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  unsigned int v4; // ecx\n  __int64 result; // rax\n  int v6; // esi\n  int i; // edx\n\n  v1 = *(_DWORD *)(a1 + 52);\n  if ( v1 )\n  {\n    result = (unsigned int)(v1 - 1);\n    *(_DWORD *)(a1 + 52) = result;\n  }\n  else\n  {\n    v2 = *(_QWORD *)(a1 + 32);\n    v3 = (unsigned int)(*(_DWORD *)(a1 + 40) - 1);\n    *(_DWORD *)(a1 + 40) = v3;\n    v4 = *(_DWORD *)(v2 + 4 * v3);\n    result = *(unsigned int *)(a1 + 48);\n    if ( (unsigned int)result > v4 )\n    {\n      v6 = *(_DWORD *)(a1 + 24);\n      LODWORD(result) = result - v4;\n      *(_DWORD *)(a1 + 24) = v6 - result;\n      for ( i = ((_BYTE)v6 - 1) & 0xF; ; --i )\n      {\n        result = (unsigned int)(result - 1);\n        if ( (_DWORD)result == -1 )\n          break;\n        while ( !i )\n        {\n          result = (unsigned int)(result - 1);\n          *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 384LL);\n          i = 15;\n          if ( (_DWORD)result == -1 )\n            goto LABEL_7;\n        }\n      }\n    }\nLABEL_7:\n    *(_DWORD *)(a1 + 48) = v4;\n    *(_DWORD *)(a1 + 56) = 0;\n  }\n  return result;\n}\n",
    "source_code": "\nvoid BN_CTX_end(BN_CTX *ctx)\n\t{\n\tCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\n\tif(ctx->err_stack)\n\t\tctx->err_stack--;\n\telse\n\t\t{\n\t\tunsigned int fp = BN_STACK_pop(&ctx->stack);\n\t\t/* Does this stack frame have anything to release? */\n\t\tif(fp < ctx->used)\n\t\t\tBN_POOL_release(&ctx->pool, ctx->used - fp);\n\t\tctx->used = fp;\n\t\t/* Unjam \"too_many\" in case \"get\" had failed */\n\t\tctx->too_many = 0;\n\t\t}\n\tCTXDBG_EXIT(ctx);\n\t}",
    "comment": "Releases resources associated with the BN_CTX structure, updating the used stack frame and resetting the too_many flag if necessary.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Decrements the reference count of a BIGNUM_CTX structure and frees associated memory if the count reaches zero , ensuring proper context management .\n",
    "cpbcs_sum": "Decrements the reference count of a BIGNUM structure, frees it if the count reaches zero.\n",
    "misum_sum": "Multiplies a BIGNUM by adjusting its length, storing the result in the solver if the context is less than zero.\n",
    "decom_sum": "Restores the previous state of a big number context, adjusting stack depth and resource counters after a scoped allocation block ends.",
    "cfg_sum": "Restores the BN_CTX context by decrementing depth counters, adjusting resource indices, and resetting state variables after completing allocated big number operations.",
    "work_score": {
        "decom": {
            "summary": "Restores the previous state of a big number context, adjusting stack depth and resource counters after a scoped allocation block ends.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly captures the core behavior of BN_CTX_end, which restores the prior state of the big number context by adjusting stack depth (`ctx->stack`) and resource counters (`ctx->used`, `ctx->too_many`) after the end of an allocation block. All content is aligned with the code\u2019s actions and scope, without introducing inaccuracies or irrelevant noise. This yields a very high proportion of accurate claims.",
                "The summary correctly captures the core purpose: restoring the previous state of a big number context after a scoped allocation by adjusting stack and resource counters, which matches the function\u2019s domain-specific effect of popping the stack frame, releasing pool resources, and resetting usage. However, it omits certain secondary details from the source, such as handling the error stack decrement branch, the condition to release resources only when fp < used, and resetting the 'too_many' flag. This limits completeness in coverage of behavior-critical semantics.",
                "The summary accurately captures the core purpose of the function: it restores the previous state of a big number context after an allocation block, consistent with the code's logic to pop the stack frame, release resources if needed, and reset counters. There are no incorrect or irrelevant claims, and although the description is somewhat general, it aligns well with the primary domain semantics without introducing noise."
            ]
        },
        "cfg": {
            "summary": "Restores the BN_CTX context by decrementing depth counters, adjusting resource indices, and resetting state variables after completing allocated big number operations.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly captures the restoration of the BN_CTX state, mentioning decrementing counters, adjusting resources, and resetting flags, which aligns with the code's decrement of err_stack, stack popping, pool release, and resetting too_many. All claims are accurate and relevant to the function\u2019s semantics, with no incorrect or irrelevant statements.",
                "The summary conveys the idea of restoring the BN_CTX context, which reflects the core function of resetting resource usage to a previous stack frame position and clearing error-related state after big number operations. This matches the source code's primary purpose of popping a stack frame, releasing any allocated pool resources, and resetting 'too_many'. However, it omits specific branching behavior for when 'err_stack' is nonzero and lacks mention of exact actions like decrementing 'err_stack', popping the frame pointer, and conditionally releasing resources based on 'fp' vs 'used'. Secondary details such as constants, error state handling specifics, and conditional logic are underrepresented.",
                "The summary correctly captures that BN_CTX_end restores context by adjusting counters and releasing resources after big number operations. It aligns with the source code's decrement of err_stack, popping stack frames, releasing pool resources when needed, resetting ctx->used and ctx->too_many. There is no contradictory or irrelevant noise, but the description is fairly generic and does not detail the specific variables or conditions, resulting in only modest insight."
            ]
        },
        "comment": {
            "summary": "Releases resources associated with the BN_CTX structure, updating the used stack frame and resetting the too_many flag if necessary.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function releases resources related to BN_CTX, updates the used stack frame, and resets the too_many flag when applicable. All these are verifiable in the source: the code calls BN_POOL_release to free resources if needed, updates ctx->used to the popped frame pointer, and sets ctx->too_many to 0. The description is accurate but omits the err_stack decrement logic, making it slightly incomplete. Overall, the majority of claims are accurate and grounded in the code.",
                "The summary correctly identifies that BN_CTX_end releases resources, updates the used frame, and resets the too_many flag, which matches the core purpose of freeing any pool allocations when unwinding a stack frame and clearing the too_many state. However, it omits mention of the err_stack decrement branch, the condition where no release occurs, and the specific interaction with BN_POOL_release and BN_STACK_pop. Core functionality is covered, but secondary details like error stack handling and exact release conditions are missing.",
                "The summary correctly states that the function releases resources tied to the BN_CTX structure, updates the used stack frame, and resets the too_many flag, which aligns with the code\u2019s behavior of calling BN_POOL_release, updating ctx->used, and setting ctx->too_many to 0. However, it omits the conditional handling of err_stack and does not mention the debug macros, leading to a low level of detail. All claims are accurate but generic, providing limited insight beyond a broad description."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584132624,
    "strip_function_name": "sub_FFFFFFFF8150AE10",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8150AE10(\n        __int64 a1,\n        _BYTE *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v14; // rcx\n  __int64 v15; // rax\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( !memcmp(a2, \"default\", 7uLL) )\n  {\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v14 + 120))(a1, 0LL, 0LL);\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = *(_QWORD *)(a1 + 248);\n    }\n    v18[0] = v15;\n    *(_DWORD *)(a1 + 256) = 0;\n  }\n  else\n  {\n    if ( (int)sub_FFFFFFFF81509C60(a2, v18) < 0 )\n      return -22LL;\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v17 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v14 + 120))(a1, 0LL, 0LL);\n      v15 = v18[0];\n      if ( v17 < v18[0] )\n        return -7LL;\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = v18[0];\n    }\n    *(_DWORD *)(a1 + 256) = 1;\n  }\n  *(_QWORD *)(a1 + 248) = v15;\n  if ( v14 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 80LL) = v15;\n    sub_FFFFFFFF8116B620(*(_QWORD *)(a1 + 72), a4, a5, a6, a7, a8, a9, a10, a11);\n  }\n  return a3;\n}\n",
    "function_name": "array_size_store",
    "decompiled_code": "__int64 __fastcall array_size_store(\n        __int64 a1,\n        _BYTE *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v14; // rcx\n  __int64 v15; // rax\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( !memcmp(a2, \"default\", 7uLL) )\n  {\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, double, double, double, double, double, double, double, double))(v14 + 120))(\n              a1,\n              0LL,\n              0LL,\n              a4,\n              a5,\n              a6,\n              a7,\n              a8,\n              a9,\n              a10,\n              a11);\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = *(_QWORD *)(a1 + 248);\n    }\n    v18[0] = v15;\n    *(_DWORD *)(a1 + 256) = 0;\n  }\n  else\n  {\n    if ( (int)strict_blocks_to_sectors(a2, v18) < 0 )\n      return -22LL;\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v17 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, double, double, double, double, double, double, double, double))(v14 + 120))(\n              a1,\n              0LL,\n              0LL,\n              a4,\n              a5,\n              a6,\n              a7,\n              a8,\n              a9,\n              a10,\n              a11);\n      v15 = v18[0];\n      if ( v17 < v18[0] )\n        return -7LL;\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = v18[0];\n    }\n    *(_DWORD *)(a1 + 256) = 1;\n  }\n  *(_QWORD *)(a1 + 248) = v15;\n  if ( v14 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 80LL) = v15;\n    revalidate_disk(*(_QWORD *)(a1 + 72), a4, a5, a6, a7, a8, a9, a10, a11);\n  }\n  return a3;\n}\n",
    "source_code": "\nstatic ssize_t\narray_size_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tsector_t sectors;\n\n\tif (strncmp(buf, \"default\", 7) == 0) {\n\t\tif (mddev->pers)\n\t\t\tsectors = mddev->pers->size(mddev, 0, 0);\n\t\telse\n\t\t\tsectors = mddev->array_sectors;\n\n\t\tmddev->external_size = 0;\n\t} else {\n\t\tif (strict_blocks_to_sectors(buf, &sectors) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->pers && mddev->pers->size(mddev, 0, 0) < sectors)\n\t\t\treturn -E2BIG;\n\n\t\tmddev->external_size = 1;\n\t}\n\n\tmddev->array_sectors = sectors;\n\tif (mddev->pers) {\n\t\tset_capacity(mddev->gendisk, mddev->array_sectors);\n\t\trevalidate_disk(mddev->gendisk);\n\t}\n\treturn len;\n}",
    "comment": "Sets the array size for a storage device based on input, updating capacity and validating the disk if a specific size is provided.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Retrieves the current temperature from a thermal zone device or falls back to the thermal zone 's temperature if the name is `` default '' .\n",
    "cpbcs_sum": "Transfers data from a memory-mapped offset to a file after validating the offset and managing synchronization and ensuring thread safety.\n",
    "misum_sum": "Sets the maximum synchronization flag for a device, validating input and invoking a callback function to appropriate callbacks based on the old.\n",
    "decom_sum": "Configures a device parameter to either the \u201cdefault\u201d preset or a validated custom value, then updates hardware settings with given floating\u2011point parameters.",
    "cfg_sum": "Updates a device's configuration to either the default or a validated custom value, then applies parameter changes through linked hardware control callbacks.",
    "work_score": {
        "decom": {
            "summary": "Configures a device parameter to either the \u201cdefault\u201d preset or a validated custom value, then updates hardware settings with given floating\u2011point parameters.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes switching between a 'default' and a custom value, but inaccurately describes the specifics: the function deals with sectors and array size, not floating\u2011point parameters, and uses integer/sector calculations. The incorrect mention of hardware settings with floating\u2011point parameters contradicts the source code. Only part of the summary aligns with the actual code behavior, with most details being inaccurate.",
                "The summary\u2019s core claim about configuring a device parameter to a default or validated custom value loosely aligns with the code\u2019s handling of 'default' versus parsed sector values, so it partially captures the main purpose. However, it incorrectly states that hardware settings are updated with floating\u2011point parameters, which contradicts the code\u2019s use of integer sector sizes and block/sector conversion. It also omits critical secondary behaviors such as error handling for invalid input or oversized values, setting external_size flags, and calls to set_capacity/revalidate_disk. Overall coverage of the core is weak and there are notable inaccuracies.",
                "The summary claims that hardware settings are updated with floating\u2011point parameters, which is inaccurate because the code operates on integer sector sizes, not floating points. It also implies generic 'device parameter configuration' without noting crucial specifics such as the parsing of \"default\" vs. custom sector values, validation via strict_blocks_to_sectors, and errors for oversized requests (E2BIG). These omissions and inaccuracies target core I/O behavior incorrectly, making this a severe semantic mismatch (FATAL) on the primary purpose. The few accurate elements, like switching between default and custom values, are overshadowed by the misinformation."
            ]
        },
        "cfg": {
            "summary": "Updates a device's configuration to either the default or a validated custom value, then applies parameter changes through linked hardware control callbacks.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function can set either a default or validated custom value and refers to applying changes, which aligns with the code's logic for assigning sectors and updating capacity via callbacks. However, it omits specific conditions like input parsing, error returns (-EINVAL, -E2BIG), and the handling of external_size flags. The statement about 'linked hardware control callbacks' is broadly accurate but generic. Most claims are accurate but at a high-level, with minor omissions of detail.",
                "The summary correctly conveys that the function updates a device configuration to either a default or a validated custom value, and triggers further changes via hardware control callbacks, which aligns with the core purpose of setting mddev array size and updating capacity via linked functions. However, it omits specific domain details such as handling 'default' keyword input, specific validation against current size, error codes like -EINVAL and -E2BIG, updating array_sectors and external_size flags, and calling set_capacity and revalidate_disk. This makes the coverage of secondary behavior incomplete.",
                "The summary accurately conveys that the function can set the configuration to a default or to a validated custom value, and that it triggers hardware-related updates via callbacks. These align with the code checking for the \"default\" string, validating custom sizes, updating array_sectors, and calling set_capacity and revalidate_disk. However, the description is generic, using broad terms like 'linked hardware control callbacks' instead of specifying the exact disk capacity reset and revalidation operations. No contradictory or irrelevant claims are present, but the summary lacks specificity that would significantly help an engineer, resulting in low informational gain."
            ]
        },
        "comment": {
            "summary": "Sets the array size for a storage device based on input, updating capacity and validating the disk if a specific size is provided.",
            "score": [
                0.6,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function sets the array size based on input and updates capacity, which matches the code\u2019s behavior when assigning `array_sectors` and calling `set_capacity`. However, it omits key conditions, such as handling the \"default\" keyword, differentiating between external and default sizes, and error returns for invalid or too-large sizes. The claim that it validates the disk when a specific size is provided is loosely accurate but lacks specificity to the conditional checks, making it only partially precise.",
                "The summary captures the core purpose of setting a storage array size and mentions capacity update and validation, aligning with the function's main domain action of determining and applying the array size. However, it omits key branch-specific details like handling the 'default' keyword, parsing sizes, error conditions (-EINVAL, -E2BIG), and the distinction between using internal versus external size, resulting in incomplete secondary coverage.",
                "The summary correctly captures the primary purpose of setting the array size based on input and mentions capacity updates and disk validation, aligning with the code's behavior when a specific size is provided. However, it omits the 'default' keyword handling, error checks for invalid or too-large sizes, and the setting of 'external_size', which are important operational details. There are no inaccurate claims, but the gain is low due to lack of specificity and missing key logic paths."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579235968,
    "strip_function_name": "sub_FFFFFFFF8105F680",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8105F680(__int64 a1)\n{\n  __int64 *v1; // rbx\n  __int64 v2; // rdx\n  _QWORD *v3; // rax\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  int v7; // r9d\n  __int64 v8; // r13\n  __int64 v9; // rax\n  bool v10; // zf\n  __int64 (__fastcall **v11)(); // rax\n  __int64 (__fastcall *v12)(); // rax\n\n  v1 = *(__int64 **)(a1 + 120);\n  if ( (__int64 *)(a1 + 120) != v1 )\n  {\n    while ( 1 )\n    {\n      v8 = sub_FFFFFFFF817928D0(v1 + 4);\n      v9 = *((int *)v1 + 9);\n      if ( (int)v9 < 0 )\n      {\n        v11 = off_FFFFFFFF81C316C0;\n        if ( (*((_DWORD *)v1 + 9) & 7) == 3 )\n          v11 = off_FFFFFFFF81C33E80;\n      }\n      else if ( (int)v9 > 15\n             || (v4 = 80 * v9,\n                 v10 = qword_FFFFFFFF81E3EEE0[10 * v9] == 0,\n                 v11 = (__int64 (__fastcall **)())&qword_FFFFFFFF81E3EEE0[10 * v9],\n                 v10) )\n      {\nLABEL_3:\n        if ( !byte_FFFFFFFF81CAC55D )\n        {\n          sub_FFFFFFFF8103BB80((__int64)\"kernel/posix-timers.c\", 929, v4, v5, v6, v7);\n          byte_FFFFFFFF81CAC55D = 1;\n        }\n        goto LABEL_5;\n      }\n      v12 = v11[8];\n      if ( !v12 )\n        goto LABEL_3;\n      if ( ((unsigned int (__fastcall *)(__int64 *))v12)(v1) == 1 )\n      {\n        sub_FFFFFFFF81792660(v1 + 4, v8);\n      }\n      else\n      {\nLABEL_5:\n        v2 = *v1;\n        v3 = (_QWORD *)v1[1];\n        *(_QWORD *)(v2 + 8) = v3;\n        *v3 = v2;\n        *v1 = 0xDEAD000000000100LL;\n        v1[8] = 0LL;\n        v1[1] = 0xDEAD000000000200LL;\n        sub_FFFFFFFF81792660(v1 + 4, v8);\n        sub_FFFFFFFF8105EA70(v1, 1);\n        v1 = *(__int64 **)(a1 + 120);\n        if ( v1 == (__int64 *)(a1 + 120) )\n          return;\n      }\n    }\n  }\n}\n",
    "function_name": "exit_itimers",
    "decompiled_code": "void __fastcall exit_itimers(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  volatile signed __int16 *v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rax\n  bool v17; // zf\n  __int64 (__fastcall **v18)(); // rax\n  __int64 (__fastcall *v19)(); // rax\n\n  v9 = *(volatile signed __int16 **)(a1 + 120);\n  if ( (volatile signed __int16 *)(a1 + 120) != v9 )\n  {\n    while ( 1 )\n    {\n      raw_spin_lock_irqsave(v9 + 16);\n      v16 = *((int *)v9 + 9);\n      if ( (int)v16 < 0 )\n      {\n        v18 = clock_posix_cpu;\n        if ( (*((_DWORD *)v9 + 9) & 7) == 3 )\n          v18 = clock_posix_dynamic;\n      }\n      else if ( (int)v16 > 15\n             || (v17 = posix_clocks[10 * v16] == 0, v18 = (__int64 (__fastcall **)())&posix_clocks[10 * v16], v17) )\n      {\nLABEL_3:\n        if ( !_warned_28687 )\n        {\n          warn_slowpath_null(\"kernel/posix-timers.c\", 0x3A1u, a2, a3, a4, a5, v14, v15, a8, a9);\n          _warned_28687 = 1;\n        }\n        goto LABEL_5;\n      }\n      v19 = v18[8];\n      if ( !v19 )\n        goto LABEL_3;\n      if ( ((unsigned int (__fastcall *)(volatile signed __int16 *))v19)(v9) == 1 )\n      {\n        raw_spin_unlock_irqrestore((_BYTE *)v9 + 32);\n      }\n      else\n      {\nLABEL_5:\n        v10 = *(_QWORD *)v9;\n        v11 = (_QWORD *)*((_QWORD *)v9 + 1);\n        *(_QWORD *)(v10 + 8) = v11;\n        *v11 = v10;\n        *(_QWORD *)v9 = 0xDEAD000000000100LL;\n        *((_QWORD *)v9 + 8) = 0LL;\n        *((_QWORD *)v9 + 1) = 0xDEAD000000000200LL;\n        raw_spin_unlock_irqrestore((_BYTE *)v9 + 32);\n        release_posix_timer(v9, 1, a2, a3, a4, a5, v12, v13, a8, a9);\n        v9 = *(volatile signed __int16 **)(a1 + 120);\n        if ( v9 == (volatile signed __int16 *)(a1 + 120) )\n          return;\n      }\n    }\n  }\n}\n",
    "source_code": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "comment": "Deletes all posix timers associated with the given signal structure by iterating through and removing each timer from the list.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Frees all PID lists associated with the given PID namespace and then deallocates the namespace structure itself .\n",
    "cpbcs_sum": "Processes a worker pool, executing associated operations while managing RCU callbacks and handling memory operations for safe concurrent access.\n",
    "misum_sum": "Executes a usermode helper process, managing its state and registry if necessary.\n",
    "decom_sum": "Iterates and removes expired POSIX timers from a kernel timer list, invoking their callbacks or cleaning up invalid entries.",
    "cfg_sum": "Iterates over a list of POSIX timers, validates and processes each, and removes and cleans up invalid or expired timers.",
    "work_score": {
        "decom": {
            "summary": "Iterates and removes expired POSIX timers from a kernel timer list, invoking their callbacks or cleaning up invalid entries.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function removes expired POSIX timers and invokes callbacks or cleans up invalid entries, but the source code shows it iterates through all timers in the list and deletes them using itimer_delete without checking expiration or invoking callbacks. This introduces inaccuracies targeting code semantics, resulting in less than half of the claims being correct.",
                "The core purpose of the function is to iterate through and delete all POSIX timers in the signal_struct's list by calling itimer_delete until the list is empty. The summary inaccurately specifies 'expired' timers and mentions invoking callbacks or cleaning invalid entries, which are not indicated in the source code. This means the core domain action is not correctly covered, and the added details are incorrect, leaving almost no accurate coverage.",
                "The summary claims the function removes expired POSIX timers and invokes their callbacks or cleans up invalid entries. The source code actually iterates through all POSIX timers in the signal_struct's list and deletes them via itimer_delete, without any logic to check expiration, invoke callbacks, or specifically handle invalid entries. This is a FATAL inaccuracy on the core purpose (what the function does), as it misstates the primary behavior by adding non-existent conditions and actions, making the description misleading and untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Iterates over a list of POSIX timers, validates and processes each, and removes and cleans up invalid or expired timers.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function validates and processes each timer and specifically removes and cleans up invalid or expired timers, but the source code only shows iteration over the list of POSIX timers and deletion via itimer_delete without explicit validation or checks for expired/invalid status. The only accurate part is that it iterates over POSIX timers; most other details are unsupported by the code, leading to a low proportion of accurate claims.",
                "The summary claims that the function validates and processes each timer and specifically removes and cleans up invalid or expired timers, but the source code shows it simply iterates through all POSIX timers in the list and deletes them without any validation or expiry checks. This means the core action of deleting all timers is not accurately covered, and the added details about validation/expiry are inaccurate. Secondary details about cleanup are partially implied but framed incorrectly.",
                "The summary incorrectly claims the function validates and distinguishes invalid or expired timers before removal, which is not reflected in the source code. The code simply iterates over the `posix_timers` list and deletes each timer without any conditional checks. This is a FATAL error affecting the core purpose of the function. While it is correct that the function iterates and removes timers, the addition of inaccurate processing/validation details undermines trust, resulting in severe misrepresentation."
            ]
        },
        "comment": {
            "summary": "Deletes all posix timers associated with the given signal structure by iterating through and removing each timer from the list.",
            "score": [
                1.0,
                0.5,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function deletes all POSIX timers tied to the provided signal structure by iterating through the list and removing each timer. This matches the source code, which uses a while loop to traverse sig->posix_timers, retrieves each timer with list_entry, and calls itimer_delete. The claim is specific, accurate, and aligned with the actual code behavior, with no inaccuracies present.",
                "The summary correctly identifies the function's core purpose: iterating through the given signal structure's POSIX timers and deleting them, matching the code\u2019s behavior. It covers the primary domain action with reasonable specificity but lacks additional details about the specific use of list operations, the `itimer_delete` function call, or edge case handling when the list is empty. This results in adequate coverage of the core with minimal secondary information.",
                "The summary makes a single specific claim about deleting all POSIX timers associated with a given signal structure by iterating through and removing each from the list. This is fully accurate per the source code: the function loops while the posix_timers list is not empty, retrieves each timer, and calls itimer_delete. There are no inaccurate or noisy claims, and the description captures the primary purpose and core side effect precisely, providing clear, high-value insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584527008,
    "strip_function_name": "sub_FFFFFFFF8156B2A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8156B2A0(\n        _QWORD *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // r12\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  unsigned __int64 v19; // rdi\n  unsigned int v20; // ebx\n  _QWORD *v22; // rax\n  __int64 *v23; // rdx\n\n  sub_FFFFFFFF8178FDC0(qword_FFFFFFFF81C80920);\n  v11 = a1 + 46;\n  sub_FFFFFFFF817926F0(&dword_FFFFFFFF81C80940);\n  if ( (_QWORD *)a1[50] == a1 + 46 )\n  {\n    v20 = -114;\n  }\n  else\n  {\n    v17 = (_QWORD *)a1[45];\n    v18 = a1[44];\n    *(_QWORD *)(v18 + 8) = v17;\n    *v17 = v18;\n    a1[44] = 0xDEAD000000000100LL;\n    a1[45] = 0xDEAD000000000200LL;\n    --*(_DWORD *)(a1[50] + 24LL);\n    v19 = a1[50];\n    if ( *(_DWORD *)(v19 + 24) == 1 )\n    {\n      v22 = *(_QWORD **)(v19 + 8);\n      v23 = (__int64 *)(v19 + 8);\n      if ( v22 != (_QWORD *)(v19 + 8) )\n      {\n        v22[4] = v22;\n        v22[3] = v22;\n        v22[6] = v22 + 2;\n        v23 = v22 + 3;\n        *v22 = v22 + 3;\n        v22[1] = v22 + 3;\n        v19 = a1[50];\n      }\n      sub_FFFFFFFF8112DCD0(v19, a3, a4, a5, a6, v15, v16, a9, a10, a2, v23, v12, v13, v14);\n    }\n    a1[50] = v11;\n    a1[48] = a1 + 44;\n    a1[44] = a1 + 47;\n    a1[45] = a1 + 47;\n    a1[47] = a1 + 44;\n    v20 = 0;\n  }\n  _InterlockedAdd(&dword_FFFFFFFF81C80940, 0x100000u);\n  _enable();\n  sub_FFFFFFFF810644C0(qword_FFFFFFFF81C80920);\n  return v20;\n}\n",
    "function_name": "snd_pcm_unlink",
    "decompiled_code": "__int64 __fastcall snd_pcm_unlink(\n        _QWORD *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // r12\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rdi\n  unsigned int v17; // ebx\n  _QWORD *v19; // rax\n  __int64 *v20; // rdx\n\n  down_write(snd_pcm_link_rwsem);\n  v11 = a1 + 46;\n  raw_write_lock_irq(&snd_pcm_link_rwlock);\n  if ( (_QWORD *)a1[50] == a1 + 46 )\n  {\n    v17 = -114;\n  }\n  else\n  {\n    v14 = (_QWORD *)a1[45];\n    v15 = a1[44];\n    *(_QWORD *)(v15 + 8) = v14;\n    *v14 = v15;\n    a1[44] = 0xDEAD000000000100LL;\n    a1[45] = 0xDEAD000000000200LL;\n    --*(_DWORD *)(a1[50] + 24LL);\n    v16 = a1[50];\n    if ( *(_DWORD *)(v16 + 24) == 1 )\n    {\n      v19 = *(_QWORD **)(v16 + 8);\n      v20 = (__int64 *)(v16 + 8);\n      if ( v19 != (_QWORD *)(v16 + 8) )\n      {\n        v19[4] = v19;\n        v19[3] = v19;\n        v19[6] = v19 + 2;\n        v20 = v19 + 3;\n        *v19 = v19 + 3;\n        v19[1] = v19 + 3;\n        v16 = a1[50];\n      }\n      kfree((__int64 *)v16, a3, a4, a5, a6, v12, v13, a9, a10, a2, v20);\n    }\n    a1[50] = v11;\n    a1[48] = a1 + 44;\n    a1[44] = a1 + 47;\n    a1[45] = a1 + 47;\n    a1[47] = a1 + 44;\n    v17 = 0;\n  }\n  _InterlockedAdd(&snd_pcm_link_rwlock, 0x100000u);\n  _enable();\n  up_write(snd_pcm_link_rwsem, a2);\n  return v17;\n}\n",
    "source_code": "\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_substream *s;\n\tint res = 0;\n\n\tdown_write(&snd_pcm_link_rwsem);\n\twrite_lock_irq(&snd_pcm_link_rwlock);\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\tlist_del(&substream->link_list);\n\tsubstream->group->count--;\n\tif (substream->group->count == 1) {\t/* detach the last stream, too */\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\trelink_to_local(s);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(substream->group);\n\t}\n\trelink_to_local(substream);\n       _end:\n\twrite_unlock_irq(&snd_pcm_link_rwlock);\n\tup_write(&snd_pcm_link_rwsem);\n\treturn res;\n}",
    "comment": "Unlinks a PCM substream from its group and releases resources if it was the last linked stream in the group.",
    "hext5_sum": "p^1_{-1/2 + i lambda}",
    "bint5_sum": "Unregisters a PCM substream , cleans up associated resources , and notifies subscribers about the substream 's unregistration .\n",
    "cpbcs_sum": "Registers an HDA codec by initializing its list and adding it to the list if it is not empty, while managing concurrency with a spin lock.\n",
    "misum_sum": "Unregisters a PCM device by removing it from the list and updating its card count and notifying the device's bus list.\n",
    "decom_sum": "Resets and reinitializes linked list node structures, updates counters, and invokes a processing routine when reference counts reach one.",
    "cfg_sum": "Updates linked list pointers, decrements reference counters, performs cleanup when last reference is released, and synchronizes state with atomic operations.",
    "work_score": {
        "decom": {
            "summary": "Resets and reinitializes linked list node structures, updates counters, and invokes a processing routine when reference counts reach one.",
            "score": [
                0.5,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes that counters are updated and an action occurs when the count reaches one, which matches the decrement of group->count and conditional handling in the code. However, it inaccurately describes 'resets and reinitializes linked list node structures' and 'invokes a processing routine' in generic terms without clearly reflecting the specific operations in the source, such as list_del, relink_to_local, or freeing the group. Overall, only part of the content precisely matches the code, with significant portions being vague or misleading.",
                "The summary fails to cover the core primary purpose, which is unlinking an ALSA PCM substream from its linked group while handling locking, reference count checks, and relinking streams to a local context. Although it mentions updating counters and invoking a routine when counts reach one, it incorrectly generalizes the operation as resetting/reinitializing linked list nodes, omitting critical domain specifics such as the audio substream unlink semantics, lock usage, error handling (-EALREADY), and freeing the group memory. Coverage of secondary behaviors like locks, error branch, and kfree is absent.",
                "The summary captures some elements of the code, such as updating counters and invoking a routine when a counter reaches one. However, it inaccurately describes the action as \"resets and reinitializes linked list node structures,\" which does not match the source code's unlinking of a PCM substream from a group and relinking streams locally. This misrepresentation targets core behavior (unlinking rather than resetting/reinitializing) and constitutes a severe factual error about the primary purpose. The inaccurate claim overshadows any accurate details, resulting in very low trustworthiness."
            ]
        },
        "cfg": {
            "summary": "Updates linked list pointers, decrements reference counters, performs cleanup when last reference is released, and synchronizes state with atomic operations.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly notes linked list pointer updates and decrementing counters, which are evident from list_del and count--. Cleanup when the last reference is released is accurately described via kfree of the group when count==1 and relinking to local. However, the claim about synchronizing state with atomic operations is misleading: the code uses read/write locks, not atomic operations. Overall, most claims align with the source, but there is one notable inaccuracy.",
                "The summary mentions linked list updates, counter decrements, and cleanup on last reference, which are accurate reflections of the source code\u2019s behavior. It also notes synchronization, though the term 'atomic operations' is not precise since the code uses rwlocks and semaphores. However, the core purpose\u2014unlinking an ALSA PCM substream from its group and relinking it to local context\u2014is missing, meaning the domain-specific action is not covered. Secondary details are partially present but incomplete, with no mention of error handling (-EALREADY) or relinking logic specifics.",
                "The summary captures some accurate, generic aspects: it updates linked list pointers and performs cleanup when last reference is released, which aligns with list_del, group count decrement, and kfree in the code. However, it incorrectly states that reference counters are decremented \u2014 the code decrements a stream group count, not a general reference counter \u2014 and mentions synchronizing with atomic operations, which is misleading since the code uses locking primitives rather than atomic ops. These inaccuracies are noise but not fatal to core function understanding, and the gain from accurate claims is low due to their generic nature."
            ]
        },
        "comment": {
            "summary": "Unlinks a PCM substream from its group and releases resources if it was the last linked stream in the group.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function unlinks a PCM substream from its group and frees resources when it is the last linked stream, which matches the code logic of removing the substream from the list, decrementing the group count, and freeing the group when count reaches one. It omits mention of the locking mechanism and early return when already unlinked, but the included claims are accurate and reflect the core semantics of the function.",
                "The summary correctly states the core action of unlinking a PCM substream from its group and freeing resources when it is the last stream, which aligns with the source code's primary purpose. However, it omits key secondary details such as checking if the stream is already unlinked with an -EALREADY error, the use of locking mechanisms to protect operations, the decrementation of the group's count, the conditional relinking of other streams to local, and the invocation of relink_to_local after unlinking. These omissions result in incomplete coverage of behavior-critical semantics.",
                "The summary accurately captures the primary purpose of the function: unlinking a PCM substream from its group and freeing the group's resources when it is the last linked stream. This aligns with the code, which removes the substream from the group's list, decrements the count, and frees the group when only one stream remains. There are no incorrect claims or noise, but the description is brief and lacks detail on locking mechanisms or error handling, providing only moderate informational value."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 435248,
    "strip_function_name": "sub_6A430",
    "strip_decompiled_code": "__int64 __fastcall sub_6A430(__int64 a1)\n{\n  unsigned __int64 v1; // rax\n  _QWORD *v3; // rax\n  void *v4; // rax\n\n  v1 = *(_QWORD *)(a1 + 592);\n  if ( v1 == 204 || v1 == 304 || v1 <= 0xC7 || *(_QWORD *)(a1 + 1072) != a1 || *(_QWORD *)(a1 + 920) == 4LL )\n    return qword_2D6490();\n  if ( *(_QWORD *)(a1 + 856) != -1LL )\n  {\n    if ( (*(_BYTE *)(a1 + 1249) & 0x10) == 0\n      || *(_QWORD *)(a1 + 928) <= 0x3E8uLL\n      || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * ngx_http_core_module) + 520LL) )\n    {\n      return qword_2D6490();\n    }\nLABEL_13:\n    v3 = *(_QWORD **)(a1 + 632);\n    *(_QWORD *)(a1 + 856) = -1LL;\n    if ( v3 )\n    {\n      *v3 = 0LL;\n      *(_QWORD *)(a1 + 632) = 0LL;\n    }\n    goto LABEL_15;\n  }\n  if ( *(_QWORD *)(a1 + 928) <= 0x3E8uLL\n    || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * ngx_http_core_module) + 520LL) )\n  {\n    *(_BYTE *)(a1 + 1249) &= ~0x20u;\n    return qword_2D6490();\n  }\n  if ( (*(_BYTE *)(a1 + 1249) & 0x10) != 0 )\n    goto LABEL_13;\nLABEL_15:\n  *(_BYTE *)(a1 + 1249) |= 4u;\n  v4 = ngx_pcalloc(*(_QWORD **)(a1 + 88), 0x10uLL);\n  if ( v4 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * ngx_http_chunked_filter_module) = v4;\n    return qword_2D6490();\n  }\n  return -1LL;\n}\n",
    "function_name": "ngx_http_chunked_header_filter",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n  ngx_uint_t status; // rax\n  ngx_table_elt_t *content_length; // rax\n  void *v4; // rax\n\n  status = r->headers_out.status;\n  if ( status == 204 || status == 304 || status <= 0xC7 || r->main != r || r->method == 4 )\n    return ngx_http_next_header_filter(r);\n  if ( r->headers_out.content_length_n == -1 )\n  {\n    if ( r->http_version <= 0x3E8 || !*((_QWORD *)r->loc_conf[ngx_http_core_module.ctx_index] + 65) )\n    {\n      *((_BYTE *)r + 1249) &= ~0x20u;\n      return ngx_http_next_header_filter(r);\n    }\n    if ( (*((_BYTE *)r + 1249) & 0x10) == 0 )\n      goto LABEL_16;\n  }\n  else if ( (*((_BYTE *)r + 1249) & 0x10) == 0\n         || r->http_version <= 0x3E8\n         || !*((_QWORD *)r->loc_conf[ngx_http_core_module.ctx_index] + 65) )\n  {\n    return ngx_http_next_header_filter(r);\n  }\n  content_length = r->headers_out.content_length;\n  r->headers_out.content_length_n = -1LL;\n  if ( content_length )\n  {\n    content_length->hash = 0LL;\n    r->headers_out.content_length = 0LL;\n  }\nLABEL_16:\n  *((_BYTE *)r + 1249) |= 4u;\n  v4 = ngx_pcalloc(r->pool, 0x10uLL);\n  if ( v4 )\n  {\n    r->ctx[ngx_http_chunked_filter_module.ctx_index] = v4;\n    return ngx_http_next_header_filter(r);\n  }\n  return -1LL;\n}\n",
    "source_code": "\n\nstatic ngx_int_t\nngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n    ngx_http_core_loc_conf_t       *clcf;\n    ngx_http_chunked_filter_ctx_t  *ctx;\n\n    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_out.content_length_n == -1\n        || r->expect_trailers)\n    {\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n\n        } else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }\n    }\n\n    return ngx_http_next_header_filter(r);\n}",
    "comment": "The function processes HTTP responses to enable chunked transfer encoding when conditions regarding content length and HTTP version are met.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Processes the HTTP response status , handling errors , retries , redirections , and managing memory for the response buffer .\n",
    "cpbcs_sum": "Processes HTTP requests by determining the request body counts, linking them to the output if certain conditions are met.\n",
    "misum_sum": "Processes and sends HTTP response data for an HTTP request, ensuring proper handling of checksum and headers before executing the core phase handler.\n",
    "decom_sum": "Initializes the HTTP chunked filter module for eligible requests, resetting related state and allocating its context before continuing normal processing.",
    "cfg_sum": "Validates HTTP request state and conditions, resets or updates module pointers, and allocates chunked filter context before returning a status code.",
    "work_score": {
        "decom": {
            "summary": "Initializes the HTTP chunked filter module for eligible requests, resetting related state and allocating its context before continuing normal processing.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function initializes the HTTP chunked filter module for eligible requests and allocates its context before continuing processing, which matches the source code\u2019s behavior of setting `r->chunked`, creating a filter context, and invoking the next header filter. However, it omits specific conditional criteria (status checks, HTTP version, chunked_transfer_encoding flag) and slightly generalizes actions like 'resetting related state,' which is only partially evident from `ngx_http_clear_content_length`. Despite these omissions, most of the stated behavior aligns with the function\u2019s actual semantics.",
                "The summary accurately notes initialization of the HTTP chunked filter and allocation of its context. However, it does not specify the core conditional behavior \u2014 applying chunked transfer encoding only under certain HTTP version, status, content length, and trailer expectations \u2014 which is the primary purpose. It omits eligibility details based on status codes, methods, and headers, and fails to mention critical side effects like clearing the content length for trailers or disabling keepalive without a known length. Overall, coverage of the core purpose is missing and secondary behaviors are only generically described.",
                "The summary correctly states that the function initializes the chunked filter module for eligible requests and allocates context before continuing, which matches the code\u2019s allocation of a filter context and setting r->chunked. However, it omits key eligibility conditions such as specific HTTP status codes, HEAD method, HTTP version requirements, and trailer handling, and includes a vague claim about 'resetting related state' that is not clearly evidenced in the code. There are no outright contradictory claims (no FATAL), but the explanation is broad and lacks specific GOLD details, resulting in low informational gain."
            ]
        },
        "cfg": {
            "summary": "Validates HTTP request state and conditions, resets or updates module pointers, and allocates chunked filter context before returning a status code.",
            "score": [
                0.5,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly generic statements that only partially align with the function\u2019s actual behavior. While it correctly notes that HTTP request state and conditions are validated, and that a chunked filter context is allocated, it inaccurately describes 'resets or updates module pointers' without clear basis in the source code, and omits key specifics such as when chunked mode is enabled, conditions for clearing content length, or disabling keepalive. The coverage of accurate, verifiable claims is moderate but incomplete.",
                "The summary does not accurately capture the core purpose of the function, which is to determine whether to enable HTTP/1.1 chunked transfer encoding for the response under specific conditions based on status codes, content length, trailers expectation, HTTP version, and configuration. It uses vague terms like 'validates HTTP request state' and 'resets or updates module pointers' without specifying chunked transfer encoding, and incorrectly generalizes actions as 'before returning a status code' when the function is passing processing to the next header filter. Key branches, conditions, and effects (like disabling keepalive) are omitted or misrepresented, resulting in failure to cover the core purpose and most critical semantics.",
                "The summary contains mostly generic statements that do not capture the specific core behavior of the function. It inaccurately describes the primary purpose by mentioning 'validates HTTP request state' and 'resets or updates module pointers' without clearly stating the key logic: determining if chunked transfer encoding should be enabled based on HTTP status, method, and content length, and conditionally clearing content length or disabling keepalive. The phrase 'returns a status code' is misleading, as it always calls the next header filter or returns NGX_ERROR only on allocation failure. This is a NOISE-dominated summary with very low specificity, providing negligible actionable detail for an engineer."
            ]
        },
        "comment": {
            "summary": "The function processes HTTP responses to enable chunked transfer encoding when conditions regarding content length and HTTP version are met.",
            "score": [
                0.6,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function processes HTTP responses to enable chunked transfer encoding based on certain conditions related to content length and HTTP version, which matches the source code's core behavior. However, it omits important conditional logic, such as specific status codes (e.g., NOT_MODIFIED, NO_CONTENT), request type checks, handling of trailers, and the behavior for non-chunked responses without content length. This makes the claim somewhat accurate but incomplete, yielding mixed reliability.",
                "The summary accurately notes that the function enables chunked transfer encoding based on content length and HTTP version, which aligns with the core behavior in the code. However, it omits critical conditions like specific HTTP status codes, request method exclusions, handling of trailers, allocation of filter context, and keepalive disabling when length is unknown without chunking. These omissions mean secondary coverage is very weak despite core being present.",
                "The summary accurately describes that the function enables chunked transfer encoding under certain conditions related to content length and HTTP version, which matches the source code\u2019s main behavior. However, it omits important specifics such as exclusion criteria for certain HTTP statuses and methods, the handling of trailers, and modifications to keepalive when chunked encoding is not used. These omissions limit detail and utility, but there is no contradictory or irrelevant noise, resulting in modest gain from one accurate but broad claim."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4997088,
    "strip_function_name": "sub_4C3FE0",
    "strip_decompiled_code": "__int64 __fastcall sub_4C3FE0(__int64 a1, const char *a2, _DWORD *a3, char a4)\n{\n  int v5; // ecx\n  unsigned int v6; // ebp\n  int v7; // ebx\n  __int64 v8; // rsi\n  signed __int64 v9; // rax\n  bool v10; // zf\n  __off_t v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // [rsp+8h] [rbp-C0h] BYREF\n  struct stat stat_buf; // [rsp+10h] [rbp-B8h] BYREF\n\n  v5 = a4 & 1;\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = sub_4AE520(*(_QWORD *)(a1 + 8), a2, &v14, &stat_buf, 0);\n    if ( v7 >= 0 )\n    {\n      v8 = v14;\n      v9 = stat_buf.st_dev + 4094;\n      if ( (signed __int64)(stat_buf.st_dev + 2047) >= 0 )\n        v9 = stat_buf.st_dev + 2047;\n      *a3 = v9 >> 11;\n      v7 = sub_4AF430(a1, v8);\n      sub_4AE4A0((void **)&v14);\n      v10 = v7 == 0;\n      if ( v7 >= 0 )\n      {\n        v7 = 2;\n        if ( v10 )\n          return v6;\n      }\n    }\n    return (unsigned int)v7;\n  }\n  *a3 = 0;\n  if ( __xstat(1, a2, &stat_buf) == -1 || (stat_buf.st_mode & 0xF000) != 0x8000 )\n    return (unsigned int)-399442290;\n  v12 = stat_buf.st_size + 4094;\n  if ( stat_buf.st_size + 2047 >= 0 )\n    v12 = stat_buf.st_size + 2047;\n  v13 = v12 >> 11;\n  if ( v13 > 0x3FFFFFFF || !v13 )\n    return (unsigned int)-399442290;\n  *a3 = v13;\n  return 1LL;\n}\n",
    "function_name": "compute_partition_size",
    "decompiled_code": "__int64 __fastcall compute_partition_size(Ecma119Image *a1, char *disk_path, _DWORD *a3, char flag)\n{\n  int v5; // ecx\n  unsigned int v6; // ebp\n  int v7; // ebx\n  iso_interval_reader *v8; // rsi\n  off_t v9; // rax\n  bool v10; // zf\n  __int64 v12; // rax\n  __int64 v13; // rax\n  iso_interval_reader *ivr; // [rsp+8h] [rbp-C0h] BYREF\n  off_t byte_count[3]; // [rsp+10h] [rbp-B8h] BYREF\n  int v16; // [rsp+28h] [rbp-A0h]\n  __int64 v17; // [rsp+40h] [rbp-88h]\n\n  v5 = flag & 1;\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = iso_interval_reader_new(a1->image, disk_path, &ivr, byte_count, 0);\n    if ( v7 >= 0 )\n    {\n      v8 = ivr;\n      v9 = byte_count[0] + 4094;\n      if ( byte_count[0] + 2047 >= 0 )\n        v9 = byte_count[0] + 2047;\n      *a3 = v9 >> 11;\n      v7 = iso_interval_reader_keep(a1, v8, 0);\n      iso_interval_reader_destroy(&ivr, 0);\n      v10 = v7 == 0;\n      if ( v7 >= 0 )\n      {\n        v7 = 2;\n        if ( v10 )\n          return v6;\n      }\n    }\n    return (unsigned int)v7;\n  }\n  *a3 = 0;\n  if ( __xstat(1, disk_path, (struct stat *)byte_count) == -1 || (v16 & 0xF000) != 0x8000 )\n    return (unsigned int)-399442290;\n  v12 = v17 + 4094;\n  if ( v17 + 2047 >= 0 )\n    v12 = v17 + 2047;\n  v13 = v12 >> 11;\n  if ( v13 > 0x3FFFFFFF || !v13 )\n    return (unsigned int)-399442290;\n  *a3 = v13;\n  return 1LL;\n}\n",
    "source_code": "static int compute_partition_size(Ecma119Image *t, char *disk_path,\n                                  uint32_t *size, int flag)\n{\n    int ret, keep;\n    off_t num;\n    struct stat stbuf;\n    struct iso_interval_reader *ivr;\n    off_t byte_count;\n\n    if (flag & 1) {\n        ret = iso_interval_reader_new(t->image, disk_path,\n                                      &ivr, &byte_count, 0);\n        if (ret < 0)\n            return ret;\n        *size = (byte_count + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        keep = iso_interval_reader_keep(t, ivr, 0);\n        iso_interval_reader_destroy(&ivr, 0);\n        if (keep < 0)\n            return keep;\n        return ISO_SUCCESS + (keep > 0);\n    }\n\n    *size = 0;\n    ret = stat(disk_path, &stbuf);\n    if (ret == -1)\n        return ISO_BAD_PARTITION_FILE;\n    if (! S_ISREG(stbuf.st_mode))\n        return ISO_BAD_PARTITION_FILE;\n    num = ((stbuf.st_size + 2047) / 2048);\n    if (num > 0x3fffffff || num == 0)\n        return ISO_BAD_PARTITION_FILE;\n    *size = num;\n    return ISO_SUCCESS;\n}",
    "comment": "Calculates the partition size from a disk path or an image based on a specified flag, ensuring valid file attributes and conditions.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the size of a file or directory from an ISO image , adjusting for potential overflows based on specified flags .\n",
    "cpbcs_sum": "Writes a null-terminated string to a binary file, checks for write errors, and retrieves the buffer length if successful.\n",
    "misum_sum": "Retrieves file status information, populates a buffer, and returns success or failure based on the provided flag code.\n",
    "decom_sum": "Determines file size in 2\u202fKB blocks for regular files or via custom handler when flagged, returning error for non-regular types or invalid sizes.",
    "cfg_sum": "Determines a file\u2019s block count from its path, validating type and size, and optionally processing it via directory-based routines before returning a status code.",
    "work_score": {
        "decom": {
            "summary": "Determines file size in 2\u202fKB blocks for regular files or via custom handler when flagged, returning error for non-regular types or invalid sizes.",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly captures key behavior: calculation of size in 2 KB blocks for regular files, use of a custom handler when the flag is set, and returning errors for non-regular files or invalid sizes. All claims align with the source code's semantics and there are no contradictory or irrelevant statements, indicating high accuracy.",
                "The summary correctly captures the core purpose of computing partition size from either a regular file in 2\u202fKB blocks or via a custom handler when a flag is set, and notes error handling for non-regular files or invalid sizes. This matches the source code\u2019s logic, including the flag branch using iso_interval_reader and the non-flag branch performing size validation. However, it omits secondary details such as the specific constants used (BLOCK_SIZE, ISO_SUCCESS, ISO_BAD_PARTITION_FILE), the rounding method, and the keep check from iso_interval_reader_keep, thus coverage of secondary behavior is limited.",
                "The summary correctly reflects the core logic: it describes the two code paths\u2014calculating size in 2\u202fKB blocks for regular files and using a custom handler when the flag is set\u2014plus returning errors for non-regular files or invalid sizes. These are accurate, specific statements that match the source code\u2019s semantics. There is no contradictory or irrelevant (NOISE) content, and no FATAL inaccuracies. The claims are fairly specific, giving useful insight into the function\u2019s input handling and computation without excessive generality."
            ]
        },
        "cfg": {
            "summary": "Determines a file\u2019s block count from its path, validating type and size, and optionally processing it via directory-based routines before returning a status code.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function determines a file's block count from its path and validates type and size, which matches the code\u2019s `stat` call, `S_ISREG` check, and size computation. It also notes the optional processing via different routines before returning a status code, aligning with the `flag & 1` branch invoking `iso_interval_reader_*` functions. However, the phrase 'directory-based routines' is inaccurate since the optional processing is not directory-specific, and the summary omits key constants and detailed error return conditions. Despite this minor imprecision, most claims reflect the source code semantics accurately.",
                "The summary covers the core purpose of computing a partition size by determining a file\u2019s block count from its path and includes validation of type and size, which matches the source code\u2019s stat calls and checks. It also acknowledges the optional processing path when a flag is set, though it incorrectly describes it as 'directory-based routines' rather than using the specific iso_interval_reader logic from the code. Secondary details such as handling error return codes, specific block size calculations, and byte-to-block rounding are omitted, leading to incomplete coverage of critical branches and constants.",
                "The summary correctly states that the function calculates a file\u2019s block count from its path and validates its type and size, which matches the code\u2019s logic for both flag and non-flag paths. However, it inaccurately describes the optional processing as using 'directory-based routines'; in reality, the flag path uses iso_interval_reader functions to handle ISO interval data rather than any directory operations. This is a minor semantic mismatch but not a severe contradiction of the primary purpose. Most of the content is accurate but somewhat generic, with limited detail on constants, thresholds, or specific cases, so the informational gain is modest."
            ]
        },
        "comment": {
            "summary": "Calculates the partition size from a disk path or an image based on a specified flag, ensuring valid file attributes and conditions.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function calculates a partition size from either a disk path or an image depending on the flag, and that it checks for valid file attributes and conditions. These points align with the code's use of the flag to choose between iso_interval_reader logic and file-based stat checks, as well as various validation steps. However, the summary is generic and omits specific details such as block size calculation, handling of error codes, and exact validation constraints. Despite this, all claims present are accurate, resulting in a high proportion of precise statements.",
                "The summary correctly identifies that the function calculates a partition size using either a disk path or image depending on a flag, which matches the core purpose. However, it omits several critical secondary semantics present in the code, such as using `iso_interval_reader` to obtain byte counts for the image path, rounding logic for block size, destruction of the reader, handling `keep` values to adjust return status, and multiple specific error conditions when validating file attributes and size ranges. These missing details limit completeness.",
                "The summary\u2019s claims are generally accurate but overly generic. It correctly notes that the function calculates a partition size from a disk path or image based on a flag and enforces validity checks, which aligns with the code\u2019s dual path logic (flag set uses iso_interval_reader; else uses stat and file checks). However, it omits all specific details about how the size is computed, the constants used, and the various error returns. No fatal inaccuracies are present, but the gain is low due to the lack of precise behavior and conditions. Noise is minimal."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 239376,
    "strip_function_name": "dtls1_get_timeout",
    "strip_decompiled_code": "_QWORD *__fastcall dtls1_get_timeout(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rax\n  __int64 v4; // rax\n  __time_t tv_sec; // rcx\n  __suseconds_t tv_usec; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __time_t v9; // rdx\n  __int64 v10; // rax\n  _QWORD *result; // rax\n  __time_t v12; // rdx\n  struct timeval v13; // [rsp+0h] [rbp-28h] BYREF\n\n  v2 = *(_QWORD *)(a1 + 136);\n  if ( !*(_QWORD *)(v2 + 840) && !*(_QWORD *)(v2 + 848) )\n    return 0LL;\n  gettimeofday(&v13, 0LL);\n  v4 = *(_QWORD *)(a1 + 136);\n  tv_sec = v13.tv_sec;\n  if ( *(_QWORD *)(v4 + 840) < v13.tv_sec )\n    goto LABEL_10;\n  tv_usec = v13.tv_usec;\n  if ( *(_QWORD *)(v4 + 840) == v13.tv_sec && *(_QWORD *)(v4 + 848) <= v13.tv_usec )\n    goto LABEL_10;\n  v7 = *(_QWORD *)(v4 + 840);\n  *a2 = v7;\n  v8 = *(_QWORD *)(v4 + 848);\n  v9 = v7 - tv_sec;\n  *a2 = v9;\n  v10 = v8 - tv_usec;\n  a2[1] = v10;\n  if ( v10 < 0 )\n  {\n    v12 = v9 - 1;\n    a2[1] = v10 + 1000000;\n    *a2 = v12;\n    result = a2;\n    if ( v12 )\n      return result;\n  }\n  else\n  {\n    result = a2;\n    if ( v9 )\n      return result;\n  }\n  if ( (__int64)a2[1] <= 14999 )\n  {\nLABEL_10:\n    *a2 = 0LL;\n    a2[1] = 0LL;\n    return a2;\n  }\n  return result;\n}\n",
    "function_name": "dtls1_get_timeout",
    "decompiled_code": "_QWORD *__fastcall dtls1_get_timeout(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rax\n  __int64 v4; // rax\n  __time_t tv_sec; // rcx\n  __suseconds_t tv_usec; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __time_t v9; // rdx\n  __int64 v10; // rax\n  _QWORD *result; // rax\n  __time_t v12; // rdx\n  struct timeval v13; // [rsp+0h] [rbp-28h] BYREF\n\n  v2 = *(_QWORD *)(a1 + 136);\n  if ( !*(_QWORD *)(v2 + 840) && !*(_QWORD *)(v2 + 848) )\n    return 0LL;\n  gettimeofday(&v13, 0LL);\n  v4 = *(_QWORD *)(a1 + 136);\n  tv_sec = v13.tv_sec;\n  if ( *(_QWORD *)(v4 + 840) < v13.tv_sec )\n    goto LABEL_10;\n  tv_usec = v13.tv_usec;\n  if ( *(_QWORD *)(v4 + 840) == v13.tv_sec && *(_QWORD *)(v4 + 848) <= v13.tv_usec )\n    goto LABEL_10;\n  v7 = *(_QWORD *)(v4 + 840);\n  *a2 = v7;\n  v8 = *(_QWORD *)(v4 + 848);\n  v9 = v7 - tv_sec;\n  *a2 = v9;\n  v10 = v8 - tv_usec;\n  a2[1] = v10;\n  if ( v10 < 0 )\n  {\n    v12 = v9 - 1;\n    a2[1] = v10 + 1000000;\n    *a2 = v12;\n    result = a2;\n    if ( v12 )\n      return result;\n  }\n  else\n  {\n    result = a2;\n    if ( v9 )\n      return result;\n  }\n  if ( (__int64)a2[1] <= 14999 )\n  {\nLABEL_10:\n    *a2 = 0LL;\n    a2[1] = 0LL;\n    return a2;\n  }\n  return result;\n}\n",
    "source_code": "\nstruct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)\n\t{\n\tstruct timeval timenow;\n\n\t/* If no timeout is set, just return NULL */\n\tif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)\n\t\t{\n\t\treturn NULL;\n\t\t}\n\n\t/* Get current time */\n\tget_current_time(&timenow);\n\n\t/* If timer already expired, set remaining time to 0 */\n\tif (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\n\t\t(s->d1->next_timeout.tv_sec == timenow.tv_sec &&\n\t\t s->d1->next_timeout.tv_usec <= timenow.tv_usec))\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\treturn timeleft;\n\t\t}\n\n\t/* Calculate time left until timer expires */\n\tmemcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n\ttimeleft->tv_sec -= timenow.tv_sec;\n\ttimeleft->tv_usec -= timenow.tv_usec;\n\tif (timeleft->tv_usec < 0)\n\t\t{\n\t\ttimeleft->tv_sec--;\n\t\ttimeleft->tv_usec += 1000000;\n\t\t}\n\n\t/* If remaining time is less than 15 ms, set it to 0\n\t * to prevent issues because of small devergences with\n\t * socket timeouts.\n\t */\n\tif (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\t}\n\t\n\n\treturn timeleft;\n\t}",
    "comment": "Calculates the remaining timeout for a DTLS connection and returns a struct timeval with the time left until expiration.",
    "hext5_sum": "p series representation.",
    "bint5_sum": "Calculates and returns the timeout in milliseconds for DTLS connections , considering various connection states and timeouts .\n",
    "cpbcs_sum": "Retrieves the current time from a DTLS timeout duration or adjusts it if no progress is needed for future writing if necessary.\n",
    "misum_sum": "Initializes and retrieves a DTLS timeout duration for a task, adjusting timeout time based on current time and handling overflow conditions.\n",
    "decom_sum": "Calculates the remaining time until a DTLS handshake timeout and returns zero if the deadline has passed or is under 15 milliseconds.",
    "cfg_sum": "Calculates the remaining DTLS handshake timeout using current system time and resets it to zero if expired or below a minimum threshold.",
    "work_score": {
        "decom": {
            "summary": "Calculates the remaining time until a DTLS handshake timeout and returns zero if the deadline has passed or is under 15 milliseconds.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function calculates the remaining time until a DTLS handshake timeout and returns zero if the deadline has passed or is under 15 milliseconds, which matches the source code behavior. These are precise and accurate domain-semantic claims with no incorrect statements, leading to full alignment with the evaluation steps.",
                "The summary correctly captures the core purpose of computing the remaining time until a DTLS handshake timeout and notes the cases where zero is returned for expired deadlines or durations under 15 milliseconds. However, it omits other notable secondary behaviors from the code such as returning NULL when no timeout is set, the explicit retrieval of current time, and the detailed handling of negative microseconds adjustment. The coverage of secondary semantics is limited, reducing completeness.",
                "The summary accurately captures the primary purpose of the function: computing the remaining time until a DTLS timeout and returning zero if expired or under 15 milliseconds. No inaccurate or contradictory claims are present, and while the description is concise, it omits some specific implementation details (like handling of zero-initialized timeout fields and exact adjustment logic), making the gain moderate rather than high. Noise is minimal and the main behavior is correctly described."
            ]
        },
        "cfg": {
            "summary": "Calculates the remaining DTLS handshake timeout using current system time and resets it to zero if expired or below a minimum threshold.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function calculates the remaining DTLS handshake timeout using the current system time and that it resets the timeout to zero if it has expired or is below a minimum threshold. These points align closely with the source code\u2019s behavior, which includes both expiration checks and a minimum threshold of 15 ms. No inaccuracies or irrelevant statements are present, making the claim fully accurate.",
                "The summary accurately captures the core function purpose: computing the remaining DTLS handshake timeout based on current time and zeroing it if expired or below a threshold. It correctly notes the minimum threshold behavior and expiration handling. However, it omits several secondary details from the code, such as returning NULL when no timeout is set, the exact threshold value of 15 ms, and adjustments for negative microseconds. Thus the core coverage is strong but secondary detail coverage is incomplete.",
                "The summary accurately states the primary purpose of the function: it computes the remaining DTLS handshake timeout based on the current system time, and resets it to zero when expired or below a small threshold. The claim matches the source code\u2019s behavior with no contradictory statements or irrelevant noise. However, the level of detail is minimal, omitting specifics such as the exact threshold value (15 ms), handling of timeval structure adjustments, or the NULL return when no timeout is set, so informational gain is moderate rather than high."
            ]
        },
        "comment": {
            "summary": "Calculates the remaining timeout for a DTLS connection and returns a struct timeval with the time left until expiration.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function calculates the remaining timeout for a DTLS connection and returns a struct timeval with the time left until expiration. This matches the code logic: it checks if a timeout is set, gets the current time, computes the difference until next_timeout, and may adjust to zero. Although generic and omitting edge-case handling details, the claim is accurate with respect to the function\u2019s semantics.",
                "The summary correctly identifies that the function calculates the remaining timeout for a DTLS connection and returns a struct timeval, which covers the core purpose accurately. However, it omits important secondary semantics such as returning NULL when no timeout is set, handling expired timers by zeroing the timeval, adjusting microseconds when negative, and setting times under 15ms to zero to avoid socket timeout issues. These behaviors are critical for full understanding but not mentioned.",
                "The summary correctly identifies the function\u2019s main purpose: computing the remaining timeout for a DTLS connection and returning it as a struct timeval. This matches the code\u2019s core behavior, with no contradictions (no FATAL errors). However, the description is very generic and omits specific details such as handling of expired timers, calculation adjustments for microseconds, and the special case for timeouts under 15 ms. The gain is low because the summary provides only a broad overview without these implementation nuances, but noise is minimal."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5123408,
    "strip_function_name": "sub_4E2D50",
    "strip_decompiled_code": "__int64 __fastcall sub_4E2D50(__int64 a1, _QWORD *a2, int *a3, char a4)\n{\n  _QWORD *v5; // rax\n  _QWORD *v6; // rbp\n  unsigned int v7; // r15d\n  _DWORD *v8; // rax\n  _DWORD *v9; // rbx\n  int v10; // eax\n  unsigned __int8 *v12; // r12\n  int v13; // eax\n  void *v14; // rax\n\n  *a2 = 0LL;\n  v5 = sub_4E19C0(0x11008uLL, 1uLL);\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = -1;\n    v8 = sub_4E19C0(0xC8uLL, 1uLL);\n    v9 = v8;\n    if ( v8 )\n    {\n      sub_4F3790(v8, &unk_7716D8, 10LL);\n      v10 = *a3;\n      v9[40] = 1;\n      *((_QWORD *)v9 + 21) = v6;\n      v7 = 0;\n      v9[6] = v10;\n      *((_BYTE *)v9 + 7) = BYTE1(v10);\n      *((_BYTE *)v9 + 8) = v10;\n      v6[8704] = 0LL;\n      v9[5] = 1;\n      (*(void (__fastcall **)(__int64, _DWORD *))(a1 + 2072))(a1, v9);\n      if ( !v9[39] )\n      {\n        v12 = (unsigned __int8 *)*((_QWORD *)v9 + 21);\n        v13 = v12[1] + (*v12 << 8);\n        *a3 = v13 + 2;\n        if ( (a4 & 1) != 0 || v13 + 2 <= 21 )\n        {\n          v7 = 1;\n        }\n        else\n        {\n          v7 = -1;\n          v14 = sub_4E19C0(1uLL, v13 - 2);\n          *a2 = v14;\n          if ( v14 )\n          {\n            v7 = 1;\n            memcpy(v14, v12 + 4, *a3 - 4);\n          }\n        }\n      }\n      free(v9);\n    }\n    free(v6);\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n  return v7;\n}\n",
    "function_name": "mmc_get_leadin_text_al",
    "decompiled_code": "__int64 __fastcall mmc_get_leadin_text_al(__int64 a1, _QWORD *a2, int *a3, char flag)\n{\n  buffer *v5; // rax\n  buffer *v6; // rbp\n  unsigned int v7; // r15d\n  command *v8; // rax\n  command *v9; // rbx\n  int v10; // eax\n  buffer *page; // r12\n  int v13; // eax\n  void *v14; // rax\n\n  *a2 = 0LL;\n  v5 = (buffer *)burn_alloc_mem(0x11008uLL, 1uLL, 0);\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = -1;\n    v8 = (command *)burn_alloc_mem(0xC8uLL, 1uLL, 0);\n    v9 = v8;\n    if ( v8 )\n    {\n      scsi_init_command(v8, MMC_GET_LEADTEXT, 10);\n      v10 = *a3;\n      v9->retry = 1;\n      v9->page = v6;\n      v7 = 0;\n      v9->dxfer_len = v10;\n      v9->opcode[7] = BYTE1(v10);\n      v9->opcode[8] = v10;\n      *(_QWORD *)&v6->sectors = 0LL;\n      v9->dir = 1;\n      (*(void (__fastcall **)(__int64, command *))(a1 + 2072))(a1, v9);\n      if ( !v9->error )\n      {\n        page = v9->page;\n        v13 = page->data[1] + (page->data[0] << 8);\n        *a3 = v13 + 2;\n        if ( (flag & 1) != 0 || v13 + 2 <= 21 )\n        {\n          v7 = 1;\n        }\n        else\n        {\n          v7 = -1;\n          v14 = burn_alloc_mem(1uLL, v13 - 2, 0);\n          *a2 = v14;\n          if ( v14 )\n          {\n            v7 = 1;\n            memcpy(v14, &page->data[4], *a3 - 4);\n          }\n        }\n      }\n      free(v9);\n    }\n    free(v6);\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n  return v7;\n}\n",
    "source_code": "static int mmc_get_leadin_text_al(struct burn_drive *d,\n                                  unsigned char **text_packs, int *alloc_len,\n                                  int flag)\n{\n\tstruct buffer *buf = NULL;\n\tstruct command *c = NULL;\n\tunsigned char *data;\n\tint ret, data_length;\n\n\t*text_packs = NULL;\n\n\tBURN_ALLOC_MEM(buf, struct buffer, 1);\n\tBURN_ALLOC_MEM(c, struct command, 1);\n\n\tscsi_init_command(c, MMC_GET_LEADTEXT, sizeof(MMC_GET_LEADTEXT));\n\tc->dxfer_len = *alloc_len;\n\tc->opcode[7]= (c->dxfer_len >> 8) & 0xff;\n\tc->opcode[8]= c->dxfer_len & 0xff;\n\tc->retry = 1;\n\tc->page = buf;\n\tc->page->bytes = 0;\n\tc->page->sectors = 0;\n\n\tc->dir = FROM_DRIVE;\n\td->issue_command(d, c);\n\tif (c->error)\n\t\t{ret = 0; goto ex;}\n\n\tdata = c->page->data;\t\n\tdata_length = (data[0] << 8) + data[1];\n\t*alloc_len = data_length + 2;\n\tif (*alloc_len >= 22 && !(flag & 1)) {\n\t\tBURN_ALLOC_MEM(*text_packs, unsigned char, *alloc_len - 4);\n\t\tmemcpy(*text_packs, data + 4, *alloc_len - 4);\n\t}\n\tret = 1;\t\nex:;\n\tBURN_FREE_MEM(c);\n\tBURN_FREE_MEM(buf);\n\treturn ret;\n}",
    "comment": "Retrieves lead-in text from a drive and allocates memory for the text if the conditions are met, returning success or failure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reads a CD-TEXT pack from a burn drive , allocating memory for text packs and returning the pack size or an error code .\n",
    "cpbcs_sum": "Writes the track to a burn drive, initializes an object if necessary, and handles exclusive read errors.\n",
    "misum_sum": "Reads the contents of a burn drive, initializes a drive, and registers a media capacity if it's a local type.\n",
    "decom_sum": "Allocates buffers, sends a command to a device, retrieves its response, and copies returned payload data into a caller-provided location.",
    "cfg_sum": "Allocates and initializes data buffers, invokes a device-specific callback, reads returned data, and conditionally copies it to the output before freeing resources.",
    "work_score": {
        "decom": {
            "summary": "Allocates buffers, sends a command to a device, retrieves its response, and copies returned payload data into a caller-provided location.",
            "score": [
                0.8,
                0.2,
                0.5
            ],
            "reason": [
                "The summary accurately notes buffer allocation, command sending to a device, response retrieval, and payload copying, which all align with the function's code behavior. However, it omits certain specifics like conditional copying based on the flag, and that the copy destination is newly allocated rather than truly caller-provided. Overall, most claims match the source semantics with minor inaccuracies.",
                "The summary gives a generic description of buffer allocation, command sending, and data copying, but it misses the core purpose of retrieving lead-in text via the MMC_GET_LEADTEXT SCSI command from the drive. No accurate claim explicitly covers this domain-specific behavior, and it omits key secondary details like error handling, the data length calculation, the conditional allocation based on flag and size, and freeing memory resources.",
                "The summary correctly identifies buffer allocation, command sending, and data copying, which align with the source code's operations. However, it inaccurately states that data is copied into a 'caller-provided location' \u2014 in reality, the function allocates memory for *text_packs internally rather than writing into an existing buffer from the caller. There is no fatal error about the primary purpose; the inaccuracy is moderate and introduces some noise. The accuracy is mostly generic and low-info, with limited specificity about command parameters, error handling, or allocation conditions."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes data buffers, invokes a device-specific callback, reads returned data, and conditionally copies it to the output before freeing resources.",
            "score": [
                0.9,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function allocates and initializes buffers, calls a device-specific command via a callback, processes returned data, conditionally copies part of it to an output buffer, and frees resources. These details align with the source code\u2019s flow and semantics, with no contradictory or irrelevant claims present, indicating high accuracy.",
                "The summary correctly notes buffer allocation, device callback invocation, reading returned data, conditional copying, and resource freeing, which are all accurate generic behaviors present in the code. However, it fails to capture the core domain-specific purpose of issuing the MMC_GET_LEADTEXT SCSI command to retrieve disc lead-in text. Without this specific action, the core functionality is not covered, and the secondary details provided remain high-level and generic.",
                "The summary correctly captures the overall sequence of operations: memory allocation, initialization, command invocation, reading data, conditional copying, and cleanup, which matches the source code\u2019s logic. However, it is entirely generic and lacks domain-specific details about MMC lead-in text retrieval, SCSI command setup, or the conditional logic involving allocation length and flags. There are no inaccuracies or contradictions, but the gain is low because the description does not provide specific insights beyond a broad outline."
            ]
        },
        "comment": {
            "summary": "Retrieves lead-in text from a drive and allocates memory for the text if the conditions are met, returning success or failure.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly captures the main function behavior: retrieving lead-in text from a drive, allocating memory conditionally, and returning a success/failure indicator. These claims align with the source code, which issues a SCSI MMC_GET_LEADTEXT command, processes data length, conditionally allocates memory for text packs when certain conditions are met, and returns an integer status. No contradictory or irrelevant claims are present.",
                "The summary accurately states that the function retrieves lead-in text from a drive and conditionally allocates memory, which matches the core purpose of issuing the MMC_GET_LEADTEXT command and returning success or failure. However, it omits key secondary details such as the use of SCSI command initialization, calculation of data length, adjustment of alloc_len, the specific flag-based condition, and memory cleanup. Coverage of the core is present, but secondary behavior-critical semantics are minimal.",
                "The summary correctly identifies that the function retrieves lead-in text from a drive and conditionally allocates memory before returning a success or failure indicator. These claims match the source code\u2019s primary purpose and logic flow, with no contradictions or irrelevant noise. However, the summary is generic and omits important specifics such as the role of `alloc_len`, the detailed condition (minimum length and flag check), and the use of SCSI commands, resulting in low informational gain despite accurate coverage of the core behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580241712,
    "strip_function_name": "sub_FFFFFFFF81154F30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81154F30(\n        __int64 a1,\n        __int64 a2,\n        int a3,\n        int a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  _DWORD *v14; // r12\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n  int v19; // edx\n  int v20; // ecx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 result; // rax\n  _DWORD *v26; // rax\n  __int64 *v27; // [rsp+0h] [rbp-28h] BYREF\n  _DWORD *v28; // [rsp+8h] [rbp-20h]\n\n  v14 = *(_DWORD **)(__readgsqword(0xA7C0u) + 1328);\n  if ( !(unsigned __int8)sub_FFFFFFFF81047700(*(_QWORD *)(a2 + 32), 0x15u, a3, a4, a5, a6)\n    || !(unsigned __int8)sub_FFFFFFFF81047B40(0x12u, 21LL, v15, v16, v17, v18)\n    || !(unsigned __int8)sub_FFFFFFFF81047B40(0x15u, 21LL, v19, v20, v21, v22) )\n  {\n    return 0xFFFFFFFFLL;\n  }\n  result = 4294967274LL;\n  if ( *v14 == 1 )\n  {\n    _InterlockedIncrement((volatile signed __int32 *)a2);\n    sub_FFFFFFFF81154B30(*(_QWORD *)(a1 + 24), a7, a8, a9, a10, v23, v24, a13, a14);\n    *(_QWORD *)(a1 + 24) = a2;\n    v26 = *(_DWORD **)(*(_QWORD *)(a2 + 8) + 32LL);\n    v27 = (__int64 *)(*(_QWORD *)(a2 + 8) + 32LL);\n    v28 = v26;\n    sub_FFFFFFFF8113F300(&v27);\n    while ( (*v28 & 0x10000) != 0 && (unsigned int)sub_FFFFFFFF8113E1B0(&v27) )\n      ;\n    sub_FFFFFFFF81162700(v14, &v27);\n    sub_FFFFFFFF81162690(v14, &v27);\n    sub_FFFFFFFF8113E0F0(&v27);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "mntns_install",
    "decompiled_code": "__int64 __fastcall mntns_install(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _DWORD *v10; // r12\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 result; // rax\n  _DWORD *v18; // rax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // [rsp+0h] [rbp-28h] BYREF\n  _DWORD *v24; // [rsp+8h] [rbp-20h]\n\n  v10 = *(_DWORD **)(__readgsqword(0xA7C0u) + 1328);\n  if ( !(unsigned __int8)ns_capable(*(_QWORD *)(a2 + 32), 0x15u, a3, a4, a5, a6, a7, a8, a9, a10)\n    || !(unsigned __int8)nsown_capable(0x12u, a3, a4, a5, a6, v11, v12, a9, a10)\n    || !(unsigned __int8)nsown_capable(0x15u, a3, a4, a5, a6, v13, v14, a9, a10) )\n  {\n    return 0xFFFFFFFFLL;\n  }\n  result = 4294967274LL;\n  if ( *v10 == 1 )\n  {\n    _InterlockedIncrement((volatile signed __int32 *)a2);\n    put_mnt_ns(*(_QWORD *)(a1 + 24), a3, a4, a5, a6, v15, v16, a9, a10);\n    *(_QWORD *)(a1 + 24) = a2;\n    v18 = *(_DWORD **)(*(_QWORD *)(a2 + 8) + 32LL);\n    v23 = (__int64 *)(*(_QWORD *)(a2 + 8) + 32LL);\n    v24 = v18;\n    path_get((__int64 *)&v23);\n    while ( (*v24 & 0x10000) != 0\n         && (unsigned int)follow_down_one(\n                            &v23,\n                            (volatile signed __int32 *)((char *)&qword_10 + 5),\n                            a3,\n                            a4,\n                            a5,\n                            a6,\n                            v19,\n                            v20,\n                            a9,\n                            a10) )\n      ;\n    set_fs_pwd((__int64)v10, (__int64 *)&v23);\n    set_fs_root((__int64)v10, (__int64 *)&v23);\n    path_put((__int64 *)&v23, (volatile signed __int32 *)&v23, a3, a4, a5, a6, v21, v22, a9, a10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int mntns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = ns;\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !nsown_capable(CAP_SYS_CHROOT) ||\n\t    !nsown_capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}",
    "comment": "Validates permissions, checks filesystem usage, updates the mount namespace in the nsproxy, and sets the current process's root and working directory.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Creates a new file in the specified directory with given flags , ensuring security checks and notifying the filesystem of the creation event .\n",
    "cpbcs_sum": "Converts a process to a file descriptor in a directory, ensuring only processes if the namespace is valid.\n",
    "misum_sum": "Adds a new mount to a process if the current time is in the user namespace and the user has a valid mount context.\n",
    "decom_sum": "Validates command parameters, updates a linked object reference, and processes its associated data through synchronized handler routines if execution conditions are met.",
    "cfg_sum": "Validates multiple input parameters, updates a linked data reference, processes associated flags through helper routines, and returns specific error codes or success status.",
    "work_score": {
        "decom": {
            "summary": "Validates command parameters, updates a linked object reference, and processes its associated data through synchronized handler routines if execution conditions are met.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary is overly generic and does not align closely with the specific domain semantics of the source code. It uses vague terms like 'command parameters', 'linked object reference', and 'synchronized handler routines', which do not accurately represent the permission checks, namespace updates, and filesystem root/path handling in the function. Almost none of the claims are precise or directly verifiable against the actual implementation, resulting in a very low proportion of accurate claims.",
                "The summary fails to clearly identify the core purpose of setting the mount namespace in nsproxy and updating the process's root and working directory. Instead, it uses vague and generic terms like 'linked object reference' and 'synchronized handler routines,' which do not accurately reflect the specific domain semantics in the source code. The core action and relevant permission/error checks are entirely missing, leaving both primary and secondary coverage weak.",
                "The summary's claims are mostly inaccurate or overly generic. It says the function validates command parameters, updates a linked object reference, and processes associated data through synchronized handler routines, but the source code actually checks namespace capabilities, verifies a single user on the fs_struct, updates the mount namespace reference, and sets new root and working directories. There is no mention of command parameters or synchronized handler routines, making these statements NOISE, and key semantics like capability checks and filesystem path updates are missed. Noise outweighs accurate content, yielding low net benefit."
            ]
        },
        "cfg": {
            "summary": "Validates multiple input parameters, updates a linked data reference, processes associated flags through helper routines, and returns specific error codes or success status.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary is highly generic and omits core semantics from the source code, such as capability checks on the mount and user namespaces, specific conditions for returning error codes (-EPERM, -EINVAL), and the precise updates to the namespace and root/pwd paths. While it loosely matches the idea of validating parameters and returning error codes, it falsely implies processing of 'associated flags' and fails to capture the domain-specific namespace operations present. Only a small portion aligns accurately with the code, resulting in low overall precision.",
                "The summary is vague and does not accurately describe the core purpose of installing a new mount namespace and updating the current process\u2019s fs_struct root and working directory after capability checks. It does not mention the namespace handling, capability validation specifics, or root path adjustments, which are critical semantics in the source code. While it generically refers to validation, updating references, and returning error codes, these are too generic to cover the actual core domain action, and it omits most secondary behavior details.",
                "The summary is mostly generic and fails to capture the core semantics of the function. While it accurately notes returning specific error codes or success status, other claims\u2014such as validating multiple input parameters and processing flags\u2014are too vague or misaligned with the actual code, which performs capability checks, reference swapping, and path/root updates. The update to a linked data reference is an imprecise description of mnt_ns assignment, and there is no mention of the namespace or root path handling, so key domain details are omitted. Noise outweighs specific accurate content, and no fatal contradictions are present."
            ]
        },
        "comment": {
            "summary": "Validates permissions, checks filesystem usage, updates the mount namespace in the nsproxy, and sets the current process's root and working directory.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly captures key semantics from the source code: it notes permission validation (CAP_SYS_ADMIN, CAP_SYS_CHROOT checks), verifies filesystem usage via the users check, describes updating the mount namespace within nsproxy, and setting both the process's root and working directory. All claims align with the function's behavior and are specific to the code, yielding high accuracy without irrelevant or contradictory statements.",
                "The summary accurately captures the core purpose: replacing the nsproxy's mount namespace and updating the current process's root and working directory. It correctly notes permission validation and filesystem usage checks, which align with the code's CAP checks and fs->users condition. However, it omits several secondary semantics such as acquiring and releasing namespace references, resolving the root path with follow_down_one, and updating pwd and root via path operations, resulting in incomplete coverage of behavior-critical details.",
                "The summary contains multiple accurate claims: it describes permission validation via capability checks, a filesystem usage check (`fs->users != 1`), updating the mount namespace in `nsproxy`, and setting the process's root and working directories\u2014exactly matching the source code's steps. All points target core behavior without contradictions or unrelated noise, and they are specific to the function's primary purpose, providing clear, high-value insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582904640,
    "strip_function_name": "sub_FFFFFFFF813DF140",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813DF140(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // r13\n  __int64 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned __int64 v17; // kr00_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v10 = __readgsqword(0xA760u);\n  v11 = *(__int64 **)(*(_QWORD *)(a1 + 24) + 840LL);\n  sub_FFFFFFFF8138EC40(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10001, a3, a4, a5, a6, a7, a8, a9, a10);\n  sub_FFFFFFFF8138F4E0(v11, (unsigned int)&unk_12198, 0LL, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = sub_FFFFFFFF81042910(50) + qword_FFFFFFFF81CC2000 + 1;\n  while ( (sub_FFFFFFFF8138E6A0((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n  {\n    if ( v14 - qword_FFFFFFFF81CC2000 < 0 )\n    {\n      if ( (sub_FFFFFFFF8138E6A0((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n        sub_FFFFFFFF81379A60(\n          (int)\"gen6_bsd_ring_write_tail\",\n          (__int64)\"timed out waiting for the BSD ring to wake up\\n\",\n          a3,\n          a4,\n          a5,\n          a6,\n          v15,\n          v16,\n          a9,\n          a10);\n      break;\n    }\n    if ( (*(_DWORD *)(v10 - 8124) & 0xEFFFFFFF) != 0 || (v17 = __readeflags(), (v17 & 0x200) == 0) )\n      _mm_pause();\n    else\n      sub_FFFFFFFF8104BD50(1);\n  }\n  sub_FFFFFFFF8138EC40(v11, *(_DWORD *)(a1 + 12) + 48, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n  return sub_FFFFFFFF8138EC40(\n           v11,\n           (unsigned int)&unk_12050,\n           (unsigned int)&unk_10000,\n           a3,\n           a4,\n           a5,\n           a6,\n           v18,\n           v19,\n           a9,\n           a10);\n}\n",
    "function_name": "gen6_bsd_ring_write_tail",
    "decompiled_code": "void __fastcall gen6_bsd_ring_write_tail(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // r13\n  volatile signed __int16 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned __int64 v17; // kr00_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v10 = __readgsqword(0xA760u);\n  v11 = *(volatile signed __int16 **)(*(_QWORD *)(a1 + 24) + 840LL);\n  i915_write32(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10001, a3, a4, a5, a6, a7, a8, a9, a10);\n  i915_write64(v11, (unsigned int)&unk_12198, 0LL, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = msecs_to_jiffies(50) + _vvar_beginning_hack + 1;\n  while ( (i915_read32((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n  {\n    if ( v14 - _vvar_beginning_hack < 0 )\n    {\n      if ( (i915_read32((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n        drm_err(\n          (__int64)\"gen6_bsd_ring_write_tail\",\n          (__int64)\"timed out waiting for the BSD ring to wake up\\n\",\n          a3,\n          a4,\n          a5,\n          a6,\n          v15,\n          v16,\n          a9,\n          a10);\n      break;\n    }\n    if ( (*(_DWORD *)(v10 - 8124) & 0xEFFFFFFF) != 0 || (v17 = __readeflags(), (v17 & 0x200) == 0) )\n      _mm_pause();\n    else\n      msleep(1, (__int64)&unk_12050, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  i915_write32(v11, *(_DWORD *)(a1 + 12) + 48, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n  i915_write32(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10000, a3, a4, a5, a6, v18, v19, a9, a10);\n}\n",
    "source_code": "\n\nstatic void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,\n\t\t\t\t     u32 value)\n{\n\tdrm_i915_private_t *dev_priv = ring->dev->dev_private;\n\n       /* Every tail move must follow the sequence below */\n\n\t/* Disable notification that the ring is IDLE. The GT\n\t * will then assume that it is busy and bring it out of rc6.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n\n\t/* Clear the context id. Here be magic! */\n\tI915_WRITE64(GEN6_BSD_RNCID, 0x0);\n\n\t/* Wait for the ring not to be idle, i.e. for it to wake up. */\n\tif (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &\n\t\t      GEN6_BSD_SLEEP_INDICATOR) == 0,\n\t\t     50))\n\t\tDRM_ERROR(\"timed out waiting for the BSD ring to wake up\\n\");\n\n\t/* Now that the ring is fully powered up, update the tail */\n\tI915_WRITE_TAIL(ring, value);\n\tPOSTING_READ(RING_TAIL(ring->mmio_base));\n\n\t/* Let the ring send IDLE messages to the GT again,\n\t * and so let it sleep to conserve power when idle.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n}",
    "comment": "Updates the tail of the BSD ring buffer after ensuring the ring is active and managing power-saving notifications.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Disables vertical blanking interrupts for a specified display pipe by clearing the interrupt enable bit in the hardware register .\n",
    "cpbcs_sum": "Displays the current graphics context ID of the Intel graphics device and schedules a response to the associated with the DRM device.\n",
    "misum_sum": "The function disables GPU cache invalidation by checking for changes in the pipeline's display interfaces, handling destination-specific devices and ensuring proper synchronization.\n",
    "decom_sum": "Writes commands to the gen6 BSD ring and waits for it to wake up, timing out with an error message if it remains idle.",
    "cfg_sum": "Initializes hardware command buffers, waits for the BSD ring to become ready with a timeout, and writes final commands to the device.",
    "work_score": {
        "decom": {
            "summary": "Writes commands to the gen6 BSD ring and waits for it to wake up, timing out with an error message if it remains idle.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary captures the main functional behavior: writing to the Gen6 BSD ring and waiting for it to wake, including the timeout/error condition if idle. These are directly reflected in the source code steps involving I915_WRITE_TAIL, wait_for(), and DRM_ERROR. While it omits certain setup and power management details, all claims present are accurate and grounded in the code, yielding high alignment.",
                "The summary correctly notes writing to the gen6 BSD ring and waiting for it to wake up with a possible timeout error, matching core aspects of the code. However, it omits critical procedural details that form the core purpose, such as disabling/enabling idle notifications, clearing the context ID, powering up sequence, and restoring the power-saving state, which are integral to the function\u2019s behavior. This makes the coverage of secondary semantics weak despite capturing the wake-up wait.",
                "The summary correctly states that the function writes commands to the gen6 BSD ring, waits for it to wake up, and logs an error on timeout. These are accurate reflections of the source code\u2019s core behavior, including its primary purpose and key side effect. However, the summary omits other important steps such as disabling and re-enabling sleep messages and clearing the context ID, but this omission does not make the existing claims inaccurate. With no contradictory statements and only moderate detail, the gain is limited but positive, and noise is minimal."
            ]
        },
        "cfg": {
            "summary": "Initializes hardware command buffers, waits for the BSD ring to become ready with a timeout, and writes final commands to the device.",
            "score": [
                0.3,
                0.5,
                0.8
            ],
            "reason": [
                "The summary includes three main claims: initialization of hardware command buffers, waiting for the BSD ring readiness with a timeout, and writing final commands to the device. The second claim is accurate since the function waits for the BSD ring to be non-idle with a timeout. The third claim is partially accurate, as it updates the ring tail rather than writing arbitrary final commands. The first claim about initializing hardware command buffers is inaccurate because the code manipulates hardware registers and power states rather than initializing buffers. Overall, fewer than half of the claims match the source code precisely.",
                "The summary correctly notes waiting for the BSD ring to become ready with a timeout, which aligns with the wait_for logic, and mentions writing final commands, which corresponds to updating the tail. However, it inaccurately frames the core action as merely 'initializes hardware command buffers' rather than explicitly describing the sequence to wake up the GEN6 BSD ring and update its tail register. It omits key secondary details like disabling idle notifications, clearing the context ID, re-enabling idle messages for power saving, and the specific GEN6 BSD hardware registers involved. Core is partially covered but lacks domain-specific precision and misses several critical steps.",
                "The summary correctly identifies the major behaviors: it handles hardware-related ring buffer operations, waits for the BSD ring to become active with a timeout, and writes the updated tail (final commands) to hardware. These are accurate reflections of the source code\u2019s core logic and I/O behavior. The only mild shortcoming is that it doesn't explicitly mention disabling/enabling idle notifications around the operation, which slightly limits completeness. No inaccuracies or irrelevant noise are present, and the claims are specific and meaningful."
            ]
        },
        "comment": {
            "summary": "Updates the tail of the BSD ring buffer after ensuring the ring is active and managing power-saving notifications.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly captures the main purpose of the function: it updates the BSD ring buffer tail after ensuring the ring is active and handling power-saving notifications. These points align with the source code\u2019s sequence of disabling idle notifications, waking the ring, updating the tail, and then re-enabling idle messages. There are no contradictory or irrelevant claims, though the summary omits some implementation specifics, making it slightly less detailed but still accurate overall.",
                "The summary correctly captures the core operation of updating the BSD ring buffer tail after confirming the ring is active, which matches the sequence in the source code. It also mentions managing power-saving notifications, reflecting the enable/disable of sleep messages. However, it omits secondary details such as clearing the context ID, the wake-up wait and error handling, and the final re-enabling of idle messages, leaving coverage of other behavior-critical semantics incomplete.",
                "The summary correctly captures the core purpose of the function: updating the BSD ring buffer tail after ensuring it is active and handling power-saving notifications. This is an ACCURATE claim aligned with the source code logic, which includes waking the ring, managing sleep message disables/enables, and then writing the tail. There is no contradictory or irrelevant content, and while the description is somewhat generic and lacks low-level specifics (e.g., register operations, timing checks), it accurately reflects the primary purpose without noise or fatal errors."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583186688,
    "strip_function_name": "sub_FFFFFFFF81423F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81423F00(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        int a14)\n{\n  __int64 v14; // rcx\n  unsigned int v15; // r15d\n  unsigned int v16; // r12d\n  __int64 result; // rax\n  __int64 v20; // rax\n  __int64 v21; // rdx\n\n  v14 = *(unsigned int *)(a1 + 7264);\n  v15 = a2 ^ *(_DWORD *)(a1 + 7264);\n  if ( (v15 & (unsigned int)a2) != 0 )\n  {\n    sub_FFFFFFFF814226D0(\n      a1,\n      (int)&unk_FFFFFFFF8198743C,\n      (__int64)\"illegal qc_active transition (%08x->%08x)\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      v14,\n      (unsigned int)a2);\n    return 4294967274LL;\n  }\n  else\n  {\n    v16 = 0;\n    result = 0LL;\n    if ( v15 )\n    {\n      do\n      {\n        while ( 1 )\n        {\n          _RBX = v15;\n          __asm { tzcnt   rbx, rbx }\n          if ( (unsigned int)_RBX <= 0x1F )\n          {\n            v20 = 216LL * (unsigned int)_RBX;\n            if ( a1 + v20 != -344 )\n            {\n              v21 = *(_QWORD *)(a1 + 8);\n              if ( !*(_QWORD *)(v21 + 176) || (*(_QWORD *)(a1 + v20 + 416) & 0x10001LL) == 1 )\n                break;\n            }\n          }\n          v14 = (unsigned int)_RBX;\n          v15 &= ~(1 << _RBX);\n          if ( !v15 )\n            return v16;\n        }\n        sub_FFFFFFFF81423CF0(a1 + v20 + 344, a2, v21, v14, a13, a14);\n        v14 = (unsigned int)_RBX;\n        ++v16;\n        v15 &= ~(1 << _RBX);\n      }\n      while ( v15 );\n      return v16;\n    }\n  }\n  return result;\n}\n",
    "function_name": "ata_qc_complete_multiple",
    "decompiled_code": "__int64 __fastcall ata_qc_complete_multiple(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned int v10; // r15d\n  unsigned int v11; // r12d\n  __int64 result; // rax\n  __int64 v15; // rax\n\n  v10 = a2 ^ *(_DWORD *)(a1 + 7264);\n  if ( (v10 & (unsigned int)a2) != 0 )\n  {\n    ata_port_printk(\n      a1,\n      (__int64)&unk_FFFFFFFF8198743C,\n      (__int64)\"illegal qc_active transition (%08x->%08x)\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      *(unsigned int *)(a1 + 7264),\n      (unsigned int)a2);\n    return 4294967274LL;\n  }\n  else\n  {\n    v11 = 0;\n    result = 0LL;\n    if ( v10 )\n    {\n      do\n      {\n        while ( 1 )\n        {\n          _RBX = v10;\n          __asm { tzcnt   rbx, rbx }\n          if ( (unsigned int)_RBX <= 0x1F )\n          {\n            v15 = 216LL * (unsigned int)_RBX;\n            if ( a1 + v15 != -344\n              && (!*(_QWORD *)(*(_QWORD *)(a1 + 8) + 176LL) || (*(_QWORD *)(a1 + v15 + 416) & 0x10001LL) == 1) )\n            {\n              break;\n            }\n          }\n          v10 &= ~(1 << _RBX);\n          if ( !v10 )\n            return v11;\n        }\n        ata_qc_complete(a1 + v15 + 344, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n        ++v11;\n        v10 &= ~(1 << _RBX);\n      }\n      while ( v10 );\n      return v11;\n    }\n  }\n  return result;\n}\n",
    "source_code": "int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active)\n{\n\tint nr_done = 0;\n\tu32 done_mask;\n\n\tdone_mask = ap->qc_active ^ qc_active;\n\n\tif (unlikely(done_mask & qc_active)) {\n\t\tata_port_err(ap, \"illegal qc_active transition (%08x->%08x)\\n\",\n\t\t\t     ap->qc_active, qc_active);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_done++;\n\t\t}\n\t\tdone_mask &= ~(1 << tag);\n\t}\n\n\treturn nr_done;\n}",
    "comment": "Processes and completes multiple ATA queued commands based on the active command status while checking for illegal state transitions.",
    "hext5_sum": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
    "bint5_sum": "Validates and sets the active DMA transition for a SCSI disk based on the provided transition values , logging an error for invalid transitions .\n",
    "cpbcs_sum": "Disables a specified USB host endpoint, ensuring that do not exceed maximum queue depth and handling potential errors during the process.\n",
    "misum_sum": "Disables specified ATA port. clears its disable port if not exceptional or deactivates it is currently running.\n",
    "decom_sum": "Validates and processes changes to the qc_active bitmask, logging illegal transitions and invoking handlers for each newly activated bit.",
    "cfg_sum": "Validates and applies changes to the qc_active bitmask, logging illegal transitions and invoking handlers for each newly activated bit.",
    "work_score": {
        "decom": {
            "summary": "Validates and processes changes to the qc_active bitmask, logging illegal transitions and invoking handlers for each newly activated bit.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function\u2019s behavior: it claims to handle 'newly activated bits', while the code processes completed commands indicated by the done_mask (bits cleared in qc_active). Although it correctly mentions validation, logging of illegal transitions, and processing based on a bitmask, the core semantic about the type of bits handled is wrong. This results in less than half of the claims being accurate.",
                "The summary claims the function handles changes to the qc_active bitmask, logs illegal transitions, and processes each newly activated bit. While it correctly mentions bitmask changes and error logging, it inaccurately describes the domain action: the code completes queued commands whose bits are newly inactive (done), not newly activated. This misses the core purpose of completing multiple queued ATA commands after they finish, leading to a failure in covering the primary domain operation.",
                "The summary contains a key inaccuracy: it states that handlers are invoked for 'newly activated' bits, but the source code processes commands whose bits are in the 'done_mask', indicating completed commands, not newly activated ones. This is a FATAL error on the primary purpose of the function, which is to finalize completed queued commands, and misrepresents the core domain action. While it correctly notes validation of the qc_active bitmask and logging of illegal transitions, the misinterpretation of the core behavior severely undermines usefulness."
            ]
        },
        "cfg": {
            "summary": "Validates and applies changes to the qc_active bitmask, logging illegal transitions and invoking handlers for each newly activated bit.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary misrepresents the code's core behavior: the function processes a qc_active change by detecting completed commands (bits cleared) rather than newly activated bits, and invokes completion handlers, not activation handlers. While it correctly mentions validating transitions and logging errors, the incorrect characterization of bit handling and handler purpose makes most claims inaccurate, resulting in low alignment.",
                "The summary incorrectly describes handling 'newly activated' bits, while the function actually processes completed commands identified by differences in qc_active values. This misrepresents the core purpose, which is completing multiple queued ATA commands and counting them, including error handling for illegal transitions. While it mentions validation and logging, the core domain action is missing and the described action contradicts the code's logic.",
                "The summary contains a FATAL error on the primary purpose: it states that the function handles 'newly activated' bits, but the code iterates over and completes commands for bits that have transitioned from active to inactive (done). This misrepresents the core domain action. While the mention of logging illegal transitions is accurate, the key I/O semantics are wrong, making the description untrustworthy overall."
            ]
        },
        "comment": {
            "summary": "Processes and completes multiple ATA queued commands based on the active command status while checking for illegal state transitions.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function processes and completes multiple ATA queued commands and that it checks for illegal state transitions based on active command status. These claims match the code's core behavior of iterating over completed commands, invoking ata_qc_complete, and detecting invalid qc_active transitions. There are no incorrect or irrelevant claims, but the description is somewhat generic and omits specifics like return value and mask computation, still maintaining >80% accuracy.",
                "The summary accurately conveys the core purpose: completing multiple ATA queued commands based on the active command status, and notes the check for illegal state transitions, which matches the error handling in the code. However, it omits secondary details such as the use of bitmask operations, the calculation of the number of completed commands, and specific return values including the error code on illegal transitions. Overall, it covers the primary purpose but lacks broader behavioral specifics.",
                "The summary correctly states that the function processes and completes multiple ATA queued commands and checks for illegal state transitions, which matches the core logic of calculating a done_mask from qc_active, validating against illegal transitions, and completing queued commands. There are no inaccurate claims or noise, but the description is generic and omits specific details such as the return value indicating the number of commands completed or the specific mechanism of detecting illegal transitions via bitwise operations. The net gain is moderate given low-info breadth but correct core coverage."
            ]
        }
    }
}
{
    "project_name": "gawk",
    "function_addr": 4677088,
    "strip_function_name": "sub_475DE0",
    "strip_decompiled_code": "char *__fastcall sub_475DE0(__int64 a1, __int64 *a2, __m128i *a3, __int64 a4, int a5, int *a6)\n{\n  __int64 v9; // rbx\n  char *v10; // rax\n  char *v11; // r15\n  char *v12; // rcx\n  __int64 v15; // [rsp+18h] [rbp-70h]\n  __int64 v16; // [rsp+20h] [rbp-68h]\n  __m128i v17; // [rsp+30h] [rbp-58h] BYREF\n  unsigned __int64 v18; // [rsp+48h] [rbp-40h]\n\n  v9 = *a2;\n  v18 = __readfsqword(0x28u);\n  v16 = *(_QWORD *)(v9 + 152);\n  v10 = sub_475C40((__int64 *)a1, a2, a3, a4, a5, a6);\n  v11 = v10;\n  if ( *a6 && !v10 )\n    return 0LL;\n  while ( a3->m128i_i8[8] == 10 )\n  {\n    *(_DWORD *)(a1 + 56) += sub_46FB40((unsigned __int8 *)a3, (__int64 *)a1, a4 | 0x800000);\n    if ( (a3->m128i_i8[8] & 0xF7) == 2 || a3->m128i_i8[8] == 9 && a5 )\n    {\n      v12 = 0LL;\n    }\n    else\n    {\n      v15 = *(_QWORD *)(v9 + 152);\n      *(_QWORD *)(v9 + 152) = v16;\n      v12 = sub_475C40((__int64 *)a1, a2, a3, a4, a5, a6);\n      if ( *a6 && !v12 )\n      {\n        if ( v11 )\n          sub_469F50(v11, (__int64 (__fastcall *)(__int64, _QWORD *))sub_46AE80, 0LL);\n        return 0LL;\n      }\n      *(_QWORD *)(v9 + 152) |= v15;\n    }\n    v17 = 0LL;\n    v17.m128i_i8[8] = 10;\n    v11 = sub_46BD40((_QWORD *)(v9 + 112), (int *)(v9 + 128), v11, v12, &v17);\n    if ( !v11 )\n    {\n      *a6 = 12;\n      return v11;\n    }\n  }\n  return v11;\n}\n",
    "function_name": "parse_reg_exp",
    "decompiled_code": "bin_tree_t *__fastcall parse_reg_exp(\n        re_string_t *regexp,\n        regex_t *preg,\n        re_token_t *token,\n        reg_syntax_t syntax,\n        Idx nest,\n        reg_errcode_t *err)\n{\n  re_dfa_t *buffer; // rbx\n  bin_tree_t *v10; // rax\n  bin_tree_t *v11; // r15\n  bin_tree_t *v12; // rcx\n  bitset_word_t v15; // [rsp+A0h] [rbp+18h]\n  bitset_word_t completed_bkref_map; // [rsp+A8h] [rbp+20h]\n  __m128i v17; // [rsp+B8h] [rbp+30h] BYREF\n  unsigned __int64 v18; // [rsp+D0h] [rbp+48h]\n\n  buffer = preg->buffer;\n  v18 = __readfsqword(0x28u);\n  completed_bkref_map = buffer->completed_bkref_map;\n  v10 = parse_branch(regexp, preg, token, syntax, nest, err);\n  v11 = v10;\n  if ( *err && !v10 )\n    return 0LL;\n  while ( *((_BYTE *)token + 8) == 10 )\n  {\n    regexp->cur_idx += peek_token(token, regexp, syntax | 0x800000);\n    if ( (*((_BYTE *)token + 8) & 0xF7) == 2 || *((_BYTE *)token + 8) == 9 && nest )\n    {\n      v12 = 0LL;\n    }\n    else\n    {\n      v15 = buffer->completed_bkref_map;\n      buffer->completed_bkref_map = completed_bkref_map;\n      v12 = parse_branch(regexp, preg, token, syntax, nest, err);\n      if ( *err && !v12 )\n      {\n        if ( v11 )\n          postorder(v11, free_tree, 0LL);\n        return 0LL;\n      }\n      buffer->completed_bkref_map |= v15;\n    }\n    v17 = 0LL;\n    v17.m128i_i8[8] = 10;\n    v11 = create_token_tree(\n            (re_dfa_t *)&buffer->str_tree_storage,\n            (bin_tree_t *)&buffer->str_tree_storage_idx,\n            v11,\n            (const re_token_t *)v12,\n            &v17);\n    if ( !v11 )\n    {\n      *err = _REG_ESPACE;\n      return v11;\n    }\n  }\n  return v11;\n}\n",
    "source_code": "\nstatic bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (__glibc_unlikely (*err != REG_NOERROR && branch == NULL))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
    "comment": "Parses a regular expression into a binary tree structure while managing alternative branches and backreference mapping.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Parses a regular expression into a binary tree structure , handling concatenation and error management through recursive expression evaluations .\n",
    "cpbcs_sum": "Parses a regular expression into a binary tree structure, handling alternations and backreference mappings while managing error states.\n",
    "misum_sum": "Parses a regular expression into an ASN.1 structure, handling scope and error management during the parsing process.\n",
    "decom_sum": "Processes input records with code 10 by repeatedly merging parsed segments, updating state fields, and aborting on errors while preserving prior context.",
    "cfg_sum": "Processes and updates an object's state based on input data type 10, invoking helper routines and aborting on validation failure or stack corruption.",
    "work_score": {
        "decom": {
            "summary": "Processes input records with code 10 by repeatedly merging parsed segments, updating state fields, and aborting on errors while preserving prior context.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims to process input records with code 10, which is unrelated to the source code's purpose of parsing a regular expression into a binary tree structure with alternation handling. While mentions of aborting on errors and preserving context loosely align with error checks and back-reference map restoration, most claims misrepresent the domain semantics, leading to a low proportion of accurate statements.",
                "The summary's claims about processing input records with a specific code, merging segments, and updating state fields do not align with the source code, which parses regular expressions into a binary tree by handling alternation tokens, managing backreference maps, and aborting on errors. The core purpose of parsing regex branches with alternation handling is not mentioned, and no accurate claim covers this primary functionality. The provided details are unrelated to the actual domain semantics of the code.",
                "The summary makes inaccurate core claims: it describes processing input records with code 10, which is not present in the source code, and omits the actual primary purpose of parsing regular expression branches with alternation tokens. It also incorrectly states repeated merging of parsed segments as a generic operation without referencing the actual `create_tree` alternation parsing logic, and misrepresents state updates as unrelated 'state fields.' These are FATAL errors affecting the primary purpose, making the description untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Processes and updates an object's state based on input data type 10, invoking helper routines and aborting on validation failure or stack corruption.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes and updates an object's state based on input data type 10, invokes helper routines, and aborts on validation failure or stack corruption. The source code shows it parses a regular expression branch, handles alternation, and manages backreference maps, with errors related to parsing and memory allocation. There is no evidence of an 'input data type 10' concept or stack corruption handling. Only the invocation of helper routines aligns loosely. Most claims are inaccurate and unrelated to the function's actual semantics, resulting in a low proportion of accurate statements.",
                "The summary's claims do not align with the source code semantics. The function parses a regular expression into a binary tree, handling alternation operators, updating a back-reference map, and managing errors like memory exhaustion. The summary instead refers to processing type 10 data, object state updates, validation failure, and stack corruption\u2014none of which are present in the source. This means the core purpose is entirely missed and no accurate coverage of behavior-critical aspects is provided.",
                "The summary contains mostly inaccurate claims: it mentions 'input data type 10', 'validation failure', and 'stack corruption', none of which correspond to the source code's logic. The actual code parses a regular expression into a binary tree, handles alternation tokens, manages backreference maps, and aborts on memory errors or regex parsing errors. The noise is overwhelming and there are fatal inaccuracies about the core purpose and error handling semantics, making the description misleading and untrustworthy."
            ]
        },
        "comment": {
            "summary": "Parses a regular expression into a binary tree structure while managing alternative branches and backreference mapping.",
            "score": [
                0.9,
                0.8,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function parses a regular expression into a binary tree and that it manages alternative branches and backreference mapping, both of which are evident in the use of `parse_branch`, `create_tree` with `OP_ALT`, and manipulation of `completed_bkref_map`. These are accurate and specific to the source code. No claims contradict or stray from the code, resulting in a high proportion of accurate statements.",
                "The summary correctly identifies the function\u2019s main purpose\u2014parsing a regular expression into a binary tree\u2014matching the code\u2019s core operation (using parse_branch, create_tree). It also mentions handling alternative branches and backreference mapping, which aligns with the loop over OP_ALT and backreference map management. Missing are explicit notes on error handling (e.g., REG_ESPACE, REG_NOERROR) and cleanup steps, so coverage of secondary behaviors is strong but not complete.",
                "The summary contains one accurate GOLD claim describing the function\u2019s core purpose \u2014 parsing a regular expression into a binary tree. It correctly notes handling of alternative branches via OP_ALT logic and mentions backreference mapping, which matches the use of completed_bkref_map in the code. There is no contradictory or irrelevant information, but the details are minimal, offering only broad coverage without specifics about error handling or token processing, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584303216,
    "strip_function_name": "sub_FFFFFFFF81534870",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81534870(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r14\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  unsigned __int64 v16; // rax\n  unsigned __int64 v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  int v20; // r9d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  int v23; // r14d\n  __int64 *v24; // rdx\n  __int64 v25; // rcx\n  int v26; // r8d\n  int v27; // r9d\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n  double v30; // xmm4_8\n  double v31; // xmm5_8\n\n  v9 = sub_FFFFFFFF812CA1F0((_WORD *)a1);\n  v16 = sub_FFFFFFFF8112CF10((int)v9 + 38, 0xD0u, v10, v11, v12, v13, a2, a3, a4, a5, v14, v15, a8, a9);\n  if ( !v16 )\n    return 1LL;\n  v17 = v16;\n  sub_FFFFFFFF812CA260(v16, (_WORD *)a1, (int)v9 + 38);\n  *(_BYTE *)(v17 + v9) = 45;\n  sub_FFFFFFFF812B84F0(v17 + v9 + 1, (__int64)\"%pUl\", a2, a3, a4, a5, v18, v19, a8, a9, a1 + 1024);\n  *(_QWORD *)(a1 + 2136) = qword_FFFFFFFF81EA8120;\n  v23 = sub_FFFFFFFF812AFED0(\n          (unsigned __int64 *)(a1 + 2104),\n          (__int64)off_FFFFFFFF81C7BA60,\n          0LL,\n          (__int64)byte_FFFFFFFF819CBB7A,\n          v17,\n          v20,\n          a2,\n          a3,\n          a4,\n          a5,\n          v21,\n          v22,\n          a8,\n          a9);\n  sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, v28, v29, a8, a9, (__int64)off_FFFFFFFF81C7BA60, v24, v25, v26, v27);\n  if ( v23 )\n    return 1LL;\n  sub_FFFFFFFF812B0B70(a1 + 2104, 0, a2, a3, a4, a5, v30, v31, a8, a9);\n  sub_FFFFFFFF81532AA0(a1, (__int64 *)&off_FFFFFFFF81C7BB80);\n  return 0LL;\n}\n",
    "function_name": "efivar_create_sysfs_entry",
    "decompiled_code": "__int64 __fastcall efivar_create_sysfs_entry(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r14\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  __int64 *v12; // rax\n  __int64 *v13; // rbx\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // r14d\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v9 = ucs2_utf8size((_WORD *)a1);\n  v12 = _kmalloc((int)v9 + 38, 208LL, a2, a3, a4, a5, v10, v11, a8, a9);\n  if ( !v12 )\n    return 1LL;\n  v13 = v12;\n  ucs2_as_utf8((__int64)v12, (_WORD *)a1, (int)v9 + 38);\n  *((_BYTE *)v13 + v9) = 45;\n  sprintf((__int64)v13 + v9 + 1, (__int64)\"%pUl\", a2, a3, a4, a5, v14, v15, a8, a9, a1 + 1024);\n  *(_QWORD *)(a1 + 2136) = efivars_kset;\n  v18 = kobject_init_and_add(\n          (__int64 **)(a1 + 2104),\n          (__int64)efivar_ktype,\n          0LL,\n          (__int64)byte_FFFFFFFF819CBB7A,\n          a2,\n          a3,\n          a4,\n          a5,\n          v16,\n          v17,\n          a8,\n          a9,\n          v13);\n  kfree(v13, a2, a3, a4, a5, v20, v21, a8, a9, (__int64)efivar_ktype, v19);\n  if ( v18 )\n    return 1LL;\n  kobject_uevent(a1 + 2104, 0, a2, a3, a4, a5, v22, v23, a8, a9);\n  efivar_entry_add(a1, (__int64 *)&efivar_sysfs_list);\n  return 0LL;\n}\n",
    "source_code": "static int\nefivar_create_sysfs_entry(struct efivar_entry *new_var)\n{\n\tint i, short_name_size;\n\tchar *short_name;\n\tunsigned long variable_name_size;\n\tefi_char16_t *variable_name;\n\n\tvariable_name = new_var->var.VariableName;\n\tvariable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);\n\n\t/*\n\t * Length of the variable bytes in ASCII, plus the '-' separator,\n\t * plus the GUID, plus trailing NUL\n\t */\n\tshort_name_size = variable_name_size / sizeof(efi_char16_t)\n\t\t\t\t+ 1 + EFI_VARIABLE_GUID_LEN + 1;\n\n\tshort_name = kzalloc(short_name_size, GFP_KERNEL);\n\n\tif (!short_name)\n\t\treturn 1;\n\n\t/* Convert Unicode to normal chars (assume top bits are 0),\n\t   ala UTF-8 */\n\tfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\n\t\tshort_name[i] = variable_name[i] & 0xFF;\n\t}\n\t/* This is ugly, but necessary to separate one vendor's\n\t   private variables from another's.         */\n\n\t*(short_name + strlen(short_name)) = '-';\n\tefi_guid_unparse(&new_var->var.VendorGuid,\n\t\t\t short_name + strlen(short_name));\n\n\tnew_var->kobj.kset = efivars_kset;\n\n\ti = kobject_init_and_add(&new_var->kobj, &efivar_ktype,\n\t\t\t\t   NULL, \"%s\", short_name);\n\tkfree(short_name);\n\tif (i)\n\t\treturn 1;\n\n\tkobject_uevent(&new_var->kobj, KOBJ_ADD);\n\tefivar_entry_add(new_var, &efivar_sysfs_list);\n\n\treturn 0;\n}",
    "comment": "Creates a sysfs entry for a new EFI variable by converting its Unicode name to ASCII and adding it to the kernel's object hierarchy.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes a new EFI variable entry and its corresponding sysfs entry if the variable content is valid and the user has appropriate permissions .\n",
    "cpbcs_sum": "Allocates and initializes a PCI bus for a PCI device based on the retrieved EDID name, setting up input parameters.\n",
    "misum_sum": "Allocates memory for a new PCM device and appends it to the uevent environment if the device does not already exist.\n",
    "decom_sum": "Formats a device identifier using \u201c%pUl\u201d, updates related global pointers, and performs initialization and registration of the device structure.",
    "cfg_sum": "Formats a pointer with a specific prefix, updates device-related state, verifies the operation, and restores context before returning success or failure.",
    "work_score": {
        "decom": {
            "summary": "Formats a device identifier using \u201c%pUl\u201d, updates related global pointers, and performs initialization and registration of the device structure.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function formats a device identifier using \"%pUl\" and updates global pointers, which are not present in the source. The actual code converts a Unicode variable name to ASCII, appends a GUID, initializes a kobject, and registers it with sysfs, but the summary misidentifies this as device structure initialization and registration. None of the claims are accurate representations of the code's semantics.",
                "The summary's claims about formatting a device identifier with '%pUl', updating global pointers, and registering a device structure do not match the source code's semantics. The function actually builds a short name from a variable name and GUID, initializes a kobject, adds it to sysfs, triggers a uevent, and adds the entry to a list. None of the summary's claims accurately reflect the core purpose or secondary behaviors present in the code, resulting in no coverage of the core domain operation.",
                "The summary contains multiple inaccurate claims about the code\u2019s purpose and behavior. It incorrectly states that the function formats a device identifier using \u201c%pUl\u201d, updates global pointers, and registers a device structure\u2014none of which occur in the source. The actual function creates a sysfs entry for an EFI variable by constructing a short name from its Unicode name and GUID, initializing a kobject, and adding it to the sysfs list. This is a severe FATAL error on the primary purpose, making the summary misleading and unusable."
            ]
        },
        "cfg": {
            "summary": "Formats a pointer with a specific prefix, updates device-related state, verifies the operation, and restores context before returning success or failure.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about formatting a pointer with a prefix, updating device-related state, verifying the operation, and restoring context do not align with the source code semantics. The function constructs a short name from a Unicode variable name and GUID, allocates memory, initializes and adds a kobject to a sysfs set, sends a uevent, and adds the entry to a list. None of the summary's claims are factually accurate with respect to the implementation, resulting in no accurate claims.",
                "The summary's claims (pointer formatting with prefix, device state update, verification, context restore) are either inaccurate or overly generic compared to the code. The function actually constructs a sysfs entry name from a Unicode variable name and a GUID, initializes and adds a kobject, sends a uevent, and registers the efivar entry. There is no mention of restoring context or generic pointer prefix formatting as stated, nor is the core purpose of creating and registering an EFI variable sysfs entry covered. This results in the core operation being missed and the claims misaligned with the source.",
                "The summary's claims \u2014 formatting a pointer with a specific prefix, updating device-related state, verifying the operation, and restoring context \u2014 do not align with the source code's actual semantics. The function converts a Unicode EFI variable name to ASCII, appends a GUID, creates and registers a kobject in sysfs, and adds the entry to a list. None of the core actions or side effects described in the summary match these steps, making the inaccuracies severe and targeting the primary purpose. This is a FATAL failure affecting the core logic, leading to an unusable summary."
            ]
        },
        "comment": {
            "summary": "Creates a sysfs entry for a new EFI variable by converting its Unicode name to ASCII and adding it to the kernel's object hierarchy.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary contains two atomic claims: 1) it creates a sysfs entry for a new EFI variable, and 2) it converts the variable's Unicode name to ASCII and adds it to the kernel's object hierarchy. Both claims are accurate: the code allocates and formats `short_name` from the Unicode name, then uses `kobject_init_and_add` to create a sysfs entry tied to the kernel object. No inaccuracies are present, and the summary correctly reflects the core domain semantics.",
                "The summary accurately describes creating a sysfs entry for an EFI variable and converting the Unicode name to ASCII, which matches the core behavior in the source code. It also correctly notes adding it to the kernel\u2019s object hierarchy. However, it omits several important secondary details such as adding a hyphen separator, appending the GUID, memory allocation and freeing, error handling when allocation or kobject addition fails, triggering a uevent, and updating the efivar sysfs list. These omissions limit coverage of the function\u2019s behavior-critical semantics.",
                "The summary correctly states that the function creates a sysfs entry for a new EFI variable and that it converts its Unicode name to ASCII, which matches the code's loop converting each 16-bit character to a byte. It also accurately notes that the variable is added to the kernel's object hierarchy via kobject_init_and_add and kobject_uevent. However, the description omits key specifics: it ignores the inclusion of the vendor GUID in the name, memory allocation and cleanup, error handling paths, and the explicit addition to efivar_sysfs_list. The claims present are accurate but generic, offering low detail and limited engineering value, with no factual inaccuracies or noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586732474,
    "strip_function_name": "sub_FFFFFFFF817859BA",
    "strip_decompiled_code": "void __fastcall __noreturn sub_FFFFFFFF817859BA(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        int a10)\n{\n  unsigned int v10; // ebx\n  void (__fastcall *v11)(int *); // rax\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // r8d\n  int v15; // r9d\n  void (*v16)(void); // rax\n  double v17; // xmm0_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v20; // rdx\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  unsigned int v24; // edi\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 v27; // rdx\n\n  sub_FFFFFFFF817822C3();\n  off_FFFFFFFF81CAB688();\n  v10 = __readgsdword(0xA030u);\n  v11 = (void (__fastcall *)(int *))off_FFFFFFFF81CB6AB8[33];\n  if ( v11 && v10 )\n    v11(&dword_FFFFFFFF81DD29D8);\n  v12 = ((unsigned int (__fastcall *)(__int64))off_FFFFFFFF81CB6AB8[36])(32LL);\n  v13 = ((__int64 (__fastcall *)(__int64))off_FFFFFFFF81CB6AB8[22])(v12);\n  if ( _bittest((const signed __int32 *)&qword_FFFFFFFF81DCE750, v10) )\n    sub_FFFFFFFF8178A51B(\n      (unsigned int)\"%s: phys CPU#%d, CPU#%d already present??\\n\",\n      (unsigned int)\"smp_callin\",\n      v13,\n      v10,\n      v14,\n      v15);\n  while ( !_bittest((const signed __int32 *)&qword_FFFFFFFF81DCE758, v10) )\n    _mm_pause();\n  v16 = (void (*)(void))off_FFFFFFFF81CB6AB8[34];\n  if ( v16 )\n    v16();\n  sub_FFFFFFFF81786852();\n  sub_FFFFFFFF81786AD6();\n  LODWORD(v12) = __readgsdword(0xA030u);\n  v17 = sub_FFFFFFFF81006060(v12);\n  sub_FFFFFFFF8178554D(v10, v17, a2, a3, a4, v18, v19, a7, a8);\n  sub_FFFFFFFF8177FEF2(v10, a10, v20, v21, v22, v23);\n  v24 = __readgsdword(0xA030u);\n  *(_QWORD *)&byte_10E00[qword_FFFFFFFF81CB6720[v10] + 160] = off_FFFFFFFF81C10020;\n  sub_FFFFFFFF81785588(v24, v17, a2, a3, a4, v25, v26, a7, a8);\n  _mm_sfence();\n  sub_FFFFFFFF817876B3(v10);\n  sub_FFFFFFFF8178A0B1(v10, &qword_FFFFFFFF81DCE750, v27);\n  dword_FFFFFFFF81DD29DC = 0;\n  sub_FFFFFFFF817864C4();\n  sub_FFFFFFFF81007390();\n  sub_FFFFFFFF81027050();\n  sub_FFFFFFFF8103F840(__readgsdword(0xA030u), 1);\n  sub_FFFFFFFF81027070();\n  *(_DWORD *)(qword_FFFFFFFF81CB6720[__readgsdword(0xA030u)] + 48128) = 2;\n  off_FFFFFFFF81C11DA8();\n  _enable();\n  off_FFFFFFFF81CAB680();\n  _mm_sfence();\n  sub_FFFFFFFF81082C80(1LL);\n}\n",
    "function_name": "start_secondary",
    "decompiled_code": "void __fastcall __noreturn start_secondary(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        int a10)\n{\n  unsigned int v10; // ebx\n  void (__fastcall *v11)(int *); // rax\n  __int64 v12; // rdi\n  unsigned int v13; // eax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  void (*v16)(void); // rax\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  signed int v25; // edi\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n  double v30; // xmm4_8\n  double v31; // xmm5_8\n\n  cpu_init(a1, a2, a3, a4, a5, a6, a7, a8);\n  off_FFFFFFFF81CAB688();\n  v10 = __readgsdword(0xA030u);\n  v11 = (void (__fastcall *)(int *))*((_QWORD *)apic + 33);\n  if ( v11 && v10 )\n    v11(&init_deasserted);\n  v12 = (*((unsigned int (__fastcall **)(__int64))apic + 36))(32LL);\n  v13 = (*((__int64 (__fastcall **)(__int64))apic + 22))(v12);\n  if ( _bittest((const signed __int32 *)&cpu_callin_mask, v10) )\n    panic(\n      (__int64)\"%s: phys CPU#%d, CPU#%d already present??\\n\",\n      a1,\n      a2,\n      a3,\n      a4,\n      v14,\n      v15,\n      a7,\n      a8,\n      \"smp_callin\",\n      v13,\n      v10);\n  while ( !_bittest((const signed __int32 *)&cpu_callout_mask, v10) )\n    _mm_pause();\n  v16 = (void (*)(void))*((_QWORD *)apic + 34);\n  if ( v16 )\n    v16();\n  setup_local_APIC();\n  end_local_APIC_setup(v12, a10, v17, v18, v19, v20);\n  setup_vector_irq(__readgsdword(0xA030u));\n  smp_store_cpu_info(v10, a1, a2, a3, a4, v21, v22, a7, a8);\n  calibrate_delay(a1, a2, a3, a4, v23, v24, a7, a8);\n  v25 = __readgsdword(0xA030u);\n  *(_QWORD *)&cpu_info[_per_cpu_offset[v10] + 160] = loops_per_jiffy;\n  set_cpu_sibling_map(v25, a1, a2, a3, a4, v26, v27, a7, a8);\n  _mm_sfence();\n  notify_cpu_starting(v10);\n  cpumask_set_cpu_1(v10, (volatile signed __int32 *)&cpu_callin_mask);\n  enable_start_cpu0 = 0;\n  check_tsc_sync_target(a1, a2, a3, a4, v28, v29, a7, a8, v10, (__int64)&cpu_callin_mask);\n  init_espfix_ap();\n  lock_vector_lock();\n  set_cpu_online(__readgsdword(0xA030u), 1);\n  unlock_vector_lock();\n  *(_DWORD *)(_per_cpu_offset[__readgsdword(0xA030u)] + 48128) = 2;\n  off_FFFFFFFF81C11DA8();\n  _enable();\n  x86_cpuinit();\n  _mm_sfence();\n  cpu_startup_entry((_BYTE *)&_per_cpu_start + 1, 1LL, a1, a2, a3, a4, v30, v31, a7, a8);\n}\n",
    "source_code": "\nvoid __cpuinit start_secondary(void)\n{\n\tunsigned int cpu;\n\tunsigned long thread_ptr;\n\n\t/*  Calculate thread_info pointer from stack pointer  */\n\t__asm__ __volatile__(\n\t\t\"%0 = SP;\\n\"\n\t\t: \"=r\" (thread_ptr)\n\t);\n\n\tthread_ptr = thread_ptr & ~(THREAD_SIZE-1);\n\n\t__asm__ __volatile__(\n\t\tQUOTED_THREADINFO_REG \" = %0;\\n\"\n\t\t:\n\t\t: \"r\" (thread_ptr)\n\t);\n\n\t/*  Set the memory struct  */\n\tatomic_inc(&init_mm.mm_count);\n\tcurrent->active_mm = &init_mm;\n\n\tcpu = smp_processor_id();\n\n\tsetup_irq(BASE_IPI_IRQ + cpu, &ipi_intdesc);\n\n\t/*  Register the clock_event dummy  */\n\tsetup_percpu_clockdev();\n\n\tprintk(KERN_INFO \"%s cpu %d\\n\", __func__, current_thread_info()->cpu);\n\n\tnotify_cpu_starting(cpu);\n\n\tset_cpu_online(cpu, true);\n\n\tlocal_irq_enable();\n\n\tcpu_startup_entry(CPUHP_ONLINE);\n}",
    "comment": "Initializes the secondary CPU by configuring memory management, enabling interrupts, and signaling readiness for operation within a multiprocessor environment.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Initializes the kernel by setting up memory , CPU access , opening the console , checking for early init commands , and loading default modules .\n",
    "cpbcs_sum": "Handles CPU state by invoking the error handler, managing CPU states, and invoking hotplug CPUs if available.\n",
    "misum_sum": "Handles CPU state changes by preparing it the CPU online CPU, and managing CPU state changes during CPU startup and online CPUs.\n",
    "decom_sum": "Initializes a secondary CPU during SMP startup, synchronizing with other cores, setting per\u2011CPU data, and enabling it for normal operation.",
    "cfg_sum": "Initializes a CPU during system startup, validating state, detecting duplicates, executing setup routines, synchronizing memory, and enabling execution.",
    "work_score": {
        "decom": {
            "summary": "Initializes a secondary CPU during SMP startup, synchronizing with other cores, setting per\u2011CPU data, and enabling it for normal operation.",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function initializes a secondary CPU during SMP startup, sets per\u2011CPU data, and enables it for normal operation, all of which are supported by the code. However, the claim about synchronizing with other cores is not explicitly evidenced in the source, making it less accurate. Most claimed behaviors align with the observed operations, yielding a high proportion of accurate claims with minor overreach.",
                "The summary correctly identifies the function\u2019s core purpose as initializing a secondary CPU during SMP startup and enabling it for operation, which aligns with the code\u2019s sequence of setting up thread info, per-CPU resources, marking the CPU online, enabling interrupts, and entering the startup loop. However, it omits important secondary details such as setting the active_mm struct from init_mm, registering IRQ for inter-processor interrupts, registering the per\u2011CPU clock event device, logging startup messages, and specific calls to notify and mark the CPU as online. Coverage of secondary behavior is weak, with no mention of IRQ setup, clocks, or atomic increment operations.",
                "The summary correctly states that the function initializes a secondary CPU during SMP startup and enables it for normal operation, which matches the core intent of the source code. However, it introduces some noise with the claim about 'synchronizing with other cores,' which is not explicitly supported in the implementation. The alignment is mostly safe but generic, with low informational gain due to lack of detailed specifics like setting thread_info from the stack pointer, configuring IRQs, and other per\u2011CPU setup steps. No fatal inaccuracies are present, but the details provided are limited and somewhat vague."
            ]
        },
        "cfg": {
            "summary": "Initializes a CPU during system startup, validating state, detecting duplicates, executing setup routines, synchronizing memory, and enabling execution.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary describes CPU initialization at startup and enabling execution, which aligns generally with the source code steps like setting up IRQ, enabling interrupts, and calling cpu_startup_entry. However, it introduces inaccurate elements such as 'validating state' and 'detecting duplicates', which are not present in the code. The claim about synchronizing memory loosely maps to atomic_inc on mm_count and setting active_mm but is generic. Overall, fewer than half of the claims are accurate, with several speculative or unrelated details.",
                "The summary gives a generic description of CPU initialization but lacks the specific core action from the source code: obtaining the thread_info pointer from the stack pointer, setting the active_mm, setting up IPI interrupts, registering a dummy clock event device, and entering the CPU startup loop. Several phrases like 'validating state' and 'detecting duplicates' are unsupported by the code, making them inaccurate. While it loosely mentions initialization and enabling execution, it fails to concretely cover the core domain purpose and omits critical secondary behaviors.",
                "The summary correctly notes that the function initializes a CPU during startup and performs setup routines, which aligns with the source code's steps such as setting memory structures, registering devices, enabling interrupts, and entering the startup loop. However, it inaccurately introduces notions of 'validating state', 'detecting duplicates', and 'synchronizing memory' not evidenced in the code, making these NOISE claims. There are no fatal contradictions about the core purpose, but the excessive NOISE reduces clarity and limits the net gain to low overall benefit."
            ]
        },
        "comment": {
            "summary": "Initializes the secondary CPU by configuring memory management, enabling interrupts, and signaling readiness for operation within a multiprocessor environment.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function initializes a secondary CPU, configures memory management, enables interrupts, and signals readiness in a multiprocessor context, all of which align with the source code\u2019s actions such as setting active_mm, enabling local IRQ, notifying CPU start, and calling cpu_startup_entry. Although the summary is somewhat generic and omits details like IRQ setup and clock device registration, the included claims are accurate and consistent with the code, with no contradictory or irrelevant statements.",
                "The summary correctly conveys the general purpose of initializing a secondary CPU, including memory setup, enabling interrupts, and signaling CPU readiness, which matches the core functionality of starting a secondary processor. However, it lacks specificity about key domain operations in the source code such as retrieving and setting the thread_info pointer from the stack, incrementing init_mm count, registering per-CPU clock devices, setting up inter-processor interrupt handlers, and calling cpu_startup_entry with CPUHP_ONLINE. The description is accurate but generic, missing several important secondary behaviors and hardware-specific details.",
                "The summary correctly conveys the broad purpose of the function\u2014initializing a secondary CPU, configuring memory management, enabling interrupts, and indicating readiness in a multiprocessor setup\u2014all of which align with the observed code operations such as setting init_mm, enabling local interrupts, and marking the CPU online. However, these claims are generic SAFE statements and lack specific GOLD details such as calculating thread_info from the stack pointer, setting IRQ handlers, or registering the clock event device. No factual inaccuracies or contradictions were present, but the low level of detail limits the net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582001184,
    "strip_function_name": "sub_FFFFFFFF81302820",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81302820(\n        int *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 (__fastcall *v10)(int *, _QWORD); // rax\n  int v11; // eax\n  bool v12; // zf\n  __int64 result; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  int i; // r14d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned __int64 v20[11]; // [rsp+0h] [rbp-58h] BYREF\n\n  v10 = *(__int64 (__fastcall **)(int *, _QWORD))(a2 + 8);\n  if ( !v10 )\n    goto LABEL_6;\n  v11 = v10(a1, *(_QWORD *)(a2 + 16));\n  v12 = v11 == 0;\n  if ( v11 < 0 )\n  {\n    *(_DWORD *)(a2 + 28) = v11;\n    return 16387LL;\n  }\n  result = 0LL;\n  if ( v12 )\n  {\nLABEL_6:\n    memset(v20, 0, 0x38uLL);\n    if ( (unsigned __int8)sub_FFFFFFFF81302020(a1, v20) || (unsigned __int8)sub_FFFFFFFF81302220((__int64)a1, v20) )\n      return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n    v16 = *a1;\n    if ( (unsigned int)(*a1 - 11) <= 2 )\n    {\n      if ( (unsigned __int8)sub_FFFFFFFF81302410((__int64)a1, v20) )\n        return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      v16 = *a1;\n    }\n    if ( v16 != 14 || !(unsigned __int8)sub_FFFFFFFF81302320((__int64)a1, v20) )\n    {\n      for ( i = 0; (unsigned __int8)sub_FFFFFFFF81302680((__int64)a1, i, v20); ++i )\n      {\n        result = sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v18, v19, a9, a10);\n        if ( (_DWORD)result )\n          return result;\n      }\n      return 0LL;\n    }\n    return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n  }\n  return result;\n}\n",
    "function_name": "acpi_dev_process_resource",
    "decompiled_code": "__int64 __fastcall acpi_dev_process_resource(\n        int *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 (__fastcall *v10)(int *, _QWORD, double, double, double, double, double, double, double, double); // rax\n  int v11; // eax\n  bool v12; // zf\n  __int64 result; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  int i; // r14d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned __int64 v20[11]; // [rsp+0h] [rbp-58h] BYREF\n\n  v10 = *(__int64 (__fastcall **)(int *, _QWORD, double, double, double, double, double, double, double, double))(a2 + 8);\n  if ( !v10 )\n    goto LABEL_6;\n  v11 = v10(a1, *(_QWORD *)(a2 + 16), a3, a4, a5, a6, a7, a8, a9, a10);\n  v12 = v11 == 0;\n  if ( v11 < 0 )\n  {\n    *(_DWORD *)(a2 + 28) = v11;\n    return 16387LL;\n  }\n  result = 0LL;\n  if ( v12 )\n  {\nLABEL_6:\n    memset(v20, 0, 0x38uLL);\n    if ( (unsigned __int8)acpi_dev_resource_memory(a1, v20) || (unsigned __int8)acpi_dev_resource_io((__int64)a1, v20) )\n      return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n    v16 = *a1;\n    if ( (unsigned int)(*a1 - 11) <= 2 )\n    {\n      if ( (unsigned __int8)acpi_dev_resource_address_space_part_2(a1, v20) )\n        return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      v16 = *a1;\n    }\n    if ( v16 != 14 || !(unsigned __int8)acpi_dev_resource_ext_address_space_part_1((__int64)a1, v20) )\n    {\n      for ( i = 0; (unsigned __int8)acpi_dev_resource_interrupt((__int64)a1, i, v20, a3, a4, a5, a6, v14, v15, a9, a10); ++i )\n      {\n        result = acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v18, v19, a9, a10);\n        if ( (_DWORD)result )\n          return result;\n      }\n      return 0LL;\n    }\n    return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n  }\n  return result;\n}\n",
    "source_code": "\nstatic acpi_status acpi_dev_process_resource(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct res_proc_context *c = context;\n\tstruct resource r;\n\tint i;\n\n\tif (c->preproc) {\n\t\tint ret;\n\n\t\tret = c->preproc(ares, c->preproc_data);\n\t\tif (ret < 0) {\n\t\t\tc->error = ret;\n\t\t\treturn AE_CTRL_TERMINATE;\n\t\t} else if (ret > 0) {\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tmemset(&r, 0, sizeof(r));\n\n\tif (acpi_dev_resource_memory(ares, &r)\n\t    || acpi_dev_resource_io(ares, &r)\n\t    || acpi_dev_resource_address_space(ares, &r)\n\t    || acpi_dev_resource_ext_address_space(ares, &r))\n\t\treturn acpi_dev_new_resource_entry(&r, c);\n\n\tfor (i = 0; acpi_dev_resource_interrupt(ares, i, &r); i++) {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_dev_new_resource_entry(&r, c);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t}\n\n\treturn AE_OK;\n}",
    "comment": "Processes ACPI resources by calling preprocessing functions, handling memory, I/O, and address space resources, and creating new resource entries as needed.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes ACPI devices by executing their _INI methods and counting the number of devices , while managing mutex locks for thread safety .\n",
    "cpbcs_sum": "Sets the rendering sequence variable for an Intel DVO device by validating access and calling the appropriate operation handler if needed.\n",
    "misum_sum": "Handles opening a specified request associated with a device by converting and invoking the appropriate event hook method.\n",
    "decom_sum": "Processes input through a sequence of validation and transformation routines, then updates the destination structure or error code based on the results.",
    "cfg_sum": "Validates and processes input data through multiple checks and subroutines, updates status on failure, and returns appropriate success or error codes.",
    "work_score": {
        "decom": {
            "summary": "Processes input through a sequence of validation and transformation routines, then updates the destination structure or error code based on the results.",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary is overly generic and does not reflect the specific domain semantics in the source code. It misses details such as handling of preproc callbacks with return value checks, resource type-specific functions for memory, I/O, and address spaces, looping through interrupts, and returning ACPI-specific status codes. Because it lacks these specifics, most of its claims are either low-information or unrelated to the code\u2019s precise behavior, resulting in less than half being accurate.",
                "The summary provides only a vague, generic description of 'validation and transformation routines' and updating structures or error codes, without explicitly covering the core purpose of processing ACPI resources into resource entries. It lacks domain-specific details about handling different resource types (memory, I/O, address space, interrupt), the use of a preprocessor callback, and specific branching behavior on errors and successes. While loosely accurate in referencing an error code update, it does not capture the primary function's ACPI resource processing semantics or other critical behaviors.",
                "The summary provides a generic description of validation, transformation, and updating a structure or error code, which aligns loosely with the code flow but lacks specificity on the domain semantics (ACPI resource processing, memory/IO/address/interrupt handling). There are no explicit inaccuracies, but the information gain is minimal because all claims are broad SAFE statements and omit key details about what resources are processed and how. The worst failure mode is NOISE from overly generic wording, reducing clarity about the primary purpose."
            ]
        },
        "cfg": {
            "summary": "Validates and processes input data through multiple checks and subroutines, updates status on failure, and returns appropriate success or error codes.",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary is mostly generic and does not capture specific domain-semantic behaviors such as invoking a preprocessor callback, handling specific ACPI resource types, iterating over interrupts, or terminating early based on errors. While it mentions validation, multiple checks, status updates, and return codes\u2014these are correct but boilerplate. Key implementation details from the source code are missing, reducing its informational accuracy.",
                "The summary makes only generic statements about validation, processing, status updates, and returning codes, which are [ACCURATE] but low-information. It does not capture the core primary purpose of processing ACPI resource structures into resource entries, nor does it mention specifics like preprocessor handling, different resource types (memory, I/O, address space, interrupts), or branching behavior. This leaves the core domain semantics uncovered and provides minimal secondary details.",
                "The summary captures the general idea that the function processes input data, performs checks, updates status on failure, and returns appropriate codes, which is accurate but very generic. It omits specific details about resource type handling (memory, IO, address spaces, interrupts) and the role of the preprocessor callback from the source. There are no contradictory or fatal claims, but the lack of domain-specific details limits usefulness. The worst failure mode here is low gain due to generic SAFE claims."
            ]
        },
        "comment": {
            "summary": "Processes ACPI resources by calling preprocessing functions, handling memory, I/O, and address space resources, and creating new resource entries as needed.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately states that the function processes ACPI resources, invokes a preprocessing function if present, and handles memory, I/O, and address space resources before creating new resource entries. It omits mention of interrupt resources handling and specific return behaviors, but all included claims align with the source code. As most claims are accurate and tied to actual code semantics, precision is high despite minor omissions.",
                "The summary correctly notes preprocessing via a preproc callback, handling of memory, I/O, and address space resources, and creation of new resource entries, which are all accurate reflections of the code. It captures the core purpose of processing various ACPI resource types into new entries. However, it omits mention of interrupt resource handling, error propagation logic via AE_CTRL_TERMINATE, and branching based on preprocessing return values, leaving secondary coverage incomplete.",
                "The summary correctly describes the main purpose of the function: it processes ACPI resources, optionally calls a preprocessing function, handles multiple resource types (memory, I/O, address space), and creates new resource entries. All stated behaviors match the source code and no inaccuracies or irrelevant noise are present. The claims provide accurate domain-semantic information, though they are somewhat broad and omit details like interrupt resource handling specifics and error handling branches, which limits the gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578993552,
    "strip_function_name": "sub_FFFFFFFF81024390",
    "strip_decompiled_code": "__int64 sub_FFFFFFFF81024390()\n{\n  __int64 result; // rax\n  unsigned int v6; // r12d\n  unsigned int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  int v10; // esi\n  const void *v11; // rbx\n  __int64 i; // rcx\n  __int64 v13; // [rsp+0h] [rbp-18h]\n\n  sub_FFFFFFFF81024340();\n  if ( (__readgsqword((unsigned int)&qword_10E24) & 8) != 0\n    && (__readgsqword((unsigned int)&qword_10E14) & 0x80000) != 0\n    && (int)__readgsdword((unsigned int)&dword_10E10) > 4 )\n  {\n    _RAX = 5LL;\n    __asm { cpuid }\n    v6 = 0;\n    if ( (_RCX & 1) != 0 )\n    {\n      v7 = (unsigned int)_RDX >> 4;\n      if ( (unsigned int)_RDX >> 4 )\n      {\n        v8 = 0;\n        v9 = 0;\n        v10 = 0;\n        do\n        {\n          if ( (v7 & 0xF) != 0 )\n          {\n            v9 = v10;\n            v8 = v7 & 0xF;\n          }\n          ++v10;\n          v7 >>= 4;\n        }\n        while ( v10 != 7 && v7 );\n        v6 = (v8 - 1) | (16 * v9);\n      }\n      else\n      {\n        v6 = -1;\n      }\n    }\n    v11 = (const void *)(__readgsqword(0xA760u) - 8136);\n    __wbinvd();\n    for ( i = 0LL; ; i = v13 )\n    {\n      do\n      {\n        do\n        {\n          _mm_clflush(v11);\n          _mm_monitor(v11, i, i);\n          _mm_mfence();\n          _mm_mwait(i, v6);\n        }\n        while ( __readgsdword(0xA030u) );\n      }\n      while ( !dword_FFFFFFFF81DD29DC );\n      v13 = i;\n      sub_FFFFFFFF810002A0();\n    }\n  }\n  result = sub_FFFFFFFF8152F750();\n  if ( (_DWORD)result )\n  {\n    if ( __readgsbyte((unsigned int)byte_10E00) > 3u )\n      __wbinvd();\n    __halt();\n  }\n  return result;\n}\n",
    "function_name": "native_play_dead",
    "decompiled_code": "__int64 native_play_dead()\n{\n  __int64 result; // rax\n  unsigned int v6; // r12d\n  unsigned int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  int v10; // esi\n  const void *v11; // rbx\n  __int64 i; // rcx\n  __int64 v13; // [rsp+0h] [rbp-18h]\n\n  play_dead_common();\n  if ( (__readgsqword((unsigned int)&qword_10E24) & 8) != 0\n    && (__readgsqword((unsigned int)&qword_10E14) & 0x80000) != 0\n    && (int)__readgsdword((unsigned int)&dword_10E10) > 4 )\n  {\n    _RAX = 5LL;\n    __asm { cpuid }\n    v6 = 0;\n    if ( (_RCX & 1) != 0 )\n    {\n      v7 = (unsigned int)_RDX >> 4;\n      if ( (unsigned int)_RDX >> 4 )\n      {\n        v8 = 0;\n        v9 = 0;\n        v10 = 0;\n        do\n        {\n          if ( (v7 & 0xF) != 0 )\n          {\n            v9 = v10;\n            v8 = v7 & 0xF;\n          }\n          ++v10;\n          v7 >>= 4;\n        }\n        while ( v10 != 7 && v7 );\n        v6 = (v8 - 1) | (16 * v9);\n      }\n      else\n      {\n        v6 = -1;\n      }\n    }\n    v11 = (const void *)(__readgsqword(0xA760u) - 8136);\n    __wbinvd();\n    for ( i = 0LL; ; i = v13 )\n    {\n      do\n      {\n        do\n        {\n          _mm_clflush(v11);\n          _mm_monitor(v11, i, i);\n          _mm_mfence();\n          _mm_mwait(i, v6);\n        }\n        while ( __readgsdword(0xA030u) );\n      }\n      while ( !enable_start_cpu0 );\n      v13 = i;\n      start_cpu0();\n    }\n  }\n  result = cpuidle_play_dead();\n  if ( (_DWORD)result )\n  {\n    if ( __readgsbyte((unsigned int)cpu_info) > 3u )\n      __wbinvd();\n    __halt();\n  }\n  return result;\n}\n",
    "source_code": "\nvoid native_play_dead(void)\n{\n\tplay_dead_common();\n\ttboot_shutdown(TB_SHUTDOWN_WFS);\n\n\tmwait_play_dead();\t/* Only returns on failure */\n\tif (cpuidle_play_dead())\n\t\thlt_play_dead();\n}",
    "comment": "Initiates a shutdown sequence and enters a low-power state, managing transitions based on CPU idle status and system power states.",
    "hext5_sum": " a choice for the \"order\" of the method, using the deuflhard criteria.",
    "bint5_sum": "Restores the local APIC state and re-enables IRQ remapping for various CPUs after a system suspend .\n",
    "cpbcs_sum": "Restores the local APIC state and registers the calling thread for the current CPU.\n",
    "misum_sum": "Calculates the number of CPU masks by iterating through the TSC thread based on the current task's cache state.\n",
    "decom_sum": "Initializes CPU idle state monitoring using MONITOR/MWAIT, flushes caches, and halts the processor when specific system flags and thresholds are met.",
    "cfg_sum": "Monitors CPU state for specific fault conditions, executes hardware wait loops, and halts the system if critical errors are detected.",
    "work_score": {
        "decom": {
            "summary": "Initializes CPU idle state monitoring using MONITOR/MWAIT, flushes caches, and halts the processor when specific system flags and thresholds are met.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary makes several claims about CPU idle state monitoring, flushing caches, and halting the processor based on system flags and thresholds. The source code does not show any cache flush operations or flag/threshold checks; instead, it sequentially calls functions like play_dead_common(), tboot_shutdown(), mwait_play_dead(), cpuidle_play_dead(), and hlt_play_dead(). The only partially related aspect is the halting behavior in hlt_play_dead(), but the rest of the claims are inaccurate or unrelated to the actual code, resulting in a low proportion of accurate statements.",
                "The summary's claims about CPU idle state monitoring, cache flushing, and halting on specific flags do not match the source code's core behavior. The function actually attempts to transition a CPU into a 'dead' state by invoking play_dead_common, triggering a trusted boot shutdown, using MWAIT to stay halted, and falling back to cpuidle or hlt methods on failure. None of these core semantics are accurately reflected, resulting in missing coverage of the primary purpose and critical steps.",
                "The summary introduces several claims\u2014CPU idle state monitoring with MONITOR/MWAIT, cache flushing, halting based on system flags and thresholds\u2014that are not reflected in the source code, which simply calls common play-dead routines, triggers tboot shutdown, and then attempts various play-dead methods. These mismatches are semantic errors that target the core purpose and behavior incorrectly, constituting a FATAL error on the main action. There are no accurate claims about the actual function, resulting in no positive gain and severe misinformation."
            ]
        },
        "cfg": {
            "summary": "Monitors CPU state for specific fault conditions, executes hardware wait loops, and halts the system if critical errors are detected.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims monitoring CPU state for fault conditions and halting on critical errors, which are not reflected in the source code. The code sequentially invokes functions for system shutdown and idle states without any explicit fault detection logic. None of the stated behaviors are directly supported, making the claims inaccurate relative to the actual semantics.",
                "The summary\u2019s claims about monitoring CPU state for faults and halting on critical errors are inaccurate with respect to the source code\u2019s semantics. The function\u2019s core purpose is to transition the CPU into a 'dead' power state by invoking play_dead_common, initiating a trusted boot shutdown, executing mwait, and falling back to cpuidle or hlt paths. The summary does not mention this shutdown/idle path at all, failing to cover the core domain operation and misrepresenting the intent as fault monitoring, leading to no alignment with the actual behavior.",
                "The summary introduces unrelated claims about monitoring CPU state and detecting critical errors, which are not evident in the source code. The actual function executes a sequence of shutdown and idle instructions (play_dead_common, tboot_shutdown, mwait_play_dead, cpuidle_play_dead, hlt_play_dead) without any explicit fault detection or monitoring logic. These inaccuracies directly target the core purpose and misrepresent the domain semantics, making them FATAL errors. No accurate, detailed claims are present, resulting in no net benefit."
            ]
        },
        "comment": {
            "summary": "Initiates a shutdown sequence and enters a low-power state, managing transitions based on CPU idle status and system power states.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function initiates a shutdown sequence and handles transitions to low-power states depending on CPU idle status, which aligns with calls to tboot_shutdown, mwait_play_dead, cpuidle_play_dead, and hlt_play_dead in the source. These claims are specific to the code\u2019s semantics and accurate, with no contradictory or irrelevant statements present.",
                "The summary captures the general idea of a shutdown and low-power transition, which aligns loosely with the function's sequences calling `tboot_shutdown`, `mwait_play_dead`, `cpuidle_play_dead`, and `hlt_play_dead`. However, it fails to explicitly state the core purpose: performing the native CPU 'play dead' procedure via `play_dead_common()` followed by specific shutdown mode and idle/failure handling. Key secondary details, like the specific shutdown type constant TB_SHUTDOWN_WFS and the branching to halt on cpuidle failure, are omitted. The coverage is generic and lacks the specific domain semantics required for strong alignment.",
                "The summary states that the function initiates a shutdown and enters a low-power state, adjusting based on CPU idle status and system power states. These claims align generally with the source code's call to shutdown functions and conditional CPU idle handling, making them accurate but generic. There are no contradictory or irrelevant claims (no FATAL, minimal NOISE), yet the description lacks specific detail about the exact sequence and functions invoked, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583981312,
    "strip_function_name": "sub_FFFFFFFF814E5F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814E5F00(__int64 *a1, unsigned int a2, unsigned __int16 *a3)\n{\n  __int64 v6; // r13\n  int v7; // edi\n  __int64 v8; // r15\n  int v9; // edi\n  __int64 result; // rax\n  __int64 v11; // r13\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // esi\n  __int64 v16; // [rsp+0h] [rbp-30h]\n\n  v6 = *a1;\n  v7 = *a3;\n  v8 = qword_FFFFFFFF81CC2000;\n  if ( (_WORD)v7 && (v16 = a1[3], v8 - v16 - sub_FFFFFFFF81042910(v7) < 0) )\n  {\n    v13 = sub_FFFFFFFF810427C0((int)v8 - *((_DWORD *)a1 + 6));\n    LOWORD(v14) = 0x7FFF;\n    v15 = *a3;\n    if ( a3[1] <= 0x7FFFu )\n      LOWORD(v14) = a3[1];\n    v14 = (unsigned __int16)v14;\n  }\n  else\n  {\n    v9 = a3[2];\n    if ( !(_WORD)v9 )\n      return a2;\n    if ( !*(_WORD *)(v6 + 10) )\n      return a2;\n    v11 = a1[4];\n    if ( v11 - sub_FFFFFFFF81042910(v9) - v8 >= 0 )\n      return a2;\n    v12 = a1[4];\n    if ( v8 - v12 >= 0 )\n      return a2;\n    v13 = sub_FFFFFFFF810427C0((int)v12 - (int)v8);\n    LOWORD(v14) = 0x7FFF;\n    v15 = a3[2];\n    if ( a3[3] <= 0x7FFFu )\n      LOWORD(v14) = a3[3];\n    v14 = (unsigned __int16)v14;\n  }\n  result = (unsigned int)(v14 + (int)((abs32(a2) - v14) * v13) / v15);\n  if ( (a2 & 0x80000000) != 0 )\n    return (unsigned int)-(int)result;\n  return result;\n}\n",
    "function_name": "apply_envelope",
    "decompiled_code": "__int64 __fastcall apply_envelope(__int64 *a1, unsigned int a2, unsigned __int16 *a3)\n{\n  __int64 v6; // r13\n  int v7; // edi\n  __int64 v8; // r15\n  int v9; // edi\n  __int64 result; // rax\n  __int64 v11; // r13\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // esi\n  __int64 v16; // [rsp+0h] [rbp-30h]\n\n  v6 = *a1;\n  v7 = *a3;\n  v8 = _vvar_beginning_hack;\n  if ( (_WORD)v7 && (v16 = a1[3], v8 - v16 - msecs_to_jiffies(v7) < 0) )\n  {\n    v13 = jiffies_to_msecs((int)v8 - *((_DWORD *)a1 + 6));\n    LOWORD(v14) = 0x7FFF;\n    v15 = *a3;\n    if ( a3[1] <= 0x7FFFu )\n      LOWORD(v14) = a3[1];\n    v14 = (unsigned __int16)v14;\n  }\n  else\n  {\n    v9 = a3[2];\n    if ( !(_WORD)v9 )\n      return a2;\n    if ( !*(_WORD *)(v6 + 10) )\n      return a2;\n    v11 = a1[4];\n    if ( v11 - msecs_to_jiffies(v9) - v8 >= 0 )\n      return a2;\n    v12 = a1[4];\n    if ( v8 - v12 >= 0 )\n      return a2;\n    v13 = jiffies_to_msecs((int)v12 - (int)v8);\n    LOWORD(v14) = 0x7FFF;\n    v15 = a3[2];\n    if ( a3[3] <= 0x7FFFu )\n      LOWORD(v14) = a3[3];\n    v14 = (unsigned __int16)v14;\n  }\n  result = (unsigned int)(v14 + (int)((abs32(a2) - v14) * v13) / v15);\n  if ( (a2 & 0x80000000) != 0 )\n    return (unsigned int)-(int)result;\n  return result;\n}\n",
    "source_code": "static int apply_envelope(struct ml_effect_state *state, int value,\n\t\t\t  struct ff_envelope *envelope)\n{\n\tstruct ff_effect *effect = state->effect;\n\tunsigned long now = jiffies;\n\tint time_from_level;\n\tint time_of_envelope;\n\tint envelope_level;\n\tint difference;\n\n\tif (envelope->attack_length &&\n\t    time_before(now,\n\t\t\tstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\n\t\tpr_debug(\"value = 0x%x, attack_level = 0x%x\\n\",\n\t\t\t value, envelope->attack_level);\n\t\ttime_from_level = jiffies_to_msecs(now - state->play_at);\n\t\ttime_of_envelope = envelope->attack_length;\n\t\tenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\n\n\t} else if (envelope->fade_length && effect->replay.length &&\n\t\t   time_after(now,\n\t\t\t      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\n\t\t   time_before(now, state->stop_at)) {\n\t\ttime_from_level = jiffies_to_msecs(state->stop_at - now);\n\t\ttime_of_envelope = envelope->fade_length;\n\t\tenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\n\t} else\n\t\treturn value;\n\n\tdifference = abs(value) - envelope_level;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\tpr_debug(\"time_from_level = 0x%x\\n\", time_from_level);\n\tpr_debug(\"time_of_envelope = 0x%x\\n\", time_of_envelope);\n\n\tdifference = difference * time_from_level / time_of_envelope;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\n\treturn value < 0 ?\n\t\t-(difference + envelope_level) : (difference + envelope_level);\n}",
    "comment": "Adjusts the input value based on an attack or fade envelope, modifying the output according to the elapsed time and specified envelope levels.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Processes input events , updates mouse device state , and manages timer interrupt based on current time and previous state changes .\n",
    "cpbcs_sum": "Processes USB request blocks by checking their status and time constraints, then moves them to a timer for further handling.\n",
    "misum_sum": "Processes mouse input events by a value to a specified value, retrying on an effect reply and waking up to a multiple times if found.\n",
    "decom_sum": "Adjusts the input value toward a target limit based on buffer space calculations and scaling parameters from the provided configuration structure.",
    "cfg_sum": "Computes an adjusted scaled value from input parameters after validating memory constraints and conditions, returning the signed result or original value if checks fail.",
    "work_score": {
        "decom": {
            "summary": "Adjusts the input value toward a target limit based on buffer space calculations and scaling parameters from the provided configuration structure.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function adjusts the input value based on buffer space calculations and scaling parameters from a configuration structure. In reality, the source code applies an envelope to the value using attack/fade lengths and levels from an ff_envelope structure, with timing based on `state->play_at` and `state->stop_at`. There is no buffer space calculation or generic configuration scaling, so the claims are domain-specific but incorrect, resulting in 0% accurate claims.",
                "The summary's claim about adjusting input based on buffer space and scaling parameters does not match the function's actual core, which is computing an adjusted effect strength based on attack/fade envelope parameters and timing. The description is inaccurate in domain semantics and fails to cover the concrete purpose of applying an envelope to a force feedback effect value. There is no coverage of the timing logic, attack/fade levels, or side effects such as debug logging, leaving both core and secondary behaviors unaddressed.",
                "The summary's claim about adjusting input value toward a target limit based on buffer space calculations and configuration scaling is inaccurate with respect to the source code. The function actually applies an envelope adjustment based on attack or fade parameters from a force-feedback envelope structure, involving timing and level computations, not buffer space. This represents a severe factual contradiction about the primary purpose and core semantics, resulting in a FATAL error that makes the description unreliable."
            ]
        },
        "cfg": {
            "summary": "Computes an adjusted scaled value from input parameters after validating memory constraints and conditions, returning the signed result or original value if checks fail.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains one main claim: it computes an adjusted scaled value after validating memory constraints and conditions, returning signed result or original value if checks fail. The scaling and conditional return parts align broadly with the code, but the mention of 'validating memory constraints' is inaccurate\u2014the source performs time-based envelope checks, not memory validation. This introduces a significant incorrect semantic element, so less than half of the claim content is accurate.",
                "The summary misses the core purpose of adjusting the input value based on attack and fade envelope timing for a force-feedback effect. While it vaguely notes computing an adjusted scaled value with conditional checks, it inaccurately introduces 'validating memory constraints' which is not present in the source code, and omits key domain details like attack_length, fade_length, time calculations, and envelope levels. Core domain semantics are not covered, and secondary behaviors such as debug logging and condition branches are not addressed.",
                "The summary incorrectly introduces a claim about validating memory constraints, which is absent from the source code and constitutes a FATAL error regarding the function\u2019s primary purpose. The actual core logic adjusts the input value based on envelope attack or fade conditions and timing; the summary omits these key domain-specific details and provides only generic statements about conditions and returning original value. Noise from inaccurate memory validation claim overwhelms the few weakly correct generic remarks, yielding minimal net benefit."
            ]
        },
        "comment": {
            "summary": "Adjusts the input value based on an attack or fade envelope, modifying the output according to the elapsed time and specified envelope levels.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function adjusts the input value based on either an attack or fade envelope, factoring in elapsed time and envelope levels. These behaviors are directly reflected in the source code through conditions checking attack_length and fade_length, computing level adjustments over time. The summary is accurate, though it omits minor implementation details such as specific limits and debug logging, but these are not essential to core semantics, resulting in high alignment.",
                "The summary correctly identifies that the function adjusts an input value based on attack or fade envelopes and factors in elapsed time and envelope levels, which matches the core purpose of applying envelope shaping to a force-feedback effect value. However, it omits secondary details such as handling both attack and fade conditions separately, the use of jiffies for timing, the replay length check for fade, debug logging, and min value constraints. These missing specifics limit coverage of other critical behavior aspects.",
                "The summary contains one concise claim describing that the function adjusts the input based on an attack or fade envelope considering elapsed time and envelope levels. This is accurate and reflects the core purpose in the source, which computes attack or fade adjustments over time using specified envelope levels. There are no contradictory or irrelevant statements, but the claim is fairly generic and lacks detail about the exact computations, scaling, and conditions, keeping the gain low."
            ]
        }
    }
}
{
    "project_name": "squashfs",
    "function_addr": 55264,
    "strip_function_name": "sub_D7E0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_D7E0(char *path, int a2)\n{\n  char *v4; // rax\n  void **v5; // r13\n  unsigned int v6; // ebp\n  char *v7; // rbx\n  int v8; // edi\n  int v9; // esi\n  unsigned int v10; // [rsp+4h] [rbp-34h] BYREF\n  unsigned __int64 v11; // [rsp+8h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  if ( dword_293988 || a2 == -1 || *((_QWORD *)&xmmword_293A30 + 1) == -1LL )\n    return __readfsqword(0x28u) ^ v11;\n  v4 = sub_D460(a2, &v10, 1);\n  v5 = (void **)v4;\n  if ( !v4 )\n  {\n    sub_3A90();\n    return __readfsqword(0x28u) ^ v11;\n  }\n  v6 = 0;\n  v7 = v4 + 8;\n  if ( v10 )\n  {\n    while ( 1 )\n    {\n      if ( dword_213694 )\n      {\n        if ( !v7[24] )\n          goto LABEL_9;\n      }\n      else\n      {\n        if ( dword_313B28 || !v7[24] )\n        {\nLABEL_9:\n          if ( lsetxattr(path, *(const char **)v7, *((const void **)v7 + 2), *((int *)v7 + 3), 0) == -1 )\n          {\n            v8 = *__errno_location();\n            if ( v8 == 95 )\n            {\n              sub_3A90();\n              sub_3A90();\n              sub_3A90();\n              dword_293988 = 1;\n            }\n            else if ( (v8 == 28 || v8 == 122) && dword_293984 <= 9 )\n            {\n              sub_3A90();\n              if ( ++dword_293984 == 10 )\n                sub_3A90();\n            }\n            else\n            {\n              strerror(v8);\n              sub_3A90();\n            }\n          }\n          goto LABEL_10;\n        }\n        if ( !dword_293980 )\n        {\n          sub_3A90();\n          sub_3A90();\n          sub_3A90();\n          dword_293980 = 1;\n        }\n      }\nLABEL_10:\n      v9 = v10;\n      ++v6;\n      v7 += 64;\n      if ( v6 >= v10 )\n        goto LABEL_21;\n    }\n  }\n  v9 = 0;\nLABEL_21:\n  sub_D420(v5, v9);\n  return __readfsqword(0x28u) ^ v11;\n}\n",
    "function_name": "write_xattr",
    "decompiled_code": "unsigned __int64 __fastcall write_xattr(char *path, int a2)\n{\n  char *xattr; // rax\n  void **v5; // r13\n  unsigned int v6; // ebp\n  char *v7; // rbx\n  int v8; // edi\n  int v9; // esi\n  unsigned int v10; // [rsp+4h] [rbp-34h] BYREF\n  unsigned __int64 v11; // [rsp+8h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  if ( ignore_xattrs_10143 || a2 == -1 || *((_QWORD *)&xmmword_293A30 + 1) == -1LL )\n    return __readfsqword(0x28u) ^ v11;\n  xattr = get_xattr(a2, &v10, 1);\n  v5 = (void **)xattr;\n  if ( !xattr )\n  {\n    progressbar_error();\n    return __readfsqword(0x28u) ^ v11;\n  }\n  v6 = 0;\n  v7 = xattr + 8;\n  if ( v10 )\n  {\n    while ( 1 )\n    {\n      if ( user_xattrs )\n      {\n        if ( !v7[24] )\n          goto LABEL_9;\n      }\n      else\n      {\n        if ( root_process || !v7[24] )\n        {\nLABEL_9:\n          if ( lsetxattr(path, *(const char **)v7, *((const void **)v7 + 2), *((int *)v7 + 3), 0) == -1 )\n          {\n            v8 = *__errno_location();\n            if ( v8 == 95 )\n            {\n              progressbar_error();\n              progressbar_error();\n              progressbar_error();\n              ignore_xattrs_10143 = 1;\n            }\n            else if ( (v8 == 28 || v8 == 122) && nospace_error_10144 <= 9 )\n            {\n              progressbar_error();\n              if ( ++nospace_error_10144 == 10 )\n                progressbar_error();\n            }\n            else\n            {\n              strerror(v8);\n              progressbar_error();\n            }\n          }\n          goto LABEL_10;\n        }\n        if ( !nonsuper_error_10142 )\n        {\n          progressbar_error();\n          progressbar_error();\n          progressbar_error();\n          nonsuper_error_10142 = 1;\n        }\n      }\nLABEL_10:\n      v9 = v10;\n      ++v6;\n      v7 += 64;\n      if ( v6 >= v10 )\n        goto LABEL_21;\n    }\n  }\n  v9 = 0;\nLABEL_21:\n  free_xattr(v5, v9);\n  return __readfsqword(0x28u) ^ v11;\n}\n",
    "source_code": "\nvoid write_xattr(char *pathname, unsigned int xattr)\n{\n\tunsigned int count;\n\tstruct xattr_list *xattr_list;\n\tint i;\n\tstatic int nonsuper_error = FALSE;\n\tstatic int ignore_xattrs = FALSE;\n\tstatic int nospace_error = 0;\n\n\tif(ignore_xattrs || xattr == SQUASHFS_INVALID_XATTR ||\n\t\t\tsBlk.s.xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn;\n\n\txattr_list = get_xattr(xattr, &count, 1);\n\tif(xattr_list == NULL) {\n\t\tERROR(\"Failed to read xattrs for file %s\\n\", pathname);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < count; i++) {\n\t\tint prefix = xattr_list[i].type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif(user_xattrs && prefix != SQUASHFS_XATTR_USER)\n\t\t\tcontinue;\n\n\t\tif(root_process || prefix == SQUASHFS_XATTR_USER) {\n\t\t\tint res = lsetxattr(pathname, xattr_list[i].full_name,\n\t\t\t\txattr_list[i].value, xattr_list[i].vsize, 0);\n\n\t\t\tif(res == -1) {\n\t\t\t\tif(errno == ENOTSUP) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the destination filesystem cannot\n\t\t\t\t\t * suppport xattrs, print error, and\n\t\t\t\t\t * disable xattr output as this error is\n\t\t\t\t\t * unlikely to go away, and printing\n\t\t\t\t\t * screenfulls of the same error message\n\t\t\t\t\t * is rather annoying\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"extended attributes are not \"\n\t\t\t\t\t\t\"supported by the destination \"\n\t\t\t\t\t\t\"filesystem\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tERROR(\"Ignoring xattrs in \"\n\t\t\t\t\t\t\t\t\"filesystem\\n\");\n\t\t\t\t\tERROR(\"To avoid this error message, \"\n\t\t\t\t\t\t\"specify -no-xattrs\\n\");\n\t\t\t\t\tignore_xattrs = TRUE;\n\t\t\t\t} else if((errno == ENOSPC || errno == EDQUOT)\n\t\t\t\t\t\t&& nospace_error < NOSPACE_MAX) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Many filesystems like ext2/3/4 have\n\t\t\t\t\t * limits on the amount of xattr\n\t\t\t\t\t * data that can be stored per file\n\t\t\t\t\t * (typically one block or 4K), so\n\t\t\t\t\t * we shouldn't disable xattr ouput,\n\t\t\t\t\t * as the error may be restriced to one\n\t\t\t\t\t * file only.  If we get a lot of these\n\t\t\t\t\t * then suppress the error messsage\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"no extended attribute space \"\n\t\t\t\t\t\t\"remaining (per file or \"\n\t\t\t\t\t\t\"filesystem limit)\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tif(++ nospace_error == NOSPACE_MAX)\n\t\t\t\t\t\tERROR(\"%d of these errors \"\n\t\t\t\t\t\t\t\"printed, further error \"\n\t\t\t\t\t\t\t\"messages of this type \"\n\t\t\t\t\t\t\t\"are suppressed!\\n\",\n\t\t\t\t\t\t\tNOSPACE_MAX);\n\t\t\t\t} else\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \"\n\t\t\t\t\t\t\"%s\\n\", xattr_list[i].full_name,\n\t\t\t\t\t\tpathname, strerror(errno));\n\t\t\t}\n\t\t} else if(nonsuper_error == FALSE) {\n\t\t\t/*\n\t\t\t * if extract user xattrs only then\n\t\t\t * error message is suppressed, if not\n\t\t\t * print error, and then suppress further error\n\t\t\t * messages to avoid possible screenfulls of the\n\t\t\t * same error message!\n\t\t\t */\n\t\t\tERROR(\"write_xattr: could not write xattr %s \"\n\t\t\t\t\t\"for file %s because you're not \"\n\t\t\t\t\t\"superuser!\\n\",\n\t\t\t\t\txattr_list[i].full_name, pathname);\n\t\t\tERROR(\"write_xattr: to avoid this error message, either\"\n\t\t\t\t\" specify -user-xattrs, -no-xattrs, or run as \"\n\t\t\t\t\"superuser!\\n\");\n\t\t\tERROR(\"Further error messages of this type are \"\n\t\t\t\t\"suppressed!\\n\");\n\t\t\tnonsuper_error = TRUE;\n\t\t}\n\t}\n\n\tfree_xattr(xattr_list, count);\n}",
    "comment": "Writes extended attributes to a specified file while handling errors for unsupported filesystems, space limitations, and non-superuser access.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a backup file to a specified disk path if it exists and is not a directory , returning success status .\n",
    "cpbcs_sum": "Retrieves the target file path for a specified directory or user directory path based on the provided filename and directory name.\n",
    "misum_sum": "Searches for a matching process based on the given name and type, checking the validity and directory validity against predefined criteria.\n",
    "decom_sum": "Sets multiple extended file attributes on a given path from a retrieved list, handling specific errno cases and tracking operation limits.",
    "cfg_sum": "Sets extended file attributes for a given path based on runtime flags, handling specific errno cases and updating related global status variables.",
    "work_score": {
        "decom": {
            "summary": "Sets multiple extended file attributes on a given path from a retrieved list, handling specific errno cases and tracking operation limits.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function sets multiple extended file attributes from a retrieved list and handles specific errno cases, which aligns with the code's looping over attributes, calling lsetxattr, and branching based on errno values. It also notes tracking operation limits, reflected in the nospace_error counter and suppression logic. While concise, all claims are directly supported by the source code, with no inaccuracies or irrelevant details.",
                "The summary correctly identifies that the function sets multiple extended attributes on a specified path from a retrieved list and handles specific errno cases, which matches the core purpose and some secondary behaviors. However, it omits important conditional logic such as ignoring xattrs under certain flags, filtering by user xattrs, superuser requirement handling, detailed suppression of repeated errors, and freeing xattr resources afterward. These omissions limit coverage of critical branches and side effects in the source code.",
                "The summary correctly states that the function sets multiple extended attributes on a given path from a retrieved list, and handles specific errno cases. It omits mention of important control flows such as skipping non-user xattrs when the user_xattrs flag is set, handling superuser restrictions, and disabling xattr output in certain conditions. The claims made are accurate but generic, offering low detail about the selection logic and suppression mechanisms. No inaccurate or contradictory statements are present, but the gain is low due to missing specific behaviors."
            ]
        },
        "cfg": {
            "summary": "Sets extended file attributes for a given path based on runtime flags, handling specific errno cases and updating related global status variables.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function sets extended attributes on a given path and references runtime flags, error handling for specific errno values, and updates to global status variables. All these elements are present in the source code, with no apparent contradictions or irrelevant noise. While concise, it captures the main domain-specific behavior accurately.",
                "The summary accurately captures the core functionality of setting extended file attributes for a given path and notes runtime flag influences, which reflects the function\u2019s main purpose. It also mentions handling specific errno cases and updating global status variables, which aligns with the code\u2019s error handling for unsupported xattrs, no space, and permission issues. However, it lacks specificity on conditions governing which xattrs are written (like user_xattrs, root_process checks) and the suppression logic for repeated errors, meaning secondary coverage is incomplete.",
                "The summary correctly captures the core function purpose of setting extended attributes for a file path and notes handling of specific errno cases along with updating global status flags, which matches the code. It omits detailed conditions such as filtering by attribute type and user/superuser checks, but there are no inaccurate claims or contradictions. The claims are generally accurate but generic, providing only moderate insight into the behavior."
            ]
        },
        "comment": {
            "summary": "Writes extended attributes to a specified file while handling errors for unsupported filesystems, space limitations, and non-superuser access.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function writes extended attributes to a specified file and handles errors for unsupported filesystems, space limitations, and non-superuser access. All these behaviors are directly reflected in the source code's logic and error handling paths. The claims are accurate, specific to the code semantics, and no contradictory or irrelevant information is present, indicating very high alignment with the evaluation steps.",
                "The summary correctly identifies the core purpose of writing extended attributes to a specified file, which matches the function's main behavior. It also mentions key error-handling cases for unsupported filesystems, space limitations, and non-superuser access. However, it omits other important details such as ignoring xattrs under certain conditions before processing, filtering based on user_xattrs and prefix type, and suppression of repeated error messages, limiting coverage of secondary behaviors.",
                "The summary accurately captures the core purpose of the function\u2014writing extended attributes to a specified file\u2014and correctly notes the main error handling cases for unsupported filesystems, out-of-space conditions, and non-superuser access, all of which are explicitly present in the source code. It omits some details such as selective processing of user xattrs and suppression of repeated errors, but there are no false or irrelevant claims. The claims are correct but relatively broad and low in specificity, providing moderate insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579258624,
    "strip_function_name": "sub_FFFFFFFF81064F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81064F00(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  _QWORD v20[2]; // [rsp+0h] [rbp-48h] BYREF\n  int v21; // [rsp+10h] [rbp-38h] BYREF\n  _BYTE v22[48]; // [rsp+18h] [rbp-30h] BYREF\n\n  sub_FFFFFFFF81790F30(a1);\n  v21 = 0;\n  sub_FFFFFFFF81060710((__int64)v22);\n  v20[0] = 0LL;\n  v20[1] = sub_FFFFFFFF81064B80;\n  sub_FFFFFFFF81792630(a1 + 16);\n  if ( *(_BYTE *)(a1 + 18) )\n  {\n    **(_QWORD **)(a1 + 32) = v20;\n    *(_QWORD *)(a1 + 32) = v20;\n    ++*(_BYTE *)(a1 + 16);\n    _enable();\n    return sub_FFFFFFFF81790F70(&v21);\n  }\n  v11 = *(_QWORD **)(a1 + 48);\n  *(_BYTE *)(a1 + 18) = 1;\n  *v11 = v20;\n  *(_QWORD *)(a1 + 48) = v20;\n  ++*(_BYTE *)(a1 + 16);\n  _enable();\n  sub_FFFFFFFF81064D70(a1, a2);\n  v17 = *(_QWORD **)(a1 + 80);\n  v18 = a1 + 72;\n  if ( v17 == (_QWORD *)(a1 + 72) )\n  {\n    sub_FFFFFFFF81064E60(a1, a3, a4, a5, a6, v15, v16, a9, a10, a2, v18, v12, v13, v14);\n    return sub_FFFFFFFF81790F70(&v21);\n  }\n  if ( *(_QWORD **)(a1 + 72) != v20 )\n    BUG();\n  v19 = v20[0];\n  *(_QWORD *)(a1 + 72) = v20[0];\n  if ( v17 == v20 )\n  {\n    *(_QWORD *)(a1 + 72) = 0LL;\n    *(_QWORD *)(a1 + 80) = v18;\n  }\n  return sub_FFFFFFFF81064E60(a1, a3, a4, a5, a6, v15, v16, a9, a10, a2, v18, v19, v13, v14);\n}\n",
    "function_name": "__synchronize_srcu",
    "decompiled_code": "__int64 __fastcall _synchronize_srcu(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned int v10; // r13d\n  __int64 v11; // rsi\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  _QWORD *v18; // rax\n  _QWORD v19[2]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned int v20; // [rsp+10h] [rbp-38h] BYREF\n  _BYTE v21[48]; // [rsp+18h] [rbp-30h] BYREF\n\n  v10 = a2;\n  cond_resched(a1, a2);\n  v11 = (__int64)\"&x->wait\";\n  v20 = 0;\n  _init_waitqueue_head((__int64)v21);\n  v19[0] = 0LL;\n  v19[1] = wakeme_after_rcu_0;\n  raw_spin_lock_irq((volatile signed __int16 *)(a1 + 16));\n  if ( *(_BYTE *)(a1 + 18) )\n  {\n    **(_QWORD **)(a1 + 32) = v19;\n    *(_QWORD *)(a1 + 32) = v19;\n    ++*(_BYTE *)(a1 + 16);\n    _enable();\n    return wait_for_completion(&v20, v11, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  v15 = *(_QWORD **)(a1 + 48);\n  *(_BYTE *)(a1 + 18) = 1;\n  *v15 = v19;\n  *(_QWORD *)(a1 + 48) = v19;\n  ++*(_BYTE *)(a1 + 16);\n  _enable();\n  v11 = v10;\n  srcu_advance_batches(a1, v10);\n  v18 = *(_QWORD **)(a1 + 80);\n  if ( v18 == (_QWORD *)(a1 + 72) )\n  {\n    srcu_reschedule(a1, a3, a4, a5, a6, v16, v17, a9, a10);\n    return wait_for_completion(&v20, v11, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  if ( *(_QWORD **)(a1 + 72) != v19 )\n    BUG();\n  *(_QWORD *)(a1 + 72) = v19[0];\n  if ( v18 == v19 )\n  {\n    *(_QWORD *)(a1 + 72) = 0LL;\n    *(_QWORD *)(a1 + 80) = a1 + 72;\n  }\n  return srcu_reschedule(a1, a3, a4, a5, a6, v16, v17, a9, a10);\n}\n",
    "source_code": "static void __synchronize_srcu(struct srcu_struct *sp, int trycount)\n{\n\tstruct rcu_synchronize rcu;\n\tstruct rcu_head *head = &rcu.head;\n\tbool done = false;\n\n\trcu_lockdep_assert(!lock_is_held(&sp->dep_map) &&\n\t\t\t   !lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"Illegal synchronize_srcu() in same-type SRCU (or RCU) read-side critical section\");\n\n\tmight_sleep();\n\tinit_completion(&rcu.completion);\n\n\thead->next = NULL;\n\thead->func = wakeme_after_rcu;\n\tspin_lock_irq(&sp->queue_lock);\n\tif (!sp->running) {\n\t\t/* steal the processing owner */\n\t\tsp->running = true;\n\t\trcu_batch_queue(&sp->batch_check0, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\n\t\tsrcu_advance_batches(sp, trycount);\n\t\tif (!rcu_batch_empty(&sp->batch_done)) {\n\t\t\tBUG_ON(sp->batch_done.head != head);\n\t\t\trcu_batch_dequeue(&sp->batch_done);\n\t\t\tdone = true;\n\t\t}\n\t\t/* give the processing owner to work_struct */\n\t\tsrcu_reschedule(sp);\n\t} else {\n\t\trcu_batch_queue(&sp->batch_queue, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\t}\n\n\tif (!done)\n\t\twait_for_completion(&rcu.completion);\n}",
    "comment": "Synchronizes SRCU processing by queuing a completion task and waiting for it to finish if not already done by the processing owner.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Cleans up and frees resources associated with a task structure , ensuring it is not in use before releasing its memory .\n",
    "cpbcs_sum": "Handles the cancellation of a scheduled timer by executing a callback and managing its states in a cgroup, manner.\n",
    "misum_sum": "Flushes a workqueue by executing its control function, updating its state, managing its states and ensuring thread safety with a mutex lock.\n",
    "decom_sum": "Initializes and links internal queue structures, enables interrupts, and processes queued double-precision parameters through a device-specific handler.",
    "cfg_sum": "Initializes and links internal data structures, updates state flags and pointers, calls processing routines, and re-enables interrupts to maintain synchronized execution flow.",
    "work_score": {
        "decom": {
            "summary": "Initializes and links internal queue structures, enables interrupts, and processes queued double-precision parameters through a device-specific handler.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about initializing and linking internal queue structures are loosely related to the code, but the statements about enabling interrupts and processing double-precision parameters through a device-specific handler are entirely inaccurate and unrelated to the SRCU synchronization logic shown. Most claims do not match the source code's actual functions and operations, resulting in very low accuracy.",
                "The summary's claims about processing double-precision parameters and using a device-specific handler are unrelated to the code, which handles SRCU synchronization, RCU batch queuing, and completion waiting. None of the [ACCURATE] claims capture the core purpose of advancing and completing SRCU batches safely, and the stated behaviors contradict the domain actions in the source.",
                "The summary's claims about enabling interrupts and processing double-precision parameters via a device-specific handler are entirely inaccurate and unrelated to the actual source code. The function manages SRCU synchronization by asserting lock conditions, queuing work, and waiting for completion, not handling numeric parameters or device I/O. This is a severe FATAL error misrepresenting the primary purpose, making the summary untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Initializes and links internal data structures, updates state flags and pointers, calls processing routines, and re-enables interrupts to maintain synchronized execution flow.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly generic descriptions like 'initializes and links internal data structures' and 'updates state flags and pointers' without accurately reflecting specific, verifiable behaviors from the source code such as lock dependency assertions, sleep possibility, SRCU batch queue management, or waiting for completion. These vague statements do not specifically target the code's unique semantics, resulting in low alignment with the evaluation steps.",
                "The summary only offers vague, generic descriptions like initializing data structures, updating state, calling routines, and handling interrupts, without specific mention of the function's core purpose: queuing and advancing SRCU batches, enforcing lock assertions, and waiting for SRCU grace periods. These domain-specific semantics are missing, so the core is not covered and there is little accurate secondary detail.",
                "The summary makes broad, generic statements about initializing data structures, updating state, and calling routines, which loosely correspond to some code actions like init_completion and rcu_batch_queue. However, it omits critical contractual behaviors such as lockdep assertions, queue selection based on running state, and completion waiting, and inaccurately mentions re-enabling interrupts, which is not a core action here. This introduces noticeable noise and provides very low informational gain, with no FATAL errors but weak alignment to source semantics."
            ]
        },
        "comment": {
            "summary": "Synchronizes SRCU processing by queuing a completion task and waiting for it to finish if not already done by the processing owner.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary makes one main claim: that the function synchronizes SRCU by queuing a completion task and waiting if not already done. This matches the code\u2019s behavior where a completion object is initialized, queued via rcu_batch_queue, and waited on with wait_for_completion unless already processed. While the summary lacks detail about lock assertions, batch advancement, or specific queues, the core synchronization behavior is accurately represented, and there are no incorrect statements. This yields a high proportion of accurate claims (>80%).",
                "The summary correctly identifies that the function deals with synchronizing SRCU and involves queuing a completion task and waiting for completion, which covers the core purpose of waiting for an SRCU grace period via queued work. However, it omits important secondary semantics from the source, such as the lockdep assertions preventing illegal calls in critical sections, initialization of completion structures, conditional handling when SRCU is not running (advancing batches, dequeuing, marking done), alternate queuing path when another thread is processing, and the use of specific spin locks and batch queues. These omissions reduce coverage of the behavior-critical details.",
                "The summary correctly captures the core purpose of the function: coordinating SRCU synchronization by queuing a task and waiting for completion when necessary. It reflects the key logic of queuing to either the batch_check0 or batch_queue and waiting unless already done, without introducing inaccuracies. However, it omits important specifics such as locking assertions, initialization steps, and conditional batch advancement, limiting detail and engineering value. No factual errors are present, but gain is modest due to generic phrasing."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579041760,
    "strip_function_name": "sub_FFFFFFFF8102FFE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8102FFE0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 *v6; // r14\n  unsigned __int64 v7; // rbx\n  unsigned __int64 v8; // rsi\n  __int64 result; // rax\n  __int64 v10; // rax\n  unsigned __int64 v11; // rdx\n  __int64 v12; // rdx\n  unsigned __int64 v13; // [rsp+0h] [rbp-38h]\n  unsigned __int64 v14; // [rsp+0h] [rbp-38h]\n  __int64 v15; // [rsp+8h] [rbp-30h]\n\n  v15 = *(_BYTE *)(a1 + 24) != 0 ? 0x110 : 0;\n  if ( a3 < a4 )\n  {\n    do\n    {\n      v6 = (unsigned __int64 *)(a2 + 8 * (v15 + ((a3 >> 39) & 0x1FF)));\n      v7 = (a3 & 0xFFFFFF8000000000LL) + 0x8000000000LL;\n      v8 = *v6;\n      if ( a4 <= v7 )\n        v7 = a4;\n      if ( (v8 & 1) != 0 )\n      {\n        result = sub_FFFFFFFF8102FCE0(a1, (v8 & 0x3FFFFFFFF000LL) - 0x780000000000LL, a3, v7);\n        if ( (_DWORD)result )\n          return result;\n      }\n      else\n      {\n        v13 = a3;\n        v10 = (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));\n        if ( !v10 )\n          return 4294967284LL;\n        v11 = v13;\n        v14 = v10;\n        result = sub_FFFFFFFF8102FCE0(a1, v10, v11, v7);\n        if ( (_DWORD)result )\n          return result;\n        v12 = 0x77FF80000000LL;\n        if ( v14 >= 0xFFFFFFFF80000000LL )\n          v12 = qword_FFFFFFFF81C10010;\n        *v6 = (v12 + v14 + 0x80000000) | 0x63;\n      }\n      a3 = v7;\n    }\n    while ( v7 < a4 );\n  }\n  return 0LL;\n}\n",
    "function_name": "kernel_ident_mapping_init",
    "decompiled_code": "__int64 __fastcall kernel_ident_mapping_init(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 *v6; // r14\n  unsigned __int64 v7; // rbx\n  unsigned __int64 v8; // rsi\n  __int64 result; // rax\n  __int64 v10; // rax\n  unsigned __int64 v11; // rdx\n  __int64 v12; // rdx\n  unsigned __int64 v13; // [rsp+0h] [rbp-38h]\n  unsigned __int64 v14; // [rsp+0h] [rbp-38h]\n  __int64 v15; // [rsp+8h] [rbp-30h]\n\n  v15 = *(_BYTE *)(a1 + 24) != 0 ? 0x110 : 0;\n  if ( a3 < a4 )\n  {\n    do\n    {\n      v6 = (unsigned __int64 *)(a2 + 8 * (v15 + ((a3 >> 39) & 0x1FF)));\n      v7 = (a3 & 0xFFFFFF8000000000LL) + 0x8000000000LL;\n      v8 = *v6;\n      if ( a4 <= v7 )\n        v7 = a4;\n      if ( (v8 & 1) != 0 )\n      {\n        result = ident_pud_init(a1, (v8 & 0x3FFFFFFFF000LL) - 0x780000000000LL, a3, v7);\n        if ( (_DWORD)result )\n          return result;\n      }\n      else\n      {\n        v13 = a3;\n        v10 = (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));\n        if ( !v10 )\n          return 4294967284LL;\n        v11 = v13;\n        v14 = v10;\n        result = ident_pud_init(a1, v10, v11, v7);\n        if ( (_DWORD)result )\n          return result;\n        v12 = 0x77FF80000000LL;\n        if ( v14 >= 0xFFFFFFFF80000000LL )\n          v12 = phys_base;\n        *v6 = (v12 + v14 + 0x80000000) | 0x63;\n      }\n      a3 = v7;\n    }\n    while ( v7 < a4 );\n  }\n  return 0LL;\n}\n",
    "source_code": "\nint kernel_ident_mapping_init(struct x86_mapping_info *info, pgd_t *pgd_page,\n\t\t\t      unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\tint result;\n\tint off = info->kernel_mapping ? pgd_index(__PAGE_OFFSET) : 0;\n\n\tfor (; addr < end; addr = next) {\n\t\tpgd_t *pgd = pgd_page + pgd_index(addr) + off;\n\t\tpud_t *pud;\n\n\t\tnext = (addr & PGDIR_MASK) + PGDIR_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (pgd_present(*pgd)) {\n\t\t\tpud = pud_offset(pgd, 0);\n\t\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpud = (pud_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pud)\n\t\t\treturn -ENOMEM;\n\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\t\tset_pgd(pgd, __pgd(__pa(pud) | _KERNPG_TABLE));\n\t}\n\n\treturn 0;\n}",
    "comment": "Initializes kernel identity mapping by setting up page entries in the page global directory for the specified address range, allocating pages as needed.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Maps a range of IOVA addresses to physical addresses in a device 's address space , handling page table entries and flushing the IOMMU as needed .\n",
    "cpbcs_sum": "Maps a range of memory pages for a device, handling page table entries and flushing the page cache if necessary.\n",
    "misum_sum": "Maps a page to a DMA domain, handling page allocation and page table entries in a specified address space.\n",
    "decom_sum": "Allocates and maps page table entries for a virtual address range, invoking lower-level mapping routines and updating entries with proper flags.",
    "cfg_sum": "Processes a virtual memory address range, allocating and mapping page table entries as needed using helper routines, and returns status codes on errors.",
    "work_score": {
        "decom": {
            "summary": "Allocates and maps page table entries for a virtual address range, invoking lower-level mapping routines and updating entries with proper flags.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function allocates and maps page table entries for a virtual address range, and that it calls a lower-level routine (`ident_pud_init`) while updating entries with flags (`_KERNPG_TABLE`). These align with the source code\u2019s primary logic. While the summary omits details such as handling existing PGD entries, iterating over the address range, and error return paths, the included claims are accurate and domain-specific. The proportion of accurate claims is high with minor omissions rather than inaccuracies.",
                "The summary correctly identifies that the function allocates and maps page table entries for a virtual address range, which matches the core purpose of initializing identity mappings in page tables using lower-level routines. However, it lacks key specifics such as handling existing pgd entries differently, computing offsets based on kernel_mapping, calling ident_pud_init with conditional early returns, dealing with allocation failures (-ENOMEM), and setting pgd entries with flags. These omissions lead to incomplete coverage of secondary, behavior-critical semantics.",
                "The summary correctly captures the core purpose of the function, which is to map a range of virtual addresses by allocating and updating page table entries, and notes that lower-level mapping functions are invoked. These are accurate, high-level descriptions aligned with the code's behavior. However, the summary is generic and omits specific details from the source, such as handling existing PGD entries, computing 'next' using PGDIR_MASK/SIZE, the conditional offset based on kernel_mapping, error handling for allocation failures, and the exact flags set (_KERNPG_TABLE). There is no inaccurate or misleading claim, but the lack of specificity limits the gain to low."
            ]
        },
        "cfg": {
            "summary": "Processes a virtual memory address range, allocating and mapping page table entries as needed using helper routines, and returns status codes on errors.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary contains a single claim describing processing of a virtual memory address range, allocating and mapping page table entries with helper routines, and returning status codes on errors. This description accurately matches the source code's loop over addresses, allocation via alloc_pgt_page, use of ident_pud_init helper, and returning nonzero codes on failures. No inaccurate or off-topic claims are present, and the detail is consistent with the function's domain semantics.",
                "The summary accurately conveys that the function processes a virtual memory address range, allocates page table entries, uses helper routines, and returns status codes on errors. This correctly matches the core purpose of setting up identity mappings for the range using `ident_pud_init` and allocation logic. However, it omits specific domain details such as handling existing PGD entries, calculation of offsets based on `kernel_mapping`, alignment to PGDIR boundaries, and setting PGD entries with correct flags, making coverage of secondary behavior incomplete.",
                "The summary contains one primary claim that the function processes a virtual memory address range, allocates and maps page table entries using helper routines, and returns status codes on errors. This is accurate and matches the code\u2019s loop over address ranges, allocation via alloc_pgt_page, mapping through set_pgd, and delegation to ident_pud_init, with error returns on failure. There are no inaccurate claims and no noise, but the statement is generic and lacks detail on conditions like existing entries or specific address calculations, giving only low informational gain."
            ]
        },
        "comment": {
            "summary": "Initializes kernel identity mapping by setting up page entries in the page global directory for the specified address range, allocating pages as needed.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately describes the function's purpose: initializing kernel identity mappings, setting up page entries in the page global directory for a given address range, and allocating pages when required. These points directly match the source code's operations, such as iterating over addresses, checking present entries, allocating `pud` pages, and setting PGD entries. All claims are factual and aligned with the code, with no apparent inaccuracies.",
                "The summary accurately states the core purpose as initializing kernel identity mapping over a specified address range by setting up PGD entries and allocating pages when necessary, which matches the source code\u2019s main loop and allocation behavior. However, it omits secondary details like handling existing PGD entries, use of pud_offset and ident_pud_init for PUD initialization, return codes for errors (including -ENOMEM), and the offset adjustment when kernel_mapping is set. This limits coverage of important branch and error semantics.",
                "The summary accurately conveys the primary purpose of the function: initializing kernel identity mapping by configuring PGD entries for a given address range and allocating pages when necessary. It aligns well with the source code's loop over the range, conditional allocation of PUD pages, and setting PGD entries. There are no contradictory or irrelevant claims, and although the description is correct, it is fairly generic without detailing specific mechanics like `pgd_present` checks or the offset logic, which limits the gain."
            ]
        }
    }
}
{
    "project_name": "sed",
    "function_addr": 4273792,
    "strip_function_name": "sub_413680",
    "strip_decompiled_code": "__int64 __fastcall sub_413680(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  void *v6; // rax\n  __int64 v7; // rbx\n  __int64 v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rsi\n\n  v4 = a2[2];\n  *a2 = a3;\n  a2[5] = 0LL;\n  a2[4] = v4;\n  v6 = malloc(8 * v4);\n  a2[6] = v6;\n  if ( !v6 )\n    return 12LL;\n  if ( v4 > 0 )\n  {\n    v7 = 0LL;\n    while ( (*(_BYTE *)(*a1 + 16LL * *(_QWORD *)(a2[3] + 8 * v7) + 8) & 8) != 0\n         || (unsigned __int8)sub_4134E0(a2 + 4, *(_QWORD *)(a2[3] + 8 * v7)) )\n    {\n      if ( a2[2] <= ++v7 )\n        goto LABEL_8;\n    }\n    return 12LL;\n  }\nLABEL_8:\n  v9 = a1[8] + 24 * (a1[17] & a3);\n  v10 = *(_QWORD *)v9;\n  v11 = *(_QWORD **)(v9 + 16);\n  v12 = *(_QWORD *)v9 + 1LL;\n  if ( *(_QWORD *)(v9 + 8) <= *(_QWORD *)v9 )\n  {\n    v11 = realloc(*(void **)(v9 + 16), 16 * v12);\n    if ( v11 )\n    {\n      v10 = *(_QWORD *)v9;\n      *(_QWORD *)(v9 + 16) = v11;\n      *(_QWORD *)(v9 + 8) = 2 * v12;\n      v12 = v10 + 1;\n      goto LABEL_9;\n    }\n    return 12LL;\n  }\nLABEL_9:\n  *(_QWORD *)v9 = v12;\n  v11[v10] = a2;\n  return 0LL;\n}\n",
    "function_name": "register_state",
    "decompiled_code": "__int64 __fastcall register_state(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  void *v6; // rax\n  __int64 v7; // rbx\n  __int64 v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rsi\n\n  v4 = a2[2];\n  *a2 = a3;\n  a2[5] = 0LL;\n  a2[4] = v4;\n  v6 = malloc(8 * v4);\n  a2[6] = v6;\n  if ( !v6 )\n    return 12LL;\n  if ( v4 > 0 )\n  {\n    v7 = 0LL;\n    while ( (*(_BYTE *)(*a1 + 16LL * *(_QWORD *)(a2[3] + 8 * v7) + 8) & 8) != 0\n         || (unsigned __int8)re_node_set_insert_last(a2 + 4, *(_QWORD *)(a2[3] + 8 * v7)) )\n    {\n      if ( a2[2] <= ++v7 )\n        goto LABEL_8;\n    }\n    return 12LL;\n  }\nLABEL_8:\n  v9 = a1[8] + 24 * (a1[17] & a3);\n  v10 = *(_QWORD *)v9;\n  v11 = *(_QWORD **)(v9 + 16);\n  v12 = *(_QWORD *)v9 + 1LL;\n  if ( *(_QWORD *)(v9 + 8) <= *(_QWORD *)v9 )\n  {\n    v11 = realloc(*(void **)(v9 + 16), 16 * v12);\n    if ( v11 )\n    {\n      v10 = *(_QWORD *)v9;\n      *(_QWORD *)(v9 + 16) = v11;\n      *(_QWORD *)(v9 + 8) = 2 * v12;\n      v12 = v10 + 1;\n      goto LABEL_9;\n    }\n    return 12LL;\n  }\nLABEL_9:\n  *(_QWORD *)v9 = v12;\n  v11[v10] = a2;\n  return 0LL;\n}\n",
    "source_code": "\nstatic reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
    "comment": "Registers a new DFA state in the state table, allocating memory as needed and populating non-epsilon nodes.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Initializes a hash table structure by allocating memory for buckets and rehashing existing buckets based on their hash values .\n",
    "cpbcs_sum": "Inserts a new entry into a hash table, handling duplicates and maintaining the table with the key and name indices for efficient regex matching entries.\n",
    "misum_sum": "Retrieves a dynamically loaded symbol from a cached file, allocating memory and updating the target array if not found.\n",
    "decom_sum": "Initializes an entry structure, allocates its array, validates elements, and appends it to a dynamically resized list within the given context.",
    "cfg_sum": "Initializes a data structure with validated elements, allocates required memory, and registers it into a managed array, returning errors on allocation or validation failure.",
    "work_score": {
        "decom": {
            "summary": "Initializes an entry structure, allocates its array, validates elements, and appends it to a dynamically resized list within the given context.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly generic statements about initializing, allocating, validating, and appending without accurately reflecting the specific behaviors in the source code, such as filtering non-epsilon nodes, handling possible memory allocation failures, and resizing the state table. While 'appending to a dynamically resized list' is somewhat accurate, 'initializes an entry structure' and 'validates elements' are vague and fail to match the domain-specific operations. Overall, less than half of the claims are precise and verifiable against the code.",
                "The summary fails to capture the core purpose of registering a DFA state into a hash-indexed state table with allocation of non-epsilon node set. It gives a vague, generic description of initialization, allocation, validation, and appending, but omits the specific domain semantics (regex DFA state registration, hash usage, non-epsilon node filtering). While some secondary behaviors like allocation, validation, and insertion are loosely mentioned, they are imprecise and do not align with the detailed code operations.",
                "The summary is mostly inaccurate relative to the source code: it describes initializing an entry structure and allocating its own array, but in the code, a provided state is updated with a hash and non-epsilon nodes, and added to a hash-indexed table entry whose array may be resized. The summary omits key behaviors like conditional insertion of nodes, hash masking for lookup, and specific error handling. While some generic elements like allocation and appending are mentioned, they are vague and misrepresent the actual domain semantics. The dominant failure mode is NOISE, with little specific, accurate detail about the function\u2019s true purpose or I/O semantics."
            ]
        },
        "cfg": {
            "summary": "Initializes a data structure with validated elements, allocates required memory, and registers it into a managed array, returning errors on allocation or validation failure.",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly identifies memory allocation and insertion into a managed array, and notes returning errors on allocation failure, which aligns with the source code. However, it inaccurately mentions 'validated elements' and 'validation failure'\u2014the code filters out epsilon nodes rather than performing general validation. Despite this, the majority of claims pertain to the code's actual behavior.",
                "The summary correctly notes memory allocation and registration into an array with error handling, aligning with the code's allocation of non-epsilon node sets and insertion into the state table. However, it misses the core specific purpose: creating a DFA state by populating non-epsilon nodes from the given state's elements and linking it into the hash-based state table. The term 'validated elements' is vague and doesn't convey the specific non-epsilon node filtering, and other key details such as hash usage, dynamic resizing of the state table array, and precise error types are absent.",
                "The summary contains mostly generic statements that loosely match the code but lacks specific details of the primary purpose. It correctly notes memory allocation and error returns, which are accurate, but the claim of 'validated elements' is vague and does not specifically reflect the code's logic (which filters non-epsilon nodes, not general validation). No clearly fatal errors are present, but the absence of key specifics (e.g., hash assignment, state table insertion mechanics) makes the gain low. The worst issue is noise from imprecise phrasing rather than contradictory facts."
            ]
        },
        "comment": {
            "summary": "Registers a new DFA state in the state table, allocating memory as needed and populating non-epsilon nodes.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function registers a new DFA state, allocates memory if needed, and populates non-epsilon nodes\u2014these behaviors match the source code's steps of setting the hash, allocating the non-epsilon node set, filtering epsilon nodes, resizing the state table array when full, and inserting the new state. All claims are accurate and aligned with the code semantics, with no irrelevant or incorrect statements.",
                "The summary accurately reflects the core functionality of registering a new DFA state in the state table and mentions memory allocation and populating non-epsilon nodes, which matches the source code\u2019s primary purpose and key operations. However, it omits important secondary details such as error handling for allocation failures, the resizing of the state table array when capacity is insufficient, and specific constants or conditions used. Coverage of the core is present but secondary behavioral semantics are only partially addressed.",
                "The summary correctly states the primary purpose of registering a new DFA state, the allocation of memory when required, and the population of non-epsilon nodes, all of which match the source code behavior. The claims are specific enough to cover key operations without introducing inaccuracies or irrelevant noise. While accurate, the level of detail is moderate and could omit nuanced error-handling paths and resizing logic specifics, providing decent but not maximal engineer acceleration."
            ]
        }
    }
}
{
    "project_name": "apr",
    "function_addr": 115376,
    "strip_function_name": "apr_unix_mode2perms",
    "strip_decompiled_code": "__int64 __fastcall apr_unix_mode2perms(__int16 a1)\n{\n  __int64 result; // rax\n  unsigned int v2; // edx\n  unsigned int v3; // edx\n  unsigned int v4; // edx\n  unsigned int v5; // edx\n  unsigned int v6; // edx\n\n  result = (unsigned __int8)((a1 & 0x800) != 0) << 15;\n  v2 = ((a1 & 0x800) != 0) << 15;\n  BYTE1(v2) |= 4u;\n  if ( (a1 & 0x100) != 0 )\n    result = v2;\n  v3 = result;\n  if ( (a1 & 0x80u) != 0 )\n  {\n    BYTE1(v3) = BYTE1(result) | 2;\n    result = v3;\n  }\n  v4 = result;\n  if ( (a1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(result) | 1;\n    result = v4;\n  }\n  v5 = result;\n  if ( (a1 & 0x400) != 0 )\n  {\n    BYTE1(v5) = BYTE1(result) | 0x40;\n    result = v5;\n  }\n  if ( (a1 & 0x20) != 0 )\n    result = (unsigned int)result | 0x40;\n  if ( (a1 & 0x10) != 0 )\n    result = (unsigned int)result | 0x20;\n  if ( (a1 & 8) != 0 )\n    result = (unsigned int)result | 0x10;\n  v6 = result;\n  if ( (a1 & 0x200) != 0 )\n  {\n    BYTE1(v6) = BYTE1(result) | 0x20;\n    result = v6;\n  }\n  if ( (a1 & 4) != 0 )\n    result = (unsigned int)result | 4;\n  if ( (a1 & 2) != 0 )\n    result = (unsigned int)result | 2;\n  if ( (a1 & 1) != 0 )\n    return (unsigned int)result | 1;\n  return result;\n}\n",
    "function_name": "apr_unix_mode2perms",
    "decompiled_code": "__int64 __fastcall apr_unix_mode2perms(__int16 a1)\n{\n  __int64 result; // rax\n  unsigned int v2; // edx\n  unsigned int v3; // edx\n  unsigned int v4; // edx\n  unsigned int v5; // edx\n  unsigned int v6; // edx\n\n  result = (unsigned __int8)((a1 & 0x800) != 0) << 15;\n  v2 = ((a1 & 0x800) != 0) << 15;\n  BYTE1(v2) |= 4u;\n  if ( (a1 & 0x100) != 0 )\n    result = v2;\n  v3 = result;\n  if ( (a1 & 0x80u) != 0 )\n  {\n    BYTE1(v3) = BYTE1(result) | 2;\n    result = v3;\n  }\n  v4 = result;\n  if ( (a1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(result) | 1;\n    result = v4;\n  }\n  v5 = result;\n  if ( (a1 & 0x400) != 0 )\n  {\n    BYTE1(v5) = BYTE1(result) | 0x40;\n    result = v5;\n  }\n  if ( (a1 & 0x20) != 0 )\n    result = (unsigned int)result | 0x40;\n  if ( (a1 & 0x10) != 0 )\n    result = (unsigned int)result | 0x20;\n  if ( (a1 & 8) != 0 )\n    result = (unsigned int)result | 0x10;\n  v6 = result;\n  if ( (a1 & 0x200) != 0 )\n  {\n    BYTE1(v6) = BYTE1(result) | 0x20;\n    result = v6;\n  }\n  if ( (a1 & 4) != 0 )\n    result = (unsigned int)result | 4;\n  if ( (a1 & 2) != 0 )\n    result = (unsigned int)result | 2;\n  if ( (a1 & 1) != 0 )\n    return (unsigned int)result | 1;\n  return result;\n}\n",
    "source_code": "\napr_fileperms_t apr_unix_mode2perms(mode_t mode)\n{\n    apr_fileperms_t perms = 0;\n\n    if (mode & S_ISUID)\n        perms |= APR_USETID;\n    if (mode & S_IRUSR)\n        perms |= APR_UREAD;\n    if (mode & S_IWUSR)\n        perms |= APR_UWRITE;\n    if (mode & S_IXUSR)\n        perms |= APR_UEXECUTE;\n\n    if (mode & S_ISGID)\n        perms |= APR_GSETID;\n    if (mode & S_IRGRP)\n        perms |= APR_GREAD;\n    if (mode & S_IWGRP)\n        perms |= APR_GWRITE;\n    if (mode & S_IXGRP)\n        perms |= APR_GEXECUTE;\n\n#ifdef S_ISVTX\n    if (mode & S_ISVTX)\n        perms |= APR_WSTICKY;\n#endif\n    if (mode & S_IROTH)\n        perms |= APR_WREAD;\n    if (mode & S_IWOTH)\n        perms |= APR_WWRITE;\n    if (mode & S_IXOTH)\n        perms |= APR_WEXECUTE;\n\n    return perms;\n}",
    "comment": "Converts a Unix file mode into an APR file permissions representation by checking user, group, and others' read, write, and execute bits.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Converts UNIX file permissions into APR file permission constants by setting corresponding permissions bits .\n",
    "cpbcs_sum": "Generates polling events for POSIX polling events based on file mode and polling event flags for user, group, and permissions.\n",
    "misum_sum": "Converts POSIX polling events to APR polling event constants by checking specific event flags in the input parameter.\n",
    "decom_sum": "Converts a Unix file mode bitmask into an APR-style permission bitfield representing read, write, execute, and special mode flags.",
    "cfg_sum": "Converts a Unix file mode bitmask into a corresponding APR permission code by mapping each mode flag to defined permission bits.",
    "work_score": {
        "decom": {
            "summary": "Converts a Unix file mode bitmask into an APR-style permission bitfield representing read, write, execute, and special mode flags.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function converts a Unix file mode bitmask into an APR-style permission bitfield, and notes inclusion of read, write, execute, and special mode flags, which aligns with the code's mapping of Unix mode constants to APR constants. All claims are accurate and domain-specific, with no contradictory or irrelevant information.",
                "The summary correctly states that the function converts a Unix file mode bitmask into an APR-style permission bitfield and mentions read, write, execute, and special mode flags, which matches the core purpose and the mapping of various S_* flags to APR_* flags seen in the source. However, it is generic and does not cover secondary details such as the specific distinction between user, group, and other permissions, or the handling of each individual flag including S_ISUID, S_ISGID, and optional S_ISVTX. This limits coverage of behavior-critical semantics beyond the core.",
                "The summary accurately states the primary purpose of the function, which is to convert a Unix file mode bitmask into an APR-style permission bitfield. It correctly mentions read, write, execute, and special mode flags, aligning with the code\u2019s handling of user, group, and other permissions, as well as SUID, SGID, and sticky bits. There are no inaccurate claims or excessive noise, though the description remains somewhat generic and lacks detail on the specific mappings, so the informational gain is moderate rather than high."
            ]
        },
        "cfg": {
            "summary": "Converts a Unix file mode bitmask into a corresponding APR permission code by mapping each mode flag to defined permission bits.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly describes the function\u2019s core domain semantic behavior, stating it maps Unix file mode flags to corresponding APR permission bits, which matches the source code's iterative bitmask checks and assignments. There are no incorrect or irrelevant claims, and the description is accurate though somewhat general, capturing the essential purpose without detailing all specific mappings.",
                "The summary accurately captures the core purpose: translating a Unix mode_t bitmask into APR-specific permission flags, reflecting the mapping of each standard mode flag to its corresponding APR constant. This matches the source code's main functionality. However, it omits secondary details such as handling special flags like S_ISUID, S_ISGID, and S_ISVTX, as well as distinctions between user, group, and world permissions, and lacks mention of the return value composition, making the coverage of nuanced behavior incomplete.",
                "The summary correctly identifies the function\u2019s core purpose: translating a Unix file mode bitmask into APR permission bits. This is an accurate reflection of the code\u2019s primary behavior with no contradictory or irrelevant statements. However, the claim is generic, lacking specifics about which mode flags are mapped and missing details on individual permission constants used, so the gain is low despite being accurate."
            ]
        },
        "comment": {
            "summary": "Converts a Unix file mode into an APR file permissions representation by checking user, group, and others' read, write, and execute bits.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function converts a Unix file mode to an APR file permissions format and checks read, write, and execute bits for user, group, and others, matching the source code's logic. However, it omits other specific bits handled such as set-user-ID, set-group-ID, and sticky bit, which are part of the domain semantics in the code. This makes most of the claims accurate but slightly incomplete.",
                "The summary correctly identifies that the function converts a Unix file mode into an APR-specific permissions format and checks user, group, and others' read, write, and execute bits, covering the core purpose accurately. However, it omits other key semantics present in the source code, such as handling special mode bits (S_ISUID, S_ISGID, S_ISVTX) and the mapping to APR-specific flags beyond just read/write/execute. This results in incomplete coverage of secondary behavior-critical details.",
                "The summary correctly states the core purpose of the function\u2014translating a Unix file mode into an APR file permissions format and checking read, write, and execute bits for user, group, and others. However, it omits specific details from the code, such as handling of setuid, setgid, and sticky bits. There are no inaccurate claims, but the gain is limited because the information is generic and lacks the precise mapping of mode flags to APR constants, resulting in low net benefit."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 1056384,
    "strip_function_name": "sub_101E80",
    "strip_decompiled_code": "__int64 __fastcall sub_101E80(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // eax\n  int i; // ebp\n  __int64 v4; // rax\n\n  if ( *(_QWORD *)(a1 + 224) )\n    return 1LL;\n  v2 = X509_policy_check(\n         a1 + 168,\n         a1 + 176,\n         *(_QWORD *)(a1 + 160),\n         *(_QWORD *)(*(_QWORD *)(a1 + 40) + 48LL),\n         *(unsigned int *)(*(_QWORD *)(a1 + 40) + 24LL));\n  if ( v2 )\n  {\n    if ( v2 == -1 )\n    {\n      for ( i = 1; i < (int)sk_num(*(unsigned int **)(a1 + 160)); ++i )\n      {\n        v4 = sk_value(*(_QWORD *)(a1 + 160), i);\n        if ( (*(_BYTE *)(v4 + 73) & 8) != 0 )\n        {\n          *(_QWORD *)(a1 + 192) = v4;\n          *(_DWORD *)(a1 + 184) = 42;\n          result = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n          if ( !(_DWORD)result )\n            return result;\n        }\n      }\n      return 1LL;\n    }\n    if ( v2 == -2 )\n    {\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 43;\n      return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n    }\n    else\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 25LL) & 8) == 0 )\n        return 1LL;\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 0;\n      return (*(unsigned int (__fastcall **)(__int64, __int64))(a1 + 64))(2LL, a1) != 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(0xBu, 145, 65, (__int64)\"x509_vfy.c\", 1499);\n    return 0LL;\n  }\n}\n",
    "function_name": "check_policy",
    "decompiled_code": "__int64 __fastcall check_policy(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // eax\n  int i; // ebp\n  __int64 v4; // rax\n\n  if ( *(_QWORD *)(a1 + 224) )\n    return 1LL;\n  v2 = X509_policy_check(\n         (__int64 **)(a1 + 168),\n         (_DWORD *)(a1 + 176),\n         *(unsigned int **)(a1 + 160),\n         *(unsigned int **)(*(_QWORD *)(a1 + 40) + 48LL),\n         *(_DWORD *)(*(_QWORD *)(a1 + 40) + 24LL));\n  if ( v2 )\n  {\n    if ( v2 == -1 )\n    {\n      for ( i = 1; i < (int)sk_num(*(unsigned int **)(a1 + 160)); ++i )\n      {\n        v4 = sk_value(*(_QWORD *)(a1 + 160), i);\n        if ( (*(_BYTE *)(v4 + 73) & 8) != 0 )\n        {\n          *(_QWORD *)(a1 + 192) = v4;\n          *(_DWORD *)(a1 + 184) = 42;\n          result = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n          if ( !(_DWORD)result )\n            return result;\n        }\n      }\n      return 1LL;\n    }\n    if ( v2 == -2 )\n    {\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 43;\n      return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n    }\n    else\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 25LL) & 8) == 0 )\n        return 1LL;\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 0;\n      return (*(unsigned int (__fastcall **)(__int64, __int64))(a1 + 64))(2LL, a1) != 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(0xBu, 145, 65, (__int64)\"x509_vfy.c\", 1499);\n    return 0LL;\n  }\n}\n",
    "source_code": "\nstatic int check_policy(X509_STORE_CTX *ctx)\n\t{\n\tint ret;\n\tif (ctx->parent)\n\t\treturn 1;\n\tret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n\t\t\t\tctx->param->policies, ctx->param->flags);\n\tif (ret == 0)\n\t\t{\n\t\tX509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\t/* Invalid or inconsistent extensions */\n\tif (ret == -1)\n\t\t{\n\t\t/* Locate certificates with bad extensions and notify\n\t\t * callback.\n\t\t */\n\t\tX509 *x;\n\t\tint i;\n\t\tfor (i = 1; i < sk_X509_num(ctx->chain); i++)\n\t\t\t{\n\t\t\tx = sk_X509_value(ctx->chain, i);\n\t\t\tif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n\t\t\t\tcontinue;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n\t\t\tif(!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\treturn 1;\n\t\t}\n\tif (ret == -2)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n\t\treturn ctx->verify_cb(0, ctx);\n\t\t}\n\n\tif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_OK;\n\t\tif (!ctx->verify_cb(2, ctx))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}",
    "comment": "Validates X509 certificate policies, checks for invalid extensions, and invokes a callback for policy notifications or errors during the verification process.",
    "hext5_sum": " the index of a human readable format.",
    "bint5_sum": "Validates the policies of an X509 certificate based on its auxiliary trust and constraints , returning success or failure status .\n",
    "cpbcs_sum": "Validates a certificate revocation by checking its status, handling both binary and soft characters, and manages memory for the certificate structure.\n",
    "misum_sum": "Validates an X.509 certificate by checking its validity and handling certificate verification based on the validation context and callback.\n",
    "decom_sum": "Validates an X.509 certificate chain against policy using `X509_policy_check`, handling specific error codes and invoking a configured callback for violations.",
    "cfg_sum": "Validates X.509 certificate policies using OpenSSL, handling specific error cases and invoking callbacks to report success or detailed verification failures.",
    "work_score": {
        "decom": {
            "summary": "Validates an X.509 certificate chain against policy using `X509_policy_check`, handling specific error codes and invoking a configured callback for violations.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly describes the function as validating an X.509 certificate chain against policy using `X509_policy_check` and notes handling specific error codes with a callback, which aligns with the source code's logic. It omits some implementation details like the handling of `ctx->parent` and explicit policy flags, but all stated claims are accurate and relevant to the code's semantics.",
                "The summary accurately captures the core purpose: validating an X.509 certificate chain against policy using `X509_policy_check`, and mentions handling errors and invoking a callback for violations, which aligns with key behaviors in the code. However, it omits important secondary details such as the distinct handling of ret values (-1, -2), the specific error constants used, conditions involving `ctx->parent` and `X509_V_FLAG_NOTIFY_POLICY`, and iteration over the chain to flag invalid policy extensions. The coverage of secondary semantics is therefore limited.",
                "The summary is largely accurate: it correctly states that the function validates an X.509 certificate chain against policy via `X509_policy_check`, processes specific error codes (-1 for invalid extensions, -2 for missing explicit policy, 0 for malloc failure), and uses a callback to handle violations. These claims directly match the source code's core logic and key side effects. There is minimal noise, and while the summary is slightly generic and omits some detail (such as how various flags influence behavior), it captures the primary purpose and I/O behavior without fatal inaccuracies."
            ]
        },
        "cfg": {
            "summary": "Validates X.509 certificate policies using OpenSSL, handling specific error cases and invoking callbacks to report success or detailed verification failures.",
            "score": [
                0.8,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function validates X.509 certificate policies using OpenSSL and handles error cases via callbacks, which aligns with the source code logic. However, it simplifies details and omits specific behaviors such as early return when a parent context exists, exact error types handled (-1 for invalid policy extensions, -2 for no explicit policy, 0 for malloc failure), and notification flag handling. These omissions reduce precision but the claims present are factually accurate, making the majority of them accurate.",
                "The summary correctly captures the core purpose of validating X.509 certificate policies with OpenSSL, which matches the function\u2019s central operation via X509_policy_check. It also notes handling specific error cases and invoking callbacks, which reflects the branches for invalid extensions, no explicit policy, and notification flags. However, it lacks finer details such as the special early exit when ctx->parent is set, the precise meanings of ret values, and the specific error codes assigned, which would improve completeness.",
                "The summary correctly states that the function validates X.509 certificate policies using OpenSSL and handles specific error cases by invoking callbacks. These are accurate GOLD-level claims about its core purpose and key side effects. However, it omits details such as the early return when ctx->parent is set, and specific handling for ret values (-1 and -2) including setting error codes and certificate references. There is no incorrect (FATAL) information, and noise is minimal, but the gain is moderate because the explanation remains fairly high-level and misses several implementation specifics."
            ]
        },
        "comment": {
            "summary": "Validates X509 certificate policies, checks for invalid extensions, and invokes a callback for policy notifications or errors during the verification process.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately reflects key behaviors in the source code, including validation of X509 certificate policies, detection of invalid extensions, and invoking a callback for both notifications and error handling during verification. All stated claims are grounded in the actual logic flow of the function, with no contradictory or irrelevant statements present, yielding a high alignment with the evaluation steps.",
                "The summary correctly identifies the core purpose of validating X509 certificate policies, which matches the primary function of the code via X509_policy_check. It also accurately notes checks for invalid extensions and the use of a callback for policy notifications or error handling. These align with the different ret case branches in the source code. However, the summary omits several specific secondary details such as distinct ret value handling (-2 for no explicit policy), parent check shortcut, and the exact error codes set for different conditions, leaving the coverage incomplete.",
                "The summary correctly captures the core function purpose of validating X509 certificate policies and notes checks for invalid extensions, matching the code\u2019s handling of EXFLAG_INVALID_POLICY and invoking callbacks for policy notifications or errors. These are accurate GOLD claims with low noise and no contradictory or missing core elements. While the summary is somewhat high-level and omits finer details like specific error codes or the handling of explicit policy absence, it still conveys the main semantics with good specificity."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 35551,
    "strip_function_name": "sub_8ADF",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_8ADF(int *a1, int *a2, __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 v4; // rax\n  _BOOL4 v8; // [rsp+2Ch] [rbp-44h]\n  int v9[4]; // [rsp+30h] [rbp-40h] BYREF\n  int v10[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v11[24]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *(int *)(a3 + 4) < 0;\n  if ( (~a4 & (*(int *)(a3 + 4) < 0)) != 0 )\n    sub_B8A(\"mpz_rootrem: Negative argument, with even root.\");\n  if ( !a4 )\n    sub_B8A(\"mpz_rootrem: Zeroth root.\");\n  if ( (int)sub_57EB(a3, 1uLL) > 0 )\n  {\n    sub_4834((__int64)v10);\n    sub_4834((__int64)v9);\n    v4 = sub_B382(a3, 2LL);\n    sub_A1EB(v9, v4 / a4 + 1);\n    if ( a4 == 2 )\n    {\n      do\n      {\n        sub_591D(v10, v9);\n        sub_6952(v9, a3, (__int64)v10);\n        sub_5D36(v9, (__int64)v9, (__int64)v10);\n        sub_6F9A(v9, (__int64)v9, 1uLL);\n      }\n      while ( (int)sub_5861((__int64)v9, (__int64)v10) < 0 );\n    }\n    else\n    {\n      sub_4834((__int64)v11);\n      if ( v8 )\n        sub_58E5(v9, (__int64)v9);\n      do\n      {\n        sub_591D(v10, v9);\n        sub_84D8(v9, (__int64)v10, a4 - 1);\n        sub_6952(v9, a3, (__int64)v9);\n        sub_5EA7((__int64)v11, (__int64)v10, a4 - 1);\n        sub_5D36(v9, (__int64)v9, (__int64)v11);\n        sub_737D(v9, (__int64)v9, a4);\n      }\n      while ( (int)sub_5861((__int64)v9, (__int64)v10) < 0 );\n      sub_48C3((__int64)v11);\n    }\n    if ( a2 )\n    {\n      sub_84D8(v9, (__int64)v10, a4);\n      sub_5DBB(a2, a3, (__int64)v9);\n    }\n    if ( a1 )\n      sub_591D(a1, v10);\n    sub_48C3((__int64)v10);\n    sub_48C3((__int64)v9);\n  }\n  else\n  {\n    if ( a1 )\n      sub_4A75(a1, a3);\n    if ( a2 )\n      a2[1] = 0;\n  }\n  return __readfsqword(0x28u) ^ v12;\n}\n",
    "function_name": "mpz_rootrem",
    "decompiled_code": "unsigned __int64 __fastcall mpz_rootrem(int *a1, int *a2, __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 v4; // rax\n  _BOOL4 v8; // [rsp+2Ch] [rbp-44h]\n  int v9[4]; // [rsp+30h] [rbp-40h] BYREF\n  int v10[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v11[24]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *(int *)(a3 + 4) < 0;\n  if ( (~a4 & (*(int *)(a3 + 4) < 0)) != 0 )\n    gmp_die(\"mpz_rootrem: Negative argument, with even root.\");\n  if ( !a4 )\n    gmp_die(\"mpz_rootrem: Zeroth root.\");\n  if ( (int)mpz_cmpabs_ui(a3, 1uLL) > 0 )\n  {\n    mpz_init((__int64)v10);\n    mpz_init((__int64)v9);\n    v4 = mpz_sizeinbase(a3, 2LL);\n    mpz_setbit(v9, v4 / a4 + 1);\n    if ( a4 == 2 )\n    {\n      do\n      {\n        mpz_swap(v10, v9);\n        mpz_tdiv_q(v9, a3, (__int64)v10);\n        mpz_add(v9, (__int64)v9, (__int64)v10);\n        mpz_tdiv_q_2exp(v9, (__int64)v9, 1uLL);\n      }\n      while ( (int)mpz_cmpabs((__int64)v9, (__int64)v10) < 0 );\n    }\n    else\n    {\n      mpz_init((__int64)v11);\n      if ( v8 )\n        mpz_neg(v9, (__int64)v9);\n      do\n      {\n        mpz_swap(v10, v9);\n        mpz_pow_ui(v9, (__int64)v10, a4 - 1);\n        mpz_tdiv_q(v9, a3, (__int64)v9);\n        mpz_mul_ui((__int64)v11, (__int64)v10, a4 - 1);\n        mpz_add(v9, (__int64)v9, (__int64)v11);\n        mpz_tdiv_q_ui(v9, (__int64)v9, a4);\n      }\n      while ( (int)mpz_cmpabs((__int64)v9, (__int64)v10) < 0 );\n      mpz_clear((__int64)v11);\n    }\n    if ( a2 )\n    {\n      mpz_pow_ui(v9, (__int64)v10, a4);\n      mpz_sub(a2, a3, (__int64)v9);\n    }\n    if ( a1 )\n      mpz_swap(a1, v10);\n    mpz_clear((__int64)v10);\n    mpz_clear((__int64)v9);\n  }\n  else\n  {\n    if ( a1 )\n      mpz_set(a1, a3);\n    if ( a2 )\n      a2[1] = 0;\n  }\n  return __readfsqword(0x28u) ^ v12;\n}\n",
    "source_code": "void\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);\n\n  if (z == 2) /* simplify sqrt loop: z-1 == 1 */\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_tdiv_q (t, y, u);\t\t/* t = y/x */\n      mpz_add (t, t, u);\t\t/* t = y/x + x */\n      mpz_tdiv_q_2exp (t, t, 1);\t/* x'= (y/x + x)/2 */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n  else /* z != 2 */ {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_pow_ui (t, u, z - 1);\t\t/* t = x^(z-1) */\n      mpz_tdiv_q (t, y, t);\t\t/* t = y/x^(z-1) */\n      mpz_mul_ui (v, u, z - 1);\t\t/* v = x*(z-1) */\n      mpz_add (t, t, v);\t\t/* t = y/x^(z-1) + x*(z-1) */\n      mpz_tdiv_q_ui (t, t, z);\t\t/* x'=(y/x^(z-1) + x*(z-1))/z */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}",
    "comment": "Computes the nth root and remainder of a multi-precision integer, handling special cases for negative and zero values.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Removes a specified integer from a multi-precision integer , handling potential negation and ensuring no carry occurs during the operation .\n",
    "cpbcs_sum": "Calculates the modular inverse of an unsigned long integer `a` modulo `2^n` and stores the result in `r`.\n",
    "misum_sum": "Calculates the modular inverse of a multi-precision integer and stores the result in a specified base variable.\n",
    "decom_sum": "Computes the integer n\u2011th root of a big integer and optionally returns the remainder, rejecting invalid root values such as zero or even roots of negatives.",
    "cfg_sum": "Computes the integer n-th root of a large number, handling errors for invalid inputs, and optionally returns the remainder and the root.",
    "work_score": {
        "decom": {
            "summary": "Computes the integer n\u2011th root of a big integer and optionally returns the remainder, rejecting invalid root values such as zero or even roots of negatives.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function computes the integer n\u2011th root of a big integer, can optionally return the remainder, and checks for invalid inputs such as zero as the root or even roots of negative numbers. All these claims align with the source code's behavior, making them accurate and semantically relevant to the function.",
                "The summary correctly captures the core purpose of computing the integer n-th root of a big integer and optionally producing the remainder, and it accurately notes invalid root checks for zero and even roots of negatives. This matches the specific domain behavior in the source. However, it omits secondary details like the different iterative algorithms for square roots vs other roots, handling of small |y| values, and the specifics of remainder calculation after root convergence. The coverage of branches, constants, and side effects is limited.",
                "The summary correctly states the primary purpose \u2014 computing the integer n\u2011th root of a big integer and optionally returning the remainder \u2014 which matches the function's behavior. It also accurately notes rejection of invalid root values, including zero and even roots of negative inputs, aligning with input validation in the code. All claims are accurate, specific to the core operation and constraints, with no noise or contradictions, yielding high utility for understanding the function."
            ]
        },
        "cfg": {
            "summary": "Computes the integer n-th root of a large number, handling errors for invalid inputs, and optionally returns the remainder and the root.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function computes the integer n-th root of a large number, handles errors for invalid inputs like negative arguments with even roots and zeroth roots, and can optionally return both the remainder and the root. These are all accurate reflections of the source code's semantics, with no incorrect or irrelevant claims present.",
                "The summary correctly states that the function computes the integer n-th root of a large number and can return both the root and remainder, which aligns with the core purpose of mpz_rootrem. It also notes error handling for invalid inputs, matching the code's checks for negative arguments with even roots and zeroth roots. However, it omits details of specific algorithms used for square roots versus other roots, handling of small |y| values, and sign management for negative inputs, which are important secondary semantics.",
                "The summary is accurate about the core purpose (computing the integer n-th root) and notes error handling for invalid inputs, which matches the source checks for negative arguments with even roots and zeroth root. It correctly states that both root and remainder may be returned optionally. The claims are specific to the code\u2019s actual I/O contract and side effects without introducing contradictory or irrelevant noise. However, the gain is moderate since no algorithmic detail or iteration method is described, limiting deeper insight."
            ]
        },
        "comment": {
            "summary": "Computes the nth root and remainder of a multi-precision integer, handling special cases for negative and zero values.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary's key claims are: 1) the function computes the nth root and remainder of a multi-precision integer, and 2) it handles special cases for negative and zero values. Both are accurate per the source code, which shows logic for validating z and y for sign and zero, and implements algorithms for computing root and remainder. No claims are incorrect or off-topic, making the proportion of accurate claims effectively 100%.",
                "The summary correctly states the core purpose of computing the nth root and remainder of a multi-precision integer, which matches the function\u2019s main domain operation. It also notes handling of negative and zero values, reflecting the code\u2019s checks for even roots of negative numbers and zeroth root errors. However, it omits several secondary details: special-case behavior when |y| \u2264 1, use of distinct iterative algorithms for square roots vs. other roots, and computation of the remainder only if requested. Limited coverage of branching and specific algorithmic steps results in incomplete alignment beyond the core.",
                "The summary correctly identifies the primary purpose of computing the nth root and remainder of a multi-precision integer, and mentions handling special cases for negative and zero values, which matches explicit checks in the code. There are no inaccurate or contradictory claims, but the description is generic and lacks detail about the algorithmic differences for square roots versus other roots, or specifics on how the remainder is computed, offering only low informational gain."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 230936,
    "strip_function_name": "mutil_parse_field_map",
    "strip_decompiled_code": "__int64 __fastcall mutil_parse_field_map(__int64 a1, _QWORD *a2, _DWORD *a3)\n{\n  int v3; // ebx\n  int v4; // eax\n  int v5; // r8d\n  int v6; // r9d\n  char *v8; // rax\n  char v9; // [rsp+0h] [rbp-180h]\n  unsigned int v11; // [rsp+28h] [rbp-158h]\n  int i; // [rsp+2Ch] [rbp-154h]\n  __int64 v13; // [rsp+30h] [rbp-150h] BYREF\n  char *s; // [rsp+38h] [rbp-148h]\n  char *v15; // [rsp+40h] [rbp-140h]\n  char *v16; // [rsp+48h] [rbp-138h]\n  _QWORD v17[38]; // [rsp+50h] [rbp-130h] BYREF\n\n  v17[35] = __readfsqword(0x28u);\n  v13 = 0LL;\n  v17[7] = \":\";\n  if ( (unsigned int)mu_wordsplit(a1, v17, 33574468LL) )\n  {\n    v3 = mu_wordsplit_strerror(v17);\n    v4 = (unsigned int)dgettext(\"mailutils\", \"cannot split line `%s': %s\");\n    mu_error(v4, a1, v3, v4, v5, v6, v9);\n    return (unsigned int)*__errno_location();\n  }\n  else\n  {\n    for ( i = 0; (unsigned __int64)i < v17[0]; ++i )\n    {\n      s = *(char **)(8LL * i + v17[1]);\n      v15 = strchr(s, 61);\n      if ( !v15 )\n      {\n        v11 = 22;\n        break;\n      }\n      if ( !v13 )\n      {\n        v11 = mu_assoc_create(&v13, 0LL);\n        if ( v11 )\n          break;\n        mu_assoc_set_destroy_item(v13, mu_list_free_item);\n        *a2 = v13;\n      }\n      v8 = v15++;\n      *v8 = 0;\n      v16 = strdup(v15);\n      if ( !v16 )\n      {\n        v11 = *__errno_location();\n        break;\n      }\n      v11 = mu_assoc_install(v13, s, v16);\n      if ( v11 )\n      {\n        free(v15);\n        break;\n      }\n    }\n    mu_wordsplit_free(v17);\n    if ( v11 )\n    {\n      if ( a3 )\n        *a3 = i;\n    }\n    return v11;\n  }\n}\n",
    "function_name": "mutil_parse_field_map",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nint __cdecl mutil_parse_field_map(const char *map, mu_assoc_t *passoc_tab, int *perr)\n{\n  __int64 v3; // rbx\n  char *v4; // rax\n  char *v6; // rax\n  int rc; // [rsp+28h] [rbp-158h]\n  int i; // [rsp+2Ch] [rbp-154h]\n  mu_assoc_t assoc_tab; // [rsp+30h] [rbp-150h] BYREF\n  char *tok; // [rsp+38h] [rbp-148h]\n  char *p; // [rsp+40h] [rbp-140h]\n  char *pptr; // [rsp+48h] [rbp-138h]\n  mu_wordsplit ws; // [rsp+50h] [rbp-130h] BYREF\n  unsigned __int64 v15; // [rsp+168h] [rbp-18h]\n\n  v15 = __readfsqword(0x28u);\n  assoc_tab = 0LL;\n  ws.ws_delim = \":\";\n  if ( (unsigned int)((__int64 (__fastcall *)(const char *, char ***, __int64))mu_wordsplit)(\n                       map,\n                       &ws.ws_wordv,\n                       33574468LL) )\n  {\n    v3 = ((__int64 (__fastcall *)(mu_wordsplit *))mu_wordsplit_strerror)(&ws);\n    v4 = dgettext(\"mailutils\", \"cannot split line `%s': %s\");\n    ((void (__fastcall *)(char *, const char *, __int64))mu_error)(v4, map, v3);\n    return *__errno_location();\n  }\n  else\n  {\n    for ( i = 0; i < ws.ws_wordc; ++i )\n    {\n      tok = ws.ws_wordv[i];\n      p = strchr(tok, 61);\n      if ( !p )\n      {\n        rc = 22;\n        break;\n      }\n      if ( !assoc_tab )\n      {\n        rc = ((__int64 (__fastcall *)(mu_assoc_t *, _QWORD))mu_assoc_create)(&assoc_tab, 0LL);\n        if ( rc )\n          break;\n        ((void (__fastcall *)(mu_assoc_t, void (__cdecl *)(void *)))mu_assoc_set_destroy_item)(\n          assoc_tab,\n          mu_list_free_item);\n        *passoc_tab = assoc_tab;\n      }\n      v6 = p++;\n      *v6 = 0;\n      pptr = strdup(p);\n      if ( !pptr )\n      {\n        rc = *__errno_location();\n        break;\n      }\n      rc = ((__int64 (__fastcall *)(mu_assoc_t, char *, char *))mu_assoc_install)(assoc_tab, tok, pptr);\n      if ( rc )\n      {\n        free(p);\n        break;\n      }\n    }\n    ((void (__fastcall *)(mu_wordsplit *))mu_wordsplit_free)(&ws);\n    if ( rc )\n    {\n      if ( perr )\n        *perr = i;\n    }\n    return rc;\n  }\n}\n",
    "source_code": "\nint\nmutil_parse_field_map (const char *map, mu_assoc_t *passoc_tab, int *perr)\n{\n  int rc;\n  int i;\n  struct mu_wordsplit ws;\n  mu_assoc_t assoc_tab = NULL;\n\n  ws.ws_delim = \":\";\n  if (mu_wordsplit (map, &ws, MU_WRDSF_DEFFLAGS|MU_WRDSF_DELIM))\n    {\n      mu_error (_(\"cannot split line `%s': %s\"), map,\n\t\tmu_wordsplit_strerror (&ws));\n      return errno;\n    }\n\n  for (i = 0; i < ws.ws_wordc; i++)\n    {\n      char *tok = ws.ws_wordv[i];\n      char *p = strchr (tok, '=');\n      char *pptr;\n      \n      if (!p)\n\t{\n\t  rc = EINVAL;\n\t  break;\n\t}\n      if (!assoc_tab)\n\t{\n\t  rc = mu_assoc_create (&assoc_tab, 0);\n\t  if (rc)\n\t    break;\n\t  mu_assoc_set_destroy_item (assoc_tab, mu_list_free_item);\n\t  *passoc_tab = assoc_tab;\n\t}\n      *p++ = 0;\n      pptr = strdup (p);\n      if (!pptr)\n\t{\n\t  rc = errno;\n\t  break;\n\t}\n      rc = mu_assoc_install (assoc_tab, tok, pptr);\n      if (rc)\n\t{\n\t  free (p);\n\t  break;\n\t}\n    }\n\n  mu_wordsplit_free (&ws);\n  if (rc && perr)\n    *perr = i;\n  return rc;\n}",
    "comment": "Parses a colon-delimited string into a key-value association table, handling errors for malformed entries and memory allocation failures.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Parses a field mapping from the input stream , populating an array with names and values while handling errors and whitespace .\n",
    "cpbcs_sum": "Parses a configuration file for a given name, returning an error code on failure.\n",
    "misum_sum": "Constructs a dynamic module by appending filename to a given sockaddr and appending it to a specified filename if successful.\n",
    "decom_sum": "Parses a colon-separated string of key=value pairs into a Mailutils association map, creating entries and reporting errors with context.",
    "cfg_sum": "Parses a colon-delimited string into key-value pairs, storing them in an association list and returning an error code on failure.",
    "work_score": {
        "decom": {
            "summary": "Parses a colon-separated string of key=value pairs into a Mailutils association map, creating entries and reporting errors with context.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly identifies that the function parses a colon-separated string of key=value pairs and stores them in an association map. It also accurately notes that errors are reported, although the mention of 'Mailutils' is generic but safe given the use of mu_assoc_* and mu_wordsplit functions from that library. No contradictory or irrelevant claims are present, making the description highly consistent with the source code functionality.",
                "The summary accurately identifies that the function parses a colon-separated string of key=value pairs and stores them in a Mailutils association map, matching the core domain-specific purpose. It also correctly notes that entries are created and errors are reported with context, reflecting the mu_error call on split failure and error tracking via perr. However, it omits secondary details such as handling invalid tokens without '=', the allocation and freeing of resources, and specifics about mu_assoc_set_destroy_item and strdup usage. Coverage of secondary semantics is limited beyond the main parsing and error reporting.",
                "The summary correctly states that the function parses a colon-separated string of key=value pairs and populates a Mailutils association map, which matches the code's use of `mu_wordsplit` with ':' delimiter and `mu_assoc_install`. It also notes error reporting with context, consistent with `mu_error` calls. No claims contradict the source, and the information is accurate though fairly high-level. Gain is moderate due to brevity and lack of specifics like memory handling or iteration details, but noise is minimal."
            ]
        },
        "cfg": {
            "summary": "Parses a colon-delimited string into key-value pairs, storing them in an association list and returning an error code on failure.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function parses a colon-delimited string into key-value pairs, stores them in an association list, and returns an error code on failure. These behaviors are directly reflected in the source code through the use of `ws.ws_delim = \":\"`, splitting, installing into `assoc_tab`, and returning `rc`. The claims are all specific to the code's semantics and match exactly, resulting in a high proportion of accurate claims.",
                "The summary correctly identifies the core purpose as parsing a colon-delimited string into key-value pairs stored in an association list, matching the function's specific domain action. It also notes that the function returns an error code on failure, which aligns with the code's error handling. However, it omits secondary behaviors such as handling missing '=' delimiters, creating and configuring the association table, memory allocation steps, freeing resources, and setting the error index via perr. This limits coverage of broader critical semantics.",
                "The summary accurately states the primary purpose of parsing a colon-delimited string into key-value pairs and storing them in an association list, as well as returning an error code on failure. These are core domain behaviors found in the source code. It omits some implementation details such as error position reporting via 'perr' and specific creation/setup of the assoc_tab, but there are no inaccurate claims or significant noise. The gain is moderate due to brevity and lack of deep specifics."
            ]
        },
        "comment": {
            "summary": "Parses a colon-delimited string into a key-value association table, handling errors for malformed entries and memory allocation failures.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function parses a colon-delimited string into a key-value association table, which matches the code's use of mu_wordsplit with \":\" and subsequent token splitting at '='. It also accurately mentions error handling for malformed entries (absence of '=') and memory allocation failures (strdup failure). All claims are specific to the source code's behavior and are correct, resulting in high accuracy.",
                "The summary accurately conveys the core purpose of parsing a colon-delimited string into a key-value association table, matching the function\u2019s main domain-specific action. It also mentions error handling for malformed entries and memory allocation failures, which are present in the code. However, it omits other secondary details such as initialization of the association table, freeing resources, setting destroy item handlers, returning error codes, and specific split error handling, leading to incomplete coverage of behavior-critical semantics.",
                "The summary is accurate: it correctly identifies that the function parses a colon-delimited string into key-value pairs, creates an association table, and addresses errors for malformed entries and allocation failures. These map directly to the source code's use of 'mu_wordsplit' with ':' delimiter, checking for '=' in tokens, and handling allocation errors. The claims are specific to the core purpose with no contradictory or irrelevant noise. However, the description omits some lower-level details like the use of 'perr' to return the error index, so the gain is solid but not exhaustive."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 988464,
    "strip_function_name": "sub_F1530",
    "strip_decompiled_code": "__int64 __fastcall sub_F1530(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v10; // rax\n  __int64 v11; // r12\n  __int64 v12; // rdi\n  __int64 (__fastcall *v14)(int, int, int, int, int, int, char); // rbp\n  _QWORD *v15; // rax\n  __int64 (__fastcall *v16)(int, int, int, int, int, int, char); // rbp\n  _QWORD *v17; // rax\n\n  if ( !qword_3605B0 || !a1 )\n    return 0xFFFFFFFFLL;\n  if ( xmlHashLookup(qword_3605B0, (unsigned __int8 *)a1) )\n  {\n    v16 = *_xmlGenericError();\n    v17 = _xmlGenericErrorContext();\n    ((void (*)(_QWORD, const char *, ...))v16)(*v17, \"Relax-NG types library '%s' already registered\\n\", a1);\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    v10 = xmlMalloc(0x38uLL);\n    v11 = (__int64)v10;\n    if ( v10 )\n    {\n      v10[6] = 0LL;\n      *(_OWORD *)v10 = 0LL;\n      *((_OWORD *)v10 + 1) = 0LL;\n      *((_OWORD *)v10 + 2) = 0LL;\n      *v10 = xmlStrdup(a1);\n      v12 = qword_3605B0;\n      *(_QWORD *)(v11 + 8) = 0LL;\n      *(_QWORD *)(v11 + 16) = a2;\n      *(_QWORD *)(v11 + 32) = a4;\n      *(_QWORD *)(v11 + 24) = a3;\n      *(_QWORD *)(v11 + 40) = a5;\n      *(_QWORD *)(v11 + 48) = a6;\n      if ( (int)xmlHashAddEntry(v12, (unsigned __int8 *)a1, v11) < 0 )\n      {\n        v14 = *_xmlGenericError();\n        v15 = _xmlGenericErrorContext();\n        ((void (*)(_QWORD, const char *, ...))v14)(*v15, \"Relax-NG types library failed to register '%s'\\n\", a1);\n        if ( *(_QWORD *)v11 )\n          xmlFree(*(void **)v11);\n        xmlFree((void *)v11);\n        return 0xFFFFFFFFLL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      sub_E9D50(0LL, (__int64)\"adding types library\\n\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n}\n",
    "function_name": "xmlRelaxNGRegisterTypeLibrary",
    "decompiled_code": "__int64 __fastcall xmlRelaxNGRegisterTypeLibrary(\n        const xmlChar *a1,\n        xmlChar *data,\n        xmlChar *have,\n        xmlChar *check,\n        xmlChar *comp,\n        xmlChar *facet)\n{\n  xmlChar **v10; // rax\n  xmlChar **v11; // r12\n  xmlHashTable *v12; // rdi\n  xmlGenericErrorFunc v14; // rbp\n  void **v15; // rax\n  xmlGenericErrorFunc v16; // rbp\n  void **v17; // rax\n\n  if ( !xmlRelaxNGRegisteredTypes || !a1 )\n    return 0xFFFFFFFFLL;\n  if ( xmlHashLookup__internal_alias(xmlRelaxNGRegisteredTypes, a1) )\n  {\n    v16 = *_xmlGenericError__internal_alias();\n    v17 = _xmlGenericErrorContext__internal_alias();\n    v16(*v17, \"Relax-NG types library '%s' already registered\\n\", (const char *)a1);\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    v10 = (xmlChar **)xmlMalloc(0x38uLL);\n    v11 = v10;\n    if ( v10 )\n    {\n      v10[6] = 0LL;\n      *(_OWORD *)v10 = 0LL;\n      *((_OWORD *)v10 + 1) = 0LL;\n      *((_OWORD *)v10 + 2) = 0LL;\n      *v10 = xmlStrdup__internal_alias(a1);\n      v12 = xmlRelaxNGRegisteredTypes;\n      v11[1] = 0LL;\n      v11[2] = data;\n      v11[4] = check;\n      v11[3] = have;\n      v11[5] = comp;\n      v11[6] = facet;\n      if ( xmlHashAddEntry__internal_alias(v12, a1, v11) < 0 )\n      {\n        v14 = *_xmlGenericError__internal_alias();\n        v15 = _xmlGenericErrorContext__internal_alias();\n        v14(*v15, \"Relax-NG types library failed to register '%s'\\n\", (const char *)a1);\n        if ( *v11 )\n          xmlFree(*v11);\n        xmlFree(v11);\n        return 0xFFFFFFFFLL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      xmlRngVErrMemory(0LL, \"adding types library\\n\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n}\n",
    "source_code": "static int\nxmlRelaxNGRegisterTypeLibrary(const xmlChar * namespace, void *data,\n                              xmlRelaxNGTypeHave have,\n                              xmlRelaxNGTypeCheck check,\n                              xmlRelaxNGTypeCompare comp,\n                              xmlRelaxNGFacetCheck facet,\n                              xmlRelaxNGTypeFree freef)\n{\n    xmlRelaxNGTypeLibraryPtr lib;\n    int ret;\n\n    if ((xmlRelaxNGRegisteredTypes == NULL) || (namespace == NULL) ||\n        (check == NULL) || (comp == NULL))\n        return (-1);\n    if (xmlHashLookup(xmlRelaxNGRegisteredTypes, namespace) != NULL) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library '%s' already registered\\n\",\n                        namespace);\n        return (-1);\n    }\n    lib =\n        (xmlRelaxNGTypeLibraryPtr)\n        xmlMalloc(sizeof(xmlRelaxNGTypeLibrary));\n    if (lib == NULL) {\n        xmlRngVErrMemory(NULL, \"adding types library\\n\");\n        return (-1);\n    }\n    memset(lib, 0, sizeof(xmlRelaxNGTypeLibrary));\n    lib->namespace = xmlStrdup(namespace);\n    lib->data = data;\n    lib->have = have;\n    lib->comp = comp;\n    lib->check = check;\n    lib->facet = facet;\n    lib->freef = freef;\n    ret = xmlHashAddEntry(xmlRelaxNGRegisteredTypes, namespace, lib);\n    if (ret < 0) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library failed to register '%s'\\n\",\n                        namespace);\n        xmlRelaxNGFreeTypeLibrary(lib, namespace);\n        return (-1);\n    }\n    return (0);\n}",
    "comment": "Registers a new Relax-NG types library with a given namespace and associated functions in the xmlRelaxNGRegisteredTypes hash table.",
    "hext5_sum": "push a pointer to the corresponding user data structures.",
    "bint5_sum": "Registers a new RelaxNG grammar type if it does not already exist in the context or the global list , returning success or failure status .\n",
    "cpbcs_sum": "Creates a new XML schema context with specified attributes and context, initializing necessary resources and handling memory allocation errors.\n",
    "misum_sum": "Logs an error message with context and line information, including source and line number, type, while reporting the error message.\n",
    "decom_sum": "Registers a new Relax-NG types library in an XML hash table, reporting errors if the library is already registered or registration fails.",
    "cfg_sum": "Registers a Relax-NG types library in an XML hash table, allocating and initializing its entry, and reports errors if allocation or registration fails.",
    "work_score": {
        "decom": {
            "summary": "Registers a new Relax-NG types library in an XML hash table, reporting errors if the library is already registered or registration fails.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function registers a new Relax-NG types library in an XML hash table and reports errors if it is already registered or registration fails. These reflect the core purpose and observable behaviors in the source code, with no contradictory or irrelevant claims. All extracted claims align with the code\u2019s semantics, yielding high coverage of accurate statements.",
                "The summary correctly identifies the core purpose as registering a new Relax-NG types library in an XML hash table and notes key error conditions like pre-existing registration and registration failure, both of which align with the source code. However, it omits secondary details such as required non-null parameters, allocation and initialization of the library struct, duplication of the namespace string, assignment of function pointers, handling of memory allocation errors, and freeing the library on failure. Coverage of these behaviors would make the summary more complete.",
                "The summary correctly identifies the core purpose of the function \u2014 registering a new Relax-NG types library in an XML hash table \u2014 and notes the key error cases when the library is already registered or registration fails. These claims match the source code\u2019s logic without contradictions. However, the summary omits specific accuracy-enhancing details from the code, such as the requirement for certain function pointers and the handling of memory allocation failures. The gain is modest but with minimal noise, resulting in a positive yet limited net benefit."
            ]
        },
        "cfg": {
            "summary": "Registers a Relax-NG types library in an XML hash table, allocating and initializing its entry, and reports errors if allocation or registration fails.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately captures the function's core behavior: registering a Relax-NG types library in a hash table, allocating and initializing its entry, and reporting errors when allocation or registration fail. All elements match the source code semantics and no incorrect or irrelevant claims are present, yielding high precision.",
                "The summary accurately conveys the core purpose of the function\u2014registering a Relax-NG types library into a hash table with allocation, initialization, and error reporting\u2014which matches the primary domain operation in the source code. It correctly notes allocation and registration failure handling. However, it omits several secondary details, such as the precondition checks for null pointers, prevention of duplicate registrations, and assignment of specific callback function pointers (have, check, comp, facet, freef). These omissions reduce completeness despite correct core coverage.",
                "The summary correctly captures the primary purpose of the function\u2014registering a Relax-NG types library in an XML hash table\u2014and mentions key steps such as allocation, initialization, and error handling on allocation or registration failure. These are accurate, specific, and aligned with the source code. There is no contradictory or irrelevant information; noise is minimal. While the summary omits some secondary details (like duplicate namespace checks and exact function arguments), it still provides clear and relevant coverage of the core logic."
            ]
        },
        "comment": {
            "summary": "Registers a new Relax-NG types library with a given namespace and associated functions in the xmlRelaxNGRegisteredTypes hash table.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function registers a new Relax-NG types library with a given namespace and associated functions in the xmlRelaxNGRegisteredTypes hash table. This matches the core logic of the source code, which allocates and initializes a library struct with provided callbacks and stores it in the hash table if not already registered. No inaccuracies or irrelevant information are present, indicating high alignment with source semantics.",
                "The summary correctly identifies the core purpose as registering a new Relax-NG types library with a namespace and function pointers in the xmlRelaxNGRegisteredTypes hash table, matching the source code's main operation. However, it omits important secondary details such as null checks for parameters, prevention of duplicate registration, memory allocation and initialization of the library struct, error reporting via xmlGenericError and xmlRngVErrMemory, cleanup on failure, and return value semantics. Coverage is limited to the main action without broader behavior-critical specifics.",
                "The summary accurately captures the primary purpose of the function, stating that it registers a new Relax-NG types library with a given namespace and functions in the xmlRelaxNGRegisteredTypes hash table. There are no contradictory or irrelevant claims, and noise is minimal. However, the summary is generic and omits specific conditions such as required non-null parameters, duplicate-check behavior, and error handling, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "libevent",
    "function_addr": 96816,
    "strip_function_name": "sub_17A30",
    "strip_decompiled_code": "__int64 __fastcall sub_17A30(__int64 a1, __int64 a2)\n{\n  __int64 input; // rax\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int (__fastcall *v6)(__int64, _QWORD); // rax\n  int v7; // eax\n  int v8; // edx\n  __int64 v9; // rsi\n\n  input = bufferevent_get_input();\n  result = evhttp_parse_headers_(a2, input);\n  if ( (result & 0xFFFFFFFD) == 0xFFFFFFFD )\n  {\n    if ( event_debug_logging_mask_ )\n      event_debugx_();\n    goto LABEL_4;\n  }\n  if ( (_DWORD)result )\n  {\n    v6 = *(int (__fastcall **)(__int64, _QWORD))(a2 + 184);\n    if ( v6 )\n    {\n      v5 = 1LL;\n      if ( v6(a2, *(_QWORD *)(a2 + 168)) < 0 )\n        return evhttp_connection_fail_(a1, v5);\n    }\n    v7 = *(_DWORD *)(a2 + 72);\n    if ( !v7 )\n    {\n      if ( !event_debug_logging_mask_ )\n        return sub_176F0(a1, a2);\n      goto LABEL_17;\n    }\n    if ( v7 != 1 )\n    {\n      event_warnx();\nLABEL_4:\n      v5 = 2LL;\n      return evhttp_connection_fail_(a1, v5);\n    }\n    v8 = *(_DWORD *)(a2 + 116);\n    if ( v8 == 100 )\n    {\n      bufferevent_get_output();\n      v9 = *(_QWORD *)(a2 + 152);\n      evbuffer_add_buffer();\n      return evhttp_start_write_(a1, v9);\n    }\n    else\n    {\n      if ( v8 != 204 && v8 != 304 && (unsigned int)(v8 - 100) > 0x63 && *(_DWORD *)(a2 + 76) != 4 )\n      {\n        if ( !event_debug_logging_mask_ )\n          return sub_176F0(a1, a2);\nLABEL_17:\n        event_debugx_();\n        return sub_176F0(a1, a2);\n      }\n      if ( event_debug_logging_mask_ )\n        event_debugx_();\n      return sub_16800(a1);\n    }\n  }\n  return result;\n}\n",
    "function_name": "evhttp_read_header",
    "decompiled_code": "__int64 __fastcall evhttp_read_header(__int64 a1, __int64 a2)\n{\n  __int64 input; // rax\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int (__fastcall *v6)(__int64, _QWORD); // rax\n  int v7; // eax\n  int v8; // edx\n  __int64 v9; // rsi\n\n  input = bufferevent_get_input();\n  result = evhttp_parse_headers_(a2, input);\n  if ( (result & 0xFFFFFFFD) == 0xFFFFFFFD )\n  {\n    if ( event_debug_logging_mask_ )\n      event_debugx_();\n    goto LABEL_4;\n  }\n  if ( (_DWORD)result )\n  {\n    v6 = *(int (__fastcall **)(__int64, _QWORD))(a2 + 184);\n    if ( v6 )\n    {\n      v5 = 1LL;\n      if ( v6(a2, *(_QWORD *)(a2 + 168)) < 0 )\n        return evhttp_connection_fail_(a1, v5);\n    }\n    v7 = *(_DWORD *)(a2 + 72);\n    if ( !v7 )\n    {\n      if ( !event_debug_logging_mask_ )\n        return evhttp_get_body(a1, a2);\n      goto LABEL_17;\n    }\n    if ( v7 != 1 )\n    {\n      event_warnx();\nLABEL_4:\n      v5 = 2LL;\n      return evhttp_connection_fail_(a1, v5);\n    }\n    v8 = *(_DWORD *)(a2 + 116);\n    if ( v8 == 100 )\n    {\n      bufferevent_get_output();\n      v9 = *(_QWORD *)(a2 + 152);\n      evbuffer_add_buffer();\n      return evhttp_start_write_(a1, v9);\n    }\n    else\n    {\n      if ( v8 != 204 && v8 != 304 && (unsigned int)(v8 - 100) > 0x63 && *(_DWORD *)(a2 + 76) != 4 )\n      {\n        if ( !event_debug_logging_mask_ )\n          return evhttp_get_body(a1, a2);\nLABEL_17:\n        event_debugx_();\n        return evhttp_get_body(a1, a2);\n      }\n      if ( event_debug_logging_mask_ )\n        event_debugx_();\n      return evhttp_connection_done(a1);\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void\nevhttp_read_header(struct evhttp_connection *evcon,\n\t\t   struct evhttp_request *req)\n{\n\tenum message_read_status res;\n\tevutil_socket_t fd = evcon->fd;\n\n\tres = evhttp_parse_headers_(req, bufferevent_get_input(evcon->bufev));\n\tif (res == DATA_CORRUPTED || res == DATA_TOO_LONG) {\n\t\t/* Error while reading, terminate */\n\t\tevent_debug((\"%s: bad header lines on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\treturn;\n\t} else if (res == MORE_DATA_EXPECTED) {\n\t\t/* Need more header lines */\n\t\treturn;\n\t}\n\n\t/* Callback can shut down connection with negative return value */\n\tif (req->header_cb != NULL) {\n\t\tif ((*req->header_cb)(req, req->cb_arg) < 0) {\n\t\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_EOF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Done reading headers, do the real work */\n\tswitch (req->kind) {\n\tcase EVHTTP_REQUEST:\n\t\tevent_debug((\"%s: checking for post data on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_get_body(evcon, req);\n\t\t/* note the request may have been freed in evhttp_get_body */\n\t\tbreak;\n\n\tcase EVHTTP_RESPONSE:\n\t\t/* Start over if we got a 100 Continue response. */\n\t\tif (req->response_code == 100) {\n\t\t\tstruct evbuffer *output = bufferevent_get_output(evcon->bufev);\n\t\t\tevbuffer_add_buffer(output, req->output_buffer);\n\t\t\tevhttp_start_write_(evcon);\n\t\t\treturn;\n\t\t}\n\t\tif (!evhttp_response_needs_body(req)) {\n\t\t\tevent_debug((\"%s: skipping body for code %d\\n\",\n\t\t\t\t\t__func__, req->response_code));\n\t\t\tevhttp_connection_done(evcon);\n\t\t} else {\n\t\t\tevent_debug((\"%s: start of read body for %s on \"\n\t\t\t\tEV_SOCK_FMT\"\\n\",\n\t\t\t\t__func__, req->remote_host, EV_SOCK_ARG(fd)));\n\t\t\tevhttp_get_body(evcon, req);\n\t\t\t/* note the request may have been freed in\n\t\t\t * evhttp_get_body */\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tevent_warnx(\"%s: bad header on \"EV_SOCK_FMT, __func__,\n\t\t    EV_SOCK_ARG(fd));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\tbreak;\n\t}\n\t/* request may have been freed above */\n}",
    "comment": "Processes incoming HTTP headers, validates them, invokes a callback if present, and handles the request or response body based on the type and status.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes HTTP trailer data , handling header parsing and managing connection state , timeouts , and error statuses accordingly .\n",
    "cpbcs_sum": "Handles the result of a DNS HTTP write event, managing timeouts and dispatching write events based on the new state.\n",
    "misum_sum": "Handles the HTTP response by parsing the data, parsing the data, and setting a timeout code or triggering a timeout callback.\n",
    "decom_sum": "Parses HTTP headers from a buffered event, handles protocol-specific responses, logs debug information, and manages connection success or failure accordingly.",
    "cfg_sum": "Parses HTTP headers from a buffered event, handles protocol-specific responses, and manages connection state with conditional logging and error handling.",
    "work_score": {
        "decom": {
            "summary": "Parses HTTP headers from a buffered event, handles protocol-specific responses, logs debug information, and manages connection success or failure accordingly.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly notes that the function parses HTTP headers from a buffered event, handles protocol-specific responses, logs debug information, and manages connection success or failure. All these points align with the source code\u2019s behavior, including parsing via evhttp_parse_headers_, branching on response type, logging with event_debug, and triggering connection fail or completion. The claims are accurate and cover the main code semantics without contradiction, yielding high precision.",
                "The summary correctly identifies parsing HTTP headers from a buffered event and mentions handling responses, logging debug info, and managing connection status, which are accurate. However, it does not specifically cover the core purpose of reading and processing HTTP request/response headers with detailed handling for cases such as DATA_CORRUPTED, DATA_TOO_LONG, MORE_DATA_EXPECTED, or the 100 Continue response, nor does it describe subsequent body handling. This results in weak coverage of critical branch and error semantics.",
                "The summary correctly states that the function parses HTTP headers from a buffered event, handles protocol-specific responses, logs debug information, and manages connection success or failure. These are accurate, high-level descriptions matching the code\u2019s behavior. However, the claims are generic and omit specific control flow details, such as handling special cases like '100 Continue' or invoking callbacks that may terminate the connection. There is no inaccurate or contradictory statement, but the information gain is low due to the broadness of the description."
            ]
        },
        "cfg": {
            "summary": "Parses HTTP headers from a buffered event, handles protocol-specific responses, and manages connection state with conditional logging and error handling.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function parses HTTP headers from a buffered event, processes protocol-specific responses, and manages the connection state with conditional logging and error handling, all of which are evident in the code. However, it omits several specific behaviors such as the handling of corrupted or overly long headers, the 100 Continue response case, and invoking a header callback, making it generic rather than highly precise. Most claims are accurate but low-detail, indicating a high proportion of correct yet non-distinguishing statements.",
                "The summary accurately states that the function parses HTTP headers from a buffered event and handles protocol-specific responses with error handling, which aligns with the code's core purpose. However, it is vague on critical specifics such as the detailed branching for request vs response, special handling for 100 Continue responses, conditions for skipping the body, the use of header callbacks, and connection termination conditions. These omissions mean the secondary behavior coverage is limited.",
                "The summary correctly notes that the function parses HTTP headers from a buffered event, handles protocol-specific responses, and manages connection state with logging and error handling. These are accurate, high-level reflections of the code's main purpose and flow. However, the claims are generic and omit specific details like handling different read status outcomes, invoking header callbacks, special-case handling for 100 Continue, and differentiating between request/response kinds. No inaccurate statements are present, but the gain is low due to lack of specificity."
            ]
        },
        "comment": {
            "summary": "Processes incoming HTTP headers, validates them, invokes a callback if present, and handles the request or response body based on the type and status.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function processes incoming HTTP headers, performs validation, optionally invokes a callback, and branches into request or response handling based on type and status. These points are directly reflected in the source code\u2019s parsing, error handling, callback check, and switch-case logic for EVHTTP_REQUEST and EVHTTP_RESPONSE. No contradictory or off-topic claims are present, making the coverage highly accurate, though the description is generalized and omits some specific conditions, such as distinct error scenarios and special 100 Continue handling.",
                "The summary correctly captures the core purpose \u2014 reading and validating HTTP headers, invoking a header callback, and branching to handle request or response bodies depending on type and status \u2014 which matches the function's primary logic. However, while it notes validation and type/status-based branching, it omits important secondary details such as handling specific error codes (DATA_CORRUPTED, DATA_TOO_LONG, MORE_DATA_EXPECTED), managing 100 Continue responses, skipping bodies when unnecessary, and conditions that free the request object. These omissions limit coverage of critical edge cases and side effects present in the source code.",
                "The summary accurately captures the core behavior of the function: reading and validating headers, invoking a callback if present, and differentiating processing based on whether it's a request or response, including handling body as appropriate. It omits finer details such as specific error conditions (DATA_CORRUPTED, DATA_TOO_LONG, MORE_DATA_EXPECTED) and special cases like '100 Continue' responses, but these omissions are minor and do not introduce inaccuracies. The claims are generic but correct, yielding moderate informational value with low noise."
            ]
        }
    }
}
{
    "project_name": "cflow",
    "function_addr": 30848,
    "strip_function_name": "sub_7880",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_7880(const char *a1)\n{\n  __int64 v1; // rbx\n  char v2; // al\n  const char *i; // rbx\n  char *v4; // rax\n  void *v5; // rax\n  char *v6; // rax\n  char *v8; // rax\n  char *v9; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v10; // [rsp+8h] [rbp-20h]\n\n  v10 = __readfsqword(0x28u);\n  v1 = strtol(a1, &v9, 0);\n  if ( *v9 || v1 <= 0 )\n  {\n    v2 = *a1;\n    for ( i = a1; *i != 61; v2 = *i )\n    {\n      while ( v2 )\n      {\n        v2 = *++i;\n        if ( *i == 61 )\n          goto LABEL_8;\n      }\n      v4 = dcgettext(0LL, \"level-indent syntax\", 5);\n      ++i;\n      error(3, 0, v4);\n    }\nLABEL_8:\n    switch ( (unsigned int)sub_7480((const void **)&off_224080, a1, (int)i - (int)a1) )\n    {\n      case 1u:\n        sub_75C0((char *)i + 1, &off_224160);\n        break;\n      case 2u:\n        sub_75C0((char *)i + 1, (char **)&qword_224E30);\n        break;\n      case 3u:\n        sub_75C0((char *)i + 1, (char **)&qword_224E38);\n        break;\n      case 4u:\n        sub_75C0((char *)i + 1, (char **)&off_224170);\n        break;\n      case 5u:\n        sub_75C0((char *)i + 1, (char **)&off_224178);\n        break;\n      default:\n        v8 = dcgettext(0LL, \"unknown level indent option: %s\", 5);\n        error(3, 0, v8, a1);\n        break;\n    }\n  }\n  else\n  {\n    v5 = (void *)sub_18E60(v1 + 1);\n    v6 = (char *)memset(v5, 32, v1 - 1);\n    v6[v1 - 1] = 0;\n    qword_224E38 = (__int64)v6;\n    qword_224E30 = (__int64)v6;\n  }\n  return __readfsqword(0x28u) ^ v10;\n}\n",
    "function_name": "set_level_indent",
    "decompiled_code": "void __fastcall set_level_indent(const char *str)\n{\n  __int64 v1; // rbx\n  char v2; // al\n  const char *i; // rbx\n  char *v4; // rax\n  void *v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  char *retaddr; // [rsp+28h] [rbp+0h] BYREF\n\n  v1 = strtol(str, &retaddr, 0);\n  if ( *retaddr || v1 <= 0 )\n  {\n    v2 = *str;\n    for ( i = str; *i != 61; v2 = *i )\n    {\n      while ( v2 )\n      {\n        v2 = *++i;\n        if ( *i == 61 )\n          goto LABEL_8;\n      }\n      v4 = dcgettext(0LL, \"level-indent syntax\", 5);\n      ++i;\n      error(3, 0, v4);\n    }\nLABEL_8:\n    switch ( find_option_type(level_indent_optype, str, (_DWORD)i - (_DWORD)str) )\n    {\n      case 1:\n        parse_level_string(i + 1, &level_begin);\n        break;\n      case 2:\n        parse_level_string(i + 1, level_indent);\n        break;\n      case 3:\n        parse_level_string(i + 1, (char **)&qword_224E38);\n        break;\n      case 4:\n        parse_level_string(i + 1, level_end);\n        break;\n      case 5:\n        parse_level_string(i + 1, (char **)&off_224178);\n        break;\n      default:\n        v7 = dcgettext(0LL, \"unknown level indent option: %s\", 5);\n        error(3, 0, v7, str);\n        break;\n    }\n  }\n  else\n  {\n    v5 = xmalloc(v1 + 1);\n    v6 = (char *)memset(v5, 32, v1 - 1);\n    v6[v1 - 1] = 0;\n    qword_224E38 = (__int64)v6;\n    level_indent[0] = v6;\n  }\n}\n",
    "source_code": "\nstatic void\nset_level_indent(const char *str)\n{\n     long n;\n     const char *p;\n     char *q;\n     \n     n = strtol(str, &q, 0);\n     if (*q == 0 && n > 0) {\n\t  char *s = xmalloc(n+1);\n\t  memset(s, ' ', n-1);\n\t  s[n-1] = 0;\n\t  level_indent[0] = level_indent[1] = s;\n\t  return;\n     }\n     \n     p = str;\n     while (*p != '=') {\n\t  if (*p == 0)\n\t       error(EX_USAGE, 0, _(\"level-indent syntax\"));\n\t  p++;\n     }\n     ++p;\n    \n     switch (find_option_type(level_indent_optype, str, p - str - 1)) {\n     case LEVEL_BEGIN:\n\t  parse_level_string(p, &level_begin);\n\t  break;\n     case LEVEL_INDENT0:\n\t  parse_level_string(p, &level_indent[0]);\n\t  break;\n     case LEVEL_INDENT1:\n\t  parse_level_string(p, &level_indent[1]);\n\t  break;\n     case LEVEL_END0:\n\t  parse_level_string(p, &level_end[0]);\n\t  break;\n     case LEVEL_END1:\n\t  parse_level_string(p, &level_end[1]);\n\t  break;\n     default:\n\t  error(EX_USAGE, 0, _(\"unknown level indent option: %s\"), str);\n     }\n}",
    "comment": "Sets the level indentation based on a string input, allocating space for indentation or parsing specific level configuration options.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Parses a level-indent syntax string into a linked list of levels , validating the input and managing memory for each level .\n",
    "cpbcs_sum": "Validates and processes an XML name string by checking its type, ensuring it contains only ASCII characters before setting the type character.\n",
    "misum_sum": "Validates and sets a variable's numeric option string by checking its characters and converting it to an unsigned long integer.\n",
    "decom_sum": "Parses and applies a level-indent configuration, either setting predefined indent styles or creating a custom space-filled indent of specified length.",
    "cfg_sum": "Parses a level indent option string, validates syntax, sets corresponding global indent styles, or reports errors for unknown or invalid formats.",
    "work_score": {
        "decom": {
            "summary": "Parses and applies a level-indent configuration, either setting predefined indent styles or creating a custom space-filled indent of specified length.",
            "score": [
                0.8,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function parses and applies a level-indent configuration and can create a custom space-filled indent with a specified length, which aligns with the code's use of strtol, xmalloc, and memset for that purpose. However, it omits specific details about handling various option types (LEVEL_BEGIN, LEVEL_INDENT0, etc.) and the associated parse_level_string calls, making the description less comprehensive. Most claims are accurate, with only minor loss of detail.",
                "The summary correctly identifies that the function processes a level-indent configuration and can either apply predefined styles or create a custom space-filled indent of a given length, which matches the core purpose of parsing input and setting appropriate indent values. However, it omits significant secondary details from the code, such as error handling for syntax issues, the specific handling of '=' delimiter in options, the mapping through option types to different indent targets, and calls to specific parsing functions for each option type. This limits coverage of behavior-critical semantics beyond the core purpose.",
                "The summary accurately captures the primary function behavior: interpreting a configuration string to set level-indent, either by selecting predefined styles or creating a space-filled indent of given length. There is no contradiction with the source code, and no irrelevant noise. However, the description is fairly general and omits details such as error handling, parsing until '=' for option name, and handling multiple specific cases (LEVEL_BEGIN, LEVEL_INDENT0, etc.), so the informative gain is moderate rather than high."
            ]
        },
        "cfg": {
            "summary": "Parses a level indent option string, validates syntax, sets corresponding global indent styles, or reports errors for unknown or invalid formats.",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately reflects the function\u2019s behavior: it parses the level indent option string, validates syntax, sets appropriate global indent style pointers, and reports errors for invalid or unknown formats. All claims are specific to the code\u2019s actual logic and do not contradict it, resulting in a very high proportion of accurate statements.",
                "The summary accurately captures the core purpose of parsing a level indent option string, matching the code's behavior of handling both numeric and named options, and reporting errors on invalid syntax or unknown options. However, it lacks secondary details such as the numeric case allocating and filling a space buffer, the specific mapping to level_indent[0] and [1], and handling LEVEL_BEGIN and LEVEL_END variants. These omissions reduce completeness.",
                "The summary correctly identifies that the function parses a level indent option string, validates its syntax, sets global indent styles, and reports errors for invalid or unknown formats. These are accurate and specific reflections of the source code\u2019s primary purpose and behavior. There is no contradictory or irrelevant noise, and the claims are GOLD-level as they highlight core operations, control flow, and side effects (modifying global state and error handling). This yields high gain with negligible noise."
            ]
        },
        "comment": {
            "summary": "Sets the level indentation based on a string input, allocating space for indentation or parsing specific level configuration options.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately conveys that the function sets level indentation from a string, either by allocating space for indentation when numeric input is provided or by parsing configuration options based on the input string format. It aligns with the source code\u2019s handling of numeric indentation values via strtol/xmalloc and parsing named level options with find_option_type and parse_level_string. All key behaviors are correctly described without introducing contradictions.",
                "The summary accurately captures the core purpose of setting level indentation based on a string, including both cases where space is allocated and where specific level options are parsed, which matches the function\u2019s main effect. However, it omits important secondary details such as how positive numeric values trigger allocation, the exact parsing logic for '=' separated options, the use of find_option_type to determine which configuration to modify, handling of various LEVEL_* cases, and error conditions for invalid syntax or unknown options. These omissions reduce completeness despite correct core coverage.",
                "The summary correctly captures the primary purpose of the function\u2014configuring the level indentation from a string input, either by allocating space or by parsing specific level-related options. Both aspects are directly supported by the code: the strtol path allocates memory for spaces and sets indentation arrays, while the switch statement parses level strings for various configuration types. There is no inaccurate or irrelevant content, but the description is somewhat broad and lacks detail about how different options (LEVEL_BEGIN, LEVEL_INDENT0, etc.) are handled, resulting in moderate informational gain."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 368656,
    "strip_function_name": "ngx_http_map_find",
    "strip_decompiled_code": "__int64 __fastcall ngx_http_map_find(\n        __int64 a1,\n        _QWORD *a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  unsigned __int64 v11; // rbp\n  unsigned __int64 v13; // rax\n  _BYTE *v14; // r14\n  unsigned __int64 v15; // rax\n  __int64 result; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rbp\n  unsigned __int64 v20; // r14\n  __int64 v21; // rax\n  unsigned __int64 v22; // rax\n\n  v11 = *(_QWORD *)a3;\n  if ( !*(_QWORD *)a3 )\n  {\n    v22 = ngx_hash_strlow(0LL, *(_QWORD *)(a3 + 8), 0LL);\n    return ngx_hash_find_combined(a2, v22, 0LL, 0LL);\n  }\n  v13 = ngx_pnalloc(*(_QWORD **)(a1 + 88), *(_QWORD *)a3);\n  v14 = (_BYTE *)v13;\n  if ( !v13 )\n    return 0LL;\n  v15 = ngx_hash_strlow(v13, *(_QWORD *)(a3 + 8), v11);\n  result = ngx_hash_find_combined(a2, v15, v14, v11);\n  if ( result )\n    return result;\n  if ( !a2[5] )\n    return 0LL;\n  v19 = a2[4];\n  v20 = 0LL;\n  while ( 1 )\n  {\n    v21 = ngx_http_regex_exec(a1, *(_QWORD **)v19, a3, a4, a5, a6, a7, v17, v18, a10, a11);\n    if ( !v21 )\n      break;\n    if ( v21 == -5 )\n    {\n      ++v20;\n      v19 += 16LL;\n      if ( a2[5] > v20 )\n        continue;\n    }\n    return 0LL;\n  }\n  return *(_QWORD *)(v19 + 8);\n}\n",
    "function_name": "ngx_http_map_find",
    "decompiled_code": "void *__fastcall ngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)\n{\n  size_t len; // rbp\n  u_char *v5; // rax\n  u_char *v6; // r14\n  ngx_uint_t v7; // rax\n  void *result; // rax\n  ngx_http_map_regex_t *regex; // rbp\n  ngx_uint_t v10; // r14\n  ngx_int_t v11; // rax\n  ngx_uint_t v12; // rax\n\n  len = match->len;\n  if ( !match->len )\n  {\n    v12 = ngx_hash_strlow(0LL, match->data, 0LL);\n    return ngx_hash_find_combined(&map->hash, v12, 0LL, 0LL);\n  }\n  v5 = (u_char *)ngx_pnalloc(r->pool, match->len);\n  v6 = v5;\n  if ( !v5 )\n    return 0LL;\n  v7 = ngx_hash_strlow(v5, match->data, len);\n  result = ngx_hash_find_combined(&map->hash, v7, v6, len);\n  if ( result )\n    return result;\n  if ( !map->nregex )\n    return 0LL;\n  regex = map->regex;\n  v10 = 0LL;\n  while ( 1 )\n  {\n    v11 = ngx_http_regex_exec(r, regex->regex, match);\n    if ( !v11 )\n      break;\n    if ( v11 == -5 )\n    {\n      ++v10;\n      ++regex;\n      if ( map->nregex > v10 )\n        continue;\n    }\n    return 0LL;\n  }\n  return regex->value;\n}\n",
    "source_code": "\n\nvoid *\nngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)\n{\n    void        *value;\n    u_char      *low;\n    size_t       len;\n    ngx_uint_t   key;\n\n    len = match->len;\n\n    if (len) {\n        low = ngx_pnalloc(r->pool, len);\n        if (low == NULL) {\n            return NULL;\n        }\n\n    } else {\n        low = NULL;\n    }\n\n    key = ngx_hash_strlow(low, match->data, len);\n\n    value = ngx_hash_find_combined(&map->hash, key, low, len);\n    if (value) {\n        return value;\n    }\n\n#if (NGX_PCRE)\n\n    if (len && map->nregex) {\n        ngx_int_t              n;\n        ngx_uint_t             i;\n        ngx_http_map_regex_t  *reg;\n\n        reg = map->regex;\n\n        for (i = 0; i < map->nregex; i++) {\n\n            n = ngx_http_regex_exec(r, reg[i].regex, match);\n\n            if (n == NGX_OK) {\n                return reg[i].value;\n            }\n\n            if (n == NGX_DECLINED) {\n                continue;\n            }\n\n            /* NGX_ERROR */\n\n            return NULL;\n        }\n    }\n\n#endif\n\n    return NULL;\n}",
    "comment": "Finds a corresponding value in a hash map or regex patterns for a given string in an HTTP request.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Finds a key-value pair in a hash table using a combined key and returns the corresponding entry from the combined hash table .\n",
    "cpbcs_sum": "Merges an HTTP URI with a specified name and type, or retrieves its index from the shared memory block.\n",
    "misum_sum": "Generates a unique temporary filename based on an HTTP location and name, handling case sensitivity and errors.\n",
    "decom_sum": "Finds an HTTP map entry by lowercase-hash lookup and falls back to regex matching when no direct hash match is found.",
    "cfg_sum": "Searches for a matching entry in a hash table using a lowercase key, and falls back to regex matching if no hash match is found.",
    "work_score": {
        "decom": {
            "summary": "Finds an HTTP map entry by lowercase-hash lookup and falls back to regex matching when no direct hash match is found.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary contains two main claims: 1) the function finds an HTTP map entry using a lowercase-hash lookup, which matches the code\u2019s use of `ngx_hash_strlow` and `ngx_hash_find_combined`, and 2) it falls back to regex matching when no direct hash match is found, which is supported by the conditional regex logic after a failed hash lookup. Both claims are accurate and reflect the actual implementation details, indicating a high proportion of precise and verifiable statements.",
                "The summary accurately captures the core purpose of the function: it describes finding an HTTP map entry via lowercase-hash lookup and falling back to regex if no direct match exists, which aligns with the domain-specific behavior in the source. However, it omits secondary details such as memory allocation from the request pool, handling of zero-length matches, conditional compilation for regex support, and explicit return behaviors on errors or declined matches. The coverage of secondary semantics is minimal.",
                "The summary accurately describes the primary purpose: performing a lowercase hash lookup to find an HTTP map entry and falling back to regex matching if no direct match is found. This aligns with the source code\u2019s sequence: converting the match string to lowercase, computing a hash, checking the hash table, and then using regex matching when applicable. There are no inaccurate or noisy claims, but the description is concise and lacks mention of some implementation details (e.g., memory allocation via ngx_pnalloc, handling of NULL returns). The gain is moderate due to correctness on the main logic and low noise."
            ]
        },
        "cfg": {
            "summary": "Searches for a matching entry in a hash table using a lowercase key, and falls back to regex matching if no hash match is found.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly describes the main behavior: it uses a lowercase key to search a hash and falls back to regex matching if no hash match is found. This aligns with the source code, which transforms the input to lowercase, searches the combined hash, and if not found, iterates over regex patterns when enabled. The description is accurate and covers the key semantics without errors, with no irrelevant claims.",
                "The summary correctly captures the core purpose: finding a matching entry in a hash table using a lowercase key and falling back to regex matching if no hash match is found. These are accurate and domain-specific descriptions of the function's primary behavior. However, it omits secondary details such as allocation of memory for the lowercase key, behavior when match length is zero, and handling of regex execution outcomes (OK, DECLINED, ERROR), which are important for complete coverage of behavior-critical semantics.",
                "The summary correctly captures the core behavior: the function searches a hash table using a lowercase key and, if no match is found, falls back to regex matching. These are accurate and specific domain actions reflected in the source code, with no contradictory or irrelevant claims. The detail about using a lowercase key is precise and matches the use of ngx_hash_strlow, and the fallback to regex is correctly described. Noise is negligible and there are no FATAL errors, making the claim highly aligned with the primary purpose."
            ]
        },
        "comment": {
            "summary": "Finds a corresponding value in a hash map or regex patterns for a given string in an HTTP request.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function searches for a matching value in either a hash map or via regex patterns for a given string in an HTTP request, which aligns with the code's logic: first performing a hash lookup, then checking regex matches if enabled and applicable. Although generic and brief, the claim is accurate and grounded in the source code's semantics. There are no inaccurate statements present.",
                "The summary accurately reflects the core purpose of the function, which is to find a matching value in either a hash table or regex list based on a string from the HTTP request, covering both matching methods. However, it omits secondary details such as memory allocation for lowercase transformation, the flow for empty matches, error handling when regex execution fails, and conditional compilation for regex support. This makes the coverage of secondary behavior limited despite correctly capturing the core action.",
                "The summary accurately states that the function searches for a corresponding value either via a hash map or regex patterns using a given string from an HTTP request. This aligns with the source code's core logic (hash lookup followed by regex matching if applicable). The claim is correct but generic, lacking detailed specifics such as allocation behavior, key calculation, or the condition for regex usage. No inaccurate elements are present, but the information gain is low due to the omission of operational details."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 357584,
    "strip_function_name": "ngx_http_request_body_save_filter",
    "strip_decompiled_code": "__int64 __fastcall ngx_http_request_body_save_filter(\n        __int64 a1,\n        _QWORD *a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  __int64 *v10; // r12\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rax\n  __int64 *free_buf; // rax\n  __int64 v16; // rdx\n  __int64 v17; // rsi\n\n  v10 = *(__int64 **)(a1 + 888);\n  if ( ngx_chain_add_copy(*(_QWORD **)(a1 + 88), v10 + 1, a2) )\n    return 500LL;\n  if ( (*(_BYTE *)(a1 + 1247) & 4) != 0 )\n    return 0LL;\n  if ( v10[3] > 0 )\n  {\n    v13 = v10[2];\n    if ( v13 && *(_QWORD *)(v13 + 8) == *(_QWORD *)(v13 + 40) && sub_56600(a1, a3, a4, a5, a6, v11, v12, a9, a10) )\n      return 500LL;\n    return 0LL;\n  }\n  if ( !*v10 && (*(_BYTE *)(a1 + 1246) & 8) == 0 )\n    return 0LL;\n  if ( !sub_56600(a1, a3, a4, a5, a6, v11, v12, a9, a10) )\n  {\n    if ( !*(_QWORD *)(*v10 + 168) )\n      return 0LL;\n    free_buf = ngx_chain_get_free_buf(*(_QWORD **)(a1 + 88), v10 + 5);\n    if ( free_buf )\n    {\n      v16 = *free_buf;\n      *(_OWORD *)(v16 + 64) = 0LL;\n      *(_BYTE *)(v16 + 72) |= 0x10u;\n      *(_OWORD *)(v16 + 16) = 0LL;\n      *(_OWORD *)(v16 + 48) = 0LL;\n      *(_OWORD *)v16 = 0LL;\n      *(_OWORD *)(v16 + 32) = 0LL;\n      v17 = *(_QWORD *)(*v10 + 168);\n      *(_QWORD *)(v16 + 56) = *v10;\n      *(_QWORD *)(v16 + 24) = v17;\n      v10[1] = (__int64)free_buf;\n      return 0LL;\n    }\n  }\n  return 500LL;\n}\n",
    "function_name": "ngx_http_request_body_save_filter",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n{\n  ngx_http_request_body_t *request_body; // r12\n  ngx_buf_t *buf; // rax\n  ngx_chain_t *free_buf; // rax\n  ngx_buf_t *v6; // rdx\n  off_t offset; // rsi\n\n  request_body = r->request_body;\n  if ( ngx_chain_add_copy(r->pool, &request_body->bufs, in) )\n    return 500LL;\n  if ( (*((_BYTE *)r + 1247) & 4) != 0 )\n    return 0LL;\n  if ( request_body->rest > 0 )\n  {\n    buf = request_body->buf;\n    if ( buf && buf->last == buf->end && ngx_http_write_request_body(r) )\n      return 500LL;\n    return 0LL;\n  }\n  if ( !request_body->temp_file && (*((_BYTE *)r + 1246) & 8) == 0 )\n    return 0LL;\n  if ( !ngx_http_write_request_body(r) )\n  {\n    if ( !request_body->temp_file->file.offset )\n      return 0LL;\n    free_buf = ngx_chain_get_free_buf(r->pool, &request_body->free);\n    if ( free_buf )\n    {\n      v6 = free_buf->buf;\n      *(_OWORD *)&v6->shadow = 0LL;\n      *((_BYTE *)v6 + 72) |= 0x10u;\n      *(_OWORD *)&v6->file_pos = 0LL;\n      *(_OWORD *)&v6->tag = 0LL;\n      *(_OWORD *)&v6->pos = 0LL;\n      *(_OWORD *)&v6->start = 0LL;\n      offset = request_body->temp_file->file.offset;\n      v6->file = &request_body->temp_file->file;\n      v6->file_last = offset;\n      request_body->bufs = free_buf;\n      return 0LL;\n    }\n  }\n  return 500LL;\n}\n",
    "source_code": "\n\nngx_int_t\nngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n{\n    ngx_buf_t                 *b;\n    ngx_chain_t               *cl;\n    ngx_http_request_body_t   *rb;\n\n    rb = r->request_body;\n\n#if (NGX_DEBUG)\n\n#if 0\n    for (cl = rb->bufs; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body old buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n#endif\n\n    for (cl = in; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body new buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n\n#endif\n\n    /* TODO: coalesce neighbouring buffers */\n\n    if (ngx_chain_add_copy(r->pool, &rb->bufs, in) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (r->request_body_no_buffering) {\n        return NGX_OK;\n    }\n\n    if (rb->rest > 0) {\n\n        if (rb->buf && rb->buf->last == rb->buf->end\n            && ngx_http_write_request_body(r) != NGX_OK)\n        {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        return NGX_OK;\n    }\n\n    /* rb->rest == 0 */\n\n    if (rb->temp_file || r->request_body_in_file_only) {\n\n        if (ngx_http_write_request_body(r) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (rb->temp_file->file.offset != 0) {\n\n            cl = ngx_chain_get_free_buf(r->pool, &rb->free);\n            if (cl == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            b = cl->buf;\n\n            ngx_memzero(b, sizeof(ngx_buf_t));\n\n            b->in_file = 1;\n            b->file_last = rb->temp_file->file.offset;\n            b->file = &rb->temp_file->file;\n\n            rb->bufs = cl;\n        }\n    }\n\n    return NGX_OK;\n}",
    "comment": "Saves the request body data by copying buffers and managing temporary files for further processing in an NGINX HTTP request.",
    "hext5_sum": "add a routine to set the demangling style to be sure it is valid and allow for any demangler initialization that maybe necessary.",
    "bint5_sum": "Processes the HTTP request body 's buffer , saves it , and manages memory while handling potential errors and end-of-stream conditions .\n",
    "cpbcs_sum": "Processes the end of a DNS request, handling both standard and asynchronous formats while managing memory and request parameters.\n",
    "misum_sum": "Reads data from an HTTP request, handling end-of-file and buffering, while invoking a post-handler if available, while logging errors and managing read errors.\n",
    "decom_sum": "Adds a copy of the HTTP request body chain and manages buffer allocation or cleanup, returning 500 on processing errors.",
    "cfg_sum": "Handles HTTP request body buffers by copying chains, validating completion, initializing a free buffer if needed, and returning appropriate HTTP status codes.",
    "work_score": {
        "decom": {
            "summary": "Adds a copy of the HTTP request body chain and manages buffer allocation or cleanup, returning 500 on processing errors.",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function adds a copy of the HTTP request body chain, which matches the use of ngx_chain_add_copy with rb->bufs, and that it returns HTTP 500 on processing errors, aligning with multiple NGX_HTTP_INTERNAL_SERVER_ERROR return cases. However, it inaccurately generalizes 'manages buffer allocation or cleanup' without capturing the specific conditional behaviors (no buffering, writing to file, creating in-file buffer) and does not explicitly mention when NGX_OK is returned. Overall, most claims are accurate but somewhat generic.",
                "The summary correctly states that the function copies the HTTP request body chain and returns a 500 status on errors, which matches the core purpose and some secondary behavior. However, it is too vague about the buffer handling logic, omits critical conditions such as handling 'rest', 'no_buffering', writing the body to a temporary file, and creating a file-based buffer from temp file data. It lacks specificity on domain actions like integrating new buffers into existing 'rb->bufs' and the conditional writes, thus coverage of secondary semantics is limited.",
                "The summary correctly states that the function adds a copy of the HTTP request body chain and returns a 500 on errors, which aligns with calls to ngx_chain_add_copy and error handling for NGX_HTTP_INTERNAL_SERVER_ERROR. However, it inaccurately claims buffer cleanup management; the code deals with buffer allocation but does not perform explicit cleanup. The description is mostly accurate but lacks detail on specific conditions and key behaviors like handling of request_body_no_buffering or writing to temp files, resulting in low informational gain."
            ]
        },
        "cfg": {
            "summary": "Handles HTTP request body buffers by copying chains, validating completion, initializing a free buffer if needed, and returning appropriate HTTP status codes.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures the main steps of the function: copying buffer chains, checking completion, initializing a free buffer under certain conditions, and returning HTTP status codes. These details match the source code behavior without introducing inaccuracies, making all claims accurate and relevant to the function's semantics.",
                "The summary mentions handling request body buffers, copying chains, verifying completion, buffer initialization, and returning status codes, which aligns with the function\u2019s core purpose of saving incoming request body data into the request\u2019s buffer chain and managing subsequent writing to disk when needed. However, it omits several key details, such as conditional paths for no-buffering mode, writing to temp files or when rb->rest > 0, zeroing and configuring the buffer for file-backed storage, and debug logging behavior. Coverage of secondary, behavior-critical semantics is limited.",
                "The summary is broadly accurate, noting the copying of chains, completion checks, free buffer initialization, and return of HTTP status codes. These correspond correctly to the source code\u2019s behavior, with no contradictory or irrelevant claims. However, the summary is high-level and omits specific flow conditions, such as handling `request_body_no_buffering`, `rest == 0` vs `rest > 0`, and temp file logic, giving only generic insight and little engineering acceleration."
            ]
        },
        "comment": {
            "summary": "Saves the request body data by copying buffers and managing temporary files for further processing in an NGINX HTTP request.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function deals with saving request body data and involves copying buffers, which matches the use of ngx_chain_add_copy in the code. It also mentions managing temporary files for further processing, aligned with the handling of rb->temp_file and file operations. These are accurate domain-specific behaviors from the source. However, the summary omits other relevant conditional flows such as non-buffering mode and writing request body logic, but the claims present are accurate, making the majority >80% accurate.",
                "The summary accurately notes saving request body data by copying buffers and handling temporary files, which matches the core function of adding incoming buffers to the request body and managing temp file storage. However, it is vague and omits key behaviors such as conditional writes when buffering is disabled, handling of remaining body data (rb->rest), specific error return paths, and debug logging. These missing details limit coverage of secondary, behavior-critical semantics.",
                "The summary correctly identifies the core purpose of saving request body data through buffer copying and handling temporary files, which aligns with the source code\u2019s operations using ngx_chain_add_copy and temp file management. However, it is very generic, omitting details such as the conditional logic around buffering modes, writing the body when rb->rest > 0, handling file offsets, and error return values. No inaccurate claims are present, but the gain is low due to lack of specificity."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592359958,
    "strip_function_name": "sub_FFFFFFFF81CE3816",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81CE3816(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned int v8; // ebx\n  double v9; // xmm0_8\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  __int64 v12; // rsi\n  __int64 v13; // rcx\n  __int64 *v14; // rdi\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n\n  v8 = dword_FFFFFFFF81DF2A14;\n  if ( dword_FFFFFFFF81DF2A14 )\n  {\n    v8 = -1;\n    sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF81987710, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  else if ( (qword_FFFFFFFF81CB4E94 & 0x200) != 0 )\n  {\n    v9 = sub_FFFFFFFF81CE5315();\n    sub_FFFFFFFF81CE3394(v9, a2, a3, a4, v10, v11, a7, a8);\n    sub_FFFFFFFF81CE37FB();\n    v12 = ((unsigned int (__fastcall *)(_QWORD))off_FFFFFFFF81CB6AB8[23])((unsigned int)dword_FFFFFFFF81C1B57C);\n    ((void (__fastcall *)(__int64, __int64))off_FFFFFFFF81CB6AB8[37])(32LL, v12);\n    v13 = 1024LL;\n    v14 = qword_FFFFFFFF81DF2A40;\n    while ( v13 )\n    {\n      *(_DWORD *)v14 = v8;\n      v14 = (__int64 *)((char *)v14 + 4);\n      --v13;\n    }\n    _interlockedbittestandset((volatile signed __int32 *)qword_FFFFFFFF81DF2A40, dword_FFFFFFFF81C1B57C);\n    sub_FFFFFFFF81786852();\n    if ( !dword_FFFFFFFF81DF3AE4 && dword_FFFFFFFF81DF5B44 )\n      sub_FFFFFFFF81CE496B(v14);\n    sub_FFFFFFFF81786AD6((__int64)v14, v12, v15, v16, v17, v18);\n    if ( dword_FFFFFFFF81DF2A04 && !dword_FFFFFFFF81DF3AE4 && dword_FFFFFFFF81DF5B44 )\n      sub_FFFFFFFF81CE4A59();\n    else\n      dword_FFFFFFFF81DF5B44 = 0;\n    off_FFFFFFFF81D78B88(v9, a2, a3, a4, v23, v24, a7, a8, (__int64)v14, v12, v19, v20, v21, v22);\n  }\n  else\n  {\n    dword_FFFFFFFF81DF2A14 = 1;\n    v8 = -1;\n    sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF81987721, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  return v8;\n}\n",
    "function_name": "APIC_init_uniprocessor",
    "decompiled_code": "__int64 __fastcall APIC_init_uniprocessor(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned int v8; // ebx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  __int64 v11; // rsi\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // rcx\n  __int64 *v15; // rdi\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  __int64 v20; // r8\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v8 = disable_apic;\n  if ( disable_apic )\n  {\n    v8 = -1;\n    printk((__int64)&unk_FFFFFFFF81987710, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  else if ( (qword_FFFFFFFF81CB4E94 & 0x200) != 0 )\n  {\n    default_setup_apic_routing(a1, a2, a3, a4, a5, a6, a7, a8);\n    verify_local_APIC(a1, a2, a3, a4, v9, v10, a7, a8);\n    connect_bsp_APIC();\n    v11 = (*((unsigned int (__fastcall **)(_QWORD))apic + 23))((unsigned int)boot_cpu_physical_apicid);\n    (*((void (__fastcall **)(__int64, __int64))apic + 37))(32LL, v11);\n    v14 = 1024LL;\n    v15 = phys_cpu_present_map;\n    while ( v14 )\n    {\n      *(_DWORD *)v15 = v8;\n      v15 = (__int64 *)((char *)v15 + 4);\n      --v14;\n    }\n    _interlockedbittestandset((volatile signed __int32 *)phys_cpu_present_map, boot_cpu_physical_apicid);\n    setup_local_APIC(a1, a2, a3, a4, v12, v13, a7, a8);\n    if ( !skip_ioapic_setup && nr_ioapics )\n      enable_IO_APIC(a1, a2, a3, a4, v16, v17, a7, a8);\n    end_local_APIC_setup(a1, a2, a3, a4, v16, v17, a7, a8);\n    if ( smp_found_config && !skip_ioapic_setup && nr_ioapics )\n      setup_IO_APIC(a1, a2, a3, a4, v22, v23, a7, a8);\n    else\n      nr_ioapics = 0;\n    off_FFFFFFFF81D78B88(a1, a2, a3, a4, v22, v23, a7, a8, (__int64)v15, v11, v18, v19, v20, v21);\n  }\n  else\n  {\n    disable_apic = 1;\n    v8 = -1;\n    printk((__int64)&unk_FFFFFFFF81987721, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  return v8;\n}\n",
    "source_code": "\nint __init APIC_init_uniprocessor(void)\n{\n\tif (disable_apic) {\n\t\tpr_info(\"Apic disabled\\n\");\n\t\treturn -1;\n\t}\n#ifdef CONFIG_X86_64\n\tif (!cpu_has_apic) {\n\t\tdisable_apic = 1;\n\t\tpr_info(\"Apic disabled by BIOS\\n\");\n\t\treturn -1;\n\t}\n#else\n\tif (!smp_found_config && !cpu_has_apic)\n\t\treturn -1;\n\n\t/*\n\t * Complain if the BIOS pretends there is one.\n\t */\n\tif (!cpu_has_apic &&\n\t    APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {\n\t\tpr_err(\"BIOS bug, local APIC 0x%x not detected!...\\n\",\n\t\t\tboot_cpu_physical_apicid);\n\t\treturn -1;\n\t}\n#endif\n\n\tdefault_setup_apic_routing();\n\n\tverify_local_APIC();\n\tconnect_bsp_APIC();\n\n#ifdef CONFIG_X86_64\n\tapic_write(APIC_ID, SET_APIC_ID(boot_cpu_physical_apicid));\n#else\n\t/*\n\t * Hack: In case of kdump, after a crash, kernel might be booting\n\t * on a cpu with non-zero lapic id. But boot_cpu_physical_apicid\n\t * might be zero if read from MP tables. Get it from LAPIC.\n\t */\n# ifdef CONFIG_CRASH_DUMP\n\tboot_cpu_physical_apicid = read_apic_id();\n# endif\n#endif\n\tphysid_set_mask_of_physid(boot_cpu_physical_apicid, &phys_cpu_present_map);\n\tsetup_local_APIC();\n\n#ifdef CONFIG_X86_IO_APIC\n\t/*\n\t * Now enable IO-APICs, actually call clear_IO_APIC\n\t * We need clear_IO_APIC before enabling error vector\n\t */\n\tif (!skip_ioapic_setup && nr_ioapics)\n\t\tenable_IO_APIC();\n#endif\n\n\tbsp_end_local_APIC_setup();\n\n#ifdef CONFIG_X86_IO_APIC\n\tif (smp_found_config && !skip_ioapic_setup && nr_ioapics)\n\t\tsetup_IO_APIC();\n\telse {\n\t\tnr_ioapics = 0;\n\t}\n#endif\n\n\tx86_init.timers.setup_percpu_clockev();\n\treturn 0;\n}",
    "comment": "Initializes the local APIC for uniprocessor systems, verifying configuration and enabling IO-APICs as necessary for proper operation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the HPET ( High Precision Event Timer ) if enabled , configures MSI capabilities , reserves platform timers , and notifies CPUs of their online status .\n",
    "cpbcs_sum": "Initializes the boot processor by checking for Intel MADT handling PCI architecture, and checking for BIOS completion or initialization status.\n",
    "misum_sum": "Initializes the Intel IOMMU by checking CPU capabilities, enabling machine check exceptions and configuring error checking for various conditions.\n",
    "decom_sum": "Initializes or resets a hardware buffer, updates control flags, and executes device-specific callbacks based on global status and configuration bits.",
    "cfg_sum": "Handles system state transitions based on global flags, performing initialization, memory updates, conditional cleanup, and invoking registered callbacks before returning updated status.",
    "work_score": {
        "decom": {
            "summary": "Initializes or resets a hardware buffer, updates control flags, and executes device-specific callbacks based on global status and configuration bits.",
            "score": [
                0.1,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about initializing or resetting a hardware buffer, updating control flags, and executing device-specific callbacks based on global status/configuration bits do not accurately reflect the source code. The function sets up and configures the APIC and IO-APIC for a uniprocessor system, performing hardware checks and enabling components as needed. There is no mention of a hardware buffer or generic device callbacks in the code, so the majority of claims are inaccurate.",
                "The summary's claims about initializing/resetting a hardware buffer, updating control flags, and executing device-specific callbacks do not align with the source code's specific purpose of initializing the local APIC and potentially the IO-APIC for a uniprocessor in the x86 architecture. It fails to mention APIC setup, verification, routing, or conditional disabling based on BIOS or configuration, meaning the core purpose is entirely missed and the statements are inaccurate relative to the actual code behavior.",
                "The summary contains only inaccurate claims that misrepresent the function's purpose. The source code clearly initializes a uniprocessor Local APIC, configures routing, verifies and connects the APIC, sets up IO-APICs, and starts per-CPU timers, with logic driven by APIC and BIOS status flags. The summary incorrectly describes operations related to a hardware buffer and device-specific callbacks, which are not present in the code. This is a severe FATAL error targeting the primary purpose and core behavior, making the description unusable."
            ]
        },
        "cfg": {
            "summary": "Handles system state transitions based on global flags, performing initialization, memory updates, conditional cleanup, and invoking registered callbacks before returning updated status.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary is overly generic and does not accurately represent the specific semantics of the function. While it vaguely mentions initialization and conditional operations, it omits critical domain-specific details such as APIC enable/disable checks, BIOS-related conditions, IO-APIC setup, and APIC ID handling. It also incorrectly implies memory updates and registered callbacks, which are not present in the source. Most claims fail to map to verifiable specifics from the code, resulting in low accuracy.",
                "The summary's claims are generic, referencing state transitions, initialization, memory updates, cleanup, and callbacks without accurately reflecting the function's core purpose of initializing the uniprocessor APIC, verifying hardware capabilities, setting APIC routing, connecting BSP APIC, handling IO-APIC setup, and dealing with specific BIOS or crash dump conditions. The core domain action is entirely missing, and none of the claims specifically match the APIC-related semantics in the source code.",
                "The summary is mostly inaccurate or overly generic. It does not mention the core purpose of initializing the local and I/O APIC in a uniprocessor system, key conditional checks for APIC availability, or the actual sequence of hardware setup functions. Claims about 'memory updates', 'conditional cleanup', and 'registered callbacks' are noise and not present in the code. While 'system state transitions based on global flags' loosely matches the disable_apic/cpu_has_apic logic, the omission of critical APIC initialization details and misrepresentation of operations makes the overall benefit very low, with noise outweighing accuracy."
            ]
        },
        "comment": {
            "summary": "Initializes the local APIC for uniprocessor systems, verifying configuration and enabling IO-APICs as necessary for proper operation.",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function initializes the local APIC for uniprocessor systems and verifies configuration, which aligns with the code\u2019s setup sequence. It also notes enabling IO-APICs as necessary, which matches the conditional IO-APIC enabling and setup logic present. While the summary omits some detailed conditions and error-handling logic, the included claims are accurate and relevant to the code\u2019s semantics, yielding a high proportion of accurate claims.",
                "The summary accurately identifies the function\u2019s primary role as initializing the local APIC in a uniprocessor context, which matches the core purpose in the code. It also notes verification of configuration and enabling IO-APICs when required. However, it omits multiple critical secondary details such as early exit conditions when APIC is disabled or not present, BIOS-related checks and error messages, specific APIC setup steps (routing, ID assignment, physid mask updates), and timer initialization. These omissions leave the coverage of secondary behavior incomplete.",
                "The summary correctly states that the function initializes the local APIC for uniprocessor systems and involves verification, which matches the primary purpose seen in the source code. It also notes enabling IO-APICs when necessary, which is consistent with the conditional IO-APIC setup in the code. However, the description is generic and omits many specific precondition checks and configuration steps present in the function, resulting in low informational gain. There are no incorrect or contradictory claims, but the coverage is shallow and lacks detail, making the net benefit low."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 981824,
    "strip_function_name": "sub_EFB40",
    "strip_decompiled_code": "__int64 __fastcall sub_EFB40(__int64 *a1, char **a2, __int64 a3, __int64 *a4, char a5, _BYTE *a6)\n{\n  __int64 v6; // rax\n  int v9; // eax\n  char *v10; // r15\n  int v11; // edx\n  __int64 result; // rax\n  char *v13; // rax\n  __int64 v14; // r15\n  char v15; // [rsp+Eh] [rbp-4Ah] BYREF\n  char v16; // [rsp+Fh] [rbp-49h] BYREF\n  __int64 v17; // [rsp+10h] [rbp-48h] BYREF\n  char *v18[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( !a1 )\n    return 0LL;\n  v6 = *a4;\n  v18[0] = *a2;\n  if ( (v6 & 0x10) == 0 )\n    return sub_EF7C0(a1, a2, a3, a4, a5, a6);\n  v9 = sub_EDE30(&v17, 0LL, 0LL, &v15, &v16, (__int64 *)v18, a3, a4[1], (unsigned __int8)v6 & 0xC0, a5, (__int64)a6);\n  v10 = v18[0];\n  v11 = v9;\n  if ( !v9 )\n  {\n    ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 563);\n    return 0LL;\n  }\n  result = 0xFFFFFFFFLL;\n  if ( v11 != -1 )\n  {\n    if ( !v16 )\n    {\n      ERR_put_error(0xDu, 132, 120, (__int64)\"tasn_dec.c\", 571);\n      return 0LL;\n    }\n    if ( (unsigned int)sub_EF7C0(a1, v18, v17, a4, 0, a6) )\n    {\n      v13 = v18[0];\n      v14 = v17 + v10 - v18[0];\n      v17 = v14;\n      if ( v15 )\n      {\n        if ( v14 > 1 && !*v18[0] && !v18[0][1] )\n        {\n          v13 = v18[0] + 2;\nLABEL_18:\n          *a2 = v13;\n          return 1LL;\n        }\n        ERR_put_error(0xDu, 132, 137, (__int64)\"tasn_dec.c\", 590);\n      }\n      else\n      {\n        if ( !v14 )\n          goto LABEL_18;\n        ERR_put_error(0xDu, 132, 119, (__int64)\"tasn_dec.c\", 601);\n      }\n      ASN1_template_free((void **)a1, a4);\n      return 0LL;\n    }\n    else\n    {\n      ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 579);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "asn1_template_ex_d2i",
    "decompiled_code": "__int64 __fastcall asn1_template_ex_d2i(__int64 *a1, char **a2, char *a3, __int64 *a4, char a5, _BYTE *a6)\n{\n  __int64 v6; // rax\n  int v9; // eax\n  unsigned __int8 *v10; // r15\n  int v11; // edx\n  __int64 result; // rax\n  unsigned __int8 *v13; // rax\n  char *v14; // r15\n  char v15; // [rsp+Eh] [rbp-4Ah] BYREF\n  char v16; // [rsp+Fh] [rbp-49h] BYREF\n  char *v17; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int8 *v18[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( !a1 )\n    return 0LL;\n  v6 = *a4;\n  v18[0] = (unsigned __int8 *)*a2;\n  if ( (v6 & 0x10) == 0 )\n    return asn1_template_noexp_d2i(a1, a2, a3, a4, a5, a6);\n  v9 = asn1_check_tlen(&v17, 0LL, 0LL, &v15, &v16, v18, (__int64)a3, a4[1], (unsigned __int8)v6 & 0xC0, a5, (__int64)a6);\n  v10 = v18[0];\n  v11 = v9;\n  if ( !v9 )\n  {\n    ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 563);\n    return 0LL;\n  }\n  result = 0xFFFFFFFFLL;\n  if ( v11 != -1 )\n  {\n    if ( !v16 )\n    {\n      ERR_put_error(0xDu, 132, 120, (__int64)\"tasn_dec.c\", 571);\n      return 0LL;\n    }\n    if ( (unsigned int)asn1_template_noexp_d2i(a1, (char **)v18, v17, a4, 0, a6) )\n    {\n      v13 = v18[0];\n      v14 = &v17[v10 - v18[0]];\n      v17 = v14;\n      if ( v15 )\n      {\n        if ( (__int64)v14 > 1 && !*v18[0] && !v18[0][1] )\n        {\n          v13 = v18[0] + 2;\nLABEL_18:\n          *a2 = (char *)v13;\n          return 1LL;\n        }\n        ERR_put_error(0xDu, 132, 137, (__int64)\"tasn_dec.c\", 590);\n      }\n      else\n      {\n        if ( !v14 )\n          goto LABEL_18;\n        ERR_put_error(0xDu, 132, 119, (__int64)\"tasn_dec.c\", 601);\n      }\n      ASN1_template_free((unsigned int **)a1, a4);\n      return 0LL;\n    }\n    else\n    {\n      ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 579);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int asn1_template_ex_d2i(ASN1_VALUE **val,\n\t\t\t\tconst unsigned char **in, long inlen,\n\t\t\t\tconst ASN1_TEMPLATE *tt, char opt,\n\t\t\t\t\t\t\tASN1_TLC *ctx)\n\t{\n\tint flags, aclass;\n\tint ret;\n\tlong len;\n\tconst unsigned char *p, *q;\n\tchar exp_eoc;\n\tif (!val)\n\t\treturn 0;\n\tflags = tt->flags;\n\taclass = flags & ASN1_TFLG_TAG_CLASS;\n\n\tp = *in;\n\n\t/* Check if EXPLICIT tag expected */\n\tif (flags & ASN1_TFLG_EXPTAG)\n\t\t{\n\t\tchar cst;\n\t\t/* Need to work out amount of data available to the inner\n\t\t * content and where it starts: so read in EXPLICIT header to\n\t\t * get the info.\n\t\t */\n\t\tret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,\n\t\t\t\t\t&p, inlen, tt->tag, aclass, opt, ctx);\n\t\tq = p;\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\telse if (ret == -1)\n\t\t\treturn -1;\n\t\tif (!cst)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We've found the field so it can't be OPTIONAL now */\n\t\tret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We read the field in OK so update length */\n\t\tlen -= p - q;\n\t\tif (exp_eoc)\n\t\t\t{\n\t\t\t/* If NDEF we must have an EOC here */\n\t\t\tif (!asn1_check_eoc(&p, len))\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\t\tASN1_R_MISSING_EOC);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* Otherwise we must hit the EXPLICIT tag end or its\n\t\t\t * an error */\n\t\t\tif (len)\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_LENGTH_MISMATCH);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\treturn asn1_template_noexp_d2i(val, in, inlen,\n\t\t\t\t\t\t\t\ttt, opt, ctx);\n\n\t*in = p;\n\treturn 1;\n\n\terr:\n\tASN1_template_free(val, tt);\n\treturn 0;\n\t}",
    "comment": "Parses an ASN.1 encoded structure, handling explicit tags and validating length, while managing errors and memory for the decoded value.",
    "hext5_sum": "set the endianness of the symbol table attached to fp.",
    "bint5_sum": "Validates an XML attribute against a RelaxNG definition , checking attributes and namespace constraints , and returning a status code .\n",
    "cpbcs_sum": "Validates ASN.1 encoded data by checking the ASN.1 encoded truncate data, length, and flags, returning the length of the encoded string.\n",
    "misum_sum": "Processes ASN.1 encoded data, decoding it into a buffer while handling implicit characters and error conditions.\n",
    "decom_sum": "Parses and validates ASN.1 data using specific decoding rules, reports detailed errors, and updates the input pointer on successful template-based decoding.",
    "cfg_sum": "Parses and decodes ASN.1 data with optional processing flags, validates structure, handles errors via ERR_put_error, and frees resources on failure.",
    "work_score": {
        "decom": {
            "summary": "Parses and validates ASN.1 data using specific decoding rules, reports detailed errors, and updates the input pointer on successful template-based decoding.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary claims that the function parses and validates ASN.1 data with specific decoding rules, reports detailed errors, and updates the input pointer upon successful decoding. These are all observable in the source code: ASN.1 decoding is performed with explicit/implicit checks, multiple ASN1err calls report specific errors, and '*in' is updated when decoding succeeds. While the summary is correct, it omits certain specifics like the handling of EXPLICIT tags and length/eoc checks, but all stated claims are accurate and relevant to the code\u2019s behavior.",
                "The summary correctly states that the function parses and validates ASN.1 data, reports errors, and updates the input pointer, which are accurate reflections of the code\u2019s behavior. However, it fails to mention the core primary purpose of handling EXPLICIT ASN.1 tags\u2014reading their headers, verifying construction, performing nested decoding, and enforcing length/EOC rules\u2014making it too generic to cover the specific domain operation. Secondary details like explicit tag processing, optional handling, and branch-specific errors are missing.",
                "The summary contains mostly accurate but generic claims. It correctly notes that the function parses and validates ASN.1 data with specific decoding rules, reports errors, and updates the input pointer after successful decoding, all of which match the source code. However, the description is broad, lacking specifics about handling explicit tags, calculating lengths, and managing NDEF/EOC cases present in the implementation. There is no inaccurate claim, but the gain is low due to minimal detail and absence of nuanced behaviors."
            ]
        },
        "cfg": {
            "summary": "Parses and decodes ASN.1 data with optional processing flags, validates structure, handles errors via ERR_put_error, and frees resources on failure.",
            "score": [
                0.6,
                0.3,
                0.2
            ],
            "reason": [
                "The summary captures some accurate aspects, such as parsing/decoding ASN.1 data, use of optional flags, structural validation, and resource freeing on errors. However, it incorrectly claims that errors are handled via ERR_put_error, while the source uses ASN1err for error reporting. This inaccuracy means the proportion of accurate claims is around 75%, yielding a mixed reliability assessment.",
                "The summary correctly notes ASN.1 parsing/decoding, optional flags, structure validation, error handling, and resource freeing, making those claims [ACCURATE]. However, it fails to cover the core primary purpose: specifically decoding an ASN.1 value from an input buffer according to a given ASN1_TEMPLATE, with explicit tag handling, length checks, and branching for EXPLICIT vs non-EXPLICIT cases. These domain-specific details, including EOC checks and explicit length mismatch handling, are missing, so coverage of the core is absent despite some correct secondary points.",
                "The summary correctly states that the function parses and decodes ASN.1 data, applies optional flags, validates structure, and frees resources on failure. However, it inaccurately claims that errors are reported via ERR_put_error, while the source code uses ASN1err as the error handling mechanism. This is a FATAL error affecting a key side effect (error reporting). The rest of the claims are accurate but broad, offering low informational gain."
            ]
        },
        "comment": {
            "summary": "Parses an ASN.1 encoded structure, handling explicit tags and validating length, while managing errors and memory for the decoded value.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function parses ASN.1 encoded structures, handles explicit tags, validates lengths, and manages errors, which matches the source code\u2019s logic involving asn1_check_tlen, explicit tag handling, length checks, and error reporting. It also mentions memory management, which is supported by the call to ASN1_template_free in the error path. All claims directly align with the code semantics, with no inaccuracies or irrelevant noise detected.",
                "The summary correctly identifies that the function parses ASN.1 structures, handles explicit tags, validates lengths, and manages errors/memory for the decoded value, which covers the core purpose. However, it lacks mention of important branches, such as handling non-explicit tags via asn1_template_noexp_d2i, checks for constructed types, NDEF/EOC conditions, and explicit length mismatches. These omissions limit coverage of critical secondary behaviors.",
                "The summary correctly identifies that the function parses ASN.1 encoded data, handles explicit tags, validates lengths, and manages errors and memory, which aligns with the code\u2019s checks for EXPLICIT tags, length consistency, NDEF/EOC handling, and cleanup via ASN1_template_free. The claims are accurate but somewhat broad and lack additional specific details, such as conditional branching to asn1_template_noexp_d2i, making the gain moderate. There is no inaccurate or misleading information, and noise is minimal."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584049712,
    "strip_function_name": "sub_FFFFFFFF814F6A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814F6A30(__int64 *a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  int v3; // ecx\n  __int64 result; // rax\n  int v5; // eax\n  int v6; // edx\n  unsigned __int8 v7; // dl\n  int v8; // ecx\n  _BOOL4 v9; // eax\n  int v10; // eax\n\n  v1 = *a1;\n  v2 = *((unsigned __int8 *)a1 + 265);\n  v3 = *(_DWORD *)(*a1 + 4);\n  if ( v2 < v3 )\n  {\n    v5 = v2 - 1;\n    v6 = v5;\n    if ( v5 < 0 || v3 < v5 )\n    {\n      return 0LL;\n    }\n    else\n    {\n      result = 1LL;\n      if ( !v6 )\n      {\n        v7 = *((_BYTE *)a1 + 256);\n        if ( (v7 & 0xFC) != 0 )\n        {\n          v8 = *(_DWORD *)(v1 + 8);\n          if ( (v8 & 0xF) != 0 )\n          {\n            result = 0LL;\n            if ( (v7 & 8) == 0 )\n            {\n              if ( v7 >> 6 == 1 || (a1[32] & 0x20) != 0 )\n              {\n                v10 = 5;\n                if ( (v8 & 4) != 0 )\n                  v10 = 4;\n              }\n              else\n              {\n                v9 = v7 >> 6 == 2;\n                if ( (v8 & 4) != 0 )\n                  v10 = 3 * v9 + 4;\n                else\n                  v10 = 3 * v9 + 5;\n              }\n              *(_DWORD *)(v1 + 4) = v10;\n              return 1LL;\n            }\n          }\n        }\n        else\n        {\n          sub_FFFFFFFF814F66A0(a1);\n          return 2LL;\n        }\n      }\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF814F66A0(a1);\n    return 2LL;\n  }\n  return result;\n}\n",
    "function_name": "cypress_protocol_handler",
    "decompiled_code": "__int64 __fastcall cypress_protocol_handler(\n        unsigned __int8 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rsi\n  int v10; // eax\n  int v11; // ecx\n  __int64 result; // rax\n  int v13; // eax\n  int v14; // edx\n  unsigned __int8 v15; // dl\n  int v16; // ecx\n  _BOOL4 v17; // eax\n  int v18; // eax\n\n  v9 = *(_QWORD *)a1;\n  v10 = a1[265];\n  v11 = *(_DWORD *)(*(_QWORD *)a1 + 4LL);\n  if ( v10 < v11 )\n  {\n    v13 = v10 - 1;\n    v14 = v13;\n    if ( v13 < 0 || v11 < v13 )\n    {\n      return 0LL;\n    }\n    else\n    {\n      result = 1LL;\n      if ( !v14 )\n      {\n        v15 = a1[256];\n        if ( (v15 & 0xFC) != 0 )\n        {\n          v16 = *(_DWORD *)(v9 + 8);\n          if ( (v16 & 0xF) != 0 )\n          {\n            result = 0LL;\n            if ( (v15 & 8) == 0 )\n            {\n              if ( v15 >> 6 == 1 || (a1[256] & 0x20) != 0 )\n              {\n                v18 = 5;\n                if ( (v16 & 4) != 0 )\n                  v18 = 4;\n              }\n              else\n              {\n                v17 = v15 >> 6 == 2;\n                if ( (v16 & 4) != 0 )\n                  v18 = 3 * v17 + 4;\n                else\n                  v18 = 3 * v17 + 5;\n              }\n              *(_DWORD *)(v9 + 4) = v18;\n              return 1LL;\n            }\n          }\n        }\n        else\n        {\n          cypress_process_packet((__int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);\n          return 2LL;\n        }\n      }\n    }\n  }\n  else\n  {\n    cypress_process_packet((__int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    return 2LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic psmouse_ret_t cypress_protocol_handler(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (psmouse->pktcnt >= cytp->pkt_size) {\n\t\tcypress_process_packet(psmouse, 0);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn cypress_validate_byte(psmouse);\n}",
    "comment": "Handles packet processing for a Cypress device, validating bytes and triggering full packet processing when the expected packet size is reached.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Validates if the mouse is within valid bounds and has valid coordinates , returning 1 for valid coordinates and 0 for invalid coordinates .\n",
    "cpbcs_sum": "Processes a PS/2 mouse to extract state and protocol version information, handling specific error conditions for invalid input data.\n",
    "misum_sum": "Classifies a specific keyboard structure into interrupt format, handling special cases for invalid input and escape sequences.\n",
    "decom_sum": "Validates and updates a control structure\u2019s state fields based on index and flag bits, resetting via helper call when constraints are violated.",
    "cfg_sum": "Checks and updates control state based on indexed flags and counters, invoking a handler or adjusting configuration before returning a status code.",
    "work_score": {
        "decom": {
            "summary": "Validates and updates a control structure\u2019s state fields based on index and flag bits, resetting via helper call when constraints are violated.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function validates and updates control structure state fields based on index and flag bits, and resets via a helper when constraints are violated. The source code shows it checks if the packet count meets a size threshold, processes the packet, and returns a specific status or validates a byte otherwise. There is no mention of index or flag bits, nor general control structure fields, making the claims inaccurate and not aligned with the actual semantics. All claims are inaccurate, yielding very low precision.",
                "The summary's claims about validating and updating a control structure's state fields based on index and flag bits do not align with the source code, which checks if a packet count meets the expected packet size, processes the packet via a helper, and returns specific status codes. No claim in the summary captures the core purpose of handling Cypress touchpad packets or the actual processing/validation logic present in the function.",
                "The summary claims that the function updates a control structure\u2019s state fields based on index and flag bits and resets via a helper when constraints are violated, but the source code instead checks if the packet count meets a size threshold, processes a packet via a helper, and returns status codes. The described behavior contradicts the actual purpose and key I/O of the function, introducing a severe inaccuracy impacting the core domain semantics. This is a FATAL error on the primary purpose, with no accurate claims present."
            ]
        },
        "cfg": {
            "summary": "Checks and updates control state based on indexed flags and counters, invoking a handler or adjusting configuration before returning a status code.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary describes generic control state checks and configuration adjustments, but the source code specifically checks if the packet count meets or exceeds a size threshold, then processes the packet and returns a specific status, otherwise validates a byte. The summary\u2019s terms such as 'indexed flags', 'adjusting configuration', and 'invoking a handler' are not clearly tied to the actual semantics of packet size checking and function calls in the code, making most claims inaccurate or overly generic. Only the notion of returning a status code loosely aligns.",
                "The summary does not accurately reflect the core purpose of the function, which is to handle Cypress touchpad protocol by processing a full packet when enough bytes are received or validating incoming bytes otherwise. The description given is generic, incorrectly mentions indexed flags and configuration adjustments, and omits any mention of packet size checks, packet processing, or validation logic, resulting in no coverage of the core domain semantics.",
                "The summary contains mostly inaccurate or noisy claims. It describes control state changes, indexed flags, and configuration adjustments, none of which appear in the source code. The actual function checks if a packet count meets a size threshold, processes the packet via cypress_process_packet, and returns a status constant, or otherwise validates a byte. There are no references to control state or configuration changes. This is primarily NOISE with no specific, accurate mapping to the core domain behavior, resulting in very low net benefit."
            ]
        },
        "comment": {
            "summary": "Handles packet processing for a Cypress device, validating bytes and triggering full packet processing when the expected packet size is reached.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary contains two core claims: that the function handles packet processing for a Cypress device and that it validates bytes and processes a full packet when the expected packet size is reached. Both are supported by the source code: the function name and the call to cypress_process_packet confirm Cypress-specific handling, while the conditional using pktcnt and pkt_size followed by cypress_validate_byte confirm the validation and full packet processing logic. This means all claims align closely with actual code behavior.",
                "The summary correctly identifies the core purpose of handling Cypress device packets, including validation of bytes and triggering full packet processing at the expected packet size, which matches the source code's conditional check and function calls. It covers the primary domain action and also notes the secondary behavior related to packet size verification. However, it omits minor details such as the specific return values (PSMOUSE_FULL_PACKET) and function names, limiting completeness.",
                "The summary contains accurate and specific information about the core functionality: it correctly states that the function processes packets for a Cypress device, validates bytes, and triggers full packet processing when the packet size threshold is reached. These are all verifiable from the source code and align with the function's primary purpose. There is no contradictory or irrelevant (NOISE) content, and the claims give clear insight into the control flow and key conditions."
            ]
        }
    }
}
{
    "project_name": "texinfo",
    "function_addr": 144448,
    "strip_function_name": "sub_23440",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_23440(unsigned int sig)\n{\n  struct sigaction *v1; // rdx\n  struct sigaction *v3; // r12\n  __pid_t v4; // eax\n  sigset_t v5; // [rsp+0h] [rbp-138h] BYREF\n  sigset_t set; // [rsp+80h] [rbp-B8h] BYREF\n  unsigned __int64 v7; // [rsp+108h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  if ( sig <= 0x1C )\n  {\n    if ( ((1LL << sig) & 0x70800C) != 0 )\n    {\n      v3 = &oact;\n      if ( sig != 20 )\n      {\n        v3 = &stru_24BAC0;\n        if ( sig != 22 )\n        {\n          if ( sig == 21 )\n          {\n            v3 = &stru_24BA20;\n          }\n          else\n          {\n            v3 = &stru_24B700;\n            if ( sig != 3 )\n            {\n              v3 = &stru_24B8E0;\n              if ( sig != 2 )\n              {\n                v3 = 0LL;\n                if ( sig == 15 )\n                  v3 = &stru_24B840;\n              }\n            }\n          }\n        }\n      }\n      sub_24440(0, dword_24C140 - 1);\n      sub_24640();\n      fflush(stdout);\n      sub_25670();\n      sigaction(sig, v3, 0LL);\n      sigemptyset(&set);\n      sigemptyset(&v5);\n      sigaddset(&v5, sig);\n      sigprocmask(1, &v5, &set);\n      v4 = getpid();\n      kill(v4, sig);\n      sub_25480();\n      sigaction(sig, &act, v3);\n      sub_23400();\n    }\n    else if ( ((1LL << sig) & 0x10000400) != 0 )\n    {\n      v1 = &stru_24B980;\n      if ( sig != 28 )\n      {\n        v1 = &stru_24B7A0;\n        if ( sig != 10 )\n          v1 = (struct sigaction *)((1LL << sig) & 0x70800C);\n      }\n      sigaction(sig, &act, v1);\n      if ( dword_24B6E0 )\n        abort();\n      dword_24B6E0 = 1;\n      sub_23400();\n      --dword_24B6E0;\n      sigemptyset(&set);\n      sigemptyset(&v5);\n      sigaddset(&v5, sig);\n      sigprocmask(1, &v5, &set);\n    }\n  }\n  return __readfsqword(0x28u) ^ v7;\n}\n",
    "function_name": "info_signal_proc",
    "decompiled_code": "void __fastcall info_signal_proc(int sig)\n{\n  struct sigaction *v1; // rdx\n  signal_info *v2; // r12\n  __pid_t v3; // eax\n  _UNKNOWN *retaddr; // [rsp+138h] [rbp+0h] BYREF\n  sigset_t v5; // [rsp+1B8h] [rbp+80h] BYREF\n  unsigned __int64 v6; // [rsp+240h] [rbp+108h]\n\n  v6 = __readfsqword(0x28u);\n  if ( (unsigned int)sig <= 0x1C )\n  {\n    if ( ((1LL << sig) & 0x70800C) != 0 )\n    {\n      v2 = &old_TSTP;\n      if ( sig != 20 )\n      {\n        v2 = &old_TTOU;\n        if ( sig != 22 )\n        {\n          if ( sig == 21 )\n          {\n            v2 = &old_TTIN;\n          }\n          else\n          {\n            v2 = &old_QUIT;\n            if ( sig != 3 )\n            {\n              v2 = &old_INT;\n              if ( sig != 2 )\n              {\n                v2 = 0LL;\n                if ( sig == 15 )\n                  v2 = &old_TERM;\n              }\n            }\n          }\n        }\n      }\n      terminal_goto_xy(0, screenheight - 1);\n      terminal_clear_to_eol();\n      fflush((FILE *)stdout);\n      terminal_unprep_terminal();\n      sigaction(sig, v2, 0LL);\n      sigemptyset(&v5);\n      sigemptyset((sigset_t *)&retaddr);\n      sigaddset((sigset_t *)&retaddr, sig);\n      sigprocmask(1, (const sigset_t *)&retaddr, &v5);\n      v3 = getpid();\n      kill(v3, sig);\n      terminal_prep_terminal();\n      sigaction(sig, &info_signal_handler, v2);\n      reset_info_window_sizes();\n    }\n    else if ( ((1LL << sig) & 0x10000400) != 0 )\n    {\n      v1 = &old_WINCH;\n      if ( sig != 28 )\n      {\n        v1 = &old_USR1;\n        if ( sig != 10 )\n          v1 = (struct sigaction *)((1LL << sig) & 0x70800C);\n      }\n      sigaction(sig, &info_signal_handler, v1);\n      if ( sigwinch_block_count )\n        abort();\n      sigwinch_block_count = 1;\n      reset_info_window_sizes();\n      --sigwinch_block_count;\n      sigemptyset(&v5);\n      sigemptyset((sigset_t *)&retaddr);\n      sigaddset((sigset_t *)&retaddr, sig);\n      sigprocmask(1, (const sigset_t *)&retaddr, &v5);\n    }\n  }\n}\n",
    "source_code": "\nstatic void\ninfo_signal_proc (int sig)\n{\n  signal_info *old_signal_handler = NULL;\n\n#if !defined (HAVE_SIGACTION)\n  /* best effort: first increment this counter and later block signals */\n  if (term_conf_busy)\n    return;\n  term_conf_busy++;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_BLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n  switch (sig)\n    {\n#if defined (SIGTSTP)\n    case SIGTSTP:\n    case SIGTTOU:\n    case SIGTTIN:\n#endif\n#if defined (SIGQUIT)\n    case SIGQUIT:\n#endif\n#if defined (SIGINT)\n    case SIGINT:\n#endif\n#if defined (SIGTERM)\n    case SIGTERM:\n#endif\n      {\n#if defined (SIGTSTP)\n        if (sig == SIGTSTP)\n          old_signal_handler = &old_TSTP;\n        if (sig == SIGTTOU)\n          old_signal_handler = &old_TTOU;\n        if (sig == SIGTTIN)\n          old_signal_handler = &old_TTIN;\n#endif /* SIGTSTP */\n#if defined (SIGQUIT)\n        if (sig == SIGQUIT)\n          old_signal_handler = &old_QUIT;\n#endif /* SIGQUIT */\n#if defined (SIGINT)\n        if (sig == SIGINT)\n          old_signal_handler = &old_INT;\n#endif /* SIGINT */\n#if defined (SIGTERM)\n        if (sig == SIGTERM)\n          old_signal_handler = &old_TERM;\n#endif /* SIGTERM */\n\n        /* For stop signals, restore the terminal IO, leave the cursor\n           at the bottom of the window, and stop us. */\n        terminal_goto_xy (0, screenheight - 1);\n        terminal_clear_to_eol ();\n        fflush (stdout);\n        terminal_unprep_terminal ();\n\trestore_termsig (sig, old_signal_handler);\n\tUNBLOCK_SIGNAL (sig);\n\tkill (getpid (), sig);\n\n        /* The program is returning now.  Restore our signal handler,\n           turn on terminal handling, redraw the screen, and place the\n           cursor where it belongs. */\n        terminal_prep_terminal ();\n\tset_termsig (sig, old_signal_handler);\n\t/* window size might be changed while sleeping */\n\treset_info_window_sizes ();\n      }\n      break;\n\n#if defined (SIGWINCH) || defined (SIGUSR1)\n#ifdef SIGWINCH\n    case SIGWINCH:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n      {\n\t/* Turn off terminal IO, tell our parent that the window has changed,\n\t   then reinitialize the terminal and rebuild our windows. */\n#ifdef SIGWINCH\n\tif (sig == SIGWINCH)\n\t  old_signal_handler = &old_WINCH;\n#endif\n#ifdef SIGUSR1\n\tif (sig == SIGUSR1)\n\t  old_signal_handler = &old_USR1;\n#endif\n\n        /* This seems risky: what if we receive a (real) signal before\n           the next line is reached? */\n#if 0\n\trestore_termsig (sig, old_signal_handler);\n\tkill (getpid (), sig);\n#endif\n\n\t/* After our old signal handler returns... */\n\tset_termsig (sig, old_signal_handler); /* needless? */\n\n        if (sigwinch_block_count != 0)\n          abort ();\n\n        /* Avoid any of the code unblocking the signal too early.  This\n           should set the variable to 1 because we shouldn't be here if\n           sigwinch_block_count > 0. */\n        sigwinch_block_count++;\n\n\treset_info_window_sizes ();\n\n        sigwinch_block_count--;\n        /* Don't unblock the signal until after we've finished. */\n\tUNBLOCK_SIGNAL (sig);\n      }\n      break;\n#endif /* SIGWINCH || SIGUSR1 */\n    }\n#if !defined (HAVE_SIGACTION)\n  /* at this time it is safer to perform unblock after decrement */\n  term_conf_busy--;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_UNBLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n}",
    "comment": "Handles various signals by restoring terminal settings, blocking signals during critical sections, and managing terminal window size changes.",
    "hext5_sum": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
    "bint5_sum": "Handles various signals by managing actions like SIGINT , SIGTSTP , SIGTTIN , and SIGTTOU while ensuring proper cleanup of previous signals .\n",
    "cpbcs_sum": "Handles SIGINT or SIGTERM signal delivery by managing terminal settings and suspending the actions based on the exit status.\n",
    "misum_sum": "Handles various signals, updates signal actions and manages signal traps for various signals, and manages child trap states accordingly.\n",
    "decom_sum": "Handles specific signals by installing custom handlers, triggering cleanup and flush routines, then re\u2011raising the signal to execute its associated action.",
    "cfg_sum": "Handles specific signals by installing appropriate handlers, adjusting signal masks, sending the signal to self, and restoring original configurations.",
    "work_score": {
        "decom": {
            "summary": "Handles specific signals by installing custom handlers, triggering cleanup and flush routines, then re\u2011raising the signal to execute its associated action.",
            "score": [
                0.6,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function handles specific signals and installs handlers, and it triggers cleanup routines. However, it omits important distinctions: the function restores old handlers instead of installing new custom ones, performs terminal-related preparations/unpreparations, and in some cases re-raises the signal. The re-raising behavior is only accurate for stop/termination signals, not for all handled signals. These inaccuracies reduce the alignment.",
                "The summary correctly notes that the function handles specific signals, installs handlers, performs cleanup/flush, and re\u2011raises the signal, which matches the core behavior of reacting to SIGTSTP, SIGINT, SIGTERM, SIGWINCH, etc. However, it omits important secondary details such as terminal state restoration before/after stopping, window size resets, conditionally blocking/unblocking signals, special handling for SIGWINCH/SIGUSR1, and use of term_conf_busy and sigwinch_block_count to prevent races. This limits coverage to the core action with minimal secondary specifics.",
                "The summary correctly states that the function handles specific signals and triggers cleanup routines before re\u2011raising the signal, which matches the code\u2019s handling for stop and termination signals. However, it is slightly generic and omits the detailed behavior for different signal types, such as window change handling without re\u2011raising, and conditions related to blocking/unblocking signals. There are no inaccurate or contradictory claims, but the gain is modest because it lacks specificity about the distinct cases and actual side effects beyond cleanup and flushing."
            ]
        },
        "cfg": {
            "summary": "Handles specific signals by installing appropriate handlers, adjusting signal masks, sending the signal to self, and restoring original configurations.",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function handles specific signals, installs appropriate handlers, adjusts signal masks, sends the signal to itself, and restores original configurations. These behaviors are supported by the code, which branches on signal types, sets old_signal_handler pointers, uses sigprocmask for mask adjustments, invokes kill(getpid(), sig), and restores terminal and signal settings. The summary is slightly generic and omits details such as terminal preparation/unpreparation and window size handling, but all stated claims align with the source code.",
                "The summary identifies that the function handles specific signals, installs appropriate handlers, adjusts signal masks, sends the signal to itself, and restores configurations, which broadly matches the code\u2019s core purpose of managing terminal-related signal handling. However, it lacks the core domain specificity of restoring and reinitializing the terminal state for stop and window-change signals, and omits critical secondary details like differentiating behavior per signal type, cursor positioning, flushing stdout, redrawing the screen, managing sigwinch_block_count, and conditional compilation paths. This results in coverage of the general mechanism but misses much of the detailed semantics.",
                "The summary captures some accurate aspects such as handling specific signals, installing handlers, and restoring configurations, which align with the code. However, it omits important details about terminal state management, screen redrawing, and signal-specific behaviors (like SIGWINCH handling and adjustments to block counts). There is no outright contradiction, but the description is generic and lacks the specific flow and side effects present in the source, resulting in low informational gain."
            ]
        },
        "comment": {
            "summary": "Handles various signals by restoring terminal settings, blocking signals during critical sections, and managing terminal window size changes.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function handles various signals, restores terminal settings, blocks signals during critical processing, and manages window size changes, all of which are explicitly present in the source code. While the description is somewhat generic and omits signal-specific behaviors, it is still largely accurate and aligned with the code's semantics.",
                "The summary correctly notes that the function handles various signals, restores terminal settings, blocks signals during critical sections, and manages terminal window size changes, all of which are accurate per the code. However, it fails to cover the core primary purpose with sufficient specificity \u2014 namely the detailed handling of stop signals (e.g., SIGTSTP, SIGINT, SIGTERM) to suspend/resume terminal operation and redraw the screen, and the specific handling for SIGWINCH/SIGUSR1 with window size reset logic and signal blocking counters. Secondary behavior coverage is thin, omitting conditions, branching logic, signal-specific actions, and restoration steps before/after stopping.",
                "The summary accurately captures core behavior: handling various signals, restoring terminal settings, blocking signals during critical sections, and managing window size changes. These are all verifiable from the source code and align with its purpose. However, while correct, the claims are broad and lack detail on specific signal types or exact restoration/reinitialization steps, resulting in low informational gain. No inaccuracies or noise are present."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 785280,
    "strip_function_name": "ENGINE_add",
    "strip_decompiled_code": "__int64 __fastcall ENGINE_add(const char **a1)\n{\n  const char **v1; // rbx\n  const char *v2; // rbp\n  int v3; // eax\n  bool v4; // al\n  __int64 v5; // rax\n  __int64 v6; // r8\n  unsigned int v7; // ebx\n\n  if ( a1 )\n  {\n    if ( !*a1 || !a1[1] )\n      ERR_put_error(38LL, 105LL, 108LL, \"eng_list.c\", 282LL);\n    CRYPTO_lock(9u, 30, (__int64)\"eng_list.c\", 0x11Cu);\n    v1 = (const char **)qword_3C0870;\n    if ( qword_3C0870 )\n    {\n      v2 = *a1;\n      do\n      {\n        v3 = strcmp(*v1, v2);\n        v1 = (const char **)v1[26];\n        v4 = v3 == 0;\n      }\n      while ( (unsigned __int8)v4 < (unsigned __int8)(v1 != 0LL) );\n      if ( v4 )\n      {\n        ERR_put_error(38LL, 120LL, 103LL, \"eng_list.c\", 116LL);\n        goto LABEL_12;\n      }\n      v5 = qword_3C0868;\n      if ( !qword_3C0868 || *(_QWORD *)(qword_3C0868 + 208) )\n      {\n        v6 = 141LL;\nLABEL_11:\n        ERR_put_error(38LL, 120LL, 110LL, \"eng_list.c\", v6);\nLABEL_12:\n        v7 = 0;\n        ERR_put_error(38LL, 105LL, 110LL, \"eng_list.c\", 288LL);\nLABEL_13:\n        CRYPTO_lock(0xAu, 30, (__int64)\"eng_list.c\", 0x123u);\n        return v7;\n      }\n      *(_QWORD *)(qword_3C0868 + 208) = a1;\n      a1[25] = (const char *)v5;\n    }\n    else\n    {\n      v6 = 125LL;\n      if ( qword_3C0868 )\n        goto LABEL_11;\n      a1[25] = 0LL;\n      qword_3C0870 = a1;\n      engine_cleanup_add_last((__int64)sub_BFED0);\n    }\n    ++*((_DWORD *)a1 + 43);\n    qword_3C0868 = (__int64)a1;\n    v7 = 1;\n    a1[26] = 0LL;\n    goto LABEL_13;\n  }\n  ERR_put_error(38LL, 105LL, 67LL, \"eng_list.c\", 276LL);\n  return 0LL;\n}\n",
    "function_name": "ENGINE_add",
    "decompiled_code": "__int64 __fastcall ENGINE_add(const char **a1)\n{\n  const char **v1; // rbx\n  const char *v2; // rbp\n  int v3; // eax\n  bool v4; // al\n  const char *v5; // rax\n  int v6; // r8d\n  unsigned int v7; // ebx\n\n  if ( a1 )\n  {\n    if ( !*a1 || !a1[1] )\n      ERR_put_error(0x26u, 105, 108, (__int64)\"eng_list.c\", 282);\n    CRYPTO_lock(9u, 30, (__int64)\"eng_list.c\", 0x11Cu);\n    v1 = (const char **)engine_list_head;\n    if ( engine_list_head )\n    {\n      v2 = *a1;\n      do\n      {\n        v3 = strcmp(*v1, v2);\n        v1 = (const char **)v1[26];\n        v4 = v3 == 0;\n      }\n      while ( (unsigned __int8)v4 < (unsigned __int8)(v1 != 0LL) );\n      if ( v4 )\n      {\n        ERR_put_error(0x26u, 120, 103, (__int64)\"eng_list.c\", 116);\n        goto LABEL_12;\n      }\n      v5 = (const char *)engine_list_tail;\n      if ( !engine_list_tail || *(_QWORD *)(engine_list_tail + 208) )\n      {\n        v6 = 141;\nLABEL_11:\n        ERR_put_error(0x26u, 120, 110, (__int64)\"eng_list.c\", v6);\nLABEL_12:\n        v7 = 0;\n        ERR_put_error(0x26u, 105, 110, (__int64)\"eng_list.c\", 288);\nLABEL_13:\n        CRYPTO_lock(0xAu, 30, (__int64)\"eng_list.c\", 0x123u);\n        return v7;\n      }\n      *(_QWORD *)(engine_list_tail + 208) = a1;\n      a1[25] = v5;\n    }\n    else\n    {\n      v6 = 125;\n      if ( engine_list_tail )\n        goto LABEL_11;\n      a1[25] = 0LL;\n      engine_list_head = a1;\n      engine_cleanup_add_last((__int64)engine_list_cleanup);\n    }\n    ++*((_DWORD *)a1 + 43);\n    engine_list_tail = (__int64)a1;\n    v7 = 1;\n    a1[26] = 0LL;\n    goto LABEL_13;\n  }\n  ERR_put_error(0x26u, 105, 67, (__int64)\"eng_list.c\", 276);\n  return 0LL;\n}\n",
    "source_code": "int ENGINE_add(ENGINE *e)\n\t{\n\tint to_return = 1;\n\tif(e == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\tif((e->id == NULL) || (e->name == NULL))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_ID_OR_NAME_MISSING);\n\t\t}\n\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\tif(!engine_list_add(e))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_INTERNAL_LIST_ERROR);\n\t\tto_return = 0;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\treturn to_return;\n\t}",
    "comment": "Adds an ENGINE structure to a list after validating its parameters and managing thread safety with locks.",
    "hext5_sum": "add arg to the end of the list of arguments 'cmd_argv' to pass to the command. len is the length of arg, including the terminating null. if this brings the list up to its maximum size, execute the command.",
    "bint5_sum": "Adds an ENGINE to a linked list , ensuring no duplicates and handling thread safety with locking mechanisms .\n",
    "cpbcs_sum": "Adds an XRECORD with a warnings in the context and associates it with the appropriate DSO validation context.\n",
    "misum_sum": "Adds a new `X509_VERIFY_PARAM` to the appropriate chain of an ENGINE structure, ensuring the list is valid and the mutex is properly locked.\n",
    "decom_sum": "Adds an ENGINE structure to the global engine list with duplicate checks, locking, and error reporting via ERR_put_error.",
    "cfg_sum": "Registers a new ENGINE into the global list with locking, duplicate checks, error reporting, and updates linkage and reference counters.",
    "work_score": {
        "decom": {
            "summary": "Adds an ENGINE structure to the global engine list with duplicate checks, locking, and error reporting via ERR_put_error.",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function adds an ENGINE structure to a global list and notes locking and error reporting, which aligns with the code. However, it inaccurately mentions duplicate checks, which are not explicitly shown, and references ERR_put_error instead of the ENGINEerr calls used. These inaccuracies reduce precision, resulting in mixed reliability of the claims.",
                "The summary correctly states that the function adds an ENGINE structure to a global list with locking and error reporting, aligning with the core purpose in the source code. However, it introduces an inaccurate detail about duplicate checks, which are not present in the provided code. It also incorrectly names the error function as ERR_put_error instead of ENGINEerr. While the core action is covered, these inaccuracies reduce completeness and correctness, and several secondary behaviors, such as handling null parameters, missing ID or name cases, and the specific error codes used, are omitted.",
                "The summary correctly states that the function adds an ENGINE structure to a global list with locking and error reporting, but inaccurately introduces duplicate checks and mentions ERR_put_error, neither of which appear in the source code. The duplicate check claim is a FATAL error because it misrepresents a key aspect of the primary purpose. While some accurate elements exist, the core action is mischaracterized, resulting in very low trustworthiness."
            ]
        },
        "cfg": {
            "summary": "Registers a new ENGINE into the global list with locking, duplicate checks, error reporting, and updates linkage and reference counters.",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function registers a new ENGINE into a global list with locking and error reporting, which aligns with the code\u2019s use of CRYPTO_w_lock/unlock and ENGINEerr calls. However, it inaccurately claims duplicate checks, linkage updates, and reference counter updates, none of which are present in the source code. These inaccuracies constitute a significant portion of the claims, reducing overall precision to below 50%.",
                "The summary correctly states that the function registers an ENGINE into a global list with locking and error reporting, which matches the core primary purpose of adding an ENGINE to a global engine list with thread-safety. However, it inaccurately claims duplicate checks, linkage updates, and reference counter modifications, none of which are in the source code. The summary omits specific error cases such as handling null parameters or missing ID/name and the branch for internal list failure, so coverage of secondary behavior-critical semantics is limited.",
                "The summary correctly states that the function registers a new ENGINE into a global list with locking and error reporting, which matches the code\u2019s core purpose. However, it inaccurately claims duplicate checks, linkage updates, and reference counter modifications \u2014 none of which are present in the source code. These are semantic inaccuracies targeting the core behavior, making them FATAL errors on the primary purpose. The presence of these errors severely undermines trust in the summary, despite some accurate elements."
            ]
        },
        "comment": {
            "summary": "Adds an ENGINE structure to a list after validating its parameters and managing thread safety with locks.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function adds an ENGINE structure to a list, validates parameters, and manages thread safety with locks. These behaviors are directly supported by the source code, which checks for NULL and missing fields, uses CRYPTO_w_lock/unlock for thread safety, and calls engine_list_add. All claims are correct and aligned with the function\u2019s semantics, with no inaccuracies present.",
                "The summary correctly captures the core purpose\u2014adding an ENGINE structure to an internal list with parameter validation and lock-based thread safety. It aligns with the code's main operation and notes validation and locking. However, it omits important secondary specifics, such as distinct error cases for null parameters, missing id or name, internal list addition failure, and the return value behavior. These omissions reduce completeness.",
                "The summary correctly states the primary purpose of adding an ENGINE structure to a list, the need for parameter validation, and use of locks for thread safety. All claims match the code: null checks on the ENGINE pointer and its id/name fields, addition via engine_list_add, and locking with CRYPTO_w_lock/CRYPTO_w_unlock. There is no inaccurate or noisy content, though the description is generic and omits specific error handling details, giving it low information gain beyond the basics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585776048,
    "strip_function_name": "sub_FFFFFFFF8169C1B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8169C1B0(\n        __int64 a1,\n        __int64 a2,\n        _OWORD *a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int v12; // ebx\n  __int64 v15; // rax\n  __int64 *v16; // r15\n  __int64 *v17; // r13\n  __int64 *v18; // rax\n  __int64 v19; // rbx\n  __int64 *v20; // rax\n  __int64 v21; // rdi\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n\n  v12 = -22;\n  if ( a4 <= 0x80 )\n  {\n    v15 = sub_FFFFFFFF815D82F0(a1, a2);\n    if ( v15 )\n    {\n      v16 = *(__int64 **)(v15 + 600);\n      if ( v16 )\n      {\n        v17 = v16 + 1;\n        sub_FFFFFFFF817927D0(v16 + 29);\n        v18 = (__int64 *)v16[1];\n        v19 = (__int64)(v18 - 28);\n        if ( v16 + 1 == v18 )\n        {\nLABEL_12:\n          v12 = -99;\n          sub_FFFFFFFF81792890(v16 + 29);\n        }\n        else\n        {\n          while ( a4 != *(_DWORD *)(v19 + 16) || *(_OWORD *)v19 - *a3 != 0LL )\n          {\n            v20 = *(__int64 **)(v19 + 224);\n            v19 = (__int64)(v20 - 28);\n            if ( v17 == v20 )\n              goto LABEL_12;\n          }\n          _InterlockedIncrement((volatile signed __int32 *)(v19 + 28));\n          sub_FFFFFFFF81792890(v16 + 29);\n          v21 = v19;\n          v12 = 0;\n          sub_FFFFFFFF8169BCB0(v21, a2, a5, a6, a7, a8, v22, v23, a11, a12);\n          if ( (__int64 *)v16[1] == v17 )\n            sub_FFFFFFFF8169B590(*v16, 1, a5, a6, a7, a8, v24, v25, a11, a12);\n        }\n      }\n      else\n      {\n        return (unsigned int)-6;\n      }\n    }\n    else\n    {\n      return (unsigned int)-19;\n    }\n  }\n  return v12;\n}\n",
    "function_name": "inet6_addr_del",
    "decompiled_code": "__int64 __fastcall inet6_addr_del(\n        __int64 a1,\n        __int64 a2,\n        _OWORD *a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int v12; // ebx\n  __int64 v15; // rax\n  __int64 v16; // r15\n  __int64 v17; // r13\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  int v20; // r9d\n  __int64 v21; // rax\n  volatile signed __int32 *v22; // rdx\n  __int64 v23; // rbx\n  __int64 v24; // rax\n  __int64 v25; // rdi\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n\n  v12 = -22;\n  if ( a4 <= 0x80 )\n  {\n    v15 = _dev_get_by_index(a1, a2);\n    if ( v15 )\n    {\n      v16 = *(_QWORD *)(v15 + 600);\n      if ( v16 )\n      {\n        v17 = v16 + 8;\n        raw_read_lock_bh((volatile signed __int32 *)(v16 + 232));\n        v21 = *(_QWORD *)(v16 + 8);\n        v22 = (volatile signed __int32 *)(v16 + 232);\n        v23 = v21 - 224;\n        if ( v16 + 8 == v21 )\n        {\nLABEL_12:\n          v12 = -99;\n          raw_read_unlock_bh((volatile signed __int32 *)(v16 + 232), a2, (__int64)v22, v18, v19, v20);\n        }\n        else\n        {\n          while ( 1 )\n          {\n            if ( a4 == *(_DWORD *)(v23 + 16) )\n            {\n              v18 = *(_QWORD *)(v23 + 8) ^ *((_QWORD *)a3 + 1) | *(_QWORD *)v23 ^ *(_QWORD *)a3;\n              if ( *(_OWORD *)v23 - *a3 == 0LL )\n                break;\n            }\n            v24 = *(_QWORD *)(v23 + 224);\n            v23 = v24 - 224;\n            if ( v17 == v24 )\n              goto LABEL_12;\n          }\n          _InterlockedIncrement((volatile signed __int32 *)(v23 + 28));\n          raw_read_unlock_bh(v22, a2, (__int64)v22, v18, v19, v20);\n          v25 = v23;\n          v12 = 0;\n          ipv6_del_addr(v25, a2, a5, a6, a7, a8, v26, v27, a11, a12);\n          if ( *(_QWORD *)(v16 + 8) == v17 )\n            addrconf_ifdown(*(_QWORD *)v16, 1u, a5, a6, a7, a8, v28, v29, a11, a12);\n        }\n      }\n      else\n      {\n        return (unsigned int)-6;\n      }\n    }\n    else\n    {\n      return (unsigned int)-19;\n    }\n  }\n  return v12;\n}\n",
    "source_code": "\nstatic int inet6_addr_del(struct net *net, int ifindex, const struct in6_addr *pfx,\n\t\t\t  unsigned int plen)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\n\tif (plen > 128)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif ((idev = __in6_dev_get(dev)) == NULL)\n\t\treturn -ENXIO;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->prefix_len == plen &&\n\t\t    ipv6_addr_equal(pfx, &ifp->addr)) {\n\t\t\tin6_ifa_hold(ifp);\n\t\t\tread_unlock_bh(&idev->lock);\n\n\t\t\tipv6_del_addr(ifp);\n\n\t\t\t/* If the last address is deleted administratively,\n\t\t\t   disable IPv6 on this interface.\n\t\t\t */\n\t\t\tif (list_empty(&idev->addr_list))\n\t\t\t\taddrconf_ifdown(idev->dev, 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock_bh(&idev->lock);\n\treturn -EADDRNOTAVAIL;\n}",
    "comment": "Removes an IPv6 address from a network interface and disables IPv6 if it becomes the last address.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Retrieves and displays IPv6 address label information based on the provided socket buffer and interface index from the specified network device .\n",
    "cpbcs_sum": "Removes specified multicast addresses from the multicast routing table if it matches the specified network interface index and address.\n",
    "misum_sum": "Removes specified IPv6 address from the routing table if it is not currently registered and membership devices from the network stack.\n",
    "decom_sum": "Searches for a matching entry by ID and 128-bit key, updates its reference count, and triggers related processing with provided parameters.",
    "cfg_sum": "Validates parameters, searches for a matching record, updates its state, triggers processing callbacks, and returns a status code based on execution outcome.",
    "work_score": {
        "decom": {
            "summary": "Searches for a matching entry by ID and 128-bit key, updates its reference count, and triggers related processing with provided parameters.",
            "score": [
                0.6,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function searches by ID and 128-bit key, updates a reference count, and triggers related processing using parameters. While the code does search by ifindex (ID) and IPv6 address (128-bit key) and calls in6_ifa_hold to update the reference count, the summary omits important conditions like prefix length checks and error handling, and does not describe the address deletion or IPv6 shutdown logic. Most claims are partially correct but lack precision, resulting in mixed reliability.",
                "The summary omits the core purpose of deleting an IPv6 address from a network interface based on prefix length and address match, and does not mention error handling or the potential disabling of IPv6 if no addresses remain. While it vaguely references searching by ID and a key, this is too generic and not tied to the domain semantics of the function, making the core functionality uncovered.",
                "The summary contains multiple inaccuracies about the function's primary purpose and key I/O: it claims the function searches by ID and 128-bit key, but the source code searches by network device index and IPv6 prefix/address. It also incorrectly states that it updates a reference count and triggers related processing with provided parameters, omitting the main behavior of deleting the IPv6 address, handling possible errors, and disabling IPv6 when the last address is removed. These are severe FATAL errors concerning the core domain action, making the summary misleading for understanding the function."
            ]
        },
        "cfg": {
            "summary": "Validates parameters, searches for a matching record, updates its state, triggers processing callbacks, and returns a status code based on execution outcome.",
            "score": [
                0.3,
                0.1,
                0.3
            ],
            "reason": [
                "The summary contains mostly generic and inaccurate statements relative to the source code. While 'validates parameters' and 'returns a status code based on execution outcome' match the function's logic, claims about 'updates its state' and 'triggers processing callbacks' are overly generic or misleading \u2014 the function deletes an IPv6 address and may disable the interface, not initiate arbitrary callbacks. The description 'searches for a matching record' loosely aligns with scanning the address list, but overall, less than half of the claims are precise and directly supported by the code.",
                "The summary makes generic claims about validation, searching, updating state, triggering callbacks, and returning status codes, but these do not accurately capture the specific domain-semantic behavior of deleting an IPv6 address from a network interface when matching prefix and address are found. The core purpose of removing an IPv6 address and potentially disabling IPv6 is not covered, and even the secondary details such as specific error conditions (-EINVAL, -ENODEV, -ENXIO, -EADDRNOTAVAIL) and lock handling are missing. The claims are vague and mismatched with the source code semantics.",
                "The summary makes several inaccurate claims about the function\u2019s semantics. It suggests 'updates its state' and 'triggers processing callbacks', which are not supported by the source code; instead, the code deletes an IPv6 address and may disable IPv6 on the interface. It also fails to mention key aspects like validation of prefix length, device lookup, and address removal logic. While there is minimal accurate overlap in noting parameter validation and returning status codes, noise from these incorrect behavioral descriptions is overwhelming, with no specific GOLD-level insights provided."
            ]
        },
        "comment": {
            "summary": "Removes an IPv6 address from a network interface and disables IPv6 if it becomes the last address.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary contains two distinct claims: that the function removes an IPv6 address from a network interface, and that it disables IPv6 if the deleted address is the last one on the interface. Both claims accurately reflect the source code's logic \u2014 the function iterates over addresses, matches by prefix length and address, deletes the address, and triggers IPv6 shutdown if the list becomes empty. No contradictory or irrelevant information is present, so the claim set is highly precise.",
                "The summary accurately captures the core purpose: removing an IPv6 address from a network interface and disabling IPv6 if it was the last address. This matches the source code's main logic. However, it omits several critical secondary details such as validating prefix length, handling specific error codes for invalid input, missing devices or interfaces, and exact matching of prefix length and address before deletion. It also leaves out the lock/unlock mechanism and call to ipv6_del_addr. These missing behaviors limit completeness despite correct core coverage.",
                "The summary accurately describes the core function: it removes an IPv6 address from a network interface and disables IPv6 if the deleted address is the last one on the interface. There are no incorrect or noisy claims, and it captures the primary purpose and a key side effect. However, the summary provides only a high-level view without detail on conditions, error handling, or matching logic, so the informational gain is moderate rather than high."
            ]
        }
    }
}
{
    "project_name": "a2ps",
    "function_addr": 4225184,
    "strip_function_name": "sub_4078A0",
    "strip_decompiled_code": "const char *__fastcall sub_4078A0(const char *src)\n{\n  size_t v1; // rax\n  size_t v2; // rdx\n  unsigned __int64 v3; // rax\n  void *v4; // rsp\n  void *v5; // rsp\n  void *v6; // r13\n  char *v7; // rbx\n  const char **v8; // rax\n  char *i; // r12\n  const char **v10; // rax\n  char *v11; // rax\n  char *v12; // rbx\n  const char *v13; // rax\n  const char *v14; // rbx\n  const char **v15; // r12\n  char *v16; // rax\n  const char *v17; // rdi\n  char v19[15]; // [rsp+0h] [rbp-20h] BYREF\n\n  v1 = strlen(src);\n  v2 = v1 + 1;\n  v3 = (v1 + 31) & 0xFFFFFFFFFFFFFFF0LL;\n  v4 = alloca(v3);\n  v5 = alloca(v3);\n  memcpy(v19, src, v2);\n  v6 = (void *)sub_4343F0(\"Ancestors\", 2LL, 1LL, 2LL, j__fputs, 0LL);\n  v7 = strtok(v19, \",;+\");\n  sub_434A00(v6, v7);\n  v8 = (const char **)sub_406920(v7);\n  for ( i = stpcpy(v19, *v8); ; i = stpcpy(i + 1, *v10) )\n  {\n    v11 = strtok(0LL, \",;+\");\n    v12 = v11;\n    if ( !v11 )\n      break;\n    sub_434A00(v6, v11);\n    v10 = (const char **)sub_406920(v12);\n    *i = 44;\n  }\n  *i = 0;\n  v13 = (const char *)sub_438B00(v19);\n  v14 = v13;\n  if ( (dword_6584C8 & 4) != 0 )\n    fprintf(stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", v13);\n  v15 = (const char **)sub_4065D0((__int64)v14);\n  v16 = strdup(v14);\n  v17 = v15[8];\n  *v15 = v16;\n  sub_434B70(v17, v6);\n  sub_4344C0(v6);\n  sub_4069F0(v15);\n  return v14;\n}\n",
    "function_name": "style_sheet_mixed_new",
    "decompiled_code": "char *__fastcall style_sheet_mixed_new(\n        const char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        char a7)\n{\n  da_growth v7; // r13d\n  void (*v8)(const void *, FILE *); // r15\n  size_t v9; // rax\n  size_t v10; // rdx\n  unsigned __int64 v11; // rax\n  void *v12; // rsp\n  void *v13; // rsp\n  darray *v14; // r13\n  char *v15; // rbx\n  style_sheet *style_sheet; // rax\n  char *i; // r12\n  style_sheet *v18; // rax\n  char *v19; // rax\n  char *v20; // rbx\n  char *v21; // rax\n  char *v22; // rbx\n  style_sheet *v23; // r12\n  _UNKNOWN *retaddr; // [rsp+28h] [rbp+8h] BYREF\n\n  v9 = strlen(a1);\n  v10 = v9 + 1;\n  v11 = (v9 + 31) & 0xFFFFFFFFFFFFFFF0LL;\n  v12 = alloca(v11);\n  v13 = alloca(v11);\n  memcpy(&a7, a1, v10);\n  v14 = da_new(a1, (size_t)&a7, v7, (size_t)&retaddr, v8, 0LL);\n  v15 = strtok(&a7, &byte_43B750[7918]);\n  da_append((darray *)v15, v15);\n  style_sheet = get_style_sheet(v15);\n  for ( i = stpcpy(&a7, style_sheet->key); ; i = stpcpy(i + 1, v18->key) )\n  {\n    v19 = strtok(0LL, &byte_43B750[7918]);\n    v20 = v19;\n    if ( !v19 )\n      break;\n    da_append((darray *)v19, v19);\n    v18 = get_style_sheet(v20);\n    *i = 44;\n  }\n  *i = 0;\n  v21 = xstrdup(0LL);\n  v22 = v21;\n  if ( (msg_verbosity & 4) != 0 )\n    fprintf((FILE *)stderr, &byte_43B750[9696], v21);\n  v23 = new_style_sheet((size_t)v22);\n  v23->key = strdup(v22);\n  da_concat((darray *)v22, (darray *)&retaddr);\n  da_erase(v14);\n  style_sheet_finalize(v23);\n  return v22;\n}\n",
    "source_code": "\nstatic char *\nstyle_sheet_mixed_new (const uchar * ancestors)\n{\n  struct style_sheet *sheet, *ancestor;\n  char *ancestor_key, *key, *cp;\n  char *ancestors_keys;\n  struct darray *ancestors_array;\n\n  /* It cannot be longer than ancestors_keys. */\n  key = ALLOCA (char, ustrlen (ancestors) + 1);\n  astrcpy (ancestors_keys, ancestors);\n\n  /* Create the darray of ancestors keys, and build the final key. */\n  ancestors_array = ancestors_new ();\n  ancestor_key = strtok (ancestors_keys, MIXED_SHEET_SEP);\n  da_append (ancestors_array, ancestor_key);\n  ancestor = get_style_sheet (ancestor_key);\n  cp = stpcpy (key, ancestor->key);\n\n  while ((ancestor_key = strtok (NULL, MIXED_SHEET_SEP)))\n    {\n      da_append (ancestors_array, ancestor_key);\n      ancestor = get_style_sheet (ancestor_key);\n      *cp++ =',';\n      cp = stpcpy (cp, ancestor->key);\n    }\n  *cp = '\\0';\n  key = xstrdup (key);\n\n  /* Create the style sheet. */\n  message (msg_sheet,\n\t   (stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", key));\n  /* Its name is its key. */\n  sheet = new_style_sheet ((uchar *) key);\n  sheet->key = strdup (key);\n  da_concat (sheet->ancestors, ancestors_array);\n  da_erase (ancestors_array);\n  style_sheet_finalize (sheet);\n\n  return key;\n}",
    "comment": "Creates a new style sheet by concatenating keys from ancestor style sheets, storing them in a darray, and finalizing the new sheet.",
    "hext5_sum": "set up the sizes and contents of the elf dynamic sections.",
    "bint5_sum": "Constructs a relative path from a given file path by traversing up its directory hierarchy until a different file system is detected .\n",
    "cpbcs_sum": "Constructs a mangled filename by concatenating a template string in /proc/irq and appending a dot suffix to a specified file.\n",
    "misum_sum": "Generates a shell message for a given message by concatenating a suffix, then returns the resulting digest string.\n",
    "decom_sum": "Parses a comma/semicolon/plus-separated list of ancestor names, builds a mixed style sheet from them, and registers it for further use.",
    "cfg_sum": "Parses a comma- or symbol-separated list of ancestor names, builds and logs a mixed style sheet, and updates related stylesheet data structures.",
    "work_score": {
        "decom": {
            "summary": "Parses a comma/semicolon/plus-separated list of ancestor names, builds a mixed style sheet from them, and registers it for further use.",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function processes a separator-delimited list of ancestor names and constructs a mixed style sheet, which is aligned with the code\u2019s logic using `strtok` with `MIXED_SHEET_SEP` and `new_style_sheet`. However, the specified separators (comma/semicolon/plus) are not confirmed by the source code; the actual separator constants are not shown, making this part unverifiable and potentially inaccurate. Additionally, the summary\u2019s phrase 'registers it for further use' is not explicitly supported\u2014while the sheet is created and finalized, there is no explicit registration mechanism shown. Thus, only part of the summary is accurate, leading to mixed reliability.",
                "The summary correctly states that the function parses a list of ancestor names separated by specific delimiters and builds a mixed style sheet from them, aligning with the core purpose of constructing a style sheet key from ancestor sheets. However, it inaccurately describes 'registers it for further use' \u2014 the code actually creates and finalizes the new style sheet object but does not show any explicit registration mechanism beyond construction. It also omits secondary details such as building the ancestor key via stpcpy, appending to an array, message logging, memory duplication, and handling of ancestor array lifecycle.",
                "The summary correctly notes that the function creates a mixed style sheet from multiple ancestor names, aligning with the code's loop, concatenation, and sheet creation. However, it inaccurately describes the separators as comma/semicolon/plus-separated, while the code uses a specific MIXED_SHEET_SEP delimiter whose value is not specified. It also incorrectly implies registration for further use, whereas the code finalizes the sheet but does not explicitly register it beyond internal creation. These inaccuracies target the core input parsing and output behavior, constituting a FATAL error related to primary purpose semantics."
            ]
        },
        "cfg": {
            "summary": "Parses a comma- or symbol-separated list of ancestor names, builds and logs a mixed style sheet, and updates related stylesheet data structures.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary contains mostly accurate claims: it describes parsing a separated list of ancestor names, building a mixed style sheet, logging its creation, and updating related stylesheet structures. The source code shows using strtok with MIXED_SHEET_SEP, creating a composite key from ancestor->key values, logging with message(), creating a new style sheet, setting its key, concatenating ancestor data, and finalizing. All claims align with the implementation details, with only minor generic phrasing and no clear inaccuracies.",
                "The summary accurately conveys that the function parses a separator-delimited list of ancestor names, constructs a mixed style sheet, logs its creation, and updates related data structures, matching the core purpose of combining ancestor style sheets into a new one. However, while the core action is covered, the summary omits secondary behavior-critical details from the code such as the exact separator constant (MIXED_SHEET_SEP), how the key is formed from ancestor keys, allocation and duplication steps, and cleanup operations on temporary arrays. These omissions reduce completeness of coverage.",
                "The summary correctly notes that the function parses a separated list of ancestor names, logs creation of a mixed style sheet, and updates stylesheet data structures, all of which align with the source code\u2019s actual behavior. It omits some specifics such as the exact separator token (MIXED_SHEET_SEP) and the construction of the `key` string from ancestor keys, but these are minor omissions. There are no factual inaccuracies or irrelevant noise, and the claims are accurate though somewhat generic, yielding moderate insight."
            ]
        },
        "comment": {
            "summary": "Creates a new style sheet by concatenating keys from ancestor style sheets, storing them in a darray, and finalizing the new sheet.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly describes that the function creates a new style sheet by concatenating ancestor keys, storing them in a darray, and finalizing it. These are accurate reflections of the source code, which uses ancestor keys to build a combined key, appends them to a darray, creates and finalizes the style sheet. While the summary omits some implementation details such as memory allocation and message logging, all included claims are precise and align with the code\u2019s behavior, making the accuracy proportion very high.",
                "The summary accurately describes the core purpose: creating a mixed style sheet by concatenating ancestor keys, storing them in a darray, and finalizing. It covers the main domain-specific behavior of generating a combined key from multiple ancestors and constructing the new sheet. However, it omits secondary details such as allocation with ALLOCA, parsing using a separator constant (MIXED_SHEET_SEP), logging via message(), memory duplication steps (xstrdup, strdup), and cleanup of the ancestors array. These omissions mean secondary behavior coverage is limited.",
                "The summary correctly captures the primary purpose of creating a new style sheet by combining keys from ancestor sheets and finalizing it, which matches the source code's behavior. However, it omits important details such as the use of a specific delimiter when concatenating, the logging step, and that the new sheet\u2019s key is explicitly set to the concatenated string. The claims present are accurate but somewhat generic, giving limited insight beyond the core action. There is no inaccurate or contradictory content, and noise is minimal, but gain is modest due to lack of specificity."
            ]
        }
    }
}
{
    "project_name": "libredwg",
    "function_addr": 7274112,
    "strip_function_name": "dwg_find_tablehandle",
    "strip_decompiled_code": "__int64 __fastcall dwg_find_tablehandle(_QWORD *a1, const char *a2, const char *a3)\n{\n  __int64 v4; // r14\n  __int64 result; // rax\n  __int64 v6; // rax\n\n  if ( a3 == 0LL || a2 == 0LL || !a1 )\n    return 0LL;\n  v4 = dwg_ctrl_table(a1, a3);\n  if ( strcmp(a3, \"LTYPE\") )\n    goto LABEL_11;\n  if ( strcmp(a2, \"BYLAYER\") && strcmp(a2, \"ByLayer\") )\n  {\n    if ( !strcmp(a2, \"BYBLOCK\") || !strcmp(a2, \"ByBlock\") )\n    {\n      result = a1[315];\n      if ( result )\n        return result;\n    }\n    else if ( !strcmp(a2, \"CONTINUOUS\") || !strcmp(a2, \"Continuous\") )\n    {\n      result = a1[316];\n      if ( result )\n        return result;\n    }\nLABEL_11:\n    if ( v4 )\n      goto LABEL_12;\nLABEL_18:\n    if ( (unsigned int)dword_1110710 <= 2 )\n      return 0LL;\nLABEL_19:\n    __fprintf_chk();\n    return 0LL;\n  }\n  result = a1[314];\n  if ( result )\n    return result;\n  if ( !v4 )\n    goto LABEL_18;\nLABEL_12:\n  v6 = dwg_resolve_handle((__int64)a1, *(_QWORD *)(v4 + 32));\n  if ( !v6 )\n  {\n    if ( (unsigned int)dword_1110710 <= 2 )\n      return 0LL;\n    goto LABEL_19;\n  }\n  if ( *(_DWORD *)(v6 + 16) == 42 )\n    return dwg_find_dicthandle_objname((__int64)a1, v4, a2);\n  if ( (unsigned int)dwg_obj_is_control(v6) )\n  {\n    dwg_dynapi_entity_value();\n    return 0LL;\n  }\n  if ( !dword_1110710 )\n    return 0LL;\n  fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n  if ( dword_1110710 )\n    __fprintf_chk();\n  fputc(10, stderr);\n  return 0LL;\n}\n",
    "function_name": "dwg_find_tablehandle",
    "decompiled_code": "BITCODE_H __fastcall dwg_find_tablehandle(Dwg_Data_2 *dwg, const char *name, const char *table)\n{\n  BITCODE_H v5; // r14\n  BITCODE_H result; // rax\n  Dwg_Object *v7; // rax\n  Dwg_Object *v8; // r12\n  const char *v9; // rcx\n  const char *v10; // rdx\n  Dwg_Entity_UNUSED *UNUSED; // r13\n  __int64 v12; // rdx\n  unsigned int v13; // r15d\n  __int64 v14; // rax\n  Dwg_Object *v15; // rax\n  Dwg_Object *v16; // r12\n  Dwg_Object_Entity *entity; // rax\n  Dwg_Entity_UNUSED *v18; // rdi\n  char v19; // r14\n  char *v20; // r12\n  int v21; // r14d\n  Dwg_Object *v22; // [rsp+90h] [rbp+18h]\n  __int64 v23; // [rsp+98h] [rbp+20h] BYREF\n  __int64 v24; // [rsp+A0h] [rbp+28h] BYREF\n  char *v25; // [rsp+A8h] [rbp+30h] BYREF\n  unsigned __int64 v26; // [rsp+B0h] [rbp+38h]\n\n  v26 = __readfsqword(0x28u);\n  LODWORD(v23) = 0;\n  v24 = 0LL;\n  if ( table == 0LL || name == 0LL || !dwg )\n    return 0LL;\n  v5 = dwg_ctrl_table(dwg, table);\n  if ( strcmp(table, \"LTYPE\") )\n  {\nLABEL_11:\n    if ( v5 )\n      goto LABEL_12;\nLABEL_18:\n    v9 = table;\n    v10 = \"dwg_find_tablehandle: Empty header_vars table %s\\n\";\n    if ( loglevel_7 <= 2 )\n      return 0LL;\nLABEL_19:\n    ((void (__fastcall *)(struct _IO_FILE *, __int64, const char *, const char *))__fprintf_chk)(stderr, 1LL, v10, v9);\n    return 0LL;\n  }\n  if ( strcmp(name, \"BYLAYER\") && strcmp(name, \"ByLayer\") )\n  {\n    if ( !strcmp(name, \"BYBLOCK\") || !strcmp(name, \"ByBlock\") )\n    {\n      result = dwg->header_vars.LTYPE_BYBLOCK;\n      if ( result )\n        return result;\n    }\n    else if ( !strcmp(name, \"CONTINUOUS\") || !strcmp(name, \"Continuous\") )\n    {\n      result = dwg->header_vars.LTYPE_CONTINUOUS;\n      if ( result )\n        return result;\n    }\n    goto LABEL_11;\n  }\n  result = dwg->header_vars.LTYPE_BYLAYER;\n  if ( result )\n    return result;\n  if ( !v5 )\n    goto LABEL_18;\nLABEL_12:\n  v7 = dwg_resolve_handle(dwg, v5->absolute_ref);\n  v8 = v7;\n  if ( !v7 )\n  {\n    if ( loglevel_7 <= 2 )\n      return 0LL;\n    v9 = table;\n    v10 = \"dwg_find_tablehandle: Could not resolve table %s\\n\";\n    goto LABEL_19;\n  }\n  if ( v7->type == 42 )\n    return dwg_find_dicthandle_objname(dwg, v5, name);\n  if ( !dwg_obj_is_control(v7) )\n  {\n    if ( loglevel_7 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( loglevel_7 )\n        ((void (*)(struct _IO_FILE *, __int64, const char *, ...))__fprintf_chk)(\n          stderr,\n          1LL,\n          \"dwg_find_tablehandle: Could not resolve CONTROL object %s for table %s\",\n          v8->name,\n          table);\n      fputc(10, stderr);\n      return 0LL;\n    }\n    return 0LL;\n  }\n  UNUSED = v8->tio.entity->tio.UNUSED;\n  ((void (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, __int64 *, _QWORD))dwg_dynapi_entity_value)(\n    UNUSED,\n    v8->name,\n    \"num_entries\",\n    &v23,\n    0LL);\n  if ( !(_DWORD)v23 )\n    return 0LL;\n  ((void (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, __int64 *, _QWORD))dwg_dynapi_entity_value)(\n    UNUSED,\n    v8->name,\n    \"entries\",\n    &v24,\n    0LL);\n  v12 = v24;\n  if ( !v24 || !(_DWORD)v23 )\n    return 0LL;\n  v22 = v8;\n  v13 = 0;\n  while ( 1 )\n  {\n    HIDWORD(v23) = 0;\n    v14 = *(_QWORD *)(v12 + 8LL * v13);\n    if ( v14 )\n    {\n      v15 = dwg_resolve_handle(dwg, *(_QWORD *)(v14 + 32));\n      v16 = v15;\n      if ( v15 )\n      {\n        entity = v15->tio.entity;\n        if ( entity )\n        {\n          v18 = entity->tio.UNUSED;\n          if ( v18 )\n          {\n            v19 = ((__int64 (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, char **, char *, _QWORD))dwg_dynapi_entity_utf8text)(\n                    v18,\n                    v16->name,\n                    \"name\",\n                    &v25,\n                    (char *)&v23 + 4,\n                    0LL);\n            if ( loglevel_7 > 3 )\n              ((void (__fastcall *)(struct _IO_FILE *, __int64, const char *, char *, char *, _QWORD))__fprintf_chk)(\n                stderr,\n                1LL,\n                \" %s.%s[%d] => %s.name: %s\\n\",\n                v22->name,\n                \"entries\",\n                v13);\n            if ( v19 )\n            {\n              v20 = v25;\n              if ( v25 )\n                break;\n            }\n          }\n        }\n      }\n    }\nLABEL_44:\n    if ( (unsigned int)v23 <= ++v13 )\n      return 0LL;\n    v12 = v24;\n  }\n  v21 = HIDWORD(v23);\n  if ( strcmp(name, v25) && strcasecmp(name, v20) )\n  {\n    if ( v21 )\n      free(v20);\n    goto LABEL_44;\n  }\n  if ( v21 )\n    free(v20);\n  return *(BITCODE_H *)(v24 + 8LL * v13);\n}\n",
    "source_code": "EXPORT BITCODE_H\ndwg_find_tablehandle (Dwg_Data *restrict dwg, const char *restrict name,\n                      const char *restrict table)\n{\n  BITCODE_BL i, num_entries = 0;\n  BITCODE_H ctrl = NULL, *hdlv = NULL;\n  Dwg_Object *obj;\n  Dwg_Object_APPID_CONTROL *_obj; // just some random generic type\n  Dwg_Header_Variables *vars = &dwg->header_vars;\n\n  if (!dwg || !name || !table)\n    return NULL;\n  // look for the _CONTROL table, and search for name in all entries\n  ctrl = dwg_ctrl_table (dwg, table);\n  if (strEQc (table, \"LTYPE\"))\n    {\n      if (strEQc (name, \"BYLAYER\") || strEQc (name, \"ByLayer\"))\n        {\n          if (vars->LTYPE_BYLAYER)\n            return vars->LTYPE_BYLAYER;\n        }\n      else if (strEQc (name, \"BYBLOCK\") || strEQc (name, \"ByBlock\"))\n        {\n          if (vars->LTYPE_BYBLOCK)\n            return vars->LTYPE_BYBLOCK;\n        }\n      else if (strEQc (name, \"CONTINUOUS\") || strEQc (name, \"Continuous\"))\n        {\n          if (vars->LTYPE_CONTINUOUS)\n            return vars->LTYPE_CONTINUOUS;\n        }\n    }\n  if (!ctrl)\n    { // TODO: silently search table_control. header_vars can be empty\n      LOG_TRACE (\"dwg_find_tablehandle: Empty header_vars table %s\\n\", table);\n      return NULL;\n    }\n  obj = dwg_resolve_handle (dwg, ctrl->absolute_ref);\n  if (!obj)\n    {\n      LOG_TRACE (\"dwg_find_tablehandle: Could not resolve table %s\\n\", table);\n      return NULL;\n    }\n  if (obj->type == DWG_TYPE_DICTIONARY)\n    return dwg_find_dicthandle_objname (dwg, ctrl, name);\n  if (!dwg_obj_is_control (obj))\n    {\n      LOG_ERROR (\"dwg_find_tablehandle: Could not resolve CONTROL object %s \"\n                 \"for table %s\",\n                 obj->name, table);\n      return NULL;\n    }\n  _obj = obj->tio.object->tio.APPID_CONTROL; // just random type\n  dwg_dynapi_entity_value (_obj, obj->name, \"num_entries\", &num_entries, NULL);\n  if (!num_entries)\n    return NULL;\n  dwg_dynapi_entity_value (_obj, obj->name, \"entries\", &hdlv, NULL);\n  if (!hdlv)\n    return NULL;\n  for (i = 0; i < num_entries; i++)\n    {\n      char *hdlname;\n      Dwg_Object *hobj;\n      Dwg_Object_APPID *_o;\n      int isnew = 0;\n      bool ok;\n\n      if (!hdlv[i])\n        continue;\n      hobj = dwg_resolve_handle (dwg, hdlv[i]->absolute_ref);\n      if (!hobj || !hobj->tio.object || !hobj->tio.object->tio.APPID)\n        continue;\n      _o = hobj->tio.object->tio.APPID;\n      ok = dwg_dynapi_entity_utf8text (_o, hobj->name, \"name\", &hdlname, &isnew, NULL);\n      LOG_HANDLE (\" %s.%s[%d] => %s.name: %s\\n\", obj->name, \"entries\", i,\n                  hobj->name, hdlname ? hdlname : \"NULL\");\n      if (ok && hdlname && (strEQ (name, hdlname) || !strcasecmp (name, hdlname)))\n        {\n          if (isnew)\n            free (hdlname);\n          return hdlv[i];\n        }\n      if (ok && isnew && hdlname)\n        free (hdlname);\n    }\n\n  return NULL;\n}",
    "comment": "Retrieves a handle for a specified named entry in a given table from a DWG file's control structure.",
    "hext5_sum": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert the numeric value to a structure, prints the header.",
    "bint5_sum": "Retrieves a handle for a specified table type and name in a DWG data structure based on the provided parameters .\n",
    "cpbcs_sum": "Retrieves UTF-8 encoded values from a DWG entity based on a specified header name and ending from a drawing object.\n",
    "misum_sum": "Processes RSA-related Unicode code to set UTF-8 grapheme based on specific flags and associated name comparisons.\n",
    "decom_sum": "Retrieves a DWG table handle for a specified object name, handling special LTYPE cases and reporting errors when resolution fails.",
    "cfg_sum": "Retrieves a DWG table handle for specific LTYPE or entity names, resolving references and returning matching objects or logging errors on failure.",
    "work_score": {
        "decom": {
            "summary": "Retrieves a DWG table handle for a specified object name, handling special LTYPE cases and reporting errors when resolution fails.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function retrieves a DWG table handle for a given name and implements special handling for LTYPE cases. It also accurately notes that the function logs errors when resolution fails. However, it omits several important details of the function's semantics, such as the specific lookup sequence using control tables, dictionary checks, and iteration over entries. Despite these omissions, the claims made are accurate and relevant to the code, giving a high proportion of correct statements.",
                "The summary accurately states that the function retrieves a DWG table handle and mentions handling special LTYPE cases, which matches the core purpose and the specific branch for LTYPE names in the code. It also notes error reporting on resolution failures, which is reflected by LOG_ERROR and LOG_TRACE calls in failure cases. However, it omits other important behaviors such as null checks for inputs, dictionary type handling via dwg_find_dicthandle_objname, iteration through table entries using name comparisons, and returning NULL when entries are missing. The coverage of secondary details is limited.",
                "The summary captures the core purpose of retrieving a DWG table handle for a given name and notes the special-case logic for LTYPE entries, which aligns accurately with the code. It also mentions error reporting on resolution failures, which occurs via LOG_ERROR and LOG_TRACE calls. However, the description is brief and omits important details such as the handling of dictionary-type objects, iteration over entries, and various null-return conditions, resulting in low informational gain despite no inaccuracies."
            ]
        },
        "cfg": {
            "summary": "Retrieves a DWG table handle for specific LTYPE or entity names, resolving references and returning matching objects or logging errors on failure.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly indicates that the function retrieves a DWG table handle for specific LTYPE or other names and that it resolves references and returns matching objects, which matches the code. However, it omits important branching logic such as the special handling for LTYPE names 'BYLAYER', 'BYBLOCK', and 'CONTINUOUS' from header variables, the handling of dictionary objects, and situations where control objects are missing. The error logging mention is accurate but generic. Overall, most claims are accurate but lack full coverage of function semantics.",
                "The summary captures the core purpose\u2014retrieving a DWG table handle for specific LTYPE or entity names and returning matching objects\u2014which aligns with the function\u2019s main logic. It also notes resolving references and error logging, which are valid secondary behaviors. However, it omits several critical details from the source code, such as handling special cases for specific LTYPE names via header variables, dictionary-type handling via dwg_find_dicthandle_objname, control object validation, iteration over entries, and UTF-8 name comparison. These omissions reduce completeness despite accurately covering the core.",
                "The summary correctly states that the function retrieves a DWG table handle and includes special handling for LTYPE names, matching the code\u2019s conditional branches for 'BYLAYER', 'BYBLOCK', and 'CONTINUOUS'. It also notes resolution of references and logging errors on failure, which aligns with calls to dwg_resolve_handle, LOG_TRACE, and LOG_ERROR. However, it omits several specific semantics such as dictionary lookup via dwg_find_dicthandle_objname, iteration over entries to match exact names, and the NULL returns in many failure paths. No claims contradict the code, but the coverage is relatively generic and lacks detailed GOLD insights, leading to only modest informational gain."
            ]
        },
        "comment": {
            "summary": "Retrieves a handle for a specified named entry in a given table from a DWG file's control structure.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves a handle for a specified named entry from a given table in a DWG file's control structure, which matches the core purpose of the code. However, it omits significant details such as special handling for specific table names (e.g., \"LTYPE\"), multiple early NULL returns, and the fact that it searches both control and dictionary objects. The claim is accurate but overly generic, missing domain-specific behaviors present in the source code.",
                "The summary correctly identifies the core function as retrieving a handle for a named entry in a specified table within a DWG control structure, which matches the code's primary purpose. However, it omits key secondary behaviors, such as special-case handling for 'LTYPE' names via header variables, multiple null and type checks, dictionary table handling, logging on errors, and iteration over control entries with name matching. These omissions limit the coverage of critical semantics beyond the core action.",
                "The summary accurately captures the core purpose of the function\u2014retrieving a handle for a named entry from a specified table in the DWG control structure. It is correct and aligned with the code's primary behavior. However, the description is very high-level and omits notable specifics such as the special handling of the 'LTYPE' table, early null checks, multiple resolution paths (dictionary vs. control object), and iteration through entries. While there is no incorrect or contradictory claim, the informational gain is low due to lack of detail."
            ]
        }
    }
}
{
    "project_name": "ncurses",
    "function_addr": 69424,
    "strip_function_name": "sub_10F30",
    "strip_decompiled_code": "_BYTE *__fastcall sub_10F30(__int64 a1, __int64 a2)\n{\n  _BYTE *result; // rax\n  _BYTE *v3; // rbp\n  _BYTE *v4; // rdx\n  unsigned int v5; // ebx\n  __int64 v6; // rdx\n  __int16 v7; // ax\n\n  result = *(_BYTE **)(a1 + 104);\n  v3 = result;\n  v4 = &result[*(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 12)];\n  if ( (*(_BYTE *)(a1 + 49) & 8) != 0 )\n  {\n    if ( result < v4 )\n      goto LABEL_17;\nLABEL_8:\n    v5 = (_DWORD)v4 - (_DWORD)v3;\n    if ( (int)v4 - (int)v3 <= 0 )\n      return result;\n    goto LABEL_9;\n  }\n  if ( result >= v4 )\n    goto LABEL_8;\n  if ( *result == 32 )\n  {\n    while ( ++v3 != v4 )\n    {\n      if ( *v3 != 32 )\n        goto LABEL_17;\n    }\n    v3 = *(_BYTE **)(a1 + 104);\n    if ( *(v4 - 1) == 32 )\n      goto LABEL_16;\n    goto LABEL_8;\n  }\nLABEL_17:\n  while ( *(v4 - 1) == 32 )\n  {\nLABEL_16:\n    if ( --v4 <= result )\n      goto LABEL_8;\n  }\n  v5 = (_DWORD)v4 - (_DWORD)v3;\n  if ( (int)v4 - (int)v3 > 0 )\n  {\nLABEL_9:\n    v6 = *(__int16 *)(a1 + 4) - v5;\n    if ( (int)v6 < 0 )\n    {\n      v6 = 0LL;\n    }\n    else\n    {\n      v7 = *(_WORD *)(a1 + 30);\n      if ( v7 == 2 )\n      {\n        v6 = (unsigned int)((int)v6 >> 1);\n      }\n      else if ( v7 != 3 )\n      {\n        v6 = 0LL;\n      }\n    }\n    sub_1FE50(a2, 0LL, v6);\n    return (_BYTE *)sub_1A040(a2, v3, v5);\n  }\n  return result;\n}\n",
    "function_name": "Perform_Justification",
    "decompiled_code": "void __fastcall Perform_Justification(FIELD *field, WINDOW *win)\n{\n  char *buf; // rax\n  char *v3; // rbp\n  char *v4; // rdx\n  int v5; // ebx\n  int v6; // edx\n  __int16 just; // ax\n\n  buf = field->buf;\n  v3 = buf;\n  v4 = &buf[field->dcols * field->drows];\n  if ( (field->opts & 0x800) != 0 )\n  {\n    if ( buf < v4 )\n      goto LABEL_17;\nLABEL_8:\n    v5 = (_DWORD)v4 - (_DWORD)v3;\n    if ( (int)v4 - (int)v3 <= 0 )\n      return;\n    goto LABEL_9;\n  }\n  if ( buf >= v4 )\n    goto LABEL_8;\n  if ( *buf == 32 )\n  {\n    while ( ++v3 != v4 )\n    {\n      if ( *v3 != 32 )\n        goto LABEL_17;\n    }\n    v3 = field->buf;\n    if ( *(v4 - 1) == 32 )\n      goto LABEL_16;\n    goto LABEL_8;\n  }\nLABEL_17:\n  while ( *(v4 - 1) == 32 )\n  {\nLABEL_16:\n    if ( --v4 <= buf )\n      goto LABEL_8;\n  }\n  v5 = (_DWORD)v4 - (_DWORD)v3;\n  if ( (int)v4 - (int)v3 > 0 )\n  {\nLABEL_9:\n    v6 = field->cols - v5;\n    if ( v6 < 0 )\n    {\n      v6 = 0;\n    }\n    else\n    {\n      just = field->just;\n      if ( just == 2 )\n      {\n        v6 >>= 1;\n      }\n      else if ( just != 3 )\n      {\n        v6 = 0;\n      }\n    }\n    wmove(win, 0, v6);\n    waddnstr(win, v3, v5);\n  }\n}\n",
    "source_code": "static void\nPerform_Justification(FIELD *field, WINDOW *win)\n{\n  FIELD_CELL *bp;\n  int len;\n\n  bp = (Field_Has_Option(field, O_NO_LEFT_STRIP)\n\t? field->buf\n\t: Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);\n\n  if (len > 0)\n    {\n      int col = 0;\n\n      assert(win && (field->drows == 1));\n\n      if (field->cols - len >= 0)\n\tswitch (field->just)\n\t  {\n\t  case JUSTIFY_LEFT:\n\t    break;\n\t  case JUSTIFY_CENTER:\n\t    col = (field->cols - len) / 2;\n\t    break;\n\t  case JUSTIFY_RIGHT:\n\t    col = field->cols - len;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n      wmove(win, 0, col);\n      myADDNSTR(win, bp, len);\n    }\n}",
    "comment": "Justifies the contents of a field within a window by aligning text based on specified justification (left, center, right) and current field length.",
    "hext5_sum": "@param[in] path colon separated list of directories @param[in] fname the name we are hunting for @param[in] mode the required file mode @returns an allocated string with the full path, or null local implementation of pathfind.",
    "bint5_sum": "Advances the cursor position in a form to the start of the next non-whitespace word in a given field , handling whitespace appropriately .\n",
    "cpbcs_sum": "Restores the display of a FIELD in a WINDOW by moving the cursor and writing the relevant data buffer contents to the window.\n",
    "misum_sum": "Restores the display of a FIELD in a WINDOW by moving the cursor position to the appropriate timeout based on a valid window.\n",
    "decom_sum": "Trims leading and trailing spaces from a buffer segment and writes the trimmed data into the destination with format-specific length adjustment.",
    "cfg_sum": "Trims leading and trailing spaces from a memory buffer, adjusts length based on format type, and writes the processed data to the destination.",
    "work_score": {
        "decom": {
            "summary": "Trims leading and trailing spaces from a buffer segment and writes the trimmed data into the destination with format-specific length adjustment.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function trims both leading and trailing spaces, while the source code only conditionally strips leading spaces if the O_NO_LEFT_STRIP option is not set and does not strip trailing spaces. Additionally, it omits the justification logic (left, center, right) and the positioning of the text in the window, which are core to the function's behavior. Thus, most claims are inaccurate or incomplete relative to the code semantics.",
                "The summary claims removal of leading and trailing spaces and format-specific length adjustment, but the source code only conditionally strips leading spaces (depending on O_NO_LEFT_STRIP) and computes length up to the end of data without trailing trim logic. It omits the core purpose of displaying the field's content in a window according to justification (left, center, right) and starting column adjustments. Secondary behaviors like single row assertion and wmove/myADDNSTR usage are also missing.",
                "The summary incorrectly states that both leading and trailing spaces are trimmed. In the source, leading spaces are only stripped if the O_NO_LEFT_STRIP option is not set, and there is no removal of trailing spaces; instead, data boundaries are computed based on buffer content. This is a FATAL error on the primary purpose since justification logic, not trimming, is the core behavior. No accurate claims remain to provide positive gain."
            ]
        },
        "cfg": {
            "summary": "Trims leading and trailing spaces from a memory buffer, adjusts length based on format type, and writes the processed data to the destination.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains claims about trimming both leading and trailing spaces and adjusting length based on a generic format type, which do not fully align with the source code. The function only conditionally skips leading spaces depending on options and calculates length based on actual data boundaries without indiscriminate trimming of trailing spaces; it just adjusts position according to justification settings. While it correctly notes that processed data is written to the destination, most of the description misrepresents the code\u2019s specific behavior, resulting in fewer than half of the claims being accurate.",
                "The summary claims trimming of both leading and trailing spaces, adjustment based on format type, and writing to a destination. The source code only conditionally strips leading spaces, calculates length until data end, and adjusts starting column based on justification (left, center, right). 'Format type' is misrepresented, as the code deals with justification settings, not a generic format concept. The core purpose \u2014 displaying a single-row field's content in a window with proper justification \u2014 is not covered at all, and key behaviors such as conditional left-strip, length computation, justification logic, and window movement are omitted or incorrect.",
                "The summary claims trimming both leading and trailing spaces and adjusting length based on format type, which contradicts the source code\u2019s actual behavior. The code only conditionally strips leading spaces (depending on O_NO_LEFT_STRIP) and calculates length from the end of meaningful data without explicitly trimming trailing spaces. The \u2018format type\u2019 adjustment described is inaccurate\u2014justification is handled by computing column shift, not formatting type. This is a FATAL error on the primary purpose, as it misstates the core text processing behavior."
            ]
        },
        "comment": {
            "summary": "Justifies the contents of a field within a window by aligning text based on specified justification (left, center, right) and current field length.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function aligns text within a window according to the specified justification (left, center, right) and considers the current field length, which matches the code's logic for calculating column offsets before writing text. However, it omits mention of conditions like single-row fields, handling of leading spaces, and checks on sufficient space, making it accurate but somewhat incomplete.",
                "The summary accurately captures the core purpose of aligning text within a window based on the field's justification setting and text length, which matches the source code's main operation. However, it omits secondary details such as handling stripping of leading spaces depending on field options, the specific condition for processing (len > 0, single-row field), and the movement and string output functions used. These omissions reduce coverage of other behavior-critical semantics.",
                "The summary correctly identifies the primary purpose of the function as justifying text within a field and window based on left, center, or right alignment, and considering the current field length. This matches the code\u2019s logic involving justification cases and calculation of column offset. There is no contradiction or noise, but the claim is relatively generic and lacks mention of other details such as stripping options, single-row assertion, and condition for non-empty content. The gain is modest because while it captures the core purpose accurately, it omits secondary operational specifics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582135843,
    "strip_function_name": "sub_FFFFFFFF81323623",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81323623(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10,\n        __int64 *a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  __int64 i; // rbx\n  __int64 *v15; // rdx\n  __int64 v16; // rcx\n  int v17; // r8d\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  int v23; // r8d\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 *v27; // rdx\n  __int64 v28; // rcx\n  int v29; // r8d\n  int v30; // r9d\n  double v31; // xmm4_8\n  double v32; // xmm5_8\n  __int64 *v33; // rdx\n  __int64 v34; // rcx\n  int v35; // r8d\n  int v36; // r9d\n  double v37; // xmm4_8\n  double v38; // xmm5_8\n\n  for ( i = 0LL; i != 24; i += 3LL )\n  {\n    sub_FFFFFFFF812FBA70(qword_FFFFFFFF81E9EAC0[i], a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);\n    qword_FFFFFFFF81E9EAC0[i] = 0LL;\n    qword_FFFFFFFF81E9EAD0[i] = 0LL;\n  }\n  sub_FFFFFFFF812FBA70(qword_FFFFFFFF81E9EA68, a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA80, a10, v15, v16, v17, v18, a1, a2, a3, a4, v19, v20, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA78, a10, v21, v22, v23, v24, a1, a2, a3, a4, v25, v26, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA70, a10, v27, v28, v29, v30, a1, a2, a3, a4, v31, v32, a7, a8);\n  return sub_FFFFFFFF8132319B((__int64)&unk_FFFFFFFF81E9EA50, a10, v33, v34, v35, v36, a1, a2, a3, a4, v37, v38, a7, a8);\n}\n",
    "function_name": "acpi_ut_mutex_terminate",
    "decompiled_code": "__int64 __fastcall acpi_ut_mutex_terminate(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10,\n        __int64 *a11)\n{\n  __int64 i; // rbx\n  __int64 *v12; // rdx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 *v15; // rdx\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 *v18; // rdx\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  for ( i = 0LL; i != 24; i += 3LL )\n  {\n    acpi_os_delete_semaphore((__int64 *)acpi_gbl_mutex_info[i], a10, a11, a1, a2, a3, a4, a5, a6, a7, a8);\n    acpi_gbl_mutex_info[i] = 0LL;\n    qword_FFFFFFFF81E9EAD0[i] = 0LL;\n  }\n  acpi_os_delete_semaphore((__int64 *)acpi_gbl_osi_mutex, a10, a11, a1, a2, a3, a4, a5, a6, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_gpe_lock, a10, v12, a1, a2, a3, a4, v13, v14, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_hardware_lock, a10, v15, a1, a2, a3, a4, v16, v17, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_reference_count_lock, a10, v18, a1, a2, a3, a4, v19, v20, a7, a8);\n  return acpi_ut_delete_rw_lock((__int64)acpi_gbl_namespace_rw_lock, a10, v21, a1, a2, a3, a4, v22, v23, a7, a8);\n}\n",
    "source_code": "\nvoid acpi_ut_mutex_terminate(void)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_terminate);\n\n\t/* Delete each predefined mutex object */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tacpi_ut_delete_mutex(i);\n\t}\n\n\tacpi_os_delete_mutex(acpi_gbl_osi_mutex);\n\n\t/* Delete the spinlocks */\n\n\tacpi_os_delete_lock(acpi_gbl_gpe_lock);\n\tacpi_os_delete_lock(acpi_gbl_hardware_lock);\n\tacpi_os_delete_lock(acpi_gbl_reference_count_lock);\n\n\t/* Delete the reader/writer lock */\n\n\tacpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_VOID;\n}",
    "comment": "Terminates and deletes all predefined mutex objects, spinlocks, and a reader/writer lock to clean up synchronization mechanisms.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases resources and deletes all video devices in the ACPI video bus , including their brightness settings , while ensuring thread safety .\n",
    "cpbcs_sum": "Releases resources and unregisters video devices and classes related to the ACPI video module exit.\n",
    "misum_sum": "Unregisters the ACPI video driver by resetting the list and freeing allocated memory for them.\n",
    "decom_sum": "Resets multiple global data slots, processes them with given parameters, and performs final aggregated computation using auxiliary processing functions.",
    "cfg_sum": "Processes and clears multiple data buffers, performs sequential computations on stored elements, updates related state arrays, and finalizes results before returning.",
    "work_score": {
        "decom": {
            "summary": "Resets multiple global data slots, processes them with given parameters, and performs final aggregated computation using auxiliary processing functions.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about resetting global data slots, processing with parameters, and performing aggregated computation do not match the source code semantics. The code deletes various mutexes, locks, and spinlocks, with no evidence of slot resets, parameter-based processing, or final aggregation. All claims are inaccurate as they fail to describe the actual function behavior.",
                "The summary's claims about resetting global data slots, processing them with parameters, and performing aggregated computation do not align with the source code, which terminates by deleting ACPI mutexes, spinlocks, and locks. The core purpose of removing synchronization primitives is entirely absent, and no accurate domain-specific details match the actual function behavior. The summary is generic and inaccurate in relation to the code.",
                "The summary's claims about resetting global data slots, processing with parameters, and performing aggregated computation do not match the source code, which is focused on deleting mutexes, locks, and a reader/writer lock. These inaccuracies are severe because they misstate the primary purpose of the function, leading to a misleading understanding of its core domain action. No accurate claims are present, making the net benefit unusable."
            ]
        },
        "cfg": {
            "summary": "Processes and clears multiple data buffers, performs sequential computations on stored elements, updates related state arrays, and finalizes results before returning.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes processing data buffers, sequential computations, and updating state arrays, none of which are reflected in the source code. The function actually deletes mutexes, spinlocks, and locks without performing computations or handling data buffers. All claims in the summary are inaccurate and unrelated to the actual semantics of the code, resulting in a complete mismatch.",
                "The summary's claims about processing data buffers, sequential computations, updating arrays, and finalizing results do not match the source code, which deletes mutexes, spinlocks, and locks to terminate synchronization resources. None of the claims accurately reflect the core purpose or any secondary behaviors present in the function.",
                "The summary claims the function processes and clears data buffers, performs sequential computations on stored elements, updates state arrays, and finalizes results, which are all inaccurate in relation to the source code. The actual function deletes predefined mutex objects, various locks, and a reader/writer lock as part of ACPI termination, with no data buffer processing or computations. These are severe mismatches about the primary purpose and core behavior, making them FATAL errors."
            ]
        },
        "comment": {
            "summary": "Terminates and deletes all predefined mutex objects, spinlocks, and a reader/writer lock to clean up synchronization mechanisms.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function terminates and deletes predefined mutex objects, spinlocks, and a reader/writer lock, which matches the code's deletion of mutexes in a loop, multiple spinlocks, and a single reader/writer lock. All claims are accurate and align with the source code behavior, with no extraneous or incorrect details.",
                "The summary correctly states the core purpose of the function: terminating and deleting predefined mutex objects, spinlocks, and a reader/writer lock, which matches the domain-specific synchronization cleanup seen in the source code. However, it omits secondary details such as deletion of the global OSI mutex, specific lock names (GPE, hardware, reference count), and the use of ACPI-specific deletion functions, meaning coverage of secondary behavior-critical semantics is incomplete.",
                "The summary correctly states the core purpose of the function: terminating and deleting predefined mutex objects, spinlocks, and a reader/writer lock. These are directly supported by the source code\u2019s calls to delete each mutex in the loop, specific spinlock deletions, and the reader/writer lock deletion. The description is accurate, targets code semantics, and has no contradictory or irrelevant claims. It is concise but provides the primary domain-specific behavior with minimal noise, though it lacks some detail of the exact mutex types or sequence, limiting informational gain."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4205360,
    "strip_function_name": "sub_402B30",
    "strip_decompiled_code": "__int64 __fastcall sub_402B30(const char *a1, __int64 a2, _BYTE *a3)\n{\n  FILE *v4; // rbx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  unsigned int v7; // r12d\n  const char *v9; // rbp\n  int *v10; // rax\n  __int64 v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  const char *v14; // rbx\n  int *v15; // rax\n  int *v16; // rax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int *v19; // rbx\n  const char *v20; // rax\n\n  *a3 = 0;\n  if ( !strcmp(a1, \"-\") )\n  {\n    v4 = stdin;\n    byte_60D2F0 = 1;\n    sub_4061E0(stdin, 2LL);\n    if ( !(unsigned int)sub_405F50(v4) )\n      return 1;\n  }\n  else\n  {\n    v11 = sub_406210(a1, 4234863LL);\n    v4 = (FILE *)v11;\n    if ( !v11 )\n    {\n      v7 = (unsigned __int8)byte_60D2DA;\n      v16 = __errno_location();\n      v19 = v16;\n      if ( (_BYTE)v7 && *v16 == 2 )\n      {\n        *a3 = 1;\n      }\n      else\n      {\n        v20 = (const char *)sub_407D50(0LL, 3LL, a1, v17, v18);\n        v7 = 0;\n        error(0, *v19, \"%s\", v20);\n      }\n      return v7;\n    }\n    sub_4061E0(v11, 2LL);\n    if ( !(unsigned int)sub_405F50(v4) )\n    {\n      if ( (unsigned int)sub_408730(v4) )\n      {\n        v14 = (const char *)sub_407D50(0LL, 3LL, a1, v12, v13);\n        v7 = 0;\n        v15 = __errno_location();\n        error(0, *v15, \"%s\", v14);\n        return v7;\n      }\n      return 1;\n    }\n  }\n  v9 = (const char *)sub_407D50(0LL, 3LL, a1, v5, v6);\n  v7 = 0;\n  v10 = __errno_location();\n  error(0, *v10, \"%s\", v9);\n  if ( stdin == v4 )\n    return v7;\n  sub_408730(v4);\n  return 0LL;\n}\n",
    "function_name": "digest_file",
    "decompiled_code": "_BOOL8 __fastcall digest_file(FILE *filename, char *binary, unsigned __int8 *bin_result, bool *missing)\n{\n  FILE *v5; // rbx\n  _BOOL4 v6; // r12d\n  char *v8; // rbp\n  int *v9; // rax\n  FILE *v10; // rax\n  char *v11; // rbx\n  int *v12; // rax\n  int *v13; // rax\n  int *v14; // rbx\n  char *v15; // rax\n\n  *bin_result = 0;\n  if ( !strcmp((const char *)filename, prefix) )\n  {\n    v5 = stdin;\n    have_read_stdin = 1;\n    fadvise(stdin, FADVISE_SEQUENTIAL);\n    if ( !(unsigned int)sha256_stream(v5, binary) )\n      return 1;\n  }\n  else\n  {\n    v10 = fopen_safer((const char *)filename, &command_name[165]);\n    v5 = v10;\n    if ( !v10 )\n    {\n      v6 = ignore_missing;\n      v13 = __errno_location();\n      v14 = v13;\n      if ( v6 && *v13 == 2 )\n      {\n        *bin_result = 1;\n      }\n      else\n      {\n        v15 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n        v6 = 0;\n        error(0, *v14, format, v15);\n      }\n      return v6;\n    }\n    fadvise(v10, FADVISE_SEQUENTIAL);\n    if ( !(unsigned int)sha256_stream(v5, binary) )\n    {\n      if ( rpl_fclose(v5) )\n      {\n        v11 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n        v6 = 0;\n        v12 = __errno_location();\n        error(0, *v12, format, v11);\n        return v6;\n      }\n      return 1;\n    }\n  }\n  v8 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n  v6 = 0;\n  v9 = __errno_location();\n  error(0, *v9, format, v8);\n  if ( stdin == v5 )\n    return v6;\n  rpl_fclose(v5);\n  return 0LL;\n}\n",
    "source_code": "\nstatic bool\ndigest_file (const char *filename, int *binary, unsigned char *bin_result,\n             bool *missing)\n{\n  FILE *fp;\n  int err;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  *missing = false;\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fp = stdin;\n      if (O_BINARY && *binary)\n        {\n          if (*binary < 0)\n            *binary = ! isatty (STDIN_FILENO);\n          if (*binary)\n            xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n    }\n  else\n    {\n      fp = fopen (filename, (O_BINARY && *binary ? \"rb\" : \"r\"));\n      if (fp == NULL)\n        {\n          if (ignore_missing && errno == ENOENT)\n            {\n              *missing = true;\n              return true;\n            }\n          error (0, errno, \"%s\", quotef (filename));\n          return false;\n        }\n    }\n\n  fadvise (fp, FADVISE_SEQUENTIAL);\n\n#if HASH_ALGO_BLAKE2\n  err = DIGEST_STREAM (fp, bin_result, b2_length / 8);\n#else\n  err = DIGEST_STREAM (fp, bin_result);\n#endif\n  if (err)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      if (fp != stdin)\n        fclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return true;\n}",
    "comment": "Calculates a digest of the specified file or standard input, handling binary mode and error management for file operations.",
    "hext5_sum": "| prints the field provided by field. | '",
    "bint5_sum": "Calculates the CRC checksum of a file or standard input and prints the checksum along with the file size .\n",
    "cpbcs_sum": "Opens a file for reading or writing, handling standard input or output based on the provided command, and manages errors accordingly.\n",
    "misum_sum": "Opens a file for reading, processes the appropriate drive based on 'must_exist', and handles interruptions and drive errors.\n",
    "decom_sum": "Opens the specified file or stdin, processes its contents, and reports errors, setting a flag if the file is missing.",
    "cfg_sum": "Opens the specified file or reads from stdin, validates the stream, reports errors, and returns a status indicating success or specific conditions.",
    "work_score": {
        "decom": {
            "summary": "Opens the specified file or stdin, processes its contents, and reports errors, setting a flag if the file is missing.",
            "score": [
                1.0,
                0.4,
                0.6
            ],
            "reason": [
                "The summary contains three atomic claims: opening a specified file or stdin, processing its contents, and setting a flag if the file is missing while reporting errors. All are accurate: the code handles stdin or file opening logic, uses DIGEST_STREAM to process contents, sets *missing to true for ignored missing files, and calls error() when problems occur. There are no inaccuracies or irrelevant statements, and all claims correctly reflect the source code's semantics.",
                "The summary correctly states that the function can open a file or stdin, processes the contents, reports errors, and sets a missing flag when the file is absent, which are all accurate. However, it omits the core purpose: computing a digest of the file's contents into a binary result using DIGEST_STREAM, including handling binary mode logic, ignore_missing behavior, and sequential read advice. These key domain-specific details are missing, resulting in weak coverage beyond generic file processing.",
                "The summary accurately captures the core behavior: opening a given file or stdin, processing its contents via a digest operation, reporting errors, and setting the missing flag if the file is not found. No contradictory claims exist, and all statements refer directly to the code semantics. However, the description is generic and lacks detail about binary mode handling, specific function calls, or conditional logic, yielding a low informational gain despite absence of noise."
            ]
        },
        "cfg": {
            "summary": "Opens the specified file or reads from stdin, validates the stream, reports errors, and returns a status indicating success or specific conditions.",
            "score": [
                0.6,
                0.2,
                0.5
            ],
            "reason": [
                "The summary contains several fact-based claims: opening a file or reading from stdin [ACCURATE], validating the stream [INACCURATE, as the code does not perform validation beyond checking for errors], reporting errors [ACCURATE], and returning a status indicating success or specific conditions [ACCURATE, as it reflects success or the 'missing' condition]. Three out of four claims are accurate, which is 75%, placing it in the mixed reliability range.",
                "The summary accurately notes opening a file or reading from stdin, reporting errors, and returning status, which are present in the code. However, it omits the core primary purpose of computing a digest from the file or stdin stream, which is the central domain-specific action. It also lacks mention of secondary details such as binary mode handling, missing file flag setting, sequential read advice, and conditional digest length for BLAKE2. As a result, the core functionality is not covered and secondary coverage is minimal.",
                "The summary correctly notes that the function can read from stdin or open a specified file, handles error reporting, and returns a status, which are accurate and aligned with the source code. However, 'validates the stream' is vague and does not specifically match any verification logic in the code beyond error checks, thus adding slight noise. No fatal inaccuracies are present and the accurate claims are mostly generic, offering low informational gain."
            ]
        },
        "comment": {
            "summary": "Calculates a digest of the specified file or standard input, handling binary mode and error management for file operations.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary contains two main claims: that the function calculates a digest of a specified file or standard input, and that it handles binary mode and error management for file operations. Both claims are accurate according to the source code: the function uses DIGEST_STREAM to compute a digest from either stdin or an opened file, and it includes logic to manage binary mode settings and robust error handling for opening, reading, and closing the file. There are no inaccurate or irrelevant statements, making the precision of claims very high.",
                "The summary correctly identifies the core purpose of computing a digest from a file or standard input, which aligns with the function\u2019s primary domain action. It also notes binary mode handling and error management, both present in the source. However, it omits other significant details such as handling missing files when ignore_missing is set, using sequential access hints (fadvise), specific handling for stdin with isatty checks, and the conditional use of BLAKE2 digest length. These omissions limit coverage of secondary behavior-critical semantics.",
                "The summary correctly captures the primary purpose of the function: computing a digest for a file or standard input, managing binary mode, and handling file operation errors, all of which are reflected in the source code. The claims are accurate but generic, providing minimal detail about how these behaviors are implemented (e.g., conditions for binary mode, missing file handling, specific digest call). There is no inaccurate or noisy content, but the gain is low due to lack of specificity."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580813104,
    "strip_function_name": "sub_FFFFFFFF811E0730",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811E0730(__int64 a1, __int64 a2)\n{\n  int v2; // ebx\n  __int64 v3; // r13\n  __int64 result; // rax\n  __int64 v5; // rax\n  int v6; // eax\n  int v7; // [rsp+4h] [rbp-34h]\n  _DWORD v8[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v2 = *(unsigned __int8 *)(a1 + 100);\n  v3 = *(_QWORD *)(a1 + 8);\n  if ( !(_BYTE)v2 )\n    BUG();\n  result = (unsigned int)*(unsigned __int8 *)(v3 + 20) + 1;\n  if ( v2 <= (int)result )\n  {\n    while ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 4LL * v2 + 80) )\n    {\n      if ( ++v2 > (int)result )\n        return result;\n    }\n    v5 = sub_FFFFFFFF811DBE20(a2, v2, v8);\n    if ( !v5 )\n      BUG();\n    v7 = v8[0];\n    v6 = sub_FFFFFFFF812BE6B0(v5 & 0xFFFFFFFFFFFFFFF8LL, (int)(8 * (v5 & 7) + v8[0]), 8 * (unsigned int)(v5 & 7))\n       - 8 * (v5 & 7);\n    if ( v6 > v7 )\n      v6 = v7;\n    if ( v8[0] <= v6 )\n      BUG();\n    ++*(_WORD *)(a1 + 90);\n    *(_DWORD *)(a1 + 60) = 1 << v2;\n    *(_DWORD *)(a1 + 52) = v6 << v2;\n    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 52);\n    sub_FFFFFFFF811E0350(a1, a2);\n    if ( *(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 44) )\n      BUG();\n    result = *(_QWORD *)(v3 + 848);\n    if ( *(_DWORD *)(result + 700) )\n      _InterlockedIncrement((volatile signed __int32 *)(result + 760));\n  }\n  return result;\n}\n",
    "function_name": "ext4_mb_simple_scan_group",
    "decompiled_code": "__int64 __fastcall ext4_mb_simple_scan_group(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  int v10; // ebx\n  __int64 v11; // r13\n  __int64 result; // rax\n  __int64 buddy; // rax\n  int v14; // eax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  int v17; // [rsp+4h] [rbp-34h]\n  _DWORD v18[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v10 = *(unsigned __int8 *)(a1 + 100);\n  v11 = *(_QWORD *)(a1 + 8);\n  if ( !(_BYTE)v10 )\n    BUG();\n  result = (unsigned int)*(unsigned __int8 *)(v11 + 20) + 1;\n  if ( v10 <= (int)result )\n  {\n    while ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 4LL * v10 + 80) )\n    {\n      if ( ++v10 > (int)result )\n        return result;\n    }\n    buddy = mb_find_buddy(a2, v10, v18);\n    if ( !buddy )\n      BUG();\n    v17 = v18[0];\n    v14 = find_next_zero_bit(\n            buddy & 0xFFFFFFFFFFFFFFF8LL,\n            (int)(8 * (buddy & 7) + v18[0]),\n            8 * (unsigned int)(buddy & 7))\n        - 8 * (buddy & 7);\n    if ( v14 > v17 )\n      v14 = v17;\n    if ( v18[0] <= v14 )\n      BUG();\n    ++*(_WORD *)(a1 + 90);\n    *(_DWORD *)(a1 + 60) = 1 << v10;\n    *(_DWORD *)(a1 + 52) = v14 << v10;\n    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 52);\n    ext4_mb_use_best_found(a1, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n    if ( *(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 44) )\n      BUG();\n    result = *(_QWORD *)(v11 + 848);\n    if ( *(_DWORD *)(result + 700) )\n      _InterlockedIncrement((volatile signed __int32 *)(result + 760));\n  }\n  return result;\n}\n",
    "source_code": "static noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}",
    "comment": "Scans the buddy system for free blocks, updates allocation context, and records statistics for memory management in an ext4 filesystem.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a new extended file attribute entry to an ext4 filesystem , ensuring it does not already exist and updating its metadata accordingly .\n",
    "cpbcs_sum": "Displays the total transaction ID in an ext4 filesystem by iterating through its bitmap and checking for the associated bitmap and space errors.\n",
    "misum_sum": "Updates the writes revoke values of free blocks in an ext4 filesystem by checking their lengths and ensuring the bitmap is not exceed the limit.\n",
    "decom_sum": "Updates device register values based on indexed configuration data, validates retrieved parameters, and increments a counter when specific hardware status conditions are met.",
    "cfg_sum": "Validates indexed data from two structures, processes it through helper routines, updates state fields, and increments counters, halting on any validation failure.",
    "work_score": {
        "decom": {
            "summary": "Updates device register values based on indexed configuration data, validates retrieved parameters, and increments a counter when specific hardware status conditions are met.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes operations involving device registers, indexed configuration data, and hardware status checks, which are unrelated to the actual code. The source code deals with scanning block groups in an ext4 filesystem, finding free blocks, and updating allocation context parameters. None of the claims align with the function's semantics, making all claims inaccurate.",
                "The summary describes operations involving hardware registers, configuration data, and device status counters, which do not align with the actual source code\u2019s purpose of scanning an ext4 block group for available free blocks using buddy allocator functions, updating allocation context, and tracking statistics. None of the claims accurately reflect the core domain behavior or secondary semantics of the code, making the coverage of the core purpose nonexistent.",
                "The summary makes multiple domain-specific claims about updating device register values, validating parameters, and interacting with hardware status, none of which align with the source code. The function in the source code scans a block group for available space in the ext4 filesystem, sets allocation extents, and updates allocation statistics; it does not handle device registers or hardware status. These are FATAL inaccuracies targeting the primary purpose and key side effects, rendering the summary unusable."
            ]
        },
        "cfg": {
            "summary": "Validates indexed data from two structures, processes it through helper routines, updates state fields, and increments counters, halting on any validation failure.",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary captures some general aspects like using data from two structures, calling helper routines, updating state, and incrementing counters, which align loosely with the function's loop over grp->bb_counters, use of mb_find_buddy and ext4_mb_use_best_found, and atomic_inc. However, several important and specific behaviors in the source code are omitted or oversimplified. For example, it fails to mention iteration bounds, specific bit and buddy-finding logic, the use of BUG_ON checks tied to certain conditions, and the selection/break logic after a match is found. It also describes 'halting on any validation failure' generically without accurately representing the precise BUG_ON triggers. Overall, while more than half of the claims are broadly accurate, they are generic and lack specificity, leading to mixed precision.",
                "The summary provides only a vague, generic description of validation, helper processing, state updates, and counter increments, which could apply to many functions. It does not explicitly cover the core purpose of scanning an ext4 block group for a suitable free extent using buddy information. While elements like state field updates and counter increments are correct in a general sense, the absence of domain-specific ext4 scanning details means the core functionality is not covered, and secondary coverage is minimal.",
                "The summary provides a generic description of validation, processing via helpers, state updates, and counter increments, which loosely matches the code's loop and BUG_ON checks, use of helper functions, and atomic counter increment. However, it omits critical specifics such as the search for free blocks, calculation of lengths and starts based on bit shifts, and explicit conditions in the loop. The claims are broadly accurate but are low\u2011information boilerplate, with no clear factual errors about the core purpose, resulting in minimal insight for understanding the function\u2019s domain behavior."
            ]
        },
        "comment": {
            "summary": "Scans the buddy system for free blocks, updates allocation context, and records statistics for memory management in an ext4 filesystem.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function scans the buddy system for free blocks and updates the allocation context, which aligns with the loop logic, the use of mb_find_buddy, mb_find_next_zero_bit, and updating ac->ac_b_ex. It also notes recording statistics, which matches the conditional atomic_inc when s_mb_stats is true. However, 'memory management' is somewhat generic and does not explicitly tie to ext4 block allocation specifics. Overall, the majority of claims are accurate with minor lack of specificity.",
                "The summary correctly notes scanning the buddy system for free blocks, updating the allocation context, and recording statistics\u2014these align with the code's core purpose and behavior. The core action of scanning ext4 block group metadata to find and use the best free extent is covered, but secondary details such as handling specific orders, use of BUG_ON for error checks, breaking after finding a match, and setting extent parameters are omitted. The wording is slightly generic, lacking mention of extent size calculation, group assignment, and conditional statistic increment tied to s_mb_stats.",
                "The summary contains mostly accurate high-level claims: it correctly states that the function scans the buddy system for free blocks, updates the allocation context, and records statistics, which matches the loop and calls in the code. However, details are somewhat generic \u2014 it simplifies allocation context updates without mentioning the calculated length, start, and group, and it describes the statistics as for 'memory management' rather than the specific ext4 block allocator stats, which is slightly imprecise but not fatally incorrect. There is no major noise or contradiction, but gain is low due to lack of specific implementation details."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 855088,
    "strip_function_name": "gsl_linalg_cholesky_scale_apply",
    "strip_decompiled_code": "__int64 __fastcall gsl_linalg_cholesky_scale_apply(_QWORD *a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // r8\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // r10\n  __int64 v5; // r9\n  __int64 v6; // r11\n  __int64 v7; // rbx\n  double v8; // xmm1_8\n  double *v9; // rcx\n  unsigned __int64 v10; // rdx\n  double v11; // xmm0_8\n  __int64 v12; // rsi\n  double *v13; // rax\n\n  if ( *a1 == a1[1] )\n  {\n    v2 = *a2;\n    if ( *a2 == *a1 )\n    {\n      if ( v2 )\n      {\n        v3 = a2[1];\n        v4 = 0LL;\n        v5 = 8 * v3;\n        v6 = 8 * v3 + a2[2];\n        v7 = -8LL * v3;\n        do\n        {\n          v8 = *(double *)(v6 + v7);\n          if ( v2 > v4 )\n          {\n            v9 = (double *)v6;\n            v10 = v4;\n            v11 = *(double *)(v6 + v7);\n            v12 = 8LL * a1[2];\n            v13 = (double *)(a1[3] + v4 * (v12 + 8));\n            while ( 1 )\n            {\n              ++v10;\n              *v13 = v11 * v8 * *v13;\n              v13 = (double *)((char *)v13 + v12);\n              if ( v2 == v10 )\n                break;\n              v11 = *v9;\n              v9 = (double *)((char *)v9 + v5);\n            }\n          }\n          ++v4;\n          v6 += v5;\n        }\n        while ( v2 != v4 );\n      }\n      return 0LL;\n    }\n    else\n    {\n      gsl_error(\"S must have length N\", \"cholesky.c\", 425LL, 19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    gsl_error(\"A is not a square matrix\", \"cholesky.c\", 421LL, 20LL);\n    return 20LL;\n  }\n}\n",
    "function_name": "gsl_linalg_cholesky_scale_apply",
    "decompiled_code": "int __fastcall gsl_linalg_cholesky_scale_apply(gsl_matrix *A, const gsl_vector *S)\n{\n  size_t size; // r8\n  size_t stride; // rax\n  size_t v4; // r10\n  __int64 v5; // r9\n  double *v6; // r11\n  __int64 v7; // rbx\n  double v8; // xmm1_8\n  double *v9; // rcx\n  size_t v10; // rdx\n  double v11; // xmm0_8\n  size_t v12; // rsi\n  double *v13; // rax\n\n  if ( A->size1 == A->size2 )\n  {\n    size = S->size;\n    if ( S->size == A->size1 )\n    {\n      if ( size )\n      {\n        stride = S->stride;\n        v4 = 0LL;\n        v5 = 8 * stride;\n        v6 = &S->data[stride];\n        v7 = 0x1FFFFFFFFFFFFFFFLL * stride;\n        do\n        {\n          v8 = v6[v7];\n          if ( size > v4 )\n          {\n            v9 = v6;\n            v10 = v4;\n            v11 = v6[v7];\n            v12 = 8 * A->tda;\n            v13 = (double *)((char *)A->data + v4 * (v12 + 8));\n            while ( 1 )\n            {\n              ++v10;\n              *v13 = v11 * v8 * *v13;\n              v13 = (double *)((char *)v13 + v12);\n              if ( size == v10 )\n                break;\n              v11 = *v9;\n              v9 = (double *)((char *)v9 + v5);\n            }\n          }\n          ++v4;\n          v6 = (double *)((char *)v6 + v5);\n        }\n        while ( size != v4 );\n      }\n      return 0;\n    }\n    else\n    {\n      ((void (__fastcall *)(const char *, char *, __int64, __int64))gsl_error)(\n        \"S must have length N\",\n        \"cholesky.c\",\n        425LL,\n        19LL);\n      return 19;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, char *, __int64, __int64))gsl_error)(\n      \"A is not a square matrix\",\n      \"cholesky.c\",\n      421LL,\n      20LL);\n    return 20;\n  }\n}\n",
    "source_code": "\nint\ngsl_linalg_cholesky_scale_apply(gsl_matrix * A, const gsl_vector * S)\n{\n  const size_t M = A->size1;\n  const size_t N = A->size2;\n\n  if (M != N)\n    {\n      GSL_ERROR(\"A is not a square matrix\", GSL_ENOTSQR);\n    }\n  else if (N != S->size)\n    {\n      GSL_ERROR(\"S must have length N\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i, j;\n\n      /* compute: A <- diag(S) A diag(S) using lower triangle */\n      for (j = 0; j < N; ++j)\n        {\n          double sj = gsl_vector_get(S, j);\n\n          for (i = j; i < N; ++i)\n            {\n              double si = gsl_vector_get(S, i);\n              double *Aij = gsl_matrix_ptr(A, i, j);\n              *Aij *= si * sj;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "comment": "Scales the elements of square matrix A by the elements of vector S using diagonal multiplication in a Cholesky decomposition context.",
    "hext5_sum": "this function computes the 12-th order and 24-th order chebyshev approximations to f(x) on [a,b]",
    "bint5_sum": "Applies a scaling transformation to the Cholesky decomposition of matrix A and stores the result in vector S .\n",
    "cpbcs_sum": "Performs a symmetric matrix-vector multiplication based on vector size and vector x and the vector size while checking for normalization.\n",
    "misum_sum": "Multiplies matrices A and B, storing results in vector S, and optionally performing matrix V via matrix B for normalization.\n",
    "decom_sum": "Scales a square matrix in-place using Cholesky factor values after validating matrix dimensions and matching scale vector length.",
    "cfg_sum": "Validates matrix dimensions for Cholesky scaling, raises errors if mismatched, and applies scaling factors to the matrix elements when dimensions are correct.",
    "work_score": {
        "decom": {
            "summary": "Scales a square matrix in-place using Cholesky factor values after validating matrix dimensions and matching scale vector length.",
            "score": [
                0.6,
                0.3,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function scales a square matrix in-place and checks that matrix dimensions match the scale vector length, aligning with the source code's validation logic and scaling operation using diag(S) A diag(S). However, it inaccurately describes the scale values as coming from a Cholesky factor, which is not in the source code; the scaling uses the values directly from the given vector S. This incorrect claim reduces the overall accuracy despite otherwise correct elements.",
                "The summary correctly notes scaling a square matrix in-place and checking that the scale vector length matches the matrix dimensions, aligning with the source code's validation and scaling. However, it misstates the nature of the scaling values as 'Cholesky factor values'\u2014the code simply scales by elements from the provided vector S, not specifically Cholesky factors. This means the core purpose (performing diag(S) * A * diag(S) scaling) is only partially represented and contains inaccurate domain terminology, limiting coverage of the primary purpose and omitting secondary details like use of lower triangle and specific error handling codes.",
                "The summary correctly notes that the function scales a square matrix in-place and validates that the matrix is square with a matching vector length, which aligns with the source code. However, it inaccurately claims the scaling uses \"Cholesky factor values\"\u2014the source just scales by the given vector S without computing or using a Cholesky factor. This is a FATAL error affecting the primary purpose, as it misrepresents the core operation. Therefore, the net benefit is very low."
            ]
        },
        "cfg": {
            "summary": "Validates matrix dimensions for Cholesky scaling, raises errors if mismatched, and applies scaling factors to the matrix elements when dimensions are correct.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function validates matrix dimensions, raises errors on mismatches, and applies scaling factors to elements when dimensions are correct. These claims align with the code: it checks if the matrix is square, ensures the vector length matches, raises appropriate errors, and performs element-wise scaling using factors from the vector S. All described behavior directly matches the source code logic, with no inaccuracies or irrelevant content.",
                "The summary correctly describes dimension validation, error handling for mismatches, and applying scaling factors to matrix elements, which aligns with the source code's checks and scaling loop. It also conveys the core purpose of performing a Cholesky scaling via diag(S) A diag(S). However, it lacks detail about the lower-triangle-only operation and specific variable handling, limiting coverage of secondary behaviors.",
                "The summary correctly captures the core purpose: it validates matrix dimensions (square matrix, matching vector length) and applies scaling factors when valid. All claims align with the source code's behavior, including error handling and scaling logic. There is no inaccurate or noisy content; however, the description is somewhat generic and lacks specifics like the exact scaling formula (diag(S) A diag(S)) and the use of the lower triangle, limiting the informational gain."
            ]
        },
        "comment": {
            "summary": "Scales the elements of square matrix A by the elements of vector S using diagonal multiplication in a Cholesky decomposition context.",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function scales a square matrix A by elements from vector S via diagonal multiplication, which matches the source code\u2019s `diag(S) A diag(S)` operation. However, the mention of a 'Cholesky decomposition context' is unsupported and inaccurate, as the code does not perform or require a Cholesky decomposition. This introduces an incorrect semantic claim, reducing the proportion of accurate claims to roughly half.",
                "The summary captures the core action of scaling a square matrix A by the diagonal elements from vector S, which matches the source code\u2019s operation of applying diag(S) A diag(S) to the matrix. However, it omits key secondary details such as error handling for non-square matrices or mismatched vector size, the fact that only the lower triangle is processed, and the absence of actual Cholesky decomposition logic despite referencing it. Coverage of the core purpose is correct but secondary behavior is weak.",
                "The summary correctly states that the function scales the elements of a square matrix A by elements of vector S using diagonal multiplication, which matches the code's core operation of applying diag(S) A diag(S) to the lower triangle. However, it inaccurately adds 'in a Cholesky decomposition context,' which is not indicated anywhere in the source code, making this an incorrect domain-specific context claim. This is a FATAL error affecting the PRIMARY PURPOSE because it misleads about the function's intended mathematical context, reducing trust in the description."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581886368,
    "strip_function_name": "sub_FFFFFFFF812E67A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812E67A0(__int64 a1, unsigned __int64 *a2)\n{\n  __int64 v2; // rbx\n  __int64 v3; // r13\n  __int64 (__fastcall *v4)(__int64, unsigned __int64 *); // rax\n  __int64 v5; // rdi\n  unsigned int v6; // ebx\n  unsigned __int64 v8; // r13\n  __int64 v9; // r15\n  unsigned __int64 v10; // rcx\n  unsigned __int64 v11; // rax\n  __int64 v12; // rax\n  bool v13; // cc\n\n  v2 = qword_FFFFFFFF81CB8C60[*(_DWORD *)(*(_QWORD *)(a1 + 32) + 76LL) & 0xFFFFF];\n  if ( *(_QWORD *)(a1 + 168) != v2 )\n    return 4294967277LL;\n  if ( !v2 )\n    return 4294967277LL;\n  v3 = *(_QWORD *)(v2 + 688);\n  if ( !v3 )\n    return 4294967277LL;\n  sub_FFFFFFFF8178F210(v2 + 56);\n  v4 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *))(v3 + 152);\n  if ( v4 )\n  {\n    v5 = v2 + 56;\n    v6 = v4(v2, a2);\n    sub_FFFFFFFF8178F1B0(v5);\n    return v6;\n  }\n  v8 = *(_QWORD *)(v2 + 272);\n  v9 = *(unsigned int *)(v2 + 280);\n  v10 = a2[19];\n  v11 = (v9 + (v8 & 0xFFF) + 4095) >> 12;\n  if ( v11 <= v10 )\n  {\n    if ( *(_DWORD *)(v2 + 192) )\n    {\n      sub_FFFFFFFF8178F1B0(v2 + 56);\n      return 4294967274LL;\n    }\n    a2[19] = v10 - v11;\n    v9 = *(unsigned int *)(v2 + 320);\n    v8 = *(_QWORD *)(v2 + 312);\n  }\n  sub_FFFFFFFF8178F1B0(v2 + 56);\n  v12 = sub_FFFFFFFF811104A0(a2[10]);\n  v13 = (unsigned __int8)dword_FFFFFFFF81CB4E80 <= 3u;\n  a2[9] = v12;\n  if ( !v13 )\n    a2[9] |= 0x10uLL;\n  return sub_FFFFFFFF8110D910(a2, v8, v9);\n}\n",
    "function_name": "fb_mmap",
    "decompiled_code": "__int64 __fastcall fb_mmap(\n        __int64 a1,\n        unsigned __int64 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rbx\n  __int64 v11; // r13\n  __int64 (__fastcall *v12)(__int64, unsigned __int64 *); // rax\n  __int64 v13; // rdi\n  unsigned int v14; // ebx\n  unsigned __int64 v16; // r13\n  __int64 v17; // r15\n  unsigned __int64 v18; // rcx\n  unsigned __int64 v19; // rax\n  char *page_prot; // rax\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  bool v23; // cc\n\n  v10 = registered_fb[*(_DWORD *)(*(_QWORD *)(a1 + 32) + 76LL) & 0xFFFFF];\n  if ( *(_QWORD *)(a1 + 168) != v10 )\n    return 4294967277LL;\n  if ( !v10 )\n    return 4294967277LL;\n  v11 = *(_QWORD *)(v10 + 688);\n  if ( !v11 )\n    return 4294967277LL;\n  mutex_lock(v10 + 56);\n  v12 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *))(v11 + 152);\n  if ( v12 )\n  {\n    v13 = v10 + 56;\n    v14 = v12(v10, a2);\n    mutex_unlock(v13);\n    return v14;\n  }\n  v16 = *(_QWORD *)(v10 + 272);\n  v17 = *(unsigned int *)(v10 + 280);\n  v18 = a2[19];\n  v19 = (v17 + (v16 & 0xFFF) + 4095) >> 12;\n  if ( v19 <= v18 )\n  {\n    if ( *(_DWORD *)(v10 + 192) )\n    {\n      mutex_unlock(v10 + 56);\n      return 4294967274LL;\n    }\n    a2[19] = v18 - v19;\n    v17 = *(unsigned int *)(v10 + 320);\n    v16 = *(_QWORD *)(v10 + 312);\n  }\n  mutex_unlock(v10 + 56);\n  page_prot = vm_get_page_prot(a2[10]);\n  v23 = (unsigned __int8)boot_cpu_data <= 3u;\n  a2[9] = (unsigned __int64)page_prot;\n  if ( !v23 )\n    a2[9] |= 0x10uLL;\n  return vm_iomap_memory(a2, v16, v17, a3, a4, a5, a6, v21, v22, a9, a10);\n}\n",
    "source_code": "\nstatic int\nfb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}",
    "comment": "Maps the framebuffer or MMIO memory region into the process's address space based on the provided virtual memory area structure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Reads framebuffer memory from a video device into a user-provided buffer , ensuring proper alignment and handling potential errors .\n",
    "cpbcs_sum": "Updates the framebuffer compression position based on the virtual console size and cursor position while ensuring thread safety with a mutex lock.\n",
    "misum_sum": "Handles framebuffer blanking and rendering power settings for a virtual console if the console is active.\n",
    "decom_sum": "Validates a context against stored identifiers, adjusts memory quotas, and invokes a handler to process or transfer data for the associated object.",
    "cfg_sum": "Validates object and memory state, adjusts resource counters, updates status flags, and processes data before returning specific success or error codes.",
    "work_score": {
        "decom": {
            "summary": "Validates a context against stored identifiers, adjusts memory quotas, and invokes a handler to process or transfer data for the associated object.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims describe validating a context against identifiers, adjusting memory quotas, and invoking a handler for data transfer, none of which align with the fb_mmap function's actual behavior of mapping framebuffer or mmio memory regions, locking access, and delegating to fb_mmap ops if present. All claims are unrelated to the source code's semantics and therefore inaccurate.",
                "The summary's claims about validating context against stored identifiers, adjusting memory quotas, and invoking a handler to process or transfer data do not match the source code, which implements framebuffer memory mapping, optionally via a driver-specific mmap handler, and manages offsets for framebuffer and MMIO regions. The core purpose of mapping framebuffer or MMIO memory into a user space VM area is entirely absent, and none of the summary's claims are accurate to the code semantics. No secondary behavior like mutex locking, error handling, or page protection setup is covered.",
                "The summary contains only NOISE, describing validation of context, identifier checking, and data transfer\u2014none of which match the function\u2019s actual purpose of mapping framebuffer or MMIO memory in response to an mmap call. There are no accurate claims about the source code\u2019s key I/O or effects, and the mismatch covers the core domain behavior, making the description unusable for understanding the function."
            ]
        },
        "cfg": {
            "summary": "Validates object and memory state, adjusts resource counters, updates status flags, and processes data before returning specific success or error codes.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary is overly generic and does not specifically reflect the actual function behavior in the source code. It omits key semantics such as handling fb_mmap callback, differentiating between framebuffer and MMIO mapping, and adjusting vm_pgoff, which are central to the function. None of its claims directly match the code\u2019s precise logic, making them largely noise rather than accurate factual statements about the function.",
                "The summary contains only vague, generic statements about validation, resource counters, and status flags which are not reflected in the actual code. It misses the core purpose of mapping framebuffer or MMIO memory into a user-space VMA, and none of its claims align with the concrete domain semantics present in the source. No accurate coverage of the primary domain action or critical behaviors such as handling accel_flags, pgoff adjustments, locking, or specific error returns is provided.",
                "The summary contains predominantly inaccurate claims: it mentions adjusting resource counters and updating status flags, which are not present in the source code. The source primarily validates `info` and `fbops`, optionally calls a driver-specific mmap method, calculates offsets for framebuffer or MMIO, sets page protections, and maps memory. These actions are not captured accurately, making the summary mostly noise with no specific GOLD-level insights. There are no FATAL contradictions about the core purpose, but the inaccuracy significantly overwhelms accurate points."
            ]
        },
        "comment": {
            "summary": "Maps the framebuffer or MMIO memory region into the process's address space based on the provided virtual memory area structure.",
            "score": [
                1.0,
                0.4,
                0.6
            ],
            "reason": [
                "The summary\u2019s single claim correctly describes the core domain-specific behavior: mapping either the framebuffer or MMIO memory based on the virtual memory area structure. This aligns with the source code logic, which checks offsets to decide between smem and mmio mapping, sets protections, and calls vm_iomap_memory. There are no incorrect or irrelevant claims, and the description is accurate, though somewhat high-level.",
                "The summary correctly identifies the core purpose as mapping either the framebuffer or MMIO memory into a process address space based on the vma, which matches the function's main domain-specific behavior. However, it omits key secondary details such as checking for fb_info and fb_ops availability, handling a custom fb_mmap operation, accel_flags validation before MMIO mapping, mutex locking around critical sections, adjustments to vm_pgoff, setting page protections, and calling fb_pgprotect. The coverage of secondary behavior is minimal.",
                "The summary accurately states the core function's purpose: it maps either the framebuffer or MMIO region into a process\u2019s address space depending on the virtual memory area, which matches the source code\u2019s logic. There are no inaccurate claims, but the description is generic and omits key decision details (e.g., fallback to fb->fb_mmap, pgoff checks, accel_flags conditions). The gain is low as it provides only a broad overview without specifics, and noise is minimal."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582270352,
    "strip_function_name": "sub_FFFFFFFF81344390",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF81344390(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r13\n  __int64 v11; // rbx\n  unsigned int v12; // r12d\n  __int64 v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 **v16; // rbx\n  __int64 *v17; // r12\n  __int64 *v18; // rdx\n  __int64 v19; // rcx\n  int v20; // r8d\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  _QWORD v24[63]; // [rsp+0h] [rbp-210h]\n  __int64 v25; // [rsp+8h] [rbp-208h] BYREF\n  char v26; // [rsp+1F8h] [rbp-18h] BYREF\n\n  v10 = &unk_FFFFFFFF81E9F5C8;\n  v11 = 1LL;\n  v12 = 1;\n  sub_FFFFFFFF8103C680(a1);\n  do\n  {\n    v13 = *(_QWORD *)(*(_QWORD *)(qword_FFFFFFFF81E9F580 + 128) + v11 * 8);\n    if ( v13 && *(_DWORD *)(v13 + 400) || dword_FFFFFFFF81E9F594 == v12 || *v10 == qword_FFFFFFFF81E9F1F8 )\n    {\n      v24[v11] = 0LL;\n    }\n    else\n    {\n      a1 = v12;\n      v24[v11] = sub_FFFFFFFF81350630(v12);\n    }\n    ++v12;\n    ++v11;\n    v10 += 5;\n  }\n  while ( v12 != 63 );\n  sub_FFFFFFFF8103D500(a1);\n  v16 = (__int64 **)&v25;\n  do\n  {\n    v17 = *v16;\n    if ( *v16 )\n    {\n      sub_FFFFFFFF81341780(*v16, a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a3, a4, a5, a6, v22, v23, a9, a10, a2, v18, v19, v20, v21);\n    }\n    ++v16;\n  }\n  while ( v16 != (__int64 **)&v26 );\n}\n",
    "function_name": "vt_disallocate_all",
    "decompiled_code": "void __fastcall vt_disallocate_all(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r13\n  __int64 v11; // rbx\n  unsigned int v12; // r12d\n  __int64 v13; // rdx\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 **v19; // rbx\n  __int64 *v20; // r12\n  __int64 *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  _QWORD v24[63]; // [rsp+0h] [rbp-210h] BYREF\n  char v25; // [rsp+1F8h] [rbp-18h] BYREF\n\n  v10 = &unk_FFFFFFFF81E9F5C8;\n  v11 = 1LL;\n  v12 = 1;\n  console_lock(a1, a2);\n  do\n  {\n    v16 = *(_QWORD *)(*(_QWORD *)(console_driver + 128) + v11 * 8);\n    if ( v16 && *(_DWORD *)(v16 + 400) || fg_console == v12 || *v10 == sel_cons )\n      v24[v11] = 0LL;\n    else\n      v24[v11] = vc_deallocate(v12, a2, v13, a3, a4, a5, a6, v14, v15, a9, a10);\n    ++v12;\n    ++v11;\n    v10 += 5;\n  }\n  while ( v12 != 63 );\n  console_unlock(a3, a4, a5, a6, v14, v15, a9, a10);\n  v19 = (__int64 **)&v24[1];\n  do\n  {\n    v20 = *v19;\n    if ( *v19 )\n    {\n      tty_port_destroy(*v19, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n      kfree(v20, a3, a4, a5, a6, v22, v23, a9, a10, a2, v21);\n    }\n    ++v19;\n  }\n  while ( v19 != (__int64 **)&v25 );\n}\n",
    "source_code": "static void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!VT_BUSY(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES) {\n\t\t\ttty_port_destroy(&vc[i]->port);\n\t\t\tkfree(vc[i]);\n\t\t}\n\t}\n}",
    "comment": "Deallocates all virtual consoles that are not busy, destroying associated tty ports and freeing memory for those consoles.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases resources associated with a tty_driver , unregisters devices , and cleans up termios structures when the driver is no longer needed .\n",
    "cpbcs_sum": "Waits for all GPU firmware devices in the ACPI subsystem by reading their status registers and counting them to their respective controls.\n",
    "misum_sum": "Destroys the GPU cache by cleaning up resources, and decrementing the reference count of the framebuffer memory freeing associated resources.\n",
    "decom_sum": "Initializes a set of up to 62 objects, skipping invalid entries, and performs two sequential processing routines on each valid object.",
    "cfg_sum": "Processes a fixed set of entries, clears invalid ones, applies computations to valid entries, and invokes update routines with provided numeric parameters.",
    "work_score": {
        "decom": {
            "summary": "Initializes a set of up to 62 objects, skipping invalid entries, and performs two sequential processing routines on each valid object.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims initialization of up to 62 objects, skipping invalid entries, and applying two sequential processing routines. The source code instead iterates from index 1 to MAX_NR_CONSOLES, conditionally deallocates or sets entries to NULL, and later frees resources for certain indices. It does not explicitly initialize objects nor is the number 62 verifiable from the code. The 'two sequential processing routines' is a vague mischaracterization; while two loops exist, their operations don't match the summary's generic description. Most claims are inaccurate relative to the actual semantics.",
                "The summary does not describe the core purpose of freeing all non-busy virtual consoles and destroying associated tty ports. It inaccurately frames the function as initializing objects rather than deallocating them, and omits key behaviors like locking, checking VT_BUSY, handling MIN_NR_CONSOLES, and freeing memory. No accurate claim in the summary captures this domain-specific deallocation task.",
                "The summary incorrectly describes the function as initializing up to 62 objects and performing two routines on each, which contradicts the source code. The actual code deallocates console structures, not initializes them. The object count and 'skipping invalid entries' are imprecise relative to the code\u2019s iteration and VT_BUSY check, and the description omits key details about console locking, deallocation, and freeing memory. This is a FATAL error on the primary purpose of the function, resulting in severely misleading output."
            ]
        },
        "cfg": {
            "summary": "Processes a fixed set of entries, clears invalid ones, applies computations to valid entries, and invokes update routines with provided numeric parameters.",
            "score": [
                0.2,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about clearing invalid entries and applying computations with numeric parameters do not align with the source code, which focuses on locking a console array, deallocating non-busy entries, destroying tty ports, and freeing memory. Most claims are generic or inaccurate regarding the actual semantics, with little to no specific verifiable match to the function's operations.",
                "The summary makes generic statements about processing entries, clearing invalid ones, and applying computations, but it does not accurately reflect the core behavior of the code, which involves locking, iterating over console indices, deallocating unused virtual consoles, destroying associated tty ports, and freeing memory. No claim in the summary specifically covers deallocating consoles or handling their resources, and the described numeric parameter updates do not exist in the source code, making the core purpose absent and introducing inaccuracies.",
                "The summary's claims about processing entries, clearing invalid ones, applying computations, and invoking update routines do not align with the source code, which deallocates virtual console structures, destroys associated ports, and frees memory. These mismatches are FATAL as they misrepresent the primary purpose and core side effects. No accurate claims are present, resulting in zero usable benefit."
            ]
        },
        "comment": {
            "summary": "Deallocates all virtual consoles that are not busy, destroying associated tty ports and freeing memory for those consoles.",
            "score": [
                0.9,
                0.8,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function deallocates all virtual consoles that are not busy, destroys their associated tty ports, and frees memory, which matches the source code. While it omits details such as skipping index 0 and the check for MIN_NR_CONSOLES before destruction, the claims present are specific and accurate to the given code\u2019s semantics.",
                "The summary correctly identifies the core purpose of the function \u2014 deallocating virtual consoles that are not busy \u2014 and includes key secondary details such as destroying associated tty ports and freeing memory. It aligns with the source code's main loop behavior and object cleanup. However, it omits specific operational details like the use of console_lock/console_unlock and the condition that destruction occurs only for consoles with an index above MIN_NR_CONSOLES, which are important behavior-critical semantics.",
                "The summary correctly captures the core behavior of the function: it targets virtual consoles, checks for busy state, and for those not busy, destroys their associated tty ports and frees their memory. These are highly specific and verifiable details aligned with the source code, with no inaccuracies or unrelated noise. The claims are GOLD-level, describing the primary purpose, key side effects, and I/O contract accurately, resulting in strong net benefit."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6104481,
    "strip_function_name": "sub_5D25A1",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_5D25A1(\n        _BYTE *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  int *v16; // rax\n  const __m128i *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  _QWORD v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = &a15;\n  v21[2] = &v22;\n  v16 = (int *)sub_4B60D0();\n  v17 = (const __m128i *)sub_4BABE0(*v16);\n  return sub_5176F5(\n           a1,\n           v21,\n           v17,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           v18,\n           v19,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "function_name": "bb_herror_msg",
    "decompiled_code": "unsigned __int64 __fastcall bb_herror_msg(\n        const __m128i *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  int *v16; // rax\n  const __m128i *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = (__int64)&a15;\n  v21[2] = (__int64)&v22;\n  v16 = (int *)_h_errno_location();\n  v17 = (const __m128i *)hstrerror(*v16);\n  return bb_verror_msg(\n           a1,\n           v21,\n           v17,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           v18,\n           v19,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "source_code": "\nvoid FAST_FUNC bb_herror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\tbb_verror_msg(s, p, hstrerror(h_errno));\n\tva_end(p);\n}",
    "comment": "Formats and displays an error message using a variable argument list and the current error description from `hstrerror(h_errno)`.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Logs an error message formatted with the provided string and arguments , retrieves the error description using ` hstrerror ` , and terminates the program .\n",
    "cpbcs_sum": "Formats an error message using a variable argument list and arguments, retrieves the error description using `hstrerror`, and terminates the program.\n",
    "misum_sum": "Logs an error message formatted with a variable argument list using a variable argument list and variable arguments.\n",
    "decom_sum": "Prepares transformation parameters and SIMD vectors, retrieves a configuration object, and performs a double-precision vector computation with the given byte buffer.",
    "cfg_sum": "Prepares processor and SIMD state, retrieves configuration data, and calls a computation routine with stored parameters to produce a final result code.",
    "work_score": {
        "decom": {
            "summary": "Prepares transformation parameters and SIMD vectors, retrieves a configuration object, and performs a double-precision vector computation with the given byte buffer.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary describes operations involving transformation parameters, SIMD vectors, configuration retrieval, and double-precision computation, none of which align with the source code's actual behavior of formatting and printing an error message using variadic arguments and hstrerror. All extracted claims are inaccurate as they do not target the function's true semantics.",
                "The summary describes operations related to SIMD vector computation, configuration retrieval, and byte buffer processing, which are unrelated to the actual code. The source code defines a function that formats and displays an error message using variable arguments and network-related error strings. No accurate claims about the core purpose or behavior of the function are present, so the core is not covered and all claims are inaccurate.",
                "The summary makes multiple claims about preparing transformation parameters, using SIMD vectors, retrieving a configuration object, and performing double-precision vector computations. None of these describe the actual source code, which initializes a variadic argument list and calls an error message function using herrno. All claims are [INACCURATE] and constitute pure noise, with no accurate mapping to the core domain action, resulting in zero net benefit."
            ]
        },
        "cfg": {
            "summary": "Prepares processor and SIMD state, retrieves configuration data, and calls a computation routine with stored parameters to produce a final result code.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary's claims about preparing processor and SIMD state, retrieving configuration data, and calling a computation routine are unrelated to the actual function, which processes variable arguments and calls an error message routine using network error strings. None of the claims align with the source code semantics, resulting in no accurate matches.",
                "The summary's claims about preparing processor/SIMD state, retrieving configuration data, and calling a computation routine are unrelated to the actual function, which formats and displays a network-related error message using variadic arguments and hstrerror. None of the claims accurately cover the core purpose, and there is no mention of the specific domain behavior or any secondary semantics from the source code.",
                "The summary contains only inaccurate claims (NOISE) unrelated to the actual code. The source function initializes a variadic argument list, retrieves an error string from h_errno via hstrerror, and calls bb_verror_msg with these parameters. It does not prepare processor/SIMD state, retrieve configuration data, or call a computation routine. There are no accurate or specific GOLD/SAFE claims, and noise is overwhelming with no net benefit."
            ]
        },
        "comment": {
            "summary": "Formats and displays an error message using a variable argument list and the current error description from `hstrerror(h_errno)`.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function formats and displays an error message using a variable argument list and includes the current error description from `hstrerror(h_errno)`. These are accurate and specific reflections of the source code behavior, with no contradictory or irrelevant claims.",
                "The summary correctly identifies that the function formats and displays an error message using a variable argument list and incorporates the description from hstrerror(h_errno), which matches the core purpose of wrapping bb_verror_msg with these arguments. However, it omits secondary details such as using va_start/va_end to manage the varargs and passing them specifically to bb_verror_msg, resulting in incomplete coverage of implementation specifics beyond the core action.",
                "The summary claims that the function formats and displays an error message using a variable argument list and the current error description from `hstrerror(h_errno)`, which aligns with the source code. It correctly identifies the use of `va_list` (`va_start`, `va_end`), the passing of these arguments to `bb_verror_msg`, and the retrieval of the error description via `hstrerror(h_errno)`. No inaccuracies or unrelated noise are present, but while accurate, the description is relatively concise and lacks deeper detail about the underlying formatting behavior or role of `bb_verror_msg`, making the gain moderate rather than high."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580570544,
    "strip_function_name": "sub_FFFFFFFF811A53B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811A53B0(\n        __int64 a1,\n        __int64 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  volatile signed __int32 *v10; // rax\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 **v17; // rbx\n  __int64 v18; // r14\n  volatile signed __int32 *v19; // r13\n  __int64 *v20; // rsi\n  unsigned int v21; // eax\n  unsigned int v22; // r12d\n  __int64 v24; // r14\n\n  v10 = sub_FFFFFFFF811A37C0(*(_QWORD *)(a1 + 48), 0LL, *a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( v10 )\n  {\n    v17 = (__int64 **)a2[2];\n    v18 = 0LL;\n    v19 = v10;\n    v20 = *v17;\n    if ( *v17 )\n    {\n      while ( 1 )\n      {\n        ++v17;\n        v21 = sub_FFFFFFFF811A2860((__int64)v19, (__int64)v20, 2u, a3, a4, a5, a6, v15, v16, a9, a10);\n        v20 = *v17;\n        v22 = v21;\n        if ( !*v17 )\n          break;\n        if ( v21 )\n          goto LABEL_12;\n        v18 = (int)v18 + 1;\n      }\n      if ( !v21 )\n        goto LABEL_8;\nLABEL_12:\n      if ( (int)v18 >= 0 )\n      {\n        v24 = (__int64)&v17[-v18 - 1];\n        do\n        {\n          --v17;\n          v20 = 0LL;\n          sub_FFFFFFFF811A19E0((__int64)v19, 0LL, **v17, a3, a4, a5, a6, v15, v16, a9, a10);\n        }\n        while ( (__int64 **)v24 != v17 );\n      }\n    }\n    else\n    {\nLABEL_8:\n      v22 = 0;\n    }\n    if ( !_InterlockedDecrement(v19) )\n      sub_FFFFFFFF811A2C80((unsigned __int64)v19, (__int64)v20, v11, v12, v13, v14, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  else\n  {\n    return (unsigned int)-2;\n  }\n  return v22;\n}\n",
    "function_name": "sysfs_merge_group",
    "decompiled_code": "__int64 __fastcall sysfs_merge_group(\n        __int64 a1,\n        unsigned __int8 **a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  volatile signed __int32 *dirent; // rax\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 **v17; // rbx\n  __int64 v18; // r14\n  volatile signed __int32 *v19; // r13\n  __int64 *v20; // rsi\n  unsigned int v21; // eax\n  unsigned int v22; // r12d\n  __int64 v24; // r14\n\n  dirent = sysfs_get_dirent(*(_QWORD *)(a1 + 48), 0LL, *a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( dirent )\n  {\n    v17 = (__int64 **)a2[2];\n    v18 = 0LL;\n    v19 = dirent;\n    v20 = *v17;\n    if ( *v17 )\n    {\n      while ( 1 )\n      {\n        ++v17;\n        v21 = sysfs_add_file((__int64)v19, (__int64)v20, 2, a3, a4, a5, a6, v15, v16, a9, a10);\n        v20 = *v17;\n        v22 = v21;\n        if ( !*v17 )\n          break;\n        if ( v21 )\n          goto LABEL_12;\n        v18 = (int)v18 + 1;\n      }\n      if ( !v21 )\n        goto LABEL_8;\nLABEL_12:\n      if ( (int)v18 >= 0 )\n      {\n        v24 = (__int64)&v17[-v18 - 1];\n        do\n        {\n          --v17;\n          v20 = 0LL;\n          sysfs_hash_and_remove((__int64)v19, 0LL, **v17, a3, a4, a5, a6, v15, v16, a9, a10);\n        }\n        while ( (__int64 **)v24 != v17 );\n      }\n    }\n    else\n    {\nLABEL_8:\n      v22 = 0;\n    }\n    if ( !_InterlockedDecrement(v19) )\n      release_sysfs_dirent((__int64)v19, (__int64)v20, v11, v12, v13, v14, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  else\n  {\n    return (unsigned int)-2;\n  }\n  return v22;\n}\n",
    "source_code": "int sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct sysfs_dirent *dir_sd;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tdir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);\n\tif (!dir_sd)\n\t\treturn -ENOENT;\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tsysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);\n\t}\n\tsysfs_put(dir_sd);\n\n\treturn error;\n}",
    "comment": "Merges a specified attribute group into a kobject's sysfs directory, adding attributes and handling errors by removing any added attributes on failure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Adds a symbolic link to a specified group in a sysfs directory , linking to a target kobject with the given link name .\n",
    "cpbcs_sum": "Attempts to merge a specified number of pages in the sysfs filesystem, verifying access for any necessary adjustments before returning the result.\n",
    "misum_sum": "Retrieves file attributes for a specified kernel object by copying data to user space, handling memory allocation and error conditions.\n",
    "decom_sum": "Processes a list of items by validating each entry, performing rollback on failure, and releasing resources, returning the final validation status.",
    "cfg_sum": "Processes a list of resource handlers, invokes necessary actions on matching entries, decrements reference count, cleans up, and returns the operation status code.",
    "work_score": {
        "decom": {
            "summary": "Processes a list of items by validating each entry, performing rollback on failure, and releasing resources, returning the final validation status.",
            "score": [
                0.5,
                0.3,
                0.5
            ],
            "reason": [
                "The summary makes generic claims about processing a list and validating entries, which loosely align with iterating over attributes and checking for errors in the code. However, the terms used are vague\u2014'validating each entry' does not explicitly match the code\u2019s creation of sysfs files, and 'releasing resources' is correct but nonspecific. The lack of mention of core domain-specific behaviors (handling sysfs attribute groups, rollback via sysfs_hash_and_remove) and presence of generic phrasing reduce precision, with roughly half of the claims aligning accurately.",
                "The summary describes generic processing of a list with validation, rollback, and resource release, which loosely matches the loop, error handling, and cleanup in the code. However, it does not convey the core purpose of merging an attribute group into a sysfs directory and adding files, missing specific domain semantics. Secondary behaviors like error rollback and resource release are covered in a generic way but without the sysfs context, making coverage of core and critical details weak.",
                "The summary contains generic statements about processing items, validation, rollback, and resource release that loosely resemble the code but lack specificity about the actual domain semantics, such as operating on sysfs attribute groups linked to a kobject. These claims are broadly accurate at a procedural level but are SAFE and low-info, with no FATAL errors since the high-level description matches the control flow. However, the absence of detailed GOLD claims results in low net benefit, as the summary omits key domain-specific details tied to the function\u2019s primary purpose."
            ]
        },
        "cfg": {
            "summary": "Processes a list of resource handlers, invokes necessary actions on matching entries, decrements reference count, cleans up, and returns the operation status code.",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly inaccurate claims when compared to the source code. It incorrectly describes processing a list of resource handlers and matching entries, which do not appear in the function. The actual function merges sysfs attribute groups by iterating over attributes, adding files, possibly removing them on error, putting the dirent, and returning an error code. Only the part about returning the operation status code aligns with the implementation, resulting in less than half of the claims being accurate.",
                "The summary uses vague terms like 'resource handlers' and 'matching entries' which do not accurately reflect the core purpose of merging an attribute group into an existing sysfs directory entry. It fails to cover the core domain operation and omits critical semantics such as iterating over attributes, adding them to the directory, handling errors by removing added files, and returning error codes like -ENOENT. While it mentions cleanup and returning a status code, these are generic and do not capture the specific source code behavior.",
                "The summary contains multiple inaccurate claims: it refers to 'resource handlers' and 'matching entries', which do not align with the code's actual functionality of merging sysfs attribute groups. The loop operates on attributes, not generic resource handlers, and 'matching entries' is misleading in this context. While it correctly mentions decrementing a reference count (via sysfs_put) and returning a status code, these accurate points are generic and low-info. The dominant failure mode is NOISE, with vague and incorrect terminology that obscures the true core purpose."
            ]
        },
        "comment": {
            "summary": "Merges a specified attribute group into a kobject's sysfs directory, adding attributes and handling errors by removing any added attributes on failure.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary captures the core semantic behavior of the function: it merges an attribute group into a kobject's sysfs directory, iteratively adds attributes, and removes any that were added if an error occurs. These are all directly supported by the source code, with no contradictory or irrelevant claims. The statement is accurate and precise, reflecting over 80% alignment with the code's behavior.",
                "The summary accurately identifies the core purpose as merging an attribute group into a kobject's sysfs directory, which matches the function's main action. It also correctly notes the addition of attributes and the error-handling procedure of removing added attributes on failure. While these are core and secondary behaviors present in the source code, it omits specifics such as returning -ENOENT when the directory entry is missing and calling sysfs_put at the end, so the coverage of secondary semantics is decent but not complete.",
                "The summary accurately captures the core purpose of the function \u2014 merging an attribute group into a kobject's sysfs directory, adding attributes, and on error removing previously added attributes. These are specific and verifiable behaviors reflected in the source code. There is no contradictory or irrelevant information, and the claims provide clear insight into the function\u2019s primary action and error handling."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582377712,
    "strip_function_name": "sub_FFFFFFFF8135E6F0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8135E6F0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 *a4)\n{\n  unsigned __int64 v5; // r13\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // rsi\n  __int64 v8; // rdx\n  unsigned __int64 v9; // rbx\n  void *v10; // r14\n  unsigned __int64 v11; // rcx\n  __int64 result; // rax\n  __int64 v14; // [rsp+8h] [rbp-38h]\n  __int64 v15; // [rsp+10h] [rbp-30h]\n\n  v5 = a3;\n  v6 = *a4;\n  v7 = *a4 + a3;\n  v8 = 0x77FF80000000LL;\n  if ( (unsigned __int64)qword_FFFFFFFF81E8C780 >= 0xFFFFFFFF80000000LL )\n    v8 = qword_FFFFFFFF81C10010;\n  if ( v7 > v8 + qword_FFFFFFFF81E8C780 + 0x80000000LL )\n    return -14LL;\n  if ( v5 )\n  {\n    v14 = 0LL;\n    while ( 1 )\n    {\n      v9 = 4096 - (v6 & 0xFFF);\n      if ( v9 > v5 )\n        v9 = v5;\n      v10 = (void *)sub_FFFFFFFF81031720(v6);\n      if ( !v10 )\n        break;\n      sub_FFFFFFFF81790F30(v6);\n      v15 = sub_FFFFFFFF812B8B10(v10, a2, (unsigned int)v9);\n      sub_FFFFFFFF81031790(v6, (__int64)v10);\n      if ( v15 )\n      {\n        v14 = v9 + v14 - v15;\n        if ( !v14 )\n          return -14LL;\nLABEL_12:\n        v11 = *a4;\n        goto LABEL_13;\n      }\n      a2 += v9;\n      v6 += v9;\n      v14 += v9;\n      v5 -= v9;\n      if ( !v5 )\n        goto LABEL_12;\n    }\n    if ( !v14 )\n      return -14LL;\n    goto LABEL_12;\n  }\n  v11 = *a4;\n  v14 = 0LL;\nLABEL_13:\n  result = v14;\n  *a4 = v14 + v11;\n  return result;\n}\n",
    "function_name": "write_mem",
    "decompiled_code": "__int64 __fastcall write_mem(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        unsigned __int64 *a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned __int64 v13; // r13\n  unsigned __int64 v14; // r12\n  unsigned __int64 v15; // rsi\n  __int64 v16; // rdx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  unsigned __int64 v19; // rbx\n  unsigned __int64 v20; // r14\n  unsigned __int64 v21; // rcx\n  __int64 result; // rax\n  __int64 v24; // [rsp+8h] [rbp-38h]\n  __int64 v25; // [rsp+10h] [rbp-30h]\n\n  v13 = a3;\n  v14 = *a4;\n  v15 = *a4 + a3;\n  v16 = 0x77FF80000000LL;\n  if ( (unsigned __int64)high_memory >= 0xFFFFFFFF80000000LL )\n    v16 = phys_base;\n  if ( v15 > v16 + high_memory + 0x80000000LL )\n    return -14LL;\n  if ( v13 )\n  {\n    v24 = 0LL;\n    while ( 1 )\n    {\n      v19 = 4096 - (v14 & 0xFFF);\n      if ( v19 > v13 )\n        v19 = v13;\n      v20 = xlate_dev_mem_ptr(v14, a5, a6, a7, a8, a9, a10, a11, a12);\n      if ( !v20 )\n        break;\n      cond_resched(v14, v15);\n      v15 = v20;\n      v25 = copy_from_user(v20, a2, (unsigned int)v19);\n      unxlate_dev_mem_ptr(v14, v20, a5, a6, a7, a8, v17, v18, a11, a12);\n      if ( v25 )\n      {\n        v24 = v19 + v24 - v25;\n        if ( !v24 )\n          return -14LL;\nLABEL_12:\n        v21 = *a4;\n        goto LABEL_13;\n      }\n      a2 += v19;\n      v14 += v19;\n      v24 += v19;\n      v13 -= v19;\n      if ( !v13 )\n        goto LABEL_12;\n    }\n    if ( !v24 )\n      return -14LL;\n    goto LABEL_12;\n  }\n  v21 = *a4;\n  v24 = 0LL;\nLABEL_13:\n  result = v24;\n  *a4 = v24 + v21;\n  return result;\n}\n",
    "source_code": "static int __kprobes write_mem(unsigned long val, unsigned long ea, int nb,\n\t\t\t       struct pt_regs *regs)\n{\n\tif (!address_ok(regs, ea, nb))\n\t\treturn -EFAULT;\n\tif ((ea & (nb - 1)) == 0)\n\t\treturn write_mem_aligned(val, ea, nb);\n\treturn write_mem_unaligned(val, ea, nb, regs);\n}",
    "comment": "Writes specified bytes from a buffer to a target object's memory section, logging the operation if enabled.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Reads memory from a specified address , checking alignment and validity before using appropriate aligned or unaligned reading methods .\n",
    "cpbcs_sum": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
    "misum_sum": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
    "decom_sum": "Copies data into page-aligned memory blocks from a source buffer while enforcing address range limits and updating the processed byte counter.",
    "cfg_sum": "Copies data from a source address to a destination in paged chunks, validating memory bounds and updating the write offset, returning error on failure.",
    "work_score": {
        "decom": {
            "summary": "Copies data into page-aligned memory blocks from a source buffer while enforcing address range limits and updating the processed byte counter.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function copies data into page-aligned memory blocks from a source buffer, enforces address range limits, and updates a processed byte counter. In the source code, the function checks address validity, decides between aligned and unaligned memory write operations, but there is no evidence of page alignment specifically, copying from a source buffer, or updating any processed byte counter. Only the address range check aligns loosely with the code. Most claims are inaccurate or unsupported, resulting in a low proportion of accurate elements.",
                "The summary's core claim about copying data into page-aligned blocks and updating a processed byte counter is inaccurate: the function writes a given value to a specified memory address, choosing aligned or unaligned routines based on address alignment, and returns an error if the address is invalid. It does not mention page alignment, source buffers, or any byte counter. This means the core primary purpose of performing a conditional aligned/unaligned memory write with address validity checks is not covered, and the summary omits other behavior-critical details such as error handling and the role of alignment checks.",
                "The summary contains multiple inaccurate claims about the function's behavior. It asserts copying data from a source buffer into page-aligned memory blocks, enforcing address range limits, and updating a processed byte counter. The source code actually writes a given value to a specified address with alignment checks, and does not involve copying from a buffer, page alignment per se, or maintaining a processed byte counter. These are FATAL inaccuracies regarding the core purpose and I/O, making the description misleading and unusable."
            ]
        },
        "cfg": {
            "summary": "Copies data from a source address to a destination in paged chunks, validating memory bounds and updating the write offset, returning error on failure.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains multiple fact-based claims, such as copying data from source to destination in paged chunks, validating memory bounds, updating the write offset, and returning an error on failure. Only the validation of memory bounds and returning an error on failure align with the source code, which checks address validity and returns -EFAULT if invalid. The source code does not copy data in paged chunks, nor update a write offset, nor directly describe a generic source-to-destination copy. Most claims are inaccurate with respect to the actual function's semantics, resulting in low precision.",
                "The summary incorrectly describes copying data in paged chunks and updating a write offset, which are not present in the source code. The core purpose\u2014writing a value to a specified memory address with alignment checks and error handling\u2014is missing. While the summary notes validating bounds and returning an error, it misrepresents the operation as chunked copying and introduces unrelated details, thus failing to cover the primary domain action and providing inaccurate claims.",
                "The summary contains multiple inaccurate claims about the function's behavior. It falsely describes copying data in paged chunks, updating a write offset, and operating on a source and destination address, none of which are present in the source code. The function actually validates an address range and then writes an aligned or unaligned value to memory, returning an error if the address is invalid. These inaccuracies are targeting the core purpose and I/O behavior, making them fatal errors that undermine trust. There are no accurate, specific claims to offset this."
            ]
        },
        "comment": {
            "summary": "Writes specified bytes from a buffer to a target object's memory section, logging the operation if enabled.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function writes bytes from a buffer to a target object's memory and logs the operation if enabled. The source code shows it writes a value to memory after validating address alignment, with no evidence of a buffer parameter, object-specific memory, or logging. Both claims contradict the actual semantics, resulting in no accurate claims.",
                "The summary's main claim about writing bytes from a buffer to a target object's memory is inaccurate, as the function writes a given value to a specified memory address after validating alignment and address safety, not from a buffer or to an object. It also adds unrelated noise about logging, which is not present in the source code. The core purpose of handling aligned and unaligned memory writes with error checking is entirely missing, so no [ACCURATE] claim covers the core domain behavior.",
                "The summary inaccurately describes the function as writing bytes from a buffer to a target object's memory and logging the operation, which contradicts the source code. The function instead writes a given value to a specified effective address, checks address validity, and delegates to aligned or unaligned write functions. The mention of a buffer, a target object's memory section, and logging are unsupported (FATAL) and misrepresent the primary purpose. This severe misalignment makes the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592542067,
    "strip_function_name": "sub_FFFFFFFF81D0FF73",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81D0FF73(\n        int a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // r12d\n  __int64 v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 result; // rax\n  __int64 v15; // rax\n  __int64 v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // edx\n  unsigned __int64 v20; // r12\n\n  v9 = 1;\n  if ( a1 >= 0 )\n    v9 = a1 + 2;\n  v11 = sub_FFFFFFFF8178CF92(a2, a3, a4, a5, a6, a7, a8, a9);\n  result = 4294967284LL;\n  if ( v11 )\n  {\n    v15 = qword_FFFFFFFF81EA6D38;\n    *(_QWORD *)v11 = 16LL * v9 - 2115343008;\n    v16 = v11 + 8;\n    *(_BYTE *)(v11 + 73) = 1;\n    *(_QWORD *)(v11 + 80) = sub_FFFFFFFF814DFE10;\n    *(_QWORD *)(v11 + 104) = sub_FFFFFFFF814DF330;\n    *(_QWORD *)(v11 + 112) = sub_FFFFFFFF814DFA50;\n    *(_QWORD *)(v11 + 672) = &unk_FFFFFFFF81C763A0;\n    *(_QWORD *)(v11 + 216) = v15 + 16;\n    if ( a1 >= 0 )\n    {\n      sub_FFFFFFFF812B8440(v16, 32LL, (__int64)\"i8042 AUX%d port\", a2, a3, a4, a5, v12, v13, a8, a9, (unsigned int)a1);\n      sub_FFFFFFFF812B8440(\n        v11 + 40,\n        32LL,\n        (__int64)\"isa0060/serio%d\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9,\n        (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      sub_FFFFFFFF812B54A0(v16, \"i8042 AUX port\", 0x20uLL);\n      sub_FFFFFFFF812B54A0(v11 + 40, \"isa0060/serio1\", 0x20uLL);\n      *(_QWORD *)(v11 + 96) = sub_FFFFFFFF814E0250;\n    }\n    v19 = dword_FFFFFFFF81EA6E40;\n    v20 = 4LL * v9;\n    result = 0LL;\n    qword_FFFFFFFF81EA6D60[v20 / 2] = v11;\n    byte_FFFFFFFF81EA6D6D[v20 * 4] = a1;\n    dword_FFFFFFFF81EA6D68[v20] = v19;\n  }\n  return result;\n}\n",
    "function_name": "i8042_create_aux_port",
    "decompiled_code": "__int64 __fastcall i8042_create_aux_port(\n        int a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // r12d\n  __int64 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 result; // rax\n  __int64 v15; // rax\n  __int64 v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // edx\n  unsigned __int64 v20; // r12\n\n  v9 = 1;\n  if ( a1 >= 0 )\n    v9 = a1 + 2;\n  v11 = kzalloc_constprop_8(a2, a3, a4, a5, a6, a7, a8, a9);\n  result = 4294967284LL;\n  if ( v11 )\n  {\n    v15 = i8042_platform_device;\n    *v11 = 16LL * v9 - 2115343008;\n    v16 = (__int64)(v11 + 1);\n    *((_BYTE *)v11 + 73) = 1;\n    v11[10] = (__int64)i8042_aux_write;\n    v11[13] = (__int64)i8042_start;\n    v11[14] = (__int64)i8042_stop;\n    v11[84] = (__int64)&i8042_mutex;\n    v11[27] = v15 + 16;\n    if ( a1 >= 0 )\n    {\n      snprintf(v16, 32LL, (__int64)\"i8042 AUX%d port\", a2, a3, a4, a5, v12, v13, a8, a9, (unsigned int)a1);\n      snprintf(\n        (__int64)(v11 + 5),\n        32LL,\n        (__int64)\"isa0060/serio%d\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9,\n        (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      strlcpy(v16, (__int64 *)\"i8042 AUX port\", 0x20uLL);\n      strlcpy((__int64)(v11 + 5), (__int64 *)\"isa0060/serio1\", 0x20uLL);\n      v11[12] = (__int64)i8042_port_close;\n    }\n    v19 = i8042_aux_irq;\n    v20 = 4LL * v9;\n    result = 0LL;\n    i8042_ports[v20 / 2] = (__int64)v11;\n    byte_FFFFFFFF81EA6D6D[v20 * 4] = a1;\n    dword_FFFFFFFF81EA6D68[v20] = v19;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int __init i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrlcpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}",
    "comment": "Initializes an i8042 auxiliary port, allocating a serio structure and configuring it for communication with the specified input device.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the loop device by allocating memory , setting up loop devices , and registering the loop device with the block device subsystem .\n",
    "cpbcs_sum": "Initializes a serial 8250 port, configures its parameters and adds it to the device if valid, while setting up a semaphore.\n",
    "misum_sum": "Initializes an input device by allocating memory, setting up its corresponding function and initializing its properties in the system.\n",
    "decom_sum": "Initializes and registers an i8042 AUX (PS/2 mouse) port device, assigning handlers, naming, and updating global controller state structures.",
    "cfg_sum": "Initializes and registers an i8042 AUX (PS/2 mouse) port device entry with formatted identifiers and associated handlers based on the given port index.",
    "work_score": {
        "decom": {
            "summary": "Initializes and registers an i8042 AUX (PS/2 mouse) port device, assigning handlers, naming, and updating global controller state structures.",
            "score": [
                0.8,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly identifies that the function initializes an i8042 AUX port by assigning handlers (write, start, stop, close) and setting naming conventions, which are evident from the code. However, it inaccurately mentions registering the device, as there is no registration or system API call present \u2014 the code only allocates and assigns data structures. The rest of the details match source code behavior, resulting in most but not all claims being accurate.",
                "The summary captures the core purpose of creating and initializing an i8042 AUX port with handlers, naming, and updating controller state, which aligns with the source code\u2019s primary function of allocating and configuring a serio device for the AUX port. However, it inaccurately includes 'registers' since the function does not register the device, and omits secondary details such as memory allocation error handling, specific differences for idx < 0 vs multiplexed ports, and setting IRQ constants. These omissions reduce completeness of coverage of key behavioral semantics.",
                "The summary correctly describes the main purpose of the function\u2014initializing an i8042 AUX port and assigning handlers\u2014matching the code\u2019s allocation of a serio structure, setting function pointers, naming, and updating global port structures. However, it inaccurately claims that the function registers the device; the code does not perform registration or add it to any system registry, only initialization. This is a minor semantic mismatch but not a core FATAL error. Overall, the summary contains mostly accurate, meaningful information with minimal noise."
            ]
        },
        "cfg": {
            "summary": "Initializes and registers an i8042 AUX (PS/2 mouse) port device entry with formatted identifiers and associated handlers based on the given port index.",
            "score": [
                0.8,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function initializes an i8042 AUX port device entry and tailors identifiers and handlers based on the index, which matches the allocation, setup of function pointers, and conditional name/phys formatting in the source. However, the summary inaccurately adds 'registers', implying external system registration not shown in the code, and specifies 'PS/2 mouse', which is not explicitly identified in the code. These minor inaccuracies reduce precision but most claims are accurate.",
                "The summary correctly identifies that the function initializes an i8042 AUX port with identifiers and handlers based on the port index, covering the core purpose of creating and configuring a serio device for PS/2 mouse functionality. However, it omits key secondary semantics such as allocating memory with kzalloc, setting specific struct serio fields like parent device, differentiating behavior for default vs. multiplexed ports, configuring close handlers only for idx < 0, and assigning IRQ values to the port structure. These omissions reduce completeness of secondary coverage.",
                "The summary correctly captures that the function initializes an i8042 AUX port with handlers and formatted identifiers based on the index, which aligns with the code. However, it inaccurately claims that the port is registered, which the source does not perform. This is a FATAL error targeting the primary purpose because registration is a distinct core action not present in the code, making the summary misleading for understanding the function's actual behavior."
            ]
        },
        "comment": {
            "summary": "Initializes an i8042 auxiliary port, allocating a serio structure and configuring it for communication with the specified input device.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function initializes an i8042 auxiliary port and allocates a serio structure, which matches the code. However, it also claims the configuration is specifically for communication with the specified input device, which is not explicitly stated or implied in the source code; the code configures various serio fields but does not mention 'specified input device' semantics. Overall, most claims are accurate, with a minor overgeneralization.",
                "The summary correctly identifies that the function initializes an i8042 auxiliary port and allocates/configures a serio structure, which matches the core purpose of creating and setting up the port. However, it lacks detail on critical secondary behaviors such as handling negative vs. non-negative idx values, setting specific fields like write/start/stop handlers, populating name and phys strings differently based on idx, assigning IRQs, and error handling for memory allocation failure. These omissions reduce completeness despite accurate core coverage.",
                "The summary correctly identifies that the function initializes an i8042 auxiliary port and allocates a serio structure, aligning with the source code. However, it is generic and omits key specifics such as handling multiple ports via idx, setting function pointers (write, start, stop, close), and configuring fields like name, phys, irq, and port_data. There are no inaccurate claims, but the low detail results in minimal gain. The main shortcoming is lack of specificity rather than noise or fatal errors."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581326800,
    "strip_function_name": "sub_FFFFFFFF8125DDD0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8125DDD0(\n        unsigned int a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // rbx\n  unsigned __int64 v11; // r13\n  unsigned __int64 v12; // rsi\n  unsigned __int64 v13; // rax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  volatile signed __int32 *v20; // rbx\n  volatile signed __int32 *v21; // r12\n  __int64 v22; // rdx\n  __int64 v23; // rcx\n  __int64 v24; // r8\n  int v25; // r9d\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n\n  v10 = sub_FFFFFFFF8125FA30(a2, 0LL, 4LL);\n  v11 = v10;\n  if ( v10 <= 0xFFFFFFFFFFFFF000LL )\n  {\n    v12 = 4LL;\n    v13 = sub_FFFFFFFF8125FA30(a1, 4LL, 0LL);\n    if ( v13 > 0xFFFFFFFFFFFFF000LL )\n    {\n      v11 = v13;\n      v20 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n    }\n    else\n    {\n      v20 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n      v21 = (volatile signed __int32 *)(v13 & 0xFFFFFFFFFFFFFFFELL);\n      v12 = v13 & 0xFFFFFFFFFFFFFFFELL;\n      v11 = (int)sub_FFFFFFFF8125C660((__int64)v20, v13 & 0xFFFFFFFFFFFFFFFELL, a3, a4, a5, a6, v18, v19, a9, a10);\n      sub_FFFFFFFF8125B5F0(v21, a3, a4, a5, a6, v26, v27, a9, a10, v12, v22, v23, v24, v25);\n    }\n    sub_FFFFFFFF8125B5F0(v20, a3, a4, a5, a6, v18, v19, a9, a10, v12, v14, v15, v16, v17);\n  }\n  return v11;\n}\n",
    "function_name": "keyctl_keyring_unlink",
    "decompiled_code": "unsigned __int64 __fastcall keyctl_keyring_unlink(\n        unsigned int a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // rbx\n  unsigned __int64 v11; // r13\n  unsigned __int64 v12; // rax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  volatile signed __int32 *v15; // rbx\n  volatile signed __int32 *v16; // r12\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = lookup_user_key(a2, 0LL, 4LL);\n  v11 = v10;\n  if ( v10 <= 0xFFFFFFFFFFFFF000LL )\n  {\n    v12 = lookup_user_key(a1, 4LL, 0LL);\n    if ( v12 > 0xFFFFFFFFFFFFF000LL )\n    {\n      v11 = v12;\n      v15 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n    }\n    else\n    {\n      v15 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n      v16 = (volatile signed __int32 *)(v12 & 0xFFFFFFFFFFFFFFFELL);\n      v11 = (int)key_unlink((__int64)v15, v12 & 0xFFFFFFFFFFFFFFFELL, a3, a4, a5, a6, v13, v14, a9, a10);\n      key_put(v16, a3, a4, a5, a6, v17, v18, a9, a10);\n    }\n    key_put(v15, a3, a4, a5, a6, v13, v14, a9, a10);\n  }\n  return v11;\n}\n",
    "source_code": "long keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_unlink(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "comment": "Unlinks a key from a specified keyring after verifying the existence of both the key and the keyring.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Links a key to a specified keyring , creating the keyring if it does not exist , and returns a status code .\n",
    "cpbcs_sum": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
    "misum_sum": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
    "decom_sum": "Processes two memory-mapped data blocks and applies computational routines on them using provided double parameters, returning the final computed block address.",
    "cfg_sum": "Validates two unsigned integer inputs, applies bitmasking, conditionally processes them with computations, and returns a status or masked pointer value.",
    "work_score": {
        "decom": {
            "summary": "Processes two memory-mapped data blocks and applies computational routines on them using provided double parameters, returning the final computed block address.",
            "score": [
                0.0,
                0.1,
                0.0
            ],
            "reason": [
                "The summary's claims about processing memory-mapped data blocks, applying computational routines, and returning a computed block address are entirely unrelated to the actual source code, which unlinks a key from a keyring using lookups and error handling. None of the claims accurately reflect the function's domain-specific behavior, resulting in a complete mismatch.",
                "The summary claims that the function processes memory-mapped data blocks with computational routines and returns a computed block address, which is entirely unrelated to the source code. The source code clearly performs a key unlink operation from a keyring after looking up keys and handling errors, with no mention of memory-mapped data, double parameters, or computed addresses. This is a complete mismatch, and the core purpose is not covered.",
                "The summary's claims about processing memory-mapped data blocks, applying computational routines, and returning a computed block address are entirely unrelated to the source code's actual behavior, which handles unlinking a key from a keyring via kernel key management functions. This constitutes total NOISE targeting none of the true semantics, with no accurate claims present, resulting in zero net benefit."
            ]
        },
        "cfg": {
            "summary": "Validates two unsigned integer inputs, applies bitmasking, conditionally processes them with computations, and returns a status or masked pointer value.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims involve validation of unsigned integers, bitmasking, conditional computations, and returning a status or masked pointer value. The source code, however, deals with looking up keys using provided IDs, handling potential errors, unlinking keys from a keyring, and returning a long status code. No bitmasking is present, and the input types are not clearly unsigned integers. All claims in the summary fail to accurately reflect the semantics of the source code, resulting in no accurate matches.",
                "The summary's claims about validating unsigned integers, bitmasking, and returning masked pointer values do not match the source code, which is about unlinking a key from a keyring via lookup functions and releasing references. The core purpose\u2014removing a specified key from a specified keyring\u2014is absent, and no accurate coverage of the function\u2019s actual semantics is provided.",
                "The summary contains multiple inaccuracies: it claims validation of unsigned integers and bitmasking, neither of which appear in the source code. The function actually performs key lookup operations, checks for errors, unlinks a key from a keyring, and returns a status code. It does not process inputs via computations or return masked pointer values. These are FATAL errors about the primary purpose and core behavior, making the description untrustworthy."
            ]
        },
        "comment": {
            "summary": "Unlinks a key from a specified keyring after verifying the existence of both the key and the keyring.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function unlinks a key from a specified keyring and checks for the existence of both before doing so. This aligns with the code\u2019s sequence of lookups for the keyring and key, error handling if they are invalid, and performing the unlink operation. The description is concise but accurately captures the core semantics without contradictions, yielding high claim accuracy.",
                "The summary correctly identifies the core action: unlinking a key from a specified keyring, and notes verification of the existence of both entities, matching the function\u2019s lookups and error checks. This covers the primary purpose with adequate specificity. However, it omits secondary details such as use of specific access permissions (KEY_WRITE, KEY_LOOKUP_FOR_UNLINK), the exact sequence of lookups, error handling via IS_ERR checks and PTR_ERR, and resource cleanup through key_ref_put calls. Lack of these reduces completeness of coverage.",
                "The summary correctly captures the primary purpose of the function: removing a key from a specific keyring and that it checks for existence of both entities before proceeding. This aligns with the source code, which uses lookup_user_key to validate both the keyring and the key before calling key_unlink. There are no inaccurate claims and noise is minimal, but the description remains generic and lacks mention of specific error handling paths or permission checks seen in the code, providing only low informational gain."
            ]
        }
    }
}
{
    "project_name": "putty",
    "function_addr": 4336,
    "strip_function_name": "sub_10F0",
    "strip_decompiled_code": "unsigned int *__fastcall sub_10F0(__int64 a1)\n{\n  unsigned int *result; // rax\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  void *v6; // rcx\n  __int64 v7; // [rsp-28h] [rbp-40h]\n  __int64 v8; // [rsp-20h] [rbp-38h]\n  __int64 v9; // [rsp-18h] [rbp-30h]\n  __int64 v10; // [rsp-10h] [rbp-28h]\n  __int64 v11; // [rsp-8h] [rbp-20h]\n\n  while ( 1 )\n  {\n    result = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 16) + 32LL))(\n                               *(_QWORD *)(a1 + 16),\n                               *(_QWORD *)(a1 + 16),\n                               0LL);\n    if ( !result )\n      break;\n    v5 = *result;\n    if ( (_DWORD)v5 != 2 )\n    {\n      if ( (_DWORD)v5 != 4 )\n      {\n        if ( (_DWORD)v5 != 1 )\n          return 0LL;\n        v6 = &loc_11B1;\n        if ( (unsigned int)((_DWORD)result - 1) <= 0xE )\n        {\n          v5 = (int)result;\n          v6 = (void *)*((_QWORD *)&loc_11BD + (int)result);\n        }\n        return (unsigned int *)sub_11CF(*(_QWORD *)(a1 + 88), sub_11CF, v5, v6, (unsigned int)result);\n      }\n      v11 = 4412LL;\n      v10 = 4420LL;\n      v9 = 4431LL;\n      v8 = 4446LL;\n      v7 = 4458LL;\n    }\n    (*(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))(*(_QWORD *)(a1 + 16) + 32LL))(\n      *(_QWORD *)(a1 + 16),\n      *(_QWORD *)(a1 + 16),\n      1LL,\n      v2,\n      v3,\n      v4,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11);\n  }\n  return result;\n}\n",
    "function_name": "ssh2_common_filter_queue",
    "decompiled_code": "bool __fastcall ssh2_common_filter_queue(PacketProtocolLayer *ppl)\n{\n  PktIn *v1; // rax\n  int type; // edx\n  BinarySource *v3; // rbx\n  const char *v4; // rbx\n  __int64 v5; // rdx\n  int v6; // eax\n  __int64 v7; // rax\n  BinarySource *binarysource; // rbx\n  int uint32; // r12d\n  const char *string; // rbx\n  __int64 v11; // rdx\n  int v12; // r8d\n  const char *v13; // rcx\n\n  while ( 1 )\n  {\n    v1 = ppl->in_pq->after(ppl->in_pq, ppl->in_pq, 0LL);\n    if ( !v1 )\n      break;\n    type = v1->type;\n    if ( v1->type != 2 )\n    {\n      if ( type != 4 )\n      {\n        if ( type == 1 )\n        {\n          binarysource = v1->binarysource_;\n          uint32 = BinarySource_get_uint32(v1->binarysource_);\n          string = (const char *)BinarySource_get_string(binarysource);\n          v12 = string_length_for_printf(v11);\n          v13 = \"unknown\";\n          if ( (unsigned int)(uint32 - 1) <= 0xE )\n            v13 = ssh2_disconnect_reasons_9548[uint32];\n          ssh_remote_error(\n            ppl->ssh,\n            \"Remote side sent disconnect message\\ntype %d (%s):\\n\\\"%.*s\\\"\",\n            uint32,\n            v13,\n            v12,\n            string);\n          LOBYTE(v1) = 1;\n        }\n        else\n        {\n          LOBYTE(v1) = 0;\n        }\n        return (char)v1;\n      }\n      v3 = v1->binarysource_;\n      BinarySource_get_bool(v1->binarysource_);\n      v4 = (const char *)BinarySource_get_string(v3);\n      v6 = string_length_for_printf(v5);\n      v7 = dupprintf(\"Remote debug message: %.*s\", v6, v4);\n      logevent_and_free(ppl->logctx, v7);\n    }\n    ppl->in_pq->after((PacketQueueBase *)ppl->in_pq, (PacketQueueNode *)ppl->in_pq, 1);\n  }\n  return (char)v1;\n}\n",
    "source_code": "\nbool ssh2_common_filter_queue(PacketProtocolLayer *ppl)\n{\n    static const char *const ssh2_disconnect_reasons[] = {\n        NULL,\n        \"host not allowed to connect\",\n        \"protocol error\",\n        \"key exchange failed\",\n        \"host authentication failed\",\n        \"MAC error\",\n        \"compression error\",\n        \"service not available\",\n        \"protocol version not supported\",\n        \"host key not verifiable\",\n        \"connection lost\",\n        \"by application\",\n        \"too many connections\",\n        \"auth cancelled by user\",\n        \"no more auth methods available\",\n        \"illegal user name\",\n    };\n\n    PktIn *pktin;\n    ptrlen msg;\n    int reason;\n\n    while ((pktin = pq_peek(ppl->in_pq)) != NULL) {\n        switch (pktin->type) {\n          case SSH2_MSG_DISCONNECT:\n            reason = get_uint32(pktin);\n            msg = get_string(pktin);\n\n            ssh_remote_error(\n                ppl->ssh, \"Remote side sent disconnect message\\n\"\n                \"type %d (%s):\\n\\\"%.*s\\\"\", reason,\n                ((reason > 0 && reason < lenof(ssh2_disconnect_reasons)) ?\n                 ssh2_disconnect_reasons[reason] : \"unknown\"),\n                PTRLEN_PRINTF(msg));\n            /* don't try to pop the queue, because we've been freed! */\n            return true;               /* indicate that we've been freed */\n\n          case SSH2_MSG_DEBUG:\n            /* XXX maybe we should actually take notice of the return value */\n            get_bool(pktin);\n            msg = get_string(pktin);\n            ppl_logevent(\"Remote debug message: %.*s\", PTRLEN_PRINTF(msg));\n            pq_pop(ppl->in_pq);\n            break;\n\n          case SSH2_MSG_IGNORE:\n            /* Do nothing, because we're ignoring it! Duhh. */\n            pq_pop(ppl->in_pq);\n            break;\n\n          default:\n            return false;\n        }\n    }\n\n    return false;\n}",
    "comment": "Processes incoming SSH2 packets, handling disconnect messages, debug messages, and ignores messages, while managing packet queue operations.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "The function reads data from a transport stream , processes it , and stores it in a buffer until no more data is available .\n",
    "cpbcs_sum": "Executes a Lua function with its name and manages the stack trace in the provided context of the sieve node.\n",
    "misum_sum": "Formats and returns a string representation of a Lua state, including its type and indentation to the output.\n",
    "decom_sum": "Processes commands from an input handler, dispatching specific actions based on command type and parameters until no further commands are available.",
    "cfg_sum": "Processes commands from an object via its function table, dispatches handlers for specific codes, and returns execution results or status accordingly.",
    "work_score": {
        "decom": {
            "summary": "Processes commands from an input handler, dispatching specific actions based on command type and parameters until no further commands are available.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary claims the function processes commands from an input handler and dispatches actions based on command type and parameters until no further commands are available. While loosely related, it fails to capture key specifics from the source such as handling SSH2 packet types (DISCONNECT, DEBUG, IGNORE), logging, and queue operations. The description is overly generic and omits critical domain-specific behavior, making most of its content low-info and not verifiably accurate with respect to the actual code.",
                "The summary generically describes processing commands from an input handler but fails to accurately convey the core purpose of handling specific SSH2 protocol message types (DISCONNECT, DEBUG, IGNORE) and the associated actions like logging errors, popping the queue, and returning state indicators. It omits key domain semantics tied to SSH2 packets, disconnect reasons, and side effects. While it vaguely matches a loop over inputs, it is too generic and misses the specific protocol behavior, making the core purpose uncovered.",
                "The summary makes a broad generic claim about processing commands from an input handler, but it introduces inaccuracies by describing 'commands' and 'parameters' which do not match the function\u2019s actual processing of SSH2 protocol packet types from a queue. It omits key specifics such as handling SSH2_MSG_DISCONNECT, DEBUG, and IGNORE, and the side effect of logging or terminating the connection, making the statement largely noise with minimal accurate mapping to the source. No fatal contradiction on core purpose, but noise overwhelms accurate content, resulting in low net benefit."
            ]
        },
        "cfg": {
            "summary": "Processes commands from an object via its function table, dispatches handlers for specific codes, and returns execution results or status accordingly.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes a generic function table dispatch pattern and handling of commands, which is not reflective of the source code's actual semantics. The function processes SSH2 protocol packets from a queue, specifically handling disconnect, debug, and ignore messages, without using a function table. None of the claims accurately match the domain-specific behavior shown in the code, resulting in no accurate claims.",
                "The summary makes generic claims about processing commands through a function table and dispatching handlers, but the source code specifically processes queued SSH2 protocol messages, handling DISCONNECT, DEBUG, and IGNORE types with distinct side effects like logging, returning freed status, or ignoring messages. The generic description fails to capture the core purpose of iterating over SSH2 incoming packet queue or mention protocol-specific cases and associated behaviors, leading to no coverage of critical domain semantics.",
                "The summary's core claim that the function processes commands via an object's function table and dispatches handlers is inaccurate, as the source code shows it directly inspects packet types from an input queue rather than using a function table mechanism. This represents a FATAL error on the primary purpose since it misstates the core domain action (packet type handling). No accurate claims are present to offset this, resulting in zero net benefit."
            ]
        },
        "comment": {
            "summary": "Processes incoming SSH2 packets, handling disconnect messages, debug messages, and ignores messages, while managing packet queue operations.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function processes SSH2 packets and handles disconnect, debug, and ignore message types, which matches the switch cases in the source code. It also mentions managing packet queue operations, which is supported by the pq_pop and pq_peek calls. All claims in the summary are accurate and aligned with the code semantics, with no contradictory or irrelevant details.",
                "The summary correctly states that the function processes incoming SSH2 packets and handles disconnect, debug, and ignore message types, which matches the primary purpose of the code. It also notes packet queue management, aligning with pq_pop and handling of pktin. However, it omits key specifics such as logging the disconnect reason and message, the early return when freed, conditional selection of disconnect reason strings, and handling default cases by returning false. Thus, while the core purpose is covered, coverage of secondary behavior-critical details is limited.",
                "The summary correctly captures the core purpose of the function: it processes different types of incoming SSH2 packets (disconnect, debug, and ignore) and interacts with the packet queue. All stated actions match the source code\u2019s switch logic, making them accurate GOLD claims with no contradictory or irrelevant information. While the description is somewhat generic and lacks finer details (e.g., specific error handling or immediate return on disconnect), the coverage of the primary purpose and key packet types is complete and free of noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585589376,
    "strip_function_name": "sub_FFFFFFFF8166E880",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8166E880(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  unsigned __int64 result; // rax\n  __int64 v10; // r8\n  int v11; // r9d\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  int v15; // eax\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v20; // r8\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  unsigned int v24; // ebx\n\n  result = sub_FFFFFFFF815F7130((__int64)&unk_FFFFFFFF818CA200, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n  v14 = (_QWORD *)result;\n  if ( result > 0xFFFFFFFFFFFFF000LL )\n    return (unsigned int)result;\n  v15 = sub_FFFFFFFF815F8510(result, 0, 255LL, 0LL, v10, v11, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( v15 < 0\n    || (v15 = sub_FFFFFFFF815F8510((__int64)v14, 32766, 254LL, 0LL, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9), v15 < 0)\n    || (v15 = sub_FFFFFFFF815F8510((__int64)v14, 0x7FFF, 253LL, 0LL, v20, v21, a2, a3, a4, a5, v22, v23, a8, a9), v15 < 0) )\n  {\n    v24 = v15;\n    sub_FFFFFFFF815F7720(v14);\n    return v24;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 568) = v14;\n    *(_BYTE *)(a1 + 576) = 0;\n    return 0LL;\n  }\n}\n",
    "function_name": "fib4_rules_init",
    "decompiled_code": "_QWORD *__fastcall fib4_rules_init(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        int a14)\n{\n  _QWORD *result; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // r12\n  int v18; // eax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // ebx\n\n  result = (_QWORD *)fib_rules_register(fib4_rules_ops_template, a1, a2, a3, a4, a5, a6, a7, a8, a9, a11, a12, a13, a14);\n  v17 = result;\n  if ( (unsigned __int64)result > 0xFFFFFFFFFFFFF000LL )\n    return (_QWORD *)(unsigned int)result;\n  v18 = fib_default_rule_add((__int64)result, 0, 255, 0, a2, a3, a4, a5, v15, v16, a8, a9);\n  if ( v18 < 0\n    || (v18 = fib_default_rule_add((__int64)v17, 32766, 254, 0, a2, a3, a4, a5, v19, v20, a8, a9), v18 < 0)\n    || (v18 = fib_default_rule_add((__int64)v17, 0x7FFF, 253, 0, a2, a3, a4, a5, v19, v20, a8, a9), v18 < 0) )\n  {\n    v21 = v18;\n    fib_rules_unregister(v17, a2, a3, a4, a5, v19, v20, a8, a9);\n    return (_QWORD *)v21;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 568) = v17;\n    *(_BYTE *)(a1 + 576) = 0;\n    return 0LL;\n  }\n}\n",
    "source_code": "\nint __net_init fib4_rules_init(struct net *net)\n{\n\tint err;\n\tstruct fib_rules_ops *ops;\n\n\tops = fib_rules_register(&fib4_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rules_init(ops);\n\tif (err < 0)\n\t\tgoto fail;\n\tnet->ipv4.rules_ops = ops;\n\tnet->ipv4.fib_has_custom_rules = false;\n\treturn 0;\n\nfail:\n\t/* also cleans all rules already added */\n\tfib_rules_unregister(ops);\n\treturn err;\n}",
    "comment": "Initializes IPv4 fib rules for a specified network, registering operations and setting default rules, or cleaning up on failure.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the IPv4 Forwarding Information Base ( FIB ) and related networking structures for a specified network namespace , handling errors appropriately .\n",
    "cpbcs_sum": "Registers an IPv6 flow table for a network namespace, initializing it, and setting parameters before invoking the registration.\n",
    "misum_sum": "Initializes IP packet mangling for IP packet mangling in the network namespace, allocating necessary tables and handling errors during registration.\n",
    "decom_sum": "Allocates and initializes a structure with specific configuration values, stores it in the context at offset 568, and cleans up on failure.",
    "cfg_sum": "Initializes a data structure with specific parameter validations, cleans up on failure, and stores it in the target object's designated memory fields.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a structure with specific configuration values, stores it in the context at offset 568, and cleans up on failure.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function allocates and initializes a structure with specific configuration values and stores it in the context at offset 568, which does not align with the source code. The code registers fib4 rules ops, initializes them, assigns to net->ipv4.rules_ops, and sets a bool flag, but there is no mention of configuration offsets or a numeric offset like 568. The cleanup on failure part is accurate, but most of the claims are inaccurate or unrelated to actual semantics, leading to a low proportion of accurate statements.",
                "The summary incorrectly describes allocating a structure with configuration values and storing it at a specific offset (568), which is not reflected in the source code. The function actually registers IPv4 fib rules operations for a given network, initializes default rules, assigns the ops to net->ipv4.rules_ops, and cleans up via fib_rules_unregister on failure. The described core purpose is missing and key domain semantics are not covered, making both core and secondary information inaccurate or absent.",
                "The summary incorrectly describes the behavior as allocating and initializing a structure with configuration values and storing it at offset 568, which is not evident in the source code. The actual code registers a rules ops structure via fib_rules_register, initializes default rules, assigns the ops pointer to net->ipv4.rules_ops, and handles failure by unregistering; no offset or explicit allocation step matching the summary exists. This is a FATAL in describing the primary purpose, making the summary unreliable."
            ]
        },
        "cfg": {
            "summary": "Initializes a data structure with specific parameter validations, cleans up on failure, and stores it in the target object's designated memory fields.",
            "score": [
                0.5,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains some accurate general points, such as initialization of a data structure, cleanup on failure, and storing in specific fields, which align with the function's behavior of registering fib rules, setting fields, and unregistering on failure. However, it inaccurately mentions 'specific parameter validations,' which are not present in the source code, and omits key domain-specific details like the use of fib4_rules_ops_template and flags. Roughly half of the claims align with the source, resulting in mixed reliability.",
                "The summary omits the specific core purpose from the source code, which is initializing IPv4 FIB rules by registering operations and setting network fields. While it mentions initialization, parameter validation, storing in memory fields, and cleanup on failure, these are generic descriptions that do not capture the domain-specific FIB rules registration and default setup. This results in no accurate coverage of the core functionality, and the summary lacks details on error checks, network object assignments, and the purpose of fib_default_rules_init.",
                "The summary contains mostly generic and vague statements that do not clearly match the code\u2019s specific behavior. While cleanup on failure is accurate, the claims about 'specific parameter validations' are inaccurate\u2014there is no input validation logic, only error checking for pointer results. The description of storing in 'designated memory fields' is broadly true but lacks specificity about the fields (net->ipv4.rules_ops and fib_has_custom_rules). Overall, noise outweighs any accurate insight, and there are no severe factual contradictions about the core purpose, which is registering IPv4 fib rules and initializing defaults."
            ]
        },
        "comment": {
            "summary": "Initializes IPv4 fib rules for a specified network, registering operations and setting default rules, or cleaning up on failure.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function initializes IPv4 FIB rules for a given network, registers operations, sets default rules, and performs cleanup on failure. These claims align with the source code behavior and are domain-specific, with no inaccurate or irrelevant statements present, resulting in a high proportion of accurate claims.",
                "The summary accurately identifies the core purpose as initializing IPv4 fib rules for a given network, including registration of operations and setting default rules. It also notes the cleanup on failure, which matches the error handling and unregister call in the code. However, it omits some secondary details such as setting `net->ipv4.rules_ops` and `fib_has_custom_rules` to false, as well as the specifics of error checking using `IS_ERR` and `PTR_ERR`. Coverage of key behaviors beyond the core is moderate but not exhaustive.",
                "The summary correctly captures the primary purpose of the function: initializing IPv4 FIB rules for a given network, registering associated operations, setting default rules, and performing cleanup on failure. All claims are accurate and directly supported by the source code with no noise or contradictions. The summary is concise and domain-specific, giving a clear high-level description without errors. While it lacks deeper technical detail such as specific struct assignments or error handling paths, it still provides meaningful insight."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 173008,
    "strip_function_name": "sub_2A3D0",
    "strip_decompiled_code": "__int64 __fastcall sub_2A3D0(\n        __int16 a1,\n        __int16 a2,\n        unsigned __int16 a3,\n        unsigned __int16 a4,\n        _QWORD *a5,\n        __int16 a6,\n        __int16 a7,\n        unsigned __int16 a8,\n        unsigned __int16 a9,\n        __int64 *a10)\n{\n  int v11; // edx\n  int v12; // r10d\n  __int64 v13; // rdi\n  __int64 *v14; // rsi\n  __int64 v15; // r8\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rcx\n\n  if ( a3 - a4 >= a8 - a9 || a4 < a9 || a1 >= a6 && (a1 > a6 || a2 > a7) )\n    return 0LL;\n  v11 = a3 - 1;\n  if ( v11 != -1 )\n  {\n    v12 = a8 - 1;\n    v13 = 8LL * v12;\n    v14 = (__int64 *)(*a5 + 8LL * v11);\n    v15 = (__int64)&v14[-v11 - 1];\n    while ( 1 )\n    {\n      v16 = *v14;\n      if ( *v14 )\n      {\n        if ( !a8 )\n          return 0LL;\n        v17 = *a10;\n        if ( v16 != *(_QWORD *)(*a10 + 8LL * v12) )\n          break;\n      }\nLABEL_17:\n      if ( --v14 == (__int64 *)v15 )\n        return 1LL;\n    }\n    v18 = v17 + v13 - 8;\n    v19 = v17 + v13 - 8 - 8LL * (unsigned int)v12;\n    while ( v18 != v19 )\n    {\n      v18 -= 8LL;\n      if ( v16 == *(_QWORD *)(v18 + 8) )\n        goto LABEL_17;\n    }\n    return 0LL;\n  }\n  return 1LL;\n}\n",
    "function_name": "whereLoopCheaperProperSubset",
    "decompiled_code": "__int64 __fastcall whereLoopCheaperProperSubset(\n        const WhereLoop *pX,\n        const WhereLoop *pY,\n        unsigned __int16 a3,\n        unsigned __int16 a4,\n        _QWORD *a5,\n        __int16 a6,\n        __int64 a7,\n        __int64 a8,\n        unsigned __int16 a9,\n        __int64 *a10)\n{\n  int v11; // edx\n  int v12; // r10d\n  __int64 v13; // rdi\n  __int64 *v14; // rsi\n  __int64 v15; // r8\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rcx\n\n  if ( a3 - a4 >= (unsigned __int16)a8 - a9\n    || a4 < a9\n    || (__int16)pX >= a6 && ((__int16)pX > a6 || (__int16)pY > (__int16)a7) )\n  {\n    return 0LL;\n  }\n  v11 = a3 - 1;\n  if ( v11 != -1 )\n  {\n    v12 = (unsigned __int16)a8 - 1;\n    v13 = 8LL * v12;\n    v14 = (__int64 *)(*a5 + 8LL * v11);\n    v15 = (__int64)&v14[-v11 - 1];\n    while ( 1 )\n    {\n      v16 = *v14;\n      if ( *v14 )\n      {\n        if ( !(_WORD)a8 )\n          return 0LL;\n        v17 = *a10;\n        if ( v16 != *(_QWORD *)(*a10 + 8LL * v12) )\n          break;\n      }\nLABEL_17:\n      if ( --v14 == (__int64 *)v15 )\n        return 1LL;\n    }\n    v18 = v17 + v13 - 8;\n    v19 = v17 + v13 - 8 - 8LL * (unsigned int)v12;\n    while ( v18 != v19 )\n    {\n      v18 -= 8LL;\n      if ( v16 == *(_QWORD *)(v18 + 8) )\n        goto LABEL_17;\n    }\n    return 0LL;\n  }\n  return 1LL;\n}\n",
    "source_code": "static int whereLoopCheaperProperSubset(\n  const WhereLoop *pX,       /* First WhereLoop to compare */\n  const WhereLoop *pY        /* Compare against this WhereLoop */\n){\n  int i, j;\n  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){\n    return 0; /* X is not a subset of Y */\n  }\n  if( pY->nSkip > pX->nSkip ) return 0;\n  if( pX->rRun >= pY->rRun ){\n    if( pX->rRun > pY->rRun ) return 0;    /* X costs more than Y */\n    if( pX->nOut > pY->nOut ) return 0;    /* X costs more than Y */\n  }\n  for(i=pX->nLTerm-1; i>=0; i--){\n    if( pX->aLTerm[i]==0 ) continue;\n    for(j=pY->nLTerm-1; j>=0; j--){\n      if( pY->aLTerm[j]==pX->aLTerm[i] ) break;\n    }\n    if( j<0 ) return 0;  /* X not a subset of Y since term X[i] not used by Y */\n  }\n  return 1;  /* All conditions meet */\n}",
    "comment": "Determines if WhereLoop `pX` is a proper subset of WhereLoop `pY` based on terms, costs, and skip values.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Adds a new rule to a list if it falls within the specified interval defined by start and end points .\n",
    "cpbcs_sum": "Searches for a specified offset within a multi-precision range of a multi-precision number, using binary search and returns the value of the first operand.\n",
    "misum_sum": "Finds the nearest source node in a given destination buffer for a specified direction and updates the skip range accordingly.\n",
    "decom_sum": "Checks coordinate bounds and verifies matching 64\u2011bit entries between two grids, returning success if all relevant positions contain identical non\u2011zero values.",
    "cfg_sum": "Validates coordinate and index ranges, checks linked data arrays for matching elements, and returns success only if all structural and value comparisons pass.",
    "work_score": {
        "decom": {
            "summary": "Checks coordinate bounds and verifies matching 64\u2011bit entries between two grids, returning success if all relevant positions contain identical non\u2011zero values.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes operations on coordinate bounds and matching 64-bit entries in grids, which does not match the source code's actual logic. The function compares two WhereLoop structures to determine if one is a cheaper proper subset based on term counts, skips, costs, and specific matching terms, not grid coordinates or 64-bit values. All claims are inaccurate with respect to the source code semantics.",
                "The summary makes claims about checking coordinate bounds and matching 64\u2011bit entries between two grids, which do not correspond to any behavior in the source code. The function actually compares two WhereLoop structures to determine if one is a cheaper proper subset, based on term counts, skip counts, run costs, output sizes, and membership of terms, returning 1 only if all conditions are satisfied. The core purpose is entirely absent from the summary, and no accurate claims are present.",
                "The summary is entirely inaccurate: it describes checking coordinate bounds and matching 64-bit grid entries, which is unrelated to the actual function that compares two WhereLoop objects for a cheaper proper subset based on term counts, skip values, run cost, output count, and matching term pointers. This is a severe FATAL error on the primary purpose, meaning the description contradicts the core semantics and makes the function unusable if relied upon."
            ]
        },
        "cfg": {
            "summary": "Validates coordinate and index ranges, checks linked data arrays for matching elements, and returns success only if all structural and value comparisons pass.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about validating coordinate and index ranges and checking linked data arrays are not aligned with the actual function, which compares properties of two WhereLoop objects to determine if one is a cheaper proper subset of the other. It does perform matching element checks between arrays, but the summary omits key semantics such as cost and skip term comparisons, and incorrectly frames the checks in terms of coordinates. Most claims do not accurately describe the code\u2019s domain-specific behavior, resulting in low precision.",
                "The summary does not identify the core purpose, which is to determine if one WhereLoop is a proper, cheaper subset of another by comparing term counts, skips, costs, and ensuring all terms appear in the other. Instead, it inaccurately describes coordinate and index validation, which is unrelated to the code semantics, and fails to capture this domain-specific subset and cost comparison logic.",
                "The summary contains mostly inaccurate claims. It describes validating coordinate and index ranges and checking linked data arrays, which do not match the function\u2019s actual purpose\u2014comparing two WhereLoop objects to determine if one is a cheaper proper subset of the other based on term counts, skip counts, run cost, output count, and matching terms. The worst failure mode is FATAL, as the primary purpose and key logic are misrepresented, making the summary misleading for understanding the function\u2019s core behavior."
            ]
        },
        "comment": {
            "summary": "Determines if WhereLoop `pX` is a proper subset of WhereLoop `pY` based on terms, costs, and skip values.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary captures the core behavior: checking if pX is a proper subset of pY using loop terms, run cost, output count, and skip values. These elements are directly supported by the source code's conditions and comparisons. It omits some implementation specifics like exact comparison logic for rRun and nOut, but all mentioned aspects are accurate and domain-relevant, making the proportion of accurate claims high.",
                "The summary correctly identifies the core purpose: checking if pX is a proper subset of pY using conditions on terms, costs, and skip values, which matches the function's domain behavior. However, it lacks detail on specific comparison logic such as the exact cost metrics (rRun, nOut), the condition that nSkip of pY must not exceed that of pX, and the exact method of verifying term inclusion via array iteration. While core is covered, secondary behavioral nuances and all edge case checks are omitted, limiting completeness.",
                "The summary is broadly accurate and correctly identifies the primary purpose: checking if pX is a proper subset of pY by comparing terms, costs, and skip values. However, it is generic and lacks specific implementation details such as exact comparison logic for nLTerm - nSkip, cost and output conditions, and term membership checks. There are no incorrect or contradictory statements, but the gain is low due to minimal detail beyond the general description."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582135650,
    "strip_function_name": "sub_FFFFFFFF81323562",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81323562(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 *v8; // rbx\n  __int64 result; // rax\n  _WORD *v10; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  _WORD *v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  _WORD *v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n\n  v8 = qword_FFFFFFFF81E9EAC0;\n  while ( 1 )\n  {\n    if ( !*v8 )\n    {\n      result = sub_FFFFFFFF812FBA00(a1, a2, a3, a4, a5, a6, a7, a8, 1LL, 1, v8);\n      v8[2] = 0LL;\n      *((_DWORD *)v8 + 2) = 0;\n      if ( (_DWORD)result )\n        break;\n    }\n    v8 += 3;\n    if ( &byte_FFFFFFFF81E9EB80 == (char *)v8 )\n    {\n      v10 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, a5, a6, a7, a8);\n      if ( !v10 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA80 = (__int64)v10;\n      *v10 = 0;\n      v13 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, v11, v12, a7, a8);\n      if ( !v13 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA78 = (__int64)v13;\n      *v13 = 0;\n      v16 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, v14, v15, a7, a8);\n      if ( !v16 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA70 = (__int64)v16;\n      *v16 = 0;\n      result = sub_FFFFFFFF812FBA00(a1, a2, a3, a4, v17, v18, a7, a8, 1LL, 1, &qword_FFFFFFFF81E9EA68);\n      if ( !(_DWORD)result )\n        return sub_FFFFFFFF81323160((__int64)&unk_FFFFFFFF81E9EA50, a1, a2, a3, a4, v19, v20, a7, a8);\n      return result;\n    }\n  }\n  return result;\n}\n",
    "function_name": "acpi_ut_mutex_initialize",
    "decompiled_code": "__int64 __fastcall acpi_ut_mutex_initialize(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 *v8; // rbx\n  __int64 result; // rax\n  __int64 *constprop_0; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 *v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 *v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n\n  v8 = acpi_gbl_mutex_info;\n  while ( 1 )\n  {\n    if ( !*v8 )\n    {\n      result = acpi_os_create_semaphore(a1, a2, a3, a4, a5, a6, a7, a8, 1LL, 1, (__int64 **)v8);\n      v8[2] = 0LL;\n      *((_DWORD *)v8 + 2) = 0;\n      if ( (_DWORD)result )\n        break;\n    }\n    v8 += 3;\n    if ( &acpi_gbl_integer_nybble_width == (char *)v8 )\n    {\n      constprop_0 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, a5, a6, a7, a8);\n      if ( !constprop_0 )\n        return 4LL;\n      acpi_gbl_gpe_lock = (__int64)constprop_0;\n      *(_WORD *)constprop_0 = 0;\n      v13 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, v11, v12, a7, a8);\n      if ( !v13 )\n        return 4LL;\n      acpi_gbl_hardware_lock = (__int64)v13;\n      *(_WORD *)v13 = 0;\n      v16 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, v14, v15, a7, a8);\n      if ( !v16 )\n        return 4LL;\n      acpi_gbl_reference_count_lock = (__int64)v16;\n      *(_WORD *)v16 = 0;\n      result = acpi_os_create_semaphore(a1, a2, a3, a4, v17, v18, a7, a8, 1LL, 1, (__int64 **)&acpi_gbl_osi_mutex);\n      if ( !(_DWORD)result )\n        return acpi_ut_create_rw_lock((__int64)acpi_gbl_namespace_rw_lock, a1, a2, a3, a4, v19, v20, a7, a8);\n      return result;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nacpi_status acpi_ut_mutex_initialize(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_initialize);\n\n\t/* Create each of the predefined mutex objects */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tstatus = acpi_ut_create_mutex(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t/* Create the spinlocks for use at interrupt level or for speed */\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_gpe_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_hardware_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_reference_count_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Mutex for _OSI support */\n\n\tstatus = acpi_os_create_mutex(&acpi_gbl_osi_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Create the reader/writer lock for namespace access */\n\n\tstatus = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_ACPI_STATUS(status);\n}",
    "comment": "Initializes predefined mutexes and locks for synchronization, including mutexes for _OSI support and a reader/writer lock for namespace access.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the ACPI processor routing table , ensuring no duplicate tables for the same module are registered , while ensuring thread safety with mutexes .\n",
    "cpbcs_sum": "Initializes ACPI table management by allocating an array, setting dimensions, and executing callbacks for the global root table list.\n",
    "misum_sum": "Initializes the ACPI table management by allocating memory, registering the device and setting up sysfs, while handling potential memory allocation errors.\n",
    "decom_sum": "Initializes multiple global buffers and invokes a setup routine for each entry until successful, then performs final processing or returns an error code.",
    "cfg_sum": "Initializes and clears buffer entries, allocates required memory blocks, invokes setup routines, and executes final processing, returning corresponding success or failure status codes.",
    "work_score": {
        "decom": {
            "summary": "Initializes multiple global buffers and invokes a setup routine for each entry until successful, then performs final processing or returns an error code.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains inaccuracies: it describes initializing 'multiple global buffers', which is not present in the source code, and suggests looping 'until successful', whereas the code loops over predefined mutex creation and returns on failure. It omits mention of mutexes, locks, and specific ACPI functions that are central to the actual behavior. Most claims are misaligned with the code's semantics, resulting in low accuracy.",
                "The summary incorrectly states that the function initializes global buffers, which do not appear in the code, and describes iterating until successful rather than creating predefined mutexes and various locks with early returns on failure. The core purpose\u2014initializing all ACPI predefined mutexes, spinlocks, and other synchronization primitives\u2014is not covered with domain-specific accuracy, and no additional key behaviors or error-handling specifics are correctly mentioned.",
                "The summary's core claims are inaccurate: it describes initialization of global buffers and processing entries until successful, which contradicts the source code. The function actually initializes predefined mutexes in a loop until a failure occurs, then creates multiple locks and a mutex, finishing with a reader/writer lock before returning status. The mismatch in both the type of objects initialized (buffers vs. mutexes/locks) and the control flow logic (success vs. failure) is a severe FATAL error on the primary purpose, making the description untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Initializes and clears buffer entries, allocates required memory blocks, invokes setup routines, and executes final processing, returning corresponding success or failure status codes.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains claims about clearing buffer entries, allocating memory blocks, and executing final processing, which are not present in the source code. The function actually creates mutexes, spinlocks, and a reader/writer lock, handling errors accordingly, but these details are missing or misrepresented in the summary. None of the claims accurately reflect the code\u2019s semantics, leading to low alignment.",
                "The summary's claims about clearing buffer entries, allocating memory blocks, and executing final processing do not align with the source code, which initializes predefined mutexes, spinlocks, a mutex for _OSI support, and a reader/writer lock. No accurate claim covers the core purpose of creating synchronization primitives for ACPI, so the core is missing and all claims are inaccurate.",
                "The summary contains multiple FATAL inaccuracies about the function's primary purpose. It incorrectly describes actions such as clearing buffer entries, allocating memory blocks, and executing final processing, none of which occur in the source code. The actual code creates predefined mutexes, spinlocks, and a reader/writer lock, returning status codes upon failure, which is entirely different. These mismatches target core functionality and I/O behavior, making the description untrustworthy."
            ]
        },
        "comment": {
            "summary": "Initializes predefined mutexes and locks for synchronization, including mutexes for _OSI support and a reader/writer lock for namespace access.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function initializes predefined mutexes and various locks, including one for _OSI support and a reader/writer lock for namespace access. These details match the source code\u2019s behavior precisely, without introducing errors or unrelated claims. All fact-based claims are accurate and grounded in the function\u2019s semantics, indicating high alignment.",
                "The summary accurately states the core purpose: initializing predefined mutexes and various locks, with specifics like _OSI support and a reader/writer lock for namespace access that match the source code. However, it omits other secondary details such as the creation of spinlocks for interrupt level use and speed, and does not mention the looped creation of ACPI_NUM_MUTEX objects or error handling for each creation step, leaving coverage incomplete.",
                "The summary correctly captures the primary purpose of the function, namely initializing predefined mutexes and various locks, including specific mention of the _OSI support mutex and the reader/writer lock for namespace access. All claims are accurate and aligned with the source code, with no contradictory statements or unrelated noise. While the summary is concise and omits finer details such as the creation of spinlocks for interrupt-level work, its coverage of key synchronization objects is specific and informative."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581323728,
    "strip_function_name": "sub_FFFFFFFF8125D1D0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8125D1D0(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // rbx\n  __int64 v12; // r14\n  unsigned __int64 v13; // rbx\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 v21; // rax\n  volatile signed __int32 *v22; // rdi\n\n  v11 = *a3;\n  *a3 = 0LL;\n  v12 = *(_QWORD *)(a1 + 152);\n  v13 = v11 & 0xFFFFFFFFFFFFFFFELL;\n  _InterlockedIncrement((volatile signed __int32 *)a2);\n  v14 = sub_FFFFFFFF81083DC0();\n  *(_QWORD *)(a2 + 96) = v14;\n  *(_QWORD *)(a1 + 96) = v14;\n  if ( v13 )\n  {\n    *(_QWORD *)(v13 + 8LL * *(unsigned __int16 *)(v13 + 20) + 24) = a2;\n    *(_QWORD *)(a1 + 152) = v13;\n    if ( v12 )\n      sub_FFFFFFFF810BA6C0((_QWORD *)v12, (__int64)sub_FFFFFFFF8125C4B0, v15, v16, v17, v18);\n  }\n  else\n  {\n    v21 = *(unsigned __int16 *)(v12 + 20);\n    if ( (unsigned __int16)v21 < *(_WORD *)(v12 + 18) )\n    {\n      v22 = *(volatile signed __int32 **)(v12 + 8 * v21 + 24);\n      *(_QWORD *)(v12 + 8LL * *(unsigned __int16 *)(v12 + 20) + 24) = a2;\n      sub_FFFFFFFF8125B5F0(v22, a4, a5, a6, a7, v19, v20, a10, a11, a2, v15, v16, v17, v18);\n    }\n    else\n    {\n      *(_QWORD *)(v12 + 8 * v21 + 24) = a2;\n      ++*(_WORD *)(v12 + 18);\n    }\n  }\n}\n",
    "function_name": "__key_link",
    "decompiled_code": "void __fastcall _key_link(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // rbx\n  __int64 v12; // r14\n  unsigned __int64 v13; // rbx\n  __int64 v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 v17; // rax\n  volatile signed __int32 *v18; // rdi\n\n  v11 = *a3;\n  *a3 = 0LL;\n  v12 = *(_QWORD *)(a1 + 152);\n  v13 = v11 & 0xFFFFFFFFFFFFFFFELL;\n  _InterlockedIncrement((volatile signed __int32 *)a2);\n  v14 = current_kernel_time();\n  *(_QWORD *)(a2 + 96) = v14;\n  *(_QWORD *)(a1 + 96) = v14;\n  if ( v13 )\n  {\n    *(_QWORD *)(v13 + 8LL * *(unsigned __int16 *)(v13 + 20) + 24) = a2;\n    *(_QWORD *)(a1 + 152) = v13;\n    if ( v12 )\n      call_rcu_sched((_QWORD *)v12, (__int64)keyring_unlink_rcu_disposal, a4, a5, a6, a7, v15, v16, a10, a11);\n  }\n  else\n  {\n    v17 = *(unsigned __int16 *)(v12 + 20);\n    if ( (unsigned __int16)v17 < *(_WORD *)(v12 + 18) )\n    {\n      v18 = *(volatile signed __int32 **)(v12 + 8 * v17 + 24);\n      *(_QWORD *)(v12 + 8LL * *(unsigned __int16 *)(v12 + 20) + 24) = a2;\n      key_put(v18, a4, a5, a6, a7, v15, v16, a10, a11);\n    }\n    else\n    {\n      *(_QWORD *)(v12 + 8 * v17 + 24) = a2;\n      ++*(_WORD *)(v12 + 18);\n    }\n  }\n}\n",
    "source_code": "void __key_link(struct key *keyring, struct key *key,\n\t\tunsigned long *_prealloc)\n{\n\tstruct keyring_list *klist, *nklist;\n\tstruct key *discard;\n\n\tnklist = (struct keyring_list *)(*_prealloc & ~KEY_LINK_FIXQUOTA);\n\t*_prealloc = 0;\n\n\tkenter(\"%d,%d,%p\", keyring->serial, key->serial, nklist);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\n\tatomic_inc(&key->usage);\n\tkeyring->last_used_at = key->last_used_at =\n\t\tcurrent_kernel_time().tv_sec;\n\n\t/* there's a matching key we can displace or an empty slot in a newly\n\t * allocated list we can fill */\n\tif (nklist) {\n\t\tkdebug(\"reissue %hu/%hu/%hu\",\n\t\t       nklist->delkey, nklist->nkeys, nklist->maxkeys);\n\n\t\tRCU_INIT_POINTER(nklist->keys[nklist->delkey], key);\n\n\t\trcu_assign_pointer(keyring->payload.subscriptions, nklist);\n\n\t\t/* dispose of the old keyring list and, if there was one, the\n\t\t * displaced key */\n\t\tif (klist) {\n\t\t\tkdebug(\"dispose %hu/%hu/%hu\",\n\t\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\t\t\tcall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\n\t\t}\n\t} else if (klist->delkey < klist->nkeys) {\n\t\tkdebug(\"replace %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tdiscard = rcu_dereference_protected(\n\t\t\tklist->keys[klist->delkey],\n\t\t\trwsem_is_locked(&keyring->sem));\n\t\trcu_assign_pointer(klist->keys[klist->delkey], key);\n\t\t/* The garbage collector will take care of RCU\n\t\t * synchronisation */\n\t\tkey_put(discard);\n\t} else {\n\t\t/* there's sufficient slack space to append directly */\n\t\tkdebug(\"append %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tRCU_INIT_POINTER(klist->keys[klist->delkey], key);\n\t\tsmp_wmb();\n\t\tklist->nkeys++;\n\t}\n}",
    "comment": "Links a key to a keyring, replacing an existing key if necessary, while managing memory and usage references appropriately.",
    "hext5_sum": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
    "bint5_sum": "Removes a key from a keyring by decrementing its reference count , removing it from the keyring list , and freeing the associated memory .\n",
    "cpbcs_sum": "Appends a message to a new keyring structure, updating timestamps, and managing reference counts for the old one or incrementing garbage collection accordingly.\n",
    "misum_sum": "Links a new keyring to a keyring by creating a new keyring and updating the old name and name.\n",
    "decom_sum": "Initializes and links an object into a table, updating reference counts and invoking callbacks to integrate it into an existing structure.",
    "cfg_sum": "Updates object linkage and counters, assigns identifiers, and conditionally invokes handlers to insert or replace entries in a structured list.",
    "work_score": {
        "decom": {
            "summary": "Initializes and links an object into a table, updating reference counts and invoking callbacks to integrate it into an existing structure.",
            "score": [
                0.2,
                0.3,
                0.4
            ],
            "reason": [
                "The summary correctly notes linking an object and updating reference counts, which matches the function\u2019s behavior of adding a key to a keyring and increasing usage. However, it is overly generic, describing it as linking into a table and invoking callbacks, which does not reflect the specific logic of handling keyring lists, RCU operations, and time updates in the source. These inaccuracies and lack of domain-specific details reduce the proportion of accurate claims to well below half.",
                "The summary captures generic actions like linking an object, updating references, and invoking callbacks, which align loosely with the code\u2019s linking of a key into a keyring list and managing usage counts. However, it fails to state the core domain-specific purpose of linking a 'struct key' into a keyring with specific replacement or append logic under RCU, omitting critical branch behavior, displaced key handling, and timing updates. Coverage is generic and lacks the specific keyring manipulation semantics.",
                "The summary provides a very generic description, loosely matching the function's behavior but lacking specifics about the keyring context, handling of preallocated lists, conditional replacement/appending, and RCU-based disposal. While reference count updating is mentioned accurately, other primary purpose details are vague, and 'invoking callbacks' is misleading since the code does not perform arbitrary callbacks beyond internal disposal via call_rcu. Overall, there is no fatal contradiction, but noise from generic wording outweighs the limited accurate content, resulting in low net benefit."
            ]
        },
        "cfg": {
            "summary": "Updates object linkage and counters, assigns identifiers, and conditionally invokes handlers to insert or replace entries in a structured list.",
            "score": [
                0.5,
                0.2,
                0.4
            ],
            "reason": [
                "The summary captures some accurate aspects such as updating counters and conditionally inserting or replacing entries in a list, matching the code's behavior. However, it omits key specific details like RCU pointer operations, how discarded keys are handled, and the list replacement/append logic. The mention of 'assigns identifiers' is inaccurate since the function does not assign identifiers, making the coverage incomplete and slightly misleading.",
                "The summary gives a generic description of updating linkages, counters, and conditional insertion/replacement in a list but does not specify the core domain purpose of linking a key into a keyring structure using RCU operations. While parts about insertion/replacement in a structured list and updating counters are accurate, the absence of explicit mention of keyring/key semantics means the core primary purpose is not covered. There is minimal secondary coverage of other behaviors like time updates, preallocation handling, or disposal of displaced keys.",
                "The summary contains mostly vague, generic claims like updating linkage, counters, assigning identifiers, and conditionally invoking handlers, which do not clearly map to the specific semantics in the source code. Core details such as the use of RCU operations, replacement vs append logic, and usage count adjustments are either missing or oversimplified. No outright contradictions are present, but the lack of specificity means gain is low and noise is high, resulting in limited utility."
            ]
        },
        "comment": {
            "summary": "Links a key to a keyring, replacing an existing key if necessary, while managing memory and usage references appropriately.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function links a key to a keyring and may replace an existing key, aligning with the core semantics of the code. It also notes memory and usage reference management, which is accurate as the function updates usage counts and disposes of old keys via RCU mechanisms. Although generic, these points are fact-based and directly tied to the implementation, with no incorrect or irrelevant claims present.",
                "The summary correctly identifies the core action of linking a key to a keyring with the possibility of replacing an existing key, which aligns with the function's primary purpose. However, it omits important secondary details present in the code, such as the handling of preallocated keyring lists, various conditional branches for replacing, appending, or reallocating keys, timestamp updates, usage count increments, and specific RCU-based memory management operations. This results in only minimal secondary coverage beyond the core action.",
                "The summary correctly states the primary purpose of linking a key to a keyring and mentions replacement of an existing key, which matches the code\u2019s behavior in both the nklist and replace branches. It also accurately notes memory management and usage reference handling, reflecting atomic_inc usage, key_put, and disposal of old lists. There are no false or irrelevant claims, but the description is broad and lacks specifics about the conditional branching and exact steps taken, giving only generic insight."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 599168,
    "strip_function_name": "sub_92480",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_92480(\n        __int64 a1,\n        char *p_buf,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  __int64 v10; // rbp\n  __int64 *v11; // rbx\n  __int64 v12; // r12\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  _QWORD *v19; // rax\n  _QWORD *v20; // rdx\n  char buf; // [rsp+7h] [rbp-21h] BYREF\n  unsigned __int64 v23; // [rsp+8h] [rbp-20h]\n\n  v10 = *(_QWORD *)a1;\n  v23 = __readfsqword(0x28u);\n  if ( (*(_BYTE *)(v10 + 226) & 1) != 0\n    || (*(_BYTE *)(*(_QWORD *)(v10 + 8) + 9LL) & 4) != 0\n    || (p_buf = &buf, (unsigned int)recv(*(_DWORD *)(v10 + 24), &buf, 1uLL, 2) != -1)\n    || *__errno_location() != 11\n    || (*(_BYTE *)(a1 + 8) &= ~0x20u, p_buf = 0LL, ngx_handle_read_event(*(_QWORD *)(v10 + 8), 0LL)) )\n  {\n    v11 = *(__int64 **)v10;\n    v12 = **(_QWORD **)v10;\n    ngx_destroy_pool(*(_QWORD **)(v10 + 88));\n    ngx_close_connection(v10, a3, a4, a5, a6, v17, v18, a9, a10, (__int64)p_buf, v13, v14, v15, v16);\n    v19 = (_QWORD *)v11[2];\n    *v19 = v11[1];\n    *(_QWORD *)(v11[1] + 8) = v19;\n    v20 = *(_QWORD **)(v12 + 48);\n    v11[2] = (__int64)v20;\n    *v20 = v11 + 1;\n    v11[1] = v12 + 40;\n    *(_QWORD *)(v12 + 48) = v11 + 1;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "function_name": "ngx_http_upstream_keepalive_close_handler",
    "decompiled_code": "void __fastcall ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)\n{\n  ngx_connection_t *data; // rbp\n  ngx_pool_t *v2; // rbx\n  __int64 v3; // r12\n  ngx_pool_t *next; // rax\n  u_char ***v5; // rdx\n  char buf[1]; // [rsp+7h] [rbp-21h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  data = (ngx_connection_t *)ev->data;\n  v7 = __readfsqword(0x28u);\n  if ( (*((_BYTE *)data + 226) & 1) != 0\n    || (*((_BYTE *)data->read + 9) & 4) != 0\n    || (unsigned int)recv(data->fd, buf, 1uLL, 2) != -1\n    || *__errno_location() != 11\n    || (*((_BYTE *)ev + 8) &= ~0x20u, ngx_handle_read_event(data->read, 0LL)) )\n  {\n    v2 = (ngx_pool_t *)data->data;\n    v3 = *(_QWORD *)data->data;\n    ngx_destroy_pool(data->pool);\n    ngx_close_connection(data);\n    next = v2->d.next;\n    next->d.last = v2->d.end;\n    *((_QWORD *)v2->d.end + 1) = next;\n    v5 = *(u_char ****)(v3 + 48);\n    v2->d.next = (ngx_pool_t *)v5;\n    *v5 = &v2->d.end;\n    v2->d.end = (u_char *)(v3 + 40);\n    *(_QWORD *)(v3 + 48) = &v2->d.end;\n  }\n}\n",
    "source_code": "\n\nstatic void\nngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)\n{\n    ngx_http_upstream_keepalive_srv_conf_t  *conf;\n    ngx_http_upstream_keepalive_cache_t     *item;\n\n    int                n;\n    char               buf[1];\n    ngx_connection_t  *c;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,\n                   \"keepalive close handler\");\n\n    c = ev->data;\n\n    if (c->close || c->read->timedout) {\n        goto close;\n    }\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {\n        ev->ready = 0;\n\n        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n            goto close;\n        }\n\n        return;\n    }\n\nclose:\n\n    item = c->data;\n    conf = item->conf;\n\n    ngx_http_upstream_keepalive_close(c);\n\n    ngx_queue_remove(&item->queue);\n    ngx_queue_insert_head(&conf->free, &item->queue);\n}",
    "comment": "Closes an upstream keepalive connection, handling read timeouts and queue management for connection reuse.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Appends a string to a dynamic buffer , ensuring it is null-terminated and handling potential errors during the write process .\n",
    "cpbcs_sum": "Flushes the file buffer to the archive, destroys it if necessary, and removes the file from the archive, logging the operation.\n",
    "misum_sum": "The function Flushes a file descriptor either using an I/O or IO file descriptor based on the cache's mode.\n",
    "decom_sum": "Closes an nginx network connection on error or event, cleans associated memory pool, and updates linked connection structures.",
    "cfg_sum": "Closes a network connection on error or event conditions, frees associated memory pool, and updates linked list pointers for connection management.",
    "work_score": {
        "decom": {
            "summary": "Closes an nginx network connection on error or event, cleans associated memory pool, and updates linked connection structures.",
            "score": [
                0.5,
                0.4,
                0.4
            ],
            "reason": [
                "The summary makes three claims: closing the nginx network connection on error/event, cleaning the associated memory pool, and updating linked connection structures. The first claim is accurate \u2014 the function closes the connection when certain conditions occur. The second claim is inaccurate because there is no evidence in the source code of memory pool cleanup; it only adjusts queue structures. The third claim is partially accurate \u2014 the function updates connection-related data structures, specifically moving the cache item in a queue. Since only about half of the claims are accurate, alignment is mixed.",
                "The summary correctly identifies that the function closes an nginx network connection based on certain events or errors, which aligns with the core purpose of the code. However, it inaccurately claims that it cleans an associated memory pool, which is not present in the source; instead, the function manages a keepalive cache item by removing it from one queue and adding it to another. This mismatch reduces accuracy, and the summary omits key specifics such as handling MSG_PEEK/errno checks, ready state updates, and re-registering read events. Secondary details are minimal and partially incorrect, limiting completeness.",
                "The summary correctly notes that the function closes an nginx network connection on certain events or conditions, but inaccurately claims it cleans an associated memory pool, which is not shown in the code. It also generically mentions updating linked connection structures without specifying that it moves the connection's queue item to the free list, making this low-info. The worst issue is the inaccurate memory pool claim (NOISE), and overall the accurate portion is minimal and generic."
            ]
        },
        "cfg": {
            "summary": "Closes a network connection on error or event conditions, frees associated memory pool, and updates linked list pointers for connection management.",
            "score": [
                0.5,
                0.3,
                0.2
            ],
            "reason": [
                "The summary correctly notes closing a network connection under certain conditions and updating linked list pointers for management, aligning with the code's behavior. However, it inaccurately claims that the function frees an associated memory pool, which is not present in the source code. This results in mixed accuracy, with roughly half of the claims being correct.",
                "The summary correctly states that the function closes a network connection on certain conditions and updates linked list pointers, which aligns with the source code's detection of close/timedout events and subsequent queue element re-linking. However, it inaccurately claims freeing of an associated memory pool, a behavior not present in the source, and it does not explicitly cover the core purpose of handling upstream keepalive connections by reassigning them to a free list on closure. Additionally, key condition handling (MSG_PEEK read, EAGAIN logic, event re-registration on non-fatal read conditions) is omitted.",
                "The summary correctly notes that the function closes a network connection under certain conditions and updates linked list pointers, which matches the source code. However, it inaccurately claims that the function frees an associated memory pool\u2014this is not present in the code, which only moves the cache item to a free queue without explicit memory deallocation. This introduces a factual error about a core side effect related to resource management, making it a FATAL issue. As this misstates a key purpose, the overall trustworthiness is significantly reduced."
            ]
        },
        "comment": {
            "summary": "Closes an upstream keepalive connection, handling read timeouts and queue management for connection reuse.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly identifies that the function closes an upstream keepalive connection and handles read timeouts, which matches the code\u2019s check for `c->close` or `c->read->timedout`. It also notes queue management for connection reuse, aligning with removal from the active queue and insertion into the free queue. All claims are accurate and grounded in the source code semantics, with no contradictory or irrelevant statements.",
                "The summary correctly captures the core purpose of closing an upstream keepalive connection and mentions handling read timeouts and queue management for reuse, which aligns with the code's main behavior. However, it omits secondary details such as the peek-read check via recv with MSG_PEEK, the specific condition for close based on c->close or timedout, the handling of EAGAIN including disabling readiness and re-registering read events, and the explicit queue removal/insert operations. Coverage of these secondary semantics is minimal, making the description incomplete beyond the core.",
                "The summary correctly captures the core purpose of the function: closing an upstream keepalive connection, handling read timeouts, and managing queue placement for connection reuse. These are accurate and specific reflections of the code's behavior, with no contradictory or irrelevant statements. The claims are concise and cover the primary purpose and side effects, providing moderately high informational value with minimal noise."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4389008,
    "strip_function_name": "sub_42F890",
    "strip_decompiled_code": "int __fastcall sub_42F890(FILE *stream, int a2, int a3)\n{\n  char **v4; // rbx\n  int v5; // edx\n  unsigned int v6; // ebp\n  char *v7; // rax\n  char *v8; // rcx\n  int v9; // r8d\n  char **v10; // rbx\n  const char *v11; // rcx\n  int v12; // r8d\n  int v14[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v4 = &off_4FBB00;\n  v5 = 0;\n  v6 = 0;\n  v7 = asc_7D76E0 + 27;\n  v14[0] = 54;\n  while ( 1 )\n  {\n    if ( !v5 )\n    {\n      v8 = *v4;\n      v9 = *((_DWORD *)v4 + 2);\n      if ( **v4 == 46 )\n      {\n        if ( a2 )\n        {\n          ++v8;\n          --v9;\nLABEL_5:\n          v7 = (char *)sub_42F7E0(stream, v7, v14, v8, v9);\n        }\n      }\n      else if ( !a2 && (!a3 || (*((_BYTE *)&xmmword_4FBB10 + 40 * v6) & 4) != 0) )\n      {\n        goto LABEL_5;\n      }\n    }\n    ++v6;\n    v4 += 5;\n    if ( v6 == 124 )\n      break;\n    v5 = *((_DWORD *)v4 + 8);\n  }\n  if ( a2 )\n  {\n    v10 = &off_4FB780;\n    v11 = \"no87\";\n    v12 = 4;\n    while ( 1 )\n    {\n      v7 = (char *)sub_42F7E0(stream, v7, v14, v11, v12);\n      if ( v10 == &off_4FBB00 )\n        break;\n      v12 = *((_DWORD *)v10 + 2);\n      v11 = *v10;\n      v10 += 4;\n    }\n  }\n  *v7 = 0;\n  return fprintf(stream, \"%s\\n\", asc_7D76E0);\n}\n",
    "function_name": "show_arch",
    "decompiled_code": "void __fastcall show_arch(FILE *a1, int a2, int a3, char *name, int *len, const char *a6)\n{\n  const arch_entry *v7; // rbx\n  unsigned int skip; // edx\n  int v9; // ebp\n  char *v10; // rax\n  const arch_entry *v11; // rbx\n  char *v12; // rcx\n  __int64 v13; // r8\n  int left[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v7 = cpu_arch;\n  skip = 0;\n  v9 = 0;\n  v10 = message_16509 + 27;\n  left[0] = 54;\n  while ( 1 )\n  {\n    if ( !skip )\n    {\n      name = (char *)v7->name;\n      len = (int *)v7->len;\n      if ( *v7->name == 46 )\n      {\n        if ( a2 )\n        {\n          ++name;\n          len = (int *)(unsigned int)((_DWORD)len - 1);\nLABEL_5:\n          v10 = output_message(a1, v10, (char *)left, name, len, a6);\n        }\n      }\n      else if ( !a2 && (!a3 || (*(_BYTE *)&cpu_arch[v9].flags.bitfield & 4) != 0) )\n      {\n        goto LABEL_5;\n      }\n    }\n    ++v9;\n    ++v7;\n    if ( v9 == 124 )\n      break;\n    skip = v7->skip;\n  }\n  if ( a2 )\n  {\n    v11 = (const arch_entry *)(cpu_noarch + 32);\n    v12 = byte_4F8D2F + 415;\n    v13 = 4LL;\n    while ( 1 )\n    {\n      v10 = output_message(a1, v10, (char *)left, v12, (int *)v13, a6);\n      if ( v11 == cpu_arch )\n        break;\n      v13 = v11->len;\n      v12 = (char *)v11->name;\n      v11 = (const arch_entry *)((char *)v11 + 32);\n    }\n  }\n  *v10 = 0;\n  fprintf(a1, &byte_4F2711[47], message_16509, name, len, a6);\n}\n",
    "source_code": "\nstatic void\nshow_arch (FILE *stream, int ext, int check)\n{\n  static char message[] = MESSAGE_TEMPLATE;\n  char *start = message + 27;\n  char *p;\n  int size = sizeof (MESSAGE_TEMPLATE);\n  int left;\n  const char *name;\n  int len;\n  unsigned int j;\n\n  p = start;\n  left = size - (start - message);\n  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)\n    {\n      /* Should it be skipped?  */\n      if (cpu_arch [j].skip)\n\tcontinue;\n\n      name = cpu_arch [j].name;\n      len = cpu_arch [j].len;\n      if (*name == '.')\n\t{\n\t  /* It is an extension.  Skip if we aren't asked to show it.  */\n\t  if (ext)\n\t    {\n\t      name++;\n\t      len--;\n\t    }\n\t  else\n\t    continue;\n\t}\n      else if (ext)\n\t{\n\t  /* It is an processor.  Skip if we show only extension.  */\n\t  continue;\n\t}\n      else if (check && ! cpu_arch[j].flags.bitfield.cpui386)\n\t{\n\t  /* It is an impossible processor - skip.  */\n\t  continue;\n\t}\n\n      p = output_message (stream, p, message, start, &left, name, len);\n    }\n\n  /* Display disabled extensions.  */\n  if (ext)\n    for (j = 0; j < ARRAY_SIZE (cpu_noarch); j++)\n      {\n\tname = cpu_noarch [j].name;\n\tlen = cpu_noarch [j].len;\n\tp = output_message (stream, p, message, start, &left, name,\n\t\t\t    len);\n      }\n\n  *p = '\\0';\n  fprintf (stream, \"%s\\n\", message);\n}",
    "comment": "Outputs architecture information to a specified stream, including enabled processors and disabled extensions, based on provided flags and conditions.",
    "hext5_sum": "| copy input file to output file, while encoding it. | '",
    "bint5_sum": "Formats and prints the symbol names and their associated flags to a specified file , handling dot-separated symbols appropriately .\n",
    "cpbcs_sum": "Processes a list of words for reading or writing lines to a specified file based on the given flags.\n",
    "misum_sum": "Outputs toggle expressions from a string, handling each string in a list, and formatting the output based on specified flags.\n",
    "decom_sum": "Generates a formatted string from predefined tables based on control flags and writes it to the given stream followed by a newline.",
    "cfg_sum": "Formats and appends specific strings based on input flags and conditions, then writes the assembled message followed by a newline to the given stream.",
    "work_score": {
        "decom": {
            "summary": "Generates a formatted string from predefined tables based on control flags and writes it to the given stream followed by a newline.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function uses predefined tables, considers control flags, formats a string, and writes it to the provided stream with a newline, all of which are evident in the source code. While the wording is generic and lacks detail such as specifics about skipping processors or handling extensions, it is still accurate in describing the core domain behavior without introducing incorrect or irrelevant claims. Nearly all statements align with the code\u2019s semantics.",
                "The summary correctly notes that the function formats data from predefined tables using control flags and writes it to the given stream, which aligns with the core purpose of presenting CPU architecture or extension names based on flags. However, it lacks specificity about the domain semantics, such as distinguishing between processors and extensions, skipping invalid architectures, and handling disabled extensions. These omissions limit coverage of behavior-critical details present in the source code.",
                "The summary correctly identifies that the function generates output from predefined tables based on control flags and writes to a provided stream with a newline, which matches the source code's use of cpu_arch/cpu_noarch arrays, filtering logic, and final fprintf. However, it is generic and omits details such as how 'ext' and 'check' control which entries are included. There are no inaccurate claims, but the limited specificity means the gain is low."
            ]
        },
        "cfg": {
            "summary": "Formats and appends specific strings based on input flags and conditions, then writes the assembled message followed by a newline to the given stream.",
            "score": [
                0.9,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly describes that the function assembles a message based on input flags and conditions, then writes it with a newline to the stream. However, it omits key specifics, such as iterating over cpu_arch and cpu_noarch arrays, skipping entries based on 'skip', extension vs processor handling, and check flag logic, which are domain-semantic behaviors. The claim is broadly accurate but lacks detail, making it a generic SAFE rather than fully GOLD. Since the single claim present is accurate, the proportion of accurate claims is 100%.",
                "The summary correctly notes that the function formats and appends strings based on flags and writes the final message to a stream, which reflects generic output behavior in the code. However, it fails to capture the core purpose of listing CPU architectures/extensions subject to conditional skipping logic. No mention is made of the architecture arrays, the distinction between extensions and processors, or disabled extensions, resulting in omission of domain-specific semantics. Secondary behavior details are minimal, focusing only on broad formatting and output.",
                "The summary correctly reflects the overall behavior of constructing and formatting a message based on conditions and then outputting it to a stream, which matches the source code's logic. However, it is vague and lacks specific details such as handling extensions vs processors, skipping based on flags, and appending disabled extensions when ext is set. The claim is accurate but generic with low informational gain; there is no evident inaccurate or fatal misstatement, but the abstraction provides minimal insight beyond broad functionality."
            ]
        },
        "comment": {
            "summary": "Outputs architecture information to a specified stream, including enabled processors and disabled extensions, based on provided flags and conditions.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly reflects the function\u2019s purpose: it outputs architecture information to a stream and distinguishes between enabled processors and disabled extensions based on flags like 'ext' and 'check'. It omits specific details about how items are skipped (e.g., '.' prefix for extensions, cpui386 check), but all stated claims are consistent with the code and domain behavior. With no inaccuracies present and only minor lack of detail, the accuracy proportion is very high.",
                "The summary correctly identifies that the function outputs architecture information to a stream and mentions both enabled processors and disabled extensions, aligning with the core primary purpose in the code. However, it omits specific, behavior-critical conditions present in the source, such as filtering based on skip flags, handling of extension names with a leading '.', and the check against the cpui386 flag. These omissions mean the secondary coverage is thin, despite accurate core coverage.",
                "The summary accurately reflects the core purpose of the function: writing architecture information to a given stream. It correctly notes inclusion of processors and disabled extensions based on conditions from the parameters 'ext' and 'check'. No contradictory or irrelevant claims are present, and the claims are concise yet cover primary I/O and behavior. While accurate, the description is somewhat generic and omits specific filtering logic (e.g., skipping based on cpu_arch attributes), resulting in moderate informational gain rather than highly detailed insight."
            ]
        }
    }
}
{
    "project_name": "GraphicsMagick",
    "function_addr": 1297040,
    "strip_function_name": "sub_13CA90",
    "strip_decompiled_code": "__int64 __fastcall sub_13CA90(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  unsigned __int8 *v5; // rbx\n  __int64 v6; // rbp\n  __int64 v7; // r13\n  size_t v8; // r13\n  __int64 *v9; // r15\n  __int64 v10; // rbp\n  _BYTE *v11; // rbx\n  __int64 v12; // [rsp+8h] [rbp-60h]\n  unsigned __int8 v13[12]; // [rsp+1Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h] BYREF\n\n  v14 = __readfsqword(0x28u);\n  v1 = (__int64)(int)sub_13BF80(a1) << 8;\n  v2 = v1 + (int)sub_13BF80(a1);\n  if ( v2 > 16 )\n  {\n    v5 = v13;\n    do\n      *v5++ = sub_13BF80(a1);\n    while ( v5 != (unsigned __int8 *)&v14 );\n    if ( (unsigned int)sub_9AC60(v13, \"ICC_PROFILE\") )\n    {\n      v6 = v2 - 14;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        sub_13BF80(a1);\n      }\n      while ( v6 != v7 );\n    }\n    else\n    {\n      v8 = v2 - 16;\n      sub_13BF80(a1);\n      sub_13BF80(a1);\n      v9 = *(__int64 **)(a1 + 24);\n      v12 = *v9;\n      sub_5BCA0(150, (__int64)\"coders/jpeg.c\");\n      if ( v2 - 16 > 0 )\n      {\n        v10 = (__int64)v9 + v2 + 464;\n        v11 = v9 + 60;\n        do\n          *v11++ = sub_13BF80(a1);\n        while ( v11 != (_BYTE *)v10 );\n      }\n      sub_6E110(v12, \"ICM\", v9 + 60, v8);\n    }\n  }\n  else\n  {\n    v3 = v2 - 3;\n    if ( v3 >= 0 )\n    {\n      do\n      {\n        --v3;\n        sub_13BF80(a1);\n      }\n      while ( v3 != -1 );\n    }\n  }\n  return 1LL;\n}\n",
    "function_name": "ReadICCProfile",
    "decompiled_code": "__int64 __fastcall ReadICCProfile(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  unsigned __int8 *v5; // rbx\n  __int64 v6; // rbp\n  __int64 v7; // r13\n  size_t v8; // r13\n  __int64 *v9; // r15\n  __int64 v10; // rbp\n  _BYTE *v11; // rbx\n  __int64 v12; // [rsp+8h] [rbp-60h]\n  unsigned __int8 v13[12]; // [rsp+1Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h] BYREF\n\n  v14 = __readfsqword(0x28u);\n  v1 = (__int64)(int)GetCharacter(a1) << 8;\n  v2 = v1 + (int)GetCharacter(a1);\n  if ( v2 > 16 )\n  {\n    v5 = v13;\n    do\n      *v5++ = GetCharacter(a1);\n    while ( v5 != (unsigned __int8 *)&v14 );\n    if ( (unsigned int)LocaleCompare(v13, \"ICC_PROFILE\") )\n    {\n      v6 = v2 - 14;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        GetCharacter(a1);\n      }\n      while ( v6 != v7 );\n    }\n    else\n    {\n      v8 = v2 - 16;\n      GetCharacter(a1);\n      GetCharacter(a1);\n      v9 = *(__int64 **)(a1 + 24);\n      v12 = *v9;\n      LogMagickEvent(150, \"coders/jpeg.c\");\n      if ( v2 - 16 > 0 )\n      {\n        v10 = (__int64)v9 + v2 + 464;\n        v11 = v9 + 60;\n        do\n          *v11++ = GetCharacter(a1);\n        while ( v11 != (_BYTE *)v10 );\n      }\n      AppendImageProfile(v12, \"ICM\", v9 + 60, v8);\n    }\n  }\n  else\n  {\n    v3 = v2 - 3;\n    if ( v3 >= 0 )\n    {\n      do\n      {\n        --v3;\n        GetCharacter(a1);\n      }\n      while ( v3 != -1 );\n    }\n  }\n  return 1LL;\n}\n",
    "source_code": "\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  long\n    length;\n\n  register long\n    i;\n\n  unsigned char\n    *profile;\n\n  /*\n    Determine length of color profile.\n  */\n  length=(long) GetCharacter(jpeg_info) << 8;\n  length+=(long) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (--length >= 0)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,\"ICC_PROFILE\") != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < length-12; i++)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n\n  /*\n    Read color profile.\n  */\n  profile=error_manager->buffer;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"ICC profile chunk: %ld bytes\",\n    length);\n\n  for (i=0 ; i < length; i++)\n   profile[i]=GetCharacter(jpeg_info);\n\n  (void) AppendImageProfile(image,\"ICM\",profile,length);\n\n  return(True);\n}",
    "comment": "Reads an ICC color profile from JPEG data, storing it in an image's buffer if the profile is valid.",
    "hext5_sum": "returns a negative integer calculates sign as well as log(|gamma(x)|). x = -n + eps assumes n >= 1",
    "bint5_sum": "Reads a generic JPEG profile , detects EXIF and XMP types , and stores the profile data in an image structure .\n",
    "cpbcs_sum": "Reads the IPTC JPEG file size from a JPEG image and stores it in the provided character buffer.\n",
    "misum_sum": "Reads the contents of a JPEG image and converts it into a 64-bit unsigned integer in little-endian format.\n",
    "decom_sum": "Parses JPEG segment data, identifies and loads embedded ICC color profile, and stores it for use in image color management.",
    "cfg_sum": "Parses JPEG segment data, detects and skips ICC_PROFILE markers, and loads ICM color profile bytes into the image structure for further processing.",
    "work_score": {
        "decom": {
            "summary": "Parses JPEG segment data, identifies and loads embedded ICC color profile, and stores it for use in image color management.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary contains two fact-based claims: (1) the function parses JPEG segment data and identifies embedded ICC profiles, which aligns with the code's behavior of checking the segment length, reading the marker, and verifying it equals 'ICC_PROFILE'; and (2) it loads and stores the profile for use in image color management, which is accurate as the code reads the profile bytes into a buffer and appends them to the image under 'ICM'. Both claims target source code semantics and are accurate, yielding a high proportion of correct claims.",
                "The summary correctly captures the core purpose of reading and loading an embedded ICC color profile from a JPEG segment into the image, which aligns with the function\u2019s primary domain-specific behavior. However, it omits important secondary details such as the length checks, identifier and marker parsing, the logging of the profile chunk size, and the handling of non-ICC segments by discarding remaining bytes. These missing points reduce coverage of the full behavior-critical semantics.",
                "The summary accurately states the function parses JPEG segment data, checks for an embedded ICC color profile, and stores it for color management. These claims align with the code\u2019s logic of reading segment length, verifying the 'ICC_PROFILE' signature, reading the profile bytes, and appending them to the image profile. There are no incorrect or noisy claims, but the description is somewhat generic and lacks specific implementation details such as early return conditions when no valid profile is present, or the exact handling of profile data. The gain is moderate due to correctness but limited specificity."
            ]
        },
        "cfg": {
            "summary": "Parses JPEG segment data, detects and skips ICC_PROFILE markers, and loads ICM color profile bytes into the image structure for further processing.",
            "score": [
                0.9,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function parses JPEG segment data, checks for the 'ICC_PROFILE' marker, and loads the color profile bytes into the image's ICM profile. The claim about skipping ICC_PROFILE markers is slightly misleading, as the code only skips data when the marker does not match 'ICC_PROFILE'; otherwise, it reads and appends the profile. Overall, the majority of the claims align with the source code's behavior, with only minor imprecision in phrasing.",
                "The summary correctly identifies that the function processes JPEG segment data, checks for an ICC_PROFILE marker, and loads the ICM color profile into the image, which matches the core purpose and key semantics in the code. However, it omits secondary details like the calculation and adjustment of the length, early exit conditions for short segments, handling of non-ICC data, use of 'LogMagickEvent' for logging, and specifics about reading into a buffer from the ErrorManager structure. This limits coverage of important branches and side effects.",
                "The summary accurately conveys that the function parses JPEG segment data, detects ICC_PROFILE markers, and loads the ICM color profile into the image structure. However, it incorrectly states that ICC_PROFILE markers are skipped; in the source code, ICC_PROFILE data is read and appended to the image profile, whereas only non-ICC profile segments are skipped. This is a FATAL error affecting the primary purpose, as it misrepresents the core domain action of handling ICC profiles."
            ]
        },
        "comment": {
            "summary": "Reads an ICC color profile from JPEG data, storing it in an image's buffer if the profile is valid.",
            "score": [
                0.8,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function reads an ICC color profile from JPEG data and stores it in an image's buffer, capturing the core behavior shown in the source code. However, the summary omits details about the validation process (checking the length threshold and matching the 'ICC_PROFILE' string) and does not clarify that the profile is appended to the image as 'ICM'. Despite these omissions, the main semantic claim aligns well with the code, making most of the information accurate.",
                "The summary correctly captures the core function of reading an ICC color profile from JPEG data and storing it, which matches the primary purpose of the code. However, it lacks coverage of key secondary details such as the validation steps using length and the \"ICC_PROFILE\" signature, handling of non-profile data, use of specific buffers from the error manager, logging of the chunk size, and appending the profile to the image with a specific type ('ICM'). This makes the coverage of secondary behavior incomplete.",
                "The summary captures the core purpose accurately: reading an ICC color profile from JPEG data. However, it omits several specifics in the source code \u2014 such as checking the profile header for 'ICC_PROFILE', handling cases where profile length is too short, and appending the profile to the image with a specific tag ('ICM') \u2014 which are important domain details. The claim about storing it 'in an image's buffer' is slightly misleading since the buffer is used temporarily before appending to the image, but it does not rise to the level of a fatal semantic error. Overall, it is a correct but generic SAFE claim with low informational gain."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1318368,
    "strip_function_name": "gsl_permutation_linear_to_canonical",
    "strip_decompiled_code": "__int64 __fastcall gsl_permutation_linear_to_canonical(__int64 *a1, _QWORD *a2)\n{\n  __int64 v2; // r8\n  __int64 v3; // rsi\n  __int64 v4; // r9\n  unsigned __int64 v5; // rdx\n  __int64 v6; // rdi\n  unsigned __int64 v7; // rax\n  __int64 i; // rcx\n  unsigned __int64 v9; // rax\n  unsigned __int64 *v10; // rcx\n\n  v2 = *a1;\n  if ( *a1 == *a2 )\n  {\n    if ( v2 )\n    {\n      v3 = a2[1];\n      v4 = a1[1];\n      v5 = 0LL;\n      v6 = *a1;\n      do\n      {\n        v7 = *(_QWORD *)(v3 + 8 * v5);\n        for ( i = 1LL; v7 > v5; ++i )\n          v7 = *(_QWORD *)(v3 + 8 * v7);\n        if ( v7 >= v5 )\n        {\n          v6 -= i;\n          *(_QWORD *)(v4 + 8 * v6) = v5;\n          v9 = *(_QWORD *)(v3 + 8 * v5);\n          if ( v9 > v5 )\n          {\n            v10 = (unsigned __int64 *)(v4 + 8 * v6 + 8);\n            do\n            {\n              *v10 = v9;\n              v9 = *(_QWORD *)(v3 + 8 * v9);\n              ++v10;\n            }\n            while ( v9 > v5 );\n          }\n          if ( !v6 )\n            break;\n        }\n        ++v5;\n      }\n      while ( v2 != v5 );\n    }\n    return 0LL;\n  }\n  else\n  {\n    gsl_error(\"size of q does not match size of p\", \"canonical.c\", 42LL, 4LL);\n    return 4LL;\n  }\n}\n",
    "function_name": "gsl_permutation_linear_to_canonical",
    "decompiled_code": "int __fastcall gsl_permutation_linear_to_canonical(gsl_permutation *q, const gsl_permutation *p)\n{\n  size_t size; // r8\n  size_t *data; // rsi\n  size_t *v4; // r9\n  size_t v5; // rdx\n  size_t v6; // rdi\n  size_t v7; // rax\n  __int64 i; // rcx\n  size_t v9; // rax\n  size_t *v10; // rcx\n\n  size = q->size;\n  if ( q->size == p->size )\n  {\n    if ( size )\n    {\n      data = p->data;\n      v4 = q->data;\n      v5 = 0LL;\n      v6 = q->size;\n      do\n      {\n        v7 = data[v5];\n        for ( i = 1LL; v7 > v5; ++i )\n          v7 = data[v7];\n        if ( v7 >= v5 )\n        {\n          v6 -= i;\n          v4[v6] = v5;\n          v9 = data[v5];\n          if ( v9 > v5 )\n          {\n            v10 = &v4[v6 + 1];\n            do\n            {\n              *v10 = v9;\n              v9 = data[v9];\n              ++v10;\n            }\n            while ( v9 > v5 );\n          }\n          if ( !v6 )\n            break;\n        }\n        ++v5;\n      }\n      while ( size != v5 );\n    }\n    return 0;\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"size of q does not match size of p\",\n      \"canonical.c\",\n      42LL,\n      4LL);\n    return 4;\n  }\n}\n",
    "source_code": "\nint\ngsl_permutation_linear_to_canonical (gsl_permutation * q,\n                                     const gsl_permutation * p)\n{\n  const size_t n = p->size;\n  size_t i, k, s;\n  size_t t = n;\n\n  const size_t *const pp = p->data;\n  size_t *const qq = q->data;\n\n  if (q->size != p->size)\n    {\n      GSL_ERROR (\"size of q does not match size of p\", GSL_EINVAL);\n    }\n\n  for (i = 0; i < n; i++)\n    {\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          k = pp[k];\n          s++;\n        }\n\n      if (k < i)\n        continue;\n\n      /* Now have k == i, i.e the least in its cycle, and s == cycle length */\n\n      t -= s;\n\n      qq[t] = i;\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          qq[t + s] = k;\n          k = pp[k];\n          s++;\n        }\n\n      if (t == 0)\n        break;\n    }\n\n  return GSL_SUCCESS;\n}",
    "comment": "Converts a given permutation `p` into its canonical form and stores the result in `q`.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Converts a linear permutation ` q ` into its canonical representation by rearranging indices based on the values in ` q ` .\n",
    "cpbcs_sum": "Converts a triplet sparse matrix to its corresponding bins representation, storing the result in the provided inverse array.\n",
    "misum_sum": "Converts a 2D point to a linear programming problem, allocating memory for the result array if necessary.\n",
    "decom_sum": "Converts a linear permutation array into its canonical form, validating equal sizes and reporting an error if the permutation lengths differ.",
    "cfg_sum": "Transforms a linear permutation into its canonical form, validating matching sizes and reporting an error if the permutations\u2019 lengths differ.",
    "work_score": {
        "decom": {
            "summary": "Converts a linear permutation array into its canonical form, validating equal sizes and reporting an error if the permutation lengths differ.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary contains two atomic claims: the function converts a linear permutation to its canonical form, and it validates that both permutations have equal sizes and reports an error if not. Both claims match the code's behavior, as the implementation computes a canonical form from the provided permutation data and checks size equality with an error return. This results in a high proportion of accurate statements.",
                "The summary correctly identifies the core purpose of converting a linear permutation to its canonical form and notes the size validation and error handling, which align with the source code. However, it omits other key procedural details such as iterating through cycles, determining cycle length, updating the canonical array positions, and the early termination condition when all elements are placed. These missing specifics limit coverage of important secondary semantics.",
                "The summary correctly states that the function converts a linear permutation to canonical form and checks size equality, which matches the core code behavior. However, it omits important details about how the canonical form is derived (cycle handling logic, index ordering) and gives only a generic description, reducing information gain. No inaccurate or contradictory claims are present, but the gain is low due to lack of specificity."
            ]
        },
        "cfg": {
            "summary": "Transforms a linear permutation into its canonical form, validating matching sizes and reporting an error if the permutations\u2019 lengths differ.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function transforms a linear permutation into a canonical form, which aligns with the function's name and behavior, and that it checks whether sizes match and reports an error if they differ\u2014the code uses a GSL_ERROR for this. These are both accurate domain-specific claims. The summary omits many specifics of the algorithm but does not contain inaccurate statements, resulting in a high proportion of accurate claims.",
                "The summary accurately mentions that the function transforms a linear permutation into its canonical form and checks for size mismatches with error reporting, which matches the core purpose and a key branch in the code. However, it omits other important details such as the cycle detection process, reordering logic, manipulation of indices in qq, and the early termination condition when t reaches zero. Coverage of secondary semantics is minimal beyond size validation.",
                "The summary correctly identifies the primary purpose of the function as converting a linear permutation into its canonical form and mentions size validation with error reporting, both of which match the source code. There is no inaccurate or contradictory claim and noise is minimal. However, the summary is generic, omitting specifics such as the algorithm for cycle detection and element reordering, so the informational gain is limited."
            ]
        },
        "comment": {
            "summary": "Converts a given permutation `p` into its canonical form and stores the result in `q`.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary captures the general idea that the function transforms permutation `p` into a canonical form and stores it in `q`, which aligns with the source code logic for generating a canonical ordering of cycles. However, it omits key accuracy details from the implementation, such as cycle detection, ordering, and the precondition check for matching sizes. The claim is correct but generic, making it low-information yet still aligned with the code's purpose; only one atomic claim is present and it is accurate.",
                "The summary correctly identifies that the function transforms permutation `p` into a canonical form stored in `q`, which matches the core purpose of processing `p` into a new arrangement in `q`. However, it omits several important secondary details from the code, such as the size mismatch error handling, the algorithm based on processing permutation cycles, and the success return value. This leads to incomplete coverage beyond the core action.",
                "The summary correctly identifies that the function transforms permutation `p` into a canonical form stored in `q`, which aligns with the main purpose in the source code. However, it is overly generic and omits important specifics such as the cycle-based rearrangement process, the requirement that `q` and `p` have the same size, and the exact nature of the canonical representation. The claim is accurate but low-info, with no evident errors, making the main shortcoming the lack of detail rather than inaccuracy."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584487984,
    "strip_function_name": "sub_FFFFFFFF81561A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81561A30(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  _QWORD *v9; // rax\n  unsigned __int64 v10; // rbx\n  __int64 v11; // rsi\n  __int64 *v12; // rdx\n  __int64 v13; // rcx\n  int v14; // r8d\n  int v15; // r9d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // eax\n\n  v9 = (_QWORD *)sub_FFFFFFFF8112CA50((_QWORD *)qword_FFFFFFFF81E8C758, 0xD0u, 1224LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = (unsigned __int64)v9;\n  v11 = (__int64)v9;\n  *v9 = *(_QWORD *)(a1 + 80);\n  v9[1] = *(_QWORD *)(a1 + 88);\n  v9[2] = *(_QWORD *)(a1 + 96);\n  v9[3] = *(_QWORD *)(a1 + 104);\n  v9[4] = *(_QWORD *)(a1 + 112);\n  v9[5] = *(_QWORD *)(a1 + 120);\n  v9[6] = *(_QWORD *)(a1 + 128);\n  v9[7] = *(_QWORD *)(a1 + 136);\n  (*(void (__fastcall **)(__int64, _QWORD *))(a1 + 160))(a1 + 64, v9);\n  v18 = *(_DWORD *)(a1 + 28);\n  if ( v18 > 0 )\n  {\n    v12 = *(__int64 **)(v10 + 72);\n    *(_DWORD *)(a1 + 40) = (_DWORD)v12;\n    if ( v18 != 1 )\n      *(_DWORD *)(a1 + 44) = *(_QWORD *)(v10 + 80);\n  }\n  sub_FFFFFFFF8112DCD0(v10, a2, a3, a4, a5, v16, v17, a8, a9, v11, v12, v13, v14, v15);\n  return 0LL;\n}\n",
    "function_name": "slave_update",
    "decompiled_code": "__int64 __fastcall slave_update(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 *v9; // rax\n  __int64 *v10; // rbx\n  __int64 v11; // rsi\n  __int64 *v12; // rdx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // eax\n\n  v9 = kmem_cache_alloc_trace((__int64 *)qword_FFFFFFFF81E8C758, 208LL, 1224LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = (__int64)v9;\n  *v9 = *(_QWORD *)(a1 + 80);\n  v9[1] = *(_QWORD *)(a1 + 88);\n  v9[2] = *(_QWORD *)(a1 + 96);\n  v9[3] = *(_QWORD *)(a1 + 104);\n  v9[4] = *(_QWORD *)(a1 + 112);\n  v9[5] = *(_QWORD *)(a1 + 120);\n  v9[6] = *(_QWORD *)(a1 + 128);\n  v9[7] = *(_QWORD *)(a1 + 136);\n  (*(void (__fastcall **)(__int64, __int64 *))(a1 + 160))(a1 + 64, v9);\n  v15 = *(_DWORD *)(a1 + 28);\n  if ( v15 > 0 )\n  {\n    v12 = (__int64 *)v10[9];\n    *(_DWORD *)(a1 + 40) = (_DWORD)v12;\n    if ( v15 != 1 )\n      *(_DWORD *)(a1 + 44) = v10[10];\n  }\n  kfree(v10, a2, a3, a4, a5, v13, v14, a8, a9, v11, v12);\n  return 0LL;\n}\n",
    "source_code": "\nstatic int slave_update(struct link_slave *slave)\n{\n\tstruct snd_ctl_elem_value *uctl;\n\tint err, ch;\n\n\tuctl = kmalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (!uctl)\n\t\treturn -ENOMEM;\n\tuctl->id = slave->slave.id;\n\terr = slave->slave.get(&slave->slave, uctl);\n\tfor (ch = 0; ch < slave->info.count; ch++)\n\t\tslave->vals[ch] = uctl->value.integer.value[ch];\n\tkfree(uctl);\n\treturn 0;\n}",
    "comment": "Updates the values of a slave device by retrieving its current control element values and storing them in the slave's array.",
    "hext5_sum": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Initializes a high-resolution timer for a sound device by allocating memory , setting up timers , and registering the timer .\n",
    "cpbcs_sum": "Copies the properties of an EFI variable entry to a HID device and marks it as dirty if the variable is valid.\n",
    "misum_sum": "Initializes a sequencer device by allocating memory, storing it and an existing slave device if no active events remain.\n",
    "decom_sum": "Allocates and initializes a 0xD0-byte structure from object fields, invokes its callback, updates state fields, and performs further processing with given double parameters.",
    "cfg_sum": "Allocates and initializes a data block from source structure, updates fields, invokes processing callbacks, and returns error if allocation fails.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a 0xD0-byte structure from object fields, invokes its callback, updates state fields, and performs further processing with given double parameters.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains several inaccuracies: it specifies a 0xD0-byte allocation and double parameters, neither of which are found in the source code, which actually uses kmalloc(sizeof(*uctl)) for a struct snd_ctl_elem_value and processes integer values. While it correctly notes allocation, initializing from object fields, invoking a callback, and updating state fields, the presence of incorrect size and parameter types means that less than half of the claims match the code accurately.",
                "The summary fails to correctly describe the core domain operation, which is updating a link_slave's values by allocating a snd_ctl_elem_value structure, calling its get callback, copying retrieved integer values for each channel, and freeing the structure. The mention of a '0xD0-byte structure' and 'double parameters' is inaccurate and unrelated to the source code, and no accurate claim covers the specific core update of slave values via the get callback. Secondary behaviors such as memory allocation checks, iteration over channels, and freeing memory are also not correctly or specifically covered.",
                "The summary contains multiple inaccurate claims: it incorrectly specifies a '0xD0-byte structure' (no size information is evident in the code), mentions 'further processing with given double parameters' (the code handles integer values, not doubles), and mislabels the callback behavior. While it correctly notes allocation, initialization, callback invocation, and state update, the majority of claims are noise or inaccurate, with several targeting core behavior wrongly. The worst failure mode is FATAL on core I/O semantics, which severely undermines trust."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes a data block from source structure, updates fields, invokes processing callbacks, and returns error if allocation fails.",
            "score": [
                0.9,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly states that memory is allocated and an error is returned if allocation fails, matching the code. It also accurately notes updating fields from the source structure and calling a processing function (the get callback). However, the description 'initializes a data block' is slightly generic and could be more specific, and 'invokes processing callbacks' is vague but still aligns with invoking slave->slave.get. Overall, most claims directly match code behavior, with minor generalization.",
                "The summary correctly notes allocation and error handling, which matches the code's kmalloc usage and ENOMEM return on failure. However, it misses the core primary purpose: retrieving control element values from the slave via a get callback and storing them in slave->vals. The description is generic ('updates fields', 'invokes processing callbacks') and lacks the specific domain semantics of ALSA control element value retrieval and assignment across channels. It also omits secondary details such as freeing the allocated structure after use.",
                "The summary correctly notes memory allocation and the error return on allocation failure, which matches the source. However, it inaccurately describes initializing from a 'source structure' and invoking 'processing callbacks'\u2014the code calls a specific get() method and copies channel values, not generic processing. The wording is vague, missing key specifics like copying integer values from uctl to slave->vals, and it omits freeing the allocation. Noise from vague, generic descriptions outweighs the limited accurate details, with no severe factual contradiction but low informational gain."
            ]
        },
        "comment": {
            "summary": "Updates the values of a slave device by retrieving its current control element values and storing them in the slave's array.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately describes the function's core behavior: it retrieves current control element values from the slave via its get method and stores them into the slave's values array. This matches the source code logic, which allocates a control element structure, populates it via the get callback, iterates over channels, copies integer values, frees memory, and returns. The description is factual, precise, and domain-relevant without contradictions or irrelevant noise, resulting in a high alignment with the evaluation steps.",
                "The summary accurately describes the core purpose as updating a slave device's values by retrieving current control element values and storing them in the slave's array. This aligns well with the code's core domain action of allocating a control element structure, calling the slave's get method, and copying retrieved integer values into the slave's vals array. However, it omits notable secondary details such as memory allocation and error handling for allocation failure, the use of count to determine the number of values copied, and freeing allocated memory after use.",
                "The summary accurately captures the primary purpose of the function: retrieving current control element values from the slave and updating the slave's array. There are no inaccurate or contradictory claims, and the description is specific to the code\u2019s core semantics, indicating high alignment. Noise is minimal, and the claim correctly reflects the key I/O and side effects in the source code."
            ]
        }
    }
}
{
    "project_name": "dico",
    "function_addr": 72448,
    "strip_function_name": "sub_11B00",
    "strip_decompiled_code": "__int64 __fastcall sub_11B00(int a1, const __m128i *a2, __int64 a3, __int64 a4)\n{\n  const char *v5; // rsi\n  __int64 v8; // rbx\n  int v9; // r14d\n  _QWORD *v10; // rax\n  __int64 v11; // r13\n  __int64 v12; // rax\n  __int64 v13; // r12\n  __int64 v14; // rbx\n  __int64 v15; // r12\n\n  v5 = \"Unexpected block statement\";\n  if ( a1 != 2 )\n    goto LABEL_4;\n  if ( *(_DWORD *)a4 != 2 )\n  {\n    v5 = \"Not enough arguments for alias\";\nLABEL_4:\n    dcgettext(0LL, v5, 5);\n    grecs_error();\n    return 1LL;\n  }\n  v8 = *(_QWORD *)(a4 + 40);\n  v9 = v8 - 1;\n  v10 = (_QWORD *)sub_2F900((int)v8, 8LL);\n  v11 = (__int64)v10;\n  if ( (int)v8 - 1 > 0 )\n  {\n    v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8LL);\n    if ( *(_DWORD *)v12 )\n    {\nLABEL_13:\n      dcgettext(0LL, \"argument %d has wrong type\", 5);\n      grecs_error();\n      return 1LL;\n    }\n    v13 = (unsigned int)(v8 - 2);\n    v14 = 1LL;\n    v15 = v13 + 1;\n    while ( 1 )\n    {\n      *(_QWORD *)(v11 + 8 * v14 - 8) = sub_2F970(*(void **)(v12 + 40));\n      if ( v14 == v15 )\n        break;\n      ++v14;\n      v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8 * v14);\n      if ( *(_DWORD *)v12 )\n        goto LABEL_13;\n    }\n    v10 = (_QWORD *)(v11 + 8 * v14);\n  }\n  *v10 = 0LL;\n  return sub_ACE0(*(void **)(**(_QWORD **)(a4 + 48) + 40LL), v9, v11, a2);\n}\n",
    "function_name": "alias_cb",
    "decompiled_code": "int __fastcall alias_cb(\n        grecs_callback_command cmd,\n        grecs_locus_t *locus,\n        void *varptr,\n        grecs_value_t *value,\n        void *cb_data)\n{\n  const char *v6; // rsi\n  char *v8; // rax\n  grecs_list_ptr_t list; // rbx\n  int v11; // r14d\n  char **v12; // rax\n  char **v13; // r13\n  grecs_value *v14; // rax\n  __int64 v15; // r12\n  __int64 v16; // rbx\n  __int64 v17; // r12\n  int v18; // ecx\n  unsigned int v19; // ebx\n  char *v20; // rax\n\n  v6 = \"Unexpected block statement\";\n  if ( cmd != grecs_callback_command::grecs_callback_set_value )\n    goto LABEL_4;\n  if ( value->type != 2 )\n  {\n    v6 = \"Not enough arguments for alias\";\nLABEL_4:\n    v8 = dcgettext(0LL, v6, 5);\n    ((void (__fastcall *)(grecs_locus_t *, _QWORD, char *))grecs_error)(locus, 0LL, v8);\n    return 1;\n  }\n  list = value->v.list;\n  v11 = (_DWORD)list - 1;\n  v12 = (char **)xcalloc((int)list, 8uLL);\n  v13 = v12;\n  if ( (int)list - 1 > 0 )\n  {\n    v14 = (grecs_value *)*((_QWORD *)value->v.arg.v + 1);\n    if ( v14->type )\n    {\n      v19 = 1;\n    }\n    else\n    {\n      v15 = (unsigned int)((_DWORD)list - 2);\n      v16 = 1LL;\n      v17 = v15 + 1;\n      do\n      {\n        v13[v16 - 1] = xstrdup(v14->v.string);\n        v18 = v16;\n        if ( v16 == v17 )\n        {\n          v12 = &v13[v16];\n          goto LABEL_12;\n        }\n        v14 = value->v.arg.v[++v16];\n      }\n      while ( !v14->type );\n      v19 = v18 + 1;\n    }\n    v20 = dcgettext(0LL, \"argument %d has wrong type\", 5);\n    ((void (__fastcall *)(grecs_locus_t *, _QWORD, char *, _QWORD))grecs_error)(locus, 0LL, v20, v19);\n    return 1;\n  }\nLABEL_12:\n  *v12 = 0LL;\n  return alias_install((*value->v.arg.v)->v.string, v11, v13, locus);\n}\n",
    "source_code": "\n\f\nint\nalias_cb(enum grecs_callback_command cmd,\n\t grecs_locus_t *locus,\n\t void *varptr,\n\t grecs_value_t *value,\n\t void *cb_data)\n{\n    char **argv;\n    int argc;\n    int i;\n\n    if (cmd != grecs_callback_set_value) {\n\tgrecs_error(locus, 0, _(\"Unexpected block statement\"));\n\treturn 1;\n    }\n    if (value->type != GRECS_TYPE_ARRAY) {\n\tgrecs_error(locus, 0, _(\"Not enough arguments for alias\"));\n\treturn 1;\n    }\n    argc = value->v.arg.c - 1;\n    argv = xcalloc(argc + 1, sizeof(argv[0]));\n    for (i = 0; i < argc; i++) {\n\tif (value->v.arg.v[i+1]->type != GRECS_TYPE_STRING) {\n\t    grecs_error(locus, 0, _(\"argument %d has wrong type\"), i+1);\n\t    return 1;\n\t}\n\targv[i] = xstrdup(value->v.arg.v[i+1]->v.string);\n    }\n    argv[i] = NULL;\n    return alias_install(value->v.arg.v[0]->v.string, argc, argv, locus);\n}",
    "comment": "Processes a callback to set an alias by checking argument types and installing the alias with provided string parameters.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes a callback to set a value by parsing a string , appending the value to a list , and managing memory for the alias .\n",
    "cpbcs_sum": "Processes a command and tag's a list of arguments, handling errors and unexpected tokens in the command list.\n",
    "misum_sum": "Processes a structured Unicode code to set an array of known words based on the string type, converting line arguments.\n",
    "decom_sum": "Parses and validates alias command arguments, reporting errors for wrong types or counts, then invokes the alias execution with collected parameters.",
    "cfg_sum": "Validates alias command arguments, reports specific errors, processes argument values into a list, and executes the alias operation with the provided context.",
    "work_score": {
        "decom": {
            "summary": "Parses and validates alias command arguments, reporting errors for wrong types or counts, then invokes the alias execution with collected parameters.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function parses and validates alias command arguments, checks for wrong types or counts, and then calls another function with the processed parameters. This aligns with the source code\u2019s behavior: it verifies the command type, ensures the argument array format, validates each argument\u2019s type, collects strings into an array, and invokes alias_install. All claims are accurate and grounded in the code\u2019s actual logic, with no contradictory or irrelevant statements.",
                "The summary correctly identifies that the function parses and validates alias command arguments, checks for type and count errors, and collects parameters before execution, which matches the code\u2019s core purpose of preparing arguments and invoking alias_install. However, it omits specifics such as the initial check for the correct callback command type, the handling of array-type input, memory allocation details, and explicit branching for error cases, leaving secondary coverage incomplete.",
                "The summary correctly captures the core behavior: it parses and validates alias command arguments, checks for incorrect types or counts, reports errors, and calls the alias execution with parameters from the input. These are accurate GOLD claims directly supported by the code, describing its primary purpose and key I/O. There is no contradictory or irrelevant noise, and the description is concise yet specific enough to be useful."
            ]
        },
        "cfg": {
            "summary": "Validates alias command arguments, reports specific errors, processes argument values into a list, and executes the alias operation with the provided context.",
            "score": [
                1.0,
                0.8,
                0.8
            ],
            "reason": [
                "The summary correctly reflects the main behaviors in the source code: it validates the alias command arguments, reports specific errors, processes argument values into a list, and executes the alias operation with the provided context. These align with observable code actions such as checking `cmd`, verifying argument types, allocating and populating argv, and calling `alias_install`. All claims are accurate and linked to the code's semantics.",
                "The summary accurately reflects the function\u2019s validation of alias command arguments, error reporting, processing values into an array, and invoking the alias operation with context, which matches the primary purpose of installing an alias from parsed arguments. It covers the core domain behavior clearly and includes secondary details like error handling and argument processing, though it omits some specifics such as type checks for each argument and allocation details. Overall coverage is strong but not exhaustive.",
                "The summary correctly captures the primary purpose and main behavior: it validates alias command arguments, reports specific errors for wrong types or missing arguments, processes them into a list, and calls alias_install with the context. All claims align with the source code's semantics and there are no inaccuracies or irrelevant noise. The gain is moderate as the summary is accurate but somewhat generic without detailing conditions such as the command type check or exact argument indexing."
            ]
        },
        "comment": {
            "summary": "Processes a callback to set an alias by checking argument types and installing the alias with provided string parameters.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly captures that the function processes a callback to set an alias, checks argument types, and installs the alias using string parameters, which matches the code's logic of validating the command, ensuring arguments are an array of strings, and calling alias_install. No contradictory or off-target claims are present, and all statements reflect the function's actual semantics.",
                "The summary correctly identifies that the function processes a callback to set an alias, checks argument types, and installs the alias using provided strings, which covers the core purpose from the source code. However, it omits key secondary details such as handling unexpected command types, specific error messages, memory allocation for arguments, and termination of the argv array, leading to incomplete coverage of important behavior-critical semantics.",
                "The summary accurately states the core purpose: handling a callback to set an alias, performing argument type checks, and installing the alias using provided strings. It omits some specifics from the code, such as the early return on unexpected commands and specific error messages, but there are no false or contradictory claims. The information gain is moderate, with correct coverage of the main behavior though lacking detail on error conditions and array handling."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5673105,
    "strip_function_name": "sub_569091",
    "strip_decompiled_code": "char __fastcall sub_569091(__int64 a1, int a2)\n{\n  char result; // al\n  _DWORD *v3; // rdx\n  int v4; // ecx\n  int v5; // eax\n  int v6; // edx\n  unsigned int v7; // esi\n  __int64 v8; // rax\n  __int64 v9; // rdi\n\n  result = 0;\n  if ( a2 != -1 )\n  {\n    v3 = off_8970B8;\n    if ( off_8970B8 )\n    {\n      v4 = *((_DWORD *)off_8970B8 + 3);\n      if ( a2 == v4 )\n      {\n        result = 1;\n        if ( v4 > 0 )\n          return result;\n      }\n      while ( 1 )\n      {\n        v3 = *(_DWORD **)v3;\n        if ( !v3 )\n          break;\n        v5 = v3[3];\n        if ( a2 == v5 && v5 > 0 )\n          return 1;\n      }\n    }\n    result = 0;\n    if ( a1 )\n    {\n      v6 = *(_DWORD *)(a1 + 8);\n      v7 = a2 | 0x80000000;\n      if ( v6 > 0 )\n      {\n        result = 1;\n        if ( *(_DWORD *)(a1 + 16) != v7 )\n        {\n          v8 = a1 + 24;\n          v9 = 8LL * (unsigned int)(v6 - 1) + 24 + a1;\n          while ( v8 != v9 )\n          {\n            v8 += 8LL;\n            if ( *(_DWORD *)(v8 - 8) == v7 )\n              return 1;\n          }\n          return 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "is_hidden_fd",
    "decompiled_code": "char __fastcall is_hidden_fd(__int64 a1, int a2)\n{\n  char result; // al\n  _DWORD *v3; // rdx\n  int v4; // ecx\n  int v5; // eax\n  int v6; // edx\n  unsigned int v7; // esi\n  __int64 v8; // rax\n  __int64 v9; // rdi\n\n  result = 0;\n  if ( a2 != -1 )\n  {\n    v3 = g_parsefile;\n    if ( g_parsefile )\n    {\n      v4 = *((_DWORD *)g_parsefile + 3);\n      if ( a2 == v4 )\n      {\n        result = 1;\n        if ( v4 > 0 )\n          return result;\n      }\n      while ( 1 )\n      {\n        v3 = *(_DWORD **)v3;\n        if ( !v3 )\n          break;\n        v5 = v3[3];\n        if ( a2 == v5 && v5 > 0 )\n          return 1;\n      }\n    }\n    result = 0;\n    if ( a1 )\n    {\n      v6 = *(_DWORD *)(a1 + 8);\n      v7 = a2 | 0x80000000;\n      if ( v6 > 0 )\n      {\n        result = 1;\n        if ( *(_DWORD *)(a1 + 16) != v7 )\n        {\n          v8 = a1 + 24;\n          v9 = 8LL * (unsigned int)(v6 - 1) + 24 + a1;\n          while ( v8 != v9 )\n          {\n            v8 += 8LL;\n            if ( *(_DWORD *)(v8 - 8) == v7 )\n              return 1;\n          }\n          return 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "static int\nis_hidden_fd(struct redirtab *rp, int fd)\n{\n\tint i;\n\tstruct parsefile *pf;\n\n\tif (fd == -1)\n\t\treturn 0;\n\t/* Check open scripts' fds */\n\tpf = g_parsefile;\n\twhile (pf) {\n\t\t/* We skip pf_fd == 0 case because of the following case:\n\t\t * $ ash  # running ash interactively\n\t\t * $ . ./script.sh\n\t\t * and in script.sh: \"exec 9>&0\".\n\t\t * Even though top-level pf_fd _is_ 0,\n\t\t * it's still ok to use it: \"read\" builtin uses it,\n\t\t * why should we cripple \"exec\" builtin?\n\t\t */\n\t\tif (pf->pf_fd > 0 && fd == pf->pf_fd) {\n\t\t\treturn 1;\n\t\t}\n\t\tpf = pf->prev;\n\t}\n\n\tif (!rp)\n\t\treturn 0;\n\t/* Check saved fds of redirects */\n\tfd |= COPYFD_RESTORE;\n\tfor (i = 0; i < rp->pair_count; i++) {\n\t\tif (rp->two_fd[i].copy == fd) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "comment": "Checks if a file descriptor is already in use by open scripts or saved redirects in the given redirection table.",
    "hext5_sum": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert a potential utf-8 encoded sequence in in into the \"order\" of the file.",
    "bint5_sum": "Determines if a given file descriptor is included or excluded based on the provided flag and the list of included files .\n",
    "cpbcs_sum": "Retrieves the previous and priority of a specified CPU, returning a pointer to the number of sheets printed.\n",
    "misum_sum": "Retrieves the current file position in a dynamically allocated string based on the provided mode and service index and backup settings.\n",
    "decom_sum": "Checks whether the given identifier matches an active entry in a global list or encoded entry within the specified object's data array.",
    "cfg_sum": "Validates whether a given identifier matches entries in a global linked list or an indexed array within a structure and returns a success flag.",
    "work_score": {
        "decom": {
            "summary": "Checks whether the given identifier matches an active entry in a global list or encoded entry within the specified object's data array.",
            "score": [
                0.5,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function checks whether an identifier matches an entry in a global list or encoded entry in an object's data array. While this loosely aligns with checking against `g_parsefile` (global linked list) and `rp->two_fd` (redirect table array), it omits critical specifics like the type being a file descriptor, conditions for skipping fd==0, and the encoding of fd via COPYFD_RESTORE. The vague terms 'identifier' and 'encoded entry' reduce precision, making it only partially accurate. Over half of the semantics are missing or generalized, leading to mixed reliability.",
                "The summary describes checking an identifier against a global list or object's data array, which is too generic and does not convey the core purpose of determining if a given file descriptor is currently in use by open scripts or stored redirects, including specific conditions like skipping fd 0 and applying COPYFD_RESTORE encoding. It misses critical domain-specific details and semantics present in the source code, resulting in no accurate coverage of the core purpose.",
                "The summary inaccurately describes the source code by referring to a generic 'identifier' and 'global list' without specifying that the function checks file descriptors against either the current parsefile chain or saved redirect table entries. The wording implies a broad matching mechanism unrelated to the actual fd-specific logic and COPYFD_RESTORE encoding in the function. This is a FATAL error in the PRIMARY PURPOSE because it misrepresents the core check performed, making the description misleading. No accurate, detailed claims are present to offset this error."
            ]
        },
        "cfg": {
            "summary": "Validates whether a given identifier matches entries in a global linked list or an indexed array within a structure and returns a success flag.",
            "score": [
                0.5,
                0.1,
                0.2
            ],
            "reason": [
                "The summary states that the function checks an identifier against a global linked list or an indexed array within a structure and returns a success flag. While the code indeed iterates through a global linked list of parsefile structs, the summary omits key specifics such as checking file descriptors, skipping fd==0 cases, applying a COPYFD_RESTORE bitwise operation, and comparing against saved redirect fds. The term 'identifier' is vague and not clearly tied to 'fd', and 'indexed array within a structure' loosely matches the two_fd array but lacks the specific comparison logic. Most claims are overly generic and miss important semantic details, resulting in partial alignment.",
                "The summary does not capture the core purpose, which is to check if a given file descriptor is hidden by appearing in open script parsefile fds or in saved redirect fds. It inaccurately describes the inputs as a generic 'identifier' and global linked list/indexed array, omitting domain-specific context like file descriptors, parsefile linkage, redirect table checks, and COPYFD_RESTORE handling. No accurate claims cover the primary domain action, resulting in a failure to reflect the function\u2019s actual semantics.",
                "The summary incorrectly describes the function as matching a generic identifier against a linked list or indexed array, which misrepresents the actual code that checks a file descriptor against a global parsefile list and saved redirect fds. This is a FATAL error on the primary purpose, as the core domain action \u2013 determining if an fd is hidden \u2013 is not captured. There are no accurate specifics and no useful gain, making it unusable."
            ]
        },
        "comment": {
            "summary": "Checks if a file descriptor is already in use by open scripts or saved redirects in the given redirection table.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function checks whether a file descriptor is in use due to either open scripts or saved redirects, which aligns with the code logic involving `g_parsefile` traversal and `rp->two_fd` checks. This description is accurate and focused on the function's semantics without introducing incorrect or irrelevant details, meaning all claims are consistent with the source code behavior.",
                "The summary accurately states the core purpose of the function: determining if a file descriptor is in use by open scripts or saved redirects in a redirection table. This matches the source code's primary operation of checking the provided fd against current parsefile entries and redirect pairs. However, it omits secondary details such as the special handling of fd == -1, skipping pf_fd == 0 due to interactive shell use cases, the COPYFD_RESTORE bitwise operation, and iteration specifics. The coverage of secondary behavior is limited, but the core is clearly captured.",
                "The summary correctly captures the primary purpose of the function: determining if a file descriptor is in use by either open scripts or saved redirects in a redirection table. This aligns with the code's checks of `g_parsefile` for matching `pf_fd` values and examining `rp->two_fd` entries after applying `COPYFD_RESTORE`. No contradictory or irrelevant claims are present, but the description is generic and lacks specific implementation details (e.g., skipping pf_fd == 0, bitwise operation with COPYFD_RESTORE), resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582823664,
    "strip_function_name": "sub_FFFFFFFF813CB4F0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF813CB4F0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        __int64 a14)\n{\n  char v14; // bl\n  __int64 v15; // r12\n  __int64 *v16; // r13\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // r8\n  __int64 v23; // r9\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  char v26; // [rsp-20h] [rbp-20h]\n\n  if ( *(_DWORD *)(a1 - 96) == 8 )\n  {\n    v15 = *(_QWORD *)(a1 - 184);\n    v16 = *(__int64 **)(v15 + 840);\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_edp_panel_off\",\n      (__int64)\"Turn eDP power off\\n\",\n      a13,\n      a14,\n      v14);\n    if ( !*(_BYTE *)(a1 + 912) )\n      sub_FFFFFFFF8103BAE0(\n        (__int64)\"drivers/gpu/drm/i915/intel_dp.c\",\n        1148,\n        (__int64)\"Need VDD to turn off panel\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9);\n    v19 = sub_FFFFFFFF813C8A00(a1);\n    sub_FFFFFFFF8138EC40(\n      v16,\n      (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v15 + 840) + 16LL) + 7LL) & 8) == 0 ? 815620 : 1970692,\n      v19 & 0xFFFFFFF0,\n      a2,\n      a3,\n      a4,\n      a5,\n      v20,\n      v21,\n      a8,\n      a9);\n    *(_BYTE *)(a1 + 912) = 0;\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_wait_panel_off\",\n      (__int64)\"Wait for panel power off time\\n\",\n      v22,\n      v23,\n      v26);\n    sub_FFFFFFFF813CA800(a1, 0xB000000F, 0, a2, a3, a4, a5, v24, v25, a8, a9);\n  }\n}\n",
    "function_name": "ironlake_edp_panel_off",
    "decompiled_code": "void __fastcall ironlake_edp_panel_off(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  volatile signed __int16 *v10; // r13\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int pp_control; // eax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  if ( *(_DWORD *)(a1 - 96) == 8 )\n  {\n    v9 = *(_QWORD *)(a1 - 184);\n    v10 = *(volatile signed __int16 **)(v9 + 840);\n    drm_ut_debug_printk(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_edp_panel_off\",\n      (__int64)\"Turn eDP power off\\n\",\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9);\n    if ( !*(_BYTE *)(a1 + 912) )\n      warn_slowpath_fmt(\n        \"drivers/gpu/drm/i915/intel_dp.c\",\n        0x47Cu,\n        (__int64)\"Need VDD to turn off panel\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n    pp_control = ironlake_get_pp_control(a1);\n    i915_write32(\n      v10,\n      (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v9 + 840) + 16LL) + 7LL) & 8) == 0 ? 815620 : 1970692,\n      pp_control & 0xFFFFFFF0,\n      a2,\n      a3,\n      a4,\n      a5,\n      v14,\n      v15,\n      a8,\n      a9);\n    *(_BYTE *)(a1 + 912) = 0;\n    drm_ut_debug_printk(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_wait_panel_off\",\n      (__int64)\"Wait for panel power off time\\n\",\n      a2,\n      a3,\n      a4,\n      a5,\n      v16,\n      v17,\n      a8,\n      a9);\n    ironlake_wait_panel_status(a1, 0xB000000F, 0, a2, a3, a4, a5, v18, v19, a8, a9);\n  }\n}\n",
    "source_code": "\nvoid ironlake_edp_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_device *dev = intel_dp_to_dev(intel_dp);\n\tstruct drm_i915_private *dev_priv = dev->dev_private;\n\tu32 pp;\n\tu32 pp_ctrl_reg;\n\n\tif (!is_edp(intel_dp))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"Turn eDP power off\\n\");\n\n\tWARN(!intel_dp->want_panel_vdd, \"Need VDD to turn off panel\\n\");\n\n\tpp = ironlake_get_pp_control(intel_dp);\n\t/* We need to switch off panel power _and_ force vdd, for otherwise some\n\t * panels get very unhappy and cease to work. */\n\tpp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = IS_VALLEYVIEW(dev) ? PIPEA_PP_CONTROL : PCH_PP_CONTROL;\n\n\tI915_WRITE(pp_ctrl_reg, pp);\n\tPOSTING_READ(pp_ctrl_reg);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tironlake_wait_panel_off(intel_dp);\n}",
    "comment": "Turns off eDP panel power by modifying control registers and ensuring no VDD is supplied, preventing panel damage during shutdown.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Enables DisplayPort functionality by initializing the panel , performing link training , and enabling backlight for the Intel display encoder .\n",
    "cpbcs_sum": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
    "misum_sum": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
    "decom_sum": "Turns off an Ironlake eDP panel in the i915 driver, ensuring VDD state, logging actions, and waiting for panel power-down timing.",
    "cfg_sum": "Turns off the Ironlake eDP panel, logs actions, ensures VDD status, updates power state, and waits for panel power-off completion.",
    "work_score": {
        "decom": {
            "summary": "Turns off an Ironlake eDP panel in the i915 driver, ensuring VDD state, logging actions, and waiting for panel power-down timing.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately states that the function turns off an Ironlake eDP panel, ensures VDD state, logs actions, and waits for panel power-down, all of which are clearly shown in the source code. These claims directly match the function's behavior without adding incorrect or irrelevant details, indicating high precision and alignment with the evaluation steps.",
                "The summary correctly identifies the core action of turning off an Ironlake eDP panel, which matches the function\u2019s primary purpose. It also notes ensuring VDD state, logging, and waiting for the panel to power down \u2014 all of which are accurate secondary behaviors from the code. However, it omits other critical implementation details such as the conditional early return if not eDP, the clearing of specific power control bits (POWER_TARGET_ON, EDP_FORCE_VDD, PANEL_POWER_RESET, EDP_BLC_ENABLE), the register choice based on Valleyview detection, and actual register writes, limiting completeness.",
                "The summary is generally accurate: it correctly identifies that the function turns off an Ironlake eDP panel in the i915 driver, checks/ensures VDD state, logs the action, and waits for panel power-down. These match the code semantics \u2014 the function gates execution to eDP panels, issues a debug log, warns if VDD is not set, writes to power control registers to turn off power and force VDD off, and calls a wait function. The coverage is slightly generic and omits low-level specifics (e.g., register write details), but there is no contradicting claim or irrelevant noise."
            ]
        },
        "cfg": {
            "summary": "Turns off the Ironlake eDP panel, logs actions, ensures VDD status, updates power state, and waits for panel power-off completion.",
            "score": [
                1.0,
                0.7,
                0.8
            ],
            "reason": [
                "The summary accurately reflects the core semantics of the function: it turns off the Ironlake eDP panel, includes logging actions, verifies VDD status, updates the power control register to change the power state, and waits for panel-off completion. All claims are domain-specific to the source code and match its behavior, with no incorrect or irrelevant statements.",
                "The summary accurately captures the core purpose of turning off the Ironlake eDP panel, matching the code\u2019s main domain action. It also includes several secondary details such as logging actions, checking/ensuring VDD status, updating the power state, and waiting for completion, all of which align with the source code's semantics. However, it omits mention of important branch logic (eDP type check), specific power register modifications, and chipset-specific register selection, so coverage is good but not complete.",
                "The summary contains accurate, concise statements about the function's purpose and behavior. It correctly states that the function turns off the Ironlake eDP panel, logs actions, checks/ensures VDD status, updates the power state, and waits for the panel to power off, all of which align with the source code. There is no noise or incorrect information, but the claims are somewhat generic and lack specific implementation details like bitmask clearing or register selection, resulting in modest informational gain."
            ]
        },
        "comment": {
            "summary": "Turns off eDP panel power by modifying control registers and ensuring no VDD is supplied, preventing panel damage during shutdown.",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function turns off the eDP panel power by modifying control registers, which matches the code's actions using `I915_WRITE` to update the panel power control register. However, the claim that it ensures no VDD is supplied is inaccurate: the code warns if `want_panel_vdd` is false and explicitly forces VDD off only after toggling bits, indicating VDD is actively managed during shutdown, not simply absent throughout. The mention of preventing panel damage is not directly supported by the code, as the comment refers to avoiding issues with certain panels but does not assert explicit damage prevention. This yields partial accuracy with notable overreach.",
                "The summary correctly captures the core purpose of turning off the eDP panel power and the removal of VDD, which matches the source code\u2019s main operation via modifying control registers. However, it omits several important secondary details such as the initial check for eDP type, the use of specific bitmask operations (POWER_TARGET_ON, EDP_FORCE_VDD, PANEL_POWER_RESET, EDP_BLC_ENABLE), branching based on IS_VALLEYVIEW for register selection, the WARN diagnostic, and the final wait for panel off. These omissions reduce completeness despite accurate core coverage.",
                "The summary accurately states the primary purpose: turning off the eDP panel by modifying control registers. However, it inaccurately claims that the function ensures no VDD is supplied to prevent panel damage, while the code clearly warns that VDD is needed to turn off the panel and initially forces VDD before switching it off. This contradicts core side-effect semantics (VDD handling), making it a severe FATAL error on a key I/O/side effect. The accurate portion is generic and lacks detail, resulting in low net benefit."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5730506,
    "strip_function_name": "sub_5770CA",
    "strip_decompiled_code": "__int64 __fastcall sub_5770CA(\n        _BYTE *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  __int64 v19; // r9\n  __int64 result; // rax\n  _QWORD v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = &a15;\n  v21[2] = &v22;\n  sub_5176F5(\n    a1,\n    v21,\n    0LL,\n    *(double *)a7.m128_u64,\n    *(double *)a8.m128_u64,\n    *(double *)a9.m128_u64,\n    *(double *)a10.m128_u64,\n    *(double *)a11.m128_u64,\n    *(double *)a12.m128_u64,\n    *(double *)a13.m128_u64,\n    *(double *)a14.m128_u64);\n  result = *(unsigned int *)qword_89A638;\n  if ( !(_DWORD)result )\n    sub_517B39((__int64)a1, (__int64)v21, v16, v17, v18, v19);\n  return result;\n}\n",
    "function_name": "die_if_script",
    "decompiled_code": "__int64 __fastcall die_if_script(\n        const __m128i *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 result; // rax\n  __int64 v19[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v20; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v21; // [rsp+28h] [rbp-B0h]\n  __int64 v22; // [rsp+30h] [rbp-A8h]\n  __int64 v23; // [rsp+38h] [rbp-A0h]\n  __int64 v24; // [rsp+40h] [rbp-98h]\n  __int64 v25; // [rsp+48h] [rbp-90h]\n  __m128 v26; // [rsp+50h] [rbp-88h]\n  __m128 v27; // [rsp+60h] [rbp-78h]\n  __m128 v28; // [rsp+70h] [rbp-68h]\n  __m128 v29; // [rsp+80h] [rbp-58h]\n  __m128 v30; // [rsp+90h] [rbp-48h]\n  __m128 v31; // [rsp+A0h] [rbp-38h]\n  __m128 v32; // [rsp+B0h] [rbp-28h]\n  __m128 v33; // [rsp+C0h] [rbp-18h]\n\n  v21 = a2;\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  if ( v15 )\n  {\n    v26 = a7;\n    v27 = a8;\n    v28 = a9;\n    v29 = a10;\n    v30 = a11;\n    v31 = a12;\n    v32 = a13;\n    v33 = a14;\n  }\n  v19[0] = 0x3000000008LL;\n  v19[1] = (__int64)&a15;\n  v19[2] = (__int64)&v20;\n  bb_verror_msg(\n    a1,\n    v19,\n    0LL,\n    *(double *)a7.m128_u64,\n    *(double *)a8.m128_u64,\n    *(double *)a9.m128_u64,\n    *(double *)a10.m128_u64,\n    *(double *)a11.m128_u64,\n    *(double *)a12.m128_u64,\n    *(double *)a13.m128_u64,\n    *(double *)a14.m128_u64);\n  result = *(unsigned int *)ptr_to_globals;\n  if ( !(_DWORD)result )\n    xfunc_die(\n      *(double *)a7.m128_u64,\n      *(double *)a8.m128_u64,\n      *(double *)a9.m128_u64,\n      *(double *)a10.m128_u64,\n      v16,\n      v17,\n      *(double *)a13.m128_u64,\n      *(double *)a14.m128_u64);\n  return result;\n}\n",
    "source_code": "\nstatic void die_if_script(unsigned lineno, const char *fmt, ...)\n{\n\tva_list p;\n\n#if HUSH_DEBUG >= 2\n\tbb_error_msg(\"hush.c:%u\", lineno);\n#endif\n\tva_start(p, fmt);\n\tbb_verror_msg(fmt, p, NULL);\n\tva_end(p);\n\tif (!G_interactive_fd)\n\t\txfunc_die();\n}",
    "comment": "Logs an error message with the line number and format specified, then terminates the program if not in interactive mode.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
    "cpbcs_sum": "Executes an error message using a variable argument list and handles the response if the call fails.\n",
    "misum_sum": "Formats and sends an error message using a variable argument list to the `bb_verror_msg` function.\n",
    "decom_sum": "Processes provided parameters into a fixed structure, calls a floating\u2011point handler, and executes a secondary routine if a global status flag is unset.",
    "cfg_sum": "Processes input parameters, forwards floating-point vector data to a handler, and triggers a secondary routine if a specific global status flag is unset.",
    "work_score": {
        "decom": {
            "summary": "Processes provided parameters into a fixed structure, calls a floating\u2011point handler, and executes a secondary routine if a global status flag is unset.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary contains multiple inaccuracies: it claims the function processes parameters into a fixed structure and calls a floating\u2011point handler, neither of which is supported by the source code. The actual code initializes a va_list from parameters, potentially logs a debug message, calls bb_verror_msg, and conditionally invokes xfunc_die based on a global flag. None of the summary's main claims match these semantics, resulting in 0% accurate claims.",
                "The summary does not accurately reflect the source code semantics. The function formats and logs an error message, potentially including the source line number, using variadic arguments, and terminates execution when not in interactive mode. The given summary incorrectly describes processing parameters into a fixed structure, calling a floating\u2011point handler, and executing another routine based on a global flag\u2014none of which occur in the code. The core purpose of error message formatting and conditional termination is entirely missing, and there are no accurate claims to support evaluation coverage.",
                "The summary is dominated by inaccurate claims. It describes processing parameters into a fixed structure and calling a floating-point handler, neither of which occurs in the source code. The actual function formats and logs error messages, and terminates if a global interactive flag is unset, so the 'secondary routine' claim loosely matches xfunc_die() but is vague. There are no accurate, specific insights; noise overwhelms any minimal correctness. Worst failure mode is NOISE."
            ]
        },
        "cfg": {
            "summary": "Processes input parameters, forwards floating-point vector data to a handler, and triggers a secondary routine if a specific global status flag is unset.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about processing input parameters, handling floating-point vector data, and triggering a routine based on a global status flag are mostly inaccurate. The source code is a function that processes a line number and a format string via variadic arguments, logs debug information, calls an error handler, and exits if a global interactive file descriptor is not set. No floating-point vectors or such specific data handling occur, so most claims contradict the actual function semantics.",
                "The summary's claims about processing parameters, handling floating\u2011point vector data, and triggering a routine based on a global flag are inaccurate. The source code shows the function formats and prints an error message with variadic arguments, conditionally logs debug info, and calls a termination routine if not interactive. None of the claims reflect this core purpose or other specific behaviors in the code, so the primary domain action is entirely missing.",
                "The summary contains only inaccurate claims. It describes processing floating-point vector data and forwarding it to a handler, which does not match the source code's behavior. The actual function handles formatted error messages, prints debug info, and exits if a global interactive flag is unset. The mismatch includes the primary purpose and I/O, making this a severe FATAL error on core functionality."
            ]
        },
        "comment": {
            "summary": "Logs an error message with the line number and format specified, then terminates the program if not in interactive mode.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly identifies that the function logs an error message including the provided line number and format string, and that it terminates the program if not in interactive mode. These details match the source code\u2019s behavior, including the conditional termination via xfunc_die when G_interactive_fd is false. No inaccurate or off-topic claims are present, so the summary is highly precise and aligns well with the function\u2019s semantics.",
                "The summary correctly states that the function logs an error message including a line number and format, and that it terminates the program when not in interactive mode, which matches the core purpose and a key conditional branch from the code. However, it omits secondary details such as the HUSH_DEBUG level check before printing the line number, the use of variable arguments, and the specific functions (bb_error_msg, bb_verror_msg, xfunc_die) involved. This results in partial but not comprehensive coverage of the source semantics.",
                "The summary accurately captures the core behavior: logging an error with a given line number and format, and terminating if not in interactive mode. These claims align with the source code's actions using bb_error_msg for debug mode and xfunc_die when G_interactive_fd is false. The information is concise and directly maps to the function\u2019s primary purpose with no contradictory or irrelevant noise, though it is relatively generic without mentioning conditional debug logging specifics. The worst failure mode is absent, and gain is moderate from clear, correct core description."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580415600,
    "strip_function_name": "sub_FFFFFFFF8117F670",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8117F670(\n        unsigned int a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // r13\n  __int64 v13; // rax\n  signed __int64 v14; // r14\n  int v15; // r15d\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rdx\n  __int64 v24; // [rsp+0h] [rbp-40h] BYREF\n  __int64 v25; // [rsp+8h] [rbp-38h]\n  unsigned int v26; // [rsp+10h] [rbp-30h]\n  int v27; // [rsp+14h] [rbp-2Ch]\n\n  v11 = -14LL;\n  if ( !((__PAIR128__(-(__int64)__CFADD__(a3, a2), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n        - ((unsigned __int64)a3\n         + a2)) >> 64) )\n  {\n    v13 = sub_FFFFFFFF8114FAA0(a1, &v24);\n    v14 = v13;\n    v15 = v24;\n    if ( !v13 )\n      return -9LL;\n    v24 = a2;\n    v25 = 0LL;\n    v26 = a3;\n    v27 = 0;\n    v16 = sub_FFFFFFFF81146A70(v13, (__int64)sub_FFFFFFFF8117E4F0, (__int64)&v24);\n    v22 = v25;\n    if ( v16 >= 0 )\n      v16 = v27;\n    if ( v25 )\n    {\n      v17 = *(_QWORD *)(v14 + 72);\n      *(_QWORD *)(v25 + 8) = v17;\n      v11 = (int)(a3 - v26);\n      if ( v15 )\nLABEL_10:\n        sub_FFFFFFFF81136100(v14, a4, a5, a6, a7, v20, v21, a10, a11, (__int64)sub_FFFFFFFF8117E4F0, v22, v17, v18, v19);\n    }\n    else\n    {\n      v11 = v16;\n      if ( v15 )\n        goto LABEL_10;\n    }\n  }\n  return v11;\n}\n",
    "function_name": "compat_sys_getdents64",
    "decompiled_code": "__int64 __fastcall compat_sys_getdents64(\n        unsigned int a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // r13\n  __int64 v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  signed __int64 v16; // r14\n  int v17; // r15d\n  int v18; // eax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 v22; // [rsp+0h] [rbp-40h] BYREF\n  __int64 v23; // [rsp+8h] [rbp-38h]\n  unsigned int v24; // [rsp+10h] [rbp-30h]\n  int v25; // [rsp+14h] [rbp-2Ch]\n\n  v11 = -14LL;\n  if ( !((__PAIR128__(-(__int64)__CFADD__(a3, a2), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n        - ((unsigned __int64)a3\n         + a2)) >> 64) )\n  {\n    v13 = fget_light(a1, &v22);\n    v16 = v13;\n    v17 = v22;\n    if ( !v13 )\n      return -9LL;\n    v22 = a2;\n    v23 = 0LL;\n    v24 = a3;\n    v25 = 0;\n    v18 = vfs_readdir(v13, (__int64)compat_filldir64, (__int64)&v22, a4, a5, a6, a7, v14, v15, a10, a11);\n    if ( v18 >= 0 )\n      v18 = v25;\n    if ( v23 )\n    {\n      *(_QWORD *)(v23 + 8) = *(_QWORD *)(v16 + 72);\n      v11 = (int)(a3 - v24);\n      if ( v17 )\nLABEL_10:\n        fput(v16, a4, a5, a6, a7, v19, v20, a10, a11);\n    }\n    else\n    {\n      v11 = v18;\n      if ( v17 )\n        goto LABEL_10;\n    }\n  }\n  return v11;\n}\n",
    "source_code": "\nasmlinkage long compat_sys_getdents64(unsigned int fd,\n\t\tstruct linux_dirent64 __user * dirent, unsigned int count)\n{\n\tstruct fd f;\n\tstruct linux_dirent64 __user * lastdirent;\n\tstruct compat_getdents_callback64 buf;\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tbuf.current_dir = dirent;\n\tbuf.previous = NULL;\n\tbuf.count = count;\n\tbuf.error = 0;\n\n\terror = vfs_readdir(f.file, compat_filldir64, &buf);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\ttypeof(lastdirent->d_off) d_off = f.file->f_pos;\n\t\tif (__put_user_unaligned(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "comment": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the results, handling errors and offsets.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information .\n",
    "cpbcs_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
    "misum_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
    "decom_sum": "Initializes a context, processes a data block with a callback, and invokes a computation routine if required, returning a status code.",
    "cfg_sum": "Validates input against system state, initializes and processes related data structures, and invokes further computations before returning a status code.",
    "work_score": {
        "decom": {
            "summary": "Initializes a context, processes a data block with a callback, and invokes a computation routine if required, returning a status code.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains vague, generic claims such as 'initializes a context' and 'processes a data block with a callback' which loosely map to parts of the function, but it omits critical, specific behaviors from the code like handling access checks, file descriptor validation, reading directory entries, and error handling. There are no precise domain-semantic details about directory reading or compatibility structure, making most claims non-distinguishing or inaccurate with respect to actual semantics.",
                "The summary's claims are generic and fail to capture the core domain-specific purpose of the function, which is to read directory entries in compat 64-bit format from a file descriptor using vfs_readdir and populate user-space buffers. It does not mention critical behaviors such as validating user write access, handling invalid file descriptors, populating offsets, and returning appropriate error codes. No accurate claim covers the core operation or key semantics of the source code.",
                "The summary provides only generic boilerplate about initializing context, using a callback, and returning a status code, which loosely applies but omits key specifics from the code such as directory entry reading, file descriptor validation, error handling, and writing the offset. There are no direct contradictions, but the lack of accurate, domain-specific details makes the information low-value. Noise from vague claims outweighs any gain."
            ]
        },
        "cfg": {
            "summary": "Validates input against system state, initializes and processes related data structures, and invokes further computations before returning a status code.",
            "score": [
                0.3,
                0.1,
                0.5
            ],
            "reason": [
                "The summary provides only vague, generic statements such as validation, initialization, processing, and returning a status code, which are broadly applicable to many functions and do not convey specific, verifiable semantics from the source code. These claims are too low-information to confirm precise behavior like access checks, file descriptor handling, use of vfs_readdir, or updating offsets, meaning less than half of the claims are accurately tied to the actual implementation.",
                "The summary contains only vague, generic statements that could apply to many functions and does not mention the specific core purpose of reading directory entries with compat_sys_getdents64 via vfs_readdir. It fails to identify the actual domain action, omits critical details like file descriptor validation, copying offsets, error handling, and buffer usage, resulting in no coverage of the core semantics.",
                "The summary makes only generic SAFE claims, such as validating input, initializing data structures, invoking computations, and returning a status code, which broadly match the source code but provide no specific or distinguishing details about core domain semantics like directory reading or compatibility handling. No FATAL inaccuracies are present, but the lack of detail yields low informational gain and minimal net benefit."
            ]
        },
        "comment": {
            "summary": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the results, handling errors and offsets.",
            "score": [
                0.8,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function retrieves directory entries from a file descriptor and writes them to a user-provided buffer, which aligns with the use of vfs_readdir and buffer management in the source code. It also notes error handling and offsets, which matches the code's handling of EFAULT, EBADF, and updating d_off. However, the description is somewhat generic and omits specifics such as the compat_sys_getdents64 context, access_ok verification, and the role of compat_filldir64, which reduces precision. Most claims are accurate but lack distinguishing technical detail.",
                "The summary correctly states that the function retrieves directory entries from a file descriptor and writes them into a user-provided buffer, which matches the core purpose of using vfs_readdir with compat_filldir64. It also notes handling of errors and offsets, aligning with the code's EFAULT/EBADF checks and updating d_off. However, it lacks specifics about compatibility behavior, access validation, and detailed branching, giving only a broad view of secondary semantics.",
                "The summary accurately describes the primary function: reading directory entries from a file descriptor into a user buffer, managing errors and offsets. All claims are specific to core semantics and consistent with the code, with no inaccuracies or noise. However, the description is brief and somewhat generic, lacking deeper insights into implementation details like `access_ok` checks, the use of `compat_filldir64`, or updating `d_off`. This yields a moderate gain due to correctness but limited specificity."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1154992,
    "strip_function_name": "gsl_multilarge_nlinear_eval_df",
    "strip_decompiled_code": "__int64 __fastcall gsl_multilarge_nlinear_eval_df(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        _QWORD *a4,\n        __int64 a5,\n        __int64 a6,\n        _QWORD *a7,\n        _QWORD *a8,\n        _QWORD *a9)\n{\n  bool v10; // zf\n  __int64 v11; // r8\n  __int64 v12; // rcx\n  __int64 (__fastcall *v13)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *); // r10\n  __int64 result; // rax\n\n  v10 = a4 == 0LL;\n  v11 = a7[3];\n  v12 = a7[4];\n  if ( v10 )\n  {\n    if ( !a8 )\n      goto LABEL_4;\n    if ( (_DWORD)a1 != 111 )\n    {\n      if ( (_DWORD)a1 != 112 )\n        goto LABEL_4;\nLABEL_23:\n      if ( *a8 == v12 )\n        goto LABEL_4;\n      goto LABEL_24;\n    }\nLABEL_15:\n    if ( *a8 == v11 )\n      goto LABEL_4;\nLABEL_24:\n    gsl_error(\"v vector has wrong size\", \"fdf.c\", 480LL, 19LL);\n    return 19LL;\n  }\n  if ( (_DWORD)a1 == 111 )\n  {\n    if ( *a4 != v12 )\n    {\nLABEL_19:\n      gsl_error(\"u vector has wrong size\", \"fdf.c\", 475LL, 19LL);\n      return 19LL;\n    }\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_15;\n  }\n  if ( (_DWORD)a1 == 112 )\n  {\n    if ( *a4 != v11 )\n      goto LABEL_19;\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_23;\n  }\nLABEL_4:\n  if ( !a9 || *a9 == v12 && a9[1] == v12 )\n  {\n    v13 = (__int64 (__fastcall *)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *))a7[1];\n    if ( v13 )\n    {\n      result = v13(a1, a2, a4, a7[5], a8, a9);\n      if ( a8 )\n        ++a7[7];\n      if ( a9 )\n        ++a7[8];\n    }\n  }\n  else\n  {\n    gsl_error(\"JTJ matrix has wrong size\", \"fdf.c\", 484LL, 19LL);\n    return 19LL;\n  }\n  return result;\n}\n",
    "function_name": "gsl_multilarge_nlinear_eval_df",
    "decompiled_code": "__int64 __fastcall gsl_multilarge_nlinear_eval_df(\n        __int64 TransJ,\n        const gsl_vector *x,\n        const gsl_vector *f,\n        const gsl_vector *u,\n        const gsl_vector *swts,\n        double h,\n        __int64 fdtype,\n        gsl_multilarge_nlinear_fdf *fdf,\n        gsl_vector *v,\n        gsl_matrix *JTJ,\n        gsl_vector *work,\n        gsl_block **a12,\n        gsl_block **a13)\n{\n  bool v14; // zf\n  gsl_block *block; // r8\n  gsl_block *v16; // rcx\n  __int64 (__fastcall *stride)(__int64, const gsl_vector *, const gsl_vector *, size_t, gsl_block **, gsl_block **, double); // r10\n  __int64 result; // rax\n\n  v14 = u == 0LL;\n  block = work->block;\n  v16 = *(gsl_block **)&work->owner;\n  if ( v14 )\n  {\n    if ( !a12 )\n      goto LABEL_4;\n    if ( (_DWORD)TransJ != 111 )\n    {\n      if ( (_DWORD)TransJ != 112 )\n        goto LABEL_4;\nLABEL_23:\n      if ( *a12 == v16 )\n        goto LABEL_4;\n      goto LABEL_24;\n    }\nLABEL_15:\n    if ( *a12 == block )\n      goto LABEL_4;\nLABEL_24:\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n      \"v vector has wrong size\",\n      \"fdf.c\",\n      480LL,\n      19LL,\n      block,\n      fdtype,\n      h);\n    return 19LL;\n  }\n  if ( (_DWORD)TransJ == 111 )\n  {\n    if ( (gsl_block *)u->size != v16 )\n    {\nLABEL_19:\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n        \"u vector has wrong size\",\n        \"fdf.c\",\n        475LL,\n        19LL,\n        block,\n        fdtype,\n        h);\n      return 19LL;\n    }\n    if ( !a12 )\n      goto LABEL_4;\n    goto LABEL_15;\n  }\n  if ( (_DWORD)TransJ == 112 )\n  {\n    if ( (gsl_block *)u->size != block )\n      goto LABEL_19;\n    if ( !a12 )\n      goto LABEL_4;\n    goto LABEL_23;\n  }\nLABEL_4:\n  if ( !a13 || *a13 == v16 && a13[1] == v16 )\n  {\n    stride = (__int64 (__fastcall *)(__int64, const gsl_vector *, const gsl_vector *, size_t, gsl_block **, gsl_block **, double))work->stride;\n    if ( stride )\n    {\n      result = stride(TransJ, x, u, work[1].size, a12, a13, h);\n      if ( a12 )\n        ++work[1].data;\n      if ( a13 )\n        ++work[1].block;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n      \"JTJ matrix has wrong size\",\n      \"fdf.c\",\n      484LL,\n      19LL,\n      block,\n      fdtype,\n      h);\n    return 19LL;\n  }\n  return result;\n}\n",
    "source_code": "\nint\ngsl_multilarge_nlinear_eval_df(const CBLAS_TRANSPOSE_t TransJ,\n                               const gsl_vector *x,\n                               const gsl_vector *f,\n                               const gsl_vector *u,\n                               const gsl_vector *swts,\n                               const double h,\n                               const gsl_multilarge_nlinear_fdtype fdtype,\n                               gsl_multilarge_nlinear_fdf *fdf,\n                               gsl_vector *v,\n                               gsl_matrix *JTJ,\n                               gsl_vector *work)\n{\n  const size_t n = fdf->n;\n  const size_t p = fdf->p;\n\n  if (u != NULL && ((TransJ == CblasNoTrans && u->size != p) ||\n                    (TransJ == CblasTrans && u->size != n)))\n    {\n      GSL_ERROR(\"u vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (v != NULL && ((TransJ == CblasNoTrans && v->size != n) ||\n                         (TransJ == CblasTrans && v->size != p)))\n    {\n      GSL_ERROR(\"v vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (JTJ != NULL && ((JTJ->size1 != p) || (JTJ->size2 != p)))\n    {\n      GSL_ERROR(\"JTJ matrix has wrong size\", GSL_EBADLEN);\n    }\n  else\n    {\n      int status;\n\n      if (fdf->df)\n        {\n          /* call user-supplied function */\n          status = ((*((fdf)->df)) (TransJ, x, u, fdf->params, v, JTJ));\n\n          if (v)\n            ++(fdf->nevaldfu);\n\n          if (JTJ)\n            ++(fdf->nevaldf2);\n        }\n      else\n        {\n#if 0\n          /* use finite difference Jacobian approximation */\n          status = gsl_multilarge_nlinear_df(h, fdtype, x, swts, fdf, f, df, work);\n#endif\n        }\n\n      return status;\n    }\n}",
    "comment": "Evaluates the Jacobian or its finite difference approximation for a nonlinear optimization problem, checking vector and matrix sizes for validity.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Evaluates the Jacobian matrix of a nonlinear model using either a user-defined function or finite difference approximation based on the provided inputs .\n",
    "cpbcs_sum": "Evaluates the result of a finite automaton based on the specified condition, adjusting the result and weight accordingly.\n",
    "misum_sum": "Evaluates a nonlinear fitting function, applying user-defined and function functions based on given type and function and function arguments, and updates results accordingly.\n",
    "decom_sum": "Validates vector and matrix sizes for specific operation codes and invokes the associated callback, reporting errors with `gsl_error` when dimensions mismatch.",
    "cfg_sum": "Validates vector and matrix sizes for specific operation codes, reports errors via `gsl_error`, and calls the evaluation routine if inputs are correct.",
    "work_score": {
        "decom": {
            "summary": "Validates vector and matrix sizes for specific operation codes and invokes the associated callback, reporting errors with `gsl_error` when dimensions mismatch.",
            "score": [
                0.8,
                0.3,
                0.6
            ],
            "reason": [
                "The summary correctly describes that the function checks vector and matrix dimensions against expected sizes and calls a callback function if valid, aligning with the code's logic. However, it inaccurately states that errors are reported with `gsl_error`; the code uses `GSL_ERROR`. This is a minor semantic mismatch, but most of the claims are still accurate and reflect the source code behavior.",
                "The summary correctly notes that the function validates vector and matrix sizes and calls a callback, aligning with the size checks and invocation of `fdf->df` in the code. However, it inaccurately states that errors are reported via `gsl_error`, while the code uses the `GSL_ERROR` macro. More critically, it fails to capture the core purpose of evaluating the derivative function (`df`) in a large-scale nonlinear fitting context, determined by Jacobian transpose dimensions and parameters. The summary omits key domain semantics such as handling different transpose modes, tracking evaluation counts (`nevaldfu` and `nevaldf2`), and considers an optional finite difference approximation path. These omissions and the inaccuracy prevent full alignment.",
                "The summary correctly captures two specific and accurate aspects of the function: it validates vector and matrix sizes for certain conditions and calls a callback when appropriate. However, it inaccurately states that errors are reported with `gsl_error`, whereas the actual code uses `GSL_ERROR`. This is a minor inaccuracy but not a severe FATAL error affecting primary purpose or I/O. The summary omits details like different size checks depending on transpose mode and tracking evaluation counters, which limits positive gain. Overall, accuracy is fair with low noise and moderate specificity."
            ]
        },
        "cfg": {
            "summary": "Validates vector and matrix sizes for specific operation codes, reports errors via `gsl_error`, and calls the evaluation routine if inputs are correct.",
            "score": [
                0.9,
                0.3,
                0.5
            ],
            "reason": [
                "The summary accurately states that the function validates vector and matrix sizes and reports errors if incorrect, aligning with specific checks in the code. It also correctly notes that the evaluation routine is called when inputs are valid, matching the `fdf->df` function call logic. While it omits details like handling `TransJ` conditions and the specific error macro name `GSL_ERROR`, the core claims are precise and consistent with the source, yielding a high proportion of accurate statements.",
                "The summary correctly notes size validation and error reporting, aligning with the code\u2019s conditional checks and GSL_ERROR calls, but it misstates the core purpose. The function\u2019s primary role is to compute and evaluate the Jacobian or related derivative quantities via a user-supplied df callback when inputs are valid, which is not explicitly captured. Secondary details, such as branch conditions for u, v, and JTJ, counter increments, and handling of missing df via finite difference, are also omitted.",
                "The summary correctly notes that the function validates vector and matrix sizes and invokes an evaluation routine if inputs are valid, which aligns with the code. However, it inaccurately states that errors are reported via `gsl_error` when the code actually uses `GSL_ERROR`, and omits key specifics such as the conditional dimension checks based on `TransJ`, handling of different input pointers (`u`, `v`, `JTJ`), and incrementing evaluation counters. The inaccuracies are minor (NOISE) rather than central FATAL errors, but the summary provides only broad SAFE claims with little detail, leading to low informational gain."
            ]
        },
        "comment": {
            "summary": "Evaluates the Jacobian or its finite difference approximation for a nonlinear optimization problem, checking vector and matrix sizes for validity.",
            "score": [
                0.5,
                0.5,
                0.6
            ],
            "reason": [
                "The summary contains two main claims: (1) the function evaluates the Jacobian or uses a finite difference approximation, and (2) it checks vector and matrix sizes for validity. The second claim is accurate based on the multiple size checks for u, v, and JTJ in the code. The first claim is only partially accurate; while the function can evaluate the Jacobian via a user-supplied function, the finite difference branch is disabled with `#if 0` and thus is not executed. This makes the first claim misleading regarding actual behavior. With one accurate claim and one partially inaccurate claim, the proportion of accurate information is around 50%, indicating mixed reliability.",
                "The summary correctly identifies that the function evaluates the Jacobian (or a finite difference approximation) and performs size checks on input vectors and matrices, which aligns with the core purpose of the code. However, it inaccurately implies that the finite difference approximation is used in practice, whereas the relevant code is disabled with `#if 0`. It omits key secondary details such as the handling of `TransJ` for transpose logic, specific error conditions and codes, interaction with the user-supplied `df` callback, and updates to evaluation counters. Coverage of the core is present but secondary semantics are thin.",
                "The summary correctly states that the function checks vector and matrix sizes for validity, which matches the explicit size checks in the source code. It also describes the function as evaluating the Jacobian or its finite difference approximation, which is partially accurate: the code can call a user-supplied derivative function, and there is a commented-out block for finite difference approximation that is not currently active. The finite difference detail is thus misleading, introducing minor noise but not a fatal error about the primary purpose. The claims are otherwise aligned but provide low informational gain due to being generic and omitting specifics like how TransJ affects size expectations."
            ]
        }
    }
}
{
    "project_name": "poke",
    "function_addr": 794656,
    "strip_function_name": "sub_C2020",
    "strip_decompiled_code": "__int64 __fastcall sub_C2020(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(_QWORD))\n{\n  unsigned __int64 v6; // rax\n  unsigned __int64 v7; // rdx\n  _QWORD *v8; // rbx\n  __int64 result; // rax\n  __int64 v10; // rsi\n  __int64 v11; // rdx\n  _QWORD *v12; // rsi\n  _QWORD *v13; // rax\n  unsigned __int64 v14; // rcx\n  unsigned __int64 v15; // [rsp+8h] [rbp-30h]\n  __int64 (__fastcall *v16)(_QWORD); // [rsp+8h] [rbp-30h]\n\n  v6 = a1[1];\n  if ( v6 >= (3 * *a1) >> 2 )\n  {\n    v16 = a4;\n    sub_17CF7(a1, (__int64)a4);\n    v6 = a1[1];\n    a4 = v16;\n  }\n  a1[1] = v6 + 1;\n  v7 = a4(a2) % *a1;\n  v8 = *(_QWORD **)(a1[2] + 8 * v7);\n  if ( v8 )\n  {\n    result = v8[2];\n  }\n  else\n  {\n    v15 = v7;\n    v13 = (_QWORD *)sub_C3420(24LL);\n    *v13 = 4LL;\n    v13[1] = 0LL;\n    v8 = v13;\n    result = sub_C3420(64LL);\n    v14 = a1[2];\n    v8[2] = result;\n    *(_QWORD *)(v14 + 8 * v15) = v8;\n  }\n  v10 = v8[1];\n  if ( v10 == *v8 )\n  {\n    *v8 = 2 * v10;\n    result = sub_C3470(result);\n    v10 = v8[1];\n    v8[2] = result;\n  }\n  v11 = v10 + 1;\n  v12 = (_QWORD *)(result + 16 * v10);\n  v8[1] = v11;\n  *v12 = a2;\n  v12[1] = a3;\n  return result;\n}\n",
    "function_name": "jitter_hash_table_add",
    "decompiled_code": "void __fastcall jitter_hash_table_add(\n        jitter_hash_table *t,\n        const jitter_word key,\n        const jitter_word value,\n        jitter_hash_function f)\n{\n  size_t binding_no; // rax\n  jitter_uint v7; // rdx\n  jitter_hash_bucket *v8; // rbx\n  jitter_hash_binding *bindings; // rax\n  size_t used_binding_no; // rsi\n  size_t v11; // rdx\n  jitter_word *p_key; // rsi\n  jitter_hash_bucket *v13; // rax\n  jitter_hash_bucket **buckets; // rcx\n  jitter_uint v15; // [rsp+40h] [rbp+8h]\n  jitter_uint (*v16)(const jitter_word); // [rsp+40h] [rbp+8h]\n\n  binding_no = t->binding_no;\n  if ( binding_no >= (3 * t->bucket_no) >> 2 )\n  {\n    v16 = f;\n    jitter_hash_table_enlarge(t, f);\n    binding_no = t->binding_no;\n    f = v16;\n  }\n  t->binding_no = binding_no + 1;\n  v7 = f(key) % t->bucket_no;\n  v8 = t->buckets[v7];\n  if ( v8 )\n  {\n    bindings = v8->bindings;\n  }\n  else\n  {\n    v15 = v7;\n    v13 = (jitter_hash_bucket *)jitter_xmalloc(0x18uLL);\n    v13->allocated_binding_no = 4LL;\n    v13->used_binding_no = 0LL;\n    v8 = v13;\n    bindings = (jitter_hash_binding *)jitter_xmalloc(0x40uLL);\n    buckets = t->buckets;\n    v8->bindings = bindings;\n    buckets[v15] = v8;\n  }\n  used_binding_no = v8->used_binding_no;\n  if ( used_binding_no == v8->allocated_binding_no )\n  {\n    v8->allocated_binding_no = 2 * used_binding_no;\n    bindings = (jitter_hash_binding *)jitter_xrealloc(bindings, 32 * used_binding_no);\n    used_binding_no = v8->used_binding_no;\n    v8->bindings = bindings;\n  }\n  v11 = used_binding_no + 1;\n  p_key = &bindings[used_binding_no].key;\n  v8->used_binding_no = v11;\n  p_key->fixnum = key.fixnum;\n  p_key[1].fixnum = value.fixnum;\n}\n",
    "source_code": "\nvoid\njitter_hash_table_add (struct jitter_hash_table *t,\n                       const union jitter_word key,\n                       const union jitter_word value,\n                       jitter_hash_function f)\n{\n  /* We only enlarge the table (when it's getting too full) on add, and never\n     shrink it. */\n  if (jitter_hash_table_overfull (t))\n    jitter_hash_table_enlarge (t, f);\n\n  t->binding_no ++;\n  jitter_uint bucket_index = f (key) % t->bucket_no;\n\n  /* Find the bucket; make it if needed. */\n  struct jitter_hash_bucket *b = t->buckets [bucket_index];\n  if (b == NULL)\n    {\n      b = jitter_xmalloc (sizeof (struct jitter_hash_bucket));\n      b->allocated_binding_no = INITIAL_BINDING_NO_PER_BUCKET;\n      b->used_binding_no = 0;\n      b->bindings\n        = jitter_xmalloc (sizeof (struct jitter_hash_binding)\n                          * INITIAL_BINDING_NO_PER_BUCKET);\n      t->buckets [bucket_index] = b;\n    }\n\n  /* Find the binding where we need to write within the bucket; make place and\n     reallocate if needed. */\n  if (b->used_binding_no == b->allocated_binding_no)\n    {\n      //printf (\"enlarging the %i-th bucket: %li to %li\\n\", (int)bucket_index, (long)b->allocated_binding_no, (long)(b->allocated_binding_no * 2));\n\n      b->bindings = jitter_xrealloc (b->bindings,\n                                     sizeof (struct jitter_hash_binding)\n                                     * (b->allocated_binding_no *= 2));\n    }\n  struct jitter_hash_binding *bi = b->bindings + (b->used_binding_no ++);\n  bi->key = key;\n  bi->value = value;\n}",
    "comment": "Adds a key-value pair to a jitter hash table, reallocating bucket space if necessary, while ensuring the table size increases when overfull.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Sorts an array of pointers using the merge sort algorithm , leveraging a temporary array for merging during the sorting process .\n",
    "cpbcs_sum": "Adds a new entry to an array, reallocating memory if necessary, and initializes the entry's data to accommodate the new entry.\n",
    "misum_sum": "Inserts an element into a hash table using a key and an associated key, resizing the array as needed.\n",
    "decom_sum": "Inserts a key\u2013value pair into a hash table, expanding buckets or resizing entry arrays when load thresholds are exceeded.",
    "cfg_sum": "Inserts a key-value pair into a hash table, expanding buckets when necessary, and allocates or resizes entries to store associated data.",
    "work_score": {
        "decom": {
            "summary": "Inserts a key\u2013value pair into a hash table, expanding buckets or resizing entry arrays when load thresholds are exceeded.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function inserts a key\u2013value pair into a hash table and that it expands buckets or resizes arrays under certain conditions. These behaviors match the source code, which enlarges the table when overfull, allocates buckets when missing, and reallocates bindings when the bucket is full. There are no inaccurate claims, and all claims are fact-based and relevant to the function's semantics.",
                "The summary accurately describes inserting a key\u2013value pair into a hash table and mentions expansion when thresholds are exceeded, covering the core purpose of adding an entry and resizing. However, it omits important secondary details from the source code, such as the check for table overfull before enlarging, the specific handling of bucket creation with initial binding allocations, and the condition for reallocating bindings when the bucket is full. These omissions reduce completeness despite the core being covered.",
                "The summary correctly states that the function inserts a key\u2013value pair into a hash table and expands storage when certain thresholds are met, which aligns with the code\u2019s behavior of enlarging the table if overfull and reallocating bucket bindings when capacity is reached. However, the summary slightly conflates two concepts by mentioning 'resizing entry arrays when load thresholds are exceeded'; array resizing occurs when a bucket is full, not based on table load thresholds. Despite this minor imprecision, there are no fatal inaccuracies, and the core purpose is captured with reasonable specificity. Noise is minimal, but the gain is moderate due to the summary\u2019s omission of details like separate conditions for table vs bucket resizing."
            ]
        },
        "cfg": {
            "summary": "Inserts a key-value pair into a hash table, expanding buckets when necessary, and allocates or resizes entries to store associated data.",
            "score": [
                0.9,
                0.7,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function inserts a key-value pair, may expand buckets when necessary, and allocates or resizes entries to store associated data. These claims align with the source code: the function increments binding count, creates a bucket if absent, and reallocates bindings when the bucket is full. It omits minor details such as enlarging the table when overfull, but most claims are accurate and directly reflect the code's behavior.",
                "The summary accurately describes the core functionality of inserting a key-value pair into a hash table and notes bucket expansion and allocation/resizing when needed, which matches the source code's domain semantics. It covers the primary purpose of the function and includes key secondary behavior (allocation of new buckets and resizing bindings). However, it omits mention of the overfull table check and enlargement of the entire hash table, as well as incrementing the binding count, meaning coverage is good but not exhaustive.",
                "The summary accurately captures the primary purpose of the function: inserting a key-value pair into a hash table, expanding buckets and allocating or resizing storage as needed. It aligns with the code's logic for enlarging the table if overfull, allocating a bucket if missing, and resizing bindings when capacity is reached. There are no incorrect or noisy claims, but the description is somewhat generic and lacks specific details such as the hash function usage for bucket indexing and the lack of table shrinking. The worst failure mode is absent; overall gain is modest due to limited specificity."
            ]
        },
        "comment": {
            "summary": "Adds a key-value pair to a jitter hash table, reallocating bucket space if necessary, while ensuring the table size increases when overfull.",
            "score": [
                1.0,
                0.8,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function adds a key-value pair to a jitter hash table, reallocates bucket space when a bucket is full, and enlarges the table when it is overfull. These details align with the source code's behavior, and no inaccurate or irrelevant claims are present. All claims are accurate and specific to the function's semantics, yielding a high proportion of accurate content.",
                "The summary correctly identifies that the function adds a key-value pair, triggers table enlargement when overfull, and reallocates bucket space when needed, matching the source code's core purpose and key secondary behaviors. It omits some finer details, such as bucket creation when absent, initial allocation sizes, and binding count tracking, but still captures the essential domain-specific behavior with reasonable accuracy.",
                "The summary is accurate: it correctly states that the function adds a key-value pair, enlarges the table when overfull, and reallocates bucket space when necessary. All claims align with the source code's behavior and target core semantics without contradiction. The statements are concise but somewhat generic, offering moderate detail on resizing and bucket allocation, resulting in a reasonable net benefit with minimal noise."
            ]
        }
    }
}
{
    "project_name": "squashfs",
    "function_addr": 93040,
    "strip_function_name": "sub_16B70",
    "strip_decompiled_code": "__int64 __fastcall sub_16B70(__int64 a1, unsigned int a2, __int64 *a3)\n{\n  __int64 v4; // rcx\n  __int64 *v5; // rbx\n  __int64 result; // rax\n  __int64 v7; // rdx\n  __int64 v8; // r13\n  __int64 v9; // rcx\n  __int64 v10; // rax\n\n  v4 = a3[1];\n  v5 = *(__int64 **)(a1 + 48);\n  result = qword_829940[(unsigned __int16)v4];\n  if ( result )\n  {\n    v7 = *a3;\n    while ( *(_QWORD *)result != v7 || v4 != *(_QWORD *)(result + 8) )\n    {\n      result = *(_QWORD *)(result + 24);\n      if ( !result )\n        goto LABEL_7;\n    }\n    a2 = *(_DWORD *)(result + 16);\n  }\nLABEL_7:\n  while ( v5 )\n  {\n    v8 = v5[3];\n    if ( !*(_BYTE *)(v8 + 174) )\n    {\n      result = *(_DWORD *)(v8 + 24) & 0xF000;\n      if ( (_DWORD)result == 0x4000 )\n      {\n        result = sub_16B70(v5[4], a2, v5[3]);\n        v5 = (__int64 *)v5[6];\n        continue;\n      }\n      if ( (_DWORD)result == 0x8000 )\n      {\n        sub_72F0(v5);\n        v9 = *(_QWORD *)(v8 + 8);\n        v10 = qword_829940[(unsigned __int16)v9];\n        if ( !v10 )\n        {\nLABEL_21:\n          result = (__int64)sub_16660((__int64)v5, a2);\n          v5 = (__int64 *)v5[6];\n          continue;\n        }\n        while ( *(_QWORD *)v10 != *(_QWORD *)v8 || v9 != *(_QWORD *)(v10 + 8) )\n        {\n          v10 = *(_QWORD *)(v10 + 24);\n          if ( !v10 )\n            goto LABEL_21;\n        }\n        result = (__int64)sub_16660((__int64)v5, *(_DWORD *)(v10 + 16));\n      }\n    }\n    v5 = (__int64 *)v5[6];\n  }\n  return result;\n}\n",
    "function_name": "generate_file_priorities",
    "decompiled_code": "__int64 __fastcall generate_file_priorities(\n        __int64 a1,\n        unsigned int a2,\n        __int64 *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int64 v12; // rcx\n  __int64 v13; // rbx\n  __int64 result; // rax\n  __int64 v15; // rdx\n  __int64 v16; // r13\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rcx\n  __int64 v20; // rax\n\n  v12 = a3[1];\n  v13 = *(_QWORD *)(a1 + 48);\n  result = sort_info_list[(unsigned __int16)v12];\n  if ( result )\n  {\n    v15 = *a3;\n    while ( *(_QWORD *)result != v15 || v12 != *(_QWORD *)(result + 8) )\n    {\n      result = *(_QWORD *)(result + 24);\n      if ( !result )\n        goto LABEL_7;\n    }\n    a2 = *(_DWORD *)(result + 16);\n  }\nLABEL_7:\n  while ( v13 )\n  {\n    v16 = *(_QWORD *)(v13 + 24);\n    if ( !*(_BYTE *)(v16 + 174) )\n    {\n      result = *(_DWORD *)(v16 + 24) & 0xF000;\n      if ( (_DWORD)result == 0x4000 )\n      {\n        result = generate_file_priorities(*(_QWORD *)(v13 + 32), a2, *(__int64 **)(v13 + 24));\n        v13 = *(_QWORD *)(v13 + 48);\n        continue;\n      }\n      if ( (_DWORD)result == 0x8000 )\n      {\n        pathname((__int64 *)v13);\n        v19 = *(_QWORD *)(v16 + 8);\n        v20 = sort_info_list[(unsigned __int16)v19];\n        if ( !v20 )\n        {\nLABEL_21:\n          result = (__int64)add_priority_list(v13, a2, a4, a5, a6, a7, v17, v18, a10, a11);\n          v13 = *(_QWORD *)(v13 + 48);\n          continue;\n        }\n        while ( *(_QWORD *)v20 != *(_QWORD *)v16 || v19 != *(_QWORD *)(v20 + 8) )\n        {\n          v20 = *(_QWORD *)(v20 + 24);\n          if ( !v20 )\n            goto LABEL_21;\n        }\n        result = (__int64)add_priority_list(v13, *(_DWORD *)(v20 + 16), a4, a5, a6, a7, v17, v18, a10, a11);\n      }\n    }\n    v13 = *(_QWORD *)(v13 + 48);\n  }\n  return result;\n}\n",
    "source_code": "\n\nvoid generate_file_priorities(struct dir_info *dir, int priority,\n\tstruct stat *buf)\n{\n\tstruct dir_ent *dir_ent = dir->list;\n\n\tpriority = get_priority(dir->pathname, buf, priority);\n\n\tfor(; dir_ent; dir_ent = dir_ent->next) {\n\t\tstruct stat *buf = &dir_ent->inode->buf;\n\t\tif(dir_ent->inode->root_entry)\n\t\t\tcontinue;\n\n\t\tswitch(buf->st_mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tadd_priority_list(dir_ent,\n\t\t\t\t\tget_priority(pathname(dir_ent), buf,\n\t\t\t\t\tpriority));\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tgenerate_file_priorities(dir_ent->dir,\n\t\t\t\t\tpriority, buf);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "comment": "Recursively assigns priority values to regular files and directories within a specified directory structure based on their pathnames and inode information.",
    "hext5_sum": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
    "bint5_sum": "Finds the next available port for a given PCI device and updates the last port ID accordingly .\n",
    "cpbcs_sum": "Retrieves a specified database from the connection and sends it to the error if the connection is not marked as a local symbol.\n",
    "misum_sum": "The function skips whitespace and sets the next element in a directory structure, handling local and pattern matching as needed.\n",
    "decom_sum": "Traverses a hierarchical structure to match identifiers in lookup tables and apply node-specific handling based on type flags.",
    "cfg_sum": "Traverses and validates hierarchical linked structures, matching entries against a lookup table, and recursively processes or updates nodes based on type-specific flags and identifiers.",
    "work_score": {
        "decom": {
            "summary": "Traverses a hierarchical structure to match identifiers in lookup tables and apply node-specific handling based on type flags.",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function matches identifiers in lookup tables and applies node-specific handling based on type flags, which does not align with the source code. The code instead computes and propagates file priorities by traversing a directory structure, checking entry types via st_mode, and either adding to a priority list for regular files or recursively processing subdirectories. No lookup tables or identifier matching are present, making the sole claim inaccurate and resulting in no accurate claims.",
                "The summary's claim about traversing a hierarchical structure and applying node-specific handling is only vaguely aligned with the code. The source code assigns priorities to directory entries based on file types (regular files and directories) and recursively processes subdirectories, which is the core purpose. The summary omits any mention of priorities, stat mode checks, recursion specifics, or external calls to get_priority/add_priority_list, and introduces unrelated 'lookup tables' and 'identifiers' that are not present in the code. Thus, the core function's domain-specific purpose is not covered.",
                "The summary makes a generic claim about traversing a hierarchical structure, which loosely matches the function's directory traversal. However, it inaccurately describes the core logic as matching identifiers in lookup tables and applying node-specific handling based on type flags, which does not occur in the source code. Instead, the actual core purpose is to compute and assign file priorities based on file type (regular file or directory), using specific functions like get_priority and add_priority_list. This constitutes a FATAL error on the primary purpose, making the summary untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Traverses and validates hierarchical linked structures, matching entries against a lookup table, and recursively processes or updates nodes based on type-specific flags and identifiers.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function\u2019s behavior. The source code shows that it iterates over directory entries, determines priorities using get_priority, and processes regular files or subdirectories based on file type, without any validation logic, lookup tables, or type-specific flags/identifiers mentioned in the summary. Most claims in the summary are unrelated to or contradict the actual code, resulting in very low accuracy.",
                "The summary does not match the core primary purpose of recursively assigning file priorities within a directory hierarchy based on file type. Claims about 'validating hierarchical linked structures' and 'matching entries against a lookup table' are inaccurate as these behaviors do not occur in the source code. No accurate claim covers the core operation of using get_priority to update the priority list for regular files or recursing into subdirectories. Secondary details such as skipping root entries and handling different file types are also missing.",
                "The summary contains multiple inaccurate claims about the code\u2019s core purpose. It states that the function validates structures, matches entries against a lookup table, and uses type-specific flags/identifiers, none of which are present in the source. The actual function recursively processes directory entries, adjusting file priorities based on file type, but there is no validation, lookup table, or flag-based logic. These contradictions target the core semantics, making them FATAL errors on the primary purpose."
            ]
        },
        "comment": {
            "summary": "Recursively assigns priority values to regular files and directories within a specified directory structure based on their pathnames and inode information.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly captures the recursive nature of the function and its assignment of priorities to regular files and directories based on their pathnames and inode data. These details align accurately with the source code's behavior, and no claims contradict the implementation, yielding a high proportion of accurate statements.",
                "The summary correctly captures the core purpose of recursively assigning priorities to files and directories based on pathnames and inode data, aligning with the function\u2019s main logic. However, it omits important secondary details from the source code, such as skipping entries marked as root_entry, the distinction in handling between regular files and directories, and the use of get_priority and add_priority_list. These omissions reduce coverage of other key behavior-critical semantics.",
                "The summary correctly captures the primary purpose of the function: recursively processing directories and assigning priorities to regular files and subdirectories based on pathname and inode data. This aligns with the observed use of get_priority, add_priority_list, and recursion in the source code. There are no contradictory or irrelevant claims, and while the statement is accurate, it is somewhat generic and lacks detail on specific logic like skipping root entries or the exact mode checks. The main shortcoming is low informational depth rather than inaccuracy."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 67936,
    "strip_function_name": "sub_10960",
    "strip_decompiled_code": "__int64 __fastcall sub_10960(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rbp\n  __int64 v9; // r14\n  __int64 v10; // r12\n  __int64 v11; // r13\n  __int64 v12; // rdx\n  __int64 v13; // rdi\n  unsigned __int64 v14; // r15\n  __int64 result; // rax\n  __int64 v16; // rbp\n  __int64 v17; // rdi\n  __int64 v18; // r8\n  unsigned __int64 v19; // r14\n\n  v7 = a1[19];\n  v8 = a1[3];\n  v9 = a1[5];\n  v10 = a1[6];\n  v11 = a1[7];\n  v12 = a1[20];\n  v13 = *a1;\n  if ( !v7 )\n  {\n    v14 = sub_2AA70(v13, v8, v9, v12, a5, a6, *((_OWORD *)a1 + 7), a1[16], a1[17]);\n    result = sub_F240(v14);\n    if ( !(_DWORD)result )\n    {\n      v16 = v9 + v8;\n      sub_29080(*a1, 0LL, 1LL);\n      v17 = *a1;\n      if ( *((_DWORD *)a1 + 20) )\n        goto LABEL_4;\nLABEL_12:\n      v19 = sub_2A9E0(v17, v10, v11, v16, 0LL);\n      result = sub_F240(v19);\n      if ( (_DWORD)result )\n      {\n        a1[8] = v19;\n        goto LABEL_9;\n      }\n      sub_29320(*a1);\n      v17 = *a1;\n      goto LABEL_4;\n    }\nLABEL_8:\n    a1[8] = v14;\n    goto LABEL_9;\n  }\n  v14 = sub_2B2B0(v13, v7, v12);\n  result = sub_F240(v14);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  v16 = v9 + v8;\n  v17 = *a1;\n  if ( !*((_DWORD *)a1 + 20) )\n    goto LABEL_12;\nLABEL_4:\n  v18 = a1[4];\n  if ( *((_DWORD *)a1 + 21) )\n    result = sub_2AAD0(v17, v10, v11, v16, v18);\n  else\n    result = sub_2A9E0(v17, v10, v11, v16, v18);\n  a1[8] = result;\nLABEL_9:\n  a1[11] = 1LL;\n  return result;\n}\n",
    "function_name": "ZSTDMT_compressChunk",
    "decompiled_code": "__int64 __fastcall ZSTDMT_compressChunk(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rbp\n  __int64 v9; // r14\n  __int64 v10; // r12\n  unsigned __int64 v11; // r13\n  __int64 v12; // rdx\n  __int64 v13; // rdi\n  __int64 v14; // r15\n  __int64 result; // rax\n  char *v16; // rbp\n  _DWORD *v17; // rdi\n  size_t v18; // r8\n  __int64 v19; // r14\n\n  v7 = a1[19];\n  v8 = a1[3];\n  v9 = a1[5];\n  v10 = a1[6];\n  v11 = a1[7];\n  v12 = a1[20];\n  v13 = *a1;\n  if ( !v7 )\n  {\n    v14 = ZSTD_compressBegin_advanced(v13, v8, v9, v12, a5, a6, *((_OWORD *)a1 + 7), *((_OWORD *)a1 + 8), a1[18]);\n    result = ZSTD_isError(v14);\n    if ( !(_DWORD)result )\n    {\n      v16 = (char *)(v9 + v8);\n      ZSTD_setCCtxParameter(*a1, 0, 1);\n      v17 = (_DWORD *)*a1;\n      if ( *((_DWORD *)a1 + 20) )\n        goto LABEL_4;\nLABEL_12:\n      v19 = ZSTD_compressContinue((__int64)v17, v10, v11, v16, 0LL);\n      result = ZSTD_isError(v19);\n      if ( (_DWORD)result )\n      {\n        a1[8] = v19;\n        goto LABEL_9;\n      }\n      ZSTD_invalidateRepCodes(*a1);\n      v17 = (_DWORD *)*a1;\n      goto LABEL_4;\n    }\nLABEL_8:\n    a1[8] = v14;\n    goto LABEL_9;\n  }\n  v14 = ZSTD_compressBegin_usingCDict(v13, v7, v12, a4, a5, a6);\n  result = ZSTD_isError(v14);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  v16 = (char *)(v9 + v8);\n  v17 = (_DWORD *)*a1;\n  if ( !*((_DWORD *)a1 + 20) )\n    goto LABEL_12;\nLABEL_4:\n  v18 = a1[4];\n  if ( *((_DWORD *)a1 + 21) )\n    result = ZSTD_compressEnd(v17, v10, v11, v16, v18);\n  else\n    result = ZSTD_compressContinue((__int64)v17, v10, v11, v16, v18);\n  a1[8] = result;\nLABEL_9:\n  a1[11] = 1LL;\n  return result;\n}\n",
    "source_code": "void ZSTDMT_compressChunk(void* jobDescription)\n{\n    ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;\n    const void* const src = (const char*)job->srcStart + job->dictSize;\n    buffer_t const dstBuff = job->dstBuff;\n    DEBUGLOG(3, \"job (first:%u) (last:%u) : dictSize %u, srcSize %u\", job->firstChunk, job->lastChunk, (U32)job->dictSize, (U32)job->srcSize);\n    if (job->cdict) {\n        size_t const initError = ZSTD_compressBegin_usingCDict(job->cctx, job->cdict, job->fullFrameSize);\n        if (job->cdict) DEBUGLOG(3, \"using CDict \");\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n    } else {\n        size_t const initError = ZSTD_compressBegin_advanced(job->cctx, job->srcStart, job->dictSize, job->params, job->fullFrameSize);\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n        ZSTD_setCCtxParameter(job->cctx, ZSTD_p_forceWindow, 1);\n    }\n    if (!job->firstChunk) {  /* flush frame header */\n        size_t const hSize = ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, 0);\n        if (ZSTD_isError(hSize)) { job->cSize = hSize; goto _endJob; }\n        ZSTD_invalidateRepCodes(job->cctx);\n    }\n\n    DEBUGLOG(4, \"Compressing : \");\n    DEBUG_PRINTHEX(4, job->srcStart, 12);\n    job->cSize = (job->lastChunk) ?   /* last chunk signal */\n                 ZSTD_compressEnd     (job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize) :\n                 ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize);\n    DEBUGLOG(3, \"compressed %u bytes into %u bytes   (first:%u) (last:%u)\", (unsigned)job->srcSize, (unsigned)job->cSize, job->firstChunk, job->lastChunk);\n\n_endJob:\n    PTHREAD_MUTEX_LOCK(job->jobCompleted_mutex);\n    job->jobCompleted = 1;\n    job->jobScanned = 0;\n    pthread_cond_signal(job->jobCompleted_cond);\n    pthread_mutex_unlock(job->jobCompleted_mutex);\n}",
    "comment": "Compresses data chunks using a context or dictionary, managing the compression state and signaling job completion through condition variables.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases allocated memory for a ZSTDv07_DCtx structure and its associated buffers , ensuring no memory leaks occur .\n",
    "cpbcs_sum": "Processes the SSH2 connection status, updates state, and executes a new result to the next request based on the current state.\n",
    "misum_sum": "Compresses SQL data using the specified dictionary and streams while handling potential errors and updating the decompression process.\n",
    "decom_sum": "Initializes and selects an object resource for the given context, creating or loading it as needed, and marks it as active.",
    "cfg_sum": "Initializes or updates object state by selecting and executing creation or update routines, storing resulting handle, setting status, and performing necessary preparation or cleanup.",
    "work_score": {
        "decom": {
            "summary": "Initializes and selects an object resource for the given context, creating or loading it as needed, and marks it as active.",
            "score": [
                0.1,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function initializes and selects an object resource, creating or loading it as needed, and marks it as active. This is inaccurate because the source code shows the function initializes compression using either a preexisting dictionary or advanced parameters, processes chunks, and signals job completion. The summary does not reflect compression-specific operations and instead describes generic resource management unrelated to the actual semantics, yielding no accurate claims.",
                "The summary's claim about initializing and selecting an object resource, creating or loading it, and marking it as active does not match the code's core purpose. The function is specifically compressing a chunk of data using Zstandard in a multithreaded job context, handling dictionary usage, first/last chunk logic, error handling, and signaling job completion. The summary is generic, non-domain-specific, and inaccurate regarding the actual compression operation, so the core purpose is entirely missing and no accurate secondary points are present.",
                "The summary is entirely inaccurate for the given source code. The function does not initialize or select an object resource, create or load it, nor mark it as active. Instead, it compresses a data chunk using a context and parameters, handles possible dictionary usage, manages chunk boundaries, logs debug info, and signals job completion. This represents a severe FATAL error on the primary purpose and key I/O behavior, making the summary unusable."
            ]
        },
        "cfg": {
            "summary": "Initializes or updates object state by selecting and executing creation or update routines, storing resulting handle, setting status, and performing necessary preparation or cleanup.",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary is overly generic and does not reference specific behaviors of the function such as compression using CDict or advanced methods, handling chunks, flushing headers, or signaling job completion. Most claims are vague and do not target the actual code semantics, resulting in few if any accurate matches.",
                "The summary is entirely generic and does not convey the specific domain purpose of compressing a chunk of data using the ZSTD multi-threaded context with optional dictionary handling, frame header flushing, and signaling job completion. None of its claims are accurate to the source code\u2019s semantics, so the core purpose is not covered and no secondary behavior is addressed.",
                "The summary is dominated by vague, generic language that fails to reflect the function\u2019s actual purpose of compressing a chunk of data using either a prepared dictionary or an advanced setup, managing chunk boundaries, and signaling job completion. It does not mention compression, dictionary use, handling first/last chunk logic, or synchronization. This is mostly NOISE with no specific accurate claims about the code\u2019s semantics, resulting in extremely low net benefit."
            ]
        },
        "comment": {
            "summary": "Compresses data chunks using a context or dictionary, managing the compression state and signaling job completion through condition variables.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary captures the core behavior: compressing data chunks with either a dictionary or context, handling compression state, and signaling completion via condition variables. These statements align with the source, which uses CDict or advanced context initialization, manages chunk progression, and signals job completion via mutexes and condition variables. While the summary omits finer details like first/last chunk handling and error checks, the included claims are accurate and relevant to the code.",
                "The summary correctly identifies that the function compresses data chunks using either a context or a dictionary and notes signaling job completion, which captures the core purpose of multi-threaded chunk compression with completion signaling. However, it omits important secondary details such as handling first/last chunk logic, flushing frame headers, error checking paths, setting compression parameters, and invalidating repeat codes. Coverage of secondary behavior-critical semantics is minimal, making the description incomplete.",
                "The summary correctly states that the function compresses data chunks using either a context or dictionary and signals job completion via condition variables, which matches the core behavior in the source. However, it omits specifics such as handling first/last chunks differently, initializing compression based on whether a dictionary is present, managing errors, and adjusting compression parameters. There are no inaccurate (FATAL) claims, but the coverage is generic and lacks the detailed GOLD insights visible in the code."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 1574128,
    "strip_function_name": "sub_1804F0",
    "strip_decompiled_code": "unsigned __int8 *__fastcall sub_1804F0(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int64 v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  char *v17; // rbp\n  unsigned __int8 *v18; // rbx\n  __int64 v19; // rax\n  _BYTE *v20; // rax\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  unsigned int v27; // eax\n  __int64 v28; // rdx\n  __int64 v29; // rcx\n  __int64 v30; // r8\n  __int64 v31; // r9\n  __m128 v32; // xmm4\n  __m128 v33; // xmm5\n\n  Rf_checkArityCall(a2, a3, a1);\n  v11 = R_HomeDir();\n  if ( !v11 )\n  {\n    v27 = (unsigned int)dcgettext(0LL, \"unable to determine R home location\", 5);\n    Rf_error(\n      v27,\n      (__int64)\"unable to determine R home location\",\n      v28,\n      v29,\n      v30,\n      v31,\n      a4,\n      a5,\n      a6,\n      a7,\n      v32,\n      v33,\n      a10,\n      a11);\n  }\n  v17 = (char *)v11;\n  v18 = (unsigned __int8 *)Rf_allocVector3(0x10u, 1LL, 0LL, a4, a5, a6, a7, v15, v16, a10, a11, v12, v13, v14);\n  v19 = R_PPStackTop;\n  if ( R_PPStackTop >= R_PPStackSize )\n    R_signal_protect_error(\n      *(double *)a4.m128_u64,\n      *(double *)a5.m128_u64,\n      *(double *)a6.m128_u64,\n      *(double *)a7.m128_u64);\n  ++R_PPStackTop;\n  *(_QWORD *)(R_PPStack + 8 * v19) = v18;\n  v20 = (_BYTE *)Rf_mkChar(v17, 1);\n  SET_STRING_ELT(v18, 0LL, v20, a4, a5, a6, a7, v24, v25, a10, a11, v21, v22, v23);\n  --R_PPStackTop;\n  return v18;\n}\n",
    "function_name": "do_Rhome",
    "decompiled_code": "unsigned __int8 *__fastcall do_Rhome(\n        char *a1,\n        __int64 a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  char *v14; // rax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  char *v20; // rbp\n  unsigned __int8 *v21; // rbx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  __int64 v24; // rax\n  _BYTE *v25; // rax\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n  __m128 v29; // xmm4\n  __m128 v30; // xmm5\n  unsigned int v32; // eax\n  __int64 v33; // rdx\n  __int64 v34; // rcx\n  __int64 v35; // r8\n  __int64 v36; // r9\n  __m128 v37; // xmm4\n  __m128 v38; // xmm5\n\n  Rf_checkArityCall(a2, a3, a1, a12, a13, a14, a4, a5, a6, a7, a8, a9, a10, a11);\n  v14 = R_HomeDir();\n  if ( !v14 )\n  {\n    v32 = (unsigned int)dcgettext(0LL, \"unable to determine R home location\", 5);\n    Rf_error(\n      v32,\n      (__int64)\"unable to determine R home location\",\n      v33,\n      v34,\n      v35,\n      v36,\n      a4,\n      a5,\n      a6,\n      a7,\n      v37,\n      v38,\n      a10,\n      a11);\n  }\n  v20 = v14;\n  v21 = (unsigned __int8 *)Rf_allocVector3(0x10u, 1LL, 0LL, a4, a5, a6, a7, v18, v19, a10, a11, v15, v16, v17);\n  v24 = R_PPStackTop;\n  if ( R_PPStackTop >= R_PPStackSize )\n    R_signal_protect_error(\n      *(double *)a4.m128_u64,\n      *(double *)a5.m128_u64,\n      *(double *)a6.m128_u64,\n      *(double *)a7.m128_u64);\n  ++R_PPStackTop;\n  *(_QWORD *)(R_PPStack + 8 * v24) = v21;\n  v25 = (_BYTE *)Rf_mkChar(v20, 1LL, a4, a5, a6, a7, v22, v23, a10, a11);\n  SET_STRING_ELT(v21, 0LL, v25, a4, a5, a6, a7, v29, v30, a10, a11, v26, v27, v28);\n  --R_PPStackTop;\n  return v21;\n}\n",
    "source_code": "\nSEXP attribute_hidden do_Rhome(SEXP call, SEXP op, SEXP args, SEXP rho)\n{\n    char *path;\n    checkArity(op, args);\n    if (!(path = R_HomeDir()))\n\terror(_(\"unable to determine R home location\"));\n    return mkString(path);\n}",
    "comment": "Returns the R home directory path as a string after verifying the function's arity and checking if the path can be determined.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Lists directories from specified paths , optionally including full names and supporting recursion , while managing memory allocation and counting results .\n",
    "cpbcs_sum": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
    "misum_sum": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
    "decom_sum": "Creates a character vector containing the R home directory path, raising an error if the location cannot be determined.",
    "cfg_sum": "Creates an R character vector containing the R home directory path, handling memory protection and raising an error if the home location is unavailable.",
    "work_score": {
        "decom": {
            "summary": "Creates a character vector containing the R home directory path, raising an error if the location cannot be determined.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately states that the function creates a character vector containing the R home directory path and raises an error if the location cannot be determined, which matches the source code behavior via mkString(path) and the error call when R_HomeDir() returns NULL. All claims are specific and verifiable against the code, with no inaccuracies present.",
                "The summary correctly captures the core purpose of the function, which is to return a string containing the R home directory path and to signal an error if this cannot be determined. This matches the source code's domain-specific behavior of calling R_HomeDir(), checking for a null pointer, and using mkString() to return the path. However, it omits secondary details such as the use of checkArity to validate the function's arguments before processing. Due to this omission, coverage of secondary semantics is limited.",
                "The summary contains two fact-based claims: (1) the function returns a character vector containing the R home directory path, and (2) it raises an error if the location cannot be determined. Both claims are accurate and directly reflect the source code's logic\u2014`mkString(path)` is called with R_HomeDir\u2019s result, and an error is triggered if that result is NULL. The claims are specific to the function\u2019s primary purpose, with no noise or inaccuracies present, offering high informational value."
            ]
        },
        "cfg": {
            "summary": "Creates an R character vector containing the R home directory path, handling memory protection and raising an error if the home location is unavailable.",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function creates an R character vector with the R home directory path and raises an error if the location is unavailable, matching the source code's use of mkString(path) and error messages. However, it inaccurately adds that the function handles memory protection, which is not shown in the source code. This introduces an incorrect claim, but most of the content is accurate and grounded in the function's behavior.",
                "The summary correctly states that the function returns the R home directory path as a character vector and mentions raising an error if the location is unavailable, which matches the code. However, it inaccurately claims handling of memory protection, which is not present in the source. The core purpose of retrieving and returning the R home path is covered, but secondary details are minimal and one is incorrect.",
                "The summary correctly states that the function returns an R character vector of the home directory path and raises an error if the location is unavailable, both of which are in the source code. However, it inaccurately claims that the function handles memory protection, which is not present in the code. This is a piece of noise but not a fatal error, and the accurate claims are minimal in detail, providing low net benefit."
            ]
        },
        "comment": {
            "summary": "Returns the R home directory path as a string after verifying the function's arity and checking if the path can be determined.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary contains two key claims: that the function returns the R home directory path as a string, and that it verifies the function's arity and checks if the path can be determined. Both claims directly match the source code behavior \u2014 `checkArity(op, args)` verifies arity, `R_HomeDir()` fetches the path, and `mkString(path)` returns it as a string, with an error triggered if the path cannot be determined. There are no inaccurate or irrelevant statements, making the summary highly precise and aligned with the code.",
                "The summary accurately states that the function returns the R home directory path as a string, verifies the function's arity, and checks if the path can be determined. This matches the core purpose, which is to retrieve the R home directory path and handle the error if it cannot be found. While it covers the primary purpose and mentions the arity check and path validation, it omits explicit details about the error message handling and the mkString conversion, limiting secondary coverage.",
                "The summary contains accurate, specific claims matching the source code: it correctly notes that the function returns the R home directory path as a string, verifies the function\u2019s arity, and checks if the path can be determined before returning it. There is no inaccurate or irrelevant information, and the description captures key domain semantics with good detail and no noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584693824,
    "strip_function_name": "sub_FFFFFFFF81593E40",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81593E40(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r14\n  unsigned __int64 v11; // rbx\n  __int64 v12; // r10\n  unsigned __int64 v13; // r9\n  __int64 v14; // r13\n  __int64 v15; // r15\n  __int64 v16; // r12\n  unsigned int v17; // eax\n  __int64 v18; // rdx\n  unsigned int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // [rsp+10h] [rbp-30h]\n\n  v10 = (_QWORD *)(a2 + 72);\n  v11 = *(_QWORD *)(a1 + 120);\n  v12 = *(_QWORD *)(a1 + 128);\n  v13 = v11 >> 16;\n  v14 = (v11 >> 18) & 1;\n  v15 = (v11 >> 19) & 0xF;\n  v16 = (v11 >> 23) & 0x3F;\n  if ( (v11 & 0x10000) != 0 )\n  {\n    v10 = (_QWORD *)(a2 + 80);\n    v22 = *(_QWORD *)(a1 + 128);\n    v20 = sub_FFFFFFFF81593DC0(v12, v11, 0, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v13 = v11 >> 16;\n    v12 = v22;\n    v21 = v20 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v20 )\n      v21 = 0LL;\n    *(_QWORD *)(a2 + 72) = v21;\n  }\n  if ( (v13 & 2) != 0 )\n  {\n    v17 = sub_FFFFFFFF81593DC0(v12, v11, 1, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v18 = v17 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v17 )\n      v18 = 0LL;\n    *v10 = v18;\n  }\n  return 0LL;\n}\n",
    "function_name": "snd_hda_mixer_amp_volume_get",
    "decompiled_code": "__int64 __fastcall snd_hda_mixer_amp_volume_get(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r14\n  unsigned __int64 v11; // rbx\n  __int64 v12; // r10\n  unsigned __int64 v13; // r9\n  __int64 v14; // r13\n  __int64 v15; // r15\n  __int64 v16; // r12\n  unsigned int v17; // eax\n  __int64 v18; // rdx\n  unsigned int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // [rsp+10h] [rbp-30h]\n\n  v10 = (_QWORD *)(a2 + 72);\n  v11 = *(_QWORD *)(a1 + 120);\n  v12 = *(_QWORD *)(a1 + 128);\n  v13 = v11 >> 16;\n  v14 = (v11 >> 18) & 1;\n  v15 = (v11 >> 19) & 0xF;\n  v16 = (v11 >> 23) & 0x3F;\n  if ( (v11 & 0x10000) != 0 )\n  {\n    v10 = (_QWORD *)(a2 + 80);\n    v22 = *(_QWORD *)(a1 + 128);\n    v20 = snd_hda_codec_amp_read(v12, v11, 0, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v13 = v11 >> 16;\n    v12 = v22;\n    v21 = v20 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v20 )\n      v21 = 0LL;\n    *(_QWORD *)(a2 + 72) = v21;\n  }\n  if ( (v13 & 2) != 0 )\n  {\n    v17 = snd_hda_codec_amp_read(v12, v11, 1, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v18 = v17 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v17 )\n      v18 = 0LL;\n    *v10 = v18;\n  }\n  return 0LL;\n}\n",
    "source_code": "int snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\tif (chs & 1)\n\t\t*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\n\tif (chs & 2)\n\t\t*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\n\treturn 0;\n}",
    "comment": "Retrieves and stores the volume values for specified audio channels from a sound codec's amplifier settings into the provided control element structure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly .\n",
    "cpbcs_sum": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
    "misum_sum": "Retrieves the mute status of audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
    "decom_sum": "Computes adjusted 7\u2011bit values from device configuration fields and stores them into specific offsets of the target structure based on control flags.",
    "cfg_sum": "Computes adjusted values from bitfield flags in input structures using helper calculations, conditionally updates output fields, and returns without producing a direct result.",
    "work_score": {
        "decom": {
            "summary": "Computes adjusted 7\u2011bit values from device configuration fields and stores them into specific offsets of the target structure based on control flags.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function computes adjusted 7\u2011bit values from device configuration fields and stores them into specific offsets based on control flags, but the source code simply reads raw amp values via read_amp_value using parameters from kcontrol and stores them into ucontrol's value fields. There is no evidence of a 7\u2011bit adjustment or offset-based storage beyond the index offsets used in parameter passing. The claims are mostly inaccurate regarding actual code semantics, resulting in a low proportion of accurate statements.",
                "The summary describes computing adjusted 7\u2011bit values from device configuration fields and storing them based on control flags, which does not match the source code's core purpose of retrieving amplifier volume values for specified channels from an HDA codec and writing them into the control element value structure. The core action of reading amplifier values per channel is not covered, and the summary introduces unrelated concepts like 7\u2011bit adjustments and offsets in a target structure.",
                "The summary incorrectly describes the function as computing adjusted 7\u2011bit values from device configuration fields, which is not present in the source code. The code reads amplifier values for left/right channels via `read_amp_value` and stores them into the `ucontrol` structure, with no evidence of 7\u2011bit adjustment or device configuration field processing. This is a FATAL error affecting the primary purpose, making the description misleading and unusable. No accurate, specific claims are present."
            ]
        },
        "cfg": {
            "summary": "Computes adjusted values from bitfield flags in input structures using helper calculations, conditionally updates output fields, and returns without producing a direct result.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. The source code retrieves channel, direction, index, and offset information from the control input, reads amplifier values for each channel using helper functions, and writes them directly to the output structure before returning 0. The summary mentions 'computes adjusted values from bitfield flags' and 'returns without producing a direct result,' which misrepresents the direct assignment of values and ignores the actual audio-related context. Most claims are not grounded in the code's semantics, resulting in low accuracy.",
                "The summary incorrectly describes the function as computing adjusted values from bitfield flags and updating output fields without producing a direct result, which misrepresents the code's core purpose. The code actually reads amplifier volume values from a codec based on channel flags using helper functions and writes them to the output structure. The domain-specific detail of reading amp volume from hardware is entirely missing, so the core purpose is not covered and claims are inaccurate regarding semantics.",
                "The summary claims the function computes adjusted values from bitfield flags, which loosely parallels checking channel flags (chs & 1 / chs & 2), but it inaccurately describes the source code\u2019s primary purpose as adjusting values rather than reading amplifier values. It also incorrectly states there is no direct result when the function clearly writes output values into ucontrol->value.integer.value. These are FATAL inaccuracies concerning the core behavior and side effects. Accurate elements are minimal and generic, offering low insight."
            ]
        },
        "comment": {
            "summary": "Retrieves and stores the volume values for specified audio channels from a sound codec's amplifier settings into the provided control element structure.",
            "score": [
                0.9,
                0.6,
                0.7
            ],
            "reason": [
                "The summary correctly describes that the function retrieves and stores volume values for specific audio channels from the codec's amplifier into the provided control structure, closely matching the source code's behavior. It captures key semantics such as targeting audio channels, interacting with a sound codec, and writing to ucontrol, with no contradictory or irrelevant statements. The claim aligns well with the implemented logic, making its accuracy high.",
                "The summary correctly captures the core purpose of reading volume values from the sound codec\u2019s amplifier for specific channels and storing them in the provided control structure, which matches the main function behavior. However, it omits secondary details such as obtaining parameters like NID, direction, index, and offset from the control, the conditional handling of left/right channels, and the absence of error handling. This limits coverage of behavior-critical semantics beyond the core action.",
                "The summary accurately states the primary purpose of the function: it retrieves amplifier volume values for specific channels from the codec and stores them in the given control element structure. This aligns with the code's behavior using read_amp_value and valp assignments for left/right channels. There are no inaccurate or irrelevant claims, and while the description is correct and clear, it is somewhat generic without detailing parameters or conditions, making the gain modest rather than high."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4881168,
    "strip_function_name": "sub_4A7B10",
    "strip_decompiled_code": "__int64 __fastcall sub_4A7B10(__int64 a1, int a2, __int64 a3, __int64 a4)\n{\n  int v4; // r8d\n  __int64 result; // rax\n\n  switch ( a2 )\n  {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 11:\n    case 33:\n    case 43:\n    case 45:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n    case 58:\n    case 60:\n    case 61:\n    case 63:\n    case 75:\n    case 77:\n      if ( !a3 )\n        goto LABEL_7;\n      goto LABEL_6;\n    case 9:\n    case 10:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n    case 16:\n    case 17:\n    case 18:\n    case 19:\n    case 20:\n    case 21:\n    case 22:\n    case 23:\n    case 34:\n    case 35:\n    case 36:\n    case 37:\n    case 38:\n    case 40:\n    case 51:\n    case 52:\n    case 53:\n    case 59:\n    case 62:\n    case 66:\n    case 67:\n    case 68:\n    case 72:\n    case 73:\n    case 74:\n      if ( a3 )\n        goto LABEL_3;\n      goto LABEL_7;\n    case 25:\n    case 26:\n    case 27:\n    case 28:\n    case 29:\n    case 30:\n    case 31:\n    case 32:\n    case 41:\n    case 46:\n    case 47:\n    case 76:\n    case 78:\n    case 79:\n      goto LABEL_3;\n    case 42:\n    case 48:\nLABEL_6:\n      if ( !a4 )\n        goto LABEL_7;\nLABEL_3:\n      v4 = *(_DWORD *)(a1 + 40);\n      if ( v4 >= *(_DWORD *)(a1 + 44) )\n        goto LABEL_7;\n      result = *(_QWORD *)(a1 + 32) + 24LL * v4;\n      *(_DWORD *)(result + 4) = 0;\n      *(_DWORD *)(a1 + 40) = v4 + 1;\n      *(_DWORD *)result = a2;\n      *(_QWORD *)(result + 8) = a3;\n      *(_QWORD *)(result + 16) = a4;\n      break;\n    default:\nLABEL_7:\n      result = 0LL;\n      break;\n  }\n  return result;\n}\n",
    "function_name": "d_make_comp",
    "decompiled_code": "demangle_component *__fastcall d_make_comp(\n        d_info *di_0,\n        demangle_component_type type,\n        demangle_component *left,\n        demangle_component *right)\n{\n  int next_comp; // r8d\n  demangle_component *result; // rax\n\n  switch ( type )\n  {\n    case demangle_component_type::DEMANGLE_COMPONENT_QUAL_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_LOCAL_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPED_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TEMPLATE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case demangle_component_type::DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_UNARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_BINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_BINARY_ARGS:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case demangle_component_type::DEMANGLE_COMPONENT_LITERAL:\n    case demangle_component_type::DEMANGLE_COMPONENT_LITERAL_NEG:\n    case demangle_component_type::DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TAGGED_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_CLONE:\n      if ( !left )\n        goto LABEL_7;\n      goto LABEL_6;\n    case demangle_component_type::DEMANGLE_COMPONENT_VTABLE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VTT:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case demangle_component_type::DEMANGLE_COMPONENT_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_JAVA_CLASS:\n    case demangle_component_type::DEMANGLE_COMPONENT_GUARD:\n    case demangle_component_type::DEMANGLE_COMPONENT_TLS_INIT:\n    case demangle_component_type::DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFTEMP:\n    case demangle_component_type::DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case demangle_component_type::DEMANGLE_COMPONENT_POINTER:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFERENCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_COMPLEX:\n    case demangle_component_type::DEMANGLE_COMPONENT_IMAGINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CAST:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONVERSION:\n    case demangle_component_type::DEMANGLE_COMPONENT_NULLARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY_ARG2:\n    case demangle_component_type::DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_DECLTYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case demangle_component_type::DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case demangle_component_type::DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case demangle_component_type::DEMANGLE_COMPONENT_PACK_EXPANSION:\n      if ( left )\n        goto LABEL_3;\n      goto LABEL_7;\n    case demangle_component_type::DEMANGLE_COMPONENT_RESTRICT:\n    case demangle_component_type::DEMANGLE_COMPONENT_VOLATILE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONST:\n    case demangle_component_type::DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONST_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_ARGLIST:\n    case demangle_component_type::DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case demangle_component_type::DEMANGLE_COMPONENT_NOEXCEPT:\n    case demangle_component_type::DEMANGLE_COMPONENT_THROW_SPEC:\n      goto LABEL_3;\n    case demangle_component_type::DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_INITIALIZER_LIST:\nLABEL_6:\n      if ( !right )\n        goto LABEL_7;\nLABEL_3:\n      next_comp = di_0->next_comp;\n      if ( next_comp >= di_0->num_comps )\n        goto LABEL_7;\n      result = &di_0->comps[next_comp];\n      result->d_printing = 0;\n      di_0->next_comp = next_comp + 1;\n      result->type = type;\n      result->u.s_number.number = (__int64)left;\n      result->u.s_extended_operator.name = right;\n      break;\n    default:\nLABEL_7:\n      result = 0LL;\n      break;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic struct demangle_component *\nd_make_comp (struct d_info *di, enum demangle_component_type type,\n             struct demangle_component *left,\n             struct demangle_component *right)\n{\n  struct demangle_component *p;\n\n  /* We check for errors here.  A typical error would be a NULL return\n     from a subroutine.  We catch those here, and return NULL\n     upward.  */\n  switch (type)\n    {\n      /* These types require two parameters.  */\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_CLONE:\n      if (left == NULL || right == NULL)\n\treturn NULL;\n      break;\n\n      /* These types only require one parameter.  */\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      if (left == NULL)\n\treturn NULL;\n      break;\n\n      /* This needs a right parameter, but the left parameter can be\n\t empty.  */\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      if (right == NULL)\n\treturn NULL;\n      break;\n\n      /* These are allowed to have no parameters--in some cases they\n\t will be filled in later.  */\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    FNQUAL_COMPONENT_CASE:\n      break;\n\n      /* Other types should not be seen here.  */\n    default:\n      return NULL;\n    }\n\n  p = d_make_empty (di);\n  if (p != NULL)\n    {\n      p->type = type;\n      p->u.s_binary.left = left;\n      p->u.s_binary.right = right;\n    }\n  return p;\n}",
    "comment": "Constructs a demangle component by validating parameters based on type and initializing its properties, returning NULL for errors or invalid types.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Demangles various C++ type components , including pointers , references , arrays , and member functions , into structured debug types .\n",
    "cpbcs_sum": "Inserts a new item into a sorted list based on the specified item type, updating the list and returning the inserted item.\n",
    "misum_sum": "Creates and initializes a new instance with specified parameters and size, linking it to a dynamic array if the type is not found.\n",
    "decom_sum": "Adds a new event with given type and parameters to an internal queue if type, arguments, and capacity meet the defined conditions.",
    "cfg_sum": "Processes specific operation codes, validates parameters, and appends a new entry with context data to a bounded list, returning zero if invalid.",
    "work_score": {
        "decom": {
            "summary": "Adds a new event with given type and parameters to an internal queue if type, arguments, and capacity meet the defined conditions.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about adding a new event to an internal queue, capacity checks, and event arguments do not align with the source code, which constructs a demangle_component based on type-specific parameter requirements and returns NULL on error. None of the claims accurately describe the actual domain behavior of the function.",
                "The summary describes adding an event to a queue with capacity checks, which is unrelated to the source code\u2019s actual purpose of creating and returning a demangle_component struct based on type-specific parameter requirements and error checks. No accurate claims match the core operation of constructing the component and assigning its fields, so the core is entirely missing and the information provided is noise.",
                "The summary inaccurately describes the function as adding an event to an internal queue, which is nowhere reflected in the source code. The actual function constructs and returns a demangle_component object based on type and parameter validation. This constitutes a severe FATAL error regarding the primary purpose, as it misidentifies the core action entirely. No accurate claims are present, so the summary is misleading and unusable."
            ]
        },
        "cfg": {
            "summary": "Processes specific operation codes, validates parameters, and appends a new entry with context data to a bounded list, returning zero if invalid.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains several inaccuracies: it refers to processing operation codes and appending to a bounded list with context data, none of which align with the source code's actual logic. The source function validates parameters based on the component type and constructs a new `demangle_component`, returning NULL in error cases, not zero. No claims in the summary accurately describe these semantics, resulting in a low accuracy proportion.",
                "The summary inaccurately describes the function\u2019s behavior: it mentions processing operation codes, appending to a bounded list, and returning zero if invalid, none of which occur in the source. The actual code constructs a demangle_component based on type, validates parameters against null, and returns NULL in error cases. The core purpose of building a demangle_component from given type and operands is entirely missing, and there are no accurate claims aligned with the source\u2019s semantics.",
                "The summary contains multiple inaccuracies about the function's core behavior. It incorrectly describes handling 'specific operation codes' and 'appending a new entry to a bounded list' with 'returning zero if invalid', which contradicts the source code logic. The actual function checks parameter validity based on type categories, creates a demangle_component struct, and returns NULL on errors. This is a severe FATAL error on its primary purpose and key I/O, making the description misleading and unusable."
            ]
        },
        "comment": {
            "summary": "Constructs a demangle component by validating parameters based on type and initializing its properties, returning NULL for errors or invalid types.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function constructs a demangle component, validates parameters based on type, initializes properties, and returns NULL for errors or invalid types. These points align closely with the source code's structure, which checks parameters according to specific enum cases, assigns fields when valid, and returns NULL otherwise. No contradictory or irrelevant information is present, and all claims are fact-based and supported by the code.",
                "The summary correctly captures the core purpose of creating a demangle component with parameter validation based on type, and returning NULL in case of errors or invalid types. This aligns with the main contract seen in the code. However, it omits specifics about the different category cases (two-parameter, one-parameter, right-only, no-parameter) and the exact struct initialization steps, so the coverage of secondary details is limited.",
                "The summary correctly states the function constructs a demangle component, validates parameters according to the type, and initializes its properties, returning NULL for errors or invalid types. These claims align with the source code's behavior and cover the primary purpose and key I/O without contradictions. The description is accurate but somewhat generic, lacking detailed specifics about parameter requirements per individual type, which limits the informational gain."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 397774,
    "strip_function_name": "sub_611CE",
    "strip_decompiled_code": "__int64 __fastcall sub_611CE(__int64 a1, unsigned int a2, unsigned __int8 **a3)\n{\n  unsigned __int8 *v4; // rax\n  char *v5; // rax\n  unsigned __int8 v6; // dl\n  __int64 v7; // rax\n  __int64 v8; // rax\n  unsigned __int8 v10; // [rsp+2Bh] [rbp-35h]\n  char v11; // [rsp+2Bh] [rbp-35h]\n  int v12; // [rsp+2Ch] [rbp-34h]\n  unsigned __int64 i; // [rsp+30h] [rbp-30h]\n  unsigned __int64 v14; // [rsp+38h] [rbp-28h]\n  unsigned __int8 *v15; // [rsp+40h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+48h] [rbp-18h]\n  unsigned __int8 *v17; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+58h] [rbp-8h]\n\n  if ( a2 <= 1 )\n    return 0LL;\n  v15 = *a3;\n  v16 = (unsigned __int64)a3[1];\n  v17 = a3[2];\n  v18 = (unsigned __int64)a3[3];\n  v14 = 0LL;\n  for ( i = 0LL; i < v16 && v14 < v18; ++i )\n  {\n    v4 = v15++;\n    v10 = *v4;\n    if ( *v4 == 92 )\n    {\n      if ( v16 == i + 1 )\n        break;\n      v5 = (char *)v15++;\n      v11 = *v5;\n      ++i;\n      v12 = mu_wordsplit_c_unquote_char((unsigned __int8)*v5);\n      if ( v12 == -1 )\n        v6 = v11;\n      else\n        v6 = v12;\n      v7 = v14++;\n      v17[v7] = v6;\n    }\n    else\n    {\n      v8 = v14++;\n      v17[v8] = v10;\n    }\n  }\n  a3[1] = (unsigned __int8 *)i;\n  a3[3] = (unsigned __int8 *)v14;\n  return 0LL;\n}\n",
    "function_name": "_c_escape_decoder",
    "decompiled_code": "mu_filter_result __cdecl c_escape_decoder(void *xd, mu_filter_command cmd, mu_filter_io *iobuf)\n{\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  char v6; // dl\n  size_t v7; // rax\n  size_t v8; // rax\n  unsigned __int8 c; // [rsp+2Bh] [rbp-35h]\n  unsigned __int8 ca; // [rsp+2Bh] [rbp-35h]\n  int x; // [rsp+2Ch] [rbp-34h]\n  size_t i; // [rsp+30h] [rbp-30h]\n  size_t j; // [rsp+38h] [rbp-28h]\n  const unsigned __int8 *iptr; // [rsp+40h] [rbp-20h]\n  size_t isize; // [rsp+48h] [rbp-18h]\n  char *optr; // [rsp+50h] [rbp-10h]\n  size_t osize; // [rsp+58h] [rbp-8h]\n\n  if ( (unsigned int)cmd <= mu_filter_command::mu_filter_done )\n    return 0;\n  iptr = (const unsigned __int8 *)iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n  j = 0LL;\n  for ( i = 0LL; i < isize && j < osize; ++i )\n  {\n    v4 = (unsigned __int8 *)iptr++;\n    c = *v4;\n    if ( *v4 == 92 )\n    {\n      if ( isize == i + 1 )\n        break;\n      v5 = (unsigned __int8 *)iptr++;\n      ca = *v5;\n      ++i;\n      x = ((__int64 (__fastcall *)(_QWORD))mu_wordsplit_c_unquote_char)(*v5);\n      if ( x == -1 )\n        v6 = ca;\n      else\n        v6 = x;\n      v7 = j++;\n      optr[v7] = v6;\n    }\n    else\n    {\n      v8 = j++;\n      optr[v8] = c;\n    }\n  }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return 0;\n}\n",
    "source_code": "static enum mu_filter_result\n_c_escape_decoder (void *xd MU_ARG_UNUSED,\n\t\t   enum mu_filter_command cmd,\n\t\t   struct mu_filter_io *iobuf)\n{\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n  \n  switch (cmd)\n    {\n    case mu_filter_init:\n    case mu_filter_done:\n      return mu_filter_ok;\n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n      if (c == '\\\\')\n\t{\n\t  int x;\n\t  if (i + 1 == isize)\n\t    break;\n\t  c = *iptr++;\n\t  i++;\n\t  x = mu_wordsplit_c_unquote_char (c);\n\t  optr[j++] = (x == -1) ? c : x;\n\t}\n      else\n\toptr[j++] = c;\n    }\n\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "comment": "Decodes escape sequences in the input buffer by replacing backslash-prefixed characters with their unquoted equivalents, storing results in the output buffer.",
    "hext5_sum": "returns a pointer to its greatest-valued item. returns |null| if |table| contains no nodes. initializes |trav| for |table|",
    "bint5_sum": "Encodes control characters in the input buffer by escaping them with a backslash and writes the result to the output buffer .\n",
    "cpbcs_sum": "Processes input bytes with specific state transitions, filtering out dots at the beginning of line read or end of data with EOF.\n",
    "misum_sum": "Processes input data through a buffer, handling whitespace, and whitespace, and writes the result to a temporary buffer while managing state and position.\n",
    "decom_sum": "Parses an input byte stream, interprets backslash escape sequences via `mu_wordsplit_c_unquote_char`, and writes the unescaped result to the output buffer.",
    "cfg_sum": "Parses an input byte stream, handling backslash escape sequences, and writes the unescaped data to an output buffer while updating position counters.",
    "work_score": {
        "decom": {
            "summary": "Parses an input byte stream, interprets backslash escape sequences via `mu_wordsplit_c_unquote_char`, and writes the unescaped result to the output buffer.",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly describes that the function processes an input byte stream and interprets backslash escape sequences using `mu_wordsplit_c_unquote_char`, writing the unescaped characters to the output buffer. This aligns with the source code\u2019s loop logic and buffer writes. Although it omits mentioning command handling (`mu_filter_init`, `mu_filter_done`), this omission is minor and the accuracy of described behavior is high.",
                "The summary accurately states the core operation: processing an input byte stream to interpret backslash escapes with `mu_wordsplit_c_unquote_char` and output the unescaped characters, which matches the function\u2019s primary purpose in the source code. However, it omits secondary behaviors such as handling `mu_filter_init` and `mu_filter_done` commands specially by returning immediately, breaking on incomplete escape sequences, and updating `iobuf->isize` and `iobuf->osize` to reflect processed counts. These omissions limit coverage of other behavior-critical semantics.",
                "The summary correctly states the core purpose: it processes the input byte stream, decodes backslash escape sequences using mu_wordsplit_c_unquote_char, and outputs the unescaped data to the buffer. This aligns precisely with the source code\u2019s logic. There is no inaccurate or noisy content, and the claim is specific and grounded in the implementation details, offering high-value insight into the function\u2019s behavior."
            ]
        },
        "cfg": {
            "summary": "Parses an input byte stream, handling backslash escape sequences, and writes the unescaped data to an output buffer while updating position counters.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately describes the core behavior of the function: it processes an input byte stream, decodes backslash escape sequences by converting them to their unescaped form, writes the result to the output buffer, and updates the input/output size counters. All claims are directly supported by the source code and correctly capture its semantics without introducing inaccuracies.",
                "The summary correctly captures the core functionality of decoding backslash escape sequences from the input stream and writing the unescaped data to the output buffer, which matches the function\u2019s primary purpose. It also notes the update of position counters, aligning with the code\u2019s assignment to iobuf sizes. However, it omits secondary details such as handling special filter commands (init/done returning ok), truncation conditions when the input ends after a backslash, and use of mu_wordsplit_c_unquote_char to potentially translate escaped characters differently. Coverage of these branches and edge cases would make it more complete.",
                "The summary accurately states the function processes an input byte stream, interprets backslash escape sequences using a decoding function, writes the resulting unescaped characters to the output buffer, and updates the input/output position counters. There are no contradictory or irrelevant claims, and the description captures the core purpose and side effects clearly, offering specific, domain-relevant insight with minimal noise."
            ]
        },
        "comment": {
            "summary": "Decodes escape sequences in the input buffer by replacing backslash-prefixed characters with their unquoted equivalents, storing results in the output buffer.",
            "score": [
                1.0,
                0.5,
                0.9
            ],
            "reason": [
                "The summary accurately states that the function processes the input buffer by detecting backslash-prefixed characters and replacing them with unquoted equivalents, then writes the results to the output buffer. This matches the source code, which uses mu_wordsplit_c_unquote_char for decoding and handles direct copying when no escape sequence is present. The claim is specific to function semantics and correct, with no unrelated or incorrect statements present.",
                "The summary correctly describes the core functionality of decoding escape sequences from the input buffer by handling backslash-prefixed characters and placing the decoded results into the output buffer, which matches the code\u2019s primary purpose. However, it omits secondary details such as the handling of mu_filter_init/mu_filter_done commands, buffer size limits, the use of mu_wordsplit_c_unquote_char for decoding, and updating iobuf sizes, resulting in partial coverage of behavior-critical semantics.",
                "The summary correctly captures the core purpose: processing the input buffer to decode escape sequences by interpreting backslash-prefixed characters and writing the decoded results to the output buffer. This matches the loop logic using mu_wordsplit_c_unquote_char. No contradictory or irrelevant claims are present, and the claim is both specific and directly tied to the code's primary function, providing clear insight into input/output behavior."
            ]
        }
    }
}
{
    "project_name": "libevent",
    "function_addr": 137856,
    "strip_function_name": "evutil_read_file_",
    "strip_decompiled_code": "__int64 __fastcall evutil_read_file_(char *a1, __int64 *a2, unsigned __int64 *a3)\n{\n  int v4; // eax\n  int v5; // ebp\n  __int64 v6; // r12\n  __off_t st_size; // rdx\n  unsigned __int64 v8; // r15\n  _BYTE *v9; // rbx\n  int v10; // eax\n  unsigned int v12; // [rsp+8h] [rbp-E0h]\n  int v13; // [rsp+Ch] [rbp-DCh]\n  stat stat_buf; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v15; // [rsp+A8h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  if ( !a2 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  if ( !a3 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  *a2 = 0LL;\n  *a3 = 0LL;\n  v4 = evutil_open_closeonexec_(a1, 0);\n  v5 = v4;\n  if ( v4 < 0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v12 = __fxstat(1, v4, &stat_buf);\n    if ( v12 || stat_buf.st_size > 0x7FFFFFFFFFFFFFFEuLL || (v6 = event_mm_malloc_(stat_buf.st_size + 1)) == 0 )\n    {\n      close(v5);\n      return (unsigned int)-2;\n    }\n    else\n    {\n      st_size = stat_buf.st_size;\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v9 = (_BYTE *)(v6 + v8);\n        v10 = read(v5, (void *)(v6 + v8), st_size - v8);\n        if ( v10 <= 0 )\n          break;\n        st_size = stat_buf.st_size;\n        v8 += v10;\n        if ( stat_buf.st_size <= v8 )\n        {\n          v9 = (_BYTE *)(v6 + v8);\n          close(v5);\n          goto LABEL_11;\n        }\n      }\n      v13 = v10;\n      close(v5);\n      if ( !v13 )\n      {\nLABEL_11:\n        *v9 = 0;\n        *a3 = v8;\n        *a2 = v6;\n        return v12;\n      }\n      event_mm_free_(v6);\n      return (unsigned int)-2;\n    }\n  }\n}\n",
    "function_name": "evutil_read_file_",
    "decompiled_code": "__int64 __fastcall evutil_read_file_(char *a1, __int64 *a2, unsigned __int64 *a3)\n{\n  int v4; // eax\n  int v5; // ebp\n  __int64 v6; // r12\n  __off_t st_size; // rdx\n  unsigned __int64 v8; // r15\n  _BYTE *v9; // rbx\n  int v10; // eax\n  unsigned int v12; // [rsp+8h] [rbp-E0h]\n  int v13; // [rsp+Ch] [rbp-DCh]\n  stat stat_buf; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v15; // [rsp+A8h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  if ( !a2 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  if ( !a3 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  *a2 = 0LL;\n  *a3 = 0LL;\n  v4 = evutil_open_closeonexec_(a1, 0);\n  v5 = v4;\n  if ( v4 < 0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v12 = __fxstat(1, v4, &stat_buf);\n    if ( v12 || stat_buf.st_size > 0x7FFFFFFFFFFFFFFEuLL || (v6 = event_mm_malloc_(stat_buf.st_size + 1)) == 0 )\n    {\n      close(v5);\n      return (unsigned int)-2;\n    }\n    else\n    {\n      st_size = stat_buf.st_size;\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v9 = (_BYTE *)(v6 + v8);\n        v10 = read(v5, (void *)(v6 + v8), st_size - v8);\n        if ( v10 <= 0 )\n          break;\n        st_size = stat_buf.st_size;\n        v8 += v10;\n        if ( stat_buf.st_size <= v8 )\n        {\n          v9 = (_BYTE *)(v6 + v8);\n          close(v5);\n          goto LABEL_11;\n        }\n      }\n      v13 = v10;\n      close(v5);\n      if ( !v13 )\n      {\nLABEL_11:\n        *v9 = 0;\n        *a3 = v8;\n        *a2 = v6;\n        return v12;\n      }\n      event_mm_free_(v6);\n      return (unsigned int)-2;\n    }\n  }\n}\n",
    "source_code": "int\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}",
    "comment": "Reads the contents of a specified file into a dynamically allocated buffer, returning the length and handling binary mode if specified.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Reads a file into an evutil_file structure , reading its contents into provided pointers while handling errors for invalid file paths .\n",
    "cpbcs_sum": "Reads a specified file into a buffer, ensuring it is valid and handling line endings appropriately.\n",
    "misum_sum": "Reads data from a file descriptor, using either a fast file or standard iovec up to the specified count.\n",
    "decom_sum": "Reads the entire contents of a specified file into a newly allocated buffer, null\u2011terminates it, and returns its size and pointer.",
    "cfg_sum": "Reads a file into a newly allocated buffer, null\u2011terminates it, returns its size, and handles errors for invalid parameters or read failures.",
    "work_score": {
        "decom": {
            "summary": "Reads the entire contents of a specified file into a newly allocated buffer, null\u2011terminates it, and returns its size and pointer.",
            "score": [
                1.0,
                0.4,
                0.8
            ],
            "reason": [
                "The summary contains a single claim: the function reads the contents of a specified file into a newly allocated buffer, null\u2011terminates it, and returns its size and pointer. This is accurate according to the source code, which allocates memory for the file contents, appends a null terminator, assigns the pointer and length to the output parameters, and returns. The claim matches the domain\u2011semantic behavior without introducing inaccuracies, representing high precision.",
                "The summary accurately covers the core purpose of the function \u2014 reading an entire file into a newly allocated, null\u2011terminated buffer and returning its size and pointer \u2014 which matches the domain\u2011specific operation in the source code. However, it omits significant secondary details such as handling binary mode via O_BINARY, file opening with close\u2011on\u2011exec, validation of file size limits, memory allocation errors, read loop behavior with N_TO_READ macro, error return codes (-1 and -2), and freeing of memory on error. These omissions mean secondary coverage is weak despite the core being correctly stated.",
                "The summary captures the primary purpose accurately: reading an entire file into a newly allocated buffer, null-terminating it, and returning its size and pointer. These are specific, verifiable behaviors in the source code and align with the core I/O semantics. There are no contradictory statements, and noise is minimal. However, the explanation omits details about error handling, binary mode handling, and the constraints on file size, which slightly limits the informational gain compared to what could be provided from the code."
            ]
        },
        "cfg": {
            "summary": "Reads a file into a newly allocated buffer, null\u2011terminates it, returns its size, and handles errors for invalid parameters or read failures.",
            "score": [
                0.8,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function reads a file into a newly allocated buffer, null\u2011terminates it, returns its size, and handles errors on read failures. These details align with the source code. However, the claim about handling errors for invalid parameters is inaccurate\u2014the function only asserts non-null pointers, not gracefully handling invalid arguments. Most claims are accurate, but there is this minor inaccuracy, leading to a slightly reduced score.",
                "The summary correctly states the core purpose of reading a file into a newly allocated buffer, null-terminating it, and returning its size, which aligns with the source code\u2019s primary operation. Error handling for read failures is mentioned and accurate. However, it inaccurately claims handling of invalid parameters; the function asserts non-null pointers rather than performing runtime checks, so it doesn\u2019t handle them as described. It also omits mention of binary mode handling, file size limitations, memory allocation failures, and specific return codes. These gaps reduce coverage of important secondary behaviors.",
                "The summary contains accurate core details: the function reads a file into a newly allocated buffer, null\u2011terminates it, returns its size, and handles errors on read failures, all of which match the code. The error handling description for invalid parameters is slightly overstated since the code asserts on null pointers rather than returning an error, but this is a minor inaccuracy and not FATAL. Overall, noise is minimal, and there is solid domain\u2011specific accuracy with moderate detail."
            ]
        },
        "comment": {
            "summary": "Reads the contents of a specified file into a dynamically allocated buffer, returning the length and handling binary mode if specified.",
            "score": [
                1.0,
                0.5,
                0.7
            ],
            "reason": [
                "The summary accurately states that the function reads a specified file into a dynamically allocated buffer, returns the length, and supports binary mode if specified. These claims align with the source code's behavior, including the use of `is_binary` to set `O_BINARY` and allocation of memory for file content. No incorrect or irrelevant claims are present, showing strong alignment with the source code semantics.",
                "The summary correctly identifies the core function as reading a file into a dynamically allocated buffer, returning the length, and noting binary mode support, which covers the primary purpose. However, it omits secondary details such as error codes for open/stat/read failures, size limit checks, allocation failure handling, use of O_BINARY conditional compilation, and ensuring null-termination. This limits coverage of critical behaviors beyond the core action.",
                "The summary accurately captures the primary purpose of the function: reading a file into a dynamically allocated buffer, returning its length, and accommodating binary mode. These are specific and correct details directly supported by the source code. There is no inaccurate or noisy content; however, the summary is relatively generic and omits other specifics such as error conditions or allocation limits. The worst failure mode is absent, and the gain is moderate due to correct but limited detail."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584245680,
    "strip_function_name": "sub_FFFFFFFF815267B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815267B0(\n        _QWORD **a1,\n        int a2,\n        __int64 a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  _QWORD *v14; // r13\n  unsigned int v15; // ebx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  char *v20; // rcx\n  __int64 v21; // r9\n\n  v14 = a1[2];\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return 0;\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v15 = sub_FFFFFFFF812B8480(\n            a3,\n            a4,\n            (__int64)\"%s %u %s %u \",\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11,\n            a12,\n            **a1,\n            3 - (unsigned int)(*((_DWORD *)v14 + 19) == 0),\n            v14[17] + 12LL,\n            *((_DWORD *)v14 + 5));\n    v19 = *((_DWORD *)v14 + 19);\n    if ( !v19 || a4 <= v15 )\n      return v15;\n    v20 = \"no\";\n    if ( v19 != 1 )\n      v20 = (char *)&unk_FFFFFFFF81999F6F;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3 + (int)v15,\n                           a4 - v15,\n                           (__int64)\"%ssync \",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           v17,\n                           v18,\n                           a11,\n                           a12,\n                           v20)\n         + v15;\n  }\n  else\n  {\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v21 = 70LL;\n    if ( !*((_DWORD *)v14 + 33) )\n      v21 = *((_DWORD *)v14 + 32) == 0 ? 65 : 68;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3,\n                           a4,\n                           (__int64)\"3 %s %s %c\",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           a9,\n                           a10,\n                           a11,\n                           a12,\n                           **a1,\n                           v14[17] + 12LL,\n                           v21);\n  }\n}\n",
    "function_name": "disk_status",
    "decompiled_code": "__int64 __fastcall disk_status(\n        _QWORD **a1,\n        int a2,\n        __int64 a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  _QWORD *v14; // r13\n  unsigned int v15; // ebx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  char *v20; // rcx\n  __int64 v21; // r9\n\n  v14 = a1[2];\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return 0;\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v15 = scnprintf(\n            a3,\n            a4,\n            (__int64)\"%s %u %s %u \",\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11,\n            a12,\n            **a1,\n            3 - (unsigned int)(*((_DWORD *)v14 + 19) == 0),\n            v14[17] + 12LL,\n            *((_DWORD *)v14 + 5));\n    v19 = *((_DWORD *)v14 + 19);\n    if ( !v19 || a4 <= v15 )\n      return v15;\n    v20 = \"no\";\n    if ( v19 != 1 )\n      v20 = (char *)&unk_FFFFFFFF81999F6F;\n    return (unsigned int)scnprintf(a3 + (int)v15, a4 - v15, (__int64)\"%ssync \", a5, a6, a7, a8, v17, v18, a11, a12, v20)\n         + v15;\n  }\n  else\n  {\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v21 = 70LL;\n    if ( !*((_DWORD *)v14 + 33) )\n      v21 = *((_DWORD *)v14 + 32) == 0 ? 65 : 68;\n    return (unsigned int)scnprintf(\n                           a3,\n                           a4,\n                           (__int64)\"3 %s %s %c\",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           a9,\n                           a10,\n                           a11,\n                           a12,\n                           **a1,\n                           v14[17] + 12LL,\n                           v21);\n  }\n}\n",
    "source_code": "\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch(status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"3 %s %s %c\", log->type->name, lc->log_dev->name,\n\t\t       lc->log_dev_flush_failed ? 'F' :\n\t\t       lc->log_dev_failed ? 'D' :\n\t\t       'A');\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %s %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\n\t\t       lc->region_size);\n\t\tDMEMIT_SYNC;\n\t}\n\n\treturn sz;\n}",
    "comment": "Generates and emits status information for a dirty log based on the provided status type, including device name and synchronization details.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Outputs the status of a dirty log , providing information or table details based on the specified status type .\n",
    "cpbcs_sum": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
    "misum_sum": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
    "decom_sum": "Formats and writes synchronization or status command strings into a buffer based on mode, device state, and provided parameters.",
    "cfg_sum": "Formats and writes status information with optional sync indicators based on input parameters and device state flags.",
    "work_score": {
        "decom": {
            "summary": "Formats and writes synchronization or status command strings into a buffer based on mode, device state, and provided parameters.",
            "score": [
                0.8,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function formats and writes status strings into a buffer depending on certain conditions such as mode and device state, which aligns with the code\u2019s use of `switch(status)` and `DMEMIT` calls. However, it inaccurately mentions 'synchronization' and 'provided parameters'. The code emits specific info or table strings based on `status`, log type, device name, and failure flags, with no indication of generic sync commands except for `DMEMIT_SYNC` tied to table output. The reference to 'provided parameters' is too vague and not anchored in the actual argument usage. Overall, most of the description is accurate, but there are minor inaccuracies and vague elements.",
                "The summary generically states that the function formats and writes command strings based on mode, device state, and parameters, which aligns partially with the code\u2019s behavior. However, it does not clearly convey the core purpose of generating disk status output for different status types (INFO, TABLE) with specific fields like type name, device name, failure status, sync mode, and region size. While the claim is broadly accurate, it misses many critical domain-specific details and status-type distinctions present in the source code.",
                "The summary correctly notes that the function formats and writes strings into a buffer based on mode (status type) and device state, aligning with the code's use of DMEMIT for STATUSTYPE_INFO and STATUSTYPE_TABLE cases. However, it generically refers to 'synchronization' and 'provided parameters' without specific mention of the actual fields emitted (e.g., type name, device name, failure flags, region size) or the conditional encoding of sync mode, making the gain low. There is no contradictory or irrelevant information, so noise is minimal, but the description is broad and lacks high-detail GOLD claims."
            ]
        },
        "cfg": {
            "summary": "Formats and writes status information with optional sync indicators based on input parameters and device state flags.",
            "score": [
                0.8,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly captures that the function formats and writes status information and includes conditionally displayed indicators based on device state flags. However, it omits specific details found in the source code, such as the distinct handling for STATUSTYPE_INFO vs STATUSTYPE_TABLE, the exact flags represented ('F', 'D', 'A'), and inclusion of region size and sync values. Despite these omissions, the key domain semantics in terms of conditional formatting based on state are accurate, making most of the claim align with the source code.",
                "The summary captures the general idea of formatting and writing status information influenced by parameters and device state flags, which aligns with the function\u2019s core behavior of emitting formatted status strings based on the status type and device conditions. However, it fails to specify the core purpose in domain-specific terms\u2014such as handling STATUSTYPE_INFO and STATUSTYPE_TABLE cases, outputting specific device name, type name, flush/failed flags, and sync/region size values\u2014so coverage of secondary behavior-critical semantics is minimal.",
                "The summary correctly states that the function formats and writes status information based on input parameters and device state flags, which matches the code's use of DMEMIT to output data determined by 'status', 'log_dev_flush_failed', and 'log_dev_failed'. However, it omits specific details such as differing output formats for STATUSTYPE_INFO vs STATUSTYPE_TABLE, the inclusion of region size, and the exact conditions for sync indicators. There are no contradictory claims, but the coverage is generic and lacks precise GOLD-level specifics, resulting in low informational gain."
            ]
        },
        "comment": {
            "summary": "Generates and emits status information for a dirty log based on the provided status type, including device name and synchronization details.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function generates and emits status information for a dirty log based on the provided status type, which matches the switch cases for STATUSTYPE_INFO and STATUSTYPE_TABLE. It also correctly mentions inclusion of device name and synchronization details, which aligns with the use of lc->log_dev->name and lc->sync in DMEMIT calls. No contradictory or irrelevant claims are present, making the claims highly accurate and specific to the code\u2019s semantics.",
                "The summary correctly captures the core purpose of generating and emitting status information for a dirty log based on the status type, which matches the function's behavior. However, it omits critical secondary details such as the specific STATUSTYPE_INFO and STATUSTYPE_TABLE branches, the emitted constants (like '3' and device status letters 'F', 'D', 'A'), region size, and default sync logic. These omissions limit coverage of nuanced behavior and output formatting present in the source code.",
                "The summary correctly states that the function generates and emits status information for a dirty log based on the status type, and it includes device name and synchronization details. These are accurate, fact-based claims directly derived from the code. However, the description is generic and omits specific behaviors such as the distinct output formats for STATUSTYPE_INFO and STATUSTYPE_TABLE, inclusion of log type name, region size, and status flags ('F', 'D', 'A'). There is no inaccurate or contradictory content, but the gain is low due to lack of detail."
            ]
        }
    }
}
{
    "project_name": "readline",
    "function_addr": 223328,
    "strip_function_name": "rl_insert_text",
    "strip_decompiled_code": "__int64 __fastcall rl_insert_text(char *src)\n{\n  unsigned int v1; // r13d\n  unsigned int v3; // eax\n  unsigned int v4; // r12d\n  int v5; // ecx\n  __int64 v6; // rdi\n  __int64 v7; // rdi\n  __int64 v8; // rdx\n  char v9; // si\n  _BYTE *v10; // rax\n  int v11; // eax\n\n  v1 = 0;\n  if ( src )\n  {\n    if ( *src )\n    {\n      v3 = strlen(src);\n      v4 = v3;\n      v1 = v3;\n      if ( v3 )\n      {\n        v5 = rl_end[0];\n        v6 = rl_end[0] + v3;\n        if ( (int)v6 >= rl_line_buffer_len )\n        {\n          rl_extend_line_buffer(v6);\n          v5 = rl_end[0];\n        }\n        v7 = rl_point[0];\n        if ( rl_point[0] <= v5 )\n        {\n          v8 = v5;\n          do\n          {\n            --v5;\n            v9 = rl_line_buffer[v8];\n            v10 = &rl_line_buffer[v8--];\n            v10[v1] = v9;\n            v7 = rl_point[0];\n          }\n          while ( v5 >= rl_point[0] );\n        }\n        strncpy(&rl_line_buffer[v7], src, (int)v4);\n        if ( !rl_doing_an_undo )\n        {\n          if ( v4 == 1 )\n          {\n            if ( rl_undo_list )\n            {\n              if ( rl_undo_list[6] == 1 )\n              {\n                v11 = rl_undo_list[3];\n                if ( v11 == rl_point[0] && v11 - rl_undo_list[2] <= 19 )\n                {\n                  rl_undo_list[3] = v11 + 1;\nLABEL_18:\n                  rl_point[0] = v4 + v11;\n                  rl_end[0] += v4;\n                  rl_line_buffer[rl_end[0]] = 0;\n                  return v1;\n                }\n              }\n            }\n          }\n          rl_add_undo(1LL, rl_point[0], rl_point[0] + v4, 0LL);\n        }\n        v11 = rl_point[0];\n        goto LABEL_18;\n      }\n    }\n  }\n  return v1;\n}\n",
    "function_name": "rl_insert_text",
    "decompiled_code": "int __fastcall rl_insert_text(const char *string)\n{\n  int v1; // r13d\n  int v3; // eax\n  int v4; // r12d\n  int v5; // ecx\n  __int64 v6; // rdi\n  __int64 v7; // rdx\n  char v8; // si\n  char *v9; // rax\n  int end; // eax\n\n  v1 = 0;\n  if ( string )\n  {\n    if ( *string )\n    {\n      v3 = strlen(string);\n      v4 = v3;\n      v1 = v3;\n      if ( v3 )\n      {\n        v5 = rl_end;\n        if ( rl_end + v3 >= rl_line_buffer_len )\n        {\n          ((void (*)(void))rl_extend_line_buffer)();\n          v5 = rl_end;\n        }\n        v6 = rl_point;\n        if ( rl_point <= v5 )\n        {\n          v7 = v5;\n          do\n          {\n            --v5;\n            v8 = rl_line_buffer[v7];\n            v9 = &rl_line_buffer[v7--];\n            v9[v1] = v8;\n            v6 = rl_point;\n          }\n          while ( v5 >= rl_point );\n        }\n        strncpy(&rl_line_buffer[v6], string, v4);\n        if ( !rl_doing_an_undo )\n        {\n          if ( v4 == 1 )\n          {\n            if ( rl_undo_list )\n            {\n              if ( rl_undo_list->what == undo_code::UNDO_INSERT )\n              {\n                end = rl_undo_list->end;\n                if ( end == rl_point && end - rl_undo_list->start <= 19 )\n                {\n                  rl_undo_list->end = end + 1;\nLABEL_18:\n                  rl_point = v4 + end;\n                  rl_end += v4;\n                  rl_line_buffer[rl_end] = 0;\n                  return v1;\n                }\n              }\n            }\n          }\n          ((void (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))rl_add_undo)(\n            1LL,\n            (unsigned int)rl_point,\n            (unsigned int)(rl_point + v4),\n            0LL);\n        }\n        end = rl_point;\n        goto LABEL_18;\n      }\n    }\n  }\n  return v1;\n}\n",
    "source_code": "int\nrl_insert_text (const char *string)\n{\n  register int i, l;\n\n  l = (string && *string) ? strlen (string) : 0;\n  if (l == 0)\n    return 0;\n\n  if (rl_end + l >= rl_line_buffer_len)\n    rl_extend_line_buffer (rl_end + l);\n\n  for (i = rl_end; i >= rl_point; i--)\n    rl_line_buffer[i + l] = rl_line_buffer[i];\n\n  strncpy (rl_line_buffer + rl_point, string, l);\n\n  /* Remember how to undo this if we aren't undoing something. */\n  if (_rl_doing_an_undo == 0)\n    {\n      /* If possible and desirable, concatenate the undos. */\n      if ((l == 1) &&\n\t  rl_undo_list &&\n\t  (rl_undo_list->what == UNDO_INSERT) &&\n\t  (rl_undo_list->end == rl_point) &&\n\t  (rl_undo_list->end - rl_undo_list->start < 20))\n\trl_undo_list->end++;\n      else\n\trl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);\n    }\n  rl_point += l;\n  rl_end += l;\n  rl_line_buffer[rl_end] = '\\0';\n  return l;\n}",
    "comment": "Inserts a given string into a line buffer at a specified point, adjusting the buffer and managing undo operations accordingly.",
    "hext5_sum": "get the elf linker hash table from a link_info structure.",
    "bint5_sum": "Inserts a string of text into the line buffer at a specified cursor position , expanding the line buffer if necessary .\n",
    "cpbcs_sum": "Inserts a new line buffer into a buffer, updating the buffer size and ensuring it does not exceed the current buffer size.\n",
    "misum_sum": "Converts a list of input, appending characters to a specified line buffer, while handling line breaks and memory management.\n",
    "decom_sum": "Inserts the given text into the readline buffer at the cursor position, shifting existing content and recording undo information if enabled.",
    "cfg_sum": "Inserts the given text into the readline buffer at the cursor position, shifting existing content, adjusting size, and updating undo history.",
    "work_score": {
        "decom": {
            "summary": "Inserts the given text into the readline buffer at the cursor position, shifting existing content and recording undo information if enabled.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function inserts the given text into the readline buffer at the cursor position, which aligns with the code's use of rl_point and shifting existing content with a loop. It also accurately mentions shifting existing content and recording undo information if enabled, matching the code's undo handling logic with rl_add_undo and concatenation of undos. All described behaviors are grounded in the source code and there are no contradictory or irrelevant claims.",
                "The summary accurately captures the core purpose of inserting text into the readline buffer at the cursor and shifting existing content, which matches the primary domain operation. It also notes recording undo information, reflecting the undo list logic in the code. However, it omits details about buffer extension when needed, specific undo concatenation conditions, handling of empty strings, and updates to cursor/end positions, so secondary coverage is limited.",
                "The summary correctly identifies the core function: inserting text at the cursor position, shifting existing buffer contents, and recording undo information if applicable. All claims align with the source code\u2019s behavior, with no contradictions or irrelevant noise. While the claims are accurate, they are somewhat generic and omit some specifics such as conditions for undo concatenation and buffer extension logic, resulting in modest informational gain."
            ]
        },
        "cfg": {
            "summary": "Inserts the given text into the readline buffer at the cursor position, shifting existing content, adjusting size, and updating undo history.",
            "score": [
                1.0,
                0.7,
                0.8
            ],
            "reason": [
                "The summary correctly captures the core semantics of the function: inserting the given text at the cursor position, shifting existing buffer contents, extending the buffer size if necessary, and updating the undo history. All these described behaviors match the source code logic, with no inaccuracies or irrelevant statements, resulting in a high proportion of accurate claims.",
                "The summary accurately describes the core purpose of the function \u2014 inserting text into the readline buffer at the cursor, shifting existing content, adjusting buffer size, and updating undo history \u2014 which aligns with the code's main logic and undo handling. It covers key secondary behaviors like buffer extension and content shifting, but omits specifics such as the conditions for concatenating undo insertions, handling empty input, and null-terminating the buffer. These missing details limit completeness.",
                "The summary correctly states the core behavior: inserting text into the readline buffer at the cursor position, shifting existing content, adjusting buffer size, and updating undo history. All these claims are accurate to the source code's semantics, with no contradictions or irrelevant noise. While the claims are concise and somewhat generic, they cover the primary purpose and key side effects with low noise, yielding a clear and useful description."
            ]
        },
        "comment": {
            "summary": "Inserts a given string into a line buffer at a specified point, adjusting the buffer and managing undo operations accordingly.",
            "score": [
                1.0,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function inserts a given string into a line buffer at a specified point, adjusts the buffer, and manages undo operations, all of which match the source code behavior. There are no claims that contradict the code, and each statement is directly supported by the implementation, making the precision very high.",
                "The summary correctly identifies the core purpose of inserting a given string into the line buffer at the current cursor position and mentions adjustment of the buffer and undo management, aligning with the code's primary operation. However, it omits important secondary details such as extending the buffer when needed, shifting existing text to make space, specific conditions for concatenating undo records, updating cursor and buffer end positions, and returning the inserted length. Coverage of secondary behavior-critical semantics is therefore limited.",
                "The summary correctly captures the core behavior: inserting a specified string into the line buffer at the current point, adjusting the buffer size, and handling undo operations. These are accurate reflections of the source code's semantics with no contradictory or irrelevant statements. However, the claims are general and lack specific details such as how the buffer is adjusted or the conditions for concatenating undo operations, resulting in low informational gain."
            ]
        }
    }
}
{
    "project_name": "glpk",
    "function_addr": 536656,
    "strip_function_name": "sub_83050",
    "strip_decompiled_code": "__int64 __fastcall sub_83050(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // r13d\n  int v3; // edx\n  __int64 v5; // rbx\n  int v6; // r12d\n  __int64 v7; // r8\n  char *v8; // rcx\n  char v9; // al\n  _BYTE *v10; // rsi\n\n  v2 = *(_DWORD *)(a1 + 32);\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(int *)a1 <= 0 )\n  {\n    v6 = 0;\n  }\n  else\n  {\n    v5 = 1LL;\n    v6 = 0;\n    do\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + v5) & 0x10) != 0 )\n      {\n        if ( ++v6 > v3 )\n          glp_assert_(\"k <= ks->n\", \"misc/ks.c\", 255LL);\n        v7 = v6;\n        v8 = (char *)(a2 + v6);\n        v9 = *v8;\n        if ( (unsigned __int8)*v8 > 1u )\n        {\n          glp_assert_(\"x[k] == 0 || x[k] == 1\", \"misc/ks.c\", 256LL);\n          v8 = (char *)(a2 + v6);\n          v7 = v6;\n          v9 = *v8;\n        }\n        v10 = (_BYTE *)(v5 + *(_QWORD *)(a1 + 40));\n        if ( (*v10 & 1) != 0 )\n          v9 = 1 - v9;\n        *v10 = v9;\n        v3 = *(_DWORD *)(a1 + 4);\n        if ( *v8 )\n          v2 += *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v7);\n      }\n      ++v5;\n    }\n    while ( *(_DWORD *)a1 >= (int)v5 );\n  }\n  if ( v6 != v3 )\n    glp_assert_(\"k == ks->n\", \"misc/ks.c\", 265LL);\n  return v2;\n}\n",
    "function_name": "restore",
    "decompiled_code": "__int64 __fastcall restore(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // r13d\n  int v3; // edx\n  __int64 v5; // rbx\n  int v6; // r12d\n  __int64 v7; // r8\n  char *v8; // rcx\n  char v9; // al\n  _BYTE *v10; // rsi\n\n  v2 = *(_DWORD *)(a1 + 32);\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(int *)a1 <= 0 )\n  {\n    v6 = 0;\n  }\n  else\n  {\n    v5 = 1LL;\n    v6 = 0;\n    do\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + v5) & 0x10) != 0 )\n      {\n        if ( ++v6 > v3 )\n          ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\"k <= ks->n\", \"misc/ks.c\", 255LL);\n        v7 = v6;\n        v8 = (char *)(a2 + v6);\n        v9 = *v8;\n        if ( (unsigned __int8)*v8 > 1u )\n        {\n          ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\n            \"x[k] == 0 || x[k] == 1\",\n            \"misc/ks.c\",\n            256LL);\n          v8 = (char *)(a2 + v6);\n          v7 = v6;\n          v9 = *v8;\n        }\n        v10 = (_BYTE *)(v5 + *(_QWORD *)(a1 + 40));\n        if ( (*v10 & 1) != 0 )\n          v9 = 1 - v9;\n        *v10 = v9;\n        v3 = *(_DWORD *)(a1 + 4);\n        if ( *v8 )\n          v2 += *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v7);\n      }\n      ++v5;\n    }\n    while ( *(_DWORD *)a1 >= (int)v5 );\n  }\n  if ( v6 != v3 )\n    ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\"k == ks->n\", \"misc/ks.c\", 265LL);\n  return v2;\n}\n",
    "source_code": "\nstatic int restore(struct ks *ks, char x[])\n{     int j, k, z;\n      z = ks->c0;\n      for (j = 1, k = 0; j <= ks->orig_n; j++)\n      {  if (ks->x[j] & 0x10)\n         {  k++;\n            xassert(k <= ks->n);\n            xassert(x[k] == 0 || x[k] == 1);\n            if (ks->x[j] & 1)\n               ks->x[j] = 1 - x[k];\n            else\n               ks->x[j] = x[k];\n            if (x[k])\n               z += ks->c[k];\n         }\n      }\n      xassert(k == ks->n);\n      return z;\n}",
    "comment": "Restores values in the `ks->x` array based on conditions and updates a sum `z` based on corresponding values from the `x` array.",
    "hext5_sum": "returns (the former by obstack_free). this can handle different kinds of stabs (s,n,d) and different kinds of stab sections. if stab_secname_obstack_end is non-null, then stab_secname and stabstr_secname will be freed if possible",
    "bint5_sum": "Finds the index of the first non-zero element in a key-value pair within the specified range of an array .\n",
    "cpbcs_sum": "Extracts the value from a variable table and updates the column list with the column of each column in the given column structure.\n",
    "misum_sum": "Extracts a linear programming problem from a linear programming problem, converting each column to a representation if necessary, and stores the index after the index.\n",
    "decom_sum": "Validates and updates binary selection flags in a knapsack structure, ensuring constraints, conditionally inverting values, and computing the total weight sum.",
    "cfg_sum": "Validates and updates item states with strict assertions, toggles values based on flags, accumulates totals, and ensures processed count matches expected count.",
    "work_score": {
        "decom": {
            "summary": "Validates and updates binary selection flags in a knapsack structure, ensuring constraints, conditionally inverting values, and computing the total weight sum.",
            "score": [
                0.9,
                0.8,
                0.8
            ],
            "reason": [
                "The summary accurately reflects the function\u2019s operations: it validates binary flags using assertions, updates selection flags within a knapsack-like structure, conditionally inverts values based on a bit check, and computes a cumulative sum of weights. All core behaviors described in the summary align with the source code semantics, with no contradictions and high specificity.",
                "The summary correctly identifies that the function validates and updates binary selection flags in a knapsack structure, enforces constraints with assertions, conditionally inverts values based on bit checks, and accumulates a total weight sum starting from an initial value. These points align with the code\u2019s core purpose and capture key secondary semantics such as constraint checking, inversion logic, and cumulative sum calculation. However, it omits certain specifics like iterating through elements, the exact bitmask conditions used (0x10 and 1), and the precise order of operations, which slightly limits completeness.",
                "The summary correctly identifies that the function validates flags (via assertions), updates selection flags, may invert values conditionally, and computes a sum, aligning well with the source code's operations. It specifies the domain context (knapsack structure) and covers the primary purpose without introducing inaccuracies or irrelevant noise. The gain is moderately high because the claims are specific to constraints, conditional inversion, and weight computation, though some details like exact bitmask usage are omitted."
            ]
        },
        "cfg": {
            "summary": "Validates and updates item states with strict assertions, toggles values based on flags, accumulates totals, and ensures processed count matches expected count.",
            "score": [
                0.9,
                0.8,
                0.9
            ],
            "reason": [
                "The summary captures the core semantics of the function: it enforces strict assertions, conditionally toggles ks->x[j] values based on bit flags, accumulates a total in z, and verifies the processed count matches ks->n. All these claims align directly with the source code\u2019s logic, with no evident inaccuracies or unrelated details, indicating high precision in describing the code behavior.",
                "The summary accurately describes key elements of the function: it notes validation via assertions, state updates, conditional toggling based on bit flags, accumulation into a total variable, and final count verification, all of which match the source code's operations. The core purpose\u2014restoring ks->x entries from array x based on flags while maintaining totals\u2014is explicitly covered through 'updates item states with strict assertions' and 'toggles values based on flags'. Secondary behaviors such as accumulation logic and the final assertion are included, though low-level details like specific flag values (0x10, bit 0) and the nature of zs accumulation are omitted.",
                "The summary contains accurate and specific claims: it notes that the function enforces strict assertions (matching the xassert checks), updates item states (corresponding to modifications of ks->x[j]), toggles values based on flags (ks->x[j] & 1 logic), accumulates totals (z += ks->c[k]), and ensures processed count matches expected count (final xassert(k == ks->n)). All these directly align with the source code's behavior. There is no contradictory or irrelevant noise, and the summary captures the core purpose and I/O behavior with good specificity, offering high gain."
            ]
        },
        "comment": {
            "summary": "Restores values in the `ks->x` array based on conditions and updates a sum `z` based on corresponding values from the `x` array.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly conveys the core behavior of the function\u2014modifying elements in `ks->x` based on conditions and incrementing `z` using values from `x`\u2014which aligns with the loop logic and the summation update in the source code. While it omits specific details like the bitwise checks, assertions, and the exact conditional transformations, the claim is accurate at a high level and directly targets code semantics, yielding a high proportion of accurate statements.",
                "The summary states that the function restores values in ks->x based on conditions and updates a sum z from x, which matches the core operation of iterating over ks->x, conditionally setting its entries from x, and accumulating z. This correctly covers the core primary purpose with appropriate specificity. However, it omits key secondary details such as the exact conditional checks on ks->x[j] bits, the assertions enforcing bounds and value constraints, and final assertion on k, as well as the precise nature of how ks->x[j] is inverted when a certain bit is set. These omissions reduce coverage of behavior-critical semantics.",
                "The summary correctly captures the core purpose: restoring values in ks->x based on conditions and updating a sum z from x. This matches the loop logic, conditional updates, and accumulation present in the source. However, it omits details like checking specific bit flags in ks->x elements, assertions on bounds and value constraints, and how values are inverted when certain bits are set. The information gain is low because these specifics are missing, but there is no inaccurate or contradictory statement, and noise is minimal."
            ]
        }
    }
}
{
    "project_name": "protobuf",
    "function_addr": 22480,
    "strip_function_name": "sub_57D0",
    "strip_decompiled_code": "__int64 __fastcall sub_57D0(__int64 a1)\n{\n  __int64 v1; // r13\n  unsigned int v2; // ebp\n  __int64 v3; // r12\n  unsigned int v4; // r14d\n  __int64 v5; // rbx\n  int v6; // eax\n  __int64 v7; // r15\n  int v9; // edx\n  __int64 v10; // [rsp+0h] [rbp-58h]\n\n  if ( !a1 )\n    return 0LL;\n  v1 = *(_QWORD *)(a1 + 64);\n  if ( !v1 )\n    return 0LL;\n  v2 = *(_DWORD *)(a1 + 48);\n  v3 = 0LL;\nLABEL_4:\n  if ( v2 <= 1 )\n  {\n    v7 = 0LL;\n    if ( v2 )\n    {\nLABEL_11:\n      v7 = v10 + 72LL * *(unsigned int *)(v1 + 4 * v3);\n      if ( 9 * *(_DWORD *)(v1 + 4 * v3) )\n        return 0LL;\n    }\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = v2 >> 1;\n      v5 = (v2 >> 1) + (unsigned int)v3;\n      v6 = 9 * *(_DWORD *)(v1 + 4 * v5);\n      v7 = *(_QWORD *)(a1 + 56) + 72LL * *(unsigned int *)(v1 + 4 * v5);\n      if ( !v6 )\n        break;\n      if ( v6 < 0 )\n      {\n        v9 = v3 + v2 - 1;\n        v3 = (unsigned int)(v5 + 1);\n        v2 = v9 - v5;\n        goto LABEL_4;\n      }\n      v2 >>= 1;\n      if ( v4 == 1 )\n        goto LABEL_11;\n    }\n  }\n  return v7;\n}\n",
    "function_name": "protobuf_c_message_descriptor_get_field_by_name",
    "decompiled_code": "const char **__fastcall protobuf_c_message_descriptor_get_field_by_name(__int64 a1, const char *a2)\n{\n  __int64 v2; // r13\n  unsigned int v3; // ebp\n  __int64 v4; // r12\n  unsigned int v5; // r14d\n  __int64 v6; // rbx\n  const char **v7; // r15\n  int v8; // eax\n  int v10; // edx\n  __int64 v11; // [rsp+8h] [rbp-50h]\n\n  if ( !a1 )\n    return 0LL;\n  v2 = *(_QWORD *)(a1 + 64);\n  if ( !v2 )\n    return 0LL;\n  v3 = *(_DWORD *)(a1 + 48);\n  v4 = 0LL;\nLABEL_4:\n  if ( v3 <= 1 )\n  {\n    v7 = 0LL;\n    if ( v3 )\n    {\n      v11 = *(_QWORD *)(a1 + 56);\nLABEL_12:\n      v7 = (const char **)(v11 + 72LL * *(unsigned int *)(v2 + 4 * v4));\n      if ( strcmp(*v7, a2) )\n        return 0LL;\n    }\n  }\n  else\n  {\n    v11 = *(_QWORD *)(a1 + 56);\n    while ( 1 )\n    {\n      v5 = v3 >> 1;\n      v6 = (v3 >> 1) + (unsigned int)v4;\n      v7 = (const char **)(v11 + 72LL * *(unsigned int *)(v2 + 4 * v6));\n      v8 = strcmp(*v7, a2);\n      if ( !v8 )\n        break;\n      if ( v8 < 0 )\n      {\n        v10 = v4 + v3 - 1;\n        v4 = (unsigned int)(v6 + 1);\n        v3 = v10 - v6;\n        goto LABEL_4;\n      }\n      v3 >>= 1;\n      if ( v5 == 1 )\n        goto LABEL_12;\n    }\n  }\n  return v7;\n}\n",
    "source_code": "\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\tconst ProtobufCFieldDescriptor *field;\n\n\tif (desc == NULL || desc->fields_sorted_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_fields;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}",
    "comment": "Retrieves the field descriptor with a matching name from a sorted list of fields in a ProtobufC message descriptor.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search .\n",
    "cpbcs_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
    "misum_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
    "decom_sum": "Searches a sorted index array for an entry with a zero key and returns its associated 72-byte structure address, or zero if not found.",
    "cfg_sum": "Searches a sorted index array for an entry with a zero-valued field and returns its associated data pointer offset.",
    "work_score": {
        "decom": {
            "summary": "Searches a sorted index array for an entry with a zero key and returns its associated 72-byte structure address, or zero if not found.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as searching for a zero key and returning a 72-byte structure address, which does not align with the source code. The actual function performs a binary search on a sorted array of field names within a message descriptor and returns the matching field descriptor, or NULL if not found. None of the claims in the summary match the semantics of the source code, resulting in all claims being inaccurate.",
                "The summary incorrectly states it searches for an entry with a zero key and returns a 72-byte structure, which contradicts the code's purpose of performing a binary search for a field with a matching name in a sorted index array. The core purpose\u2014finding a ProtobufCFieldDescriptor by name\u2014is entirely missing and replaced with inaccurate details, and no accurate secondary behaviors are described.",
                "The summary's core claim about searching for an entry with a zero key and returning a 72-byte structure address does not match the source code. The function actually searches a sorted index of field names using binary search and returns a matching field descriptor pointer. The mentioned 'zero key' and '72-byte structure' are inaccurate and contradict the primary purpose, making this a severe FATAL error on the core semantic behavior. No accurate claims remain to provide value."
            ]
        },
        "cfg": {
            "summary": "Searches a sorted index array for an entry with a zero-valued field and returns its associated data pointer offset.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary misrepresents the code\u2019s actual behavior. The function searches a sorted index array of field names using binary search to find a matching name, not a zero-valued field. It returns a pointer to the corresponding field descriptor if found, otherwise NULL. The claim about a zero-valued field and pointer offset is inaccurate, resulting in no accurate fact-based claims aligned with the source logic.",
                "The summary fails to capture the core purpose of locating a field descriptor in a protobuf message descriptor by matching its name using a binary search on a sorted index. Instead, it incorrectly describes searching for a zero-valued field and returning a pointer offset, which contradicts the source code. There is no accurate coverage of the primary domain behavior and no mention of secondary details such as null checks, binary search steps, or string comparison.",
                "The summary claims the function searches for a zero-valued field and returns its data pointer offset, which is incorrect. The source code shows it searches a sorted array of field indices by name using binary search and returns the matching field descriptor or NULL. The introduced concept of a zero-valued field is a severe inaccuracy targeting the core purpose, making the description untrustworthy. There are no accurate claims to offset this fatal error."
            ]
        },
        "comment": {
            "summary": "Retrieves the field descriptor with a matching name from a sorted list of fields in a ProtobufC message descriptor.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function retrieves a field descriptor by matching a name from a sorted list of fields in a ProtobufC message descriptor, aligning with the code\u2019s binary search on fields_sorted_by_name. It captures the core domain-specific behavior without inaccuracies, though it omits explicit mention of NULL checks and search mechanics, making it slightly less detailed but still accurate.",
                "The summary accurately states that the function retrieves a field descriptor by name from a sorted list in a ProtobufC message descriptor, which matches the core purpose derived from the code. However, it omits important secondary details such as the use of binary search, handling of NULL descriptors, returning NULL when not found, and specific field array indexing. These omissions reduce coverage of behavior-critical aspects.",
                "The summary correctly states the core purpose of the function: retrieving a field descriptor by matching name from a sorted list within a ProtobufC message descriptor. This is accurate and aligns with the code\u2019s binary search approach. The claim is specific to the primary function behavior, with no contradictory or irrelevant information, though it is somewhat generic and omits mention of how the search is implemented. No FATAL or excessive noise is present, but the informational gain is moderate due to lack of detail."
            ]
        }
    }
}
{
    "project_name": "poke",
    "function_addr": 544320,
    "strip_function_name": "sub_84E40",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_84E40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)\n{\n  __int64 v8; // r12\n  __int64 v9; // rdi\n  int v10; // eax\n  __int64 v11; // rdi\n  __int64 v12; // r12\n  int v13; // eax\n  __int64 v14; // rdi\n  __int64 v15; // r12\n  int v16; // eax\n  __int64 v17; // rdi\n  __int64 v18; // r12\n  int v19; // eax\n  __int64 v20; // rdi\n  __int64 v21; // r12\n  unsigned __int64 result; // rax\n  _QWORD *v23; // rcx\n  __int64 v24; // r8\n  __int64 v25; // r9\n\n  sub_81170((__int64 *)(a1 + 16), 5);\n  v8 = *(_QWORD *)(a1 + 16);\n  if ( a2 )\n    ++*(_DWORD *)(a2 + 60);\n  v9 = *(_QWORD *)(a1 + 8);\n  *(_QWORD *)(v8 + 32) = a2;\n  v10 = sub_8A6E0(v9);\n  v11 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v8 + 16) = v10;\n  v12 = *(_QWORD *)(a1 + 16);\n  v13 = sub_8A6E0(v11);\n  v14 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v12 + 20) = v13;\n  v15 = *(_QWORD *)(a1 + 16);\n  v16 = sub_8A6E0(v14);\n  v17 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v15 + 24) = v16;\n  v18 = *(_QWORD *)(a1 + 16);\n  v19 = sub_8A6E0(v17);\n  v20 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v18 + 56) = v19;\n  v21 = *(_QWORD *)(a1 + 16);\n  result = sub_8A6E0(v20);\n  *(_DWORD *)(v21 + 52) = result;\n  if ( a2 )\n    return sub_81880(a1, 0xE8u, 0LL, v23, v24, v25, a7);\n  return result;\n}\n",
    "function_name": "pkl_asm_for",
    "decompiled_code": "void __fastcall pkl_asm_for(pkl_asm_0 pasm, pkl_ast_node head)\n{\n  pkl_asm_level *level; // r12\n  pvm_program *program; // rdi\n  pvm_program_label v5; // eax\n  pvm_program *v6; // rdi\n  pkl_asm_level *v7; // r12\n  pvm_program_label v8; // eax\n  pvm_program *v9; // rdi\n  pkl_asm_level *v10; // r12\n  pvm_program_label v11; // eax\n  pvm_program *v12; // rdi\n  pkl_asm_level *v13; // r12\n  pvm_program_label v14; // eax\n  pvm_program *v15; // rdi\n  pkl_asm_level *v16; // r12\n\n  pkl_asm_pushlevel((pkl_asm_0)&pasm->level, 5);\n  level = pasm->level;\n  if ( head )\n    ++*((_DWORD *)head + 15);\n  program = pasm->program;\n  level->node1 = head;\n  v5 = pvm_program_fresh_label(program);\n  v6 = pasm->program;\n  level->label1 = v5;\n  v7 = pasm->level;\n  v8 = pvm_program_fresh_label(v6);\n  v9 = pasm->program;\n  v7->label2 = v8;\n  v10 = pasm->level;\n  v11 = pvm_program_fresh_label(v9);\n  v12 = pasm->program;\n  v10->label3 = v11;\n  v13 = pasm->level;\n  v14 = pvm_program_fresh_label(v12);\n  v15 = pasm->program;\n  v13->continue_label = v14;\n  v16 = pasm->level;\n  v16->break_label = pvm_program_fresh_label(v15);\n  if ( head )\n    pkl_asm_insn_0(pasm, pkl_asm_insn::PKL_INSN_PUSHF, 0LL);\n}\n",
    "source_code": "\nvoid\npkl_asm_for (pkl_asm pasm, pkl_ast_node head)\n{\n  pkl_asm_pushlevel (pasm, PKL_ASM_ENV_FOR_LOOP);\n\n  pasm->level->node1 = ASTREF (head);\n  pasm->level->label1 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label2 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label3 = pvm_program_fresh_label (pasm->program);\n  pasm->level->continue_label = pvm_program_fresh_label (pasm->program);\n  pasm->level->break_label = pvm_program_fresh_label (pasm->program);\n\n  if (head)\n    pkl_asm_insn (pasm, PKL_INSN_PUSHF, 0);\n}",
    "comment": "Initializes a for loop's environment in the assembly context, assigning labels and pushing the loop node if a valid head is provided.",
    "hext5_sum": "p is redefine node. hash value is generated from its \"source\" filed.",
    "bint5_sum": "Initializes loop labels and node references for a 'for-in ' loop based on the specified label type , which is either an array or a string .\n",
    "cpbcs_sum": "Finalizes a conditional assembly by writing an HTML span name, and referencing the result to the output buffer.\n",
    "misum_sum": "Encodes loop and values in a structured format by assigning values and referencing the given argument in the specified byte stream.\n",
    "decom_sum": "Initializes object state from `a1`, updates linked structure counters, stores multiple retrieved values, and optionally triggers a handler when `a2` is provided.",
    "cfg_sum": "Initializes and updates structured data fields from an object, increments a counter if provided, and triggers further processing when a secondary object exists.",
    "work_score": {
        "decom": {
            "summary": "Initializes object state from `a1`, updates linked structure counters, stores multiple retrieved values, and optionally triggers a handler when `a2` is provided.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary describes initializing object state from `a1`, updating linked structure counters, storing retrieved values, and triggering a handler when `a2` is provided, none of which match the source code. The source code instead sets up labels and loop environment for `pkl_asm_for`, with no mention of `a1`/`a2`, counters, or handlers. All claims are inaccurate, resulting in 0% accurate content.",
                "The summary's claims about initializing state from `a1`, updating linked structure counters, storing values, and triggering a handler with `a2` are unrelated to the source code, which sets up a for-loop assembly context, assigns AST references, generates multiple labels, and optionally pushes a FOR instruction. None of the claims accurately cover the core purpose, and there is no mention of label creation, loop control, or ASM environment setup.",
                "The summary contains only inaccurate statements unrelated to the source code's behavior. The source code sets up a loop context by pushing a new assembler level, associating the AST node, generating fresh labels for loop control, and optionally emitting a push frame instruction when 'head' is non-null. The summary instead describes initializing state from 'a1', updating counters in a linked structure, storing retrieved values, and triggering a handler based on 'a2', none of which occur in the function. This is pure NOISE targeting unrelated semantics, with no accurate claims and no gain."
            ]
        },
        "cfg": {
            "summary": "Initializes and updates structured data fields from an object, increments a counter if provided, and triggers further processing when a secondary object exists.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains multiple claims, such as initializing and updating structured data fields, incrementing a counter, and triggering further processing when a secondary object exists. None of these match the specific semantics of the source code, which sets up loop-related labels and pushes an environment level for a 'for' loop. The described behavior does not correspond to the actual function logic, resulting in all claims being inaccurate.",
                "The summary's claims about initializing fields from an object, incrementing a counter, and triggering processing when a secondary object exists are not aligned with the source code. The function sets up a for-loop environment, assigns AST node references, generates multiple labels including continue and break labels, and conditionally pushes an instruction if a node exists. None of these core semantics are covered, and the provided claims are inaccurate and unrelated to the actual domain operation.",
                "The summary's claims \u2014 initializing/updating fields from an object, incrementing a counter, and conditional processing of a secondary object \u2014 do not match the source code. The function actually pushes a FOR loop environment, assigns labels, stores an AST node reference, and optionally issues a PKL_INSN_PUSHF instruction. All claims in the summary are inaccurate and unrelated to the core purpose, with the worst failure being a severe contradiction on the primary purpose, making it unusable."
            ]
        },
        "comment": {
            "summary": "Initializes a for loop's environment in the assembly context, assigning labels and pushing the loop node if a valid head is provided.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly identifies the setup of a for loop environment in the assembly context, including label assignments and pushing the loop node when `head` is provided. These details align precisely with the source code's operations of `pkl_asm_pushlevel`, `pvm_program_fresh_label` calls for multiple labels, and conditional `pkl_asm_insn` usage. No inaccuracies or unrelated claims are present, indicating very high alignment.",
                "The summary correctly captures the core purpose: setting up an environment for a 'for' loop in the assembly context and assigning labels, as well as conditionally pushing the loop node when a head is provided. This aligns with the source code's creation of a FOR loop environment, setting multiple labels including continue and break, and issuing a PKL_INSN_PUSHF if head is non-null. However, it omits mention of the specific environment constant (PKL_ASM_ENV_FOR_LOOP), the exact number of labels created, and the specific instruction pushed, which are key secondary details.",
                "The summary correctly identifies the function's primary purpose\u2014initializing a for loop environment in the assembly context\u2014and notes accurate details such as assigning labels and pushing the loop node when 'head' is provided. All claims align with the source code without contradiction. The specificity about loop initialization and conditional push provides moderate gain, with no noise or fatal inaccuracies present."
            ]
        }
    }
}
{
    "project_name": "libredwg",
    "function_addr": 9908448,
    "strip_function_name": "dwg_object_polyline_2d_get_numpoints",
    "strip_decompiled_code": "__int64 __fastcall dwg_object_polyline_2d_get_numpoints(__int64 a1, _DWORD *a2)\n{\n  unsigned int v2; // ebp\n  _DWORD *v4; // r13\n  __int64 v5; // rdx\n  __int64 v6; // r14\n  __int64 v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // r13\n  __int64 object; // rax\n\n  if ( !a1 || *(_DWORD *)(a1 + 16) != 15 )\n  {\n    if ( dword_11106F8 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( dword_11106F8 )\n        __fprintf_chk();\n      fputc(10, stderr);\n    }\n    *a2 = 1;\n    return 0;\n  }\n  v4 = *(_DWORD **)(a1 + 88);\n  v5 = *(_QWORD *)(a1 + 56);\n  v6 = *(_QWORD *)(v5 + 8);\n  *a2 = 0;\n  if ( *v4 <= 0x18u )\n  {\n    v2 = 0;\n    if ( *v4 > 0x14u )\n    {\n      v8 = dwg_ref_object(v4, *(_QWORD *)(v6 + 16));\n      v9 = dwg_ref_object(v4, *(_QWORD *)(v6 + 24));\n      if ( v8 )\n      {\n        do\n        {\n          if ( dwg_object_to_VERTEX_2D(v8) )\n            ++v2;\n          else\n            *a2 = 1;\n          object = dwg_next_object(v8);\n          v8 = object;\n        }\n        while ( object && v9 != object );\n      }\n      else\n      {\n        *a2 = 1;\n      }\n    }\n    else\n    {\nLABEL_8:\n      v7 = dwg_next_object(a1);\n      if ( v7 )\n      {\n        while ( *(_DWORD *)(v7 + 16) != 6 )\n        {\n          if ( !dwg_object_to_VERTEX_2D(v7) )\n          {\n            *a2 = 1;\n            goto LABEL_8;\n          }\n          ++v2;\n          v7 = dwg_next_object(a1);\n          if ( !v7 )\n            return v2;\n        }\n      }\n    }\n    return v2;\n  }\n  return *(unsigned int *)(*(_QWORD *)(v5 + 8) + 12LL);\n}\n",
    "function_name": "dwg_object_polyline_2d_get_numpoints",
    "decompiled_code": "BITCODE_BL __fastcall dwg_object_polyline_2d_get_numpoints(const dwg_object *obj, int *error)\n{\n  BITCODE_BL v2; // ebp\n  _dwg_struct *parent; // r13\n  Dwg_Object_Entity *entity; // rdx\n  Dwg_Entity_UNUSED *UNUSED; // r14\n  Dwg_Object *v7; // rax\n  Dwg_Object *v8; // rbx\n  __int64 v9; // r13\n  __int64 v10; // rax\n\n  if ( !obj || obj->type != 15 )\n  {\n    if ( loglevel_9 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( loglevel_9 )\n        ((void (*)(struct _IO_FILE *, __int64, const char *, ...))__fprintf_chk)(\n          stderr,\n          1LL,\n          \"%s: empty or wrong arg\",\n          \"dwg_object_polyline_2d_get_numpoints\");\n      fputc(10, stderr);\n    }\n    *error = 1;\n    return 0;\n  }\n  parent = obj->parent;\n  entity = obj->tio.entity;\n  UNUSED = entity->tio.UNUSED;\n  *error = 0;\n  if ( parent->header.version <= (unsigned int)DWG_VERSION_TYPE::R_2000 )\n  {\n    v2 = 0;\n    if ( parent->header.version > (unsigned int)DWG_VERSION_TYPE::R_12c1 )\n    {\n      v8 = (Dwg_Object *)((__int64 (__fastcall *)(_dwg_struct *, _QWORD))dwg_ref_object_localalias_21)(\n                           parent,\n                           *((_QWORD *)UNUSED + 2));\n      v9 = ((__int64 (__fastcall *)(_dwg_struct *, _QWORD))dwg_ref_object_localalias_21)(\n             parent,\n             *((_QWORD *)UNUSED + 3));\n      if ( v8 )\n      {\n        do\n        {\n          if ( dwg_object_to_VERTEX_2D(v8) )\n            ++v2;\n          else\n            *error = 1;\n          v10 = ((__int64 (__fastcall *)(Dwg_Object *))dwg_next_object)(v8);\n          v8 = (Dwg_Object *)v10;\n        }\n        while ( v10 && v9 != v10 );\n      }\n      else\n      {\n        *error = 1;\n      }\n    }\n    else\n    {\nLABEL_8:\n      v7 = (Dwg_Object *)((__int64 (__fastcall *)(const dwg_object *))dwg_next_object)(obj);\n      if ( v7 )\n      {\n        while ( v7->type != 6 )\n        {\n          if ( !dwg_object_to_VERTEX_2D(v7) )\n          {\n            *error = 1;\n            goto LABEL_8;\n          }\n          ++v2;\n          v7 = (Dwg_Object *)((__int64 (__fastcall *)(const dwg_object *))dwg_next_object)(obj);\n          if ( !v7 )\n            return v2;\n        }\n      }\n    }\n    return v2;\n  }\n  return entity->tio.UNUSED[3];\n}\n",
    "source_code": "BITCODE_BL\ndwg_object_polyline_2d_get_numpoints (const dwg_object *restrict obj,\n                                      int *restrict error)\n{\n  if (obj && obj->type == DWG_TYPE_POLYLINE_2D)\n    {\n      BITCODE_BL num_points = 0;\n      Dwg_Data *dwg = obj->parent;\n      Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;\n      Dwg_Entity_VERTEX_2D *vertex;\n      *error = 0;\n\n      if (dwg->header.version >= R_2004)\n        return obj->tio.entity->tio.POLYLINE_2D->num_owned;\n      // iterate over first_vertex - last_vertex\n      else if (dwg->header.version >= R_13)\n        {\n          Dwg_Object *vobj = dwg_ref_object (dwg, _obj->first_vertex);\n          Dwg_Object *vlast = dwg_ref_object (dwg, _obj->last_vertex);\n          if (!vobj)\n            *error = 1;\n          else\n            {\n              do\n                {\n                  if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                    {\n                      num_points++;\n                    }\n                  else\n                    {\n                      *error = 1; // return not all vertices, but some\n                    }\n                }\n              while ((vobj = dwg_next_object (vobj)) && vobj != vlast);\n            }\n        }\n      else // <r13: iterate over vertices until seqend\n        {\n          Dwg_Object *vobj;\n          while ((vobj = dwg_next_object (obj))\n                 && vobj->type != DWG_TYPE_SEQEND)\n            {\n              if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                num_points++;\n              else\n                *error = 1; // return not all vertices, but some\n            }\n        }\n      return num_points;\n    }\n  else\n    {\n      LOG_ERROR (\"%s: empty or wrong arg\", __FUNCTION__)\n      *error = 1;\n      return 0L;\n    }\n}",
    "comment": "Counts the number of 2D vertices in a polyline object based on DWG version and returns the count or an error code.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Counts the number of 2D vertices in a polyline object , returning an error if any vertex is invalid or if the object is incorrect .\n",
    "cpbcs_sum": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
    "misum_sum": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
    "decom_sum": "Retrieves the number of 2D vertex points in a DWG polyline object, reporting errors when the object type or data is invalid.",
    "cfg_sum": "Retrieves the number of 2D polyline vertices from a DWG object, validating type and structure, and sets an error flag with messages on failure.",
    "work_score": {
        "decom": {
            "summary": "Retrieves the number of 2D vertex points in a DWG polyline object, reporting errors when the object type or data is invalid.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary makes two fact-based claims: that the function retrieves the number of 2D vertex points in a DWG polyline and that it reports errors when the object type or data is invalid. Both claims align with the source code, which counts vertices depending on DWG version and sets an error flag on invalid type or missing vertex data. The claims are accurate but leave out version-specific logic, so while correct, they are somewhat generic.",
                "The summary correctly identifies that the function retrieves the number of 2D vertex points from a DWG polyline object and signals errors when the object type or data is invalid, covering the core purpose. However, it omits important details such as handling different DWG version branches (R_2004 direct count, R_13 iteration, pre-R_13 sequence end), the specific iteration over vertices, partial error reporting when some vertices are invalid, and logging for empty or wrong arguments. These omissions limit coverage of secondary behavior-critical semantics.",
                "The summary contains one accurate GOLD claim that the function retrieves the number of 2D vertex points in a DWG polyline object, which matches the core logic. It also correctly notes that the function reports errors when the object type or data is invalid, which aligns with the error handling for wrong type, null object, or invalid vertex sequence. There are no inaccurate or noisy claims, but the description is relatively generic and omits the version-specific branching and iteration details, limiting the informational gain."
            ]
        },
        "cfg": {
            "summary": "Retrieves the number of 2D polyline vertices from a DWG object, validating type and structure, and sets an error flag with messages on failure.",
            "score": [
                0.8,
                0.5,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves the number of 2D polyline vertices and validates the object type, which matches the code. It also correctly notes that it sets an error flag on failure. However, the claim that it sets 'messages' on failure is inaccurate: the code only logs an error message when the object is empty or of the wrong type, not in all failure cases, and generally just updates the error flag. All other parts are accurate, giving a high proportion of correct claims despite the minor exaggeration about messages.",
                "The summary accurately covers the core purpose of obtaining the vertex count from a 2D polyline DWG object and mentions type validation and error handling, matching the source code\u2019s main intent. However, it omits key secondary details such as version-specific logic for retrieving vertices, iteration methods for different DWG versions, and the distinction between complete and partial vertex retrieval. The mention of messages on failure is slightly inaccurate since the code only logs an error in the wrong-type case, not for all failure conditions.",
                "The summary correctly states that the function retrieves the number of vertices for a 2D polyline from a DWG object and validates its type. It also notes setting an error flag on failure, which matches the code. However, the mention of 'messages on failure' is inaccurate because the function only logs an error in the wrong-argument case, not in all failure scenarios, and uses an error flag otherwise. Overall, the description is mostly accurate, with minor noise and limited detail on the version-dependent iteration logic, keeping the gain low."
            ]
        },
        "comment": {
            "summary": "Counts the number of 2D vertices in a polyline object based on DWG version and returns the count or an error code.",
            "score": [
                0.6,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function counts the number of 2D vertices in a polyline object depending on the DWG version, which matches the conditional branching in the code. However, it inaccurately implies that the function returns an error code directly, whereas in the source code, errors are indicated via the error pointer, and the return value is always a count. This introduces a semantic contradiction for one of the main claims, reducing overall accuracy.",
                "The summary accurately captures the core purpose of counting 2D vertices in a polyline object with logic depending on DWG version, correctly reflecting the primary domain operation. However, it omits important secondary details such as handling different DWG version ranges with distinct iteration strategies, specific error conditions when vertices cannot be processed, and the initialization/resetting of the error flag. These omissions limit the completeness of the coverage.",
                "The summary correctly states the primary purpose of counting 2D vertices in a polyline object depending on the DWG version, which matches the core logic in the code. It also notes returning a count or an error code, which aligns with the return value and error handling via the 'error' pointer. However, the description is broad and omits key specifics such as the different iteration methods for various DWG versions (>=R_2004, >=R_13, <R_13) and conditions for setting error to 1, resulting in low informational gain. No inaccuracies are present, but the explanation is too generic to be highly useful."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6038306,
    "strip_function_name": "sub_5C2322",
    "strip_decompiled_code": "__int64 __fastcall sub_5C2322(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __m128i *v10; // rbx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rax\n  __m128 v14; // xmm4\n  __m128 v15; // xmm5\n  __int64 v16; // rdi\n  const char *v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n\n  v10 = sub_51816D((const char *)0xB8, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  qword_89A638 = (__int64)v10;\n  v10->m128i_i32[3] = 1024;\n  v13 = sub_51812F((const char *)0x400, a10, a1, a2, a3, a4, v11, v12, a7, a8);\n  v10[1].m128i_i64[1] = v13;\n  v10[2].m128i_i64[0] = v13;\n  v10[3].m128i_i64[0] = (__int64)v10[3].m128i_i64;\n  v10[3].m128i_i64[1] = (__int64)v10[3].m128i_i64;\n  v16 = *(_QWORD *)(a10 + 8);\n  if ( v16 )\n  {\n    v18 = (const char *)sub_518195(v16, a10, a1, a2, a3, a4, *(double *)v14.m128_u64, *(double *)v15.m128_u64, a7, a8);\n    v10[2].m128i_i64[1] = (__int64)v18;\n    if ( !(unsigned int)sub_5C1052(v18, 1LL, v19, v20, v21, v22, a1, a2, a3, a4, v23, v24, a7, a8) )\n      return 0LL;\n    if ( v10->m128i_i32[1] )\n      sub_5C0E5C(1, 1LL, v25, v26, v27, v28, a1, a2, a3, a4, v14, v15, a7, a8);\n    v10[4].m128i_i8[8] = 0;\n  }\n  sub_5C17D1(a1, a2, a3, a4, *(double *)v14.m128_u64, *(double *)v15.m128_u64, a7, a8);\n  return 0LL;\n}\n",
    "function_name": "ed_main",
    "decompiled_code": "__int64 __fastcall ed_main(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __m128i *v10; // rbx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __m128 v13; // xmm4\n  __m128 v14; // xmm5\n  __int64 v15; // rax\n  const __m128i *v16; // rdi\n  int *v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n\n  v10 = xzalloc(0xB8uLL, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  ptr_to_globals = (__int64)v10;\n  v10->m128i_i32[3] = 1024;\n  xmalloc(0x400uLL, a10, a1, a2, a3, a4, v11, v12, a7, a8);\n  v10[1].m128i_i64[1] = v15;\n  v10[2].m128i_i64[0] = v15;\n  v10[3].m128i_i64[0] = (__int64)v10[3].m128i_i64;\n  v10[3].m128i_i64[1] = (__int64)v10[3].m128i_i64;\n  v16 = *(const __m128i **)(a10 + 8);\n  if ( v16 )\n  {\n    v18 = xstrdup(v16, a10, a1, a2, a3, a4, *(double *)v13.m128_u64, *(double *)v14.m128_u64, a7, a8);\n    v10[2].m128i_i64[1] = (__int64)v18;\n    if ( !(unsigned int)readLines((const char *)v18, 1LL, v19, v20, v21, v22, a1, a2, a3, a4, v23, v24, a7, a8) )\n      return 0LL;\n    if ( v10->m128i_i32[1] )\n      setCurNum(1, 1LL, v25, v26, v27, v28, a1, a2, a3, a4, v13, v14, a7, a8);\n    v10[4].m128i_i8[8] = 0;\n  }\n  doCommands(a1, a2, a3, a4, v13, v14, a7, a8);\n  return 0LL;\n}\n",
    "source_code": "int ed_main(int argc UNUSED_PARAM, char **argv)\n{\n\tINIT_G();\n\n\tbufSize = INITBUF_SIZE;\n\tbufBase = xmalloc(bufSize);\n\tbufPtr = bufBase;\n\tlines.next = &lines;\n\tlines.prev = &lines;\n\n\tif (argv[1]) {\n\t\tfileName = xstrdup(argv[1]);\n\t\tif (!readLines(fileName, 1)) {\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (lastNum)\n\t\t\tsetCurNum(1);\n\t\tdirty = FALSE;\n\t}\n\n\tdoCommands();\n\treturn EXIT_SUCCESS;\n}",
    "comment": "Initializes a buffer, reads lines from a specified file if provided, and then executes commands in a loop.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes an event-driven daemon that monitors input device events , processes them , and logs relevant actions accordingly .\n",
    "cpbcs_sum": "Initializes a new peer structure with an identifier and associated info and allocates a new file descriptor.\n",
    "misum_sum": "Allocates and initializes a new mount structure, setting its properties and registering the provided file stream with those handling.\n",
    "decom_sum": "Initializes a 1024-byte memory structure, links resources, validates them, triggers auxiliary processing, and finalizes state based on validation results.",
    "cfg_sum": "Initializes a data structure, validates associated resources, executes follow-up routines if checks pass, and finalizes state before returning a success or failure indicator.",
    "work_score": {
        "decom": {
            "summary": "Initializes a 1024-byte memory structure, links resources, validates them, triggers auxiliary processing, and finalizes state based on validation results.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains multiple inaccuracies: it claims a fixed 1024-byte memory structure initialization, but the code uses INITBUF_SIZE without specifying 1024; 'links resources' is vague and not clearly mapped to the code; 'validates them' is unsupported by the code, which only reads file lines without explicit validation logic; 'triggers auxiliary processing' and 'finalizes state based on validation results' do not directly match the observed operations. Very few claims accurately reflect the actual initialization of buffers, setting list pointers, and running commands, resulting in low accuracy overall.",
                "The summary does not accurately capture the core purpose of the function, which is to initialize editor state, optionally load a file's lines into memory, set the current line number, and run commands. While it mentions initialization and validation generically, it introduces inaccurate details like a hardcoded 1024-byte size and vague 'links resources' and 'auxiliary processing' without reference to the actual file-reading and command execution logic. The core domain action is missing and several claims are incorrect in relation to the source code semantics.",
                "The summary contains multiple inaccuracies: it claims a 1024-byte memory structure is initialized, but the source code uses INITBUF_SIZE without stating its value; mentions linking resources, validating them, and finalizing state based on validation results, none of which clearly align with the actual behavior of linking list nodes, reading file lines, setting current line number, and running commands. These are FATAL inaccuracies regarding the primary purpose, I/O handling, and core logic, making the summary misleading and unusable. There are no precise, GOLD-aligned details extracted from the source."
            ]
        },
        "cfg": {
            "summary": "Initializes a data structure, validates associated resources, executes follow-up routines if checks pass, and finalizes state before returning a success or failure indicator.",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary is overly generic and omits key code-specific details such as buffer allocation, list initialization, conditional file reading, and command execution. It inaccurately states there is validation of resources and a possible failure return, whereas the source always returns success. Few claims directly match the source\u2019s semantics, resulting in low alignment.",
                "The summary offers only vague, generic descriptions like 'initializes a data structure' and 'executes follow-up routines,' which do not capture the core domain purpose of setting up buffers and linked list pointers, optionally reading lines from a file, adjusting state, and running commands. It fails to explicitly state the key action of reading file content and executing commands, making the core purpose uncovered and secondary behavior largely absent.",
                "The summary is mostly generic and lacks alignment with the specific semantics of the source code. It does not mention key details such as memory allocation via xmalloc, conditionally reading lines from a file, setting the current line number, and executing commands regardless of the checks. The claim about returning a success or failure indicator is inaccurate because the function always returns success; thus, it introduces a factual error on the primary output behavior. This constitutes a FATAL error on a core aspect (return value), making the net benefit very low despite some generic accurate claims of initialization and follow-up routines."
            ]
        },
        "comment": {
            "summary": "Initializes a buffer, reads lines from a specified file if provided, and then executes commands in a loop.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function initializes a buffer and reads lines from a file if an argument is provided, which matches the buffer allocation and file reading logic in the code. It also mentions executing commands in a loop, which is consistent with the call to doCommands() that likely processes commands until completion. All claims are accurate and align with the source code\u2019s domain-specific behavior.",
                "The summary accurately describes buffer initialization, conditional file reading, and execution of commands, aligning with the core purpose of initializing state and processing user commands from a file if specified. However, it omits important secondary details such as setting up linked list pointers, handling the case when file read fails by exiting early, resetting the current line number when data exists, and marking the buffer as not dirty. These omissions reduce coverage of behavior-critical semantics.",
                "The summary contains accurate claims: it correctly describes buffer initialization, conditional reading of lines from a provided file, and execution of commands. These are central behaviors of the function and align with the source code. However, it omits details such as specific initialization of linked list pointers, allocation size constants, and handling of return conditions from 'readLines'. The claims are accurate but fairly generic, offering low-info gain. There is no contradictory or irrelevant content, so noise is minimal."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 344960,
    "strip_function_name": "sub_54380",
    "strip_decompiled_code": "__int64 __fastcall sub_54380(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v8; // r12\n  __int64 v9; // r14\n  __int64 v10; // rbx\n  __int64 v11; // r8\n  __int64 v12; // rax\n  __int64 v13; // rbp\n  __int64 v14; // r11\n  __int64 v18; // [rsp+20h] [rbp-48h]\n\n  v8 = a2;\n  v9 = a4;\n  if ( a4 > 165 )\n  {\n    do\n    {\n      v10 = v9 >> 1;\n      v13 = v9 - (v9 >> 1);\n      v18 = __gmpn_dcpi1_bdiv_qr_n(a1, v8, a3, v9 >> 1, a5, a6);\n      __gmpn_mullo_n(a6, a1, a3 + 8 * v13, v9 >> 1);\n      __gmpn_add_n(v8 + 8 * v13, v8 + 8 * v13, a6, v9 >> 1);\n      v11 = 8 * (v9 >> 1);\n      v14 = v8 + v11;\n      if ( v9 >> 1 < v13 )\n      {\n        v12 = __gmpn_addmul_1(v8 + 8 * v10, a1, v9 >> 1, *(_QWORD *)(a3 + 8 * v10));\n        v11 = 8 * v10;\n        v14 = v8 + 8 * v10;\n        *(_QWORD *)(v8 + 8 * v9 - 8) += v18 + v12;\n      }\n      a1 += v11;\n      v8 = v14;\n      v9 -= v9 >> 1;\n    }\n    while ( v13 > 165 );\n  }\n  else\n  {\n    v13 = a4;\n    v14 = a2;\n  }\n  return __gmpn_sbpi1_bdiv_q(a1, v14, v13, a3, v13, a5);\n}\n",
    "function_name": "mpn_dcpi1_bdiv_q_n",
    "decompiled_code": "void __fastcall mpn_dcpi1_bdiv_q_n(mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)\n{\n  mp_size_t v9; // r14\n  __int64 v10; // rbx\n  __int64 v11; // rbp\n  __int64 v12; // r8\n  mp_limb_t *v13; // r11\n  __int64 v14; // rax\n  __int64 v17; // [rsp+88h] [rbp+20h]\n\n  v9 = n;\n  if ( n > 165 )\n  {\n    do\n    {\n      v10 = v9 >> 1;\n      v11 = v9 - (v9 >> 1);\n      v17 = ((__int64 (__fastcall *)(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr))__gmpn_dcpi1_bdiv_qr_n)(\n              qp,\n              np,\n              dp,\n              v9 >> 1,\n              dinv,\n              tp);\n      ((void (__fastcall *)(mp_ptr, mp_ptr, const mp_limb_t *, mp_size_t))__gmpn_mullo_n)(tp, qp, &dp[v11], v9 >> 1);\n      ((void (__fastcall *)(mp_limb_t *, mp_limb_t *, mp_ptr, mp_size_t))__gmpn_add_n)(&np[v11], &np[v11], tp, v9 >> 1);\n      v12 = v9 >> 1;\n      v13 = &np[v12];\n      if ( v9 >> 1 < v11 )\n      {\n        v14 = ((__int64 (__fastcall *)(mp_limb_t *, mp_ptr, mp_size_t, const mp_limb_t))__gmpn_addmul_1)(\n                &np[v10],\n                qp,\n                v9 >> 1,\n                dp[v10]);\n        v12 = v10;\n        v13 = &np[v10];\n        np[v9 - 1] += v17 + v14;\n      }\n      qp = (mp_ptr)((char *)qp + v12 * 8);\n      np = v13;\n      v9 -= v9 >> 1;\n    }\n    while ( v11 > 165 );\n  }\n  JUMPOUT(0xB6E0LL);\n}\n",
    "source_code": "\nstatic void\nmpn_dcpi1_bdiv_q_n (mp_ptr qp,\n\t\t    mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t    mp_limb_t dinv, mp_ptr tp)\n{\n  while (ABOVE_THRESHOLD (n, DC_BDIV_Q_THRESHOLD))\n    {\n      mp_size_t lo, hi;\n      mp_limb_t cy;\n\n      lo = n >> 1;\t\t\t/* floor(n/2) */\n      hi = n - lo;\t\t\t/* ceil(n/2) */\n\n      cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, lo, dinv, tp);\n\n      mpn_mullo_n (tp, qp, dp + hi, lo);\n      mpn_add_n (np + hi, np + hi, tp, lo);\n\n      if (lo < hi)\n\t{\n\t  cy += mpn_addmul_1 (np + lo, qp, lo, dp[lo]);\n\t  np[n - 1] += cy;\n\t}\n      qp += lo;\n      np += lo;\n      n -= lo;\n    }\n  mpn_sbpi1_bdiv_q (qp, np, n, dp, n, dinv);\n}",
    "comment": "Divides a multi-precision number by another using a divide-and-conquer approach, updating quotient and remainder for large input sizes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Computes the quotient and remainder of the division of ` a ` and ` b ` raised to ` x ` , storing the result in ` r ` .\n",
    "cpbcs_sum": "Adds two multi-precision integers represented by the first set of two base integers using the iterative function.\n",
    "misum_sum": "Calculates the product of two multi-precision integers using division approximation and stores the result in `rp` storing the result in `rp`\n",
    "decom_sum": "Performs a recursive multi-limb division of large integers using GMP\u2019s divide-and-conquer and schoolbook algorithms for quotient and remainder computation.",
    "cfg_sum": "Recursively performs multi-precision division using GMP algorithms, splitting operands above a threshold and combining partial results to compute the final quotient.",
    "work_score": {
        "decom": {
            "summary": "Performs a recursive multi-limb division of large integers using GMP\u2019s divide-and-conquer and schoolbook algorithms for quotient and remainder computation.",
            "score": [
                0.7,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly identifies that the function performs large integer division using GMP\u2019s divide-and-conquer and schoolbook algorithms, which matches the code\u2019s loop applying mpn_dcpi1_bdiv_qr_n and mpn_sbpi1_bdiv_q for quotient computation. However, it inaccurately mentions remainder computation, which is not returned or explicitly computed in this function. Most claims are accurate regarding domain semantics, but the remainder part is incorrect, reducing precision.",
                "The summary correctly identifies that the function performs multi-limb division using GMP\u2019s divide-and-conquer and schoolbook algorithms, which matches the core purpose of implementing a threshold-based divide-and-conquer algorithm for quotient computation. However, it inaccurately states that it computes the remainder, which is not evident in the source; the function focuses on quotient calculation and adjustments, not returning a remainder. It also omits important secondary behaviors such as threshold checks, splitting operands into high/low parts, cyclic carry handling, and specific calls to helper functions like mpn_dcpi1_bdiv_qr_n and mpn_sbpi1_bdiv_q. Coverage of secondary details is weak.",
                "The summary correctly identifies that the function performs multi-limb division using a divide-and-conquer approach followed by a schoolbook algorithm, which matches the sequential calls to mpn_dcpi1_bdiv_qr_n and mpn_sbpi1_bdiv_q in the source. However, it inaccurately states that both quotient and remainder are computed, while the function is focused on quotient computation only. This is a FATAL error affecting the primary purpose of the function, resulting in a severe misrepresentation despite the otherwise accurate algorithm description."
            ]
        },
        "cfg": {
            "summary": "Recursively performs multi-precision division using GMP algorithms, splitting operands above a threshold and combining partial results to compute the final quotient.",
            "score": [
                0.9,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly describes that the function operates on multi-precision division, uses a threshold to split operands, and combines partial results to produce the quotient, which aligns with the code\u2019s use of ABOVE_THRESHOLD, operand splitting, and combining with mpn_add_n. It omits certain specifics like the exact helper functions invoked and precise data types, but does not introduce inaccuracies. Overall, the majority of claims are accurate and grounded in the code semantics.",
                "The summary correctly states that the function performs multi-precision division using GMP algorithms and mentions splitting operands above a threshold and combining partial results, which aligns with the recursive halving and combining seen in the source. This covers the core primary purpose of dividing large numbers into parts above a threshold to compute the quotient. However, it lacks detail on secondary behavior such as the specific helper functions used (mpn_dcpi1_bdiv_qr_n, mpn_mullo_n, mpn_add_n, mpn_addmul_1, mpn_sbpi1_bdiv_q), the carry handling logic, and the threshold constants, so coverage is incomplete.",
                "The summary correctly identifies that the function performs multi-precision division using GMP algorithms and splits operands above a threshold, which matches the use of ABOVE_THRESHOLD, lo/hi splitting, and recursive calls. However, it inaccurately describes the operation as recursive; the code uses a while loop with iterative processing instead of true recursion. The claim about combining partial results to compute the final quotient is consistent with the code. The worst failure mode is a FATAL error on the core method description due to mislabeling iteration as recursion, which targets the primary purpose."
            ]
        },
        "comment": {
            "summary": "Divides a multi-precision number by another using a divide-and-conquer approach, updating quotient and remainder for large input sizes.",
            "score": [
                0.8,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly identifies that the function performs division of multi-precision numbers using a divide-and-conquer method and applies this for large sizes, which corresponds to the threshold-based loop in the source code. However, it inaccurately states that the remainder is updated; the implementation updates the dividend remainder segment but does not store or explicitly return a separate remainder value. This minor inaccuracy slightly reduces precision but most claims align with the function\u2019s behavior.",
                "The summary correctly states that the function performs division between multi-precision numbers using a divide-and-conquer approach, which matches the core purpose. However, it omits important secondary behaviors such as use of thresholds to determine recursion, splitting operands into halves, intermediate multiplication and addition operations, conditional addmul and carry handling, pointer adjustments, and final call to a smaller base-case division function. These details are critical to fully capturing the function's behavior.",
                "The summary correctly identifies that the function performs division of multi-precision numbers using a divide-and-conquer approach, which matches the loop logic splitting n into hi and lo parts and calling subroutines accordingly. However, it inaccurately states that both quotient and remainder are updated \u2014 the source code only updates the quotient and modifies np representing the remaining dividend part, but there is no explicit remainder output. This is a FATAL error on key I/O since it misstates the output semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580562848,
    "strip_function_name": "sub_FFFFFFFF811A35A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811A35A0(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        __int16 a3,\n        __int64 a4,\n        __int64 a5,\n        volatile signed __int32 **a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  unsigned __int64 v16; // rax\n  volatile signed __int32 *v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r12d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // rdx\n  __int64 v24; // rcx\n  int v25; // r8d\n  int v26; // r9d\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  __int64 result; // rax\n  signed __int32 v30; // et0\n  volatile signed __int32 *v32[7]; // [rsp+8h] [rbp-38h] BYREF\n\n  v16 = sub_FFFFFFFF811A3160(a5, 16877, 1, a7, a8, a9, a10, a11, a12, a13, a14);\n  if ( !v16 )\n    return 4294967284LL;\n  *(_WORD *)(v16 + 96) |= a3 << 8;\n  *(_QWORD *)(v16 + 72) = a1;\n  v17 = (volatile signed __int32 *)v16;\n  v32[1] = 0LL;\n  v32[0] = a2;\n  *(_QWORD *)(v16 + 56) = a4;\n  sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C41440);\n  v20 = sub_FFFFFFFF811A33A0(v32, (__int64)v17, a7, a8, a9, a10, v18, v19, a13, a14);\n  sub_FFFFFFFF811A34E0((__int64)v32, (__int64)v17, a7, a8, a9, a10, v21, v22, a13, a14);\n  if ( v20 )\n  {\n    v30 = _InterlockedDecrement(v17);\n    LOBYTE(v23) = v30 == 0;\n    result = v20;\n    if ( !v30 )\n    {\n      sub_FFFFFFFF811A2C80((unsigned __int64)v17, (__int64)v17, v23, v24, v25, v26, a7, a8, a9, a10, v27, v28, a13, a14);\n      return v20;\n    }\n  }\n  else\n  {\n    *a6 = v17;\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "create_dir",
    "decompiled_code": "__int64 __fastcall create_dir(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        __int16 a3,\n        __int64 a4,\n        __int64 *a5,\n        volatile signed __int32 **a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 *v16; // rax\n  volatile signed __int32 *v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r12d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // rdx\n  __int64 v24; // rcx\n  int v25; // r8d\n  int v26; // r9d\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  __int64 result; // rax\n  signed __int32 v30; // et0\n  volatile signed __int32 *v32[7]; // [rsp+8h] [rbp-38h] BYREF\n\n  v16 = sysfs_new_dirent(a5, 16877, 1, a7, a8, a9, a10, a11, a12, a13, a14);\n  if ( !v16 )\n    return 4294967284LL;\n  *((_WORD *)v16 + 48) |= a3 << 8;\n  v16[9] = a1;\n  v17 = (volatile signed __int32 *)v16;\n  v32[1] = 0LL;\n  v32[0] = a2;\n  v16[7] = a4;\n  mutex_lock((__int64)&sysfs_mutex);\n  v20 = sysfs_add_one(v32, (__int64)v17, a7, a8, a9, a10, v18, v19, a13, a14);\n  sysfs_addrm_finish((__int64)v32, (__int64)v17, a7, a8, a9, a10, v21, v22, a13, a14);\n  if ( v20 )\n  {\n    v30 = _InterlockedDecrement(v17);\n    LOBYTE(v23) = v30 == 0;\n    result = v20;\n    if ( !v30 )\n    {\n      release_sysfs_dirent((__int64)v17, (__int64)v17, v23, v24, v25, v26, a7, a8, a9, a10, v27, v28, a13, a14);\n      return v20;\n    }\n  }\n  else\n  {\n    *a6 = v17;\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,\n\tenum kobj_ns_type type, const void *ns, const char *name,\n\tstruct sysfs_dirent **p_sd)\n{\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct sysfs_addrm_cxt acxt;\n\tstruct sysfs_dirent *sd;\n\tint rc;\n\n\t/* allocate */\n\tsd = sysfs_new_dirent(name, mode, SYSFS_DIR);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\n\tsd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);\n\tsd->s_ns = ns;\n\tsd->s_dir.kobj = kobj;\n\n\t/* link in */\n\tsysfs_addrm_start(&acxt, parent_sd);\n\trc = sysfs_add_one(&acxt, sd);\n\tsysfs_addrm_finish(&acxt);\n\n\tif (rc == 0)\n\t\t*p_sd = sd;\n\telse\n\t\tsysfs_put(sd);\n\n\treturn rc;\n}",
    "comment": "Creates a directory entry in a configuration filesystem, ensuring it does not already exist and managing reference counts for the parent directory.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Renames a sysfs directory entry by updating its name , parent , and namespace , ensuring no conflicts with existing entries .\n",
    "cpbcs_sum": "Adds a new mount to a specified namespace, creating a sysfs directory if successful, and ensures the directory is properly marked as needed.\n",
    "misum_sum": "Creates and registers an inode for a specified device with specified attributes and device index, handling errors during the process.\n",
    "decom_sum": "Initializes a new structure with provided parameters, performs two configuration routines, and returns it through output pointer or cleans up on failure.",
    "cfg_sum": "Allocates and initializes a data structure, sets configuration fields, performs validation, atomically updates references, and returns either success with object or an error code.",
    "work_score": {
        "decom": {
            "summary": "Initializes a new structure with provided parameters, performs two configuration routines, and returns it through output pointer or cleans up on failure.",
            "score": [
                0.6,
                0.2,
                0.5
            ],
            "reason": [
                "The summary captures some aspects of the code, such as initializing a structure with parameters and returning it via an output pointer or cleaning up on failure, which aligns with the allocation, setup, and conditional return/cleanup in the function. However, it omits critical specifics: the structure is a sysfs directory entry, initialization involves setting flags, namespace, and kobject, and the 'two configuration routines' phrase is vague and doesn't clearly map to the sysfs_addrm_start/add_one/finish sequence. While the general behavior is mostly correct, the lack of domain-specific detail and vague description reduces precision.",
                "The summary vaguely describes initializing a structure and performing routines but omits the core primary purpose \u2014 creating and linking a sysfs directory entry under a parent with specific mode and namespace details. While it notes returning via an output pointer or cleaning up on failure, it fails to mention the domain-specific action of adding the new sysfs_dirent to sysfs and the context of directory creation, resulting in no accurate coverage of the core function's role.",
                "The summary generically describes initialization and configuration but omits critical domain-specific details: it does not mention that the function creates a sysfs directory, the specific mode and flags set, or the start/add/finish calls for linking into sysfs. While loosely accurate about initializing a structure and conditionally returning it via an output pointer or cleaning up, the claims are overly generic (SAFE) and provide minimal insight. No direct inaccuracies (FATAL) are present, but the low-info, high-noise nature limits usefulness."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes a data structure, sets configuration fields, performs validation, atomically updates references, and returns either success with object or an error code.",
            "score": [
                0.5,
                0.2,
                0.4
            ],
            "reason": [
                "The summary correctly notes allocation and initialization of a data structure, setting configuration fields, and returning success or error, which align with the code. However, it inaccurately states that the function performs validation (no explicit validation logic exists) and atomically updates references (the code sequences sysfs_addrm_start/add_one/finish, but not in an atomic reference-update context). These inaccuracies reduce precision, with roughly half the claims being accurate.",
                "The summary omits the core domain-specific purpose of creating and linking a sysfs directory entry for a kobject, instead giving only generic implementation details. While it mentions allocation, initialization, and returning success or error codes, these are generic operations not specific to the source\u2019s main behavior, and there is no accurate claim describing the actual sysfs directory creation/linking. Secondary semantics such as mode setup, namespace handling, and branch behavior are also missing.",
                "The summary contains mostly generic claims such as allocation, initialization, configuration setting, and returning success or error, which are broadly accurate but provide low specific insight. However, it inaccurately adds 'performs validation', which is not present in the source code logic, representing noise rather than a fatal contradiction. No claim is a strong, specific GOLD detail, and the noise outweighs the minimal accurate content, leading to low net benefit."
            ]
        },
        "comment": {
            "summary": "Creates a directory entry in a configuration filesystem, ensuring it does not already exist and managing reference counts for the parent directory.",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly identifies that the function creates a directory entry in a special filesystem, which matches the sysfs context in the source code. However, it inaccurately claims that the function ensures the directory does not already exist and manages reference counts for the parent directory\u2014these behaviors are not present in the code. The code simply allocates a new dirent, initializes fields, links it to the parent, and returns an error if allocation or addition fails, without explicit existence checks or parent reference count handling. This results in less than half of the claims being accurate.",
                "The summary claims the function ensures the directory does not already exist and manages reference counts for the parent, but these behaviors are not seen in the source code, making them inaccurate. While it correctly states that a directory entry is created in a filesystem, it misidentifies it as a configuration filesystem and omits the specific core domain purpose of creating a sysfs directory entry with a given kobject, namespace, type, and name under a parent sysfs_dirent. It also misses other critical behaviors such as flag setting, namespace assignment, kobject linking, and the add/remove transaction pattern with error handling.",
                "The summary correctly states that the function creates a directory entry in a filesystem, which matches the code's behavior of allocating and linking a sysfs_dirent. However, it inaccurately adds that the function ensures the directory does not already exist and manages reference counts for the parent directory\u2014these checks and explicit reference count management are not present in the source. These are semantic claims about the core purpose that contradict the code, making them FATAL errors on the WHAT. The result is unusable for understanding the true primary behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582126582,
    "strip_function_name": "sub_FFFFFFFF813211F6",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813211F6(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  char v12; // r13\n  unsigned int v13; // ebx\n  __int64 v14; // rdx\n  unsigned int v15; // r12d\n  __int64 v16; // rax\n  __int64 v17; // r14\n  __int64 v18; // r14\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // eax\n  __int64 v22; // rdx\n\n  result = 4097LL;\n  if ( a1 )\n  {\n    result = 8LL;\n    v12 = *(_BYTE *)(a1 + 11);\n    if ( v12 )\n    {\n      result = sub_FFFFFFFF81323698(0LL, a2, a3);\n      v13 = result;\n      if ( !(_DWORD)result )\n      {\n        v14 = qword_FFFFFFFF81E9EC20;\n        v15 = 0;\n        v16 = qword_FFFFFFFF81E9EC20;\n        while ( v15 != dword_FFFFFFFF81E9EC28 )\n        {\n          v17 = v16;\n          a2 = v16;\n          v16 += 32LL;\n          v18 = v17 - qword_FFFFFFFF81E9EC20;\n          if ( v12 == *(_BYTE *)(v16 - 8) )\n          {\n            v13 = 8;\n            if ( *(_DWORD *)(a2 + 20) != 1413763908 )\n            {\n              v13 = 6;\n              if ( sub_FFFFFFFF8132088D(v15, a2, qword_FFFFFFFF81E9EC20) )\n              {\n                if ( qword_FFFFFFFF81E9E9D8 )\n                {\n                  a2 = *(_QWORD *)(qword_FFFFFFFF81E9EC20 + v18 + 8);\n                  qword_FFFFFFFF81E9E9D8(1LL, a2, qword_FFFFFFFF81E9E9D0);\n                }\n                v13 = sub_FFFFFFFF81320720(v15, a2, v14, a4, a5, a6, a7, v19, v20, a10, a11);\n                if ( !v13 )\n                {\n                  v21 = sub_FFFFFFFF813207F2(v15, a2, v14);\n                  a2 = 0LL;\n                  v13 = v21;\n                  sub_FFFFFFFF813208D0(v15, 0LL, v22);\n                }\n              }\n            }\n            break;\n          }\n          ++v15;\n        }\n        sub_FFFFFFFF8132371B(0LL, a2, v14);\n        return v13;\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "acpi_unload_parent_table",
    "decompiled_code": "__int64 __fastcall acpi_unload_parent_table(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  char v11; // r13\n  int v12; // r8d\n  int v13; // r9d\n  unsigned int v14; // ebx\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  unsigned int v17; // r12d\n  __int64 v18; // rax\n  __int64 v19; // r14\n  __int64 v20; // r14\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  unsigned int v23; // eax\n\n  result = 4097LL;\n  if ( a1 )\n  {\n    result = 8LL;\n    v11 = *(_BYTE *)(a1 + 11);\n    if ( v11 )\n    {\n      result = acpi_ut_acquire_mutex(0);\n      v14 = result;\n      if ( !(_DWORD)result )\n      {\n        v15 = acpi_gbl_root_table_list;\n        v16 = (unsigned int)dword_FFFFFFFF81E9EC28;\n        v17 = 0;\n        v18 = acpi_gbl_root_table_list;\n        while ( v17 != dword_FFFFFFFF81E9EC28 )\n        {\n          v19 = v18;\n          a2 = v18;\n          v18 += 32LL;\n          v20 = v19 - acpi_gbl_root_table_list;\n          if ( v11 == *(_BYTE *)(v18 - 8) )\n          {\n            v14 = 8;\n            if ( *(_DWORD *)(a2 + 20) != 1413763908 )\n            {\n              v14 = 6;\n              if ( acpi_tb_is_table_loaded(v17, a2) )\n              {\n                if ( acpi_gbl_table_handler )\n                {\n                  a2 = *(_QWORD *)(acpi_gbl_root_table_list + v20 + 8);\n                  a3 = acpi_gbl_table_handler(1LL, a2, acpi_gbl_table_handler_context);\n                }\n                v14 = acpi_tb_delete_namespace_by_owner(v17, a2, a3, a4, a5, a6, v21, v22, a9, a10);\n                if ( !v14 )\n                {\n                  v23 = acpi_tb_release_owner_id(v17, a2);\n                  a2 = 0LL;\n                  v14 = v23;\n                  acpi_tb_set_table_loaded_flag(v17, 0LL);\n                }\n              }\n            }\n            break;\n          }\n          ++v17;\n        }\n        acpi_ut_release_mutex(0, a2, v15, v16, v12, v13);\n        return v14;\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "acpi_status acpi_unload_parent_table(acpi_handle object)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, object);\n\tacpi_status status = AE_NOT_EXIST;\n\tacpi_owner_id owner_id;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_unload_parent_table);\n\n\t/* Parameter validation */\n\n\tif (!object) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t/*\n\t * The node owner_id is currently the same as the parent table ID.\n\t * However, this could change in the future.\n\t */\n\towner_id = node->owner_id;\n\tif (!owner_id) {\n\n\t\t/* owner_id==0 means DSDT is the owner. DSDT cannot be unloaded */\n\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t/* Must acquire the interpreter lock during this operation */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Find the table in the global table list */\n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\tif (owner_id != acpi_gbl_root_table_list.tables[i].owner_id) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Allow unload of SSDT and OEMx tables only. Do not allow unload\n\t\t * of the DSDT. No other types of tables should get here, since\n\t\t * only these types can contain AML and thus are the only types\n\t\t * that can create namespace objects.\n\t\t */\n\t\tif (ACPI_COMPARE_NAME\n\t\t    (acpi_gbl_root_table_list.tables[i].signature.ascii,\n\t\t     ACPI_SIG_DSDT)) {\n\t\t\tstatus = AE_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Ensure the table is actually loaded */\n\n\t\tif (!acpi_tb_is_table_loaded(i)) {\n\t\t\tstatus = AE_NOT_EXIST;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Invoke table handler if present */\n\n\t\tif (acpi_gbl_table_handler) {\n\t\t\t(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,\n\t\t\t\t\t\t     acpi_gbl_root_table_list.\n\t\t\t\t\t\t     tables[i].pointer,\n\t\t\t\t\t\t     acpi_gbl_table_handler_context);\n\t\t}\n\n\t\t/*\n\t\t * Delete all namespace objects owned by this table. Note that\n\t\t * these objects can appear anywhere in the namespace by virtue\n\t\t * of the AML \"Scope\" operator. Thus, we need to track ownership\n\t\t * by an ID, not simply a position within the hierarchy.\n\t\t */\n\t\tstatus = acpi_tb_delete_namespace_by_owner(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = acpi_tb_release_owner_id(i);\n\t\tacpi_tb_set_table_loaded_flag(i, FALSE);\n\t\tbreak;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\n\treturn_ACPI_STATUS(status);\n}",
    "comment": "Unloads ACPI tables by deleting namespace objects and calling the table handler, ensuring conditions to prevent unloading the DSDT are met.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Registers a new interface or reactivates an invalid one in the global list , ensuring unique interface names while managing mutexes and synchronization .\n",
    "cpbcs_sum": "Deletes a specified table from the ACPI table list, ensuring no duplicate tables exist.\n",
    "misum_sum": "Checks for active thermal trip points and manages state changes in the ACPI namespace, ensuring proper state management.\n",
    "decom_sum": "Processes an entry identified by a specific byte in a global table, performing validation and update callbacks with provided double parameters.",
    "cfg_sum": "Processes an input structure identified by a specific byte, validates and executes related handlers, and returns the final status code.",
    "work_score": {
        "decom": {
            "summary": "Processes an entry identified by a specific byte in a global table, performing validation and update callbacks with provided double parameters.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary is inaccurate because it describes processing an entry identified by a byte and using double parameters, which do not align with the source code. The source function operates on an ACPI namespace node, validates parameters, acquires a mutex, checks owner IDs, and unloads certain ACPI tables, but no byte indexing or double parameters are involved. None of the claims are accurate in describing the code's semantics.",
                "The summary is inaccurate and does not reflect the source code\u2019s core purpose or domain semantics. The function unloads a parent ACPI table linked to a namespace node, handling owner ID validation, restrictions on unloading DSDT, acquiring mutex locks, invoking unload handlers, deleting namespace objects, and updating table state. The summary incorrectly describes processing an entry by a byte, with double parameters and generic callbacks, none of which are present in the code, thus missing both the primary purpose and secondary behaviors.",
                "The summary contains entirely inaccurate claims about the function's semantics. It mentions processing an entry identified by a byte and performing callbacks with double parameters, none of which match the actual code. The source shows unloading an ACPI table by owner ID, handling only SSDT/OEMx tables, acquiring a mutex, invoking a table unload handler, and deleting namespace objects. This is a severe contradiction on the primary purpose and I/O, constituting a fatal error that renders the summary unusable."
            ]
        },
        "cfg": {
            "summary": "Processes an input structure identified by a specific byte, validates and executes related handlers, and returns the final status code.",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains generic and inaccurate statements not grounded in the source code semantics. It incorrectly describes the input as a structure identified by a specific byte, whereas the code takes an ACPI handle, converts it to a namespace node, and processes based on owner_id. It omits key specific behaviors such as preventing unload of DSDT, checking table load status, invoking a table handler, and deleting namespace objects. The claims fail to capture actual domain-specific logic, leading to low alignment.",
                "The summary omits the core purpose of unloading the parent ACPI table by owner ID, including restrictions for DSDT, lock acquisition, and namespace deletion. It inaccurately describes the input as a 'specific byte' rather than an ACPI handle, and lacks key secondary behaviors like table type checks, handler invocation, and mutex management. No [ACCURATE] claim in the summary captures the actual core domain action.",
                "The summary contains significant inaccuracies. It claims the function processes an input structure identified by a specific byte, which contradicts the source where the function operates on an ACPI handle cast to a namespace node and uses an owner_id, not a specific byte. It omits the core purpose of unloading an ACPI parent table, validation against DSDT unloading, mutex acquisition, and namespace cleanup. The description is both vague and misleading, with the main WHAT/FATAL error being misrepresentation of core I/O semantics, making it untrustworthy."
            ]
        },
        "comment": {
            "summary": "Unloads ACPI tables by deleting namespace objects and calling the table handler, ensuring conditions to prevent unloading the DSDT are met.",
            "score": [
                0.8,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states that the function unloads ACPI tables by deleting namespace objects and calling the table handler, and that it ensures conditions to prevent unloading the DSDT. These are specific and verifiable details aligned with the source code's behavior, though the summary omits other steps such as parameter validation, lock acquisition, and checks to confirm the table is loaded. The covered claims are accurate, but coverage is not exhaustive.",
                "The summary correctly captures the core action of unloading ACPI tables by deleting namespace objects and invoking the table handler, and mentions the restriction against unloading the DSDT, aligning with the source code's primary purpose. However, it omits important secondary details such as parameter validation, the requirement to acquire and release the interpreter mutex, checks for table existence, and handling of specific error codes. These omissions limit coverage of key behavior-critical semantics.",
                "The summary accurately notes that the function unloads ACPI tables by deleting namespace objects, invokes the table handler, and enforces constraints to prevent unloading the DSDT. These are directly supported by the code. However, it omits parameter validation, mutex acquisition/release, table type checks beyond DSDT, and the condition that only certain table types are allowed to unload. While the omissions reduce completeness, there are no false or irrelevant claims, so noise is minimal and the gain is moderate."
            ]
        }
    }
}
{
    "project_name": "bash",
    "function_addr": 823136,
    "strip_function_name": "_rl_dispatch_callback",
    "strip_decompiled_code": "__int64 __fastcall rl_dispatch_callback(__int64 a1)\n{\n  unsigned int v2; // edi\n  int v4; // ebp\n  __int64 v5; // rdi\n  int v6; // eax\n  unsigned int v7; // eax\n\n  if ( (*(_BYTE *)a1 & 1) != 0 )\n  {\n    v2 = *(_DWORD *)(a1 + 40);\n  }\n  else\n  {\n    v6 = sub_C7CE0(*(_DWORD *)(a1 + 12));\n    if ( v6 < 0 )\n      rl_abort_internal();\n    v7 = rl_dispatch_subseq((unsigned int)v6, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 4));\n    *(_DWORD *)a1 |= 1u;\n    v2 = v7;\n  }\n  if ( v2 == -3 )\n  {\n    if ( rl_caught_signal )\n      rl_signal_handler((unsigned int)rl_caught_signal);\n    goto LABEL_6;\n  }\n  v4 = sub_C8DB0(v2, *(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 12), *(_DWORD *)a1 & 2);\n  if ( rl_caught_signal )\n    rl_signal_handler((unsigned int)rl_caught_signal);\n  if ( v4 >= 0 )\n    goto LABEL_28;\n  if ( v4 != -1 )\n  {\n    if ( v4 == -3 )\n    {\nLABEL_6:\n      if ( rl_kscxt )\n        *(_DWORD *)(rl_kscxt + 40) = -3;\n      return 4294967293LL;\n    }\n    goto LABEL_21;\n  }\n  if ( (*(_BYTE *)a1 & 2) == 0 )\n  {\nLABEL_28:\n    while ( 1 )\n    {\n      v5 = rl_kscxt;\n      if ( !rl_kscxt )\n        break;\n      rl_kscxt = *(_QWORD *)(rl_kscxt + 32);\n      xfree(v5);\n    }\n    rl_readline_state &= ~0x200000uLL;\n    return (unsigned int)v4;\n  }\nLABEL_21:\n  rl_kscxt = *(_QWORD *)(a1 + 32);\n  if ( rl_kscxt )\n    *(_DWORD *)(rl_kscxt + 40) = v4;\n  xfree(a1);\n  return (unsigned int)v4;\n}\n",
    "function_name": "_rl_dispatch_callback",
    "decompiled_code": "int __fastcall rl_dispatch_callback(_rl_keyseq_cxt *cxt)\n{\n  int childval; // edi\n  int v4; // ebp\n  _rl_keyseq_cxt *v5; // rdi\n  int v6; // eax\n  int v7; // eax\n\n  if ( (cxt->flags & 1) != 0 )\n  {\n    childval = cxt->childval;\n  }\n  else\n  {\n    v6 = rl_subseq_getchar(cxt->okey);\n    if ( v6 < 0 )\n      rl_abort_internal();\n    v7 = rl_dispatch_subseq(v6, cxt->dmap, cxt->subseq_arg);\n    cxt->flags |= 1u;\n    childval = v7;\n  }\n  if ( childval == -3 )\n  {\n    if ( rl_caught_signal )\n      rl_signal_handler(rl_caught_signal);\n    goto LABEL_6;\n  }\n  v4 = rl_subseq_result(childval, cxt->oldmap, cxt->okey, cxt->flags & 2);\n  if ( rl_caught_signal )\n    rl_signal_handler(rl_caught_signal);\n  if ( v4 >= 0 )\n    goto LABEL_28;\n  if ( v4 != -1 )\n  {\n    if ( v4 == -3 )\n    {\nLABEL_6:\n      if ( rl_kscxt )\n        rl_kscxt->childval = -3;\n      return -3;\n    }\n    goto LABEL_21;\n  }\n  if ( (cxt->flags & 2) == 0 )\n  {\nLABEL_28:\n    while ( 1 )\n    {\n      v5 = rl_kscxt;\n      if ( !rl_kscxt )\n        break;\n      rl_kscxt = rl_kscxt->ocxt;\n      xfree(v5);\n    }\n    rl_readline_state &= ~0x200000uLL;\n    return v4;\n  }\nLABEL_21:\n  rl_kscxt = cxt->ocxt;\n  if ( rl_kscxt )\n    rl_kscxt->childval = v4;\n  xfree(cxt);\n  return v4;\n}\n",
    "source_code": "int\n_rl_dispatch_callback (_rl_keyseq_cxt *cxt)\n{\n  int nkey, r;\n\n  /* For now */\n  /* The first time this context is used, we want to read input and dispatch\n     on it.  When traversing the chain of contexts back `up', we want to use\n     the value from the next context down.  We're simulating recursion using\n     a chain of contexts. */\n  if ((cxt->flags & KSEQ_DISPATCHED) == 0)\n    {\n      nkey = _rl_subseq_getchar (cxt->okey);\n      if (nkey < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);\n      cxt->flags |= KSEQ_DISPATCHED;\n    }\n  else\n    r = cxt->childval;\n\n  /* For now */\n  if (r != -3)\t/* don't do this if we indicate there will be other matches */\n    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));\n\n  RL_CHECK_SIGNALS ();\n  /* We only treat values < 0 specially to simulate recursion. */\n  if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))\t/* success! or failure! */\n    {\n      _rl_keyseq_chain_dispose ();\n      RL_UNSETSTATE (RL_STATE_MULTIKEY);\n      return r;\n    }\n\n  if (r != -3)\t\t\t/* magic value that says we added to the chain */\n    _rl_kscxt = cxt->ocxt;\n  if (_rl_kscxt)\n    _rl_kscxt->childval = r;\n  if (r != -3)\n    _rl_keyseq_cxt_dispose (cxt);\n\n  return r;\n}",
    "comment": "Handles key sequence input and dispatches actions based on the context, managing recursion through context chaining and returning results based on input validity.",
    "hext5_sum": "get the index of a g++ global constructor or destructor from the symbol name.",
    "bint5_sum": "Dispatches a command sequence based on its state , handling subsequences and signals , while managing signal handlers and rescheduling as necessary .\n",
    "cpbcs_sum": "Processes a callback command by handling its arguments, managing state transitions and executing a callback function while stopping the input.\n",
    "misum_sum": "Handles fatal signals by managing signal handlers, updating signal handlers and ensuring the buffer is ready for the correct state.\n",
    "decom_sum": "Processes a readline input dispatch, handling subsequences, signals, and cleanup of context structures before returning an execution status code.",
    "cfg_sum": "Handles readline command dispatch, processes caught signals, updates context state, frees resources, and returns status or error codes based on execution results.",
    "work_score": {
        "decom": {
            "summary": "Processes a readline input dispatch, handling subsequences, signals, and cleanup of context structures before returning an execution status code.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function processes readline input dispatch and involves handling subsequences, signals, and cleanup of context structures before returning a status code, all of which are evident in the source code. While the description is somewhat generic and lacks detailed specifics such as conditional handling, recursion simulation, and key sequence management, it still aligns well with the actual function behavior, with no inaccurate claims.",
                "The summary correctly identifies that the function deals with readline input dispatch and mentions subsequences, signal handling, and cleanup, which aligns with the source code's core purpose of reading and dispatching key sequences within a context chain. However, it omits critical details about the branching logic, special values like -3, recursion simulation, and error conditions such as aborting on negative input, resulting in incomplete coverage of behavior-critical semantics.",
                "The summary correctly states the core function purpose of dispatching readline input and mentions handling subsequences, signals, and cleanup, all of which align with the source code. However, these claims are generic SAFE statements and lack specific details about the simulated recursion, key value handling, and magic return values present in the implementation. There is no FATAL inaccuracy, but the information gain is low due to absence of concrete GOLD-level insights."
            ]
        },
        "cfg": {
            "summary": "Handles readline command dispatch, processes caught signals, updates context state, frees resources, and returns status or error codes based on execution results.",
            "score": [
                0.9,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly identifies that the function handles command dispatch, checks signals, updates context state, frees resources, and returns status/error codes, all of which align with the source code. However, it is overly generic and omits specific key details such as the simulation of recursion via a chain of contexts, handling of magic value -3, and conditions for disposing contexts. While all claims are accurate, they lack granular specificity, making them mostly SAFE rather than GOLD.",
                "The summary generically describes command dispatch, signal handling, context updates, and resource cleanup, which are accurate but vague. It does not explicitly cover the core purpose\u2014the function reads a subsequence key from the context and dispatches it using a keymap, simulating recursion via a chain of contexts\u2014which is a key domain-specific operation in the source. While secondary aspects like signal processing and cleanup are mentioned, the absence of specific coverage of the primary key dispatch logic leaves the core purpose uncovered.",
                "The summary contains mostly generic SAFE claims such as handling command dispatch, processing signals, updating state, freeing resources, and returning status codes. These map broadly to the code\u2019s behavior, but offer little specific technical detail, providing low gain. There are no FATAL inaccuracies about the primary purpose or key I/O, and while the statements are accurate at a high level, they lack precision about dispatch sequencing, conditional paths, and simulated recursion. Noise is minimal, but the lack of domain-specific detail keeps the net benefit low."
            ]
        },
        "comment": {
            "summary": "Handles key sequence input and dispatches actions based on the context, managing recursion through context chaining and returning results based on input validity.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary captures the main functional behavior: handling key sequence input, dispatching based on context, and managing recursion via context chaining, which aligns with the source code\u2019s use of `_rl_subseq_getchar`, `_rl_dispatch_subseq`, and child context handling. However, it omits specific conditional flows such as the treatment of magic value `-3`, signal checking, and disposal of contexts/states, which are notable for accuracy. Most claims are accurate but generalized, with only minor omissions.",
                "The summary correctly identifies that the function handles key sequence input, dispatches actions based on context, and uses context chaining to simulate recursion, which aligns with the core purpose of reading a key, dispatching subsequence actions, and managing recursion via context chains. However, it omits several important secondary behaviors such as signal checking, special handling of the -3 magic value for matches, aborting on input errors, disposing of key sequence contexts and chains, and state management with RL_UNSETSTATE. These omissions reduce the completeness of coverage of critical branches and side effects.",
                "The summary correctly states that the function handles key sequence input, dispatches actions according to context, and manages recursion through context chaining, which aligns with the source code logic using KSEQ_DISPATCHED and child context values. It also accurately notes returning results based on input validity, reflecting checks on nkey and result values. These claims are broadly correct but generic, lacking mention of specific detailed behavior such as handling special result codes (-3), abort conditions, or signal checks. No contradictory or irrelevant content is present, but informational gain is low due to the generality."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5092624,
    "strip_function_name": "sub_4DB510",
    "strip_decompiled_code": "__int64 __fastcall sub_4DB510(char *s2, _DWORD *a2, int *a3, int *a4, int *a5, _DWORD *a6)\n{\n  __int64 v8; // rax\n  char *v9; // rbx\n  int *v10; // r14\n  int v11; // r15d\n  int v12; // eax\n  int v13; // eax\n  __int64 v15; // rdx\n  unsigned int v16; // [rsp+8h] [rbp-50h]\n\n  v8 = sub_4E19C0(1uLL, 0x400uLL);\n  if ( !v8 )\n    return 0xFFFFFFFFLL;\n  v9 = (char *)v8;\n  if ( dword_7713EC < 0 )\n  {\nLABEL_9:\n    v13 = sub_4F27F0(s2, a2, a3, a4, a5, a6);\n  }\n  else\n  {\n    v10 = (int *)&unk_783BE0;\n    v11 = 0;\n    while ( 1 )\n    {\n      if ( v10[56] >= 0 )\n      {\n        v12 = sub_4DB2B0((__int64)v10, v9);\n        if ( v12 < 0 )\n        {\n          v13 = 1;\n          goto LABEL_10;\n        }\n        if ( v12 )\n        {\n          v13 = strcmp(v9, s2);\n          if ( !v13 )\n            break;\n        }\n      }\n      ++v11;\n      v10 += 596;\n      if ( dword_7713EC < v11 )\n        goto LABEL_9;\n    }\n    v15 = 596LL * v11;\n    *a3 = dword_783BE8[v15];\n    *a4 = dword_783BF0[v15];\n    *a5 = dword_783BEC[v15];\n    *a6 = dword_783BF4[v15];\n    *a2 = *(_DWORD *)((char *)&unk_783BE4 + v15 * 4);\n    if ( *a3 >= 0 && *a4 >= 0 && *a5 >= 0 )\n      v13 = *a6 >= 0;\n  }\nLABEL_10:\n  v16 = v13;\n  free(v9);\n  return v16;\n}\n",
    "function_name": "burn_drive_obtain_scsi_adr",
    "decompiled_code": "__int64 __fastcall burn_drive_obtain_scsi_adr(\n        char *a1,\n        int *bus_no,\n        burn_drive *a3,\n        int *a4,\n        int *target_no,\n        int *lun_no)\n{\n  size_t v6; // rax\n  char *v9; // rax\n  char *v10; // rbx\n  burn_drive *v11; // r14\n  int v12; // r15d\n  int adr; // eax\n  int v14; // eax\n  unsigned int v16; // [rsp+8h] [rbp-50h]\n\n  v9 = (char *)burn_alloc_mem(v6, 1uLL, 0);\n  if ( !v9 )\n    return 0xFFFFFFFFLL;\n  v10 = v9;\n  if ( drivetop < 0 )\n  {\nLABEL_9:\n    v14 = sg_obtain_scsi_adr(a1, bus_no, &a3->drive_role, a4, target_no, lun_no);\n  }\n  else\n  {\n    v11 = drive_array;\n    v12 = 0;\n    while ( 1 )\n    {\n      if ( v11->global_index >= 0 )\n      {\n        adr = burn_drive_d_get_adr((__int64)v11, v10);\n        if ( adr < 0 )\n        {\n          v14 = 1;\n          goto LABEL_10;\n        }\n        if ( adr )\n        {\n          v14 = strcmp(v10, a1);\n          if ( !v14 )\n            break;\n        }\n      }\n      ++v12;\n      ++v11;\n      if ( drivetop < v12 )\n        goto LABEL_9;\n    }\n    a3->drive_role = drive_array[v12].host;\n    *a4 = drive_array[v12].channel;\n    *target_no = drive_array[v12].id;\n    *lun_no = drive_array[v12].lun;\n    *bus_no = drive_array[v12].bus_no;\n    if ( a3->drive_role >= 0 && *a4 >= 0 && *target_no >= 0 )\n      v14 = *lun_no >= 0;\n  }\nLABEL_10:\n  v16 = v14;\n  free(v10);\n  return v16;\n}\n",
    "source_code": "int burn_drive_obtain_scsi_adr(char *path,\n\t\t\t       int *bus_no, int *host_no, int *channel_no,\n\t\t\t       int *target_no, int *lun_no)\n{\n\tint ret, i;\n\tchar *adr = NULL;\n\n\tBURN_ALLOC_MEM(adr, char, BURN_DRIVE_ADR_LEN);\n\n\t/* open drives cannot be inquired by sg_obtain_scsi_adr() */\n\tfor (i = 0; i < drivetop + 1; i++) {\n\t\tif (drive_array[i].global_index < 0)\n\tcontinue;\n\t\tret = burn_drive_d_get_adr(&(drive_array[i]),adr);\n\t\tif (ret < 0)\n\t\t\t{ret = 1; goto ex;}\n\t\tif (ret == 0)\n\tcontinue;\n\t\tif (strcmp(adr, path) == 0) {\n\t\t\t*host_no = drive_array[i].host;\n\t\t\t*channel_no = drive_array[i].channel;\n\t\t\t*target_no = drive_array[i].id;\n\t\t\t*lun_no = drive_array[i].lun;\n\t\t\t*bus_no = drive_array[i].bus_no;\n\t\t\tif (*host_no < 0 || *channel_no < 0 ||\n\t\t\t    *target_no < 0 || *lun_no < 0)\n\t\t\t\t{ret = 0; goto ex;}\n\t\t\t{ret = 1; goto ex;}\n\t\t}\n\t}\n\n\tret = sg_obtain_scsi_adr(path, bus_no, host_no, channel_no,\n\t\t\t\t target_no, lun_no);\nex:;\n\tBURN_FREE_MEM(adr);\n\treturn ret;\n}",
    "comment": "Retrieves the SCSI address information for a specified drive path, utilizing both local and SCSI inquiry methods.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the media and session IDs of a drive based on its current profile and specified flags , returning results through output parameters .\n",
    "cpbcs_sum": "Reads data from a specified file descriptor, copies it to a buffer and handles potential errors during the read operation.\n",
    "misum_sum": "Reads the symbolic link Information Structure (CIS) from a drive, extracts a pattern and potential header data with support and memory allocation.\n",
    "decom_sum": "Searches a stored list for a matching string and retrieves associated integer parameters, or processes inputs directly if no list is defined.",
    "cfg_sum": "Searches a loaded table for a matching string, retrieves associated integer fields, validates them, and returns a status code after freeing allocated memory.",
    "work_score": {
        "decom": {
            "summary": "Searches a stored list for a matching string and retrieves associated integer parameters, or processes inputs directly if no list is defined.",
            "score": [
                0.5,
                0.3,
                0.5
            ],
            "reason": [
                "The summary contains two main claims: that the function searches a stored list for a matching string and retrieves associated integer parameters, and that it processes inputs directly if no list is defined. The first claim is accurate, as the code iterates through `drive_array` comparing `adr` to `path` and assigns multiple integer parameters when a match is found. The second claim is inaccurate; the code does not process inputs directly based on the absence of a list, but rather calls `sg_obtain_scsi_adr` after checking all entries. Given that only one of the two claims aligns with the actual function behavior, the proportion of accurate claims is about 50%, leading to a mixed reliability score.",
                "The summary vaguely mentions searching a stored list for a matching string and retrieving associated integers, aligning somewhat with the loop over drive_array and matching path. However, it omits core specifics: the purpose is to obtain SCSI address components for a drive path, including host, channel, target, LUN, and bus numbers, and to fall back to sg_obtain_scsi_adr when no match is found. The secondary details about return values, error checks, and memory allocation/free are entirely missing, and 'processes inputs directly if no list is defined' misrepresents the actual fallback logic in the code.",
                "The summary correctly notes that the function searches a stored list for a matching string and retrieves associated integer parameters, which aligns with iterating over drive_array to match a path and set bus/host/channel/target/lun numbers. However, it inaccurately states that processing occurs directly if no list is defined; in reality, the function falls back to sg_obtain_scsi_adr after exhausting the list, not dependent on whether the list exists. This is a low-impact inaccuracy (NOISE) and there are no severe FATAL errors, but the description lacks detail about key conditions and return values, giving only broad SAFE claims with limited insight."
            ]
        },
        "cfg": {
            "summary": "Searches a loaded table for a matching string, retrieves associated integer fields, validates them, and returns a status code after freeing allocated memory.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly notes that the function searches a table for a matching string, retrieves associated integers, performs validation, and frees allocated memory before returning a status code. These points align with the code\u2019s behavior: iterating over `drive_array`, comparing `adr` to `path`, assigning the integer fields, checking for negative values, freeing `adr`, and returning `ret`. While minor details such as the fallback `sg_obtain_scsi_adr` call are omitted, over 80% of the claims are accurate and relevant to the source code semantics.",
                "The summary correctly notes searching a table, matching a string, retrieving integer fields, validating them, and freeing memory, which aligns with the loop over drive_array, strcmp against the path, assignment of host/channel/target/lun/bus_no, validation checks, and BURN_FREE_MEM. However, it omits the core purpose of obtaining SCSI address details for a given path, including the fallback to sg_obtain_scsi_adr when not found in drive_array. Without explicitly covering the SCSI address retrieval domain operation, the core functionality is missing, yielding fairly complete secondary coverage but lacking the main domain-specific action.",
                "The summary correctly notes that the function searches a table of loaded drives for a matching string, retrieves associated integer fields, validates them, and frees allocated memory before returning a status code. These are accurate reflections of the source code's behavior, including its iteration over drive_array, matching against 'path', setting host/channel/target/lun/bus_no, validation of negative values, and freeing 'adr'. There are no incorrect or irrelevant claims, but the description is somewhat generic and omits implementation-specific details like falling back to sg_obtain_scsi_adr when no match is found. The overall gain is moderate due to its brevity."
            ]
        },
        "comment": {
            "summary": "Retrieves the SCSI address information for a specified drive path, utilizing both local and SCSI inquiry methods.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function retrieves SCSI address information for a specified drive path, which matches the core domain behavior seen in the source. Mentioning utilization of both local and SCSI inquiry methods aligns with the code's use of burn_drive_d_get_adr for local drives and sg_obtain_scsi_adr otherwise. While the summary is brief and omits certain details such as conditional checks and return value semantics, its claims are accurate and relevant to the code semantics with no contradictions.",
                "The summary correctly captures the core purpose of obtaining SCSI address information for a given drive path using local lookup and fallback to SCSI inquiry, which matches the code\u2019s primary functionality. However, it omits secondary details such as memory allocation and deallocation, iteration over drive_array, handling of open drives, comparison logic for matching paths, and error conditions for invalid address components. The coverage of important branches and constants is minimal, resulting in a thin description beyond the core.",
                "The summary contains a single accurate claim: the function retrieves SCSI address information for a given drive path. It also correctly mentions that both local data (from drive_array via burn_drive_d_get_adr) and a SCSI inquiry method (sg_obtain_scsi_adr) are used. There are no inaccurate or contradictory details, but the description is generic and lacks specifics about control flow, return values, or the conditions under which each method is used. The low detail means the gain is modest but noise is minimal."
            ]
        }
    }
}
{
    "project_name": "bool",
    "function_addr": 4201200,
    "strip_function_name": "sub_401AF0",
    "strip_decompiled_code": "__int64 __fastcall sub_401AF0(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 result; // rax\n  __int64 v3; // rax\n  bool v4; // zf\n  __int64 v5; // rbx\n  __int64 v6; // rax\n  int v7; // r13d\n  __int64 v8; // rbp\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  __int64 v12; // r14\n\n  sub_403DC0();\n  qword_608860 = sub_403E20(128LL);\n  *(_DWORD *)(qword_608860 + 104) = sub_402820(a1);\n  v1 = qword_608860;\n  result = *(unsigned int *)(qword_608860 + 104);\n  if ( (_DWORD)result )\n  {\n    v3 = sub_403E20((unsigned int)(qword_608848 + 17));\n    v4 = (byte_608858 & 4) == 0;\n    *(_QWORD *)(v1 + 96) = v3;\n    if ( v4 )\n    {\n      v5 = qword_608860;\n      v6 = sub_403E20((unsigned int)(8 * *(_DWORD *)(qword_608860 + 104)));\n      v7 = dword_608850;\n      *(_QWORD *)(v5 + 88) = v6;\n      if ( !v7 )\n        v7 = 1;\n      result = *(unsigned int *)(qword_608860 + 104);\n      if ( (int)result > 0 )\n      {\n        v8 = 0LL;\n        do\n        {\n          v9 = sub_403E20((unsigned int)(8 * v7));\n          v10 = v9;\n          if ( v7 > 0 )\n          {\n            v11 = 8LL * (unsigned int)(v7 - 1) + 8 + v9;\n            v12 = v9;\n            do\n            {\n              v12 += 8LL;\n              *(_QWORD *)(v12 - 8) = sub_403E20((unsigned int)(qword_608848 + 17));\n            }\n            while ( v11 != v12 );\n          }\n          result = *(unsigned int *)(qword_608860 + 104);\n          *(_QWORD *)(*(_QWORD *)(qword_608860 + 88) + 8 * v8++) = v10;\n        }\n        while ( (int)result > (int)v8 );\n      }\n    }\n    else\n    {\n      return *(unsigned int *)(qword_608860 + 104);\n    }\n  }\n  return result;\n}\n",
    "function_name": "context_init",
    "decompiled_code": "__int64 __fastcall context_init(char *a1)\n{\n  context *v1; // rbx\n  __int64 result; // rax\n  line *v3; // rax\n  bool v4; // zf\n  context *v5; // rbx\n  line ***v6; // rax\n  signed int occurrences; // r13d\n  __int64 v8; // rbp\n  line **v9; // rax\n  line **v10; // r12\n  line **v11; // rbx\n  line **v12; // r14\n\n  mem_init();\n  context_0 = (context *)mem_alloc(128);\n  context_0->num_pat = expr_init(a1);\n  v1 = context_0;\n  result = (unsigned int)context_0->num_pat;\n  if ( (_DWORD)result )\n  {\n    v3 = (line *)mem_alloc(opt.context + 17);\n    v4 = (*((_BYTE *)&opt + 24) & 4) == 0;\n    v1->tmp = v3;\n    if ( v4 )\n    {\n      v5 = context_0;\n      v6 = (line ***)mem_alloc(8 * context_0->num_pat);\n      occurrences = opt.occurrences;\n      v5->lines = v6;\n      if ( !occurrences )\n        occurrences = 1;\n      result = (unsigned int)context_0->num_pat;\n      if ( (int)result > 0 )\n      {\n        v8 = 0LL;\n        do\n        {\n          v9 = (line **)mem_alloc(8 * occurrences);\n          v10 = v9;\n          if ( occurrences > 0 )\n          {\n            v11 = &v9[(unsigned int)(occurrences - 1) + 1];\n            v12 = v9;\n            do\n              *v12++ = (line *)mem_alloc(opt.context + 17);\n            while ( v11 != v12 );\n          }\n          result = (unsigned int)context_0->num_pat;\n          context_0->lines[v8++] = v10;\n        }\n        while ( (int)result > (int)v8 );\n      }\n    }\n    else\n    {\n      return (unsigned int)context_0->num_pat;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint\ncontext_init (char *str)\n{\n  mem_init ();\n  context = mem_alloc (sizeof (struct context));\n  context->num_pat = expr_init (str);\n  if (!context->num_pat)\n    return 0;\n\n  context->tmp = mem_alloc (sizeof (struct line) - sizeof (char[4])\n      + opt.context + 1);\n\n  if (!opt.out_quiet)\n    {\n      register int i, j, occurrences;\n      struct line **line;\n\n      context->lines = mem_alloc (context->num_pat\n\t  * sizeof (struct line **));\n      occurrences = opt.occurrences ? opt.occurrences : 1;\n\n      for (i = 0; i < context->num_pat; i++)\n\t{\n\t  line = mem_alloc (occurrences * sizeof (struct line *));\n\t  for (j = 0; j < occurrences; j++)\n\t    line[j] = mem_alloc (sizeof (struct line) - sizeof (char[4])\n\t\t+ opt.context + 1);\n\n\t  context->lines[i] = line;\n\t}\n    }\n\n  return context->num_pat;\n}",
    "comment": "Initializes the context structure, allocating memory for patterns and lines based on given input and options, and returns the number of patterns.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes a new file pattern by allocating memory , extracting matches , and inserting it into a pattern list while handling errors appropriately .\n",
    "cpbcs_sum": "Copies the current number of history chains to a new document while handling potential file size limits and ensuring proper memory management.\n",
    "misum_sum": "Copies the contents of a `format_arg_list`, to a new destination file, marking the result as needed, and handling errors appropriately.\n",
    "decom_sum": "Allocates and initializes a multi-level pointer structure based on the given parameter and global settings, preparing nested buffers for subsequent processing.",
    "cfg_sum": "Allocates and initializes nested memory structures based on input parameters and configuration flags, updating global state before returning a computed status code.",
    "work_score": {
        "decom": {
            "summary": "Allocates and initializes a multi-level pointer structure based on the given parameter and global settings, preparing nested buffers for subsequent processing.",
            "score": [
                0.9,
                0.4,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function allocates and initializes a multi-level pointer structure based on input and global settings, and prepares nested buffers, which aligns with the code\u2019s use of mem_alloc for the context structure, context->lines arrays, and nested line buffers. It does omit some specifics, such as conditional allocation depending on opt.out_quiet and handling of occurrences, but the described behavior is broadly accurate and relevant to the code semantics. Nearly all claims match the source code.",
                "The summary correctly notes allocation and initialization of a multi-level pointer structure influenced by a parameter and global settings, which matches the function's operations on context and its lines arrays. However, it fails to explicitly cover the core primary purpose\u2014initializing the context structure with patterns from the input string via expr_init and allocating per-pattern buffers when output is not quiet\u2014thus missing key conditional logic and detailed behavior. Secondary coverage is also limited, with no mention of pattern count handling, error return on failure, or occurrences-based allocation.",
                "The summary correctly captures the general idea of allocating and initializing structures based on input parameters and global settings, but it is very broad. It omits specific, high-value details present in the code, such as the initialization of `context->num_pat` via `expr_init`, conditional allocation based on `opt.out_quiet`, and the exact nested allocation logic tied to `opt.occurrences` and `opt.context`. No claims are outright false, but the generic phrasing makes the gain low and the omission of code-specific mechanics reduces usefulness."
            ]
        },
        "cfg": {
            "summary": "Allocates and initializes nested memory structures based on input parameters and configuration flags, updating global state before returning a computed status code.",
            "score": [
                0.9,
                0.4,
                0.5
            ],
            "reason": [
                "The summary correctly captures that the function allocates and initializes nested memory structures, uses input parameters and configuration flags, updates a global state (`context`), and returns a computed value (`context->num_pat`). All these points align with the source code\u2019s behavior and do not introduce incorrect or unrelated claims, indicating a high proportion of accurate statements.",
                "The summary correctly notes that the function allocates and initializes memory structures and uses configuration flags, which aligns with the code's behavior, making these claims accurate. However, the core primary purpose\u2014initializing the global 'context' structure by setting its num_pat from expr_init on the input and conditionally allocating nested line buffers\u2014is not stated with sufficient domain-specific detail. The description is too generic to capture the key pattern count initialization and conditional line allocation logic, and it omits mention of branches, specific structure fields, and constants used.",
                "The summary captures the general idea that the function allocates and initializes memory based on input parameters and configuration flags, and updates global state before returning a value. These are generic but accurate descriptions (SAFE), with no evident contradictions to the source code. However, the claims are broad and do not detail key specifics such as the allocation pattern for 'context->lines', the role of 'occurrences', or the exact meaning of the returned value. The low level of detail limits the gain, and while there is no FATAL error, the positive value is modest."
            ]
        },
        "comment": {
            "summary": "Initializes the context structure, allocating memory for patterns and lines based on given input and options, and returns the number of patterns.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function initializes a context structure, allocates memory for patterns and lines using provided input and options, and returns the number of patterns. These points align with the source code behavior, with no contradictions or irrelevant claims present, indicating nearly full accuracy.",
                "The summary accurately captures the core purpose of the function: initializing a context structure, allocating memory for patterns and associated lines based on input and options, and returning the number of patterns. However, it omits secondary details such as the call to mem_init, handling of the case when expr_init fails (returning 0), conditional allocation depending on opt.out_quiet, calculation of occurrences from opt.occurrences, and the specific allocation structure for context->tmp and context->lines. These omissions limit coverage of critical branching and memory allocation nuances.",
                "The summary accurately captures the primary purpose of the function: initializing the context structure, allocating memory for patterns and lines based on input and options, and returning the number of patterns. These are specific and correct reflections of the source code's behavior, with no contradictory or noisy claims. While the description is concise and misses some lower-level allocation details, it correctly addresses key I/O and side effects with minimal noise."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 226656,
    "strip_function_name": "ngx_proxy_protocol_write",
    "strip_decompiled_code": "char *__fastcall ngx_proxy_protocol_write(\n        __int64 a1,\n        __int64 a2,\n        char *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int16 v12; // ax\n  char *v13; // rbx\n  char *v14; // rbx\n  char *v15; // r13\n  unsigned __int16 port; // ax\n\n  if ( (__int64)&a3[-a2] <= 106 )\n    return 0LL;\n  if ( ngx_connection_local_sockaddr(a1, 0LL, 0LL, a4, a5, a6, a7, a8, a9, a10, a11) )\n    return 0LL;\n  v12 = **(_WORD **)(a1 + 104);\n  if ( v12 == 2 )\n  {\n    qmemcpy((void *)a2, \"PROXY TCP4 \", 11);\n    v13 = (char *)(a2 + 11);\n    goto LABEL_6;\n  }\n  if ( v12 == 10 )\n  {\n    qmemcpy((void *)a2, \"PROXY TCP6 \", 11);\n    v13 = (char *)(a2 + 11);\nLABEL_6:\n    v14 = &v13[ngx_sock_ntop(*(__int16 **)(a1 + 104), *(_DWORD *)(a1 + 112), v13, a3 - v13, 0LL)];\n    *v14 = 32;\n    v15 = &v14[ngx_sock_ntop(*(__int16 **)(a1 + 168), *(_DWORD *)(a1 + 176), v14 + 1, a3 - (v14 + 1), 0LL) + 1];\n    LOWORD(v14) = ngx_inet_get_port(*(_WORD **)(a1 + 104));\n    port = ngx_inet_get_port(*(_WORD **)(a1 + 168));\n    return ngx_slprintf(v15, a3, \" %ui %ui\\r\\n\", (unsigned __int16)v14, port);\n  }\n  *(_BYTE *)(a2 + 14) = 10;\n  qmemcpy((void *)a2, \"PROXY UNKNOW\", 12);\n  *(_WORD *)(a2 + 12) = 3406;\n  return (char *)(a2 + 15);\n}\n",
    "function_name": "ngx_proxy_protocol_write",
    "decompiled_code": "u_char *__fastcall ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n{\n  sa_family_t sa_family; // ax\n  u_char *v5; // rbx\n  u_char *v6; // rbx\n  u_char *v7; // r13\n  in_port_t port; // ax\n\n  if ( last - buf <= 106 )\n    return 0LL;\n  if ( ngx_connection_local_sockaddr(c, 0LL, 0LL) )\n    return 0LL;\n  sa_family = c->sockaddr->sa_family;\n  if ( sa_family == 2 )\n  {\n    qmemcpy(buf, \"PROXY TCP4 \", 11);\n    v5 = buf + 11;\n    goto LABEL_6;\n  }\n  if ( sa_family == 10 )\n  {\n    qmemcpy(buf, \"PROXY TCP6 \", 11);\n    v5 = buf + 11;\nLABEL_6:\n    v6 = &v5[ngx_sock_ntop(c->sockaddr, c->socklen, v5, last - v5, 0LL)];\n    *v6 = 32;\n    v7 = &v6[ngx_sock_ntop(c->local_sockaddr, c->local_socklen, v6 + 1, last - (v6 + 1), 0LL) + 1];\n    LOWORD(v6) = ngx_inet_get_port(c->sockaddr);\n    port = ngx_inet_get_port(c->local_sockaddr);\n    return ngx_slprintf(v7, last, \" %ui %ui\\r\\n\", (unsigned __int16)v6, port);\n  }\n  buf[14] = 10;\n  qmemcpy(buf, \"PROXY UNKNOW\", 12);\n  *((_WORD *)buf + 6) = 3406;\n  return buf + 15;\n}\n",
    "source_code": "\n\nu_char *\nngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n{\n    ngx_uint_t  port, lport;\n\n    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {\n        return NULL;\n    }\n\n    if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n        return NULL;\n    }\n\n    switch (c->sockaddr->sa_family) {\n\n    case AF_INET:\n        buf = ngx_cpymem(buf, \"PROXY TCP4 \", sizeof(\"PROXY TCP4 \") - 1);\n        break;\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        buf = ngx_cpymem(buf, \"PROXY TCP6 \", sizeof(\"PROXY TCP6 \") - 1);\n        break;\n#endif\n\n    default:\n        return ngx_cpymem(buf, \"PROXY UNKNOWN\" CRLF,\n                          sizeof(\"PROXY UNKNOWN\" CRLF) - 1);\n    }\n\n    buf += ngx_sock_ntop(c->sockaddr, c->socklen, buf, last - buf, 0);\n\n    *buf++ = ' ';\n\n    buf += ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, last - buf,\n                         0);\n\n    port = ngx_inet_get_port(c->sockaddr);\n    lport = ngx_inet_get_port(c->local_sockaddr);\n\n    return ngx_slprintf(buf, last, \" %ui %ui\" CRLF, port, lport);\n}",
    "comment": "Constructs and writes a PROXY protocol header, including client and server IP addresses and ports, to the provided buffer.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Formats and writes the PROXY protocol header to a connection based on its address and port , handling both IPv4 and IPv6 cases .\n",
    "cpbcs_sum": "Writes data to a buffer of data from a socket, handling both single and asynchronous operations accordingly.\n",
    "misum_sum": "Handles TCP connections to a specified address and port, managing retransmission states and sending a packet if the address is not a TCP connection.\n",
    "decom_sum": "Builds and writes a PROXY protocol header with source and destination IPs and ports for TCP4, TCP6, or UNKNOWN connections.",
    "cfg_sum": "Formats and writes a PROXY protocol header with TCP4/TCP6 source and destination addresses and ports, returning zero if validation or address retrieval fails.",
    "work_score": {
        "decom": {
            "summary": "Builds and writes a PROXY protocol header with source and destination IPs and ports for TCP4, TCP6, or UNKNOWN connections.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly states that the function builds and writes a PROXY protocol header including source and destination IPs and ports, and it captures the conditional handling for TCP4, TCP6, or UNKNOWN based on the socket family. All these details align with the source code's logic and behavior, with no contradictory or irrelevant claims present.",
                "The summary accurately captures the core purpose of the function, which is to build and write a PROXY protocol header for TCP4, TCP6, or UNKNOWN connections including source and destination IPs and ports. This matches the specific domain effect in the code. However, it omits secondary behavior-critical details such as buffer size checks, error handling when retrieving local socket address, handling of default cases with 'PROXY UNKNOWN', and use of specific Nginx utility functions for address/port formatting. Coverage is good on the core but lacks breadth on these additional semantics.",
                "The summary correctly identifies the primary purpose as constructing and writing a PROXY protocol header and notes inclusion of source and destination IPs and ports, as well as handling TCP4, TCP6, and UNKNOWN cases. These are accurate and specific reflections of the source code\u2019s core logic. There is no contradictory or irrelevant information, and noise is minimal, yielding a strong net benefit from precise domain-semantic detail."
            ]
        },
        "cfg": {
            "summary": "Formats and writes a PROXY protocol header with TCP4/TCP6 source and destination addresses and ports, returning zero if validation or address retrieval fails.",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function formats and writes a PROXY protocol header with TCP4/TCP6 addresses and ports, which matches the source code\u2019s handling of AF_INET and AF_INET6 cases and the inclusion of both source and destination addresses and ports. However, it inaccurately claims that the function returns zero on failure; in reality, it returns NULL or an alternate string for 'UNKNOWN'. This contradiction lowers the proportion of accurate claims, though the rest of the description is mostly aligned.",
                "The summary captures the core purpose of formatting and writing a PROXY protocol header with TCP4/TCP6 source and destination addresses and ports, which matches the specific domain action in the code. However, it inaccurately states that the function returns zero on failure, whereas the code returns NULL. It omits mention of handling unknown address families, the exact buffer space check, and the steps for obtaining and writing both addresses. Secondary coverage is minimal and contains an incorrect detail, reducing the overall alignment.",
                "The summary correctly states that the function formats and writes a PROXY protocol header including TCP4/TCP6 addresses and ports, which matches the code's behavior. However, it inaccurately claims the function returns zero on validation or address retrieval failure; the actual implementation returns NULL in such cases. This is a FATAL in describing the core return value behavior (key I/O). Other details are mostly accurate but the primary FATAL error on return type semantics severely undermines trustworthiness."
            ]
        },
        "comment": {
            "summary": "Constructs and writes a PROXY protocol header, including client and server IP addresses and ports, to the provided buffer.",
            "score": [
                1.0,
                0.6,
                0.7
            ],
            "reason": [
                "The summary states that the function constructs and writes a PROXY protocol header with client and server IP addresses and ports to a buffer. This aligns well with the source code, which builds a header starting with a PROXY TCP4/TCP6/UNKNOWN prefix, then appends client and server addresses via ngx_sock_ntop, followed by their ports using ngx_inet_get_port, and writes this to the provided buffer. The claim is specific, verifiable from the code, and accurate, with no evident inaccuracies or irrelevant information.",
                "The summary correctly identifies that the function constructs and writes a PROXY protocol header and includes client/server IP addresses and ports, matching the core domain action in the source code. However, it omits key secondary details such as buffer size checks, handling of address families (IPv4, IPv6, unknown), and early returns on errors, leading to incomplete coverage of the behavior-critical semantics.",
                "The summary correctly describes the primary purpose of the function: constructing and writing a PROXY protocol header with client and server IPs and ports to a buffer. This matches the source code\u2019s behavior, which uses the appropriate PROXY TCP version keywords, writes both remote and local addresses, and appends their ports. There are no inaccurate claims and no extraneous noise, but the claim is generic with low detail on conditional handling (e.g., AF_INET6, UNKNOWN cases), making the gain modest."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580876272,
    "strip_function_name": "sub_FFFFFFFF811EFDF0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811EFDF0(\n        __int64 a1,\n        unsigned __int64 a2,\n        unsigned int a3,\n        unsigned int a4,\n        volatile signed __int8 *a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  unsigned int v16; // eax\n  int v17; // r8d\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned __int64 v21; // rax\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  __int64 result; // rax\n  unsigned __int64 v25; // [rsp+0h] [rbp-58h]\n  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a4 >= a3 )\n  {\n    v16 = sub_FFFFFFFF811AFDD0(a1, (__int64)v26, a6, a7, a8, a9, a10, a11, a12, a13);\n    if ( !v16 )\n      goto LABEL_3;\nLABEL_10:\n    sub_FFFFFFFF811CA2C0(\n      *(_QWORD *)(a1 + 40),\n      (__int64)\"ext4_write_inline_data_end\",\n      734,\n      v16,\n      v17,\n      v18,\n      a6,\n      a7,\n      a8,\n      a9,\n      v19,\n      v20,\n      a12,\n      a13);\n    return 0LL;\n  }\n  if ( (*(_QWORD *)a5 & 8) == 0 )\n    return 0LL;\n  v16 = sub_FFFFFFFF811AFDD0(a1, (__int64)v26, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( v16 )\n    goto LABEL_10;\nLABEL_3:\n  sub_FFFFFFFF8178FDC0(a1 - 88);\n  if ( (*(_QWORD *)(a1 - 96) & 0x10000000) == 0 || !*(_WORD *)(a1 + 678) )\n    BUG();\n  v21 = __readgsqword(0xA760u) - 8152;\n  ++*(_DWORD *)(v21 + 28);\n  v25 = v21;\n  sub_FFFFFFFF811EF1C0(\n    (unsigned __int16 *)a1,\n    v26,\n    ((__int64)(a5 + 0x160000000000LL) >> 6 << 12) - 0x780000000000LL,\n    a2,\n    a3);\n  --*(_DWORD *)(v25 + 28);\n  _InterlockedOr8(a5, 8u);\n  _InterlockedAnd8(a5, 0xEFu);\n  sub_FFFFFFFF810644C0((volatile signed __int64 *)(a1 - 88));\n  result = a4;\n  if ( v26[0] )\n  {\n    sub_FFFFFFFF81163E20(v26[0], a6, a7, a8, a9, v22, v23, a12, a13);\n    return a4;\n  }\n  return result;\n}\n",
    "function_name": "ext4_write_inline_data_end",
    "decompiled_code": "__int64 __fastcall ext4_write_inline_data_end(\n        __int64 a1,\n        unsigned __int64 a2,\n        unsigned int a3,\n        unsigned int a4,\n        volatile signed __int8 *a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  int inode_loc; // eax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  unsigned __int64 v19; // rax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 result; // rax\n  unsigned __int64 v23; // [rsp+0h] [rbp-58h]\n  __int64 v24[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a4 >= a3 )\n  {\n    inode_loc = ext4_get_inode_loc(a1, (__int64)v24, a6, a7, a8, a9, a10, a11, a12, a13);\n    if ( !inode_loc )\n      goto LABEL_3;\nLABEL_10:\n    _ext4_std_error(\n      *(_QWORD *)(a1 + 40),\n      \"ext4_write_inline_data_end\",\n      0x2DEu,\n      inode_loc,\n      a6,\n      a7,\n      a8,\n      a9,\n      v17,\n      v18,\n      a12,\n      a13);\n    return 0LL;\n  }\n  if ( (*(_QWORD *)a5 & 8) == 0 )\n    return 0LL;\n  inode_loc = ext4_get_inode_loc(a1, (__int64)v24, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( inode_loc )\n    goto LABEL_10;\nLABEL_3:\n  down_write((volatile signed __int64 *)(a1 - 88));\n  if ( (*(_QWORD *)(a1 - 96) & 0x10000000) == 0 || !*(_WORD *)(a1 + 678) )\n    BUG();\n  v19 = __readgsqword(0xA760u) - 8152;\n  ++*(_DWORD *)(v19 + 28);\n  v23 = v19;\n  ext4_write_inline_data(\n    (unsigned __int16 *)a1,\n    v24,\n    ((__int64)(a5 + 0x160000000000LL) >> 6 << 12) - 0x780000000000LL,\n    a2,\n    a3);\n  --*(_DWORD *)(v23 + 28);\n  _InterlockedOr8(a5, 8u);\n  _InterlockedAnd8(a5, 0xEFu);\n  up_write((volatile signed __int64 *)(a1 - 88), (__int64)v24);\n  result = a4;\n  if ( v24[0] )\n  {\n    _brelse(v24[0], a6, a7, a8, a9, v20, v21, a12, a13);\n    return a4;\n  }\n  return result;\n}\n",
    "source_code": "\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
    "comment": "Writes inline data to the inode's page, marking it as up-to-date and clearing its dirty state after successfully copying the specified length.",
    "hext5_sum": "dump the symbol table.",
    "bint5_sum": "Reads inline data from an inode into a buffer , ensuring the requested length does not exceed the inode 's inline size .\n",
    "cpbcs_sum": "Writes inline data to a journaled inode by validating write pointer and ensuring the buffer is not empty before returning the write result.\n",
    "misum_sum": "Writes inline data to a journal, ensuring the inode size consistency and updating the buffer's flags accordingly.\n",
    "decom_sum": "Finalizes and commits inline data writes in the ext4 filesystem, performing validation, locking, flag updates, and error logging.",
    "cfg_sum": "Handles inline data write in ext4 filesystem, validating conditions, updating counters, performing write operations, and logging completion status.",
    "work_score": {
        "decom": {
            "summary": "Finalizes and commits inline data writes in the ext4 filesystem, performing validation, locking, flag updates, and error logging.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary includes accurate and relevant claims: it describes finalizing inline data writes, validation checks (copied length vs PageUptodate), locking via xattr_sem, flag updates like SetPageUptodate and ClearPageDirty, and error logging with ext4_std_error. These align with the source code\u2019s operations without introducing incorrect details, making the coverage precise and domain-specific.",
                "The summary correctly identifies that the function deals with finalizing inline data writes in ext4 and mentions validation, locking, flag updates, and error logging, which are all consistent with the source. However, it fails to explicitly cover the core behavior with concrete detail \u2014 namely mapping the page, writing inline data at a specific offset and length, and handling partial writes due to uptodate checks or inode location errors. The coverage of secondary semantics is minimal and lacks specifics about memory mapping, clearing PageDirty, and branch handling.",
                "The summary correctly identifies the primary purpose of the function as finalizing inline data writes in ext4 and notes generic operations like validation, locking, updating flags, and error logging. These match the code, which validates 'copied' vs 'len', acquires 'xattr_sem', writes inline data, sets page uptodate, clears dirty flag, and logs errors. However, the claims are broad SAFE statements with low specificity and lack mention of critical I/O details such as handling of 'copied' when errors occur or mapping/unmapping the page. No inaccurate or contradictory claims are present, but the gain is low due to the absence of precise GOLD details."
            ]
        },
        "cfg": {
            "summary": "Handles inline data write in ext4 filesystem, validating conditions, updating counters, performing write operations, and logging completion status.",
            "score": [
                0.5,
                0.5,
                0.4
            ],
            "reason": [
                "The summary captures the general purpose of handling inline data writes in ext4, which aligns with the source code\u2019s write operations and condition checks. However, it introduces inaccurate or unsupported details such as 'updating counters' and 'logging completion status,' which are not present in the function. The summary is mostly generic and misses specific behaviors like acquiring locks, mapping pages, and error handling paths, leading to a mix of accurate and inaccurate claims.",
                "The summary correctly notes that the function handles inline data writes in the ext4 filesystem, which covers the core purpose of writing inline data for an inode. However, it inaccurately mentions 'updating counters' and 'logging completion status', which do not appear in the source code. It omits important secondary behaviors such as error handling via ext4_std_error, the use of xattr_sem locking, kmap/kunmap operations, marking the page uptodate, clearing the dirty flag, and releasing the buffer head. Overall coverage of core is present but secondary detail is weak and partly incorrect.",
                "The summary contains mostly generic and low-information claims such as handling inline data writes, validating conditions, and performing write operations. However, it inaccurately mentions 'updating counters' and 'logging completion status,' which are not present in the source code. These are NOISE rather than FATAL errors, but they notably misrepresent behavior. While the primary purpose of writing inline data is correctly mentioned, the lack of specifics like semaphore handling, error processing, and page state updates, coupled with the presence of inaccurate claims, results in low net benefit."
            ]
        },
        "comment": {
            "summary": "Writes inline data to the inode's page, marking it as up-to-date and clearing its dirty state after successfully copying the specified length.",
            "score": [
                0.6,
                0.6,
                0.6
            ],
            "reason": [
                "The summary captures the core behavior of writing inline data to the inode's page and the post-write actions of marking it up-to-date and clearing the dirty state, which align with the function's semantics. However, it omits important conditional checks such as early exits when 'copied' is less than 'len' and when 'ext4_get_inode_loc' fails, as well as the locking and mapping steps. These omissions mean the summary is only partially accurate, missing key operational details.",
                "The summary correctly identifies that the function writes inline data to an inode's page, marks it up-to-date, and clears the dirty state, which matches the core purpose and critical side effects in the code. However, it omits important conditional and error-handling logic\u2014such as checks for partial writes, page validity, acquisition/release of xattr_sem, inode location retrieval, and error handling\u2014that are also key aspects of the function's behavior.",
                "The summary accurately describes the core behavior of writing inline data, marking the page up-to-date, and clearing the dirty state, which aligns with the source code. However, it omits key conditional logic such as cases where 'copied < len', handling of PageUptodate checks, and error handling from ext4_get_inode_loc. These omissions reduce completeness but there are no outright contradictions, so the worst failure mode is noise from missing specific details. Gain is moderate, with some domain-specific accuracy but lacking full coverage of flow and edge cases."
            ]
        }
    }
}
{
    "project_name": "lua",
    "function_addr": 79888,
    "strip_function_name": "sub_13810",
    "strip_decompiled_code": "void __fastcall sub_13810(__int64 a1, int a2)\n{\n  __int64 v3; // rbp\n  int v4; // r10d\n  __int64 *v5; // rdi\n  __int64 *v6; // r9\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // rax\n\n  v3 = *(_QWORD *)(a1 + 24);\n  v4 = *(_DWORD *)(v3 + 60);\n  if ( v4 < a2 )\n  {\n    v10 = sub_ECF0(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n    v4 = *(_DWORD *)(v3 + 60);\n    *(_QWORD *)(v3 + 48) = v10;\n    if ( a2 > v4 )\n    {\n      v11 = (_QWORD *)(v10 + 8LL * v4);\n      v12 = v10 + 8 * (v4 + (unsigned __int64)(unsigned int)(a2 - 1 - v4)) + 8;\n      do\n        *v11++ = 0LL;\n      while ( v11 != (_QWORD *)v12 );\n    }\n  }\n  if ( v4 > 0 )\n  {\n    v5 = *(__int64 **)(v3 + 48);\n    v6 = v5;\n    do\n    {\n      v7 = *v6;\n      *v6 = 0LL;\n      if ( v7 )\n      {\n        do\n        {\n          v8 = *(_QWORD *)(v7 + 16);\n          v9 = &v5[*(_DWORD *)(v7 + 12) & (unsigned int)(a2 - 1)];\n          *(_QWORD *)(v7 + 16) = *v9;\n          *v9 = v7;\n          v7 = v8;\n        }\n        while ( v8 );\n      }\n      ++v6;\n    }\n    while ( &v5[(unsigned int)(v4 - 1) + 1] != v6 );\n  }\n  if ( a2 < v4 )\n    *(_QWORD *)(v3 + 48) = sub_ECF0(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n  *(_DWORD *)(v3 + 60) = a2;\n}\n",
    "function_name": "luaS_resize",
    "decompiled_code": "void __fastcall luaS_resize(_QWORD *a1, int a2)\n{\n  __int64 v3; // rbp\n  int v4; // r10d\n  __int64 *v5; // rdi\n  __int64 *v6; // r9\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // rax\n\n  v3 = a1[3];\n  v4 = *(_DWORD *)(v3 + 60);\n  if ( v4 < a2 )\n  {\n    v10 = luaM_realloc_(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n    v4 = *(_DWORD *)(v3 + 60);\n    *(_QWORD *)(v3 + 48) = v10;\n    if ( a2 > v4 )\n    {\n      v11 = (_QWORD *)(v10 + 8LL * v4);\n      v12 = v10 + 8 * (v4 + (unsigned __int64)(unsigned int)(a2 - 1 - v4)) + 8;\n      do\n        *v11++ = 0LL;\n      while ( v11 != (_QWORD *)v12 );\n    }\n  }\n  if ( v4 > 0 )\n  {\n    v5 = *(__int64 **)(v3 + 48);\n    v6 = v5;\n    do\n    {\n      v7 = *v6;\n      *v6 = 0LL;\n      if ( v7 )\n      {\n        do\n        {\n          v8 = *(_QWORD *)(v7 + 16);\n          v9 = &v5[*(_DWORD *)(v7 + 12) & (unsigned int)(a2 - 1)];\n          *(_QWORD *)(v7 + 16) = *v9;\n          *v9 = v7;\n          v7 = v8;\n        }\n        while ( v8 );\n      }\n      ++v6;\n    }\n    while ( &v5[(unsigned int)(v4 - 1) + 1] != v6 );\n  }\n  if ( a2 < v4 )\n    *(_QWORD *)(v3 + 48) = luaM_realloc_(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n  *(_DWORD *)(v3 + 60) = a2;\n}\n",
    "source_code": "void luaS_resize(lua_State* L, int newsize) {\n  int i;\n  stringtable* tb = &G(L)->strt; // global string table\n  if (newsize > tb->size) { /* grow table if needed */\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n    for (i = tb->size; i < newsize; i++)\n      // open hash table, tb->hash is the pointer for linked list\n      tb->hash[i] = NULL;\n  }\n  for (i = 0; i < tb->size; i++) { /* rehash */\n    TString* p = tb->hash[i];\n    tb->hash[i] = NULL;\n    while (p) { /* for each node in the list */\n      TString* hnext = p->u.hnext; /* save next */\n      unsigned int h = lmod(p->hash, newsize); /* new position */\n      p->u.hnext = tb->hash[h]; /* chain it */\n      tb->hash[h] = p;\n      p = hnext;\n    }\n  }\n  if (newsize < tb->size) { /* shrink table if needed */\n    /* vanishing slice should be empty */\n    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n  }\n  tb->size = newsize;\n}",
    "comment": "Resizes the global string table, rehashes existing strings, and reallocates memory based on the new size provided.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sorts an array of file names using either ` strcoll ` or ` strcmp ` based on the specified sorting type while managing memory allocation .\n",
    "cpbcs_sum": "Resizes the resources array and clears the non-zero elements from the context's cache if no indices are present.\n",
    "misum_sum": "Inserts a new element into a dynamically allocated array, updating the linked list and initializing it with the specified index and index.\n",
    "decom_sum": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to match the new size specified by the given parameter.",
    "cfg_sum": "Resizes a hash table to the specified bucket count, reinitializes entries, and redistributes existing nodes based on updated size constraints.",
    "work_score": {
        "decom": {
            "summary": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to match the new size specified by the given parameter.",
            "score": [
                1.0,
                0.4,
                0.7
            ],
            "reason": [
                "The summary contains one atomic claim: that the function resizes a hash table\u2019s bucket array and rehashes all linked entries to match the new size. This is accurate and aligned with the source code, which reallocates the bucket array, reinitializes new slots, and rehashes entries for the new size. No inaccurate or irrelevant claims are present, so the proportion of accurate claims is 100%.",
                "The summary accurately describes the core purpose of the function\u2014resizing the hash table and rehashing entries\u2014matching the source code\u2019s domain-specific behavior. However, it omits important secondary details, such as handling both table growth and shrink cases, initializing new buckets to NULL, performing assertions on shrinking, and using Lua-specific memory reallocation functions. The coverage of secondary behavior-critical semantics is minimal.",
                "The summary accurately captures the primary purpose of the function: resizing the hash table\u2019s bucket array and rehashing linked entries to fit the new size parameter. This matches the source code, which reallocates the bucket array when growing or shrinking, initializes new buckets, and iterates through old entries to reassign them based on the new hash positions. There are no inaccurate claims or noise, but the description is generic and lacks specific details such as handling growth vs. shrink conditions or pointer manipulations, resulting in modest gain."
            ]
        },
        "cfg": {
            "summary": "Resizes a hash table to the specified bucket count, reinitializes entries, and redistributes existing nodes based on updated size constraints.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary accurately describes the core purpose of resizing the hash table, including reinitializing entries and redistributing existing nodes according to the new size. These points match the source code\u2019s logic of growing/shrinking the table and rehashing nodes. It omits some low-level details, such as conditional growth or shrink handling and null-initialization specifics, but all stated claims are correct and relevant to the code\u2019s semantics, making the proportion of accurate claims above 80%.",
                "The summary correctly captures the core purpose of resizing the global string hash table, including reinitializing buckets and redistributing existing nodes according to the new size, which matches the core domain operation in the source code. However, it omits secondary details such as the conditional allocation when growing, initialization of new buckets to NULL, assertion checks when shrinking, and use of linked list chaining during rehashing, resulting in incomplete coverage of important behavior-critical semantics.",
                "The summary correctly captures the primary purpose of resizing the hash table to the specified bucket count and redistributing nodes based on the new size, aligning with the code's behavior. It also notes reinitialization of entries, which matches setting new hash slots to NULL. There is no inaccurate or contradictory claim, and the information is succinct but somewhat generic, providing low-to-moderate insight without deep specifics on growth/shrink conditions or rehashing details."
            ]
        },
        "comment": {
            "summary": "Resizes the global string table, rehashes existing strings, and reallocates memory based on the new size provided.",
            "score": [
                1.0,
                0.6,
                0.8
            ],
            "reason": [
                "The summary captures the core semantics of the function accurately: it changes the size of the global string table, rehashes entries, and reallocates memory based on a new size. These behaviors are consistent with the source code implementation, with each mentioned action (resizing, rehashing, memory reallocation) verifiable from the provided function logic. There are no contradictory or irrelevant claims, and no significant omissions that would misrepresent the function\u2019s main contract.",
                "The summary correctly identifies the core purpose \u2014 resizing the global string table and rehashing existing strings \u2014 and mentions memory reallocation, which aligns with the code\u2019s use of luaM_reallocvector and rehash loop. However, it omits secondary details such as handling growth vs. shrinking separately, initializing new hash slots to NULL when growing, asserting empty slots when shrinking, and preserving linked lists during rehash. These omissions make coverage of secondary behavior incomplete.",
                "The summary contains accurate, specific claims about resizing the global string table, rehashing existing strings, and reallocating memory based on the provided new size, all of which align directly with the source code\u2019s core behavior. There is no contradictory (FATAL) or irrelevant (NOISE) information, but the summary remains high-level and omits details such as conditions for growth/shrinkage and initialization of new slots, limiting its informational gain."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 165072,
    "strip_function_name": "ssl3_get_req_cert_type",
    "strip_decompiled_code": "__int64 __fastcall ssl3_get_req_cert_type(__int64 a1, _BYTE *a2)\n{\n  __int64 v2; // rax\n  __int64 result; // rax\n  __int64 v4; // r10\n  int v5; // r8d\n  __int64 v6; // r9\n  int v7; // ecx\n\n  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 936LL) + 24LL);\n  if ( *(int *)a1 > 768 && (v2 & 0x200) != 0 )\n  {\n    *a2 = 21;\n    a2[1] = 22;\n    return 2LL;\n  }\n  if ( (v2 & 0xA) != 0 )\n  {\n    *a2 = 3;\n    a2[1] = 4;\n    v6 = 3LL;\n    v7 = 4;\n    v4 = 2LL;\n    v5 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  else\n  {\n    v4 = 0LL;\n    v5 = 0;\n    v6 = 1LL;\n    v7 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  if ( (v2 & 0xE) != 0 )\n  {\n    a2[v4] = 5;\n    a2[v6] = 6;\n    LODWORD(v6) = v7 + 1;\n    v4 = v7;\n    v5 = v7;\n    v7 += 2;\n    v6 = (int)v6;\n  }\nLABEL_6:\n  a2[v4] = 1;\n  a2[v6] = 2;\n  if ( (v2 & 0x60) != 0 )\n  {\n    result = (unsigned int)v7;\n    if ( *(int *)a1 <= 768 )\n      return result;\n    a2[v7] = 65;\n    v7 = v5 + 4;\n    a2[v5 + 3] = 66;\n  }\n  result = (unsigned int)v7;\n  if ( *(int *)a1 > 768 )\n  {\n    result = (unsigned int)(v7 + 1);\n    a2[v7] = 64;\n  }\n  return result;\n}\n",
    "function_name": "ssl3_get_req_cert_type",
    "decompiled_code": "__int64 __fastcall ssl3_get_req_cert_type(__int64 a1, _BYTE *a2)\n{\n  __int64 v2; // rax\n  __int64 result; // rax\n  __int64 v4; // r10\n  int v5; // r8d\n  __int64 v6; // r9\n  int v7; // ecx\n\n  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 936LL) + 24LL);\n  if ( *(int *)a1 > 768 && (v2 & 0x200) != 0 )\n  {\n    *a2 = 21;\n    a2[1] = 22;\n    return 2LL;\n  }\n  if ( (v2 & 0xA) != 0 )\n  {\n    *a2 = 3;\n    a2[1] = 4;\n    v6 = 3LL;\n    v7 = 4;\n    v4 = 2LL;\n    v5 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  else\n  {\n    v4 = 0LL;\n    v5 = 0;\n    v6 = 1LL;\n    v7 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  if ( (v2 & 0xE) != 0 )\n  {\n    a2[v4] = 5;\n    a2[v6] = 6;\n    LODWORD(v6) = v7 + 1;\n    v4 = v7;\n    v5 = v7;\n    v7 += 2;\n    v6 = (int)v6;\n  }\nLABEL_6:\n  a2[v4] = 1;\n  a2[v6] = 2;\n  if ( (v2 & 0x60) != 0 )\n  {\n    result = (unsigned int)v7;\n    if ( *(int *)a1 <= 768 )\n      return result;\n    a2[v7] = 65;\n    v7 = v5 + 4;\n    a2[v5 + 3] = 66;\n  }\n  result = (unsigned int)v7;\n  if ( *(int *)a1 > 768 )\n  {\n    result = (unsigned int)(v7 + 1);\n    a2[v7] = 64;\n  }\n  return result;\n}\n",
    "source_code": "\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\n\t{\n\tint ret=0;\n\tunsigned long alg_k;\n\n\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n#ifndef OPENSSL_NO_GOST\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tif (alg_k & SSL_kGOST)\n\t\t\t{\n\t\t\tp[ret++]=TLS_CT_GOST94_SIGN;\n\t\t\tp[ret++]=TLS_CT_GOST01_SIGN;\n\t\t\treturn(ret);\n\t\t\t}\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (alg_k & (SSL_kDHr|SSL_kEDH))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_FIXED_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_FIXED_DH;\n#  endif\n\t\t}\n\tif ((s->version == SSL3_VERSION) &&\n\t\t(alg_k & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\n#  endif\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_RSA\n\tp[ret++]=SSL3_CT_RSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_DSA\n\tp[ret++]=SSL3_CT_DSS_SIGN;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->version >= TLS1_VERSION))\n\t\t{\n\t\tp[ret++]=TLS_CT_RSA_FIXED_ECDH;\n\t\tp[ret++]=TLS_CT_ECDSA_FIXED_ECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDSA\n\t/* ECDSA certs can be used with RSA cipher suites as well \n\t * so we don't need to check for SSL_kECDH or SSL_kEECDH\n\t */\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tp[ret++]=TLS_CT_ECDSA_SIGN;\n\t\t}\n#endif\t\n\treturn(ret);\n\t}",
    "comment": "Determines and populates the required certificate types based on the SSL connection's cipher algorithms and version.",
    "hext5_sum": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
    "bint5_sum": "Determines the SSL certificate type based on the handshake message type and updates the provided SSL_CERT_TYPE structure accordingly .\n",
    "cpbcs_sum": "Constructs and sets an OCSP cipher node based on the provided key and supported types, returning the appropriate digest type and permissions.\n",
    "misum_sum": "Constructs and returns a string representation of a DTLS ClientHello message, writing the result to a buffer, while checking for length constraints.\n",
    "decom_sum": "Constructs and returns an SSLv3 certificate request type list based on connection version and peer capability bitmask flags.",
    "cfg_sum": "Generates a list of requested SSL certificate type codes based on session version and capability flags, returning the total number of types added.",
    "work_score": {
        "decom": {
            "summary": "Constructs and returns an SSLv3 certificate request type list based on connection version and peer capability bitmask flags.",
            "score": [
                0.8,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly captures that the function constructs and returns a list of certificate types and bases its decisions on the connection version and algorithm/key capability flags. However, it incorrectly specifies 'SSLv3' only, omitting that it can also operate for TLS1 and above depending on conditions, and the term 'peer capability' is misleading since the code uses the local connection's cipher algorithm flags. Most of the core contract is accurate but with these minor inaccuracies.",
                "The summary correctly states that the function builds and returns a certificate request type list based on the SSL/TLS version and key-exchange algorithm flags, which aligns with the core purpose seen in the source (iterating through SSL_k* bits to append cert types to 'p'). However, it omits important specific details such as handling of various algorithm families (GOST, DH, RSA, DSA, ECDH, ECDSA) and conditional compilation macros. It also simplifies 'peer capability bitmask' to only a generic description, losing the explicit domain semantics from the code's constant values and branching rules.",
                "The summary captures the general purpose of producing a certificate request type list based on version and capability flags, which aligns with the source code\u2019s logic of checking TLS/SSL version and algorithm key bits. However, it inaccurately specifies 'SSLv3' only, whereas the code also covers TLS1 and above with different handling, making the main purpose misrepresented \u2014 this is a core semantic mismatch affecting the description\u2019s reliability. The description is otherwise generic and lacks specific details about the various certificate types and conditional checks, limiting informational gain."
            ]
        },
        "cfg": {
            "summary": "Generates a list of requested SSL certificate type codes based on session version and capability flags, returning the total number of types added.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly captures the core behavior: the function builds a list of SSL certificate type codes depending on the session version and algorithm/capability flags, then returns the count. This aligns well with the code, which conditionally appends specific constants to the array based on protocol version and key exchange method flags before returning the number of added entries. No contradictions or irrelevant noise are present, and the claim is factually accurate, albeit at a slightly generic level.",
                "The summary accurately captures the core purpose: determining and returning SSL certificate type codes based on session version and key exchange algorithm flags. However, it omits secondary details such as handling specific algorithm types (GOST, DH, RSA, DSA, ECDH, ECDSA), conditional additions for TLS1 vs SSL3, and the multiple sets of constants used. These omissions reduce coverage of important behavior-critical semantics.",
                "The summary correctly states the core purpose: generating a list of SSL certificate type codes based on session parameters and returning the count. This matches the code logic, which conditionally appends certificate types depending on version and algorithm flags, and returns the size of the list. The description is accurate but generic, lacking specific details about the supported certificate types or flag conditions, so information gain is low. No inaccurate or contradictory claims are present, and noise is minimal."
            ]
        },
        "comment": {
            "summary": "Determines and populates the required certificate types based on the SSL connection's cipher algorithms and version.",
            "score": [
                0.9,
                0.5,
                0.6
            ],
            "reason": [
                "The summary accurately states that the function determines and populates certificate types based on the SSL connection's cipher algorithms and version, which matches the source code behavior. However, it is generic and omits specifics such as the distinct algorithm checks (GOST, DH, RSA, DSA, ECDH, ECDSA) and version conditions. Despite the lack of detail, it does not contain inaccuracies or unrelated information, making all claims correct but low in informational value.",
                "The summary correctly identifies that the function selects certificate types based on SSL cipher algorithms and protocol version, which matches the core purpose of populating a buffer with valid certificate type codes. However, it is vague and omits key secondary details from the code, such as the specific certificate type constants for GOST, DH, RSA, DSA, and ECDH/ECDSA, and the version-dependent conditional logic. This results in incomplete coverage of the critical branch handling and constants used.",
                "The summary accurately conveys the core purpose of the function: selecting and populating certificate types based on the connection's cipher algorithms and TLS/SSL version. This is a correct, domain-relevant description without contradictions to the source code. However, it is broad and lacks detail about the exact algorithm checks, constant values used, and conditional compilation, providing only low-information gain. Noise is minimal, but specificity is missing, so the benefit is modest."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583530080,
    "strip_function_name": "sub_FFFFFFFF81477C60",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81477C60(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // r8d\n  int v6; // r9d\n\n  *(_DWORD *)(a2 + 4) = 46;\n  *(_DWORD *)(a2 + 8) = 0;\n  result = sub_FFFFFFFF81477910(a1 + 1856, (_DWORD *)(a2 + 4));\n  if ( (_DWORD)result )\n    return result;\n  result = *(_QWORD *)(a1 + 2696);\n  if ( (*(_BYTE *)(result + 316) & 1) == 0 )\n    return result;\n  if ( *(_WORD *)(a1 + 2934) != 4277 )\n    goto LABEL_15;\n  *(_DWORD *)(a2 + 4) &= ~2u;\n  result = *(unsigned int *)(a1 + 2380);\n  if ( (result & 4) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 3696) & 1) == 0 )\n    {\nLABEL_6:\n      *(_DWORD *)(a2 + 8) |= 2u;\n      result = *(unsigned int *)(a1 + 2380);\n      goto LABEL_7;\n    }\n    sub_FFFFFFFF815DB960(\n      *(_QWORD *)(a1 + 2688),\n      (unsigned int)\"Interface does not support directed (unicast) frame wake-up packets\\n\",\n      v3,\n      v4,\n      v5,\n      v6);\nLABEL_15:\n    result = *(unsigned int *)(a1 + 2380);\n    if ( (result & 4) == 0 )\n      goto LABEL_7;\n    goto LABEL_6;\n  }\nLABEL_7:\n  if ( (result & 8) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 4u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 0x10) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 8u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 2) != 0 )\n    *(_DWORD *)(a2 + 8) |= 0x20u;\n  return result;\n}\n",
    "function_name": "e1000_get_wol",
    "decompiled_code": "__int64 __fastcall e1000_get_wol(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n\n  *(_DWORD *)(a2 + 4) = 46;\n  *(_DWORD *)(a2 + 8) = 0;\n  result = e1000_wol_exclusion_isra_13(a1 + 1856, (_DWORD *)(a2 + 4));\n  if ( (_DWORD)result )\n    return result;\n  result = *(_QWORD *)(a1 + 2696);\n  if ( (*(_BYTE *)(result + 316) & 1) == 0 )\n    return result;\n  if ( *(_WORD *)(a1 + 2934) != 4277 )\n    goto LABEL_15;\n  *(_DWORD *)(a2 + 4) &= ~2u;\n  result = *(unsigned int *)(a1 + 2380);\n  if ( (result & 4) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 3696) & 1) == 0 )\n    {\nLABEL_6:\n      *(_DWORD *)(a2 + 8) |= 2u;\n      result = *(unsigned int *)(a1 + 2380);\n      goto LABEL_7;\n    }\n    netdev_err(\n      *(_QWORD *)(a1 + 2688),\n      (__int64)\"Interface does not support directed (unicast) frame wake-up packets\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      v11,\n      v12,\n      a9,\n      a10);\nLABEL_15:\n    result = *(unsigned int *)(a1 + 2380);\n    if ( (result & 4) == 0 )\n      goto LABEL_7;\n    goto LABEL_6;\n  }\nLABEL_7:\n  if ( (result & 8) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 4u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 0x10) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 8u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 2) != 0 )\n    *(_DWORD *)(a2 + 8) |= 0x20u;\n  return result;\n}\n",
    "source_code": "\nstatic void e1000_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t                 WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\t/* this function will set ->supported = 0 and return 1 if wol is not\n\t * supported by this hardware\n\t */\n\tif (e1000_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\t/* apply any specific unsupported masks here */\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t/* KSP3 does not support UCAST wake-ups */\n\t\twol->supported &= ~WAKE_UCAST;\n\n\t\tif (adapter->wol & E1000_WUFC_EX)\n\t\t\te_err(drv, \"Interface does not support directed \"\n\t\t\t      \"(unicast) frame wake-up packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n}",
    "comment": "Configures wake-on-LAN options for the network device based on adapter capabilities and supported wake-up frame types.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the Ethernet device 's MAC address , modifying it if necessary , and stores it in the provided ethtool_cmd structure .\n",
    "cpbcs_sum": "Initializes the e1000 network adapter and sets up hardware quirks for the network device and interrupt handling based on its state.\n",
    "misum_sum": "Initializes the PHY device by setting its advertising capabilities and determining the auto-negotiation process based on its current link status and flags.\n",
    "decom_sum": "Configures wake-up packet capability flags for a network interface based on hardware status and logs when directed unicast support is unavailable.",
    "cfg_sum": "Configures wake-up packet support flags based on hardware state, bitmask settings, and interface capabilities, logging when directed frame wake-up is unsupported.",
    "work_score": {
        "decom": {
            "summary": "Configures wake-up packet capability flags for a network interface based on hardware status and logs when directed unicast support is unavailable.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function configures wake-up packet capability flags based on hardware status and that it logs when directed unicast support is unavailable. Both claims are directly supported by the source code: the 'wol->supported' and 'wol->wolopts' are set according to hardware and adapter state, and an error is logged for KSP3 devices when directed unicast is unsupported. There are no inaccurate claims, indicating high alignment with the source behavior.",
                "The summary correctly covers the core purpose \u2014 setting wake-up capability flags for a network interface based on hardware status \u2014 and mentions logging when directed unicast is unsupported, which matches the specific KSP3 hardware branch behavior. However, it omits secondary details like the explicit supported wake-up types (magic, broadcast, multicast, unicast), the initial default setup, the condition that exits early if WOL is not supported or device can't wake, and the mapping of adapter \\u2018wol\\u2019 bits to wolopts flags. These missing aspects reduce completeness despite accurate core coverage.",
                "The summary correctly states that the function configures wake-up capability flags for a network interface based on hardware status and mentions logging when unicast support is unavailable, both of which align with the code's behavior. It omits some details such as specific wake-up types, exclusion checks, and conditional masking, but there are no inaccurate claims or noise. The claims are accurate but relatively general, providing low informational gain."
            ]
        },
        "cfg": {
            "summary": "Configures wake-up packet support flags based on hardware state, bitmask settings, and interface capabilities, logging when directed frame wake-up is unsupported.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately describes that the function configures wake-up packet support flags using hardware state, bitmask settings, and interface capabilities, and mentions logging when directed frame wake-up is unsupported. These elements align well with the source code, which sets `wol->supported` and `wol->wolopts` based on hardware/device checks and logs a message when unicast wake-ups are unsupported. No contradictory or irrelevant claims are present, and the coverage is concise but correct.",
                "The summary accurately describes the core purpose: setting wake-up packet support flags contingent on hardware, bitmask configurations, and interface capability, and notes logging for unsupported directed frame wake-up. This matches the source's logic for initializing `wol->supported`, applying hardware-specific exclusions, and setting `wol->wolopts` according to adapter flags. However, it omits detail on the initial supported mask constants, the conditional early return when wake-on-LAN is not supported, and specifics about each wake type configured via bitmask checks, so secondary coverage is partial rather than comprehensive.",
                "The summary correctly states that the function configures wake-up packet support flags according to hardware state, bitmask settings, and interface capabilities, and notes logging when directed frame wake-up is unsupported. These are accurate GOLD claims aligned with the code\u2019s primary purpose and key side effects, with no contradictory or irrelevant details. While accurate, the description is concise and lacks detailed insight into specific constants or exclusion logic, limiting the depth of gain."
            ]
        },
        "comment": {
            "summary": "Configures wake-on-LAN options for the network device based on adapter capabilities and supported wake-up frame types.",
            "score": [
                0.9,
                0.4,
                0.6
            ],
            "reason": [
                "The summary correctly describes that the function configures wake-on-LAN options based on adapter capabilities and supported wake-up frame types, aligning with the source code\u2019s use of `wol->supported` and `wol->wolopts` settings. While concise and somewhat generic, it is accurate and covers the main purpose without contradictions. There are no factually incorrect or unrelated claims.",
                "The summary accurately states the core purpose of configuring wake-on-LAN options based on adapter capabilities and wake-up frame types, which matches the function's main operation from the source code. However, it omits important secondary details: initial supported flags setup, handling hardware exclusions, specific device ID masking (removing UCAST for KSP3), error logging, and mapping adapter->wol bitmask to wolopts. Coverage of these behavior-critical semantics is weak beyond the core.",
                "The summary correctly captures the primary purpose of the function\u2014configuring wake-on-LAN options based on the adapter's capabilities and supported frame types. This aligns with the code behavior of setting 'supported' flags, checking hardware support, applying exclusions, and setting 'wolopts'. It is accurate but lacks detail, omitting specifics such as conditional handling for certain device IDs and exclusion logic. No inaccuracies or noise are present, but the gain is low due to the generic nature of the claim."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578930512,
    "strip_function_name": "sub_FFFFFFFF81014D50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81014D50(__int64 a1)\n{\n  __int64 v1; // rbx\n  int v2; // eax\n  int v3; // edx\n  int v4; // edx\n  __int64 result; // rax\n  int v6; // edx\n  __int64 v7; // rcx\n  __int64 i; // rax\n  __int64 v9; // rsi\n\n  if ( !dword_FFFFFFFF81CB5600 )\n    return 4294967201LL;\n  v1 = *(_QWORD *)(a1 + 232);\n  v2 = *(_DWORD *)(a1 + 232) & 1;\n  if ( (v1 & 2) != 0 )\n  {\n    if ( dword_FFFFFFFF81CB8498 > 1 && !(unsigned __int8)sub_FFFFFFFF81047B60(21LL) )\n      return 4294967283LL;\n    v2 = v1 & 1 | 2;\n  }\n  if ( (v1 & 8) != 0 )\n    v2 |= 0xFFCu;\n  if ( (v1 & 0x10) != 0 )\n    v2 |= 0xC54u;\n  v3 = v2;\n  if ( (v1 & 0x20) != 0 )\n  {\n    LOBYTE(v3) = v2 | 0xA8;\n    v2 = v3;\n  }\n  v4 = v2;\n  if ( (v1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(v2) | 8;\n    v2 = v4;\n  }\n  *(_DWORD *)(a1 + 344) = v2;\n  result = 0LL;\n  if ( qword_FFFFFFFF81CB5610 )\n  {\n    v6 = 7;\n    v7 = 0LL;\n    for ( i = 1LL; ; i *= 2LL )\n    {\n      if ( (i & *(_QWORD *)(a1 + 232)) != 0 )\n      {\n        v9 = *(int *)(qword_FFFFFFFF81CB5610 + 4 * i);\n        if ( v9 == -1 )\n          return 4294967201LL;\n        v7 |= v9;\n      }\n      if ( !--v6 )\n      {\n        *(_DWORD *)(a1 + 352) = 2;\n        result = 0LL;\n        *(_QWORD *)(a1 + 336) = qword_FFFFFFFF81CB5608 & ~v7;\n        return result;\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "intel_pmu_setup_lbr_filter",
    "decompiled_code": "__int64 __fastcall intel_pmu_setup_lbr_filter(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rbx\n  int v7; // eax\n  int v8; // edx\n  int v9; // edx\n  __int64 result; // rax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 i; // rax\n  __int64 v14; // rsi\n\n  if ( !dword_FFFFFFFF81CB5600 )\n    return 4294967201LL;\n  v6 = *(_QWORD *)(a1 + 232);\n  v7 = *(_DWORD *)(a1 + 232) & 1;\n  if ( (v6 & 2) != 0 )\n  {\n    if ( sysctl_perf_event_paranoid > 1 && !(unsigned __int8)capable(0x15u, a2, a3, a4, a5, a6) )\n      return 4294967283LL;\n    v7 = v6 & 1 | 2;\n  }\n  if ( (v6 & 8) != 0 )\n    v7 |= 0xFFCu;\n  if ( (v6 & 0x10) != 0 )\n    v7 |= 0xC54u;\n  v8 = v7;\n  if ( (v6 & 0x20) != 0 )\n  {\n    LOBYTE(v8) = v7 | 0xA8;\n    v7 = v8;\n  }\n  v9 = v7;\n  if ( (v6 & 0x40) != 0 )\n  {\n    BYTE1(v9) = BYTE1(v7) | 8;\n    v7 = v9;\n  }\n  *(_DWORD *)(a1 + 344) = v7;\n  result = 0LL;\n  if ( qword_FFFFFFFF81CB5610 )\n  {\n    v11 = 7;\n    v12 = 0LL;\n    for ( i = 1LL; ; i *= 2LL )\n    {\n      if ( (i & *(_QWORD *)(a1 + 232)) != 0 )\n      {\n        v14 = *(int *)(qword_FFFFFFFF81CB5610 + 4 * i);\n        if ( v14 == -1 )\n          return 4294967201LL;\n        v12 |= v14;\n      }\n      if ( !--v11 )\n      {\n        *(_DWORD *)(a1 + 352) = 2;\n        result = 0LL;\n        *(_QWORD *)(a1 + 336) = qword_FFFFFFFF81CB5608 & ~v12;\n        return result;\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint intel_pmu_setup_lbr_filter(struct perf_event *event)\n{\n\tint ret = 0;\n\n\t/*\n\t * no LBR on this PMU\n\t */\n\tif (!x86_pmu.lbr_nr)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * setup SW LBR filter\n\t */\n\tret = intel_pmu_setup_sw_lbr_filter(event);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * setup HW LBR filter, if any\n\t */\n\tif (x86_pmu.lbr_sel_map)\n\t\tret = intel_pmu_setup_hw_lbr_filter(event);\n\n\treturn ret;\n}",
    "comment": "Configures both software and hardware LBR filters for a performance event if LBR support is available on the PMU.",
    "hext5_sum": " a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Configures performance monitoring event registers for Intel PMU , enabling or disabling features based on event configuration and CPU capabilities .\n",
    "cpbcs_sum": "Initializes performance monitoring events for a performance event by setting event attributes based on event flags and updating event counts accordingly.\n",
    "misum_sum": "Initializes uncore performance monitoring unit architecture by configuring event attributes and validating CPU model settings.\n",
    "decom_sum": "Configures device control flags from an input structure and updates hardware mask registers, returning error codes if initialization or capability checks fail.",
    "cfg_sum": "Validates configuration flags from a structure, applies specific bitmask updates, and returns predefined error codes if global settings or mapped values fail checks.",
    "work_score": {
        "decom": {
            "summary": "Configures device control flags from an input structure and updates hardware mask registers, returning error codes if initialization or capability checks fail.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function configures device control flags and updates hardware mask registers, but the source code shows it sets up software and hardware Last Branch Record (LBR) filters for a perf event using PMU state, returning specific error codes if LBR is unsupported or filter setup fails. The described 'device control flags' and 'hardware mask registers' do not match the domain semantics, and none of the claims align closely with the actual behavior. This results in a very low proportion of accurate claims.",
                "The summary's claims about configuring device control flags and updating hardware mask registers do not match the source code, which sets up software and optionally hardware LBR filters for an Intel PMU, returning specific error codes when unsupported or setup fails. The core purpose of configuring LBR filters based on PMU capabilities is missing, and no accurate domain-specific behavior from the code is reflected.",
                "The summary contains multiple inaccurate claims about the function's purpose and behavior. It inaccurately states that the function configures device control flags and updates hardware mask registers, which is not present in the source code. The actual code sets up software and optional hardware Last Branch Record (LBR) filters for a performance event, with specific checks for PMU capability. These inaccuracies target the core purpose and I/O of the function (FATAL), making the description misleading and unusable. No accurate or helpful details are provided to offset this error."
            ]
        },
        "cfg": {
            "summary": "Validates configuration flags from a structure, applies specific bitmask updates, and returns predefined error codes if global settings or mapped values fail checks.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes validating configuration flags, applying bitmask updates, and performing checks on global settings or mapped values. None of these actions are present in the source code, which instead checks for LBR support, calls specific setup functions, and returns their results. The claims do not align with the actual function logic, resulting in no accurate fact-based correspondence.",
                "The summary makes claims about validating configuration flags, applying bitmask updates, and returning errors based on global settings or mapped values, but the source code does not perform bitmask updates or generic flag validation. The actual core purpose is to set up software and optionally hardware Last Branch Record filters for a performance event, with an early return if unsupported. None of the claims accurately reflect this domain-specific behavior, so the core is not covered and secondary details are also incorrect.",
                "The summary introduces inaccurate semantics: it claims the function validates configuration flags, applies bitmask updates, and checks mapped values with error codes, none of which match the source code. The actual function checks if LBR is supported, then calls setup functions for software and possibly hardware filters. These FATAL inaccuracies misrepresent the primary purpose and key actions, leaving no accurate claims to provide value."
            ]
        },
        "comment": {
            "summary": "Configures both software and hardware LBR filters for a performance event if LBR support is available on the PMU.",
            "score": [
                1.0,
                0.5,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function configures software and hardware LBR filters for a performance event when LBR support is available on the PMU. This matches the code logic: it checks for LBR support, sets up the software filter, and conditionally sets up the hardware filter if available. There are no inaccurate or irrelevant claims, making the description precise and aligned with the source code semantics.",
                "The summary correctly describes that the function configures both software and hardware LBR filters for a performance event only if LBR is supported on the PMU, capturing the core purpose accurately. However, it lacks details about specific execution flow and edge cases present in the source, such as returning -EOPNOTSUPP when LBR is not supported, conditional hardware setup based on lbr_sel_map, and handling the return values from filter setup functions. This results in incomplete coverage of secondary behavior-critical semantics.",
                "The summary accurately captures the primary purpose of the function: it configures software and hardware LBR filters for a performance event, and it correctly conditions this on LBR support being available on the PMU. While it omits some specifics, such as returning specific error codes when unsupported and conditional hardware filter setup, there are no inaccurate claims or irrelevant noise. The gain is moderate, as the description is specific enough to convey the core behavior but lacks finer implementation details."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592452338,
    "strip_function_name": "sub_FFFFFFFF81CFA0F2",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81CFA0F2(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 v8; // rbx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int i; // eax\n  unsigned __int64 v14; // rsi\n  __int64 v15; // rcx\n  int j; // eax\n\n  v8 = 0LL;\n  sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF819A0BD2, a1, a2, a3, a4, a5, a6, a7, a8, \"dquot_6.5.2\");\n  sub_FFFFFFFF8119FA40(off_FFFFFFFF81C40A00, a1, a2, a3, a4, v9, v10, a7, a8);\n  qword_FFFFFFFF81E936D0 = sub_FFFFFFFF811057E0((__int64)\"dquot\", 0xF0uLL, 0x20uLL, 1449984, 0LL);\n  qword_FFFFFFFF81E936C0 = sub_FFFFFFFF810EB290(32LL, 0LL);\n  if ( !qword_FFFFFFFF81E936C0 )\n    sub_FFFFFFFF8178A51B((__int64)\"Cannot create dquot hash table\", a1, a2, a3, a4, v11, v12, a7, a8);\n  do\n  {\n    if ( (unsigned int)sub_FFFFFFFF812C77E0((__int64)&unk_FFFFFFFF81E93580 + v8, 0LL, a1, a2, a3, a4, v11, v12, a7, a8) )\n      sub_FFFFFFFF8178A51B((__int64)\"Cannot create dquot stat counters\", a1, a2, a3, a4, v11, v12, a7, a8);\n    v8 += 40LL;\n  }\n  while ( v8 != 320 );\n  for ( i = 0; 0x200uLL >> ((unsigned __int8)i + 1); ++i )\n    ;\n  dword_FFFFFFFF81E936CC = i;\n  v14 = 1LL << i;\n  v15 = qword_FFFFFFFF81E936C0;\n  dword_FFFFFFFF81E936C8 = (1LL << i) - 1;\n  for ( j = 0; v14 > j; ++j )\n    *(_QWORD *)(v15 + 8LL * j) = 0LL;\n  sub_FFFFFFFF8178A70F(\n    (__int64)\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n    a1,\n    a2,\n    a3,\n    a4,\n    v11,\n    v12,\n    a7,\n    a8,\n    v14,\n    0LL,\n    4096LL);\n  sub_FFFFFFFF810F5F40((__int64)&off_FFFFFFFF81C40D40);\n  return 0LL;\n}\n",
    "function_name": "dquot_init",
    "decompiled_code": "__int64 __fastcall dquot_init(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)\n{\n  __int64 v8; // rbx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  int i; // eax\n  unsigned __int64 v18; // rsi\n  __int64 v19; // rcx\n  int j; // eax\n\n  v8 = 0LL;\n  printk((__int64)&unk_FFFFFFFF819A0BD2, a1, a2, a3, a4, a5, a6, a7, a8, \"dquot_6.5.2\");\n  register_sysctl_table((__int64 **)sys_table, a1, a2, a3, a4, v9, v10, a7, a8);\n  dquot_cachep = (__int64)kmem_cache_create(\n                            (__int64 *)\"dquot\",\n                            0xF0uLL,\n                            0x20uLL,\n                            1449984,\n                            0LL,\n                            a1,\n                            a2,\n                            a3,\n                            a4,\n                            v11,\n                            v12,\n                            a7,\n                            a8);\n  dquot_hash = _get_free_pages(0x20u, 0, a1, a2, a3, a4, v13, v14, a7, a8);\n  if ( !dquot_hash )\n    panic((__int64)\"Cannot create dquot hash table\", a1, a2, a3, a4, v15, v16, a7, a8);\n  do\n  {\n    if ( (unsigned int)_percpu_counter_init((__int64)&unk_FFFFFFFF81E93580 + v8, 0LL, a1, a2, a3, a4, v15, v16, a7, a8) )\n      panic((__int64)\"Cannot create dquot stat counters\", a1, a2, a3, a4, v15, v16, a7, a8);\n    v8 += 40LL;\n  }\n  while ( v8 != 320 );\n  for ( i = 0; 0x200uLL >> ((unsigned __int8)i + 1); ++i )\n    ;\n  dq_hash_bits = i;\n  v18 = 1LL << i;\n  v19 = dquot_hash;\n  dq_hash_mask = (1LL << i) - 1;\n  for ( j = 0; v18 > j; ++j )\n    *(_QWORD *)(v19 + 8LL * j) = 0LL;\n  printk(\n    (__int64)\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n    a1,\n    a2,\n    a3,\n    a4,\n    v15,\n    v16,\n    a7,\n    a8,\n    v18,\n    0LL,\n    4096LL);\n  register_shrinker((__int64)&dqcache_shrinker, v18);\n  return 0LL;\n}\n",
    "source_code": "\nstatic int __init dquot_init(void)\n{\n\tint i, ret;\n\tunsigned long nr_hash, order;\n\n\tprintk(KERN_NOTICE \"VFS: Disk quotas %s\\n\", __DQUOT_VERSION__);\n\n\tregister_sysctl_table(sys_table);\n\n\tdquot_cachep = kmem_cache_create(\"dquot\",\n\t\t\tsizeof(struct dquot), sizeof(unsigned long) * 4,\n\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tNULL);\n\n\torder = 0;\n\tdquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);\n\tif (!dquot_hash)\n\t\tpanic(\"Cannot create dquot hash table\");\n\n\tfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\n\t\tret = percpu_counter_init(&dqstats.counter[i], 0);\n\t\tif (ret)\n\t\t\tpanic(\"Cannot create dquot stat counters\");\n\t}\n\n\t/* Find power-of-two hlist_heads which can fit into allocation */\n\tnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\n\tdq_hash_bits = 0;\n\tdo {\n\t\tdq_hash_bits++;\n\t} while (nr_hash >> dq_hash_bits);\n\tdq_hash_bits--;\n\n\tnr_hash = 1UL << dq_hash_bits;\n\tdq_hash_mask = nr_hash - 1;\n\tfor (i = 0; i < nr_hash; i++)\n\t\tINIT_HLIST_HEAD(dquot_hash + i);\n\n\tprintk(\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n\t\t\tnr_hash, order, (PAGE_SIZE << order));\n\n\tregister_shrinker(&dqcache_shrinker);\n\n\treturn 0;\n}",
    "comment": "Initializes the disk quota subsystem by creating a cache, allocating a hash table, and setting up statistical counters.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the dquot subsystem by registering the sysctl table and creating a sysctl table for dynamic device management .\n",
    "cpbcs_sum": "Initializes memory management caches, including page allocation numbers and a sysctl table, while ensuring thread safety with a mutex.\n",
    "misum_sum": "Initializes memory management caches, sets up CPU-specific entries, and prepares for available page lists, and registers the cache for writeback operations.\n",
    "decom_sum": "Initializes the disk quota cache by allocating a hash table, setting up statistics counters, and logging its size and memory parameters.",
    "cfg_sum": "Initializes the dquot subsystem, creating hash tables and stat counters, handling allocation errors, and logging cache table configuration before finalizing setup.",
    "work_score": {
        "decom": {
            "summary": "Initializes the disk quota cache by allocating a hash table, setting up statistics counters, and logging its size and memory parameters.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary includes accurate claims about allocating a hash table, initializing statistics counters, and logging size and memory parameters, all of which are explicitly present in the source code. It omits some details, such as setting up the shrinker and registering the sysctl table, but the claims it does make are fully aligned with the code, leading to a high proportion of accurate statements.",
                "The summary accurately describes key aspects of the function: initializing the disk quota cache, allocating a hash table, setting up statistics counters, and logging size/memory values, which aligns with the source code\u2019s core purpose of initializing disk quota infrastructure. However, it omits important secondary behaviors such as creating the kmem_cache for quota structures, registering sysctl and shrinker, handling allocation failures with panic, and computing hash bits/mask. Core purpose is covered but secondary coverage is limited.",
                "The summary accurately states that the function initializes the disk quota cache, allocates a hash table, sets up statistics counters, and logs size/memory parameters \u2014 all of which are explicitly present in the source code. There are no contradictory or irrelevant claims, and although the description is correct, it is somewhat generic and omits specific details such as sysctl registration, precise allocation flags, and shrinker registration. The accuracy is high but the informational gain is moderate due to brevity."
            ]
        },
        "cfg": {
            "summary": "Initializes the dquot subsystem, creating hash tables and stat counters, handling allocation errors, and logging cache table configuration before finalizing setup.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary accurately captures the key semantics of the function: it initializes the dquot subsystem, sets up hash tables, creates and initializes stat counters, includes error handling for allocation failures, logs configuration details, and completes setup. All claims are supported by the source code, with no contradictions or irrelevant statements present, indicating very high alignment with the evaluation steps.",
                "The summary correctly identifies the core purpose of initializing the dquot subsystem with hash tables and stat counters, and notes error handling and logging, which aligns with the source code's behavior. However, it omits several secondary details such as registering the sysctl table, using a slab cache for dquot objects, calculating dq_hash_bits and dq_hash_mask, and registering the shrinker, which are important parts of the initialization process. Coverage is solid for the main function but incomplete for other critical semantics.",
                "The summary correctly captures the core purpose and actions of the function: it initializes the dquot subsystem, creates hash tables and stat counters, handles allocation errors via panics, logs configuration details, and completes setup. All claims are accurate and tied directly to the source code semantics. There is no noise or contradiction, and the information is specific enough to be useful in conveying the function's behavior."
            ]
        },
        "comment": {
            "summary": "Initializes the disk quota subsystem by creating a cache, allocating a hash table, and setting up statistical counters.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately captures the main functional steps: initializing the disk quota subsystem, creating a cache, allocating a hash table, and setting up statistical counters, all of which are explicitly performed in the source code. Although it omits some details like logging, sysctl registration, and shrinker registration, the claims present are correct and directly reflect core semantics, yielding a high proportion of accurate statements.",
                "The summary accurately notes that the function initializes the disk quota subsystem, creates a cache, allocates a hash table, and sets up statistical counters, all of which are present in the source. These claims cover the core purpose of initializing key data structures for the quota subsystem, but they omit several secondary behaviors such as registering sysctl tables, handling allocation failures with panic, calculating hash parameters, initializing each hash bucket, logging informational messages, and registering a shrinker. Coverage of these other important side effects and branches is lacking, leading to incomplete representation of the function\u2019s behavior.",
                "The summary accurately reflects the primary purpose of the function: it initializes the disk quota subsystem, creates a cache (`kmem_cache_create`), allocates a hash table (`__get_free_pages`), and sets up per-CPU statistical counters (`percpu_counter_init`). These are specific, verifiable domain actions aligned with the source code. No claims are inaccurate or noisy, but the summary omits some secondary details like registering sysctl/shrinker, which slightly limits completeness. Overall, it is concise and largely GOLD, with minimal noise."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586672864,
    "strip_function_name": "sub_FFFFFFFF817770E0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF817770E0(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v11; // rsi\n  char *v12; // rax\n  __int64 *v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  char *v19; // rbx\n  __int64 v20; // r14\n  unsigned int v21; // r12d\n  __int64 result; // rax\n  __int64 v23[4]; // [rsp+7h] [rbp-21h] BYREF\n\n  v11 = 208LL;\n  v12 = (char *)sub_FFFFFFFF815CF830(3776, 0xD0u, 0, 0xFFFFFFFF, a1, a2, a3, a4, a5, a6, a7, a8);\n  v19 = v12;\n  if ( !v12 )\n  {\n    v21 = -22;\n    goto LABEL_4;\n  }\n  v11 = *(unsigned int *)(a10 + 4);\n  v20 = sub_FFFFFFFF81607D60(v12, v11, *(_DWORD *)a10, dword_FFFFFFFF81CA0800, 0, 2);\n  if ( !v20 )\n  {\n    v21 = -12;\n    goto LABEL_4;\n  }\n  v11 = 1LL;\n  LOBYTE(v23[0]) = byte_FFFFFFFF81EBF448;\n  v21 = sub_FFFFFFFF812C91D0(v19, 1, 1LL, v23);\n  if ( v21 )\n  {\nLABEL_4:\n    sub_FFFFFFFF815CFEE0(\n      (unsigned __int64)v19,\n      (volatile signed __int32 *)v11,\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8);\n    return v21;\n  }\n  *(_DWORD *)(v20 - 20) = *((_DWORD *)v19 + 52) + *((_DWORD *)v19 + 49) - (v20 - 20);\n  result = sub_FFFFFFFF81607160(\n             *(_QWORD *)(*(_QWORD *)(a10 + 40) + 192LL),\n             (unsigned __int64)v19,\n             *(unsigned int *)(a10 + 4),\n             64LL,\n             v15,\n             v16,\n             a1,\n             a2,\n             a3,\n             a4,\n             v17,\n             v18,\n             a7,\n             a8);\n  if ( (int)result > 0 )\n    return 0LL;\n  return result;\n}\n",
    "function_name": "netlbl_unlabel_list",
    "decompiled_code": "__int64 __fastcall netlbl_unlabel_list(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v11; // rsi\n  char *v12; // rax\n  __int64 *v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  char *v19; // rbx\n  __int64 v20; // r14\n  unsigned int v21; // r12d\n  __int64 result; // rax\n  __int64 v23[4]; // [rsp+7h] [rbp-21h] BYREF\n\n  v11 = 208LL;\n  v12 = (char *)_alloc_skb(3776, 0xD0u, 0, -1, a1, a2, a3, a4, a5, a6, a7, a8);\n  v19 = v12;\n  if ( !v12 )\n  {\n    v21 = -22;\n    goto LABEL_4;\n  }\n  v11 = *(unsigned int *)(a10 + 4);\n  v20 = genlmsg_put(v12, v11, *(_DWORD *)a10, netlbl_unlabel_gnl_family, 0, 2, a1, a2, a3, a4, v17, v18, a7, a8);\n  if ( !v20 )\n  {\n    v21 = -12;\n    goto LABEL_4;\n  }\n  v11 = 1LL;\n  LOBYTE(v23[0]) = netlabel_unlabel_acceptflg;\n  v21 = nla_put(v19, 1, 1, v23);\n  if ( v21 )\n  {\nLABEL_4:\n    kfree_skb(\n      (volatile signed __int32 *)v19,\n      (volatile signed __int32 *)v11,\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8);\n    return v21;\n  }\n  *(_DWORD *)(v20 - 20) = *((_DWORD *)v19 + 52) + *((_DWORD *)v19 + 49) - (v20 - 20);\n  result = netlink_unicast(\n             *(_QWORD *)(*(_QWORD *)(a10 + 40) + 192LL),\n             (__int64)v19,\n             *(_DWORD *)(a10 + 4),\n             64,\n             a1,\n             a2,\n             a3,\n             a4,\n             v17,\n             v18,\n             a7,\n             a8);\n  if ( (int)result > 0 )\n    return 0LL;\n  return result;\n}\n",
    "source_code": "static int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct sk_buff *ans_skb;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\tgoto list_failure;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\n\t\t\t\t 0, NLBL_UNLABEL_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u8(ans_skb,\n\t\t\t     NLBL_UNLABEL_A_ACPTFLG,\n\t\t\t     netlabel_unlabel_acceptflg);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}",
    "comment": "Generates and replies with a netlabel unlabeling response containing an acceptance flag in a netlink message or returns an error.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Generates and sends a Netlink message containing the protocol version in response to a management query .\n",
    "cpbcs_sum": "Retrieves and lists a network label domain mapping entry, responding to a Generic Netlink request within kernel space.\n",
    "misum_sum": "Retrieves the transmission and protocol of a network device based on the protocol version and protocol from the nl80211 protocol.\n",
    "decom_sum": "Initializes a device-specific structure, configures it with provided parameters, and communicates with the device, returning an error code or success status.",
    "cfg_sum": "Initializes a data structure with given parameters, performs setup and validation, applies configuration, and executes a final operation returning success or specific error codes.",
    "work_score": {
        "decom": {
            "summary": "Initializes a device-specific structure, configures it with provided parameters, and communicates with the device, returning an error code or success status.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains claims about initializing a device-specific structure, configuring with provided parameters, and communicating with a device, which are not supported by the source code. The actual function builds a netlink reply message with specific attributes and handles memory allocation errors; no device-specific structure or direct device communication occurs. All claims are inaccurate, resulting in no alignment with the code semantics.",
                "The summary's claims about initializing a device-specific structure, configuring it with provided parameters, and communicating with the device are inaccurate for the given source code. The function actually constructs a netlink reply message containing the netlabel unlabel accept flag and sends it back via generic netlink, with error handling for allocation and encoding failures. The core purpose of assembling and returning this specific netlabel information is not covered, and all claims in the summary target unrelated device operations rather than the actual networking message handling in the code.",
                "The summary's claims about initializing a device-specific structure, configuring it with provided parameters, and communicating with the device are inaccurate. The source code actually constructs a netlink message, adds attributes, and sends a reply for the netlabel unlabel list operation, with error handling. These FATAL inaccuracies target the core purpose and key I/O of the function, making the description misleading and untrustworthy."
            ]
        },
        "cfg": {
            "summary": "Initializes a data structure with given parameters, performs setup and validation, applies configuration, and executes a final operation returning success or specific error codes.",
            "score": [
                0.3,
                0.2,
                0.4
            ],
            "reason": [
                "The summary is overly generic and does not mention key domain-specific details from the source code such as use of nlmsg_new, genlmsg_put_reply, nla_put_u8 with netlabel_unlabel_acceptflg, or the structure being an sk_buff. While it loosely matches a pattern of initialization, validation, configuration, and returning error codes, it omits crucial context-specific behavior, making most claims low-info and not highly specific. This results in less than half of the claims being accurate in terms of precise code semantics.",
                "The summary provides only generic statements about initialization, setup, validation, and configuration without specifying the core operation. The source code\u2019s core purpose is to construct and send a netlabel unlabel list reply message via generic netlink, including the accept flag value and managing allocation failures. This specific domain behavior is absent, and while the summary mentions returning error codes, it omits all key details such as message creation, netlink specifics, constants used, and branch handling.",
                "The summary is overly generic and does not make specific, verifiable claims about the function's domain semantics. It omits key details such as creating a netlink message, adding the accept flag, handling memory allocation failures, and sending a reply. The claims about initialization, validation, configuration, and final operation are too broad, providing low informational value. There are no outright false statements, but noise is high and net benefit is minimal."
            ]
        },
        "comment": {
            "summary": "Generates and replies with a netlabel unlabeling response containing an acceptance flag in a netlink message or returns an error.",
            "score": [
                0.9,
                0.5,
                0.8
            ],
            "reason": [
                "The summary accurately captures the core behavior of the function: creating a netlink reply message, including the unlabel acceptance flag, and returning an error in failure cases. These elements are verifiable in the source code, and there are no incorrect or irrelevant claims present. The only slight shortcoming is that the summary omits specific error codes and the use of helper functions, but this does not affect overall precision.",
                "The summary correctly captures the core purpose of creating and returning a netlink response containing the acceptance flag, matching the code\u2019s specific domain action. It also notes the alternative of returning an error, reflecting the failure handling. However, it omits important secondary details such as the use of `nlmsg_new`, `genlmsg_put_reply`, exact error codes like `-EINVAL` and `-ENOMEM`, and cleanup via `kfree_skb`. Coverage of the core is accurate but secondary semantics are limited.",
                "The summary correctly identifies the function\u2019s primary purpose: generating and replying with a netlink message containing the unlabel acceptance flag, or returning an error if unable. This matches the source\u2019s construction of the message with `NLBL_UNLABEL_A_ACPTFLG` and use of `genlmsg_reply`, plus error handling on allocation steps. The claim is accurate, specific to the code\u2019s semantics, and there is no contradictory or irrelevant noise, though the description is moderately concise and lacks details about error conditions. Net benefit is positive but not maximized due to limited specificity beyond the core purpose."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4341728,
    "strip_function_name": "sub_423FE0",
    "strip_decompiled_code": "__int64 *__fastcall sub_423FE0(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rax\n  __int64 *result; // rax\n  char *v4; // rax\n\n  v1 = *(_QWORD *)(a1 + 8);\n  if ( (*(_BYTE *)a1 & 1) != 0 )\n  {\n    if ( qword_7EA588 == v1 )\n    {\n      a1 = *(_QWORD *)(a1 + 24);\n      v1 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v2 = sub_422EC0(a1);\n      v1 = *(_QWORD *)(v2 + 8);\n      a1 = v2;\n    }\n  }\n  result = (__int64 *)*(unsigned int *)(v1 + 24);\n  if ( (char)result >= 0 )\n  {\n    if ( (BYTE1(result) & 1) != 0 )\n    {\n      v4 = dcgettext(0LL, \"section symbols are already global\", 5);\n      return sub_4176A0(v4);\n    }\n    else\n    {\n      if ( (*(_BYTE *)a1 & 1) != 0 )\n      {\n        if ( v1 == qword_7EA588 && v1 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + 32LL) )\n        {\n          v1 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL);\n          return sub_417850(\"can't make register symbol `%s' global\", *(const char **)(v1 + 8));\n        }\n      }\n      else if ( *(_QWORD *)(v1 + 32) == qword_7EA588 )\n      {\n        return sub_417850(\"can't make register symbol `%s' global\", *(const char **)(v1 + 8));\n      }\n      LOBYTE(result) = (unsigned __int8)result & 0x7E;\n      result = (__int64 *)((unsigned int)result | 2);\n      *(_DWORD *)(v1 + 24) = (_DWORD)result;\n    }\n  }\n  return result;\n}\n",
    "function_name": "S_SET_EXTERNAL",
    "decompiled_code": "void __fastcall S_SET_EXTERNAL(symbolS *s)\n{\n  asymbol *bsym; // rdx\n  symbolS *v2; // rax\n  flagword flags; // eax\n  char *v4; // rax\n\n  bsym = s->bsym;\n  if ( (*(_BYTE *)&s->sy_flags & 1) != 0 )\n  {\n    if ( reg_section == (segT)bsym )\n    {\n      s = s->sy_value.X_op_symbol;\n      bsym = s->bsym;\n    }\n    else\n    {\n      v2 = (symbolS *)local_symbol_convert((__int64)s);\n      bsym = v2->bsym;\n      s = v2;\n    }\n  }\n  flags = bsym->flags;\n  if ( (flags & 0x80u) == 0 )\n  {\n    if ( (flags & 0x100) != 0 )\n    {\n      v4 = dcgettext(0LL, &byte_4F5ED0[480], 5);\n      as_warn(v4);\n    }\n    else\n    {\n      if ( (*(_BYTE *)&s->sy_flags & 1) != 0 )\n      {\n        if ( bsym == (asymbol *)reg_section && bsym == (asymbol *)s->sy_value.X_op_symbol->bsym->section )\n        {\n          bsym = s->sy_value.X_op_symbol->bsym;\nLABEL_10:\n          as_bad(&byte_4F5ED0[520], bsym->name);\n          return;\n        }\n      }\n      else if ( bsym->section == reg_section )\n      {\n        goto LABEL_10;\n      }\n      LOBYTE(flags) = flags & 0x7E;\n      bsym->flags = flags | 2;\n    }\n  }\n}\n",
    "source_code": "\nvoid\nS_SET_EXTERNAL (symbolS *s)\n{\n  if (LOCAL_SYMBOL_CHECK (s))\n    s = local_symbol_convert ((struct local_symbol *) s);\n  if ((s->bsym->flags & BSF_WEAK) != 0)\n    {\n      /* Let .weak override .global.  */\n      return;\n    }\n  if (s->bsym->flags & BSF_SECTION_SYM)\n    {\n      /* Do not reassign section symbols.  */\n      as_warn (_(\"section symbols are already global\"));\n      return;\n    }\n#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK\n  if (S_GET_SEGMENT (s) == reg_section)\n    {\n      as_bad (\"can't make register symbol `%s' global\",\n\t      S_GET_NAME (s));\n      return;\n    }\n#endif\n  s->bsym->flags |= BSF_GLOBAL;\n  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);\n\n#ifdef TE_PE\n  if (! an_external_name && S_GET_NAME(s)[0] != '.')\n    an_external_name = S_GET_NAME (s);\n#endif\n}",
    "comment": "Sets a symbol as global, overriding weak and local flags while preventing reassignment of section or register symbols.",
    "hext5_sum": "this function is called when we want to merge a new symbol with an existing symbol. it handles the various cases which arise when we find a definition in a dynamic object, or when there is already a definition in a dynamic object. the new symbol is described by name, sym, psec, and pvalue. we set sym_hash to the hash table entry. we set poldbfd to the old symbol's bfd. we set pold_weak if the old symbol was weak. we set pold_alignment to the alignment of an old common symbol. we set override if the old symbol is overriding a",
    "bint5_sum": "Retrieves or creates a section symbol for a given section , ensuring it is not already defined or already marked as global .\n",
    "cpbcs_sum": "Marks a symbol as thread-local if it is not already classified as its section and checks for valid section flags.\n",
    "misum_sum": "Marks a symbol as thread-local if it is not already classified and marks its segment as local if it is not already present.\n",
    "decom_sum": "Marks a section symbol as global unless it is a register symbol, reporting errors if it is already global or invalid for global status.",
    "cfg_sum": "Marks section symbols as global unless already global or register symbols, performing validation and returning error messages for invalid cases.",
    "work_score": {
        "decom": {
            "summary": "Marks a section symbol as global unless it is a register symbol, reporting errors if it is already global or invalid for global status.",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary misrepresents the code's behavior by stating it marks a section symbol as global, while the source explicitly avoids reassigning section symbols and instead warns about them. It omits key conditions such as handling weak symbols, converting local symbols, and not marking register symbols as global. Only a small portion regarding register symbol restriction is accurate, resulting in low alignment with the source semantics.",
                "The summary correctly notes that the function sets symbols to global and mentions error/reporting when invalid. However, it inaccurately states that section symbols are marked as global unless they are register symbols\u2014source code shows section symbols are not reassigned and only warnings are issued, and weak symbols are also skipped entirely. The core purpose of converting a symbol to global status with exceptions is partially captured but important conditions like skipping weak symbols, conversion for local symbols, and handling an_external_name are missing.",
                "The summary incorrectly describes the function\u2019s primary behavior: the code marks a symbol as global unless it is weak, a section symbol, or a register symbol, with warnings or errors for section symbols and register symbols. The summary inaccurately states that the function marks a section symbol as global, which contradicts the source as section symbols are explicitly not reassigned. This is a FATAL error on the primary purpose, making the output untrustworthy despite some partial mention of register symbol checks and error reporting."
            ]
        },
        "cfg": {
            "summary": "Marks section symbols as global unless already global or register symbols, performing validation and returning error messages for invalid cases.",
            "score": [
                0.2,
                0.3,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function marks section symbols as global unless already global or register symbols, when the source code actually avoids reassigning section symbols altogether and instead warns if they are already global. It accurately notes validation and error messaging for invalid cases like register symbols, but misses other behaviors such as handling LOCAL_SYMBOL_CHECK, weak symbols, and updating flags. Less than half of the claims are accurate.",
                "The summary correctly notes that section symbols can be marked as global and that validation/error handling occurs for invalid cases, which aligns with the code's behavior for section and register symbols. However, it misses the core primary purpose: setting a symbol's flags to BSF_GLOBAL while clearing BSF_LOCAL and BSF_WEAK, with specific conditions that prevent this for weak symbols, section symbols, and register symbols. The summary inaccurately implies that section symbols can be marked global unless already global, while the code explicitly prevents reassigning section symbols entirely. It omits mention of weak symbol handling and the TE_PE conditional external name assignment, resulting in incomplete coverage of critical branches and side effects.",
                "The summary incorrectly states that the function marks section symbols as global unless already global, when the code explicitly avoids making section symbols global and issues a warning instead. This is a FATAL inaccuracy about the primary purpose and key side effect. While the summary mentions validation and error messages for invalid cases (which matches register symbol checks), the major misstatement on section symbols directly misrepresents core behavior, making the description unreliable."
            ]
        },
        "comment": {
            "summary": "Sets a symbol as global, overriding weak and local flags while preventing reassignment of section or register symbols.",
            "score": [
                0.9,
                0.6,
                0.8
            ],
            "reason": [
                "The summary accurately describes the core function behavior: it sets a symbol as global, clears weak and local flags, and restricts reassignment of section or register symbols. These details match the source code\u2019s checks for BSF_WEAK, BSF_SECTION_SYM, and register symbols, with correct handling of flags. The coverage is high and free from contradictions, though it omits less critical conditions like local symbol conversion and TE_PE handling.",
                "The summary accurately identifies the core function purpose: setting a symbol as global and removing weak/local flags, and notes prevention of reassignment for section and register symbols. This matches the source code\u2019s conditional checks for `BSF_WEAK`, `BSF_SECTION_SYM`, and register section handling, thus covering the core domain action and key branch behaviors. However, it omits secondary details such as the early return when weak flag is set, the warning issued for section symbols, error reporting for register symbols, and the TE_PE-specific assignment to `an_external_name`. These omissions reduce completeness despite correct core coverage.",
                "The summary accurately captures the core purpose of the function: setting a symbol as global, overriding weak/local flags, and preventing reassignment of section or register symbols. All claims directly align with the source code logic, with no contradictions or irrelevant noise. While accurate, the description is relatively concise and omits some minor details (e.g., conversion of local symbols, conditional external name assignment), providing moderate rather than extensive insight."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5587923,
    "strip_function_name": "sub_5543D3",
    "strip_decompiled_code": "__int64 __fastcall sub_5543D3(\n        _DWORD *a1,\n        int a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  _BYTE *v11; // r13\n  __int64 v12; // rbp\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 result; // rax\n  int v20; // ebx\n  _BYTE *v21; // rax\n  _BYTE *v22; // r12\n  _DWORD v23[18]; // [rsp+0h] [rbp-48h] BYREF\n\n  v11 = a1;\n  v12 = a3;\n  if ( sub_400580(a3, 46LL) )\n  {\n    if ( (unsigned int)sub_554FD9(v23, v12, 2LL) )\n    {\nLABEL_3:\n      sub_517A10(\"\\\"%s\\\" is invalid lladdr\", v12, v13, v14, v15, v16, a4, a5, a6, a7, v17, v18, a10, a11, v23[0]);\n      return 0xFFFFFFFFLL;\n    }\n    result = 0xFFFFFFFFLL;\n    if ( a2 > 3 )\n    {\n      *a1 = v23[1];\n      return 4LL;\n    }\n  }\n  else\n  {\n    result = 1LL;\n    if ( a2 > 0 )\n    {\n      v20 = 0;\n      while ( 1 )\n      {\n        v21 = (_BYTE *)sub_400580(v12, 58LL);\n        v22 = v21;\n        if ( v21 )\n        {\n          *v21 = 0;\n          v22 = v21 + 1;\n        }\n        if ( (unsigned int)sub_441CB0(v12, (__int64)\"%x\", (unsigned int)v23) != 1 || v23[0] > 0xFFu )\n          break;\n        *v11 = v23[0];\n        if ( !v22 )\n          return (unsigned int)(v20 + 1);\n        ++v20;\n        ++v11;\n        if ( v20 == a2 )\n          return (unsigned int)(v20 + 1);\n        v12 = (__int64)v22;\n      }\n      goto LABEL_3;\n    }\n  }\n  return result;\n}\n",
    "function_name": "ll_addr_a2n",
    "decompiled_code": "__int64 __fastcall ll_addr_a2n(\n        _DWORD *a1,\n        int a2,\n        const char *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  _BYTE *v11; // r13\n  const char *v12; // rbp\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 result; // rax\n  int v20; // ebx\n  char *v21; // rax\n  char *v22; // r12\n  _DWORD v23[18]; // [rsp+0h] [rbp-48h] BYREF\n\n  v11 = a1;\n  v12 = a3;\n  if ( strchr(a3, 46) )\n  {\n    if ( (unsigned int)get_addr_1((__int64)v23, (__int64)v12, 2) )\n    {\nLABEL_3:\n      bb_error_msg(\n        (const __m128i *)\"\\\"%s\\\" is invalid lladdr\",\n        (__int64)v12,\n        v13,\n        v14,\n        v15,\n        v16,\n        a4,\n        a5,\n        a6,\n        a7,\n        v17,\n        v18,\n        a10,\n        a11,\n        v23[0]);\n      return 0xFFFFFFFFLL;\n    }\n    result = 0xFFFFFFFFLL;\n    if ( a2 > 3 )\n    {\n      *a1 = v23[1];\n      return 4LL;\n    }\n  }\n  else\n  {\n    result = 1LL;\n    if ( a2 > 0 )\n    {\n      v20 = 0;\n      while ( 1 )\n      {\n        v21 = strchr(v12, 58);\n        v22 = v21;\n        if ( v21 )\n        {\n          *v21 = 0;\n          v22 = v21 + 1;\n        }\n        if ( (unsigned int)sscanf((__int64)v12, (__int64)\"%x\", v23) != 1 || v23[0] > 0xFFu )\n          break;\n        *v11 = v23[0];\n        if ( !v22 )\n          return (unsigned int)(v20 + 1);\n        ++v20;\n        ++v11;\n        if ( v20 == a2 )\n          return (unsigned int)(v20 + 1);\n        v12 = v22;\n      }\n      goto LABEL_3;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint FAST_FUNC ll_addr_a2n(unsigned char *lladdr, int len, char *arg)\n{\n\tint i;\n\n\tif (strchr(arg, '.')) {\n\t\tinet_prefix pfx;\n\t\tif (get_addr_1(&pfx, arg, AF_INET)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 4) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(lladdr, pfx.data, 4);\n\t\treturn 4;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tint temp;\n\t\tchar *cp = strchr(arg, ':');\n\t\tif (cp) {\n\t\t\t*cp = 0;\n\t\t\tcp++;\n\t\t}\n\t\tif (sscanf(arg, \"%x\", &temp) != 1 || (temp < 0 || temp > 255)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tlladdr[i] = temp;\n\t\tif (!cp) {\n\t\t\tbreak;\n\t\t}\n\t\targ = cp;\n\t}\n\treturn i+1;\n}",
    "comment": "Converts a string representation of a link-layer address to its binary format, supporting both IPv4 addresses and hexadecimal notation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Parses a DHCP option string to extract IP address and netmask , adding it to a given IP address structure .\n",
    "cpbcs_sum": "The function decodes a string of specified IP address and stores it in a buffer, ensuring proper newline alignment and formatting.\n",
    "misum_sum": "Parses a string for a numerical number, validating the range of a valid IPv4 address and length, and stores it in a dynamically allocated structure.\n",
    "decom_sum": "Parses and validates a MAC address string, storing its bytes in the output buffer and reporting an error if the format or values are invalid.",
    "cfg_sum": "Parses and validates a MAC address string, storing bytes into the output buffer or returning an error if the format is invalid.",
    "work_score": {
        "decom": {
            "summary": "Parses and validates a MAC address string, storing its bytes in the output buffer and reporting an error if the format or values are invalid.",
            "score": [
                0.3,
                0.3,
                0.2
            ],
            "reason": [
                "The summary specifies parsing and validating a MAC address, but the source code also handles IPv4 address notation when a '.' is present. This means the summary omits important behavior and misrepresents the broader functionality. Although it correctly mentions validation, error reporting, and storing bytes in the output buffer, these are generic and partly accurate, with the core domain semantics inaccurately constrained to MAC-only parsing. Less than half of the claims are accurate.",
                "The summary correctly states that the function parses and validates an address string and stores bytes in an output buffer with error reporting, which aligns with core purpose of converting textual link-layer address formats into binary. However, it inaccurately narrows this to MAC addresses only, omitting that the function also handles IPv4 addresses with dotted-decimal notation, checks length constraints for IPv4, and parses colon-separated hex byte sequences. Several critical branch-specific behaviors are missing, such as the handling of periods in the address, the use of get_addr_1 for IPv4, and return value specifics. Core coverage is incomplete due to mischaracterization of address types.",
                "The summary incorrectly identifies the function as parsing a MAC address specifically, whereas the source code handles both IPv4 addresses (if containing '.') and generic byte sequences separated by colons, storing results in the provided buffer. This is a FATAL error about the primary purpose, as MAC parsing is only one possible format. Although some aspects such as validation and writing to the buffer are accurate, the core WHAT is misstated, making the description misleading for understanding the function\u2019s true behavior."
            ]
        },
        "cfg": {
            "summary": "Parses and validates a MAC address string, storing bytes into the output buffer or returning an error if the format is invalid.",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary claims the function parses and validates a MAC address string, but the source code shows it handles both IPv4 dotted-decimal notation (detected by '.') and colon-separated hex notation, storing up to 4 bytes for IPv4 or up to len bytes otherwise. The summary omits the IPv4 case entirely, making its primary claim inaccurate. Only part of its description (validation and storing bytes) is correct, resulting in less than half of the claims being accurate.",
                "The summary correctly states that the function parses and validates an address string into a byte buffer with error handling, which aligns with the source code's purpose of converting either IPv4 dotted decimal or colon-separated hexadecimal strings to a byte array. However, it inaccurately narrows the domain to MAC addresses only, missing the fact that IPv4 addresses are also supported, and omits key secondary details like handling different formats, length checks, and specific return values. The core is partially covered but overly specific and incomplete on secondary behaviors.",
                "The summary inaccurately describes the function as parsing a MAC address, while the source code handles both IPv4 addresses and sequences of hexadecimal byte values separated by colons. This misidentification affects the primary purpose of the function, which is core to its semantics, making it a severe factual error. Although it mentions validation and storing bytes correctly, the central claim is incorrect and undermines trust in the summary."
            ]
        },
        "comment": {
            "summary": "Converts a string representation of a link-layer address to its binary format, supporting both IPv4 addresses and hexadecimal notation.",
            "score": [
                1.0,
                0.4,
                0.8
            ],
            "reason": [
                "The summary correctly states that the function converts a string link-layer address to binary and supports IPv4 dotted notation and hexadecimal representation, both of which are evident from the code. These claims are domain-specific and accurately reflect the function's behavior, with no incorrect or irrelevant statements present.",
                "The summary correctly states that the function converts a string link-layer address to binary and supports IPv4 dotted decimal and hexadecimal notation, which matches the core purpose of parsing either an IPv4 address or colon-separated hex bytes into a byte array. However, it omits secondary details such as length checking, error handling when parsing fails or out-of-range values occur, and the specific return values based on address type. The core operation is covered but secondary behavior coverage is minimal.",
                "The summary accurately captures the primary purpose of the function: converting a string link-layer address to binary, noting support for IPv4 dotted-decimal and hexadecimal formats. These are correct and specific to the source code. There is no contradictory or irrelevant information, and noise is minimal. The claims are moderately specific, offering clear insight into the function's behavior without being overly generic."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579841792,
    "strip_function_name": "sub_FFFFFFFF810F3500",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810F3500(volatile signed __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  unsigned int v4; // r15d\n  _QWORD *v5; // rax\n  int v6; // ebx\n  __int64 v7; // rbx\n  __int64 *v8; // rbx\n  __int64 v9; // rcx\n  _BOOL8 v10; // [rsp-38h] [rbp-38h]\n\n  result = *(_QWORD *)a1;\n  if ( (*(_QWORD *)a1 & 0x20) != 0 )\n  {\n    result = *(_QWORD *)a1;\n    if ( (*(_QWORD *)a1 & 0x40) == 0 )\n    {\n      result = *(_QWORD *)a1;\n      if ( (*(_QWORD *)a1 & 0x100000) == 0 )\n      {\n        v3 = *((_QWORD *)a1 + 4);\n        v10 = (*(_QWORD *)a1 & 0x80000LL) == 0;\n        v4 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 4 : 2;\n        v5 = (_QWORD *)*((_QWORD *)a1 + 5);\n        v6 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 2 : 0;\n        *(_QWORD *)(v3 + 8) = v5;\n        *v5 = v3;\n        *((_QWORD *)a1 + 4) = 0xDEAD000000000100LL;\n        v7 = (unsigned int)(v6 + 1);\n        *((_QWORD *)a1 + 5) = 0xDEAD000000000200LL;\n        sub_FFFFFFFF81101110(a2 - 968, (unsigned int)v7, 0xFFFFFFFFLL);\n        _InterlockedOr8(a1, 0x40u);\n        v8 = (__int64 *)(a2 + 16 * v7);\n        v9 = *v8;\n        *(_QWORD *)(v9 + 8) = a1 + 32;\n        *((_QWORD *)a1 + 5) = v8;\n        *((_QWORD *)a1 + 4) = v9;\n        *v8 = (__int64)(a1 + 32);\n        sub_FFFFFFFF81101110(a2 - 968, v4, 1LL);\n        __incgsqword(0xDE08u);\n        result = a2 + 8 * v10;\n        ++*(_QWORD *)(result + 96);\n        ++*(_QWORD *)(result + 80);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "__activate_page",
    "decompiled_code": "__int64 __fastcall _activate_page(volatile signed __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  unsigned int v4; // r15d\n  _QWORD *v5; // rax\n  int v6; // ebx\n  __int64 v7; // rbx\n  __int64 *v8; // rbx\n  __int64 v9; // rcx\n  _BOOL8 v10; // [rsp-38h] [rbp-38h]\n\n  result = *(_QWORD *)a1;\n  if ( (*(_QWORD *)a1 & 0x20) != 0 )\n  {\n    result = *(_QWORD *)a1;\n    if ( (*(_QWORD *)a1 & 0x40) == 0 )\n    {\n      result = *(_QWORD *)a1;\n      if ( (*(_QWORD *)a1 & 0x100000) == 0 )\n      {\n        v3 = *((_QWORD *)a1 + 4);\n        v10 = (*(_QWORD *)a1 & 0x80000LL) == 0;\n        v4 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 4 : 2;\n        v5 = (_QWORD *)*((_QWORD *)a1 + 5);\n        v6 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 2 : 0;\n        *(_QWORD *)(v3 + 8) = v5;\n        *v5 = v3;\n        *((_QWORD *)a1 + 4) = 0xDEAD000000000100LL;\n        v7 = (unsigned int)(v6 + 1);\n        *((_QWORD *)a1 + 5) = 0xDEAD000000000200LL;\n        _mod_zone_page_state(a2 - 968, v7, -1);\n        _InterlockedOr8(a1, 0x40u);\n        v8 = (__int64 *)(a2 + 16 * v7);\n        v9 = *v8;\n        *(_QWORD *)(v9 + 8) = a1 + 32;\n        *((_QWORD *)a1 + 5) = v8;\n        *((_QWORD *)a1 + 4) = v9;\n        *v8 = (__int64)(a1 + 32);\n        _mod_zone_page_state(a2 - 968, v4, 1);\n        __incgsqword(0xDE08u);\n        result = a2 + 8 * v10;\n        ++*(_QWORD *)(result + 96);\n        ++*(_QWORD *)(result + 80);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}",
    "comment": "Activates a page by removing it from the LRU list and updating its status if it is inactive and eligible for activation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Deactivates an LRU page by removing it from the active list , updating its state , and potentially moving it to the inactive list .\n",
    "cpbcs_sum": "Deactivates an LRU page by removing it from the active list, updating its state, and potentially moving it to the inactive list.\n",
    "misum_sum": "Deactivates an LRU page by removing it from the active list, updating its state, and inserting it into the LRU list.\n",
    "decom_sum": "Re-links queue nodes, updates state flags and counters, and signals scheduler events when specific connection status bits are set.",
    "cfg_sum": "Updates linked data structures and global counters when specific status bits are set, performing synchronization and invoking helper routines under defined flag conditions.",
    "work_score": {
        "decom": {
            "summary": "Re-links queue nodes, updates state flags and counters, and signals scheduler events when specific connection status bits are set.",
            "score": [
                0.0,
                0.1,
                0.3
            ],
            "reason": [
                "The summary contains claims unrelated to the actual code semantics. It references queue nodes, scheduler events, and connection status bits, none of which exist in the provided function. The code operates on page structures in the LRU list, sets an active flag, updates counters/statistics, and does not involve networking or scheduler signaling. Therefore, none of the claims are accurate, resulting in no alignment with source code behavior.",
                "The summary does not cover the core purpose of activating a page by moving it from the inactive to active LRU list when certain conditions are met, nor does it mention page cache/file distinctions, list operations, or VM event/count updates. Instead, it inaccurately describes unrelated queue nodes, scheduler events, and connection status bits, which are not present in the source code, making the content irrelevant to the actual function.",
                "The summary describes actions involving queue nodes, connection status bits, and signaling scheduler events, which are unrelated to the source code's actual behavior. The function operates on memory pages, checking LRU state, updating flags, moving them between lists, and updating VM statistics. All claims in the summary are NOISE, with none accurately reflecting the code semantics. The worst failure mode is overwhelming NOISE, and there is no accurate information gain."
            ]
        },
        "cfg": {
            "summary": "Updates linked data structures and global counters when specific status bits are set, performing synchronization and invoking helper routines under defined flag conditions.",
            "score": [
                0.3,
                0.3,
                0.5
            ],
            "reason": [
                "The summary contains generic statements about updating data structures and counters under certain conditions but lacks specific and verifiable details from the source code, such as the exact flags checked (PageLRU, !PageActive, !PageUnevictable) or the helper routines invoked. These omissions make most claims low-info and only loosely accurate, resulting in less than half of the claims being precise domain-semantic matches to the function\u2019s behavior.",
                "The summary makes a very generic claim about updating data structures and counters under certain conditions, which is accurate in a broad sense but fails to specify the core purpose of the function: moving a page from the inactive LRU list to the active LRU list when it meets specific criteria. The essential domain semantics and key operations, such as checking PageLRU, PageActive, and PageUnevictable flags, recalculating LRU type, and invoking specific helper functions related to page activation, are omitted. Secondary behaviors like event counting and reclaim statistics updates are also only vaguely implied without concrete detail.",
                "The summary makes only a generic claim about updating data structures and counters under certain flag conditions, which loosely corresponds to the code but lacks specificity about the actual operations such as activating a page, modifying LRU lists, and the exact flags checked. No claims contradict the code, but the gain is low due to the abstract language and omission of key details, and noise is noticeable."
            ]
        },
        "comment": {
            "summary": "Activates a page by removing it from the LRU list and updating its status if it is inactive and eligible for activation.",
            "score": [
                0.9,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly states the function activates a page, removes it from the LRU list, and updates its status when the page is inactive and eligible, which matches the source code's conditional checks for LRU, not active, and not unevictable. It omits some minor details such as specific status flags set and event/stat updates, but the main semantics are accurately captured, resulting in a high proportion of accurate claims.",
                "The summary correctly identifies the core purpose of activating a page by removing it from the LRU list and updating its status when certain conditions are met, which matches the source code's main operation. However, it omits secondary details such as the specific conditions checked (e.g., not unevictable), the determination of file cache status, the change to the LRU type, and the updates to VM events and reclaim statistics. These omissions weaken coverage of other critical behaviors.",
                "The summary correctly states the primary purpose of the function: activating a page that is inactive and eligible, by removing it from the LRU list and updating its status. This matches the code's logic of checking PageLRU, !PageActive, and !PageUnevictable, then adjusting its LRU position and marking it active. However, the summary omits specific details about adding the page to the active LRU list, counting PGACTIVATE events, and updating reclaim stats. The omissions reduce the informational value, but there are no contradictory or irrelevant claims, meaning noise is low and accuracy is solid though generic."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585720688,
    "strip_function_name": "sub_FFFFFFFF8168E970",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8168E970(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  volatile signed __int32 *v17; // rdi\n  __int64 v18; // rsi\n  __int64 v19; // rdi\n  __int64 v20; // rdx\n  __int64 v21; // rcx\n  __int64 v22; // r8\n  int v23; // r9d\n\n  sub_FFFFFFFF815CFFC0(a1 + 112, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( *(_DWORD *)(a1 + 236) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 27);\n    sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 475, (__int64)v11, v12, v13, v14);\n    if ( !*(_QWORD *)(a1 + 64) )\n      goto LABEL_3;\n  }\n  else if ( !*(_QWORD *)(a1 + 64) )\n  {\n    goto LABEL_3;\n  }\n  a2 = (_DWORD *)(qword_1C0 + 28);\n  sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 476, (__int64)v11, v12, v13, v14);\nLABEL_3:\n  if ( *(_QWORD *)(a1 + 512) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 29);\n    sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 477, (__int64)v11, v12, v13, v14);\n  }\n  if ( (*(_QWORD *)(a1 + 208) & 1) == 0 )\n    return sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF81A16D80, a1, (_DWORD)v11, v12, v13, v14);\n  v17 = *(volatile signed __int32 **)(a1 + 632);\n  if ( v17 )\n  {\n    if ( !_InterlockedDecrement(v17) )\n      sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a3, a4, a5, a6, v15, v16, a9, a10, (__int64)a2, v11, v12, v13, v14);\n  }\n  _InterlockedDecrement64(&qword_FFFFFFFF81EB37E0);\n  sub_FFFFFFFF81043110();\n  v18 = *(_QWORD *)(a1 + 40);\n  v19 = *(_QWORD *)(a1 + 48);\n  sub_FFFFFFFF815C9370(v19, v18, 0xFFFFFFFF);\n  return sub_FFFFFFFF81043640(v19, v18, v20, v21, v22, v23);\n}\n",
    "function_name": "unix_sock_destructor",
    "decompiled_code": "unsigned __int64 __fastcall unix_sock_destructor(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 *v11; // rdx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 *v14; // rdi\n  __int64 v15; // rsi\n  const char *v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  skb_queue_purge(a1 + 112, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( *(_DWORD *)(a1 + 236) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 27);\n    warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DBu, a3, a4, a5, a6, v12, v13, a9, a10);\n    if ( !*(_QWORD *)(a1 + 64) )\n      goto LABEL_3;\n  }\n  else if ( !*(_QWORD *)(a1 + 64) )\n  {\n    goto LABEL_3;\n  }\n  a2 = (_DWORD *)(qword_1C0 + 28);\n  warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DCu, a3, a4, a5, a6, v12, v13, a9, a10);\nLABEL_3:\n  if ( *(_QWORD *)(a1 + 512) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 29);\n    warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DDu, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  if ( (*(_QWORD *)(a1 + 208) & 1) == 0 )\n    return printk((__int64)&unk_FFFFFFFF81A16D80, a3, a4, a5, a6, v12, v13, a9, a10, a1);\n  v14 = *(__int64 **)(a1 + 632);\n  if ( v14 )\n  {\n    if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )\n      kfree(v14, a3, a4, a5, a6, v12, v13, a9, a10, (__int64)a2, v11);\n  }\n  _InterlockedDecrement64(&unix_nr_socks);\n  local_bh_disable();\n  v15 = *(_QWORD *)(a1 + 40);\n  v16 = *(const char **)(a1 + 48);\n  sock_prot_inuse_add((__int64)v16, v15, 0xFFFFFFFF);\n  return local_bh_enable(v16, v15, a3, a4, a5, a6, v17, v18, a9, a10);\n}\n",
    "source_code": "\nstatic void unix_sock_destructor(struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(!sk_unhashed(sk));\n\tWARN_ON(sk->sk_socket);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tprintk(KERN_INFO \"Attempt to release alive unix socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tif (u->addr)\n\t\tunix_release_addr(u->addr);\n\n\tatomic_long_dec(&unix_nr_socks);\n\tlocal_bh_disable();\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n#ifdef UNIX_REFCNT_DEBUG\n\tprintk(KERN_DEBUG \"UNIX %p is destroyed, %ld are still alive.\\n\", sk,\n\t\tatomic_long_read(&unix_nr_socks));\n#endif\n}",
    "comment": "Destroys a Unix socket, purging its receive queue and decrementing the count of active sockets if the socket is marked as dead.",
    "hext5_sum": "p^1_{-1/2 + i lambda}",
    "bint5_sum": "Cleans up and frees resources associated with a Unix socket , including multicast addresses , credentials , and the socket structure itself .\n",
    "cpbcs_sum": "Cleans up the XFRM device by purging error queue and ensuring the socket is dead before decrementing its reference count.\n",
    "misum_sum": "Releases resources and cleans up a socket buffer if the socket is properly marked for proper cleanup.\n",
    "decom_sum": "Logs AF_UNIX socket state changes, decrements reference counters, performs cleanup, and finalizes resources when certain connection and flag conditions are met.",
    "cfg_sum": "Handles UNIX socket state verification, logs specific events, releases associated locks, decrements counters, performs resource cleanup, and executes final socket-related operations before returning.",
    "work_score": {
        "decom": {
            "summary": "Logs AF_UNIX socket state changes, decrements reference counters, performs cleanup, and finalizes resources when certain connection and flag conditions are met.",
            "score": [
                0.6,
                0.4,
                0.6
            ],
            "reason": [
                "The summary captures some accurate aspects of the code, such as logging socket state changes, decrementing reference counters, and performing cleanup. However, it inaccurately generalizes conditions by referring to 'connection and flag conditions' without specifying the actual checks present (like SOCK_DEAD and sk_unhashed). It omits key operations such as purging the receive queue and releasing bound addresses, and the phrasing around 'finalizes resources' is vague. Overall, the majority of claims are relevant but several are overly generic or imprecise, resulting in mixed reliability.",
                "The summary generally captures that the function logs socket state, decrements counters, and performs cleanup, aligning with the destructor\u2019s actions such as purging queues, releasing addresses, and adjusting reference counts. However, it fails to concretely cover the core primary purpose: destroying a UNIX domain socket with specific checks (alive socket condition via SOCK_DEAD, WARN_ON assertions, BH disable/enable) and associated resource finalization. It lacks specificity about the domain (UNIX socket teardown) and omits key branch/error handling and constants, making secondary coverage thin.",
                "The summary correctly notes cleanup, reference counter decrements, and logging, aligning with the source code behavior. However, it is too generic and omits key specifics such as purging the receive queue, WARN_ON checks, SOCK_DEAD flag verification, address release, and specific debug logging. There are no clear factual errors, but the lack of detailed domain-specific claims limits the gain, and the safe statements provide low insight. Noise is minimal, yet the accuracy is based on broad SAFE claims without GOLD-level detail."
            ]
        },
        "cfg": {
            "summary": "Handles UNIX socket state verification, logs specific events, releases associated locks, decrements counters, performs resource cleanup, and executes final socket-related operations before returning.",
            "score": [
                0.8,
                0.3,
                0.5
            ],
            "reason": [
                "The summary correctly notes socket state verification, logging, decrementing counters, and resource cleanup, which align with the code's WARN_ON checks, printk calls, atomic_long_dec, and release functions. However, it inaccurately states that the function releases associated locks\u2014no lock release occurs in the code\u2014so one claim is incorrect. Most claims reflect real code behavior, yielding a high proportion of accurate statements.",
                "The summary omits the core primary purpose, which is to destruct a UNIX socket by purging its receive queue, verifying its state, releasing its bound address, decrementing the global socket count, and updating protocol usage. While it mentions generic cleanup and state verification, it lacks concrete, domain-specific details like purging the receive queue, address release, and protocol usage accounting. Secondary aspects such as warning conditions, the early return if the socket is not dead, or specific counter updates are not clearly covered.",
                "The summary contains some accurate elements, such as verifying socket state, logging events, decrementing counters, and performing resource cleanup, which match the code. However, it introduces an inaccurate claim about releasing associated locks, which is not present in the function, and omits specific details like purging the receive queue and protocol usage decrement operations. The inaccuracies are noise rather than fatal, but they reduce specificity, and most claims are generic with limited technical insight."
            ]
        },
        "comment": {
            "summary": "Destroys a Unix socket, purging its receive queue and decrementing the count of active sockets if the socket is marked as dead.",
            "score": [
                0.7,
                0.5,
                0.7
            ],
            "reason": [
                "The summary correctly captures that the function destroys a Unix socket, purges its receive queue, and decrements the global count when the socket is marked dead, which matches the conditional `sock_flag(sk, SOCK_DEAD)` and `atomic_long_dec(&unix_nr_socks)` in the source. However, it omits several accurate, domain-specific behaviors, such as warning checks, releasing the socket address, and protocol usage count adjustments, giving a partially complete depiction of the semantics.",
                "The summary accurately covers the core purpose of destroying a Unix socket and includes the requirement that it be marked dead, as well as purging the receive queue and decrementing the socket count. However, it omits several secondary details present in the code, such as warning checks for memory allocations, unhashed status, and presence of sk_socket, the printk for alive sockets, releasing bound addresses, protocol in-use adjustments, and conditional debug logging. These omissions reduce coverage of critical secondary behaviors.",
                "The summary captures the primary purpose (destroying a Unix socket) and two key behaviors (purging the receive queue and decrementing active socket count only if dead), both of which are clearly reflected in the source code. While it omits other details like WARN_ON checks, address release, and protocol usage counters, there are no inaccurate or contradictory claims, and noise is minimal. The gain is moderate due to its brevity and limited coverage of distinct code actions."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 682751,
    "strip_function_name": "sub_A6AFF",
    "strip_decompiled_code": "__int64 __fastcall sub_A6AFF(__int64 a1, int a2, int a3, int *a4)\n{\n  int v5; // eax\n  int v7; // [rsp+24h] [rbp-13Ch]\n  int i; // [rsp+28h] [rbp-138h]\n  int v9; // [rsp+2Ch] [rbp-134h]\n  void *v10; // [rsp+38h] [rbp-128h]\n  void *dest; // [rsp+48h] [rbp-118h]\n  _BYTE src[264]; // [rsp+50h] [rbp-110h] BYREF\n  unsigned __int64 v13; // [rsp+158h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( a2 != 6 )\n    return 38LL;\n  if ( a3 == 1 )\n  {\n    if ( !a4 )\n      return 22LL;\n    v7 = 0;\n    v9 = *a4;\n    for ( i = 0; i <= 255; ++i )\n    {\n      if ( (unsigned int)i <= 0x7F && (v9 & mu_c_tab[i]) != 0 )\n      {\n        v5 = v7++;\n        src[v5] = i;\n      }\n    }\n    v10 = malloc(v7);\n    if ( !v10 )\n      return 12LL;\n    memcpy(v10, src, v7);\n    sub_A6985(a1);\n    *(_QWORD *)(a1 + 248) = v10;\n    *(_QWORD *)(a1 + 256) = v7;\n    return 0LL;\n  }\n  if ( a3 <= 1 )\n  {\n    if ( a3 )\n      return 38LL;\n    if ( a4 )\n    {\n      dest = malloc(*((_QWORD *)a4 + 1));\n      if ( !dest )\n        return 12LL;\n      memcpy(dest, *(const void **)a4, *((_QWORD *)a4 + 1));\n      sub_A6985(a1);\n      *(_QWORD *)(a1 + 248) = dest;\n      *(_QWORD *)(a1 + 256) = *((_QWORD *)a4 + 1);\n    }\n    else\n    {\n      sub_A6985(a1);\n    }\n    return 0LL;\n  }\n  if ( a3 != 2 )\n  {\n    if ( a3 != 3 )\n      return 38LL;\n    *(_DWORD *)(a1 + 232) &= ~1u;\n    *(_QWORD *)(a1 + 152) = 0LL;\n    return 0LL;\n  }\n  if ( a4 )\n    return sub_A6AAA(a1, *(_QWORD *)a4);\n  else\n    return 22LL;\n}\n",
    "function_name": "_nullstream_ctl",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nint __cdecl nullstream_ctl(_mu_stream *str, int code, int opcode, void *arg)\n{\n  int v5; // eax\n  int cnt; // [rsp+24h] [rbp-13Ch]\n  int i; // [rsp+28h] [rbp-138h]\n  int classa; // [rsp+2Ch] [rbp-134h]\n  char *p_0; // [rsp+38h] [rbp-128h]\n  char *p; // [rsp+48h] [rbp-118h]\n  char buf[264]; // [rsp+50h] [rbp-110h] BYREF\n  unsigned __int64 v13; // [rsp+158h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( code != 6 )\n    return 38;\n  if ( opcode == 1 )\n  {\n    if ( !arg )\n      return 22;\n    cnt = 0;\n    classa = *(_DWORD *)arg;\n    for ( i = 0; i <= 255; ++i )\n    {\n      if ( (unsigned int)i <= 0x7F && (classa & mu_c_tab[i]) != 0 )\n      {\n        v5 = cnt++;\n        buf[v5] = i;\n      }\n    }\n    p_0 = (char *)malloc(cnt);\n    if ( !p_0 )\n      return 12;\n    memcpy(p_0, buf, cnt);\n    nullstream_free_pattern((_mu_nullstream *)str);\n    str[1].buffer = p_0;\n    str[1].level = cnt;\n    return 0;\n  }\n  if ( opcode <= 1 )\n  {\n    if ( opcode )\n      return 38;\n    if ( arg )\n    {\n      p = (char *)malloc(*((_QWORD *)arg + 1));\n      if ( !p )\n        return 12;\n      memcpy(p, *(const void **)arg, *((_QWORD *)arg + 1));\n      nullstream_free_pattern((_mu_nullstream *)str);\n      str[1].buffer = p;\n      str[1].level = *((_QWORD *)arg + 1);\n    }\n    else\n    {\n      nullstream_free_pattern((_mu_nullstream *)str);\n    }\n    return 0;\n  }\n  if ( opcode != 2 )\n  {\n    if ( opcode != 3 )\n      return 38;\n    str[1].ref_count &= ~1u;\n    str->size = 0LL;\n    return 0;\n  }\n  if ( arg )\n    return nullstream_truncate(str, *(_QWORD *)arg);\n  else\n    return 22;\n}\n",
    "source_code": "\nstatic int\n_nullstream_ctl (struct _mu_stream *str, int code, int opcode, void *arg)\n{\n  struct _mu_nullstream *np = (struct _mu_nullstream *)str;\n\n  if (code != MU_IOCTL_NULLSTREAM)\n    /* Only this code is supported */\n    return ENOSYS;\n  switch (opcode)\n    {\n    case MU_IOCTL_NULLSTREAM_SET_PATTERN:\n      if (!arg)\n\t_nullstream_free_pattern (np);\n      else\n\t{\n\t  struct mu_nullstream_pattern *pat = arg;\n\t  char *p;\n\t  \n\t  p = malloc (pat->size);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, pat->pattern, pat->size);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = pat->size;\n\t}\n      break;\n\n    case MU_IOCTL_NULLSTREAM_SET_PATCLASS:\n      if (!arg)\n\treturn EINVAL;\n      else\n\t{\n\t  char buf[256];\n\t  int cnt = 0, i;\n\t  int class = *(int*)arg;\n\t  char *p;\n\t  \n\t  for (i = 0; i < 256; i++)\n\t    {\n\t      if (mu_c_is_class (i, class))\n\t\tbuf[cnt++] = i;\n\t    }\n\n\t  p = malloc (cnt);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, buf, cnt);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = cnt;\n\t}\n      break;\n\t  \n    case MU_IOCTL_NULLSTREAM_SETSIZE:\n      if (!arg)\n\treturn EINVAL;\n      else\n\treturn _nullstream_truncate (str, *(mu_off_t*)arg);\n      break;\n\n    case MU_IOCTL_NULLSTREAM_CLRSIZE:\n      np->mode &= ~MU_NULLSTREAM_SIZE;\n      np->base.size = NULL;\n      break;\n      \n    default:\n      return ENOSYS;\n    }\n  return 0;\n}",
    "comment": "Handles control operations for a nullstream, including setting patterns, pattern classes, and managing size-related functionalities.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Handles socket options for IPv6 , including multicast membership , source filtering , and destination filtering , while ensuring proper state management and error handling .\n",
    "cpbcs_sum": "Manages a configuration file by setting, clearing, start and end positions based on specified flags, and count, returning appropriate status codes based on node types.\n",
    "misum_sum": "Sets a value in a specified environment by converting a character array to a long integer and handling errors appropriately.\n",
    "decom_sum": "Configures and updates a data structure\u2019s byte filter or buffer based on mode and input parameters, allocating memory and copying data as required.",
    "cfg_sum": "Processes configuration commands based on mode, allocating or copying memory for data bytes, updating internal state, and returning specific error or success codes.",
    "work_score": {
        "decom": {
            "summary": "Configures and updates a data structure\u2019s byte filter or buffer based on mode and input parameters, allocating memory and copying data as required.",
            "score": [
                0.5,
                0.2,
                0.4
            ],
            "reason": [
                "The summary makes generic claims about configuring and updating a data structure's filter or buffer with memory allocation and copying, which loosely aligns with some operations in the source code (setting patterns or pattern classes). However, it lacks specificity about the ioctl codes, error handling, and multiple distinct operations (clear size, set size) that are present. The description omits critical control-flow and domain-specific details, making the coverage incomplete. Only part of the content is accurately reflected, with over half being vague rather than precise code semantics.",
                "The summary vaguely describes configuring a data structure\u2019s byte filter or buffer but does not accurately capture the core purpose of handling specific MU_IOCTL_NULLSTREAM control codes for a nullstream, such as setting patterns, pattern classes, size, or clearing size. It misses the domain\u2010specific semantics and error handling present in the source code, providing only a generic depiction without covering the detailed operations or core intent.",
                "The summary is overly generic and fails to capture the specific semantics of the function, such as handling distinct opcodes for setting a pattern, pattern class, size, or clearing size, and returning ENOSYS or EINVAL on invalid parameters. While it hints at memory allocation and copying data, it omits key control codes, condition checks, and error handling behaviors. This results in mostly low-info SAFE claims and significant NOISE, with no FATAL inaccuracies but poor coverage of the primary purpose."
            ]
        },
        "cfg": {
            "summary": "Processes configuration commands based on mode, allocating or copying memory for data bytes, updating internal state, and returning specific error or success codes.",
            "score": [
                0.8,
                0.2,
                0.5
            ],
            "reason": [
                "The summary contains generic statements about processing commands, memory allocation, state updates, and returning codes, which loosely match the code behavior but lack specificity about the supported opcodes, conditions, and exact handling. It omits key details like required argument checks, specific MU_IOCTL_NULLSTREAM cases, and error types such as ENOSYS, ENOMEM, and EINVAL. Most claims are safe but low-information, with minimal risk of inaccuracy, resulting in high proportion accurate but not deeply precise.",
                "The summary contains generic phrases about processing commands, memory allocation, state updates, and returning codes, which are [ACCURATE] in a broad sense but lack the specific core action: handling MU_IOCTL_NULLSTREAM opcodes to configure pattern data, pattern classes, stream size, or clear size. Without explicitly covering the ioctl-based nullstream control and its domain-specific behaviors, the core purpose is not represented, and no detailed branches or specific constants are mentioned.",
                "The summary gives a generic description of processing configuration commands, allocating/copying memory, updating state, and returning codes, which is broadly accurate but lacks specific details from the source code such as supported opcodes, argument validation, and exact changes to internal fields. There is no contradictory or clearly false statement, but the coverage is generic SAFE claims with low informational value, offering little specific insight. The worst failure mode is low gain from accurate but overly broad statements."
            ]
        },
        "comment": {
            "summary": "Handles control operations for a nullstream, including setting patterns, pattern classes, and managing size-related functionalities.",
            "score": [
                0.9,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly states that the function handles control operations for a nullstream, mentioning setting patterns, pattern classes, and managing size-related functionalities, all of which are explicitly implemented in the source code. However, it omits specific details such as input validation, error codes returned for unsupported operations, and the clear function codes used, making it accurate but generic and lacking in precision on the domain semantics.",
                "The summary correctly identifies that the function deals with nullstream control operations, including setting patterns, pattern classes, and size management, aligning with the core purpose of handling MU_IOCTL_NULLSTREAM opcodes. However, it lacks specific details about error handling for invalid arguments, memory allocation failures, and how patterns are constructed from character classes, which reduces coverage of secondary, behavior-critical aspects.",
                "The summary correctly captures the core purpose of the function\u2014handling control operations for a nullstream, and mentions setting patterns, pattern classes, and size management. These are accurate, domain-specific aspects of the code. However, the claims are broad and omit specifics such as the error handling for invalid arguments, the distinction between setting a size and clearing it, and the related opcodes. There is no inaccurate or contradictory information, but the gain is low due to the lack of detail, resulting in limited utility for engineers."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 872080,
    "strip_function_name": "sub_D4E90",
    "strip_decompiled_code": "__int64 __fastcall sub_D4E90(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)\n{\n  __int64 v4; // r13\n  int *v5; // r15\n  unsigned __int64 v6; // r14\n  unsigned __int8 *v7; // r12\n  __int64 v8; // r13\n  __int64 v10; // rsi\n  unsigned __int8 *v11; // rdi\n  __int64 v12; // rdx\n  unsigned __int64 v13; // rax\n  unsigned __int8 *v15; // [rsp+8h] [rbp-60h]\n  __int64 v16; // [rsp+18h] [rbp-50h]\n  unsigned __int8 *v17; // [rsp+20h] [rbp-48h]\n\n  v4 = a1;\n  v16 = a2;\n  v17 = a3;\n  if ( a4 <= 0x3FFFFFFFFFFFFFFFLL )\n  {\n    v12 = a4;\n  }\n  else\n  {\n    v5 = (int *)(a1 + 88);\n    v6 = a4;\n    v7 = a3;\n    v15 = (unsigned __int8 *)(a1 + 40);\n    v8 = a2;\n    do\n    {\n      v10 = v8;\n      v11 = v7;\n      v8 += 0x4000000000000000LL;\n      v7 += 0x4000000000000000LL;\n      DES_ede3_cfb64_encrypt(\n        v11,\n        v10,\n        0x4000000000000000LL,\n        *(_QWORD *)(a1 + 120),\n        *(_QWORD *)(a1 + 120) + 128LL,\n        *(_QWORD *)(a1 + 120) + 256LL,\n        v15,\n        v5,\n        *(unsigned int *)(a1 + 16));\n      v6 -= 0x4000000000000000LL;\n    }\n    while ( v6 > 0x3FFFFFFFFFFFFFFFLL );\n    v4 = a1;\n    v12 = a4 & 0x3FFFFFFFFFFFFFFFLL;\n    v13 = (((a4 - 0x4000000000000000LL) >> 62) + 1) << 62;\n    v17 += v13;\n    v16 += v13;\n  }\n  if ( v12 )\n    DES_ede3_cfb64_encrypt(\n      v17,\n      v16,\n      v12,\n      *(_QWORD *)(v4 + 120),\n      *(_QWORD *)(v4 + 120) + 128LL,\n      *(_QWORD *)(v4 + 120) + 256LL,\n      (unsigned __int8 *)(v4 + 40),\n      (int *)(v4 + 88),\n      *(unsigned int *)(v4 + 16));\n  return 1LL;\n}\n",
    "function_name": "des_ede_cfb64_cipher",
    "decompiled_code": "__int64 __fastcall des_ede_cfb64_cipher(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)\n{\n  __int64 v4; // r13\n  int *v5; // r15\n  unsigned __int64 v6; // r14\n  unsigned __int8 *v7; // r12\n  __int64 v8; // r13\n  __int64 v10; // rsi\n  unsigned __int8 *v11; // rdi\n  __int64 v12; // rdx\n  unsigned __int64 v13; // rax\n  unsigned __int8 *v15; // [rsp+8h] [rbp-60h]\n  __int64 v16; // [rsp+18h] [rbp-50h]\n  unsigned __int8 *v17; // [rsp+20h] [rbp-48h]\n\n  v4 = a1;\n  v16 = a2;\n  v17 = a3;\n  if ( a4 <= 0x3FFFFFFFFFFFFFFFLL )\n  {\n    v12 = a4;\n  }\n  else\n  {\n    v5 = (int *)(a1 + 88);\n    v6 = a4;\n    v7 = a3;\n    v15 = (unsigned __int8 *)(a1 + 40);\n    v8 = a2;\n    do\n    {\n      v10 = v8;\n      v11 = v7;\n      v8 += 0x4000000000000000LL;\n      v7 += 0x4000000000000000LL;\n      DES_ede3_cfb64_encrypt(\n        v11,\n        v10,\n        0x4000000000000000LL,\n        *(_DWORD **)(a1 + 120),\n        (_DWORD *)(*(_QWORD *)(a1 + 120) + 128LL),\n        (_DWORD *)(*(_QWORD *)(a1 + 120) + 256LL),\n        v15,\n        v5,\n        *(unsigned int *)(a1 + 16));\n      v6 -= 0x4000000000000000LL;\n    }\n    while ( v6 > 0x3FFFFFFFFFFFFFFFLL );\n    v4 = a1;\n    v12 = a4 & 0x3FFFFFFFFFFFFFFFLL;\n    v13 = (((a4 - 0x4000000000000000LL) >> 62) + 1) << 62;\n    v17 += v13;\n    v16 += v13;\n  }\n  if ( v12 )\n    DES_ede3_cfb64_encrypt(\n      v17,\n      v16,\n      v12,\n      *(_DWORD **)(v4 + 120),\n      (_DWORD *)(*(_QWORD *)(v4 + 120) + 128LL),\n      (_DWORD *)(*(_QWORD *)(v4 + 120) + 256LL),\n      (unsigned __int8 *)(v4 + 40),\n      (int *)(v4 + 88),\n      *(unsigned int *)(v4 + 16));\n  return 1LL;\n}\n",
    "source_code": "\nstatic int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n\t\t\t      const unsigned char *in, size_t inl)\n{\n\twhile (inl>=EVP_MAXCHUNK)\n\t\t{\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, \n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n\t\t\t       (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\t\tinl-=EVP_MAXCHUNK;\n\t\tin +=EVP_MAXCHUNK;\n\t\tout+=EVP_MAXCHUNK;\n\t\t}\n\tif (inl)\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)inl,\n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n                               (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\treturn 1;\n}",
    "comment": "Encrypts input data using Triple DES in CFB64 mode, processing it in chunks of EVP_MAXCHUNK size.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Encrypts input data using DES in CFB mode , processing it in chunks and updating the cipher context accordingly .\n",
    "cpbcs_sum": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
    "misum_sum": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
    "decom_sum": "Encrypts data of arbitrary length using 3DES in CFB64 mode, processing large inputs in 2^62-byte chunks with maintained key and IV state.",
    "cfg_sum": "Encrypts data using Triple DES in CFB64 mode, processing large input in chunks while maintaining and updating encryption state.",
    "work_score": {
        "decom": {
            "summary": "Encrypts data of arbitrary length using 3DES in CFB64 mode, processing large inputs in 2^62-byte chunks with maintained key and IV state.",
            "score": [
                0.5,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly identifies that the function encrypts arbitrary-length data using 3DES in CFB64 mode, and that key and IV state are maintained. However, it inaccurately claims processing is done in 2^62-byte chunks; the code clearly uses EVP_MAXCHUNK as the chunk size, which is not specified and certainly not 2^62 bytes. This significant error reduces accuracy, resulting in only partial alignment with source semantics.",
                "The summary correctly identifies that the function encrypts data using 3DES in CFB64 mode and that it preserves key and IV state, which matches the core purpose of the code. However, it inaccurately states the chunk size as 2^62 bytes instead of the actual constant EVP_MAXCHUNK from the code, and does not cover the loop logic that processes data until fewer than EVP_MAXCHUNK bytes remain. Secondary behaviors like handling partial final blocks and returning success are only partially reflected.",
                "The summary correctly identifies that the function encrypts data using 3DES in CFB64 mode and that key/IV state is maintained across chunks, which matches the source. However, it inaccurately states the chunk size as 2^62 bytes, while the code clearly uses EVP_MAXCHUNK (a smaller constant, typically much less than 2^62). This is a FATAL error affecting the PRIMARY PURPOSE\u2019s key I/O detail, making the description untrustworthy despite some accurate elements."
            ]
        },
        "cfg": {
            "summary": "Encrypts data using Triple DES in CFB64 mode, processing large input in chunks while maintaining and updating encryption state.",
            "score": [
                1.0,
                0.6,
                0.9
            ],
            "reason": [
                "The summary correctly identifies that the function uses Triple DES in CFB64 mode and processes large input in chunks, which aligns with the source code calling DES_ede3_cfb64_encrypt in loops using EVP_MAXCHUNK. It also accurately notes maintenance of encryption state via context variables such as iv and num. All claims are supported by the code, with no inaccuracies present.",
                "The summary correctly identifies that the function encrypts data using Triple DES in CFB64 mode and notes chunked processing with state maintenance, which matches the core domain behavior evident in the code. The core purpose of performing Triple DES CFB64 encryption with chunk handling is clearly covered. However, secondary details such as specific chunk size (EVP_MAXCHUNK), handling of remaining bytes, and use of internal key schedules and IV are absent, making coverage of behavior-critical semantics incomplete.",
                "The summary contains accurate GOLD-level claims: it correctly identifies that the function uses Triple DES in CFB64 mode, processes large input in chunks using EVP_MAXCHUNK, and maintains/updates encryption state through the DES_ede3_cfb64_encrypt calls and IV/num variables. There is no noise or inaccurate information, and the claims directly reflect the primary purpose of the code, offering high informational value."
            ]
        },
        "comment": {
            "summary": "Encrypts input data using Triple DES in CFB64 mode, processing it in chunks of EVP_MAXCHUNK size.",
            "score": [
                1.0,
                0.6,
                0.6
            ],
            "reason": [
                "The summary correctly identifies that the function uses Triple DES in CFB64 mode and processes input in chunks of EVP_MAXCHUNK, which matches the source code\u2019s use of DES_ede3_cfb64_encrypt and loop logic. All stated facts are accurate and directly reflect the code\u2019s semantics, with no incorrect or irrelevant claims present.",
                "The summary correctly identifies the core operation as encrypting with Triple DES in CFB64 mode and notes chunked processing via EVP_MAXCHUNK, which matches the source code\u2019s domain semantics. However, it omits details about handling any remaining bytes after full chunks, the use of three separate key schedules (ks1, ks2, ks3), maintenance of the IV and num state, and the unconditional success return value. These missing points limit secondary coverage despite accurately covering the core purpose.",
                "The summary accurately states the core purpose of the function: performing encryption using Triple DES in CFB64 mode and processing data in EVP_MAXCHUNK-sized chunks, which matches the source code behavior. There is no contradictory or irrelevant information (no FATAL or excessive NOISE), but the description is generic and lacks additional details such as handling of partial chunks and use of internal key schedules, resulting in low informational gain."
            ]
        }
    }
}
