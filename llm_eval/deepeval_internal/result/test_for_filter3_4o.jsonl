{
    "source_code": "static int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D; /* The absolute value is stored. */\n  long Q;\n  mp_limb_t tl;\n\n  /* Test on the absolute value. */\n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */\n  if (mpz_root (Qk, n, 2))\n    return 0; /* A square is composite. */\n\n  /* Check Ds up to square root (in case, n is prime)\n     or avoid overflows */\n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */\n  /* For those Ds we have (D/n) = (n/|D|) */\n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */\n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */\n  b0 = mpz_scan0 (n, 0);\n\n  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */\n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t/* If Ud != 0 */\n    while (V->_mp_size != 0 && --b0 != 0)\t/* while Vk != 0 */\n      /* V <- V ^ 2 - 2Q^k */\n      /* Q^{2k} = (Q^k)^2 */\n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}",
    "comment": "Determines if an odd integer is prime using the Lucas-Lehmer test and computes the Lucas sequence value based on specific parameters.",
    "prorec_sum": "Performs a strong Lucas primality test on a given large integer using mini-GMP routines to determine if it is prime.",
    "filter_prorec_sum": "Checks if a given large integer is an odd prime using a strong Lucas primality test implementation from the mini-GMP library.",
    "prorec_aug_sum": "Performs a strong Lucas probable prime test on a given odd number using mini-gmp functions and returns the primality result.",
    "filter_prorec_aug_sum": "Performs a strong Lucas primality test on a given odd multi-precision integer using mini-GMP functions and returns the result.",
    "work_score": {
        "prorec": {
            "summary": "Performs a strong Lucas primality test on a given large integer using mini-GMP routines to determine if it is prime.",
            "score": [
                0.3380173179335941,
                0.4658414009278583,
                0.46127798172629736
            ],
            "reason": [
                "The summary contains one main claim: that the function performs a strong Lucas primality test using mini-GMP routines to determine if a number is prime. This claim is partially accurate as the function indeed implements a Lucas test, but the summary lacks specificity and omits key details such as the handling of specific variables and conditions within the function. Additionally, the summary does not mention the function's behavior when encountering composite numbers or the specific steps involved in the test, which are crucial for a complete understanding. Therefore, less than 50% of the claims are accurate.",
                "The summary correctly identifies the core purpose of the function as performing a strong Lucas primality test, which aligns with the core operation of the source code. However, it lacks coverage of secondary details such as the specific steps involved in the test, like checking the square root, handling different values of D, and the use of mini-GMP routines for specific operations. The summary does not mention error handling or edge cases, which are present in the source code.",
                "The summary correctly identifies the function as performing a Lucas primality test, which is a specific and accurate claim. However, it inaccurately states that the function determines if the integer is prime, which is not explicitly confirmed by the source code. The function checks for compositeness and returns a boolean-like result, but the summary oversimplifies this behavior. The claim about using mini-GMP routines is generic and does not provide additional insight. Overall, the summary contains both accurate and inaccurate elements, with the inaccuracies not being severe enough to be considered FATAL, but noticeable enough to limit the net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Checks if a given large integer is an odd prime using a strong Lucas primality test implementation from the mini-GMP library.",
            "score": [
                0.7026385079191544,
                0.34842843039923366,
                0.5631574883983509
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking if a given large integer is an odd prime using a strong Lucas primality test. This aligns with the source code, which implements a strong Lucas test for primality. The mention of 'mini-GMP library' is not directly verifiable from the source code provided, but it does not contradict the function's behavior. Therefore, the summary is mostly accurate with a minor non-verifiable detail.",
                "The summary correctly identifies the use of a strong Lucas primality test, which aligns with the core purpose of the function. However, it inaccurately claims the function checks if an integer is an odd prime, while the function actually checks for composite numbers and returns based on specific conditions. The summary lacks coverage of secondary details such as the handling of square numbers, the search for a suitable D, and the iterative process involving Lucas sequences.",
                "The summary correctly identifies the function as implementing a strong Lucas primality test, which is a specific and accurate claim. However, it inaccurately states that the function checks if a given integer is an odd prime, which is misleading as the function returns 0 for composite squares and does not directly confirm primality. This introduces noise, but not to an overwhelming extent. The accurate claim provides some insight, but the noise limits the overall benefit."
            ]
        }
    }
}
{
    "source_code": "\n\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret = 0;\n\tBN_CTX *new_ctx = NULL;\n\t\n\tif (p != NULL)\n\t\t{\n\t\tif (!BN_copy(p, &group->field)) return 0;\n\t\t}\n\n\tif (a != NULL || b != NULL)\n\t\t{\n\t\tif (group->meth->field_decode)\n\t\t\t{\n\t\t\tif (ctx == NULL)\n\t\t\t\t{\n\t\t\t\tctx = new_ctx = BN_CTX_new();\n\t\t\t\tif (ctx == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(a, &group->a)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(b, &group->b)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tret = 1;\n\t\n err:\n\tif (new_ctx)\n\t\tBN_CTX_free(new_ctx);\n\treturn ret;\n\t}",
    "comment": "Retrieves the elliptic curve parameters (field, a, and b) from the specified EC_GROUP structure into provided BIGNUM variables.",
    "prorec_sum": "Retrieves the prime field curve parameters a, b, and p from an EC group, using BN_copy or group-specific methods with optional BN_CTX management.",
    "filter_prorec_sum": "Retrieves the elliptic curve parameters a, b, and field prime from a GFp group, using BN_copy or a method callback with optional BN_CTX.",
    "prorec_aug_sum": "Retrieves the curve parameters a, b, and field modulus from a GFp EC_GROUP, using BN_copy or method-specific operations with optional BN_CTX management.",
    "filter_prorec_aug_sum": "Retrieves the elliptic curve group parameters a, b, and field modulus into supplied BIGNUMs, using method-specific or direct BN_copy operations with optional BN_CTX.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves the prime field curve parameters a, b, and p from an EC group, using BN_copy or group-specific methods with optional BN_CTX management.",
            "score": [
                0.9231264252839662,
                0.7801727087815167,
                0.8619374991393804
            ],
            "reason": [
                "The summary accurately describes the function's purpose of retrieving the curve parameters a, b, and p from an EC group. It correctly mentions the use of BN_copy and group-specific methods, as well as the optional management of BN_CTX. These claims align well with the source code, with only minor omissions in detail, such as the specific conditions under which BN_copy is used versus field_decode methods.",
                "The summary accurately covers the core purpose of the function, which is to retrieve the prime field curve parameters a, b, and p from an EC group. It mentions the use of BN_copy and group-specific methods, aligning with the source code's operations. The summary also notes optional BN_CTX management, reflecting the conditional creation and freeing of BN_CTX in the code. However, it lacks detail on error handling and specific conditions under which different methods are used, such as field_decode versus BN_copy.",
                "The summary accurately describes the function's purpose of retrieving the curve parameters a, b, and p from an EC group. It correctly mentions the use of BN_copy and group-specific methods, as well as the optional management of BN_CTX. There are no inaccuracies or noise, and the claims are specific and aligned with the source code, providing high gain by clearly outlining the function's behavior."
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves the elliptic curve parameters a, b, and field prime from a GFp group, using BN_copy or a method callback with optional BN_CTX.",
            "score": [
                0.8986017055670359,
                0.8292728958821319,
                0.8547642855652743
            ],
            "reason": [
                "The summary accurately describes the function's purpose of retrieving elliptic curve parameters a, b, and the field prime from a GFp group. It correctly mentions the use of BN_copy and a method callback, as well as the optional use of BN_CTX. These claims align well with the source code, with only minor omissions such as the error handling mechanism, which does not significantly impact the overall accuracy.",
                "The summary accurately covers the core purpose of the function, which is to retrieve the elliptic curve parameters a, b, and the field prime from a GFp group. It mentions the use of BN_copy and a method callback, aligning with the source code's logic of using BN_copy and field_decode methods. The summary also notes the optional use of BN_CTX, which is consistent with the source code's handling of the context. However, it lacks details on error handling and the specific conditions under which different methods are used, such as the presence of the field_decode method and the allocation of a new BN_CTX.",
                "The summary accurately describes the function's purpose of retrieving elliptic curve parameters a, b, and the field prime from a GFp group. It correctly mentions the use of BN_copy and a method callback, as well as the optional use of BN_CTX. The claims are specific and align well with the source code, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nvoid FAST_FUNC bb_perror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\t/* Guard against \"<error message>: Success\" */\n\tbb_verror_msg(s, p, errno ? strerror(errno) : NULL);\n\tva_end(p);\n}",
    "comment": "Logs an error message along with the string representation of the current errno value, using a variable argument list for additional context.",
    "prorec_sum": "Packages input parameters and optional SIMD values, computes a derived value if configured, and forwards them to another routine for final processing.",
    "filter_prorec_sum": "Builds a parameter block from scalar and vector inputs, computes optional doubles via a helper, and forwards them to another processing routine.",
    "prorec_aug_sum": "Constructs parameter data from provided coordinates and calls a processing routine, optionally transforming vectors through an auxiliary computation if a global flag is set.",
    "filter_prorec_aug_sum": "Constructs parameter data from provided vectors and conditionally computes a double-based value before invoking a secondary processing routine with these arguments.",
    "work_score": {
        "prorec": {
            "summary": "Packages input parameters and optional SIMD values, computes a derived value if configured, and forwards them to another routine for final processing.",
            "score": [
                0.09658173915634935,
                0.10293122335602445,
                0.12796938067540087
            ],
            "reason": [
                "The summary does not accurately describe the source code. The function 'bb_perror_msg' does not involve SIMD values or compute a derived value; it initializes a variable argument list and forwards the message to 'bb_verror_msg'. The claims in the summary are largely inaccurate, with less than 50% alignment to the source code.",
                "The summary does not accurately reflect the core purpose of the source code. The function 'bb_perror_msg' is designed to format and forward error messages, not to compute derived values or handle SIMD values. The summary fails to cover the core operation of handling error messages and lacks any accurate secondary details related to the function's behavior.",
                "The summary contains a FATAL inaccuracy regarding the PRIMARY PURPOSE of the function. The source code describes a function 'bb_perror_msg' that handles error messages using variadic arguments and forwards them to 'bb_verror_msg'. The summary incorrectly describes the function as dealing with SIMD values and computing derived values, which is not present in the source code. This severe misalignment with the core domain action results in a score reflecting negative benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Builds a parameter block from scalar and vector inputs, computes optional doubles via a helper, and forwards them to another processing routine.",
            "score": [
                0.056217650088579804,
                0.1,
                0.11329642316084462
            ],
            "reason": [
                "The summary does not accurately describe the source code. The function 'bb_perror_msg' does not build a parameter block from scalar and vector inputs, nor does it compute optional doubles. Instead, it initializes a variable argument list and calls 'bb_verror_msg' with an error message. The claims in the summary are not aligned with the actual functionality of the source code, resulting in less than 50% accuracy.",
                "The summary does not cover the core primary purpose of the source code, which is to handle error messages using variadic arguments and forward them to another function. The claims in the summary are inaccurate as they describe unrelated operations like building parameter blocks and computing doubles, which are not present in the source code. There is almost no secondary information relevant to the source code's behavior.",
                "The summary is entirely inaccurate as it does not describe the source code's functionality. The source code defines a function 'bb_perror_msg' that handles error messages using variable arguments and forwards them to another function 'bb_verror_msg'. The summary incorrectly describes building parameter blocks and computing doubles, which are not present in the code. This constitutes a severe FATAL error regarding the core purpose of the function, resulting in a very low score."
            ]
        }
    }
}
{
    "source_code": "int mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t &context->range.level[0].cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\tebitmap_destroy(&context->range.level[1].cat);\n\treturn rc;\n}",
    "comment": "Imports and copies the MLS category attributes into the context structure if MLS is enabled, handling errors by destroying allocated resources.",
    "prorec_sum": "Checks a global state and performs two geometry-related update operations on structures at given offsets, returning success if either update is executed.",
    "filter_prorec_sum": "Checks global initialization and performs two object-related update operations using provided parameters, returning a status code if either succeeds.",
    "prorec_aug_sum": "Processes two related data structures using multiple computation routines, updating them when certain conditions are met, and returns a status code indicating the operation result.",
    "filter_prorec_aug_sum": "Processes two related data structures with provided parameters, performing conditional sub-operations only if initial checks succeed, then returns the computed status code.",
    "work_score": {
        "prorec": {
            "summary": "Checks a global state and performs two geometry-related update operations on structures at given offsets, returning success if either update is executed.",
            "score": [
                0.14040148388061477,
                0.17576615100040538,
                0.18841023955973146
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions 'geometry-related update operations,' which is not relevant to the source code. The function checks a global state and performs bitmap operations, returning success only if both updates are successful, not if either is executed. Less than 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which is related to importing and copying categories in a multilevel security (MLS) context from a net label. The CLAIM_LIST inaccurately describes the function as performing 'geometry-related update operations,' which is irrelevant and incorrect. It fails to mention the conditional branch based on 'mls_enabled' or the error handling involving 'ebitmap_destroy' functions for cleanup, focusing instead on an incorrect description of the actions performed by the code.",
                "The summary inaccurately describes the function's purpose and operations. It incorrectly states that the function performs 'geometry-related update operations' and returns success if 'either update is executed,' which contradicts the source code. The function actually checks a global state, performs bitmap import and copy operations, and returns success only if both operations succeed. This misrepresentation of the core purpose and key operations constitutes a severe FATAL error, leading to a low score."
            ]
        },
        "filter_prorec": {
            "summary": "Checks global initialization and performs two object-related update operations using provided parameters, returning a status code if either succeeds.",
            "score": [
                0.1858980001243697,
                0.26718018933769944,
                0.22801975078686035
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions 'checks global initialization,' which is correct as the function checks 'policydb.mls_enabled.' However, it incorrectly states that the function 'returns a status code if either succeeds,' while the function actually returns 0 if successful and a non-zero status code if either operation fails. The summary fails to mention the specific operations of importing and copying ebitmaps, and the error handling with 'ebitmap_destroy.' Overall, less than 50% of the claims are accurate.",
                "The summary fails to cover the core primary purpose of the function, which is to import and copy MLS categories using specific bitmap operations. It inaccurately states that a status code is returned if either operation succeeds, whereas the function returns 0 if successful and an error code if not. The summary does mention object-related updates, but lacks specificity and omits critical error handling and side effects.",
                "The summary inaccurately describes the primary purpose of the function by suggesting it returns a status code if either update operation succeeds, while the function only returns a status code upon failure. This is a severe FATAL error regarding the core I/O behavior. The summary does correctly note object-related updates, but the significant inaccuracies overshadow these accurate elements, resulting in a near-zero net benefit."
            ]
        }
    }
}
{
    "source_code": "\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum pipe pipe, bool state)\n{\n\tint reg;\n\tu32 val;\n\tbool cur_state;\n\tenum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,\n\t\t\t\t\t\t\t\t      pipe);\n\n\t/* if we need the pipe A quirk it must be always on */\n\tif (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)\n\t\tstate = true;\n\n\tif (!intel_using_power_well(dev_priv->dev) &&\n\t    cpu_transcoder != TRANSCODER_EDP) {\n\t\tcur_state = false;\n\t} else {\n\t\treg = PIPECONF(cpu_transcoder);\n\t\tval = I915_READ(reg);\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\t}\n\n\tWARN(cur_state != state,\n\t     \"pipe %c assertion failure (expected %s, current %s)\\n\",\n\t     pipe_name(pipe), state_string(state), state_string(cur_state));\n}",
    "comment": "Asserts the state of a specified display pipe in the Intel graphics driver, ensuring it matches the expected enablement state.",
    "prorec_sum": "Checks an Intel GPU display pipe\u2019s enabled state and logs an assertion failure if it differs from the expected on/off configuration.",
    "filter_prorec_sum": "Checks an Intel GPU display pipe\u2019s state against expectations and logs an assertion failure with pipe ID and on/off status details.",
    "prorec_aug_sum": "Checks the expected on/off state of a display pipe and logs an assertion failure if the current hardware state does not match.",
    "filter_prorec_aug_sum": "Checks a GPU display pipe\u2019s expected on/off state against hardware status and logs an assertion failure if the states differ.",
    "work_score": {
        "prorec": {
            "summary": "Checks an Intel GPU display pipe\u2019s enabled state and logs an assertion failure if it differs from the expected on/off configuration.",
            "score": [
                0.9,
                0.7189645054121032,
                0.8109259157765983
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking the enabled state of an Intel GPU display pipe and logging an assertion failure if there is a mismatch with the expected state. This aligns with the source code, which includes logic for determining the current state and comparing it to the expected state. The only minor omission is the specific handling of the PIPE_A quirk, which is not mentioned in the summary.",
                "The summary accurately covers the core purpose of the function, which is to check the enabled state of an Intel GPU display pipe and log an assertion failure if it does not match the expected state. This aligns with the function's operation of reading the pipe configuration and comparing it to the expected state. However, the summary does not mention specific conditions like the PIPE_A quirk or the handling of power well usage, which are critical secondary behaviors in the source code.",
                "The summary accurately captures the primary purpose of the function, which is to check the enabled state of an Intel GPU display pipe and log an assertion failure if there is a mismatch with the expected state. This aligns well with the source code, which involves reading the pipe configuration and comparing it to the expected state. The summary is concise and specific, providing high gain by clearly stating the core functionality without introducing noise or inaccuracies."
            ]
        },
        "filter_prorec": {
            "summary": "Checks an Intel GPU display pipe\u2019s state against expectations and logs an assertion failure with pipe ID and on/off status details.",
            "score": [
                0.9125907348663812,
                0.7688743493053475,
                0.815284309500852
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking the state of an Intel GPU display pipe against expected values and logging an assertion failure if there is a mismatch. It mentions key details such as the pipe ID and on/off status, which align with the source code's use of 'pipe', 'state', and 'cur_state'. The summary captures the core functionality without introducing inaccuracies, resulting in a high proportion of accurate claims.",
                "The summary accurately captures the core purpose of the function, which is to check the state of an Intel GPU display pipe against expected values and log an assertion failure if there is a mismatch. This aligns with the function's operation of reading the pipe configuration and comparing it to the expected state. The summary also mentions logging details, which covers the secondary behavior of providing pipe ID and status in the log. However, it does not explicitly mention the handling of the PIPE_A quirk or the conditions under which the current state is determined, which are critical for complete coverage.",
                "The summary accurately describes the function's primary purpose of checking the state of an Intel GPU display pipe against expectations and logging assertion failures with specific details like pipe ID and on/off status. This aligns well with the source code, which includes logic for determining the current state and logging discrepancies. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\n\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\n{\n\tcistpl_longlink_mfc_t mfc;\n\tunsigned int no_funcs, i, no_chains;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!(s->resource_setup_done)) {\n\t\tdev_dbg(&s->dev,\n\t\t\t   \"no resources available, delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\n\tif (pcmcia_validate_mem(s)) {\n\t\tdev_dbg(&s->dev, \"validating mem resources failed, \"\n\t\t       \"delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\tret = pccard_validate_cis(s, &no_chains);\n\tif (ret || !no_chains) {\n\t\tdev_dbg(&s->dev, \"invalid CIS or invalid resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\n\t\tno_funcs = mfc.nfn;\n\telse\n\t\tno_funcs = 1;\n\ts->functions = no_funcs;\n\n\tfor (i = 0; i < no_funcs; i++)\n\t\tpcmcia_device_add(s, i);\n\n\treturn ret;\n}",
    "comment": "Adds a PCMCIA card to the socket after validating resources and reading its function information from the card's CIS.",
    "prorec_sum": "Initializes and validates a hardware context, retrieves a count value, and iteratively performs device-specific operations for each enumerated unit.",
    "filter_prorec_sum": "Initializes device state, validates readiness, retrieves configuration data, and triggers operations for each configured unit using provided parameters.",
    "prorec_aug_sum": "Configures a device by validating state, reading parameters, and issuing initialization commands for each detected channel or endpoint.",
    "filter_prorec_aug_sum": "Configures and initiates device operations based on retrieved parameters, performing repeated command dispatches for each available unit and returning status codes on failure or completion.",
    "work_score": {
        "prorec": {
            "summary": "Initializes and validates a hardware context, retrieves a count value, and iteratively performs device-specific operations for each enumerated unit.",
            "score": [
                0.4856817067887702,
                0.4149137711132145,
                0.5231112450477058
            ],
            "reason": [
                "The summary correctly identifies the initialization and validation steps, as the function checks resource setup and memory validation. It also mentions retrieving a count value, which aligns with the retrieval of 'no_funcs'. However, the summary lacks specificity regarding the handling of CIS validation and the exact conditions leading to device-specific operations, resulting in mixed reliability.",
                "The summary covers the core purpose of initializing and validating the hardware context, which aligns with the function's operations of checking resource setup and validating memory. However, it lacks specificity regarding the handling of errors and the detailed process of adding devices, such as the conditions under which the function returns specific error codes or the exact nature of the device-specific operations performed.",
                "The summary accurately describes the initialization and validation of hardware context and the iterative device-specific operations, aligning with the function's purpose. However, it lacks specificity regarding the handling of resources and error conditions, which are crucial aspects of the function's behavior. The claims are mostly generic and broad, providing limited insight into the function's detailed operations."
            ]
        },
        "filter_prorec": {
            "summary": "Initializes device state, validates readiness, retrieves configuration data, and triggers operations for each configured unit using provided parameters.",
            "score": [
                0.4355222800114002,
                0.46120418225235343,
                0.4940480027782986
            ],
            "reason": [
                "The summary includes claims about initializing device state and validating readiness, which align with the mutex operations and validation checks in the source code. However, the claim about retrieving configuration data and triggering operations for each configured unit is less precise and does not accurately reflect the specific operations performed by the function, such as handling CIS validation and adding devices based on function count. Approximately 50-80% of the claims are accurate, indicating mixed reliability.",
                "The summary covers the core purpose of the function, which involves initializing device state and validating readiness, aligning with the mutex operations and validation checks in the source code. However, it lacks specificity regarding the handling of CIS validation, error conditions, and the detailed operations triggered for each function, which are critical secondary behaviors in the source code.",
                "The summary provides a generic overview of the function's operations, such as initializing device state and triggering operations, which aligns with the source code's actions of validating resources and adding devices. However, it lacks specificity regarding key operations like mutex locking, resource validation, and handling of CIS, which are crucial for understanding the function's behavior. The claims are mostly SAFE but provide low insight, and there is no FATAL error, resulting in a mediocre net benefit."
            ]
        }
    }
}
{
    "source_code": "\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n\t{\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tCMS_SignerInfo *si;\n\tint i;\n\tsinfos = CMS_get0_SignerInfos(cms);\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tif (!cms_SignerInfo_content_sign(cms, si, chain))\n\t\t\treturn 0;\n\t\t}\n\tcms->d.signedData->encapContentInfo->partial = 0;\n\treturn 1;\n\t}",
    "comment": "Finalizes the signing process for all signer information in the CMS_ContentInfo structure by signing the content and marking it as complete.",
    "prorec_sum": "Finalizes signing for each CMS signer by completing digests, adding required signed attributes, generating signatures, and storing them in the signer information structures.",
    "filter_prorec_sum": "Finalizes CMS SignedData by processing each signer\u2019s digest context, adding required signed attributes, generating signatures, and storing them in the structure.",
    "prorec_aug_sum": "Generates and finalizes CMS signed-data signatures by processing each signer\u2019s digest, adding required attributes, and creating the final signature output.",
    "filter_prorec_aug_sum": "Finalizes CMS SignedData by computing digests or signatures for each signer and updating corresponding attributes, handling errors and freeing resources.",
    "work_score": {
        "prorec": {
            "summary": "Finalizes signing for each CMS signer by completing digests, adding required signed attributes, generating signatures, and storing them in the signer information structures.",
            "score": [
                0.39892180249282366,
                0.45886015579689426,
                0.43199862682017465
            ],
            "reason": [
                "The summary contains elements that are partially accurate but mixed with inaccuracies. The claim that the function finalizes signing by completing digests and generating signatures is supported by the source code, which processes each signer and signals success or failure. However, the summary inaccurately mentions adding required signed attributes and storing them in signer information structures, details not explicitly verifiable or visible in the provided source code, suggesting a proportion of claims within the 50-80% range are accurate.",
                "The summary covers the core purpose of finalizing signing for each CMS signer, which aligns with the function's operation of iterating over signer information and signing content. However, it lacks detail on secondary aspects such as error handling (returning 0 on failure) and setting 'partial' to 0 in 'encapContentInfo'.",
                "The summary contains some accurate claims about the function's purpose, such as finalizing signing for each CMS signer, which aligns with the loop iterating over signer information and calling cms_SignerInfo_content_sign. However, it inaccurately mentions completing digests and adding signed attributes, which are not explicitly shown in the source code. The noise from these inaccuracies is noticeable, but there is no severe contradiction affecting core functionality."
            ]
        },
        "filter_prorec": {
            "summary": "Finalizes CMS SignedData by processing each signer\u2019s digest context, adding required signed attributes, generating signatures, and storing them in the structure.",
            "score": [
                0.4260132242369591,
                0.46978955246749105,
                0.4581332037721926
            ],
            "reason": [
                "The summary accurately describes the function's purpose of finalizing CMS SignedData by processing signer information, which aligns with the loop iterating over signer infos and calling cms_SignerInfo_content_sign. However, it inaccurately mentions adding signed attributes and generating signatures, which are not explicitly shown in the source code. Thus, about 50-80% of the claims are accurate.",
                "The summary covers the core purpose of finalizing CMS SignedData by processing each signer, which aligns with the loop iterating over signer infos and signing content. However, it lacks details on setting 'partial' to 0 and the return values, which are critical for understanding the function's complete behavior.",
                "The summary mentions processing each signer's digest context and generating signatures, which aligns with the source code's loop over signer info and content signing. However, the statement about storing signatures and adding required signed attributes is not explicitly clear in the source, indicating some noise. No critical inaccuracies (FATAL) are present, but the lack of detailed correspondence limits net benefit."
            ]
        }
    }
}
{
    "source_code": "static void tcp_set_skb_tso_segs(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int mss_now)\n{\n\tif (skb->len <= mss_now || !sk_can_gso(sk) ||\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\t/* Avoid the costly divide in the normal\n\t\t * non-TSO case.\n\t\t */\n\t\tskb_shinfo(skb)->gso_segs = 1;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t} else {\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss_now);\n\t\tskb_shinfo(skb)->gso_size = mss_now;\n\t\tskb_shinfo(skb)->gso_type = sk->sk_gso_type;\n\t}\n}",
    "comment": "Sets the TCP segmentation offload parameters for a socket buffer based on its length and the maximum segment size.",
    "prorec_sum": "Configures TCP segment header fields based on connection state and packet size, logging anomalies once, before finalizing length and identifier values.",
    "filter_prorec_sum": "Calculates and updates TCP output segment header fields based on connection state, segment size, and flags, with a one-time debug log on anomaly.",
    "prorec_aug_sum": "Updates TCP output header fields based on segment and connection state, logging anomalies once, to prepare acknowledgment or segment size information.",
    "filter_prorec_aug_sum": "Calculates and writes TCP segment count, size, and sequence fields into the packet buffer header based on connection state and provided parameters.",
    "work_score": {
        "prorec": {
            "summary": "Configures TCP segment header fields based on connection state and packet size, logging anomalies once, before finalizing length and identifier values.",
            "score": [
                0.14687906266262438,
                0.1863704341424261,
                0.23508221597104115
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions configuring TCP segment header fields based on connection state and packet size, which is misleading. The function actually sets GSO segment values based on packet length and MSS, without any logging or finalizing of length and identifier values. Only one claim is somewhat accurate, relating to packet size, but overall, the summary fails to capture the specific operations performed by the function.",
                "The summary does not accurately cover the core purpose of the function, which is to set TSO segment fields based on packet size and connection capabilities. It incorrectly mentions logging anomalies and finalizing length and identifier values, which are not present in the source code. The summary lacks coverage of key behaviors such as handling non-TSO cases and setting gso_segs, gso_size, and gso_type based on conditions.",
                "The summary inaccurately describes the function's behavior, focusing on logging anomalies and finalizing length and identifier values, which are not present in the source code. The primary purpose of setting TCP segment header fields based on packet size and connection state is misrepresented, leading to a FATAL error regarding the core domain action. There are no accurate claims to provide positive gain."
            ]
        },
        "filter_prorec": {
            "summary": "Calculates and updates TCP output segment header fields based on connection state, segment size, and flags, with a one-time debug log on anomaly.",
            "score": [
                0.18471755465685818,
                0.2647262661000819,
                0.30411801875254935
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions calculating and updating TCP output segment header fields based on connection state, segment size, and flags, which is partially correct as the function updates segment size and type based on conditions. However, it incorrectly includes a 'one-time debug log on anomaly,' which is not present in the source code. Less than 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which is to set the TSO segments and related fields in the skb_shinfo structure based on conditions involving segment size and connection capabilities. The mention of 'TCP output segment header fields' is vague and does not accurately reflect the specific operation of setting gso_segs, gso_size, and gso_type. Additionally, the summary incorrectly mentions a 'one-time debug log on anomaly,' which is not present in the source code. While the summary touches on connection state and segment size, it lacks specificity and misses key details such as the conditions checked and the exact fields updated.",
                "The summary inaccurately claims a debug log on anomaly, which is not present in the source code, constituting a FATAL error regarding side effects. The summary's mention of calculating and updating TCP output segment header fields is correct but generic, providing low gain. The noise from the inaccurate claim overwhelms the accurate but low-info claim."
            ]
        }
    }
}
{
    "source_code": "\nSEXP attribute_hidden do_dynunload(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    char buf[2 * PATH_MAX];\n\n    checkArity(op,args);\n    if (!isString(CAR(args)) || LENGTH(CAR(args)) != 1)\n\terror(_(\"character argument expected\"));\n    GetFullDLLPath(call, buf, translateChar(STRING_ELT(CAR(args), 0)));\n    if(!DeleteDLL(buf))\n\terror(_(\"shared object '%s\\' was not loaded\"), buf);\n    return R_NilValue;\n}",
    "comment": "Unloads a shared object from memory by verifying the argument and deleting its associated DLL using the full path derived from the input.",
    "prorec_sum": "Validates a single character argument specifying a shared object name, loads it, and raises an error if the object is not found.",
    "filter_prorec_sum": "Validates a single string argument and reports an error if the specified shared object was not successfully loaded.",
    "prorec_aug_sum": "Loads a shared object by name from a character argument, invoking an internal loader and erroring if the object is not loaded.",
    "filter_prorec_aug_sum": "Validates a single string argument, translates it, and reports an error if the corresponding shared object is not loaded.",
    "work_score": {
        "prorec": {
            "summary": "Validates a single character argument specifying a shared object name, loads it, and raises an error if the object is not found.",
            "score": [
                0.2056778880938163,
                0.2359881248425654,
                0.19831195767964005
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions loading a shared object, which contradicts the source code that actually unloads a shared object. The claim about validating a single character argument is accurate, but the overall description fails to capture the function's primary purpose, leading to less than 50% accuracy.",
                "The summary inaccurately states that the function loads a shared object, whereas the source code indicates it attempts to unload a shared object. The core purpose of deleting a DLL is not covered. The summary correctly mentions error handling for invalid arguments, but misses other critical behaviors like path translation and DLL deletion.",
                "The summary inaccurately claims that the function 'loads' a shared object when it actually 'unloads' a DLL, which is the primary purpose and core action of the function. Additionally, it omits key information about the validation process and the specific error handling implemented in the source. This severe inaccuracy regarding the primary purpose results in a detrimental effect on understanding, making it untrustworthy."
            ]
        },
        "filter_prorec": {
            "summary": "Validates a single string argument and reports an error if the specified shared object was not successfully loaded.",
            "score": [
                0.2633920923300561,
                0.24499963925983265,
                0.265054714266768
            ],
            "reason": [
                "The summary contains two claims: validation of a single string argument and error reporting if a shared object was not loaded. The first claim is accurate as the code checks for a single string argument. However, the second claim is inaccurate because the code reports an error if the shared object was not successfully unloaded, not loaded. Thus, less than 50% of the claims are accurate.",
                "The summary inaccurately states the function reports an error if the shared object was not successfully loaded, whereas the source code indicates it reports an error if the shared object was not successfully unloaded. The core purpose of unloading a DLL is not covered, and the summary lacks secondary details such as argument validation and error handling.",
                "The summary inaccurately describes the function's behavior by stating it reports an error if the shared object was not successfully loaded, whereas the source code shows it reports an error if the shared object was not successfully unloaded. This is a FATAL error concerning the PRIMARY PURPOSE of the function. The claim about validating a single string argument is accurate but generic, providing low gain."
            ]
        }
    }
}
{
    "source_code": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED)\n\t\treturn 0;\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "comment": "Allocates an audit context for a given task if auditing is enabled and filters the task based on its audit state.",
    "prorec_sum": "Allocates and initializes an audit data structure for the given object, setting type-specific fields and marking it with an audit flag.",
    "filter_prorec_sum": "Allocates and initializes an audit data structure for the given object, linking it to global lists and handling out-of-memory errors.",
    "prorec_aug_sum": "Allocates and initializes an audit data structure for the given task, linking it to global lists and marking the task with an audit flag.",
    "filter_prorec_aug_sum": "Allocates and initializes an audit record for the given context, linking it to global structures and handling memory exhaustion errors.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes an audit data structure for the given object, setting type-specific fields and marking it with an audit flag.",
            "score": [
                0.43319184881726114,
                0.40463941035495943,
                0.49164165538282356
            ],
            "reason": [
                "The summary claims that the function allocates and initializes an audit data structure, which aligns with the creation of 'audit_context'. However, it incorrectly generalizes the setting of type-specific fields and does not mention the function's checks and early returns, such as when auditing is not enabled. Additionally, the summary's mention of marking with an audit flag is partially accurate as 'TIF_SYSCALL_AUDIT' is set but lacks specificity. Overall, 50-80% of the claims are accurate.",
                "The summary correctly identifies the allocation and initialization of an audit data structure, which aligns with the core purpose of the function. However, it lacks specificity regarding the conditional checks and error handling present in the source code, such as the audit state filtering, memory allocation failure handling, and setting of thread flags.",
                "The summary correctly identifies the allocation and initialization of an audit data structure, which aligns with the function's purpose. However, it lacks specificity regarding the conditions under which the function returns early without allocation, such as when auditing is disabled or memory allocation fails. The summary also omits details about setting the filter key and thread flag, which are key actions in the function. The noise is noticeable due to missing specific conditions and actions, resulting in limited insight."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes an audit data structure for the given object, linking it to global lists and handling out-of-memory errors.",
            "score": [
                0.22644463162761305,
                0.27888756961915273,
                0.3285665687237803
            ],
            "reason": [
                "The summary inaccurately claims that the function links the audit data structure to global lists, which is not supported by the source code. It correctly mentions handling out-of-memory errors but fails to accurately describe the function's behavior regarding audit context allocation and initialization. Less than 50% of the claims are accurate.",
                "The summary inaccurately claims that the function links the audit data structure to global lists, which is not supported by the source code. It correctly mentions handling out-of-memory errors but fails to cover the core purpose of setting the task's audit context and enabling syscall auditing. The core purpose is not covered, and only a few secondary points are mentioned.",
                "The summary inaccurately claims that the function links the audit data structure to global lists, which is not supported by the source code, representing a FATAL error regarding the PRIMARY PURPOSE. Additionally, the summary fails to mention key operations such as setting the thread flag for syscall auditing, which contributes to noise. The accurate part about handling out-of-memory errors provides low gain due to its generic nature."
            ]
        }
    }
}
{
    "source_code": "int Xorriso_register_matched_adr(struct XorrisO *xorriso,\n                                char *adr, int count_limit,\n                                int *filec, char **filev, off_t *mem, int flag)\n{\n int l;\n\n if(flag&1) {\n   (*filec)++;\n   l= strlen(adr)+1;\n   (*mem)+= sizeof(char *)+l;\n   if(l % sizeof(char *))\n     (*mem)+= sizeof(char *)-(l % sizeof(char *));\n } else {\n   if(*filec >= count_limit) {\n     sprintf(xorriso->info_text,\n         \"Number of matching files changed unexpectedly (> %d)\",\n         count_limit);\n     Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0,\n                         (flag&2 ? \"FATAL\" : \"WARNING\"), 0);\n     return(flag&2 ? -1 : 0);\n   }\n   filev[*filec]= strdup(adr);\n   if(filev[*filec]==NULL) {\n     Xorriso_no_pattern_memory(xorriso, (off_t) (strlen(adr)+1), 0);\n     return(-1);\n   }\n   (*filec)++;\n }\n return(1);\n}",
    "comment": "Registers a matched address by updating file count, allocating memory for the address, and handling errors based on a specified flag.",
    "prorec_sum": "Adds a file path to a list, updates counters and memory alignment, and logs a warning or fatal error if expected count is exceeded.",
    "filter_prorec_sum": "Adds a matching filename to a list, updating counters and alignment, or logs a warning/fatal if the match count exceeds the expected limit.",
    "prorec_aug_sum": "Handles adding a matching filename to a list, updating counters and buffers, and issuing warnings or fatal errors if count limits are exceeded.",
    "filter_prorec_aug_sum": "Adds a matching file name to a list, updating counters and buffers, and logs warnings or fatal errors if count limits are exceeded.",
    "work_score": {
        "prorec": {
            "summary": "Adds a file path to a list, updates counters and memory alignment, and logs a warning or fatal error if expected count is exceeded.",
            "score": [
                0.8853000952782937,
                0.7674641061005668,
                0.827580777197553
            ],
            "reason": [
                "The summary accurately describes the function's behavior: adding a file path to a list, updating counters and memory alignment, and logging a warning or fatal error if the count limit is exceeded. These claims align well with the source code, which performs these operations based on the flag and count_limit conditions. The summary captures the core functionality and error handling, with only minor omissions in detail.",
                "The summary accurately covers the core purpose of the function, which is to add a file path to a list and update counters and memory alignment. It also mentions logging a warning or fatal error if the expected count is exceeded, which aligns with the error handling in the source code. However, it lacks detail on specific conditions like the handling of memory alignment and the distinction between warning and fatal error based on flags.",
                "The summary accurately describes the function's behavior: adding a file path to a list, updating counters, and handling memory alignment. It correctly notes the logging of a warning or fatal error when the count limit is exceeded, aligning well with the source code. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Adds a matching filename to a list, updating counters and alignment, or logs a warning/fatal if the match count exceeds the expected limit.",
            "score": [
                0.8716283474770952,
                0.744780676373096,
                0.8125907335968762
            ],
            "reason": [
                "The summary accurately describes the function's behavior: adding a filename to a list and updating counters when a flag is set, or logging a warning/fatal error if the match count exceeds the limit. The claims are highly specific and verifiable against the source code, with only minor omissions regarding memory alignment details.",
                "The summary accurately covers the core purpose of the function, which is to add a matching filename to a list and update counters and memory alignment. It also correctly mentions the logging of warnings or fatal errors when the match count exceeds the limit, aligning with the source code's behavior. However, it lacks detail on specific edge cases like memory allocation failure handling.",
                "The summary accurately describes the function's primary purpose of adding a matching filename to a list and updating counters and alignment. It correctly notes the logging of a warning or fatal error if the match count exceeds the limit, aligning well with the source code's behavior. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic int\ngmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,\n\t\tu32 gmbus1_index)\n{\n\tint reg_offset = dev_priv->gpio_mmio_base;\n\tu16 len = msg->len;\n\tu8 *buf = msg->buf;\n\n\tI915_WRITE(GMBUS1 + reg_offset,\n\t\t   gmbus1_index |\n\t\t   GMBUS_CYCLE_WAIT |\n\t\t   (len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t   GMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\t\tu32 val, loop = 0;\n\n\t\tret = gmbus_wait_hw_status(dev_priv, GMBUS_HW_RDY,\n\t\t\t\t\t   GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = I915_READ(GMBUS3 + reg_offset);\n\t\tdo {\n\t\t\t*buf++ = val & 0xff;\n\t\t\tval >>= 8;\n\t\t} while (--len && ++loop < 4);\n\t}\n\n\treturn 0;\n}",
    "comment": "Reads data from a GMBUS device into a buffer, handling timing and status checks during the transfer process.",
    "prorec_sum": "Transfers data blocks from a buffer to hardware registers in 256-byte chunks, invoking helper routines for writing and reading until all bytes are processed.",
    "filter_prorec_sum": "Transfers data blocks from a buffer to hardware registers in chunks, issuing commands and writing bytes with periodic status checks until complete.",
    "prorec_aug_sum": "Transfers data blocks from a buffer to hardware registers in fixed-size chunks, invoking lower-level routines to send and retrieve byte values.",
    "filter_prorec_aug_sum": "Transfers chunks of up to 256 bytes from a buffer to hardware registers, invoking helper calls for data output and synchronization until completion.",
    "work_score": {
        "prorec": {
            "summary": "Transfers data blocks from a buffer to hardware registers in 256-byte chunks, invoking helper routines for writing and reading until all bytes are processed.",
            "score": [
                0.12450850131323717,
                0.18727532027860466,
                0.20821995141008415
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions transferring data in 256-byte chunks, which is not supported by the source code. The function reads data from hardware registers into a buffer, not the other way around. Additionally, the summary fails to mention key operations such as the use of gmbus_wait_hw_status and I915_READ, which are crucial to the function's operation. Less than 50% of the claims are accurate.",
                "The summary inaccurately describes the function's operation as transferring data blocks from a buffer to hardware registers, which contradicts the source code's actual purpose of reading data from hardware registers into a buffer. The core purpose of performing a GMBUS read operation is not covered, and the summary fails to mention key aspects like the use of specific registers, handling of read operations, and loop mechanics for processing data. The summary provides little secondary information relevant to the function's behavior.",
                "The summary inaccurately describes the function's behavior, stating it transfers data in 256-byte chunks, which contradicts the source code that processes data based on the message length and reads from hardware registers. This is a FATAL error regarding the core domain action, leading to a low score. There are no accurate claims to provide any positive gain."
            ]
        },
        "filter_prorec": {
            "summary": "Transfers data blocks from a buffer to hardware registers in chunks, issuing commands and writing bytes with periodic status checks until complete.",
            "score": [
                0.1981536821386522,
                0.27801208881595446,
                0.30618136332187196
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It claims the function transfers data blocks from a buffer to hardware registers, which is incorrect. The function actually reads data from hardware registers into a buffer, as indicated by the use of I915_READ and the loop that writes to the buffer. The summary also mentions issuing commands and writing bytes, which is misleading since the function primarily reads data. Therefore, less than 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which is to perform a read transfer from hardware registers using the GMBUS protocol. The summary inaccurately describes the operation as transferring data from a buffer to hardware registers, whereas the function reads data into a buffer. The summary mentions periodic status checks, which aligns with the function's behavior of checking hardware status, but lacks coverage of other critical semantics such as error handling and specific register operations.",
                "The summary inaccurately describes the function's behavior, stating it transfers data from a buffer to hardware registers, which contradicts the source code that reads data into a buffer from hardware registers. This is a FATAL error regarding the core domain action, leading to a negative net benefit. There are no accurate claims to provide any positive gain."
            ]
        }
    }
}
{
    "source_code": "static void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}",
    "comment": "Purges old Power Save buffers from access points and stations, freeing memory and updating the total buffered frame count.",
    "prorec_sum": "Traverses two linked lists, processes selected entries with a helper routine, accumulates their counters, and stores the total into the object's data field.",
    "filter_prorec_sum": "Traverses two linked lists of objects, processes those with valid data using a helper routine, sums specific integer fields, and stores the accumulated total.",
    "prorec_aug_sum": "Aggregates specific node values from two linked lists, processes matching entries, and updates a total count field in the given data structure.",
    "filter_prorec_aug_sum": "Aggregates specific node metrics from two linked lists, processes matching entries, and stores the total count into the parent structure\u2019s field.",
    "work_score": {
        "prorec": {
            "summary": "Traverses two linked lists, processes selected entries with a helper routine, accumulates their counters, and stores the total into the object's data field.",
            "score": [
                0.49385128521058047,
                0.2431386652303696,
                0.31184449574819284
            ],
            "reason": [
                "The summary correctly identifies the traversal of two linked lists and the accumulation of counters, which aligns with the source code's operations on 'local->interfaces' and 'local->sta_list'. However, it lacks specificity regarding the purging of frames and the use of helper routines like 'dev_kfree_skb' and 'ieee80211_free_txskb', which are crucial to the function's behavior. The summary is partially accurate but misses key details about the function's semantics.",
                "The summary does not cover the core primary purpose of the function, which is to purge old power-saving buffers by dequeuing and freeing specific network frames. The summary mentions traversing linked lists and accumulating counters, which aligns with the code's operations of iterating over interfaces and stations and updating counters. However, it misses the critical aspect of purging frames and freeing memory, which is central to the function's purpose. Several secondary points are mentioned, but the core action is not accurately captured.",
                "The summary includes general operations of the source code such as traversing lists and accumulating counters, which align with the source code's behavior. However, it fails to accurately describe the specific operations like purging frames from buffers and updating PS buffers. This leads to a notable amount of noise since it does not highlight core functionalities, but it does not contain any fatal inaccuracies about key I/O or the primary purpose. Therefore, the net benefit remains low due to insufficient detail in the accurate claims, leading to weak overall gain."
            ]
        },
        "filter_prorec": {
            "summary": "Traverses two linked lists of objects, processes those with valid data using a helper routine, sums specific integer fields, and stores the accumulated total.",
            "score": [
                0.20765301798423902,
                0.21365469599404047,
                0.33402905081441625
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions traversing linked lists and processing objects with valid data, which is not specific to the function's operations. The function purges old power save buffers and updates totals, but the summary fails to capture these specific actions. Less than 50% of the claims are accurate.",
                "The summary fails to cover the core primary purpose of the function, which is to purge old power save buffers from AP and mesh interfaces and drop frames from stations. It inaccurately describes the function as processing objects with valid data and summing integer fields, which does not align with the source code's operations of dequeuing and freeing skb buffers. While it mentions traversing linked lists, it lacks coverage of behavior-critical semantics such as the purging mechanism and the specific handling of skb buffers.",
                "The summary inaccurately describes the function's operations. It mentions processing objects with valid data using a helper routine, which is not reflected in the source code. The function purges old PS buffers and updates totals, but does not involve processing with a helper routine or summing specific integer fields as described. The inaccuracies are overwhelming, leading to a low net benefit."
            ]
        }
    }
}
{
    "source_code": "\nstatic void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,\n\t\t\t\t int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mroute_msgsize(mfc->mfc_parent >= MAXVIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = ipmr_fill_mroute(mrt, skb, 0, 0, mfc, cmd);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE, err);\n}",
    "comment": "Notifies the kernel about multicast route changes by creating and sending a netlink message based on the provided mfc_cache and command.",
    "prorec_sum": "Allocates and initializes a routing-related structure with provided parameters, handles errors by freeing resources, and reports status to the networking subsystem.",
    "filter_prorec_sum": "Allocates and initializes a network-related structure with provided parameters, handles errors by freeing resources, and reports status through a specified context.",
    "prorec_aug_sum": "Allocates and initializes a data structure with provided parameters, processes it, and handles cleanup and error reporting based on the operation\u2019s result.",
    "filter_prorec_aug_sum": "Allocates and initializes a data structure with provided parameters, invokes a setup routine, handles errors by cleanup, and signals the result to a managing context.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes a routing-related structure with provided parameters, handles errors by freeing resources, and reports status to the networking subsystem.",
            "score": [
                0.542778445764049,
                0.5279940437156717,
                0.5710727563651091
            ],
            "reason": [
                "The summary correctly identifies the allocation and initialization of a routing-related structure and error handling by freeing resources, which aligns with the source code's use of nlmsg_new and kfree_skb. However, the claim about reporting status to the networking subsystem is vague and does not accurately reflect the specific behavior of rtnl_notify and rtnl_set_sk_err, leading to mixed reliability.",
                "The summary covers the core purpose by mentioning the allocation and initialization of a routing-related structure, aligning with the creation of a netlink message in the source code. However, it lacks specificity regarding the exact operation performed, such as notifying the networking subsystem with `rtnl_notify`. Error handling is mentioned, but the summary does not cover all secondary behaviors like the specific error reporting mechanism using `rtnl_set_sk_err`.",
                "The summary correctly identifies the allocation and initialization of a routing-related structure and error handling through resource freeing, which aligns with the source code. However, it lacks specificity regarding the exact functions and parameters involved, such as 'mroute_netlink_event', 'mfc_cache', and 'cmd'. The claim about reporting status to the networking subsystem is accurate but generic, providing low informational gain. Overall, the summary is mostly accurate but lacks detailed insights, resulting in a mediocre net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes a network-related structure with provided parameters, handles errors by freeing resources, and reports status through a specified context.",
            "score": [
                0.5138425924815478,
                0.4488297323892527,
                0.5329999783682801
            ],
            "reason": [
                "The summary accurately captures the function's behavior of allocating a structure (skb) and handling errors by freeing this resource, aligning well with the code's logic. However, it generically mentions 'network-related structure' without specifying 'skb' or its purpose. 'Reports status through a specified context' is vague, lacking detail specific to the function notifying through 'rtnl_notify'. Approximately 75% of claims are accurate, leading to a mid-range score.",
                "The summary covers the core purpose of handling network events and error management, but lacks specificity about the exact operations like 'mroute_netlink_event' and 'rtnl_notify'. It mentions error handling and resource freeing, which aligns with the error branch in the source code, but does not detail the specific network operations or the use of 'mfc_cache' and 'mr_table'.",
                "The summary correctly identifies the allocation and initialization of a network-related structure and error handling through resource freeing, which aligns with the source code. However, it lacks specificity regarding the function's primary purpose of handling netlink events and notifying status through rtnl_notify, resulting in a low-info gain. The summary is generic and does not capture the detailed semantics of the function, leading to a mediocre net benefit."
            ]
        }
    }
}
{
    "source_code": "\nvoid inet_twdr_twkill_work(struct work_struct *work)\n{\n\tstruct inet_timewait_death_row *twdr =\n\t\tcontainer_of(work, struct inet_timewait_death_row, twkill_work);\n\tint i;\n\n\tBUILD_BUG_ON((INET_TWDR_TWKILL_SLOTS - 1) >\n\t\t\t(sizeof(twdr->thread_slots) * 8));\n\n\twhile (twdr->thread_slots) {\n\t\tspin_lock_bh(&twdr->death_lock);\n\t\tfor (i = 0; i < INET_TWDR_TWKILL_SLOTS; i++) {\n\t\t\tif (!(twdr->thread_slots & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\twhile (inet_twdr_do_twkill_work(twdr, i) != 0) {\n\t\t\t\tif (need_resched()) {\n\t\t\t\t\tspin_unlock_bh(&twdr->death_lock);\n\t\t\t\t\tschedule();\n\t\t\t\t\tspin_lock_bh(&twdr->death_lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttwdr->thread_slots &= ~(1 << i);\n\t\t}\n\t\tspin_unlock_bh(&twdr->death_lock);\n\t}\n}",
    "comment": "Processes and removes active threads from the timewait death row while managing concurrency using spin locks and checking for rescheduling needs.",
    "prorec_sum": "Processes and clears active bit flags by invoking associated handlers until no flags remain, repeatedly performing conditional operations based on status bits.",
    "filter_prorec_sum": "Processes pending flags for up to eight channels, invoking handlers until conditions clear, then updates the flag mask and repeats until all are serviced.",
    "prorec_aug_sum": "Processes up to eight flagged work items, repeatedly invoking handlers until completion, clearing processed flags, and looping until no pending tasks remain.",
    "filter_prorec_aug_sum": "Processes up to eight flagged entries by repeatedly invoking handler routines until completion and clearing processed flags in the given data structure.",
    "work_score": {
        "prorec": {
            "summary": "Processes and clears active bit flags by invoking associated handlers until no flags remain, repeatedly performing conditional operations based on status bits.",
            "score": [
                0.7564785091399174,
                0.5561711063286523,
                0.6786279067316381
            ],
            "reason": [
                "The summary accurately describes the function's behavior of processing and clearing active bit flags by invoking handlers, as seen in the loop that checks and clears bits in 'twdr->thread_slots'. The conditional operations based on status bits are correctly mentioned, aligning with the function's repeated checks and scheduling operations. Most claims are specific and verifiable, with high alignment to the source code.",
                "The summary accurately describes the core purpose of processing and clearing active bit flags, which aligns with the function's operation of iterating over thread slots and invoking handlers. However, it lacks detail on secondary aspects such as the locking mechanism, scheduling, and error handling, which are critical behaviors in the source code.",
                "The summary accurately describes the function's primary purpose of processing and clearing active bit flags by invoking handlers, which aligns with the source code's logic of iterating over thread slots and calling 'inet_twdr_do_twkill_work'. The conditional operations based on status bits are correctly mentioned, reflecting the checks and scheduling in the code. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Processes pending flags for up to eight channels, invoking handlers until conditions clear, then updates the flag mask and repeats until all are serviced.",
            "score": [
                0.45307871208719075,
                0.572165243834155,
                0.5330805063983568
            ],
            "reason": [
                "The summary correctly identifies the function's role in processing flags and updating the flag mask, which aligns with the source code's behavior of iterating over thread slots and invoking handlers. However, the mention of 'up to eight channels' is inaccurate as the code does not specify a channel count, and the summary lacks specificity regarding the locking mechanism and scheduling conditions present in the source code.",
                "The summary covers the core purpose of processing pending flags and invoking handlers, which aligns with the function's operation of iterating over thread slots and executing work. However, it lacks detail on specific behaviors such as locking mechanisms, scheduling, and the exact nature of the handlers invoked, which are critical secondary aspects of the source code.",
                "The summary correctly identifies the iterative process of handling flags and updating the mask, which aligns with the loop structure in the source code. However, it lacks specificity regarding the use of locks and scheduling, which are key aspects of the function's operation. The claims are mostly generic and do not provide detailed insights into the function's behavior, resulting in a mediocre net benefit with noticeable noise."
            ]
        }
    }
}
{
    "source_code": "\n\nstatic int unix_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u;\n\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, uaddr);\n\tint err = 0;\n\n\tif (peer) {\n\t\tsk = unix_peer_get(sk);\n\n\t\terr = -ENOTCONN;\n\t\tif (!sk)\n\t\t\tgoto out;\n\t\terr = 0;\n\t} else {\n\t\tsock_hold(sk);\n\t}\n\n\tu = unix_sk(sk);\n\tunix_state_lock(sk);\n\tif (!u->addr) {\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tsunaddr->sun_path[0] = 0;\n\t\t*uaddr_len = sizeof(short);\n\t} else {\n\t\tstruct unix_address *addr = u->addr;\n\n\t\t*uaddr_len = addr->len;\n\t\tmemcpy(sunaddr, addr->name, *uaddr_len);\n\t}\n\tunix_state_unlock(sk);\n\tsock_put(sk);\nout:\n\treturn err;\n}",
    "comment": "Retrieves the Unix socket's address or initializes it as empty if not connected, handling peer connections appropriately.",
    "prorec_sum": "Retrieves address data into a buffer, updates a reference count, and invokes cleanup when no longer referenced.",
    "filter_prorec_sum": "Retrieves address data from a socket structure, updates output parameters, and manages reference counts with locking and cleanup on zero references.",
    "prorec_aug_sum": "Retrieves an associated data entry, updates reference counters, copies its contents into the destination buffer, and performs cleanup when no longer referenced.",
    "filter_prorec_aug_sum": "Retrieves and writes structured data from an object, updating reference counts and invoking cleanup when no references remain.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves address data into a buffer, updates a reference count, and invokes cleanup when no longer referenced.",
            "score": [
                0.22070052960620953,
                0.3046225761504297,
                0.3312671558738503
            ],
            "reason": [
                "The summary contains claims that are mostly inaccurate. It mentions retrieving address data into a buffer, which aligns with the function's behavior of copying address data into 'sunaddr'. However, the summary inaccurately claims updating a reference count and invoking cleanup when no longer referenced, which are not reflected in the source code. The function does hold and release a socket, but this is not equivalent to updating a reference count or cleanup as described. Less than 50% of the claims are accurate.",
                "The summary mentions retrieving address data and updating a reference count, which aligns partially with the function's role of getting a Unix socket address and manipulating the socket's reference. However, it lacks the specific domain wording needed to fully capture the core primary purpose, which is 'retrieving a Unix address and handling reference with error management.' It misses critical points like the peer connection handling and address condition checking in the source code, making the summary incomplete.",
                "The summary contains NOISE as it inaccurately describes the function's behavior. It mentions 'updates a reference count' and 'invokes cleanup when no longer referenced,' which are not present in the source code. The function primarily retrieves address data and manages socket references, but the summary fails to accurately capture these actions. There are no FATAL inaccuracies regarding the core purpose, but the overwhelming NOISE results in a net benefit close to zero."
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves address data from a socket structure, updates output parameters, and manages reference counts with locking and cleanup on zero references.",
            "score": [
                0.4101134939357268,
                0.4513454308154755,
                0.5008428979237232
            ],
            "reason": [
                "The summary correctly mentions retrieving address data from a socket structure and updating output parameters, aligning with the function's behavior of extracting address information and setting 'uaddr_len'. However, it inaccurately describes managing reference counts with locking and cleanup on zero references, which is not explicitly handled in the source code. The function does involve locking and reference management, but not specifically in the context of zero references. Thus, about 50-80% of the claims are accurate.",
                "The summary covers the core purpose of retrieving address data from a socket structure, which aligns with the function's operation of extracting the address from the socket. However, it lacks specificity regarding the peer condition, error handling, and the exact nature of reference management and locking mechanisms, which are critical secondary behaviors in the source code.",
                "The summary correctly identifies the function's purpose of retrieving address data from a socket structure and updating output parameters, which aligns with the source code. However, it inaccurately mentions 'cleanup on zero references,' which is not evident in the code, introducing noise. The summary lacks specific details about the function's behavior, such as handling peer connections and the use of locks, resulting in low gain."
            ]
        }
    }
}
{
    "source_code": "void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory. The 'span' of the expression\n      ** is required by pragma table_info.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                    (int)(pSpan->zEnd - pSpan->zStart));\n      x.pLeft = pSpan->pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  sqlite3ExprDelete(db, pSpan->pExpr);\n}",
    "comment": "Validates and sets a default value for the last column of a new table, ensuring it is a constant expression before storing it.",
    "prorec_sum": "Sets a constant default value for a database column, creating and assigning the associated expression object, or reports an error if non-constant.",
    "filter_prorec_sum": "Updates a table column\u2019s default value when it is a constant, otherwise logs an error, and manages related memory references.",
    "prorec_aug_sum": "Validates a column\u2019s default value as constant, builds and assigns its data structure, and cleans up or reports an error if validation fails.",
    "filter_prorec_aug_sum": "Updates a table column\u2019s default value if it is constant, creating and attaching the necessary internal object, otherwise logs an error.",
    "work_score": {
        "prorec": {
            "summary": "Sets a constant default value for a database column, creating and assigning the associated expression object, or reports an error if non-constant.",
            "score": [
                0.8570576134221909,
                0.6856075635528567,
                0.8041980107620483
            ],
            "reason": [
                "The summary accurately describes the function's behavior: setting a default value for a database column and reporting an error if the value is non-constant. It captures the key operations of creating and assigning an expression object, aligning well with the source code. The claims are highly specific and verifiable, with only minor omissions regarding the handling of volatile memory and expression duplication.",
                "The summary accurately covers the core purpose of the function, which is to set a default value for a database column and handle errors if the value is non-constant. It mentions creating and assigning the associated expression object, aligning with the source code's operations involving expression duplication and assignment. However, it lacks detail on specific secondary behaviors like memory management (e.g., freeing and duplicating expressions) and the use of specific flags and tokens.",
                "The summary accurately describes the primary purpose of the function, which is to set a default value for a database column and report an error if the value is non-constant. This aligns with the core domain action and key I/O of the function. The summary provides specific insight into the function's behavior, offering high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Updates a table column\u2019s default value when it is a constant, otherwise logs an error, and manages related memory references.",
            "score": [
                0.879045268505924,
                0.7294544234092725,
                0.7952417339619509
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it updates a column's default value if the expression is constant, logs an error otherwise, and manages memory references. These claims align well with the source code, which checks for constant expressions, logs errors, and handles memory operations. The summary captures the core functionality with high precision.",
                "The summary accurately covers the core purpose of the function, which is to update a table column's default value when it is a constant, and log an error otherwise. It also mentions managing related memory references, which aligns with the function's operations of copying and deleting expressions. However, it lacks details on specific operations like checking if the expression is constant or function, and the use of tokens pointing to volatile memory.",
                "The summary accurately describes the primary purpose of the function, which is to update a table column's default value if it is constant, and log an error otherwise. It also mentions memory management, which aligns with the function's operations on memory references. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}",
    "comment": "The function processes the addition of an IGMP multicast group, initializing it and managing timers based on the interface's multicast version and state.",
    "prorec_sum": "Initializes a wireless station context if not already done, then updates or blocks its state based on connection flags and timing conditions.",
    "filter_prorec_sum": "Initializes a station context and updates its status or triggers wake/block actions based on connection flags and timing conditions.",
    "prorec_aug_sum": "Initializes state for a network device and conditionally triggers timestamp or mode updates based on its configuration flags and time-related checks.",
    "filter_prorec_aug_sum": "Initializes device state and conditionally triggers timer or status updates based on control fields and time comparisons within the associated device structure.",
    "work_score": {
        "prorec": {
            "summary": "Initializes a wireless station context if not already done, then updates or blocks its state based on connection flags and timing conditions.",
            "score": [
                0.063798729114169,
                0.08807970889295665,
                0.1363907177115675
            ],
            "reason": [
                "The summary does not accurately reflect the source code. The function 'igmp_group_added' deals with multicast group management, not wireless station context initialization or connection flags. The claims in the summary are unrelated to the actual function behavior, resulting in less than 50% accuracy.",
                "The summary does not accurately reflect the core purpose of the source code. The function 'igmp_group_added' is related to IGMP group management, specifically adding a multicast group to an interface and handling IGMP version-specific actions. The summary incorrectly describes operations related to a wireless station context, which is not present in the source code. There is almost no secondary information relevant to the actual function's behavior.",
                "The summary is inaccurate as it does not reflect the source code's purpose or actions. The source code deals with IGMP group management, not wireless station context initialization or connection flags. This represents a severe FATAL error regarding the PRIMARY PURPOSE, leading to a score in the 1-3 range."
            ]
        },
        "filter_prorec": {
            "summary": "Initializes a station context and updates its status or triggers wake/block actions based on connection flags and timing conditions.",
            "score": [
                0.07310585903489891,
                0.1,
                0.11480471923932738
            ],
            "reason": [
                "The summary does not accurately reflect the source code. The function 'igmp_group_added' deals with multicast group management, not station context initialization or connection flags. None of the claims in the summary align with the actual function behavior, resulting in less than 50% accuracy.",
                "The summary does not cover the core primary purpose of the function, which is to handle IGMP group addition by updating multicast group status and triggering related actions based on specific conditions. The summary inaccurately describes the function as initializing a station context and dealing with connection flags, which does not align with the source code's focus on multicast group management.",
                "The summary is entirely inaccurate as it does not describe the function's purpose or behavior. The function 'igmp_group_added' deals with multicast group management, not station context initialization or connection flags. This constitutes a severe FATAL error regarding the core domain action, making the summary unusable."
            ]
        }
    }
}
{
    "source_code": "static int shrink_dqcache_memory(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tint nr = sc->nr_to_scan;\n\n\tif (nr) {\n\t\tspin_lock(&dq_list_lock);\n\t\tprune_dqcache(nr);\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\treturn ((unsigned)\n\t\tpercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS])\n\t\t/100) * sysctl_vfs_cache_pressure;\n}",
    "comment": "Releases disk quota cache memory by pruning unused entries based on the specified number of entries to scan and adjusts the cache pressure accordingly.",
    "prorec_sum": "Releases and cleans up a set of linked resource objects under a lock, invoking their destructors, then returns a scaled usage metric value.",
    "filter_prorec_sum": "Cleans up and unlinks a set of linked structures, invokes their cleanup callbacks, and returns a scaled value based on a global counter.",
    "prorec_aug_sum": "Cleans up and unlinks a series of list entries, invoking associated destructors, then returns a scaled value based on a global counter.",
    "filter_prorec_aug_sum": "Cleans up and unlinks multiple linked structures, invokes their termination callbacks, then returns a scaled value based on a global 64\u2011bit counter.",
    "work_score": {
        "prorec": {
            "summary": "Releases and cleans up a set of linked resource objects under a lock, invoking their destructors, then returns a scaled usage metric value.",
            "score": [
                0.33309087136508914,
                0.346185052852839,
                0.433400314980504
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions releasing and cleaning up linked resource objects and invoking destructors, which is not evident in the source code. The function locks a list, prunes a cache, and returns a scaled metric, but does not explicitly release resources or invoke destructors. Less than 50% of the claims are accurate.",
                "The summary inaccurately describes the function's core purpose. The function 'shrink_dqcache_memory' primarily prunes the dqcache under a lock and returns a scaled metric based on free dquot count and cache pressure, but the summary incorrectly mentions 'linked resource objects' and 'destructors', which are not present in the source code. While the summary does mention returning a scaled metric, it fails to accurately cover the core operation of pruning dqcache, leading to several secondary points being missed.",
                "The summary inaccurately describes the function's behavior by stating it 'invokes destructors,' which is not evident in the source code, marking it as NOISE. The function does release resources under a lock, aligning with the summary, but the description of returning a 'scaled usage metric value' is vague and lacks specificity, contributing to low gain. The absence of FATAL inaccuracies allows for a score above 3, but the noise and low gain limit the score to 4."
            ]
        },
        "filter_prorec": {
            "summary": "Cleans up and unlinks a set of linked structures, invokes their cleanup callbacks, and returns a scaled value based on a global counter.",
            "score": [
                0.17472557052180535,
                0.2540421012427685,
                0.2731066554152028
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions cleaning up and unlinking linked structures and invoking cleanup callbacks, which are not present in the source code. The function actually locks a list, prunes a cache, and returns a scaled value based on a counter. Only the part about returning a scaled value is somewhat accurate, but overall, less than 50% of the claims align with the source code.",
                "The summary inaccurately describes the function's core purpose, which is to prune the dqcache based on the number to scan and return a scaled value from a counter. The summary mentions cleaning up and unlinking structures, which is not explicitly covered in the source code. It does mention returning a scaled value based on a global counter, which aligns with the function's return statement, but lacks coverage of the locking mechanism and specific counter operations.",
                "The summary inaccurately describes the function's behavior. It mentions 'cleans up and unlinks a set of linked structures' and 'invokes their cleanup callbacks,' which are not reflected in the source code. The function actually locks a list, prunes the cache, and returns a scaled value based on a counter, which is not captured in the summary. These inaccuracies are considered FATAL as they misrepresent the core domain action and key I/O, leading to a negative net benefit."
            ]
        }
    }
}
{
    "source_code": "\nvoid BN_CTX_end(BN_CTX *ctx)\n\t{\n\tCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\n\tif(ctx->err_stack)\n\t\tctx->err_stack--;\n\telse\n\t\t{\n\t\tunsigned int fp = BN_STACK_pop(&ctx->stack);\n\t\t/* Does this stack frame have anything to release? */\n\t\tif(fp < ctx->used)\n\t\t\tBN_POOL_release(&ctx->pool, ctx->used - fp);\n\t\tctx->used = fp;\n\t\t/* Unjam \"too_many\" in case \"get\" had failed */\n\t\tctx->too_many = 0;\n\t\t}\n\tCTXDBG_EXIT(ctx);\n\t}",
    "comment": "Releases resources associated with the BN_CTX structure, updating the used stack frame and resetting the too_many flag if necessary.",
    "prorec_sum": "Ends a big number context by restoring stack state, releasing allocated blocks, and updating depth and position tracking fields.",
    "filter_prorec_sum": "Releases temporary BIGNUM resources in a BN_CTX context, restoring stack and pool state after a scoped allocation ends.",
    "prorec_aug_sum": "Releases temporary big number variables and stack frames from a BN_CTX structure, restoring internal counters and linked context frames.",
    "filter_prorec_aug_sum": "Releases allocated big number context frames and restores internal state counters after nested usage.",
    "work_score": {
        "prorec": {
            "summary": "Ends a big number context by restoring stack state, releasing allocated blocks, and updating depth and position tracking fields.",
            "score": [
                0.8027170347779237,
                0.7717112395126818,
                0.793146625676388
            ],
            "reason": [
                "The summary accurately describes the function's behavior of restoring stack state and releasing allocated blocks, which aligns with the source code's operations of decrementing the error stack, popping the stack frame, releasing pool resources, and resetting the 'too_many' flag. The mention of updating depth and position tracking fields is somewhat generic but still relevant to the function's operations. Overall, the claims are highly specific and verifiable, with more than 80% accuracy.",
                "The summary accurately covers the core purpose of the function, which is to end a big number context by restoring stack state and releasing allocated blocks. It mentions updating depth and position tracking fields, aligning with the function's operations on 'ctx->used' and 'ctx->too_many'. While the summary captures most key points, it lacks specific mention of error stack handling, which is a critical behavior in the source code.",
                "The summary accurately describes the function's core actions: restoring stack state, releasing allocated blocks, and updating tracking fields, aligning well with the source code. The claims are specific and verifiable, providing high gain by clearly outlining the function's behavior. There is minimal noise, and no inaccuracies are present, resulting in a high net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Releases temporary BIGNUM resources in a BN_CTX context, restoring stack and pool state after a scoped allocation ends.",
            "score": [
                0.8409077353273094,
                0.7344053579121291,
                0.8092474181235862
            ],
            "reason": [
                "The summary accurately describes the function's behavior of releasing temporary BIGNUM resources and restoring stack and pool state after a scoped allocation ends. These claims align well with the source code, which involves decrementing the error stack, popping the stack frame, releasing the pool, and resetting the 'too_many' flag. The summary captures the core functionality without introducing inaccuracies, resulting in high precision.",
                "The summary accurately covers the core purpose of the function, which is to release temporary BIGNUM resources and restore the stack and pool state in a BN_CTX context. This aligns with the source code's operations of popping the stack, releasing the pool, and resetting the 'too_many' flag. However, while the core is covered, the summary could be more detailed in mentioning specific behaviors like handling the 'err_stack' and the conditional logic involved.",
                "The summary accurately describes the function's primary purpose of releasing temporary BIGNUM resources and restoring the stack and pool state after a scoped allocation ends. This aligns well with the source code, which shows the decrement of the error stack and the release of the pool resources based on the stack frame pointer. The claims are specific and provide a clear understanding of the function's behavior, offering high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic ssize_t\narray_size_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tsector_t sectors;\n\n\tif (strncmp(buf, \"default\", 7) == 0) {\n\t\tif (mddev->pers)\n\t\t\tsectors = mddev->pers->size(mddev, 0, 0);\n\t\telse\n\t\t\tsectors = mddev->array_sectors;\n\n\t\tmddev->external_size = 0;\n\t} else {\n\t\tif (strict_blocks_to_sectors(buf, &sectors) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->pers && mddev->pers->size(mddev, 0, 0) < sectors)\n\t\t\treturn -E2BIG;\n\n\t\tmddev->external_size = 1;\n\t}\n\n\tmddev->array_sectors = sectors;\n\tif (mddev->pers) {\n\t\tset_capacity(mddev->gendisk, mddev->array_sectors);\n\t\trevalidate_disk(mddev->gendisk);\n\t}\n\treturn len;\n}",
    "comment": "Sets the array size for a storage device based on input, updating capacity and validating the disk if a specific size is provided.",
    "prorec_sum": "Configures a device\u2019s operational mode, default or parsed from input, validates capacity, updates internal state, and applies provided parameter values.",
    "filter_prorec_sum": "Sets a device\u2019s configuration value to \u201cdefault\u201d or a parsed custom setting, validates limits, updates state, and applies provided calibration parameters.",
    "prorec_aug_sum": "Sets a device parameter to either the default or a validated custom value and updates related structures with provided configuration data.",
    "filter_prorec_aug_sum": "Configures the target object's current profile to either \"default\" or a validated custom value and updates related parameters through a linked handler.",
    "work_score": {
        "prorec": {
            "summary": "Configures a device\u2019s operational mode, default or parsed from input, validates capacity, updates internal state, and applies provided parameter values.",
            "score": [
                0.5719629035218625,
                0.4175687257753756,
                0.6158356249969283
            ],
            "reason": [
                "The summary correctly identifies that the function configures a device's operational mode based on input and updates internal state, which aligns with the source code's handling of 'default' and parsed input. However, it lacks specificity regarding the validation of capacity and the exact conditions under which internal state updates occur, such as the checks for 'mddev->pers' and the return values for errors. Approximately 50-80% of the claims are accurate, indicating mixed reliability.",
                "The summary covers the core purpose of configuring the device's operational mode and updating internal state, which aligns with setting the array size based on input or default. However, it lacks specificity regarding the validation of capacity against the parsed input and the handling of errors like -EINVAL and -E2BIG, which are critical behaviors in the source code.",
                "The summary captures the function's purpose of configuring the device's mode and updating internal state, which aligns with the source code. However, it lacks specificity regarding the validation of capacity and the exact conditions under which parameters are applied, resulting in a generic overview. The absence of detailed claims leads to low informational gain, and the summary does not contain any fatal inaccuracies, but the noise is noticeable due to its broadness."
            ]
        },
        "filter_prorec": {
            "summary": "Sets a device\u2019s configuration value to \u201cdefault\u201d or a parsed custom setting, validates limits, updates state, and applies provided calibration parameters.",
            "score": [
                0.3177516700958661,
                0.3951064034248709,
                0.47309280027945616
            ],
            "reason": [
                "The summary contains several inaccuracies. It correctly identifies that the function sets a device's configuration to 'default' or a custom setting and validates limits, which aligns with the code's logic of handling 'default' and parsing custom settings. However, it inaccurately mentions 'applies provided calibration parameters,' which is not present in the source code. Additionally, the summary does not mention the updating of 'array_sectors' or the revalidation of the disk, which are key operations in the function. Less than 50% of the claims are accurate.",
                "The summary covers the core purpose of setting a device's configuration value based on input, which aligns with the function's operation of setting 'array_sectors' and 'external_size'. However, it lacks specificity regarding the validation of limits and the application of calibration parameters, which are critical behaviors in the source code. The summary does not mention error handling or the specific conditions under which different actions are taken, such as the use of 'default' or custom settings.",
                "The summary correctly identifies the function's ability to set a configuration value to 'default' or a custom setting and update the state, which aligns with the source code. However, it inaccurately mentions 'calibration parameters,' which are not present in the code, introducing noise. The claims are mostly generic, providing limited insight, resulting in low net benefit."
            ]
        }
    }
}
{
    "source_code": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "comment": "Deletes all posix timers associated with the given signal structure by iterating through and removing each timer from the list.",
    "prorec_sum": "Removes and cleans up expired POSIX timers from a linked list, invoking appropriate callbacks or logging errors when timer handlers are missing.",
    "filter_prorec_sum": "Processes and removes expired POSIX timers from a linked list, invoking type-specific handlers and cleaning up associated resources.",
    "prorec_aug_sum": "Removes expired POSIX timers from a task\u2019s timer list, invoking their callbacks or cleanup routines as appropriate.",
    "filter_prorec_aug_sum": "Removes expired or invalid POSIX timer entries from a linked list and cleans up associated resources in kernel/posix-timers.c.",
    "work_score": {
        "prorec": {
            "summary": "Removes and cleans up expired POSIX timers from a linked list, invoking appropriate callbacks or logging errors when timer handlers are missing.",
            "score": [
                0.18453021051825808,
                0.2915105649424826,
                0.3070492189657874
            ],
            "reason": [
                "The summary claim that the function removes and cleans up expired POSIX timers is somewhat accurate as the function iterates and deletes timers from a list. However, the mention of invoking callbacks or logging errors is inaccurate; the source code only shows deletion of timers without callbacks or error logging mechanisms. Thus, less than 50% of claims are accurate.",
                "The summary inaccurately describes the function's core purpose. The core operation is to delete POSIX timers from a linked list, but the summary incorrectly mentions expired timers and callbacks or error logging, which are not present in the source code. While the summary does mention removing timers, it fails to accurately cover the core purpose and introduces inaccuracies about secondary behaviors.",
                "The summary inaccurately describes the function's behavior, as it does not remove expired timers or invoke callbacks/log errors. Instead, it deletes all POSIX timers from the list without checking expiration or handling errors. This constitutes a FATAL error regarding the PRIMARY PURPOSE of the function, leading to a negative benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Processes and removes expired POSIX timers from a linked list, invoking type-specific handlers and cleaning up associated resources.",
            "score": [
                0.2237590904150037,
                0.3398970229413062,
                0.33656104798766867
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It claims the function processes and removes expired POSIX timers, invoking type-specific handlers and cleaning up resources, which is not supported by the source code. The function simply deletes timers from a list without any indication of handling expiration or invoking specific handlers. Thus, less than 50% of the claims are accurate.",
                "The summary inaccurately describes the function's core purpose. The function 'exit_itimers' deletes POSIX timers from a linked list, but the summary incorrectly states it processes expired timers and invokes type-specific handlers, which is not evident in the source code. The core purpose of removing timers is mentioned, but the additional claims about expiration and handlers are inaccurate, leading to a lack of coverage of the core purpose and secondary behaviors.",
                "The summary inaccurately describes the function's purpose, claiming it processes and removes expired POSIX timers, which contradicts the source code. The function simply deletes all timers in the list without checking for expiration or invoking type-specific handlers. This constitutes a FATAL error regarding the PRIMARY PURPOSE, leading to a negative benefit."
            ]
        }
    }
}
{
    "source_code": "\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_substream *s;\n\tint res = 0;\n\n\tdown_write(&snd_pcm_link_rwsem);\n\twrite_lock_irq(&snd_pcm_link_rwlock);\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\tlist_del(&substream->link_list);\n\tsubstream->group->count--;\n\tif (substream->group->count == 1) {\t/* detach the last stream, too */\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\trelink_to_local(s);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(substream->group);\n\t}\n\trelink_to_local(substream);\n       _end:\n\twrite_unlock_irq(&snd_pcm_link_rwlock);\n\tup_write(&snd_pcm_link_rwsem);\n\treturn res;\n}",
    "comment": "Unlinks a PCM substream from its group and releases resources if it was the last linked stream in the group.",
    "prorec_sum": "Removes an entry from a linked structure, updates related counters, reinitializes list links, and triggers further processing when only one item remains.",
    "filter_prorec_sum": "Removes an entry from a linked list, updates related queue counters, resets pointers, and triggers follow-up processing with provided parameters.",
    "prorec_aug_sum": "Removes and reinitializes a linked list entry from an audio device structure, updates related counters, and triggers subsequent audio stream handling operations.",
    "filter_prorec_aug_sum": "Removes and invalidates a linked substream structure, updates reference counters, triggers cleanup routines, and reinitializes its list pointers before returning a status code.",
    "work_score": {
        "prorec": {
            "summary": "Removes an entry from a linked structure, updates related counters, reinitializes list links, and triggers further processing when only one item remains.",
            "score": [
                0.742204023714813,
                0.4875699771524394,
                0.7180796722939733
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it removes an entry from a linked structure, updates counters, and reinitializes list links. It also correctly notes further processing when only one item remains, aligning with the code's logic of detaching the last stream and freeing the group. Most claims are specific and verifiable, indicating high precision.",
                "The summary covers the core purpose of unlinking a PCM substream from a linked structure, which aligns with the core operation of the function. However, it lacks specificity regarding the handling of the last stream, error conditions, and synchronization mechanisms, which are critical secondary aspects of the source code.",
                "The summary accurately describes the function's behavior: removing an entry from a linked structure, updating counters, and reinitializing list links. It also correctly notes further processing when only one item remains. The claims are specific and align well with the source code, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Removes an entry from a linked list, updates related queue counters, resets pointers, and triggers follow-up processing with provided parameters.",
            "score": [
                0.39325424267561404,
                0.29848189008306875,
                0.4308749911067382
            ],
            "reason": [
                "The summary correctly identifies the removal of an entry from a linked list and the update of related counters, which aligns with the list deletion and counter decrement in the source code. However, it inaccurately mentions resetting pointers and triggering follow-up processing with provided parameters, which are not evident in the source code. Approximately 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of unlinking a PCM substream from its group, which involves specific operations like decrementing the group count and potentially freeing the group. The summary mentions removing an entry from a linked list and updating counters, which aligns with some secondary aspects, but lacks specificity regarding the core unlinking operation and related conditions.",
                "The summary contains NOISE as it inaccurately mentions 'updates related queue counters' and 'resets pointers', which are not present in the source code. The claim 'removes an entry from a linked list' is ACCURATE, but overall, the summary lacks specificity and contains inaccuracies, leading to a low net benefit."
            ]
        }
    }
}
{
    "source_code": "\n\nstatic ngx_int_t\nngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n    ngx_http_core_loc_conf_t       *clcf;\n    ngx_http_chunked_filter_ctx_t  *ctx;\n\n    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_out.content_length_n == -1\n        || r->expect_trailers)\n    {\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n\n        } else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }\n    }\n\n    return ngx_http_next_header_filter(r);\n}",
    "comment": "The function processes HTTP responses to enable chunked transfer encoding when conditions regarding content length and HTTP version are met.",
    "prorec_sum": "Handles HTTP request state by checking connection and configuration flags, resetting or allocating chunked filter context, and returning a status indicator.",
    "filter_prorec_sum": "Handles HTTP request state checks and initializes the chunked filter context if conditions are met, otherwise resets related fields and returns immediately.",
    "prorec_aug_sum": "Handles HTTP request state checks, clears or resets related fields, and allocates chunked filter context when specific conditions on timers and flags are met.",
    "filter_prorec_aug_sum": "Manages HTTP request state for chunked transfer encoding, validating conditions and allocating filter context before enabling the chunked filter module.",
    "work_score": {
        "prorec": {
            "summary": "Handles HTTP request state by checking connection and configuration flags, resetting or allocating chunked filter context, and returning a status indicator.",
            "score": [
                0.4394129336251032,
                0.3286350728841073,
                0.4564169510656595
            ],
            "reason": [
                "The summary makes several claims: it suggests the function handles HTTP request state (generic and correct to an extent), checks flags (somewhat accurate but vague), resets or allocates a chunked filter context (specific and accurate), and returns a status indicator (not specifically accurate as it returns a pointer). Only the claim about the filter context is precise. The remainder are generic and incomplete, leading to less than 50% of claims being highly accurate.",
                "The summary does not cover the core primary purpose of the function, which is to handle chunked transfer encoding for HTTP requests based on specific conditions. While it mentions handling HTTP request state and allocating chunked filter context, it lacks specificity about the conditions under which chunked encoding is applied, such as HTTP version checks and status codes. The summary provides some secondary information but misses key details about the function's behavior and decision-making process.",
                "The summary contains generic claims about handling HTTP request state and returning a status indicator, which are broadly accurate but low-info (SAFE). However, it lacks specific details about the function's behavior, such as the conditions under which chunked transfer encoding is set or when the content length is cleared. There are no FATAL inaccuracies, but the lack of specificity results in low net benefit, with noise noticeable due to the absence of detailed insights."
            ]
        },
        "filter_prorec": {
            "summary": "Handles HTTP request state checks and initializes the chunked filter context if conditions are met, otherwise resets related fields and returns immediately.",
            "score": [
                0.7269672358609554,
                0.5098908485230077,
                0.6277372646128873
            ],
            "reason": [
                "The summary accurately describes the function's behavior by mentioning the handling of HTTP request state checks and the initialization of the chunked filter context under specific conditions. It correctly notes the immediate return when conditions are not met, aligning well with the source code logic. The summary captures the core functionality without introducing inaccuracies, reflecting high precision.",
                "The summary covers the core purpose of the function, which is to initialize the chunked filter context under specific conditions. However, it lacks detail on secondary behaviors such as the specific conditions checked (e.g., HTTP status, content length, HTTP version) and the handling of trailers and keepalive settings. These are critical for understanding the function's complete behavior.",
                "The summary accurately reflects the core behavior of the function. It correctly mentions that the function handles HTTP request state checks and initializes the chunked filter context if certain conditions are met, which aligns with the logic in the source code. However, the wording 'resets related fields and returns immediately' is somewhat generic and lacks specificity about the exact fields modified. Overall, the claims are accurate and provide a beneficial overview of the function's purpose, resulting in high net benefit with minimal noise."
            ]
        }
    }
}
{
    "source_code": "static int compute_partition_size(Ecma119Image *t, char *disk_path,\n                                  uint32_t *size, int flag)\n{\n    int ret, keep;\n    off_t num;\n    struct stat stbuf;\n    struct iso_interval_reader *ivr;\n    off_t byte_count;\n\n    if (flag & 1) {\n        ret = iso_interval_reader_new(t->image, disk_path,\n                                      &ivr, &byte_count, 0);\n        if (ret < 0)\n            return ret;\n        *size = (byte_count + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        keep = iso_interval_reader_keep(t, ivr, 0);\n        iso_interval_reader_destroy(&ivr, 0);\n        if (keep < 0)\n            return keep;\n        return ISO_SUCCESS + (keep > 0);\n    }\n\n    *size = 0;\n    ret = stat(disk_path, &stbuf);\n    if (ret == -1)\n        return ISO_BAD_PARTITION_FILE;\n    if (! S_ISREG(stbuf.st_mode))\n        return ISO_BAD_PARTITION_FILE;\n    num = ((stbuf.st_size + 2047) / 2048);\n    if (num > 0x3fffffff || num == 0)\n        return ISO_BAD_PARTITION_FILE;\n    *size = num;\n    return ISO_SUCCESS;\n}",
    "comment": "Calculates the partition size from a disk path or an image based on a specified flag, ensuring valid file attributes and conditions.",
    "prorec_sum": "Determines a regular file\u2019s size in 2\u202fKB blocks using either a cached lookup or direct stat, returning error codes for invalid conditions.",
    "filter_prorec_sum": "Determines a file\u2019s block count from device or size data, using cached stat information when requested, and validates it is a regular file.",
    "prorec_aug_sum": "Retrieves file or device size in 2\u202fKB blocks after validating it is a regular file, returning specific error codes on failure conditions.",
    "filter_prorec_aug_sum": "Determines the file\u2019s size in 2\u202fKB blocks after validating its type, or retrieves equivalent size information via a filesystem-specific lookup.",
    "work_score": {
        "prorec": {
            "summary": "Determines a regular file\u2019s size in 2\u202fKB blocks using either a cached lookup or direct stat, returning error codes for invalid conditions.",
            "score": [
                0.8196128429292999,
                0.7116316786653726,
                0.7482042544580462
            ],
            "reason": [
                "The summary accurately describes the function's behavior of determining a file's size in 2 KB blocks using either a cached lookup or direct stat. It correctly mentions the return of error codes for invalid conditions, aligning well with the source code logic. However, it lacks specific details about the conditions under which each method is used, such as the flag parameter's role in deciding the method.",
                "The summary accurately covers the core purpose of the function, which is to determine a regular file's size in 2 KB blocks. It mentions the use of cached lookup or direct stat, aligning with the conditional logic in the source code. The summary also notes the return of error codes for invalid conditions, which corresponds to the handling of errors and edge cases in the code. However, it lacks mention of specific constants like BLOCK_SIZE and does not detail the exact error codes returned, which prevents a perfect score.",
                "The summary accurately describes the function's primary purpose of determining a file's size in 2 KB blocks and mentions the use of cached lookup or direct stat, which aligns with the source code. It correctly notes the return of error codes for invalid conditions, reflecting the function's behavior. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Determines a file\u2019s block count from device or size data, using cached stat information when requested, and validates it is a regular file.",
            "score": [
                0.5410970656355707,
                0.49631555792856324,
                0.5212615887204973
            ],
            "reason": [
                "The summary accurately mentions determining a file's block count and validating it as a regular file, aligning with the source code's logic. However, the claim about using cached stat information is inaccurate, as the code does not indicate caching behavior. Approximately 50-80% of the claims are accurate, leading to a mixed reliability score.",
                "The summary accurately mentions determining a file's block count and validating it as a regular file, which aligns with the core purpose of computing partition size. However, it lacks detail on the specific operations like using iso_interval_reader and handling flags, which are critical secondary behaviors in the source code.",
                "The summary accurately describes how the function 'determines a file\u2019s block count from device or size data' and 'validates it is a regular file.' These claims are directly supported by the implementation logic. However, the mention of 'using cached stat information when requested' is inaccurate as there is no indication of using cached stat info; instead, it uses the 'stat' system call synchronously. The inaccuracies are minor, while the summary provides specific and concise information about the core functionality of the code, resulting in high net benefit with low noise."
            ]
        }
    }
}
{
    "source_code": "\nstruct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)\n\t{\n\tstruct timeval timenow;\n\n\t/* If no timeout is set, just return NULL */\n\tif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)\n\t\t{\n\t\treturn NULL;\n\t\t}\n\n\t/* Get current time */\n\tget_current_time(&timenow);\n\n\t/* If timer already expired, set remaining time to 0 */\n\tif (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\n\t\t(s->d1->next_timeout.tv_sec == timenow.tv_sec &&\n\t\t s->d1->next_timeout.tv_usec <= timenow.tv_usec))\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\treturn timeleft;\n\t\t}\n\n\t/* Calculate time left until timer expires */\n\tmemcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n\ttimeleft->tv_sec -= timenow.tv_sec;\n\ttimeleft->tv_usec -= timenow.tv_usec;\n\tif (timeleft->tv_usec < 0)\n\t\t{\n\t\ttimeleft->tv_sec--;\n\t\ttimeleft->tv_usec += 1000000;\n\t\t}\n\n\t/* If remaining time is less than 15 ms, set it to 0\n\t * to prevent issues because of small devergences with\n\t * socket timeouts.\n\t */\n\tif (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\t}\n\t\n\n\treturn timeleft;\n\t}",
    "comment": "Calculates the remaining timeout for a DTLS connection and returns a struct timeval with the time left until expiration.",
    "prorec_sum": "Calculates the remaining time before a DTLS event expires and returns zero when the deadline has passed or is within 15 milliseconds.",
    "filter_prorec_sum": "Calculates the remaining time until a DTLS handshake retransmission deadline and returns zero if expired or below a minimal threshold.",
    "prorec_aug_sum": "Calculates and returns the remaining time until a stored DTLS timer expires, or zero if the deadline has passed or is very close.",
    "filter_prorec_aug_sum": "Calculates and returns the remaining time until the DTLS retransmission timeout based on current time and stored expiry values.",
    "work_score": {
        "prorec": {
            "summary": "Calculates the remaining time before a DTLS event expires and returns zero when the deadline has passed or is within 15 milliseconds.",
            "score": [
                0.9113235869884546,
                0.787253050103526,
                0.8471020897636418
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it calculates the remaining time before a DTLS event expires and returns zero when the deadline has passed or is within 15 milliseconds. These claims align well with the source code, which checks for expired timers and adjusts for small time divergences. The summary captures the core functionality without introducing inaccuracies.",
                "The summary accurately covers the core purpose of the function, which is to calculate the remaining time before a DTLS event expires. It correctly mentions returning zero when the deadline has passed or is within 15 milliseconds, aligning with the source code's logic for handling expired timers and small divergences. However, it lacks mention of specific details like the use of 'struct timeval' and the handling of negative microseconds, which are critical secondary behaviors.",
                "The summary accurately describes the function's behavior of calculating the remaining time before a DTLS event expires and returning zero when the deadline has passed or is within 15 milliseconds. This aligns well with the source code, which checks if the timeout has expired or is less than 15 milliseconds and sets the remaining time to zero in those cases. The claims are specific and provide a clear understanding of the function's primary purpose, offering high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Calculates the remaining time until a DTLS handshake retransmission deadline and returns zero if expired or below a minimal threshold.",
            "score": [
                0.8700016289954113,
                0.8347358598138863,
                0.8458840151684963
            ],
            "reason": [
                "The summary accurately describes the function's behavior of calculating the remaining time until a deadline and returning zero if the time is expired or below a minimal threshold. This aligns well with the source code, which checks for expiration and adjusts the time left, setting it to zero if below 15 ms. The claims are highly specific and verifiable, with over 80% accuracy.",
                "The summary accurately captures the core purpose of the function, which is calculating the remaining time until a DTLS handshake retransmission deadline and returning zero if expired or below a minimal threshold. This aligns with the source code's logic, including handling expired timers and minimal thresholds. However, the summary does not explicitly mention secondary details like the use of `get_current_time`, adjustments for negative microseconds, or the specific handling of small divergences with socket timeouts, which are behavior-critical semantics.",
                "The summary accurately captures the primary purpose of the function, which is to calculate the remaining time until a DTLS handshake retransmission deadline. It correctly notes that the function returns zero if the timer has expired or if the remaining time is below a minimal threshold. These claims are specific and verifiable against the source code, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "static int mmc_get_leadin_text_al(struct burn_drive *d,\n                                  unsigned char **text_packs, int *alloc_len,\n                                  int flag)\n{\n\tstruct buffer *buf = NULL;\n\tstruct command *c = NULL;\n\tunsigned char *data;\n\tint ret, data_length;\n\n\t*text_packs = NULL;\n\n\tBURN_ALLOC_MEM(buf, struct buffer, 1);\n\tBURN_ALLOC_MEM(c, struct command, 1);\n\n\tscsi_init_command(c, MMC_GET_LEADTEXT, sizeof(MMC_GET_LEADTEXT));\n\tc->dxfer_len = *alloc_len;\n\tc->opcode[7]= (c->dxfer_len >> 8) & 0xff;\n\tc->opcode[8]= c->dxfer_len & 0xff;\n\tc->retry = 1;\n\tc->page = buf;\n\tc->page->bytes = 0;\n\tc->page->sectors = 0;\n\n\tc->dir = FROM_DRIVE;\n\td->issue_command(d, c);\n\tif (c->error)\n\t\t{ret = 0; goto ex;}\n\n\tdata = c->page->data;\t\n\tdata_length = (data[0] << 8) + data[1];\n\t*alloc_len = data_length + 2;\n\tif (*alloc_len >= 22 && !(flag & 1)) {\n\t\tBURN_ALLOC_MEM(*text_packs, unsigned char, *alloc_len - 4);\n\t\tmemcpy(*text_packs, data + 4, *alloc_len - 4);\n\t}\n\tret = 1;\t\nex:;\n\tBURN_FREE_MEM(c);\n\tBURN_FREE_MEM(buf);\n\treturn ret;\n}",
    "comment": "Retrieves lead-in text from a drive and allocates memory for the text if the conditions are met, returning success or failure.",
    "prorec_sum": "Allocates and initializes buffers, processes data through a callback, and optionally extracts a payload segment into output based on size and flag conditions.",
    "filter_prorec_sum": "Allocates buffers, invokes a callback to fill them, validates length, and copies resulting ISO9660 volume data into the provided output pointer.",
    "prorec_aug_sum": "Allocates buffers, invokes a callback to fill them, reads a length-prefixed payload, and optionally copies the payload data into a provided output buffer.",
    "filter_prorec_aug_sum": "Allocates buffers, invokes a callback to fill them, then extracts and optionally copies payload data based on header length and a control flag.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes buffers, processes data through a callback, and optionally extracts a payload segment into output based on size and flag conditions.",
            "score": [
                0.7723721165054679,
                0.47322294575805524,
                0.5502405598747007
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it allocates and initializes buffers, processes data through a callback (issue_command), and conditionally extracts a payload segment based on size and flag conditions. These claims align well with the source code, where buffers are allocated, a command is issued, and data is conditionally copied based on alloc_len and flag. The summary captures the core operations and logic of the function, with over 80% of claims being accurate.",
                "The summary covers the core purpose of allocating and initializing buffers, which aligns with the source code's operations of memory allocation for 'buf' and 'c'. It also mentions processing data, which corresponds to the command issued to the drive and data extraction. However, the summary lacks specificity regarding the SCSI command initialization and the handling of errors, which are critical behaviors in the source code.",
                "The summary captures the key steps of the function like allocating buffers and conditionally extracting text based on conditions. The claim about processing data through a callback is slightly misleading as it uses a command issue process instead. There are no fatal inaccuracies, and noise is minimal, but the gain is high due to good alignment overall."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates buffers, invokes a callback to fill them, validates length, and copies resulting ISO9660 volume data into the provided output pointer.",
            "score": [
                0.4228391742487158,
                0.3382731902448525,
                0.41753678749195994
            ],
            "reason": [
                "The summary correctly mentions buffer allocation and copying data into an output pointer, aligning with the source code's use of BURN_ALLOC_MEM and memcpy. However, it inaccurately describes the function as invoking a callback, which is not present in the source code. Additionally, the summary's reference to ISO9660 volume data is misleading, as the source code does not specify this format. Approximately 50-80% of the claims are accurate, indicating mixed reliability.",
                "The summary mentions buffer allocation and data copying, which aligns with the source code's operations of allocating memory for buffers and copying data into text_packs. However, it inaccurately describes the function as invoking a callback and handling ISO9660 volume data, which is not present in the source code. The core purpose of issuing a SCSI command to retrieve lead-in text is not covered.",
                "The summary contains inaccuracies and noise. It correctly mentions buffer allocation and data copying, which aligns with the source code. However, it inaccurately describes the function as invoking a callback and handling ISO9660 volume data, which is not evident in the source code. The inaccuracies do not target the core purpose or key I/O, but they contribute to noticeable noise, limiting the net benefit."
            ]
        }
    }
}
{
    "source_code": "\nstatic int mntns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = ns;\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !nsown_capable(CAP_SYS_CHROOT) ||\n\t    !nsown_capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}",
    "comment": "Validates permissions, checks filesystem usage, updates the mount namespace in the nsproxy, and sets the current process's root and working directory.",
    "prorec_sum": "Validates inode-related conditions before updating a file reference and performing subsequent filesystem operations on the associated directory entry.",
    "filter_prorec_sum": "Validates several conditions, updates a reference to a new object, and performs a series of linked data structure operations if the current state equals one.",
    "prorec_aug_sum": "Validates multiple conditions, updates a reference, processes data through several helper routines, and finalizes operations when a specific runtime flag equals one.",
    "filter_prorec_aug_sum": "Validates multiple conditions on input parameters, updates a shared pointer, and performs a sequence of synchronized operations on associated data structures.",
    "work_score": {
        "prorec": {
            "summary": "Validates inode-related conditions before updating a file reference and performing subsequent filesystem operations on the associated directory entry.",
            "score": [
                0.13922207472599543,
                0.1525529260295014,
                0.17587210165845502
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions 'inode-related conditions' and 'updating a file reference,' which are not present in the source code. The function primarily deals with namespace capabilities and filesystem structure updates, not inode conditions or file references. Thus, the claims are mostly [INACCURATE] with less than 50% alignment.",
                "The summary does not accurately cover the core primary purpose of the function, which is to install a mount namespace into a nsproxy. The summary incorrectly mentions inode-related conditions and file reference updates, which are not present in the source code. It fails to mention the key operations such as capability checks, namespace assignment, and path updates, resulting in almost no secondary information being covered.",
                "The summary inaccurately describes the function's purpose and operations. It mentions inode-related conditions and file reference updates, which are not present in the source code. The function primarily deals with namespace capabilities and updates the filesystem structure, not inode conditions or file references. This represents a severe FATAL error regarding the core domain action, leading to a score in the 1-3 range."
            ]
        },
        "filter_prorec": {
            "summary": "Validates several conditions, updates a reference to a new object, and performs a series of linked data structure operations if the current state equals one.",
            "score": [
                0.48215346085890964,
                0.356007726736695,
                0.43540096619752705
            ],
            "reason": [
                "The summary correctly identifies that the function validates several conditions and updates references, which aligns with the checks for capabilities and the assignment of mnt_ns. However, it inaccurately describes the condition 'if the current state equals one' as the function checks if fs->users equals one, not the current state. The summary also lacks specificity regarding the linked data structure operations, which involve path manipulation and namespace updates, leading to mixed reliability.",
                "The summary mentions condition validation and updating references, which aligns with the permission checks and namespace updates in the source code. However, it lacks specificity about the core purpose of installing a mount namespace and updating the filesystem structure, which is crucial. The summary is vague and does not cover the core domain operation of setting the filesystem's root and pwd based on the new namespace.",
                "The summary correctly identifies that the function validates conditions and updates references, which aligns with the source code's checks for capabilities and user count, and the update of nsproxy->mnt_ns. However, it lacks specificity regarding the exact conditions checked and the detailed operations performed on the data structures, such as the manipulation of the root path and the namespace. The summary's generic nature results in low informational gain, and while there is no fatal inaccuracy, the lack of detail limits the net benefit."
            ]
        }
    }
}
{
    "source_code": "\n\nstatic void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,\n\t\t\t\t     u32 value)\n{\n\tdrm_i915_private_t *dev_priv = ring->dev->dev_private;\n\n       /* Every tail move must follow the sequence below */\n\n\t/* Disable notification that the ring is IDLE. The GT\n\t * will then assume that it is busy and bring it out of rc6.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n\n\t/* Clear the context id. Here be magic! */\n\tI915_WRITE64(GEN6_BSD_RNCID, 0x0);\n\n\t/* Wait for the ring not to be idle, i.e. for it to wake up. */\n\tif (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &\n\t\t      GEN6_BSD_SLEEP_INDICATOR) == 0,\n\t\t     50))\n\t\tDRM_ERROR(\"timed out waiting for the BSD ring to wake up\\n\");\n\n\t/* Now that the ring is fully powered up, update the tail */\n\tI915_WRITE_TAIL(ring, value);\n\tPOSTING_READ(RING_TAIL(ring->mmio_base));\n\n\t/* Let the ring send IDLE messages to the GT again,\n\t * and so let it sleep to conserve power when idle.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n}",
    "comment": "Updates the tail of the BSD ring buffer after ensuring the ring is active and managing power-saving notifications.",
    "prorec_sum": "Writes commands to the BSD ring buffer and waits for it to become idle before issuing further GPU instructions.",
    "filter_prorec_sum": "Writes commands to the gen6 BSD hardware ring, waits for it to wake up with a timeout, then issues final control writes.",
    "prorec_aug_sum": "Writes commands to the BSD ring buffer and waits until it becomes ready, logging a timeout error if wake\u2011up does not occur.",
    "filter_prorec_aug_sum": "Writes commands to the Gen6 BSD ring buffer and waits for it to wake, timing out and logging an error if necessary.",
    "work_score": {
        "prorec": {
            "summary": "Writes commands to the BSD ring buffer and waits for it to become idle before issuing further GPU instructions.",
            "score": [
                0.19445781028544573,
                0.2754546412939647,
                0.2744739122916623
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions waiting for the BSD ring buffer to become idle before issuing further GPU instructions, which contradicts the source code. The function actually waits for the ring to wake up, not become idle, before updating the tail. This is a critical misrepresentation of the function's sequence, resulting in a low proportion of accurate claims.",
                "The summary does not cover the core primary purpose of the function, which is to update the tail of the BSD ring buffer after ensuring it is powered up. The summary inaccurately states that the function waits for the ring to become idle, whereas the source code shows it waits for the ring to wake up. The summary lacks coverage of secondary details such as disabling/enabling idle notifications and handling potential timeout errors.",
                "The summary inaccurately describes the function's behavior by stating it waits for the BSD ring buffer to become idle before issuing further GPU instructions, which contradicts the source code. The function actually waits for the ring to wake up, not become idle, before updating the tail. This is a FATAL error regarding the core domain action. There are no accurate claims to provide positive gain."
            ]
        },
        "filter_prorec": {
            "summary": "Writes commands to the gen6 BSD hardware ring, waits for it to wake up with a timeout, then issues final control writes.",
            "score": [
                0.782268101181662,
                0.486478207296111,
                0.6840386790858445
            ],
            "reason": [
                "The summary accurately describes the sequence of operations in the source code: writing commands to the hardware ring, waiting for it to wake up with a timeout, and issuing final control writes. These steps align well with the function's behavior, capturing the core actions performed by the code. However, the summary lacks specific details about disabling and enabling notifications and clearing the context id, which are also part of the function's operations.",
                "The summary covers the core purpose of writing commands to the gen6 BSD hardware ring and waiting for it to wake up, which aligns with the core operation of updating the ring tail after ensuring the ring is powered up. However, it lacks detail on disabling/enabling idle notifications, clearing context ID, and handling errors, which are critical secondary behaviors in the source code.",
                "The summary accurately captures the sequence of operations in the function: writing commands to the hardware ring, waiting for it to wake up, and issuing final control writes. While the summary is concise and lacks specific details about the disabling/enabling of sleep messages and context ID clearing, it correctly identifies the primary purpose and key actions without introducing inaccuracies or overwhelming noise."
            ]
        }
    }
}
{
    "source_code": "int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active)\n{\n\tint nr_done = 0;\n\tu32 done_mask;\n\n\tdone_mask = ap->qc_active ^ qc_active;\n\n\tif (unlikely(done_mask & qc_active)) {\n\t\tata_port_err(ap, \"illegal qc_active transition (%08x->%08x)\\n\",\n\t\t\t     ap->qc_active, qc_active);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_done++;\n\t\t}\n\t\tdone_mask &= ~(1 << tag);\n\t}\n\n\treturn nr_done;\n}",
    "comment": "Processes and completes multiple ATA queued commands based on the active command status while checking for illegal state transitions.",
    "prorec_sum": "Validates and updates qc_active state bits, logging illegal transitions and invoking handlers for each newly activated bit in the ATA port structure.",
    "filter_prorec_sum": "Validates qc_active bit transitions, logs illegal changes, and processes newly activated bits by invoking related handlers.",
    "prorec_aug_sum": "Validates and processes changes to a qc_active bitmask, logging illegal transitions and invoking handlers for each newly activated queue command slot.",
    "filter_prorec_aug_sum": "Validates and processes changes in qc_active bitmask, logging illegal transitions and invoking handlers for newly activated ATA queued commands.",
    "work_score": {
        "prorec": {
            "summary": "Validates and updates qc_active state bits, logging illegal transitions and invoking handlers for each newly activated bit in the ATA port structure.",
            "score": [
                0.6144780970370121,
                0.5550702052629137,
                0.5214075255015164
            ],
            "reason": [
                "The summary accurately describes the function's behavior of validating and updating qc_active state bits, logging illegal transitions, and invoking handlers for each newly activated bit. These claims align well with the source code, where the function checks for illegal transitions, logs errors, and processes active bits. The summary captures the core functionality, with over 80% of claims being accurate.",
                "The summary covers the core purpose of validating and updating qc_active state bits, which aligns with the function's operation of checking and completing queued commands. However, it lacks detail on specific secondary behaviors such as handling errors with illegal transitions and the exact mechanism of invoking handlers for each activated bit, which are critical aspects of the source code.",
                "The summary correctly identifies the function's role in validating and updating the qc_active state bits and logging illegal transitions, which aligns with the source code's behavior. However, it inaccurately describes the invocation of handlers for each newly activated bit, as the function completes commands for bits that are no longer active, not newly activated. This introduces noise, reducing the overall benefit of the summary."
            ]
        },
        "filter_prorec": {
            "summary": "Validates qc_active bit transitions, logs illegal changes, and processes newly activated bits by invoking related handlers.",
            "score": [
                0.8393115373139365,
                0.7222589480780078,
                0.7912841153848931
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it validates qc_active transitions, logs illegal changes, and processes activated bits. These claims align well with the source code, which checks for illegal transitions, logs errors, and processes commands based on the done_mask. The summary captures the core functionality, with over 80% of claims being accurate.",
                "The summary accurately covers the core purpose of the function, which is to validate qc_active bit transitions and log illegal changes, aligning with the source code's operation of checking for illegal transitions and returning an error if found. It also mentions processing newly activated bits by invoking related handlers, which corresponds to the function's loop that completes queued commands. However, it lacks details on specific error handling (returning -EINVAL) and does not mention the exact mechanism of processing bits (using ata_qc_complete).",
                "The summary accurately describes the function's behavior: it validates qc_active transitions, logs illegal changes, and processes bits by invoking handlers. These claims align well with the source code, which checks for illegal transitions, logs errors, and processes commands. The summary provides specific insights into the function's core actions, offering high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (__glibc_unlikely (*err != REG_NOERROR && branch == NULL))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
    "comment": "Parses a regular expression into a binary tree structure while managing alternative branches and backreference mapping.",
    "prorec_sum": "Processes repeated type\u201110 records by invoking subordinate handlers, temporarily adjusting a link\u2011state field, and merging their results into a cumulative linked structure.",
    "filter_prorec_sum": "Processes and merges link-related symbol data in a loop when a specific flag is set, handling errors and restoring state appropriately.",
    "prorec_aug_sum": "Processes input records with type 10 by repeatedly merging results from two retrieval calls, updating state fields, and handling error or cleanup conditions.",
    "filter_prorec_aug_sum": "Processes input records with type 10 by repeatedly merging parsed results and updating state, handling errors via cleanup and restoring section pointer values.",
    "work_score": {
        "prorec": {
            "summary": "Processes repeated type\u201110 records by invoking subordinate handlers, temporarily adjusting a link\u2011state field, and merging their results into a cumulative linked structure.",
            "score": [
                0.05856350969440556,
                0.11702827523137269,
                0.1636893119547837
            ],
            "reason": [
                "The summary does not accurately reflect the source code. The source code describes a function for parsing regular expressions and handling alternation operators, while the summary mentions processing type-10 records and adjusting link-state fields, which are not present in the code. This results in less than 50% of the claims being accurate.",
                "The summary does not cover the core primary purpose of the function, which is to parse regular expressions and construct a binary tree representing the parsed structure. The summary inaccurately describes the function as processing type-10 records and adjusting a link-state field, which does not align with the source code's operations. There is almost no secondary information relevant to the function's behavior, such as error handling or branch conditions.",
                "The summary contains several inaccuracies and does not align with the source code. It mentions processing 'type-10 records' and 'invoking subordinate handlers,' which are not present in the code. The summary fails to describe the function's primary purpose of parsing regular expressions and handling alternation operators. These inaccuracies are considered FATAL as they misrepresent the core domain action of the function."
            ]
        },
        "filter_prorec": {
            "summary": "Processes and merges link-related symbol data in a loop when a specific flag is set, handling errors and restoring state appropriately.",
            "score": [
                0.1,
                0.14230518386745128,
                0.17865877078339767
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions processing and merging link-related symbol data, which is not evident in the source code. The function appears to parse regular expressions and handle errors, but there is no indication of link-related symbol data processing. Thus, the claims are mostly NOISE, with less than 50% accuracy.",
                "The summary does not cover the core primary purpose of the function, which is to parse regular expressions and construct a binary tree representing the parsed structure. The summary inaccurately describes the function as processing link-related symbol data, which contradicts the source code semantics. Additionally, it fails to mention any secondary behavior-critical semantics such as handling of alternative branches, error conditions, or state restoration related to the parsing process.",
                "The summary is inaccurate as it does not describe the function's purpose or behavior correctly. The function 'parse_reg_exp' processes regular expressions, not link-related symbol data. It handles errors and restores state, but the summary's focus on a specific flag and link-related symbols is misleading and contradicts the source code semantics, constituting a severe FATAL error regarding the core domain action."
            ]
        }
    }
}
{
    "source_code": "static int\nefivar_create_sysfs_entry(struct efivar_entry *new_var)\n{\n\tint i, short_name_size;\n\tchar *short_name;\n\tunsigned long variable_name_size;\n\tefi_char16_t *variable_name;\n\n\tvariable_name = new_var->var.VariableName;\n\tvariable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);\n\n\t/*\n\t * Length of the variable bytes in ASCII, plus the '-' separator,\n\t * plus the GUID, plus trailing NUL\n\t */\n\tshort_name_size = variable_name_size / sizeof(efi_char16_t)\n\t\t\t\t+ 1 + EFI_VARIABLE_GUID_LEN + 1;\n\n\tshort_name = kzalloc(short_name_size, GFP_KERNEL);\n\n\tif (!short_name)\n\t\treturn 1;\n\n\t/* Convert Unicode to normal chars (assume top bits are 0),\n\t   ala UTF-8 */\n\tfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\n\t\tshort_name[i] = variable_name[i] & 0xFF;\n\t}\n\t/* This is ugly, but necessary to separate one vendor's\n\t   private variables from another's.         */\n\n\t*(short_name + strlen(short_name)) = '-';\n\tefi_guid_unparse(&new_var->var.VendorGuid,\n\t\t\t short_name + strlen(short_name));\n\n\tnew_var->kobj.kset = efivars_kset;\n\n\ti = kobject_init_and_add(&new_var->kobj, &efivar_ktype,\n\t\t\t\t   NULL, \"%s\", short_name);\n\tkfree(short_name);\n\tif (i)\n\t\treturn 1;\n\n\tkobject_uevent(&new_var->kobj, KOBJ_ADD);\n\tefivar_entry_add(new_var, &efivar_sysfs_list);\n\n\treturn 0;\n}",
    "comment": "Creates a sysfs entry for a new EFI variable by converting its Unicode name to ASCII and adding it to the kernel's object hierarchy.",
    "prorec_sum": "Formats a memory buffer with a \u201c%pUl\u201d identifier, updates device-specific pointers, and registers the prepared data structure for further processing.",
    "filter_prorec_sum": "Formats a string containing a GUID with the \"%pUl\" specifier, stores it in a buffer, and registers it into the object's data structure.",
    "prorec_aug_sum": "Allocates and formats a buffer with a device identifier, updates related state pointers, invokes registration routines, and finalizes associated device setup.",
    "filter_prorec_aug_sum": "Formats and sends a \"%pUl\" identifier to a hardware-related structure, updates associated pointers, and finalizes with a device-specific handler call.",
    "work_score": {
        "prorec": {
            "summary": "Formats a memory buffer with a \u201c%pUl\u201d identifier, updates device-specific pointers, and registers the prepared data structure for further processing.",
            "score": [
                0.10648942682706966,
                0.1106690598206238,
                0.15925790060702763
            ],
            "reason": [
                "The summary contains claims that are largely inaccurate. It mentions formatting a memory buffer with a '%pUl' identifier, which is not present in the source code. It also refers to updating device-specific pointers and registering a data structure for further processing, which are not explicitly described in the code. The function primarily deals with creating a sysfs entry for an EFI variable, converting Unicode to ASCII, and handling kobject operations. Less than 50% of the claims align with the source code, indicating low accuracy.",
                "The summary does not cover the core primary purpose of the function, which is to create a sysfs entry for an EFI variable. The summary inaccurately describes formatting a memory buffer with a '%pUl' identifier and updating device-specific pointers, which are not present in the source code. It fails to mention key operations such as converting Unicode to ASCII, handling GUIDs, and interacting with kobject and sysfs, which are critical behaviors in the source code.",
                "The summary contains FATAL inaccuracies about the PRIMARY PURPOSE of the function. It incorrectly describes the function as formatting a buffer with a '%pUl' identifier and updating device-specific pointers, whereas the function actually creates a sysfs entry for an EFI variable. There are no accurate claims in the summary, resulting in a negative or zero benefit from the provided information."
            ]
        },
        "filter_prorec": {
            "summary": "Formats a string containing a GUID with the \"%pUl\" specifier, stores it in a buffer, and registers it into the object's data structure.",
            "score": [
                0.15055091038261753,
                0.20603964697327415,
                0.2699301815121631
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions formatting a GUID with the '%pUl' specifier, which is not present in the source code. The function actually converts a Unicode variable name to ASCII, appends a '-' separator, and un-parses a GUID into the short_name buffer. Only the registration of the object into the data structure is correctly mentioned, resulting in less than 50% accuracy.",
                "The summary does not cover the core primary purpose of the function, which is to create a sysfs entry for an EFI variable. It inaccurately describes the formatting of a GUID with '%pUl', which is not present in the source code. The summary lacks coverage of key operations such as memory allocation, Unicode conversion, and kobject initialization, which are critical behaviors in the source code.",
                "The summary inaccurately describes the function's behavior, focusing on formatting a GUID with a '%pUl' specifier, which is not present in the source code. This constitutes a FATAL error regarding the core domain action, as the function's primary purpose involves creating a sysfs entry with a short name derived from a variable name and GUID, not formatting a GUID with '%pUl'. The summary fails to capture the key I/O and side effects accurately, leading to a negative benefit."
            ]
        }
    }
}
{
    "source_code": "\nvoid __cpuinit start_secondary(void)\n{\n\tunsigned int cpu;\n\tunsigned long thread_ptr;\n\n\t/*  Calculate thread_info pointer from stack pointer  */\n\t__asm__ __volatile__(\n\t\t\"%0 = SP;\\n\"\n\t\t: \"=r\" (thread_ptr)\n\t);\n\n\tthread_ptr = thread_ptr & ~(THREAD_SIZE-1);\n\n\t__asm__ __volatile__(\n\t\tQUOTED_THREADINFO_REG \" = %0;\\n\"\n\t\t:\n\t\t: \"r\" (thread_ptr)\n\t);\n\n\t/*  Set the memory struct  */\n\tatomic_inc(&init_mm.mm_count);\n\tcurrent->active_mm = &init_mm;\n\n\tcpu = smp_processor_id();\n\n\tsetup_irq(BASE_IPI_IRQ + cpu, &ipi_intdesc);\n\n\t/*  Register the clock_event dummy  */\n\tsetup_percpu_clockdev();\n\n\tprintk(KERN_INFO \"%s cpu %d\\n\", __func__, current_thread_info()->cpu);\n\n\tnotify_cpu_starting(cpu);\n\n\tset_cpu_online(cpu, true);\n\n\tlocal_irq_enable();\n\n\tcpu_startup_entry(CPUHP_ONLINE);\n}",
    "comment": "Initializes the secondary CPU by configuring memory management, enabling interrupts, and signaling readiness for operation within a multiprocessor environment.",
    "prorec_sum": "Initializes and synchronizes a secondary CPU during SMP startup, performing setup, waiting for readiness, and enabling interrupts before resuming execution.",
    "filter_prorec_sum": "Initializes and synchronizes a CPU during SMP startup, setting per\u2011CPU state, invoking init callbacks, and enabling it for scheduling.",
    "prorec_aug_sum": "Initializes and synchronizes a CPU during SMP startup, performing hardware setup, time initialization, memory mapping, and enabling interrupts before entering normal operation.",
    "filter_prorec_aug_sum": "Initializes a secondary CPU during SMP boot, synchronizing with startup flags, setting per\u2011CPU data, and enabling it for normal operation.",
    "work_score": {
        "prorec": {
            "summary": "Initializes and synchronizes a secondary CPU during SMP startup, performing setup, waiting for readiness, and enabling interrupts before resuming execution.",
            "score": [
                0.5300055401851298,
                0.4799972570571568,
                0.5650832291694894
            ],
            "reason": [
                "The summary correctly identifies the function's role in initializing a secondary CPU during SMP startup, which aligns with the source code's operations like setting up IRQs and enabling interrupts. However, it inaccurately mentions 'waiting for readiness,' which is not evident in the source code, reducing the proportion of accurate claims.",
                "The summary covers the core purpose of initializing a secondary CPU during SMP startup, which aligns with the source code's operations like setting up IRQs and enabling interrupts. However, it lacks detail on specific actions such as calculating the thread_info pointer, incrementing mm_count, and registering the clock_event dummy, which are critical for full coverage.",
                "The summary correctly identifies the function's role in initializing a secondary CPU during SMP startup, which aligns with the core purpose of the source code. However, it inaccurately mentions 'waiting for readiness,' which is not evident in the source code, contributing to noise. The summary lacks specific details about key operations like setting memory structures and registering clock events, resulting in low gain from accurate claims."
            ]
        },
        "filter_prorec": {
            "summary": "Initializes and synchronizes a CPU during SMP startup, setting per\u2011CPU state, invoking init callbacks, and enabling it for scheduling.",
            "score": [
                0.6482028184635441,
                0.6179834331884699,
                0.7645108170435123
            ],
            "reason": [
                "The summary accurately describes the function's role in initializing and synchronizing a CPU during SMP startup, setting per-CPU state, and enabling it for scheduling. It mentions invoking init callbacks, which aligns with the function's operations like setting memory structures, registering clock events, and notifying CPU startup. Most claims are specific and verifiable, with high alignment to the source code.",
                "The summary covers the core purpose of initializing and synchronizing a CPU during SMP startup, which aligns with the source code's operations like setting per-CPU state and enabling it for scheduling. However, it lacks coverage of secondary details such as the calculation of thread_info pointer, memory struct setup, IRQ setup, and clock event registration, which are critical behaviors in the source code.",
                "The summary accurately captures the primary purpose of the function, which is to initialize and synchronize a CPU during SMP startup. It mentions setting per-CPU state and enabling it for scheduling, which aligns with the source code actions such as setting the memory struct, registering the clock event, and enabling local IRQs. The summary is concise and specific, providing high gain by highlighting key operations like invoking init callbacks and enabling scheduling. There is minimal noise, and the claims are mostly accurate, contributing to a high net benefit."
            ]
        }
    }
}
{
    "source_code": "\nstatic acpi_status acpi_dev_process_resource(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct res_proc_context *c = context;\n\tstruct resource r;\n\tint i;\n\n\tif (c->preproc) {\n\t\tint ret;\n\n\t\tret = c->preproc(ares, c->preproc_data);\n\t\tif (ret < 0) {\n\t\t\tc->error = ret;\n\t\t\treturn AE_CTRL_TERMINATE;\n\t\t} else if (ret > 0) {\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tmemset(&r, 0, sizeof(r));\n\n\tif (acpi_dev_resource_memory(ares, &r)\n\t    || acpi_dev_resource_io(ares, &r)\n\t    || acpi_dev_resource_address_space(ares, &r)\n\t    || acpi_dev_resource_ext_address_space(ares, &r))\n\t\treturn acpi_dev_new_resource_entry(&r, c);\n\n\tfor (i = 0; acpi_dev_resource_interrupt(ares, i, &r); i++) {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_dev_new_resource_entry(&r, c);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t}\n\n\treturn AE_OK;\n}",
    "comment": "Processes ACPI resources by calling preprocessing functions, handling memory, I/O, and address space resources, and creating new resource entries as needed.",
    "prorec_sum": "Processes hardware or ACPI data from the given structure, invoking resource-specific handlers and iterating elements to apply a standardized processing routine with error handling.",
    "filter_prorec_sum": "Processes hardware resource data from an input structure, invoking specific handlers and performing iterative operations to update the target structure with provided parameters.",
    "prorec_aug_sum": "Processes ACPI operand data by invoking region handlers or iterating field extraction routines, then dispatches results to a common evaluation function with provided parameters.",
    "filter_prorec_aug_sum": "Processes an ACPI operand by invoking its handler or iterating field elements, populating a local buffer, and executing a common evaluation routine.",
    "work_score": {
        "prorec": {
            "summary": "Processes hardware or ACPI data from the given structure, invoking resource-specific handlers and iterating elements to apply a standardized processing routine with error handling.",
            "score": [
                0.54212179825386,
                0.4659574087030262,
                0.4992087233663985
            ],
            "reason": [
                "The summary correctly identifies that the function processes ACPI data and involves error handling, which aligns with the source code. However, it lacks specificity regarding the invocation of resource-specific handlers and the iteration process, which are key aspects of the function's behavior. This results in mixed reliability, as only some claims are accurately detailed.",
                "The summary covers the core purpose of processing ACPI resources with error handling, aligning with the function's operation of invoking resource-specific handlers and iterating over elements. However, it lacks specificity in describing the exact domain operations like handling memory, I/O, and address spaces, and does not mention the pre-processing step or the termination condition.",
                "The summary provides a generic overview of the function's purpose, mentioning processing of hardware or ACPI data and error handling, which aligns with the source code. However, it lacks specific details about the function's operations, such as the invocation of pre-processing functions and the handling of different resource types. The claims are mostly SAFE but provide low informational gain, and there is no FATAL error, although the lack of specificity results in mediocre net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Processes hardware resource data from an input structure, invoking specific handlers and performing iterative operations to update the target structure with provided parameters.",
            "score": [
                0.464711656803804,
                0.44418260332569004,
                0.46738147680650866
            ],
            "reason": [
                "The summary correctly identifies that the function processes hardware resource data and invokes specific handlers, which aligns with the function's use of preproc and resource processing functions. However, it lacks specificity regarding the iterative operations and the conditions under which different handlers are invoked, leading to mixed reliability.",
                "The summary covers the core purpose of processing hardware resource data from an input structure, which aligns with the function's operation of handling ACPI resources. However, it lacks specificity regarding the pre-processing step, error handling, and the iterative processing of interrupts, which are critical behaviors in the source code.",
                "The summary provides a generic overview of the function's purpose, mentioning processing of hardware resource data and iterative operations, which aligns with the source code's actions. However, it lacks specificity regarding the function's key operations, such as the handling of pre-processing errors and the specific resource types processed. The absence of detailed claims results in low informational gain, and the summary does not contain any inaccurate claims, thus avoiding a negative impact."
            ]
        }
    }
}
{
    "source_code": "\nvoid native_play_dead(void)\n{\n\tplay_dead_common();\n\ttboot_shutdown(TB_SHUTDOWN_WFS);\n\n\tmwait_play_dead();\t/* Only returns on failure */\n\tif (cpuidle_play_dead())\n\t\thlt_play_dead();\n}",
    "comment": "Initiates a shutdown sequence and enters a low-power state, managing transitions based on CPU idle status and system power states.",
    "prorec_sum": "Initializes CPU idle monitoring using MONITOR/MWAIT instructions when specific hardware conditions are met, otherwise handles CPU bug checks and halts if critical errors occur.",
    "filter_prorec_sum": "Monitors a specific memory location using CPU MWAIT until triggered, then executes a handler, otherwise halts the processor under certain system state conditions.",
    "prorec_aug_sum": "Puts the CPU into a monitored low\u2011power idle state using MWAIT after cache flush, based on specific system and processor capability checks.",
    "filter_prorec_aug_sum": "Initializes CPU cache monitoring parameters and repeatedly enters low-power wait states until a wake condition occurs, then handles system halt on critical state.",
    "work_score": {
        "prorec": {
            "summary": "Initializes CPU idle monitoring using MONITOR/MWAIT instructions when specific hardware conditions are met, otherwise handles CPU bug checks and halts if critical errors occur.",
            "score": [
                0.18533640679245353,
                0.2861155126902747,
                0.3119009843732404
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions initializing CPU idle monitoring using MONITOR/MWAIT instructions, which is not explicitly stated in the source code. The function calls 'mwait_play_dead()', but the summary incorrectly adds context about hardware conditions and CPU bug checks that are not present in the code. Only a small portion of the claims align with the actual function behavior, resulting in a low score.",
                "The summary does not accurately cover the core primary purpose of the function, which involves executing a sequence of functions related to CPU shutdown and idle states. The summary incorrectly emphasizes CPU idle monitoring and error handling, which are not the main focus of the source code. While it mentions halting, it misses the specific sequence of operations like 'play_dead_common', 'tboot_shutdown', and 'mwait_play_dead'.",
                "The summary inaccurately describes the function's behavior, focusing on CPU idle monitoring and hardware conditions, which are not present in the source code. The function primarily involves shutting down and handling CPU states, with no mention of MONITOR/MWAIT instructions or bug checks. The inaccuracies are overwhelming, leading to a net benefit close to zero."
            ]
        },
        "filter_prorec": {
            "summary": "Monitors a specific memory location using CPU MWAIT until triggered, then executes a handler, otherwise halts the processor under certain system state conditions.",
            "score": [
                0.16068251420732707,
                0.2956199798636672,
                0.2731066554152029
            ],
            "reason": [
                "The summary inaccurately represents the source code's function. It emphasizes monitoring a memory location with CPU MWAIT until triggered, which is not explicitly detailed in the code. The use of 'halt the processor under certain system state conditions' tangentially relates to the stopping mechanisms in the code but doesn't explicitly describe the function's operations like 'play_dead_common' or 'tboot_shutdown'. Therefore, only a very small proportion of claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which involves calling 'play_dead_common', 'tboot_shutdown', and handling failure with 'mwait_play_dead'. It inaccurately describes the function as monitoring memory with MWAIT, which is not explicitly stated in the source code. The summary mentions halting the processor, which aligns with 'hlt_play_dead', but lacks coverage of other critical behaviors like shutdown and failure handling.",
                "The summary contains inaccuracies regarding the function's behavior. It mentions monitoring a specific memory location using CPU MWAIT, which is not explicitly stated in the source code. The summary also incorrectly describes the function's execution flow, as it does not mention the shutdown and halt operations accurately. These inaccuracies are considered FATAL as they misrepresent the core domain action and key side effects of the function. The noise from these inaccuracies overwhelms any accurate claims, resulting in a net benefit close to zero."
            ]
        }
    }
}
{
    "source_code": "static int apply_envelope(struct ml_effect_state *state, int value,\n\t\t\t  struct ff_envelope *envelope)\n{\n\tstruct ff_effect *effect = state->effect;\n\tunsigned long now = jiffies;\n\tint time_from_level;\n\tint time_of_envelope;\n\tint envelope_level;\n\tint difference;\n\n\tif (envelope->attack_length &&\n\t    time_before(now,\n\t\t\tstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\n\t\tpr_debug(\"value = 0x%x, attack_level = 0x%x\\n\",\n\t\t\t value, envelope->attack_level);\n\t\ttime_from_level = jiffies_to_msecs(now - state->play_at);\n\t\ttime_of_envelope = envelope->attack_length;\n\t\tenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\n\n\t} else if (envelope->fade_length && effect->replay.length &&\n\t\t   time_after(now,\n\t\t\t      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\n\t\t   time_before(now, state->stop_at)) {\n\t\ttime_from_level = jiffies_to_msecs(state->stop_at - now);\n\t\ttime_of_envelope = envelope->fade_length;\n\t\tenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\n\t} else\n\t\treturn value;\n\n\tdifference = abs(value) - envelope_level;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\tpr_debug(\"time_from_level = 0x%x\\n\", time_from_level);\n\tpr_debug(\"time_of_envelope = 0x%x\\n\", time_of_envelope);\n\n\tdifference = difference * time_from_level / time_of_envelope;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\n\treturn value < 0 ?\n\t\t-(difference + envelope_level) : (difference + envelope_level);\n}",
    "comment": "Adjusts the input value based on an attack or fade envelope, modifying the output according to the elapsed time and specified envelope levels.",
    "prorec_sum": "Adjusts an input value toward a target limit based on buffer occupancy thresholds and scaling factors from provided parameters.",
    "filter_prorec_sum": "Calculates and returns a rate-adjusted value based on input signal parameters, enforcing limits and bounds from current buffer and timing constraints.",
    "prorec_aug_sum": "Adjusts a signed input value based on threshold checks and scaling calculations using fields from two data structures and given 16\u2011bit parameters.",
    "filter_prorec_aug_sum": "Adjusts an input value proportionally based on threshold checks and scaling parameters retrieved from the provided data structure and measurement function.",
    "work_score": {
        "prorec": {
            "summary": "Adjusts an input value toward a target limit based on buffer occupancy thresholds and scaling factors from provided parameters.",
            "score": [
                0.11446680274152154,
                0.1272156449518312,
                0.15935196248120082
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions adjusting an input value based on buffer occupancy thresholds and scaling factors, which are not present in the source code. The function deals with applying an envelope on an input value based on attack and fade logic, which is not accurately captured in the summary. Less than 50% of the claims reflect the actual source code behavior, leading to low precision.",
                "The summary does not cover the core primary purpose of the function, which is to apply an envelope effect to an input value based on attack and fade parameters. The summary incorrectly mentions buffer occupancy thresholds and scaling factors, which are not present in the source code. There is almost no secondary information provided that aligns with the source code's behavior.",
                "The summary is inaccurate as it does not describe the function's purpose or behavior correctly. The function adjusts an input value based on an envelope's attack and fade parameters, not buffer occupancy thresholds or scaling factors. This represents a severe FATAL error regarding the core domain action, leading to a score reflecting negative benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Calculates and returns a rate-adjusted value based on input signal parameters, enforcing limits and bounds from current buffer and timing constraints.",
            "score": [
                0.243083650880227,
                0.29914692616360405,
                0.3700979145728504
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions 'rate-adjusted value' and 'input signal parameters,' which are not present in the source code. The function calculates a modified value based on envelope levels and timing constraints, but does not enforce limits from a buffer or adjust rates. Less than 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which is to apply an envelope effect based on attack and fade parameters. The summary vaguely mentions rate-adjustment and timing constraints but lacks specificity about the envelope effect and its conditions. It fails to address key secondary behaviors such as handling attack and fade lengths, calculating differences, and returning adjusted values based on these calculations.",
                "The summary provides a generic description of the function's purpose but lacks specificity. It mentions rate-adjusted value and timing constraints, which are relevant but not detailed enough to capture the specific operations like attack and fade length handling or the calculation of difference based on envelope levels. The summary does not contradict the source code, but it fails to highlight key aspects such as the use of jiffies for timing or the conditional logic for envelope application, resulting in low net benefit due to lack of detailed insights."
            ]
        }
    }
}
{
    "source_code": "\nvoid write_xattr(char *pathname, unsigned int xattr)\n{\n\tunsigned int count;\n\tstruct xattr_list *xattr_list;\n\tint i;\n\tstatic int nonsuper_error = FALSE;\n\tstatic int ignore_xattrs = FALSE;\n\tstatic int nospace_error = 0;\n\n\tif(ignore_xattrs || xattr == SQUASHFS_INVALID_XATTR ||\n\t\t\tsBlk.s.xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn;\n\n\txattr_list = get_xattr(xattr, &count, 1);\n\tif(xattr_list == NULL) {\n\t\tERROR(\"Failed to read xattrs for file %s\\n\", pathname);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < count; i++) {\n\t\tint prefix = xattr_list[i].type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif(user_xattrs && prefix != SQUASHFS_XATTR_USER)\n\t\t\tcontinue;\n\n\t\tif(root_process || prefix == SQUASHFS_XATTR_USER) {\n\t\t\tint res = lsetxattr(pathname, xattr_list[i].full_name,\n\t\t\t\txattr_list[i].value, xattr_list[i].vsize, 0);\n\n\t\t\tif(res == -1) {\n\t\t\t\tif(errno == ENOTSUP) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the destination filesystem cannot\n\t\t\t\t\t * suppport xattrs, print error, and\n\t\t\t\t\t * disable xattr output as this error is\n\t\t\t\t\t * unlikely to go away, and printing\n\t\t\t\t\t * screenfulls of the same error message\n\t\t\t\t\t * is rather annoying\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"extended attributes are not \"\n\t\t\t\t\t\t\"supported by the destination \"\n\t\t\t\t\t\t\"filesystem\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tERROR(\"Ignoring xattrs in \"\n\t\t\t\t\t\t\t\t\"filesystem\\n\");\n\t\t\t\t\tERROR(\"To avoid this error message, \"\n\t\t\t\t\t\t\"specify -no-xattrs\\n\");\n\t\t\t\t\tignore_xattrs = TRUE;\n\t\t\t\t} else if((errno == ENOSPC || errno == EDQUOT)\n\t\t\t\t\t\t&& nospace_error < NOSPACE_MAX) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Many filesystems like ext2/3/4 have\n\t\t\t\t\t * limits on the amount of xattr\n\t\t\t\t\t * data that can be stored per file\n\t\t\t\t\t * (typically one block or 4K), so\n\t\t\t\t\t * we shouldn't disable xattr ouput,\n\t\t\t\t\t * as the error may be restriced to one\n\t\t\t\t\t * file only.  If we get a lot of these\n\t\t\t\t\t * then suppress the error messsage\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"no extended attribute space \"\n\t\t\t\t\t\t\"remaining (per file or \"\n\t\t\t\t\t\t\"filesystem limit)\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tif(++ nospace_error == NOSPACE_MAX)\n\t\t\t\t\t\tERROR(\"%d of these errors \"\n\t\t\t\t\t\t\t\"printed, further error \"\n\t\t\t\t\t\t\t\"messages of this type \"\n\t\t\t\t\t\t\t\"are suppressed!\\n\",\n\t\t\t\t\t\t\tNOSPACE_MAX);\n\t\t\t\t} else\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \"\n\t\t\t\t\t\t\"%s\\n\", xattr_list[i].full_name,\n\t\t\t\t\t\tpathname, strerror(errno));\n\t\t\t}\n\t\t} else if(nonsuper_error == FALSE) {\n\t\t\t/*\n\t\t\t * if extract user xattrs only then\n\t\t\t * error message is suppressed, if not\n\t\t\t * print error, and then suppress further error\n\t\t\t * messages to avoid possible screenfulls of the\n\t\t\t * same error message!\n\t\t\t */\n\t\t\tERROR(\"write_xattr: could not write xattr %s \"\n\t\t\t\t\t\"for file %s because you're not \"\n\t\t\t\t\t\"superuser!\\n\",\n\t\t\t\t\txattr_list[i].full_name, pathname);\n\t\t\tERROR(\"write_xattr: to avoid this error message, either\"\n\t\t\t\t\" specify -user-xattrs, -no-xattrs, or run as \"\n\t\t\t\t\"superuser!\\n\");\n\t\t\tERROR(\"Further error messages of this type are \"\n\t\t\t\t\"suppressed!\\n\");\n\t\t\tnonsuper_error = TRUE;\n\t\t}\n\t}\n\n\tfree_xattr(xattr_list, count);\n}",
    "comment": "Writes extended attributes to a specified file while handling errors for unsupported filesystems, space limitations, and non-superuser access.",
    "prorec_sum": "Sets multiple extended file attributes on the specified path from provided data and handles specific errno cases with retries or state flags.",
    "filter_prorec_sum": "Sets multiple extended file attributes on the given path from retrieved records, handling specific errno conditions and updating related global error state flags.",
    "prorec_aug_sum": "Sets extended file attributes on the given path from retrieved metadata, handling specific errno cases and updating related global error state flags.",
    "filter_prorec_aug_sum": "Sets extended file attributes from a descriptor onto the specified path, handling specific errno cases and maintaining related operation state flags.",
    "work_score": {
        "prorec": {
            "summary": "Sets multiple extended file attributes on the specified path from provided data and handles specific errno cases with retries or state flags.",
            "score": [
                0.42752238466276066,
                0.4709644029845196,
                0.4452813844135862
            ],
            "reason": [
                "The summary correctly identifies the function's purpose of setting extended file attributes on a specified path, which aligns with the source code. However, it inaccurately mentions handling errno cases with retries, which is not present in the code. The code handles errno cases by setting state flags and printing error messages, not by retrying operations. Thus, the summary is partially accurate, with mixed reliability.",
                "The summary covers the core purpose of setting extended file attributes on a specified path, which aligns with the primary function of the source code. However, it lacks detail on secondary behaviors such as handling specific error cases like ENOTSUP, ENOSPC, and EDQUOT, and the use of state flags like ignore_xattrs and nonsuper_error. The mention of retries is inaccurate as the code does not implement retry logic.",
                "The summary provides a generic overview of setting extended file attributes and handling errno cases, which aligns with the source code's functionality. However, it lacks specificity regarding the conditions under which attributes are set or errors are handled, such as the checks for user_xattrs, root_process, and specific errno values like ENOTSUP and ENOSPC. This results in low informational gain, and the summary does not capture the detailed logic and error suppression mechanisms present in the code."
            ]
        },
        "filter_prorec": {
            "summary": "Sets multiple extended file attributes on the given path from retrieved records, handling specific errno conditions and updating related global error state flags.",
            "score": [
                0.6579140607054772,
                0.6947935110942478,
                0.6689906680277071
            ],
            "reason": [
                "The summary accurately describes the function's purpose of setting extended file attributes on a given path and mentions handling specific errno conditions, which aligns with the source code's logic. However, it lacks detail on the conditions under which attributes are set or ignored, such as the checks for 'ignore_xattrs' and 'xattr' validity, and the specific error handling for 'ENOTSUP', 'ENOSPC', and 'EDQUOT'.",
                "The summary accurately covers the core purpose of the function, which is setting multiple extended file attributes on a given path. It also mentions handling specific errno conditions and updating global error state flags, which aligns with the error handling and flag updates in the source code. However, it lacks detail on the specific conditions under which attributes are set or skipped, such as user_xattrs and root_process checks.",
                "The summary accurately captures the core functionality of setting multiple extended file attributes and handling specific errno conditions, which aligns with the source code's logic. However, it lacks detail on the specific conditions and flags updated, such as 'ignore_xattrs' and 'nonsuper_error', which are crucial for understanding the function's behavior. The claims are mostly accurate but generic, providing moderate insight without significant detail."
            ]
        }
    }
}
{
    "source_code": "static void __synchronize_srcu(struct srcu_struct *sp, int trycount)\n{\n\tstruct rcu_synchronize rcu;\n\tstruct rcu_head *head = &rcu.head;\n\tbool done = false;\n\n\trcu_lockdep_assert(!lock_is_held(&sp->dep_map) &&\n\t\t\t   !lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"Illegal synchronize_srcu() in same-type SRCU (or RCU) read-side critical section\");\n\n\tmight_sleep();\n\tinit_completion(&rcu.completion);\n\n\thead->next = NULL;\n\thead->func = wakeme_after_rcu;\n\tspin_lock_irq(&sp->queue_lock);\n\tif (!sp->running) {\n\t\t/* steal the processing owner */\n\t\tsp->running = true;\n\t\trcu_batch_queue(&sp->batch_check0, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\n\t\tsrcu_advance_batches(sp, trycount);\n\t\tif (!rcu_batch_empty(&sp->batch_done)) {\n\t\t\tBUG_ON(sp->batch_done.head != head);\n\t\t\trcu_batch_dequeue(&sp->batch_done);\n\t\t\tdone = true;\n\t\t}\n\t\t/* give the processing owner to work_struct */\n\t\tsrcu_reschedule(sp);\n\t} else {\n\t\trcu_batch_queue(&sp->batch_queue, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\t}\n\n\tif (!done)\n\t\twait_for_completion(&rcu.completion);\n}",
    "comment": "Synchronizes SRCU processing by queuing a completion task and waiting for it to finish if not already done by the processing owner.",
    "prorec_sum": "Initializes lock-related state, updates linked list pointers, enables interrupts, and invokes further processing with provided parameters.",
    "filter_prorec_sum": "Initializes and links internal queue elements, enables interrupts, and dispatches processing of provided parameters within a locked synchronization context.",
    "prorec_aug_sum": "Initializes and links internal data structures, enables interrupts, and processes parameters before invoking a secondary handler for further execution.",
    "filter_prorec_aug_sum": "Initializes internal queue pointers, enables interrupts, and processes a hardware event with provided parameters before invoking the corresponding handler.",
    "work_score": {
        "prorec": {
            "summary": "Initializes lock-related state, updates linked list pointers, enables interrupts, and invokes further processing with provided parameters.",
            "score": [
                0.23602047436286594,
                0.2648734867777311,
                0.3833972120611103
            ],
            "reason": [
                "The summary contains several claims, but only one is accurate. The claim about initializing lock-related state is correct as the function uses 'rcu_lockdep_assert' and 'spin_lock_irq'. However, the claims about updating linked list pointers, enabling interrupts, and invoking further processing with provided parameters are inaccurate. The function does not enable interrupts nor does it process parameters directly, and the linked list pointer update is not a primary function behavior.",
                "The summary does not cover the core primary purpose of the function, which is to synchronize SRCU (Sleepable Read-Copy Update) state and manage batch processing. It mentions initializing lock-related state and linked list pointers, which are secondary aspects, but misses the main operation of SRCU synchronization and batch management. The summary lacks coverage of critical behaviors such as handling of completion, batch queuing, and rescheduling.",
                "The summary contains mostly NOISE claims that do not accurately describe the function's behavior. It mentions initializing lock-related state and updating linked list pointers, which are SAFE but generic and low-info claims. However, it inaccurately states enabling interrupts, which is not supported by the source code, indicating NOISE. The summary fails to capture specific actions like the assertion checks, batch processing, and completion handling, which are key aspects of the function's purpose. The worst failure mode is NOISE, as the summary lacks detailed and specific insights into the function's core operations."
            ]
        },
        "filter_prorec": {
            "summary": "Initializes and links internal queue elements, enables interrupts, and dispatches processing of provided parameters within a locked synchronization context.",
            "score": [
                0.2978849219599902,
                0.27194487575994175,
                0.38748444576193947
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions enabling interrupts, which is not present in the source code. The claim about initializing and linking internal queue elements is accurate, as the function does initialize and link elements like 'rcu.head'. However, the summary fails to accurately describe the synchronization context and processing dispatch, as the function primarily deals with SRCU synchronization and batch processing rather than generic parameter dispatching. Less than 50% of the claims are accurate.",
                "The summary does not cover the core primary purpose of the function, which is to synchronize SRCU by managing batches and handling completion. It mentions initializing and linking queue elements, enabling interrupts, and dispatching processing, which are secondary aspects but misses the core synchronization operation and handling of SRCU batches.",
                "The summary contains inaccuracies and noise. It mentions enabling interrupts, which is not present in the source code, and does not accurately describe the function's primary purpose of synchronizing SRCU structures. The summary fails to capture specific details such as the use of spin locks, the initialization of completion, and the queuing of batches, which are crucial for understanding the function's behavior. The inaccuracies and lack of specific insights result in a low net benefit."
            ]
        }
    }
}
{
    "source_code": "\nint kernel_ident_mapping_init(struct x86_mapping_info *info, pgd_t *pgd_page,\n\t\t\t      unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\tint result;\n\tint off = info->kernel_mapping ? pgd_index(__PAGE_OFFSET) : 0;\n\n\tfor (; addr < end; addr = next) {\n\t\tpgd_t *pgd = pgd_page + pgd_index(addr) + off;\n\t\tpud_t *pud;\n\n\t\tnext = (addr & PGDIR_MASK) + PGDIR_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (pgd_present(*pgd)) {\n\t\t\tpud = pud_offset(pgd, 0);\n\t\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpud = (pud_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pud)\n\t\t\treturn -ENOMEM;\n\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\t\tset_pgd(pgd, __pgd(__pa(pud) | _KERNPG_TABLE));\n\t}\n\n\treturn 0;\n}",
    "comment": "Initializes kernel identity mapping by setting up page entries in the page global directory for the specified address range, allocating pages as needed.",
    "prorec_sum": "Maps a virtual address range to physical pages in an IOMMU domain, allocating and setting page table entries as required.",
    "filter_prorec_sum": "Maps a virtual address range to physical memory in an IOMMU page table, allocating and linking page table entries when absent.",
    "prorec_aug_sum": "Traverses a virtual address range, allocating and linking page table entries as needed, and delegates processing of each mapped segment to a helper function.",
    "filter_prorec_aug_sum": "Traverses a range of virtual addresses, allocating and mapping missing page table entries, and recursively processing already present mappings.",
    "work_score": {
        "prorec": {
            "summary": "Maps a virtual address range to physical pages in an IOMMU domain, allocating and setting page table entries as required.",
            "score": [
                0.16418492257348874,
                0.2712236513877416,
                0.27168441457833425
            ],
            "reason": [
                "The summary inaccurately describes the function's purpose. The function 'kernel_ident_mapping_init' maps a virtual address range to physical pages, but it does not specifically mention IOMMU domains, which is a significant deviation from the source code's context. Additionally, the summary fails to accurately capture the function's behavior regarding page table entry allocation and setting, as it omits details about the conditional logic and specific operations performed within the function. Less than 50% of the claims are accurate.",
                "The summary inaccurately describes the function's purpose as mapping a virtual address range to physical pages in an IOMMU domain, which is not supported by the source code. The core purpose of the function is to initialize kernel identity mappings for a given address range, involving allocation and setting of page table entries. While the summary mentions allocation and setting of page table entries, it misses the specific context of kernel identity mapping and does not cover the core purpose accurately. Secondary details like handling of page directory entries and error conditions are not covered.",
                "The summary inaccurately claims the function maps a virtual address range to physical pages in an IOMMU domain, which contradicts the source code's purpose of initializing identity mappings for kernel address space. This is a severe FATAL error regarding the PRIMARY PURPOSE, making the summary misleading and untrustworthy."
            ]
        },
        "filter_prorec": {
            "summary": "Maps a virtual address range to physical memory in an IOMMU page table, allocating and linking page table entries when absent.",
            "score": [
                0.1977255496719501,
                0.3005729725015563,
                0.3664531665158931
            ],
            "reason": [
                "The summary inaccurately describes the function's purpose. The function 'kernel_ident_mapping_init' maps a virtual address range to physical memory, but it does so in the context of kernel page tables, not IOMMU page tables. The claim about allocating and linking page table entries is accurate, but the context is incorrect, leading to less than 50% accuracy.",
                "The summary inaccurately describes the function as mapping a virtual address range to physical memory in an IOMMU page table, which contradicts the source code's operation of initializing kernel identity mappings in a page table. While it mentions allocating and linking page table entries, it misses the core purpose of setting up identity mappings and handling specific conditions like pgd presence and memory allocation failures.",
                "The summary inaccurately describes the function's purpose as mapping a virtual address range to physical memory in an IOMMU page table, which is not supported by the source code. This constitutes a NOISE failure mode as it does not align with the actual function's operation of initializing kernel identity mappings. The summary does mention allocating and linking page table entries, which is accurate but generic and low-info, resulting in low gain. The noise is noticeable, and the gain is very low, leading to a low net benefit."
            ]
        }
    }
}
{
    "source_code": "\nstatic reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
    "comment": "Registers a new DFA state in the state table, allocating memory as needed and populating non-epsilon nodes.",
    "prorec_sum": "Allocates and initializes a data structure, validates its elements, and appends it into a dynamically resized list within a container object.",
    "filter_prorec_sum": "Allocates and initializes an entry structure, validates referenced elements, and appends it into a dynamically resized list within the primary data container.",
    "prorec_aug_sum": "Initializes a data structure, allocates memory for its elements, validates them, and inserts the structure into a dynamically managed list indexed by a mask.",
    "filter_prorec_aug_sum": "Allocates and initializes an entry structure, validates referenced elements, and appends it into a dynamically resized list within the given container.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes a data structure, validates its elements, and appends it into a dynamically resized list within a container object.",
            "score": [
                0.7438399694913896,
                0.5400157845236181,
                0.7020175929879123
            ],
            "reason": [
                "The summary accurately describes the function's behavior of allocating and initializing a data structure, validating its elements, and appending it into a dynamically resized list. These actions are reflected in the source code, where memory allocation and validation checks are performed before appending the new state to the state table. The summary captures the core operations without contradicting the source code semantics.",
                "The summary covers the core purpose of the function, which involves allocating and initializing a data structure and appending it to a list. However, it lacks specificity regarding the domain semantics, such as handling non-epsilon nodes and managing memory allocation errors. The secondary coverage is weak as it does not mention error handling or specific operations like resizing the array when needed.",
                "The summary accurately describes the function's behavior of allocating and initializing a data structure, validating its elements, and appending it to a dynamically resized list. These claims align with the source code's operations, such as memory allocation, element validation, and list insertion. The summary lacks specific details about error handling and the exact nature of the data structure, which limits the gain from the accurate claims."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes an entry structure, validates referenced elements, and appends it into a dynamically resized list within the primary data container.",
            "score": [
                0.5462206291753101,
                0.5082928009141903,
                0.5354387975050277
            ],
            "reason": [
                "The summary captures some aspects of the function's behavior, such as appending to a dynamically resized list and validating elements. However, it inaccurately describes the initialization of an entry structure, as the function primarily deals with state registration and error handling rather than structure allocation. Approximately 50-80% of the claims are accurate, indicating mixed reliability.",
                "The summary covers the core purpose of the function, which involves allocating and initializing a state and appending it to a list. However, it lacks detail on specific behaviors such as error handling (e.g., REG_ESPACE returns), the handling of epsilon nodes, and the dynamic resizing logic of the state table.",
                "The summary provides a generic overview of the function's operations, such as allocation, initialization, validation, and appending to a list. However, it lacks specificity regarding the function's behavior, such as handling errors with REG_ESPACE or the specific conditions under which elements are inserted. The claims are mostly SAFE but provide low insight, with no FATAL inaccuracies. The noise is noticeable due to the lack of detailed information."
            ]
        }
    }
}
