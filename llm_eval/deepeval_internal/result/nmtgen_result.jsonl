{
    "project_name": "sed",
    "function_addr": 4232128,
    "strip_function_name": "sub_4093C0",
    "strip_decompiled_code": "__int64 __fastcall sub_4093C0(__int64 a1, __int64 *a2, signed __int64 a3, signed __int64 a4, signed __int64 a5)\n{\n  __int64 v6; // r9\n  __int64 v7; // rbx\n  bool v8; // of\n  signed __int64 v9; // rbx\n  __int64 v10; // rsi\n  signed __int64 v11; // r9\n  __int64 result; // rax\n  __int64 v13; // rsi\n  __int64 v14; // rax\n\n  v6 = *a2;\n  v7 = *a2 >> 1;\n  v8 = __OFADD__(*a2, v7);\n  v9 = *a2 + v7;\n  if ( v8 )\n  {\n    v9 = 0x7FFFFFFFFFFFFFFFLL;\n    if ( a4 != -1 )\n      v9 = a4;\n  }\n  else if ( v9 > a4 && a4 != -1 )\n  {\n    v9 = a4;\n  }\n  v10 = a5 * v9;\n  if ( !is_mul_ok(a5, v9) )\n  {\n    v13 = 0x7FFFFFFFFFFFFFFFLL;\nLABEL_15:\n    v14 = v13 / a5;\n    v10 = v13 - v13 % a5;\n    v9 = v14;\n    if ( a1 )\n      goto LABEL_8;\nLABEL_16:\n    *a2 = 0LL;\n    goto LABEL_8;\n  }\n  if ( v10 <= 127 )\n  {\n    v13 = 128LL;\n    goto LABEL_15;\n  }\n  if ( !a1 )\n    goto LABEL_16;\nLABEL_8:\n  if ( v9 - v6 < a3 )\n  {\n    if ( (v8 = __OFADD__(a3, v6), v11 = a3 + v6, v9 = v11, v8)\n      || v11 > a4 && a4 != -1\n      || (v10 = a5 * v11, !is_mul_ok(a5, v11)) )\n    {\n      sub_411C90(a1, v10);\n    }\n  }\n  result = sub_411AA0(a1, v10);\n  *a2 = v9;\n  return result;\n}\n",
    "function_name": "xpalloc",
    "decompiled_code": "void *__fastcall xpalloc(void *pa, __int64 *a2, ptrdiff_t a3, ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  __int64 v6; // r9\n  __int64 v7; // rbx\n  bool v8; // of\n  ptrdiff_t v9; // rbx\n  signed __int64 v10; // r9\n  void *result; // rax\n  __int64 v12; // rsi\n\n  v6 = *a2;\n  v7 = *a2 >> 1;\n  v8 = __OFADD__(*a2, v7);\n  v9 = *a2 + v7;\n  if ( v8 )\n  {\n    v9 = 0x7FFFFFFFFFFFFFFFLL;\n    if ( nitems_max != -1 )\n      v9 = nitems_max;\n  }\n  else if ( v9 > nitems_max && nitems_max != -1 )\n  {\n    v9 = nitems_max;\n  }\n  if ( !is_mul_ok(item_size, v9) )\n  {\n    v12 = 0x7FFFFFFFFFFFFFFFLL;\nLABEL_15:\n    v9 = v12 / item_size;\n    if ( pa )\n      goto LABEL_8;\nLABEL_16:\n    *a2 = 0LL;\n    goto LABEL_8;\n  }\n  if ( item_size * v9 <= 127 )\n  {\n    v12 = 128LL;\n    goto LABEL_15;\n  }\n  if ( !pa )\n    goto LABEL_16;\nLABEL_8:\n  if ( v9 - v6 < a3 )\n  {\n    if ( (v8 = __OFADD__(a3, v6), v10 = a3 + v6, v9 = v10, v8)\n      || v10 > nitems_max && nitems_max != -1\n      || !is_mul_ok(item_size, v10) )\n    {\n      xalloc_die();\n    }\n  }\n  result = xrealloc(pa, v9);\n  *a2 = v9;\n  return result;\n}\n",
    "source_code": "\nstatic void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
    "comment": "Allocates or reallocates memory for an array based on its current size, growth constraints, and item size, ensuring safe memory usage.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Dynamically reallocates memory for an array , adjusting size based on current usage , minimum increments , and maximum limits while ensuring safety against overflow .\n",
    "cpbcs_sum": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
    "misum_sum": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
    "decom_sum": "Resizes a buffer size tracker to a safe larger value within limits, ensuring overflow-safe multiplication before invoking allocation and initialization routines.",
    "cfg_sum": "Calculates a new buffer size with overflow checks, caps it to limits, adjusts based on constraints, and reallocates memory accordingly.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains only a vague statement about pushing a pointer type, which does not accurately reflect the function's detailed memory reallocation logic, growth calculations, or constraints visible in the source code. It fails to extract or match any fact-based claims from the implementation, resulting in no accurate claims.",
                "The summary 'push a pointer type' is vague and does not capture the primary purpose of the function, which is to reallocate memory for a dynamically growing array with specific growth rules and constraints. It misses all critical semantic units such as handling small allocation sizes, growth calculation, overflow checks, and error handling. The claim does not align with any specific source code semantics and is essentially noise.",
                "The summary contains a single vague claim that does not align with the source code's actual functionality. The function resizes allocated memory for an array with constraints, not simply 'push a pointer type.' This is a NOISE failure, offering no accurate or useful insight into the code's semantics, resulting in low net benefit."
            ]
        },
        "bint5": {
            "summary": "Dynamically reallocates memory for an array , adjusting size based on current usage , minimum increments , and maximum limits while ensuring safety against overflow .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function reallocates memory for an array, taking into account current size, minimum increment, and maximum limits, and incorporates overflow safety. These elements align with the source code\u2019s logic, including checks for overflow and constraints before allocation. No significant inaccuracies are present, and all claims are specific and supported by the implementation.",
                "The summary correctly identifies the primary purpose of dynamically reallocating memory for an array and mentions constraints like minimum increments, maximum limits, and overflow safety, aligning with the source code's behavior. However, it omits secondary details such as the DEFAULT_MXFAST threshold for small allocations, specific 50% growth strategy, and the error handling via xalloc_die, resulting in incomplete coverage of key constants and behaviors.",
                "The summary is broadly accurate: it describes dynamic reallocation of memory for an array, incorporating minimum increments, maximum limits, and overflow safety, which matches the code's logic in xpalloc. However, it is very generic and omits specific implementation details such as DEFAULT_MXFAST growth logic, conditional growth to 50%, and wrap-around handling functions. There are no contradictory (FATAL) claims, but the gain is low due to lack of specifics, making the description safe but not a strong force multiplier."
            ]
        },
        "cpbcs": {
            "summary": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
            "score": [
                1.0,
                0.7,
                0.9
            ],
            "reason": [
                "The summary accurately captures the core functionality of the function: dynamic reallocation of array memory with adjustments based on current size, minimum increment, and maximum limits, and incorporates overflow safety checks. All these details align with the source code's semantics without contradiction, and there are no extraneous or incorrect claims.",
                "The summary correctly identifies the function\u2019s purpose as dynamic reallocation of an array and notes its handling of size adjustments and limits, aligning with the code\u2019s main logic of growing memory while avoiding overflow. However, it omits key secondary details such as the initial DEFAULT_MXFAST small-allocation policy, precise overflow and wraparound checks (INT_ADD_WRAPV, INT_MULTIPLY_WRAPV), and the error path invoking xalloc_die. These omissions prevent a higher completeness rating.",
                "The summary accurately captures the main purpose of xpalloc\u2014performing dynamic memory reallocation for an array, constrained by minimum increments, maximum limits, and overflow safety checks. It omits minor implementation specifics such as the default growth strategy for small allocations and the use of helper functions like INT_ADD_WRAPV, but these omissions reduce detail rather than introduce errors. The claims are all accurate (no FATAL or NOISE) and provide high-level yet technically correct insight, leading to strong overall alignment."
            ]
        },
        "misum": {
            "summary": "Dynamically reallocates memory for an array, adjusting size based on current usage, minimum increments, and maximum limits while ensuring safety against overflow.\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly identifies that the function reallocates memory for an array and adjusts the size based on current usage, minimum increments, and maximum limits, aligning with the code's logic. It also notes the safety against overflow, which matches the INT_ADD_WRAPV and INT_MULTIPLY_WRAPV checks. While slightly general and omitting specific growth strategy details, all stated claims are accurate and grounded in the source implementation.",
                "The summary correctly captures the primary purpose of the function: to reallocate memory for an array with size adjustments based on minimum increment, maximum limits, and overflow safety. However, it omits important secondary details from the source code, such as the specific growth strategy (DEFAULT_MXFAST constant for small allocations, ~50% growth otherwise), handling of NULL initial pointer, detailed overflow checks on addition and multiplication, and the exact error handling through xalloc_die. This results in partial coverage without full alignment on key implementation specifics.",
                "The summary correctly identifies that the function reallocates array memory and considers minimum increments, maximum limits, and overflow safety, which matches the source logic. It omits specifics like growth to DEFAULT_MXFAST for small arrays and the ~50% growth strategy, so the claims are accurate but broad and low-detail. No contradictory or irrelevant information is present, meaning there is no FATAL or NOISE, but the gain from the summary is low due to limited technical depth."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 210003,
    "strip_function_name": "mu_get_host_name",
    "strip_decompiled_code": "__int64 __fastcall mu_get_host_name(char **a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-34h]\n  char *ptr; // [rsp+20h] [rbp-30h]\n  size_t size; // [rsp+28h] [rbp-28h]\n  char *v5; // [rsp+30h] [rbp-20h]\n  char *v6; // [rsp+30h] [rbp-20h]\n  size_t v7; // [rsp+38h] [rbp-18h]\n  struct hostent *v8; // [rsp+40h] [rbp-10h]\n  size_t v9; // [rsp+48h] [rbp-8h]\n\n  ptr = 0LL;\n  size = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      if ( size )\n      {\n        v7 = 2 * size;\n        if ( 2 * size < size )\n          goto LABEL_20;\n        size *= 2LL;\n        v5 = (char *)realloc(ptr, v7);\n      }\n      else\n      {\n        size = 64LL;\n        v5 = (char *)malloc(0x40uLL);\n      }\n      if ( !v5 )\n        goto LABEL_20;\n      ptr = v5;\n      v5[size - 1] = 0;\n      if ( !gethostname(v5, size - 1) )\n        break;\n      if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )\n      {\n        v2 = *__errno_location();\n        free(v5);\n        return v2;\n      }\n    }\n  }\n  while ( v5[size - 1] );\n  if ( !strchr(v5, 46) )\n  {\n    v8 = gethostbyname(v5);\n    if ( v8 )\n    {\n      v9 = strlen(v8->h_name);\n      if ( size < v9 + 1 )\n      {\n        v6 = (char *)realloc(v5, v9 + 1);\n        if ( !v6 )\n        {\nLABEL_20:\n          free(ptr);\n          return 12LL;\n        }\n        ptr = v6;\n      }\n      strcpy(ptr, v8->h_name);\n    }\n  }\n  *a1 = ptr;\n  return 0LL;\n}\n",
    "function_name": "mu_get_host_name",
    "decompiled_code": "int __cdecl mu_get_host_name(char **host)\n{\n  int rc; // [rsp+1Ch] [rbp-34h]\n  char *hostname; // [rsp+20h] [rbp-30h]\n  size_t size; // [rsp+28h] [rbp-28h]\n  char *p; // [rsp+30h] [rbp-20h]\n  char *pa; // [rsp+30h] [rbp-20h]\n  __int64 ns; // [rsp+38h] [rbp-18h]\n  struct hostent *hp; // [rsp+40h] [rbp-10h]\n  size_t len; // [rsp+48h] [rbp-8h]\n\n  hostname = 0LL;\n  size = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      if ( size )\n      {\n        ns = 2 * size;\n        if ( 2 * size < size )\n          goto LABEL_20;\n        size *= 2LL;\n        p = (char *)realloc(hostname, ns);\n      }\n      else\n      {\n        size = 64LL;\n        p = (char *)malloc(0x40uLL);\n      }\n      if ( !p )\n        goto LABEL_20;\n      hostname = p;\n      p[size - 1] = 0;\n      if ( !gethostname(p, size - 1) )\n        break;\n      if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )\n      {\n        rc = *__errno_location();\n        free(p);\n        return rc;\n      }\n    }\n  }\n  while ( p[size - 1] );\n  if ( !strchr(p, 46) )\n  {\n    hp = gethostbyname(p);\n    if ( hp )\n    {\n      len = strlen(hp->h_name);\n      if ( size < len + 1 )\n      {\n        pa = (char *)realloc(p, len + 1);\n        if ( !pa )\n        {\nLABEL_20:\n          free(hostname);\n          return 12;\n        }\n        hostname = pa;\n      }\n      strcpy(hostname, hp->h_name);\n    }\n  }\n  *host = hostname;\n  return 0;\n}\n",
    "source_code": "\nint\nmu_get_host_name (char **host)\n{\n  char *hostname = NULL;\n  size_t size = 0;\n  char *p;\n\n  while (1)\n    {\n      if (size == 0)\n\t{\n\t  size = MAXHOSTNAMELEN;\n\t  p = malloc (size);\n\t}\n      else\n\t{\n\t  size_t ns = size * 2;\n\t  if (ns < size)\n\t    {\n\t      free (hostname);\n\t      return ENOMEM;\n\t    }\n\t  size = ns;\n\t  p = realloc (hostname, size);\n\t}\n      if (!p)\n\t{\n\t  free (hostname);\n\t  return ENOMEM;\n\t}\n      hostname = p;\n      hostname[size - 1] = 0;\n      if (gethostname (hostname, size - 1) == 0)\n\t{\n\t  if (!hostname[size - 1])\n\t    break;\n\t}\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n\t       && errno != ENOMEM)\n\t{\n\t  int rc = errno;\n\t  free (hostname);\n\t  return rc;\n\t}\n    }\n\n  /* Try to return fully qualified host name */\n  if (!strchr (hostname, '.'))\n    {\n      struct hostent *hp = gethostbyname (hostname);\n      if (hp)\n\t{\n\t  size_t len = strlen (hp->h_name);\n\t  if (size < len + 1)\n\t    {\n\t      p = realloc (hostname, len + 1);\n\t      if (!p)\n\t\t{\n\t\t  free (hostname);\n\t\t  return ENOMEM;\n\t\t}\n\t      hostname = p;\n\t    }\n\t  strcpy (hostname, hp->h_name);\n\t}\n    }\n  \n  *host = hostname;\n  return 0;\n}",
    "comment": "Retrieves the host name of the machine, expanding the buffer as needed, and attempts to return the fully qualified host name if not present.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the host name from a hostname structure , dynamically allocating memory as needed and handling potential errors during the process .\n",
    "cpbcs_sum": "Retrieves the current working directory, dynamically allocating memory for it, and ensures the buffer has been opened successfully.\n",
    "misum_sum": "Reads a string from a POSIX ACL file, allocates memory to store the buffer and returning an error code on failure.\n",
    "decom_sum": "Retrieves the system\u2019s hostname, expanding the buffer as needed, and resolves the fully qualified domain name if missing a dot.",
    "cfg_sum": "Retrieves the system\u2019s hostname, reallocating buffer as needed, resolves to fully qualified name if missing, and returns it or an error code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains only a vague phrase that does not accurately reflect the source code\u2019s semantics. It fails to mention key operations such as determining the host name, handling memory allocation and errors, or returning the result. No specific, fact-based claims from the summary can be tagged as accurate compared to the source code.",
                "The summary 'push a pointer type' is vague, does not identify the primary purpose of the function, and lacks any reference to the source code's observable behavior, such as retrieving and returning the host name with error handling. It fails to capture both the main functionality and any secondary details, making it irrelevant to the actual implementation.",
                "The summary \"push a pointer type.\" is vague, low-info, and does not accurately reflect the source code's purpose or implementation, which retrieves and returns the fully qualified host name via a pointer. This is pure NOISE, providing no useful, specific insight and missing all key I/O and side effects. The worst failure mode is overwhelming NOISE."
            ]
        },
        "bint5": {
            "summary": "Retrieves the host name from a hostname structure , dynamically allocating memory as needed and handling potential errors during the process .\n",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function retrieves the host name and allocates memory dynamically while handling errors, which aligns with the source implementation. However, it inaccurately specifies retrieving the host name from a 'hostname structure', whereas the code uses system calls like gethostname and optionally gethostbyname, not a predefined structure. This misrepresentation reduces accuracy, making the claim only partially correct.",
                "The summary captures the general idea of retrieving a host name and handling errors, aligning with the primary purpose in the source code. However, it inaccurately states that the name is obtained from a hostname structure, while the code uses system calls like gethostname and gethostbyname. It omits key secondary details such as iterative buffer resizing, specific errno checks, and returning a fully qualified domain name when missing. Thus, coverage of the primary purpose is partial, and important specifics are missed.",
                "The summary makes a vague claim about retrieving a host name and allocating memory, which loosely aligns with the code but inaccurately states that the hostname is obtained from a 'hostname structure'\u2014the actual source uses gethostname and possibly gethostbyname, not a preexisting structure. This is a FATAL error about the primary purpose of the code. The rest of the claim is generic and low-info, yielding little positive gain."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the current working directory, dynamically allocating memory for it, and ensures the buffer has been opened successfully.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves the current working directory and ensures the buffer has been opened successfully, but the source code shows it retrieves the host name using gethostname and optionally gethostbyname. None of the claims match the actual implementation, making them inaccurate.",
                "The summary is entirely inaccurate \u2014 it describes retrieving the current working directory and opening a buffer, which does not match the source code's actual primary purpose of retrieving the host name using dynamic memory allocation and handling errors. It misses all critical semantic units, including the iterative resizing loop, gethostname usage, handling of specific errno values, and optional resolution to a fully qualified host name.",
                "The summary incorrectly claims the function retrieves the current working directory, which contradicts the source code where the function actually retrieves the host name using gethostname and gethostbyname. This is a FATAL inaccuracy about the primary purpose and I/O behavior. There are no accurate or helpful claims to offset the error, resulting in a very low alignment score."
            ]
        },
        "misum": {
            "summary": "Reads a string from a POSIX ACL file, allocates memory to store the buffer and returning an error code on failure.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function reads a string from a POSIX ACL file, but the source code actually retrieves the hostname using gethostname and optionally gethostbyname. The summary also omits key details like repeated allocation/resizing and error handling for specific errno values, and instead introduces an unrelated context. None of the claims align with the actual logic in the source, making them inaccurate.",
                "The summary is entirely inaccurate: it describes reading from a POSIX ACL file, which is unrelated to the source code. The source code obtains the system's host name using gethostname, expands the buffer as needed, handles allocation errors, and optionally resolves a fully qualified name. The summary misses the primary purpose of getting the host name and does not mention any of the key secondary details such as buffer resizing, error handling, or use of gethostbyname.",
                "The summary is entirely inaccurate. The source code retrieves and potentially expands the system hostname using gethostname and gethostbyname, not reading from a POSIX ACL file. The claim targets the primary purpose and semantics incorrectly, misrepresenting both the I/O and the allocation logic, which constitutes a FATAL error impacting reliability."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579183232,
    "strip_function_name": "sub_FFFFFFFF81052880",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81052880(unsigned int *a1)\n{\n  unsigned __int64 v2; // rdi\n  __int64 v3; // r8\n  __int64 v4; // rcx\n  bool v5; // cf\n  unsigned __int64 v6; // rcx\n  unsigned int v7; // eax\n  unsigned __int64 v8; // rdx\n  unsigned int v9; // eax\n  char v10; // cl\n  _QWORD v12[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  memset(a1, 0, 0x70uLL);\n  sub_FFFFFFFF81083F50(v12);\n  sub_FFFFFFFF810843D0(v12);\n  *(_QWORD *)a1 = v12[0] + (v12[1] != 0LL);\n  sub_FFFFFFFF8106C890(a1 + 2, 0LL, 5LL);\n  *((_WORD *)a1 + 40) = dword_FFFFFFFF81DFB1E4;\n  sub_FFFFFFFF810EB320(a1);\n  sub_FFFFFFFF81121050(a1);\n  v2 = *((_QWORD *)a1 + 4);\n  v3 = *((_QWORD *)a1 + 8);\n  v4 = *((_QWORD *)a1 + 4);\n  v5 = __CFADD__(v3, v4);\n  v6 = v3 + v4;\n  if ( !v5 && v2 <= v6 )\n  {\n    v7 = a1[26];\n    if ( v7 <= 1 )\n    {\n      v10 = 0;\nLABEL_9:\n      *((_QWORD *)a1 + 5) <<= v10;\n      *((_QWORD *)a1 + 6) <<= v10;\n      a1[26] = 1;\n      *((_QWORD *)a1 + 4) = v2 << v10;\n      *((_QWORD *)a1 + 7) <<= v10;\n      *((_QWORD *)a1 + 9) <<= v10;\n      *((_QWORD *)a1 + 11) <<= v10;\n      *((_QWORD *)a1 + 12) <<= v10;\n      *((_QWORD *)a1 + 8) = v3 << v10;\n      return 0LL;\n    }\n    v8 = 2 * v6;\n    v9 = v7 >> 1;\n    if ( v6 <= 2 * v6 )\n    {\n      v10 = 1;\n      while ( v9 != 1 )\n      {\n        ++v10;\n        v9 >>= 1;\n        if ( 2 * v8 < v8 )\n          return 0LL;\n        v8 *= 2LL;\n      }\n      goto LABEL_9;\n    }\n  }\n  return 0LL;\n}\n",
    "function_name": "do_sysinfo",
    "decompiled_code": "__int64 __fastcall do_sysinfo(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  unsigned __int64 v7; // rdi\n  __int64 v8; // r8\n  __int64 v9; // rcx\n  bool v10; // cf\n  unsigned __int64 v11; // rcx\n  unsigned int v12; // eax\n  unsigned __int64 v13; // rdx\n  unsigned int v14; // eax\n  char v15; // cl\n  _QWORD v17[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  memset(a1, 0, 0x70uLL);\n  ktime_get_ts(v17, a2, a3, 0LL, a5, a6);\n  monotonic_to_bootbased(v17);\n  *(_QWORD *)a1 = v17[0] + (v17[1] != 0LL);\n  get_avenrun((_QWORD *)a1 + 1, 0LL, 5);\n  *((_WORD *)a1 + 40) = nr_threads;\n  si_meminfo((__int64)a1);\n  si_swapinfo((__int64)a1);\n  v7 = *((_QWORD *)a1 + 4);\n  v8 = *((_QWORD *)a1 + 8);\n  v9 = *((_QWORD *)a1 + 4);\n  v10 = __CFADD__(v8, v9);\n  v11 = v8 + v9;\n  if ( !v10 && v7 <= v11 )\n  {\n    v12 = a1[26];\n    if ( v12 <= 1 )\n    {\n      v15 = 0;\nLABEL_9:\n      *((_QWORD *)a1 + 5) <<= v15;\n      *((_QWORD *)a1 + 6) <<= v15;\n      a1[26] = 1;\n      *((_QWORD *)a1 + 4) = v7 << v15;\n      *((_QWORD *)a1 + 7) <<= v15;\n      *((_QWORD *)a1 + 9) <<= v15;\n      *((_QWORD *)a1 + 11) <<= v15;\n      *((_QWORD *)a1 + 12) <<= v15;\n      *((_QWORD *)a1 + 8) = v8 << v15;\n      return 0LL;\n    }\n    v13 = 2 * v11;\n    v14 = v12 >> 1;\n    if ( v11 <= 2 * v11 )\n    {\n      v15 = 1;\n      while ( v14 != 1 )\n      {\n        ++v15;\n        v14 >>= 1;\n        if ( 2 * v13 < v13 )\n          return 0LL;\n        v13 *= 2LL;\n      }\n      goto LABEL_9;\n    }\n  }\n  return 0LL;\n}\n",
    "source_code": "static int do_sysinfo(struct sysinfo *info)\n{\n\tunsigned long mem_total, sav_total;\n\tunsigned int mem_unit, bitcount;\n\tstruct timespec tp;\n\n\tmemset(info, 0, sizeof(struct sysinfo));\n\n\tktime_get_ts(&tp);\n\tmonotonic_to_bootbased(&tp);\n\tinfo->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);\n\n\tget_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);\n\n\tinfo->procs = nr_threads;\n\n\tsi_meminfo(info);\n\tsi_swapinfo(info);\n\n\t/*\n\t * If the sum of all the available memory (i.e. ram + swap)\n\t * is less than can be stored in a 32 bit unsigned long then\n\t * we can be binary compatible with 2.2.x kernels.  If not,\n\t * well, in that case 2.2.x was broken anyways...\n\t *\n\t *  -Erik Andersen <andersee@debian.org>\n\t */\n\n\tmem_total = info->totalram + info->totalswap;\n\tif (mem_total < info->totalram || mem_total < info->totalswap)\n\t\tgoto out;\n\tbitcount = 0;\n\tmem_unit = info->mem_unit;\n\twhile (mem_unit > 1) {\n\t\tbitcount++;\n\t\tmem_unit >>= 1;\n\t\tsav_total = mem_total;\n\t\tmem_total <<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If mem_total did not overflow, multiply all memory values by\n\t * info->mem_unit and set it to 1.  This leaves things compatible\n\t * with 2.2.x, and also retains compatibility with earlier 2.4.x\n\t * kernels...\n\t */\n\n\tinfo->mem_unit = 1;\n\tinfo->totalram <<= bitcount;\n\tinfo->freeram <<= bitcount;\n\tinfo->sharedram <<= bitcount;\n\tinfo->bufferram <<= bitcount;\n\tinfo->totalswap <<= bitcount;\n\tinfo->freeswap <<= bitcount;\n\tinfo->totalhigh <<= bitcount;\n\tinfo->freehigh <<= bitcount;\n\nout:\n\treturn 0;\n}",
    "comment": "Populates the `sysinfo` structure with system uptime, load averages, process count, and adjusted memory and swap information, ensuring compatibility with older kernels.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes a high-resolution timer by configuring it with minimum and maximum values , ensuring it does n't exceed predefined limits .\n",
    "cpbcs_sum": "Initiates a high-resolution timer by setting the start time and clock times, updating the timer's expiration and CPU affinity accordingly.\n",
    "misum_sum": "Sets the current time and adjusts the new PID based on the provided clock and header while validating the new CPU clock and size.\n",
    "decom_sum": "Initializes a 0x70-byte structure with timing values and scales multiple 64-bit fields based on a calculated shift derived from combined counters.",
    "cfg_sum": "Initializes a data structure, updates its fields via calculations and bit shifts based on size constraints, and finalizes configuration before returning a status.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a vague statement that does not correspond to any specific behavior in the source code. There are no verifiable fact-based claims related to the actual sysinfo implementation, so it provides no accurate information for evaluation purposes.",
                "The summary 'push a pointer type' is unrelated to the source code behavior. The function do_sysinfo initializes a sysinfo struct, fills system uptime, load averages, process count, memory and swap information, and normalizes memory values. The summary misses the primary purpose and all secondary details, making it completely inaccurate.",
                "The summary contains a single vague statement that does not correspond to the function\u2019s actual behavior of populating a sysinfo structure with uptime, process count, load averages, and memory info. It is pure NOISE, offering no accurate or relevant detail about the code\u2019s purpose, inputs, or outputs, leading to minimal utility and no factual insight."
            ]
        },
        "bint5": {
            "summary": "Initializes a high-resolution timer by configuring it with minimum and maximum values , ensuring it does n't exceed predefined limits .\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary refers to initializing a high-resolution timer with specific limits, which is unrelated to the source code. The source code handles system information retrieval, uptime calculation, memory and swap info adjustments, but does not configure timers. All claims in the summary are inaccurate, resulting in no alignment with the source code.",
                "The summary describes behavior related to initializing a high-resolution timer with limits, which is unrelated to the actual code. The source function collects system information such as uptime, load averages, process count, and memory statistics, and adjusts memory units for compatibility. The primary purpose is entirely missed and no accurate claims match any critical semantic units from the source.",
                "The summary claims the function initializes a high-resolution timer with min/max limits, which is entirely unrelated to the source code. The source code gathers system information such as uptime, load averages, process count, and memory statistics, and adjusts memory units for compatibility. This mismatch is a FATAL error regarding the primary purpose, leading to high negative impact with no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Initiates a high-resolution timer by setting the start time and clock times, updating the timer's expiration and CPU affinity accordingly.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes initiating a high-resolution timer with expiration and CPU affinity updates, which is unrelated to the actual source code. The source implements a sysinfo function that gathers system uptime, load averages, process count, and memory statistics; no timer initiation or CPU affinity logic exists. All claims are inaccurate due to complete mismatch with code semantics.",
                "The summary describes initiating a high-resolution timer with expiration and CPU affinity changes, which is entirely unrelated to the source code. The function in the source code gathers and formats system information such as uptime, load averages, process count, and memory statistics, with specific overflow handling. The primary purpose is missed, and none of the claims in the summary are accurate or map to the critical semantic units from the code.",
                "The summary contains a single claim that the function initiates a high-resolution timer, sets start/clock times, and updates timer expiration and CPU affinity. This is entirely inaccurate, as the source code instead gathers system information such as uptime, load averages, process counts, and memory statistics. There are no operations relating to timer expiration or CPU affinity. This is a FATAL error targeting the primary purpose and key side effects, making the response unreliable."
            ]
        },
        "misum": {
            "summary": "Sets the current time and adjusts the new PID based on the provided clock and header while validating the new CPU clock and size.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims do not match the source code. The code retrieves system uptime, load averages, process count, and memory info, but does not set a new PID, adjust it based on a clock or header, or validate CPU clock and size. All claims are inaccurate regarding the actual implementation, resulting in no accurate matches.",
                "The summary is completely inaccurate as it describes setting a PID and validating a CPU clock, which are not present in the source code. The code actually gathers system information including uptime, load averages, process count, and memory statistics, with logic for memory unit scaling. The primary purpose and all secondary details are missed, resulting in no coverage of actual critical semantic units.",
                "The summary claims the function sets time and adjusts a PID based on clock and CPU validations, which contradicts the actual code. The source function collects system information (uptime, load, memory, swap), not PID or CPU clock validation. This constitutes a FATAL error about core purpose. No accurate statements exist to offset this inaccuracy, resulting in low reliability and minimal informational value."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582460464,
    "strip_function_name": "sub_FFFFFFFF81372A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81372A30(__int64 a1, _DWORD *a2)\n{\n  __int64 v2; // r12\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // rax\n  int i; // ecx\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // rdx\n  int v11; // esi\n  int v12; // eax\n\n  v2 = *(_QWORD *)(a1 + 400);\n  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 888) + 416LL) & 0x20) == 0 )\n    return 4294967274LL;\n  if ( !v2 )\n    return 4294967274LL;\n  sub_FFFFFFFF81379AC0(1, (unsigned int)\"drm\", (unsigned int)\"drm_markbufs\", (unsigned int)\"%d, %d, %d\\n\", a2[1], a2[2]);\n  v4 = (int)a2[1];\n  v5 = v4 >> 1;\n  if ( !(v4 >> 1) )\n    return 4294967274LL;\n  for ( i = 0; ; ++i )\n  {\n    v5 >>= 1;\n    v7 = i + 1;\n    if ( !v5 )\n      break;\n  }\n  if ( (v4 & (v4 - 1)) != 0 )\n  {\n    v7 = i + 2;\n    v8 = i - 3;\n  }\n  else\n  {\n    v8 = i - 4;\n  }\n  if ( v8 > 0x11 )\n    return 4294967274LL;\n  v9 = a2[2];\n  if ( v9 < 0 )\n    return 4294967274LL;\n  v10 = (_DWORD *)(v2 + 88LL * v7);\n  v11 = v10[1];\n  if ( v9 > v11 )\n    return 4294967274LL;\n  v12 = a2[3];\n  if ( v11 < v12 || v12 < 0 )\n    return 4294967274LL;\n  v10[18] = v9;\n  v10[19] = a2[3];\n  return 0LL;\n}\n",
    "function_name": "drm_markbufs",
    "decompiled_code": "__int64 __fastcall drm_markbufs(__int64 a1, _DWORD *a2)\n{\n  __int64 v2; // r12\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // rax\n  int i; // ecx\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // rdx\n  int v11; // esi\n  int v12; // eax\n\n  v2 = *(_QWORD *)(a1 + 400);\n  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 888) + 416LL) & 0x20) == 0 )\n    return 4294967274LL;\n  if ( !v2 )\n    return 4294967274LL;\n  drm_ut_debug_printk(\n    1,\n    (int)\"drm\",\n    (__int64)\"drm_markbufs\",\n    (__int64)\"%d, %d, %d\\n\",\n    (unsigned int)a2[1],\n    (unsigned int)a2[2],\n    a2[3]);\n  v4 = (int)a2[1];\n  v5 = v4 >> 1;\n  if ( !(v4 >> 1) )\n    return 4294967274LL;\n  for ( i = 0; ; ++i )\n  {\n    v5 >>= 1;\n    v7 = i + 1;\n    if ( !v5 )\n      break;\n  }\n  if ( (v4 & (v4 - 1)) != 0 )\n  {\n    v7 = i + 2;\n    v8 = i - 3;\n  }\n  else\n  {\n    v8 = i - 4;\n  }\n  if ( v8 > 0x11 )\n    return 4294967274LL;\n  v9 = a2[2];\n  if ( v9 < 0 )\n    return 4294967274LL;\n  v10 = (_DWORD *)(v2 + 88LL * v7);\n  v11 = v10[1];\n  if ( v9 > v11 )\n    return 4294967274LL;\n  v12 = a2[3];\n  if ( v11 < v12 || v12 < 0 )\n    return 4294967274LL;\n  v10[18] = v9;\n  v10[19] = a2[3];\n  return 0LL;\n}\n",
    "source_code": "int drm_markbufs(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tstruct drm_buf_desc *request = data;\n\tint order;\n\tstruct drm_buf_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\treturn -EINVAL;\n\n\tif (!dma)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"%d, %d, %d\\n\",\n\t\t  request->size, request->low_mark, request->high_mark);\n\torder = drm_order(request->size);\n\tif (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)\n\t\treturn -EINVAL;\n\tentry = &dma->bufs[order];\n\n\tif (request->low_mark < 0 || request->low_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\tif (request->high_mark < 0 || request->high_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\n\tentry->freelist.low_mark = request->low_mark;\n\tentry->freelist.high_mark = request->high_mark;\n\n\treturn 0;\n}",
    "comment": "Configures buffer management parameters, including size and free list thresholds, for a Direct Rendering Manager (DRM) device's DMA buffers.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Marks the buffer usage for a DRM device by writing minimum and maximum values to its control register .\n",
    "cpbcs_sum": "Retrieves the vblank state of a specified CRTC in a formatted buffer, ensuring the device fits within valid bounds.\n",
    "misum_sum": "Converts a DRM connector to a formatted string representation, returning an error if the device does not already enabled.\n",
    "decom_sum": "Validates DRM buffer parameters and updates buffer metadata with provided indices after performing alignment and bounds checks.",
    "cfg_sum": "Validates DRM buffer parameters against hardware constraints, and updates buffer indices only when required flags are set and all checks pass.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior related to measuring columns of multibyte character strings and rejecting unprintable characters, which is entirely unrelated to the source code. The source implements drm_markbufs, handling DMA buffer marking, low/high watermark checks, and returning error codes for invalid input. None of the claims in the summary match or are supported by the source code, making all claims inaccurate.",
                "The summary describes behavior related to multibyte character strings and handling of non-printable characters, which is entirely unrelated to the source code. The source code's primary purpose is to validate parameters and set low/high watermark values for DRM buffers, with specific DMA and bounds checks. The summary misses the primary purpose and all critical semantic units, making all claims inaccurate.",
                "The summary describes behavior related to measuring display columns for multibyte character strings and rejecting unprintable characters, which is entirely unrelated to the source code that manages DRM device DMA buffer marks. This is a complete semantic mismatch, making the claim [INACCURATE] with FATAL impact on understanding the primary purpose. There are no accurate claims, resulting in no benefit and severe misinformation."
            ]
        },
        "bint5": {
            "summary": "Marks the buffer usage for a DRM device by writing minimum and maximum values to its control register .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function writes minimum and maximum values to a control register, but the source code sets low_mark and high_mark fields in the freelist of a specific buffer entry, not a hardware register. While the idea of marking buffer usage is somewhat aligned, the reference to a control register is inaccurate, making the majority of the single atomic claim incorrect.",
                "The summary incorrectly describes writing to a control register, which is not present in the source code. The function\u2019s primary purpose is to set the low and high watermarks for a specific buffer order in the DRM device\u2019s DMA buffers after validating input values. The summary misses the validation steps, the use of freelist structure, and the absence of any control register interaction, thus failing to capture the actual implementation\u2019s semantics.",
                "The summary claims the function writes minimum and maximum values to a control register, which is inaccurate because the source code updates the freelist's low_mark and high_mark within a buffer entry, not any hardware register. This is a FATAL error as it misstates the primary purpose and side effect of the function by incorrectly describing where values are written."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the vblank state of a specified CRTC in a formatted buffer, ensuring the device fits within valid bounds.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes retrieving the vblank state of a CRTC, which is unrelated to the source code. The function in the source code marks buffer low and high water marks for DMA buffers, with multiple bounds checks and returns an error if invalid. None of the summary's claims match the implementation, resulting in all claims being inaccurate.",
                "The summary claims the function retrieves the vblank state of a CRTC and formats it into a buffer, which is completely unrelated to the source code's purpose. The actual function marks buffer low/high watermarks for a DRM device's DMA buffers with extensive input validation. The summary fails to capture the primary purpose and all secondary behaviors, making all claims inaccurate.",
                "The summary claims the function retrieves vblank state for a CRTC, which is entirely unrelated to the actual code. The source implements buffer marking for DMA operations, validating size/order and setting low/high watermarks. This is a semantic mismatch on the primary purpose, constituting a FATAL error that misrepresents key I/O and side effects. No accurate claims are present, resulting in high negative impact and zero useful gain."
            ]
        },
        "misum": {
            "summary": "Converts a DRM connector to a formatted string representation, returning an error if the device does not already enabled.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function converts a DRM connector to a formatted string and checks device enablement, but the actual source implements buffer mark processing for DMA buffers. None of the described behaviors\u2014string formatting, connector handling, or enablement checks\u2014exist in the code, so all claims are inaccurate and unrelated to the implementation.",
                "The summary describes converting a DRM connector to a formatted string and mentions device enablement, which is entirely unrelated to the source code's purpose of setting buffer freelist low/high marks based on a request, with multiple validity checks. It misses the primary purpose and all secondary details, and the claim is inaccurate in targeting source semantics.",
                "The summary claims the function converts a DRM connector to a formatted string and returns an error if the device is not already enabled. This is a FATAL inaccuracy because the source code does not deal with DRM connectors or string formatting at all; it processes a DRM buffer descriptor, validates size/order/marks, and updates freelist thresholds. The primary purpose is entirely misrepresented, leading to zero alignment with the source."
            ]
        }
    }
}
{
    "project_name": "lua",
    "function_addr": 39904,
    "strip_function_name": "sub_9BE0",
    "strip_decompiled_code": "const char *__fastcall sub_9BE0(__int64 a1, __int64 *a2, int a3, _QWORD *a4)\n{\n  __int64 v6; // rdx\n  __int64 v7; // r12\n  __int64 v8; // rdi\n  int v9; // ebp\n  const char *result; // rax\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // [rsp+8h] [rbp-30h]\n\n  v6 = *a2;\n  if ( (*((_BYTE *)a2 + 66) & 2) != 0 )\n  {\n    v7 = a2[4];\n    v8 = *(_QWORD *)(*(_QWORD *)v6 + 24LL);\n    if ( a3 < 0 )\n    {\n      v9 = -a3;\n      if ( v9 < (int)(((v7 - v6) >> 4) - *(unsigned __int8 *)(v8 + 10)) )\n      {\n        *a4 = v6 + 16 * (v9 + (unsigned __int64)*(unsigned __int8 *)(v8 + 10));\n        return \"(*vararg)\";\n      }\n      return 0LL;\n    }\n    v13 = a4;\n    result = (const char *)sub_CF30(v8, (unsigned int)a3, (unsigned int)((a2[5] - *(_QWORD *)(v8 + 56)) >> 2) - 1);\n    v12 = a3;\n    a4 = v13;\n    if ( result )\n    {\nLABEL_11:\n      *a4 = v7 + 16 * v12 - 16;\n      return result;\n    }\n  }\n  else\n  {\n    v7 = v6 + 16;\n  }\n  if ( *(__int64 **)(a1 + 32) == a2 )\n    v11 = *(_QWORD *)(a1 + 16);\n  else\n    v11 = *(_QWORD *)a2[3];\n  v12 = a3;\n  if ( (v11 - v7) >> 4 >= a3 && a3 > 0 )\n  {\n    result = \"(*temporary)\";\n    goto LABEL_11;\n  }\n  return 0LL;\n}\n",
    "function_name": "findlocal",
    "decompiled_code": "const char *__fastcall findlocal(__int64 a1, __int64 *a2, int a3, _QWORD *a4)\n{\n  __int64 v6; // rdx\n  __int64 v7; // r12\n  __int64 v8; // rdi\n  int v9; // ebp\n  const char *result; // rax\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // [rsp+8h] [rbp-30h]\n\n  v6 = *a2;\n  if ( (*((_BYTE *)a2 + 66) & 2) != 0 )\n  {\n    v7 = a2[4];\n    v8 = *(_QWORD *)(*(_QWORD *)v6 + 24LL);\n    if ( a3 < 0 )\n    {\n      v9 = -a3;\n      if ( v9 < (int)(((v7 - v6) >> 4) - *(unsigned __int8 *)(v8 + 10)) )\n      {\n        *a4 = v6 + 16 * (v9 + (unsigned __int64)*(unsigned __int8 *)(v8 + 10));\n        return \"(*vararg)\";\n      }\n      return 0LL;\n    }\n    v13 = a4;\n    result = (const char *)luaF_getlocalname(v8, a3, (unsigned int)((a2[5] - *(_QWORD *)(v8 + 56)) >> 2) - 1);\n    v12 = a3;\n    a4 = v13;\n    if ( result )\n    {\nLABEL_11:\n      *a4 = v7 + 16 * v12 - 16;\n      return result;\n    }\n  }\n  else\n  {\n    v7 = v6 + 16;\n  }\n  if ( *(__int64 **)(a1 + 32) == a2 )\n    v11 = *(_QWORD *)(a1 + 16);\n  else\n    v11 = *(_QWORD *)a2[3];\n  v12 = a3;\n  if ( (v11 - v7) >> 4 >= a3 && a3 > 0 )\n  {\n    result = \"(*temporary)\";\n    goto LABEL_11;\n  }\n  return 0LL;\n}\n",
    "source_code": "\nstatic const char* findlocal(lua_State* L, CallInfo* ci, int n, StkId* pos) {\n  const char* name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0) /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  } else\n    base = ci->func + 1;\n  if (name == NULL) { /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\"; /* generic name for any valid slot */\n    else\n      return NULL; /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}",
    "comment": "Retrieves the local variable name from a Lua function's call frame or returns a generic name for temporary slots if no name exists.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Retrieves a specified column value from a table , handling both integer and non-integer inputs , ensuring valid column indices .\n",
    "cpbcs_sum": "Retrieves the value of an upvalue from a Lua stack based on its type, handling both direct and negative values accordingly.\n",
    "misum_sum": "Converts a binary tree to an additional token based on the integer value and current stack pointers, handling memory allocation errors appropriately.\n",
    "decom_sum": "Retrieves a function argument\u2019s address from a call frame and returns its descriptor string for varargs or temporary arguments based on index and bounds.",
    "cfg_sum": "Retrieves a function argument or temporary value by index, validates bounds, and returns its address with an identifying string if conditions are met.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer with printf-style formatting, num_bytes controlling output length, and hex conversion are entirely unrelated to the source code, which deals with locating local variable names in a Lua stack frame. None of the claims match the code's semantics, resulting in 0% accuracy.",
                "The summary describes behavior unrelated to the source code. It references conversion to a string based on printf formatting, a static buffer, and byte limits, none of which appear in the function. The source code instead deals with retrieving the name of a local variable or vararg in a Lua stack frame, handling cases with no name and setting a position pointer. The summary misses the primary purpose entirely and contains only inaccurate claims.",
                "All claims in the summary are unrelated to the source code's actual functionality. The source code finds a local variable name and its position in the stack for a given function call, with special handling for varargs and temporary slots, but the summary talks about converting values, printf formatting characters, and byte limits, which are completely disconnected from the implementation. This represents overwhelming NOISE, giving no accurate or relevant insights."
            ]
        },
        "bint5": {
            "summary": "Retrieves a specified column value from a table , handling both integer and non-integer inputs , ensuring valid column indices .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes retrieving a column value from a table with handling for integer and non-integer inputs and column index validation, which does not match the source code's actual logic of locating a local variable in Lua stack frames, handling vararg access, and providing fallback names for valid slots. None of the claims align with the code semantics, indicating a complete mismatch.",
                "The summary is inaccurate because it describes retrieving a column value from a table with integer/non-integer input handling, which is unrelated to the source code's purpose. The function in the source code finds the name and stack position of a local variable in a Lua call frame, handling varargs, unnamed slots, and stack bounds. None of the actual semantics, primary purpose, or secondary details from the code are mentioned, so no claims are accurate and no coverage of CSU_LIST exists.",
                "The summary claims the function retrieves a specified column value from a table, handling both integer and non-integer inputs and ensuring valid column indices. This is inaccurate because the actual source code deals with finding local variable names in a Lua stack frame and handling varargs, not table column values or non-integer input types. The mismatch targets the primary purpose of the function, making it a FATAL error and providing no accurate insights."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the value of an upvalue from a Lua stack based on its type, handling both direct and negative values accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves the value of an upvalue based on type and handles direct and negative values, but the source code shows it retrieves the name of a local variable (or vararg) from the Lua stack, not an upvalue, and determines its name rather than its value. This is a semantic mismatch, making the core claims inaccurate and leaving no accurate elements in the summary.",
                "The summary misidentifies the function\u2019s purpose, describing retrieval of an upvalue\u2019s value instead of locating a local variable\u2019s name and position within a Lua call frame. It confuses types and semantics entirely, missing the handling of varargs, name resolution with luaF_getlocalname, and the fallback to temporary names. Only vaguely touches on handling negative indices, offering negligible alignment with the source code\u2019s actual logic.",
                "The summary inaccurately claims the function retrieves an upvalue, whereas the source code shows it retrieves the name of a local variable from a Lua stack, including handling varargs and temporary slots. This is a FATAL error because it misstates the primary purpose of the function. There is no accurate claim to offset the incorrect one, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Converts a binary tree to an additional token based on the integer value and current stack pointers, handling memory allocation errors appropriately.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes converting a binary tree and handling memory allocation errors, which is unrelated to the source code. The source implements a function to find local variable names in Lua stack frames, with special handling for varargs and temporary slots. None of the claims match the code\u2019s semantics, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate as it describes converting a binary tree, token generation, and memory allocation error handling, none of which relate to the source code. The source function finds the name of a local variable or vararg in a Lua call frame based on an index and updates a stack position pointer. The summary fails to capture the primary purpose or any secondary details of the implementation.",
                "The summary asserts behavior about binary tree conversion, token generation, integer processing, and memory allocation handling, none of which are present in the source. The actual code inspects Lua stack frames and retrieves local variable names, with no tree structure or allocation logic. These contradictions represent a FATAL misinterpretation of the primary function\u2019s purpose and I/O behavior, leading to a very low reliability assessment."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 441281,
    "strip_function_name": "mu_ident_stat",
    "strip_decompiled_code": "unsigned __int64 __fastcall mu_ident_stat(int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  int v9; // edx\n  int v10; // ecx\n  int v11; // r8d\n  int v12; // r9d\n  int v13; // eax\n  int v14; // ecx\n  int v15; // r8d\n  int v16; // r9d\n  int v17; // r9d\n  char v19; // [rsp+0h] [rbp-50h]\n  char v20; // [rsp+0h] [rbp-50h]\n  char v21; // [rsp+0h] [rbp-50h]\n  unsigned int iterator; // [rsp+1Ch] [rbp-34h]\n  __int64 v23; // [rsp+20h] [rbp-30h] BYREF\n  __int64 v24; // [rsp+28h] [rbp-28h] BYREF\n  __int64 v25; // [rsp+30h] [rbp-20h] BYREF\n  _QWORD *v26; // [rsp+38h] [rbp-18h] BYREF\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v28; // [rsp+48h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  mu_stream_printf(a1, (int)\"BEGIN IDENT STAT\\n\", a3, a4, a5, a6, v19);\n  mu_assoc_count(qword_2DFC80, &v23);\n  mu_stream_printf(a1, (int)\"N=%zu\\n\", v23, v6, v7, v8, v20);\n  if ( v23 )\n  {\n    iterator = mu_assoc_get_iterator(qword_2DFC80, &v24);\n    if ( iterator )\n    {\n      v13 = mu_strerror(iterator);\n      mu_stream_printf(a1, (int)\"mu_assoc_get_iterator: %s\\n\", v13, v14, v15, v16, v21);\n    }\n    else\n    {\n      v27 = 0LL;\n      mu_iterator_first(v24);\n      while ( !(unsigned int)mu_iterator_is_done(v24) )\n      {\n        mu_iterator_current_kv(v24, &v25, &v26);\n        mu_stream_printf(a1, (int)\"%04zu: %s: %zu\\n\", v27, v25, *v26, v17, v21);\n        mu_iterator_next(v24);\n        ++v27;\n      }\n    }\n    mu_iterator_destroy(&v24);\n  }\n  mu_stream_printf(a1, (int)\"END IDENT STAT\\n\", v9, v10, v11, v12, v21);\n  return __readfsqword(0x28u) ^ v28;\n}\n",
    "function_name": "mu_ident_stat",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nvoid __cdecl mu_ident_stat(mu_stream_t str)\n{\n  const char *v1; // rax\n  unsigned int rc; // [rsp+1Ch] [rbp-34h]\n  size_t count; // [rsp+20h] [rbp-30h] BYREF\n  mu_iterator_t itr; // [rsp+28h] [rbp-28h] BYREF\n  const char *key; // [rsp+30h] [rbp-20h] BYREF\n  mu_ident_ref *ref; // [rsp+38h] [rbp-18h] BYREF\n  size_t i; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  ((void (__fastcall *)(mu_stream_t, const char *))mu_stream_printf)(str, \"BEGIN IDENT STAT\\n\");\n  ((void (__fastcall *)(mu_assoc_t, size_t *))mu_assoc_count)(nametab, &count);\n  ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"N=%zu\\n\", count);\n  if ( count )\n  {\n    rc = ((__int64 (__fastcall *)(mu_assoc_t, mu_iterator_t *))mu_assoc_get_iterator)(nametab, &itr);\n    if ( rc )\n    {\n      v1 = (const char *)((__int64 (__fastcall *)(_QWORD))mu_strerror)(rc);\n      ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"mu_assoc_get_iterator: %s\\n\", v1);\n    }\n    else\n    {\n      i = 0LL;\n      ((void (__fastcall *)(mu_iterator_t))mu_iterator_first)(itr);\n      while ( !(unsigned int)((__int64 (__fastcall *)(mu_iterator_t))mu_iterator_is_done)(itr) )\n      {\n        ((void (__fastcall *)(mu_iterator_t, const char **, mu_ident_ref **))mu_iterator_current_kv)(itr, &key, &ref);\n        ((void (*)(mu_stream_t, const char *, ...))mu_stream_printf)(str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n        ((void (__fastcall *)(mu_iterator_t))mu_iterator_next)(itr);\n        ++i;\n      }\n    }\n    ((void (__fastcall *)(mu_iterator_t *))mu_iterator_destroy)(&itr);\n  }\n  ((void (__fastcall *)(mu_stream_t, const char *))mu_stream_printf)(str, \"END IDENT STAT\\n\");\n}\n",
    "source_code": "  \nvoid\nmu_ident_stat (mu_stream_t str)\n{\n  size_t count, i;\n  mu_iterator_t itr;\n  \n  mu_stream_printf (str, \"BEGIN IDENT STAT\\n\");\n\n  mu_assoc_count (nametab, &count);\n  mu_stream_printf (str, \"N=%zu\\n\", count);\n\n  if (count > 0)\n    {\n      int rc = mu_assoc_get_iterator (nametab, &itr);\n      if (rc)\n\tmu_stream_printf (str, \"mu_assoc_get_iterator: %s\\n\",\n\t\t\t  mu_strerror (rc));\n      else\n\t{\n\t  i = 0;\n\t  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);\n\t       mu_iterator_next (itr), i++)\n\t    {\n\t      const char *key;\n\t      struct mu_ident_ref *ref;\n\t      \n\t      mu_iterator_current_kv (itr,\n\t\t\t\t      (const void **)&key, (void **)&ref);  \n\t      mu_stream_printf (str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n\t    }\n\t}\n      mu_iterator_destroy (&itr);\n    }\n  mu_stream_printf (str, \"END IDENT STAT\\n\");\n}",
    "comment": "Outputs the count and details of identifiers from a name table to a specified stream, including key-value pairs and their associated counts.",
    "hext5_sum": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
    "bint5_sum": "Identifies and prints file status information , including permissions , ownership , size , and modification time , from a specified directory stream .\n",
    "cpbcs_sum": "Saves a transport stream to a specified mailbox with the provided name and optional identifier, handling stream creation and errors.\n",
    "misum_sum": "Prints the details of a sieve machine with optional tag by iterating through a filter stream, iterating when the operation fails.\n",
    "decom_sum": "Outputs statistics of all key-value pairs in the global association, including count and each entry, to the specified stream.",
    "cfg_sum": "Outputs formatted statistics of an associative collection, iterating through key-value pairs, handling iterator errors, and ensuring proper resource cleanup and stack integrity.",
    "work_score": {
        "hext5": {
            "summary": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes computing a covariance matrix using a QRP^T decomposition, which is unrelated to the source code. The source code outputs identification statistics from an association table, iterating over keys and counts, with no mathematical decomposition or matrix operations. All claims are inaccurate because they do not reflect any functionality of the provided code.",
                "The summary describes computing a covariance matrix using a QR decomposition, which has no relation to the source code's behavior. The source code outputs identifier statistics from a name table to a stream, including counts and iteration details, and does not perform any matrix operations. This misses the primary purpose entirely and all secondary details, making the summary fully inaccurate.",
                "The summary describes computing a covariance matrix using a QRP^T decomposition, which has no relation to the source code's behavior of printing identification statistics from an associative table via an iterator. This is a NOISE failure covering the primary purpose entirely, with zero accurate claims and no insight into the actual implementation."
            ]
        },
        "bint5": {
            "summary": "Identifies and prints file status information , including permissions , ownership , size , and modification time , from a specified directory stream .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function deals with file status information such as permissions, ownership, size, and modification time from a directory stream, but the source code actually iterates over a name table and prints identifier statistics with counts. None of the claims match the code's actual operations, resulting in no accurate alignment.",
                "The summary describes behavior related to file status information, permissions, ownership, size, and modification time from a directory stream, which is entirely inaccurate compared to the source code. The source function prints identifier statistics from an association table, including a count and iterating over keys with associated counts, along with error handling for iterator creation. The summary misses the primary purpose and all secondary details from the source, making it completely misaligned.",
                "The summary claims the function identifies and prints file status details such as permissions, ownership, size, and modification time from a directory stream. In reality, the code prints identifier statistics from an associative table, including a count and key-value data with reference counts, not file metadata. This is a FATAL inaccuracy regarding the primary purpose and key I/O, resulting in high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Saves a transport stream to a specified mailbox with the provided name and optional identifier, handling stream creation and errors.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about saving a transport stream to a mailbox with a name and optional identifier, handling stream creation and errors, do not align with the source code. The function in the source code prints identification statistics from an association table, iterates over entries, and outputs key/count information. None of the claims in the summary correspond to these operations, making them inaccurate.",
                "The summary is entirely inaccurate: it describes saving a transport stream to a mailbox with a provided name and optional identifier, which is unrelated to the source code. The actual function prints identification statistics from an association table to a stream, iterates over entries, and handles iterator errors; none of these behaviors are mentioned. The primary purpose and all secondary details are missed.",
                "The summary is entirely inaccurate as it claims the function saves a transport stream to a mailbox, which contradicts the source code's actual purpose of printing identification statistics from an association table via a stream. This is a FATAL error regarding the primary purpose and I/O behavior, leaving no accurate claims and making the output unreliable."
            ]
        },
        "misum": {
            "summary": "Prints the details of a sieve machine with optional tag by iterating through a filter stream, iterating when the operation fails.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about a 'sieve machine,' 'optional tag,' and 'filter stream' do not match the source code, which actually prints identification statistics from an associative table, including keys and counts, and handles iterator results. All claims target semantics unrelated to the source implementation, making them inaccurate.",
                "The summary is inaccurate as it describes a sieve machine with optional tags and iterating through a filter stream, which does not match the source code. The actual function prints identification statistics from an association table, handles iterator creation errors, and lists keys with their counts. The primary purpose and all secondary details are missed, resulting in no accurate claims aligned with the code.",
                "The summary makes inaccurate and irrelevant claims, such as referencing a 'sieve machine', 'optional tag', and 'filter stream', none of which are present in the source code. The function actually prints identification statistics from an association table via an iterator. These mismatches represent NOISE and potentially misleading information targeting the primary purpose, resulting in no reliable alignment and no useful insights."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581103152,
    "strip_function_name": "sub_FFFFFFFF81227430",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81227430(\n        __int64 a1,\n        _DWORD *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  _DWORD *v13; // rax\n  __int64 *v14; // rdx\n  __int64 v15; // rcx\n  int v16; // r8d\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r13d\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  int v23; // r8d\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  _DWORD *v28; // [rsp+0h] [rbp-68h] BYREF\n  _DWORD *v29; // [rsp+8h] [rbp-60h]\n  _QWORD v30[3]; // [rsp+10h] [rbp-58h] BYREF\n  int v31; // [rsp+28h] [rbp-40h]\n  _QWORD v32[7]; // [rsp+30h] [rbp-38h] BYREF\n\n  v30[0] = a1 - 448;\n  v32[3] = 0LL;\n  v32[0] = &unk_FFFFFFFF81C484A8;\n  v30[1] = a2 - 112;\n  v30[2] = *(_QWORD *)(a3 + 8);\n  v31 = *(_DWORD *)(a3 + 4);\n  v32[1] = v30;\n  v32[2] = &v28;\n  v29 = (_DWORD *)sub_FFFFFFFF81217C20(a4, a5, a6, a7, a8, a9, a10, a11);\n  v13 = (_DWORD *)sub_FFFFFFFF81217C20(a4, a5, a6, a7, v11, v12, a10, a11);\n  v28 = v13;\n  if ( v29 && v13 )\n  {\n    v20 = sub_FFFFFFFF81226DE0(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL) + 40LL), (__int64)v32);\n    sub_FFFFFFFF812192A0((__int64)a2, v28);\n    a2 = v29;\n    sub_FFFFFFFF812192A0(a1, v29);\n    v13 = v28;\n  }\n  else\n  {\n    v20 = -12;\n  }\n  sub_FFFFFFFF8112DCD0((unsigned __int64)v13, a4, a5, a6, a7, v18, v19, a10, a11, (__int64)a2, v14, v15, v16, v17);\n  sub_FFFFFFFF8112DCD0((unsigned __int64)v29, a4, a5, a6, a7, v25, v26, a10, a11, (__int64)a2, v21, v22, v23, v24);\n  return v20;\n}\n",
    "function_name": "nfs3_proc_link",
    "decompiled_code": "__int64 __fastcall nfs3_proc_link(\n        __int64 a1,\n        _DWORD *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 *v13; // rax\n  __int64 *v14; // rdx\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int v17; // r13d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 *v22; // rdx\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 *v26; // [rsp+0h] [rbp-68h] BYREF\n  __int64 *v27; // [rsp+8h] [rbp-60h]\n  _QWORD v28[3]; // [rsp+10h] [rbp-58h] BYREF\n  int v29; // [rsp+28h] [rbp-40h]\n  _QWORD v30[7]; // [rsp+30h] [rbp-38h] BYREF\n\n  v28[0] = a1 - 448;\n  v30[3] = 0LL;\n  v30[0] = &unk_FFFFFFFF81C484A8;\n  v28[1] = a2 - 112;\n  v28[2] = *(_QWORD *)(a3 + 8);\n  v29 = *(_DWORD *)(a3 + 4);\n  v30[1] = v28;\n  v30[2] = &v26;\n  v27 = nfs_alloc_fattr(a4, a5, a6, a7, a8, a9, a10, a11);\n  v13 = nfs_alloc_fattr(a4, a5, a6, a7, v11, v12, a10, a11);\n  v26 = v13;\n  if ( v27 && v13 )\n  {\n    v17 = nfs3_rpc_wrapper_constprop_9(\n            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL) + 40LL),\n            (__int64)v30,\n            a4,\n            a5,\n            a6,\n            a7,\n            v15,\n            v16,\n            a10,\n            a11);\n    nfs_post_op_update_inode((__int64)a2, v26, a4, a5, a6, a7, v18, v19, a10, a11);\n    a2 = v27;\n    nfs_post_op_update_inode(a1, v27, a4, a5, a6, a7, v20, v21, a10, a11);\n    v13 = v26;\n  }\n  else\n  {\n    v17 = -12;\n  }\n  kfree(v13, a4, a5, a6, a7, v15, v16, a10, a11, (__int64)a2, v14);\n  kfree(v27, a4, a5, a6, a7, v23, v24, a10, a11, (__int64)a2, v22);\n  return v17;\n}\n",
    "source_code": "\nstatic int\nnfs3_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs3_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct nfs3_linkres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tres.fattr = nfs_alloc_fattr();\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.fattr == NULL || res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_post_op_update_inode(inode, res.fattr);\nout:\n\tnfs_free_fattr(res.dir_attr);\n\tnfs_free_fattr(res.fattr);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}",
    "comment": "Links a source inode to a target directory inode with a specified name using an NFS procedure and updates their attributes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Renames a file in an NFS directory by sending a rename RPC request and updating directory inodes with the response .\n",
    "cpbcs_sum": "Renames a directory entry on an NFS server and updates the directory's inode attributes based on the new response.\n",
    "misum_sum": "Renames a file in an NFS directory by sending a rename RPC request and updating the directory's inode attributes.\n",
    "decom_sum": "Initializes two computed data structures from floating\u2011point parameters, stores them in target contexts, and invokes processing routines, returning an operation status code.",
    "cfg_sum": "Generates two computed data objects from input parameters, validates them, updates associated structures, sets a status code, performs cleanup, and returns the result.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only a vague, low-information phrase that does not accurately reflect any specific detail or functionality from the source code. It fails to mention the NFS link procedure, arguments, RPC calls, or inode updates present in the implementation, resulting in no accurate claims to evaluate.",
                "The summary 'push a pointer type.' is unrelated to the source code's primary purpose, which is performing an NFSv3 link operation between two inodes via an RPC call with proper attribute allocation, updates, and cleanup. It fails to capture any aspect of the function's behavior, inputs, outputs, or side effects, leading to no verifiable coverage of critical semantic units.",
                "The summary contains a vague, unrelated statement ('push a pointer type') that does not match or describe the source code's functionality, which involves creating NFSv3 links via RPC calls and updating inode attributes. This is pure NOISE with no accurate claims, providing no insight into primary purpose, I/O, or side effects."
            ]
        },
        "bint5": {
            "summary": "Renames a file in an NFS directory by sending a rename RPC request and updating directory inodes with the response .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as renaming a file via a rename RPC, whereas the source code clearly performs a link operation using NFS3PROC_LINK, allocating file attributes, making a synchronous RPC call to create the link, and updating both inode attributes. None of the main claims match the actual operation, resulting in no accurate claims.",
                "The summary incorrectly describes the function as performing a file rename via a rename RPC, while the source code clearly implements a link operation using the NFS3PROC_LINK procedure. This contradicts the primary purpose and fails to mention key steps such as allocating attributes, handling memory allocation failure, invoking rpc_call_sync, and updating both the source and target inodes. As the primary behavior is misidentified, none of the critical semantic units are accurately covered.",
                "The summary incorrectly claims the function renames a file via a rename RPC, while the source code clearly performs a link operation using NFS3PROC_LINK and link-specific arguments. This is a FATAL error about the primary purpose of the function. No accurate claims remain to provide understanding, resulting in high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Renames a directory entry on an NFS server and updates the directory's inode attributes based on the new response.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function renames a directory entry on an NFS server, but the source code actually performs a hard link operation using NFSv3 LINK procedure, not a rename. While it correctly notes that the directory's inode attributes are updated, the primary operation is misrepresented, making one of the main claims inaccurate and resulting in less than half of the claims being correct.",
                "The summary claims the function renames a directory entry, which is inaccurate; the source code actually performs an NFS hard link operation between two inodes. While it does update inode attributes after the RPC call, the primary purpose is misrepresented, meaning the summary misses the main semantics and most secondary details such as input handling, allocation checks, and error paths.",
                "The summary incorrectly describes the function as renaming a directory entry, while the source implements NFSv3 hard link creation (`nfs3_proc_link`). This misstates the primary purpose, constituting a FATAL inaccuracy. The only partially accurate element is that the function updates directory inode attributes after the RPC call. However, because the core functionality is misrepresented, overall accuracy and utility are very low."
            ]
        },
        "misum": {
            "summary": "Renames a file in an NFS directory by sending a rename RPC request and updating the directory's inode attributes.\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function renames a file using a rename RPC request, while the source code clearly performs an NFS link operation via the NFS3PROC_LINK procedure. This is a fatal mismatch in functionality and semantics. No claims in the summary are accurate to the source implementation, as even the attribute update inodes occur for both the link target and its parent directory, not in the context of renaming.",
                "The summary is inaccurate because it describes a file rename operation via a rename RPC, while the source code clearly performs a link operation using NFS3PROC_LINK, creating a hard link between the given inode and directory. Although it mentions updating the directory's inode attributes, it misrepresents the primary purpose and RPC type, missing key implementation details such as argument setup, memory allocation for attributes, and synchronous RPC call behavior.",
                "The summary contains a FATAL inaccuracy: it claims the function renames a file via a rename RPC request, but the source code clearly performs a link operation using NFS3PROC_LINK, not a rename. This is a wrong statement about the primary purpose and semantics of the code, leading to high negative impact. No accurate or helpful claims are present to offset this error."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578882688,
    "strip_function_name": "sub_FFFFFFFF81009280",
    "strip_decompiled_code": "unsigned __int64 sub_FFFFFFFF81009280()\n{\n  unsigned __int64 v0; // rax\n  int v1; // r8d\n  int v2; // r9d\n  unsigned __int64 v3; // rcx\n  unsigned __int64 v4; // r12\n  unsigned __int64 v5; // rdi\n  unsigned __int64 v6; // rcx\n  unsigned int v7; // ecx\n  unsigned __int64 result; // rax\n  unsigned __int64 v9; // rbx\n  unsigned __int64 v10[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( dword_FFFFFFFF81CB4F64 )\n    goto LABEL_14;\n  if ( qword_FFFFFFFF81C12640 != -1 )\n  {\n    v0 = sub_FFFFFFFF81009120((__int64 *)v10, dword_FFFFFFFF81DCE588);\n    v3 = v10[0];\n    if ( qword_FFFFFFFF81DCE580 == v10[0] || qword_FFFFFFFF81C12640 == -1 || v0 == -1LL )\n      goto LABEL_14;\n    v4 = 1000000 * (v0 - qword_FFFFFFFF81C12640);\n    if ( dword_FFFFFFFF81DCE588 )\n    {\n      if ( qword_FFFFFFFF81DCE580 > v10[0] )\n        v3 = v10[0] + 0x100000000LL;\n      v9 = v3 - qword_FFFFFFFF81DCE580;\n      LODWORD(v6) = v9 * (unsigned int)sub_FFFFFFFF8102BA50(4LL) / 0xF4240;\n    }\n    else\n    {\n      v5 = -1LL;\n      if ( !(v10[0] | qword_FFFFFFFF81DCE580) )\n      {\nLABEL_12:\n        v7 = dword_FFFFFFFF81CB4F68;\n        if ( (__int64)abs64((unsigned int)dword_FFFFFFFF81CB4F68 - v5) > dword_FFFFFFFF81CB4F68 / 0x64u )\n          return sub_FFFFFFFF81087030(&off_FFFFFFFF81C12700, 1000LL, v7);\n        dword_FFFFFFFF81CB4F68 = v5;\n        sub_FFFFFFFF8178A70F(\n          (unsigned int)&unk_FFFFFFFF81989760,\n          (unsigned int)v5 / 0x3E8,\n          (unsigned int)v5 % 0x3E8,\n          1000,\n          v1,\n          v2);\nLABEL_14:\n        v7 = dword_FFFFFFFF81CB4F68;\n        return sub_FFFFFFFF81087030(&off_FFFFFFFF81C12700, 1000LL, v7);\n      }\n      if ( qword_FFFFFFFF81DCE580 > v10[0] )\n        v3 = v10[0] + 0x1000000;\n      v6 = 1000000000 * (v3 - qword_FFFFFFFF81DCE580) / 0x369E99;\n    }\n    v5 = v4 / (unsigned int)v6;\n    goto LABEL_12;\n  }\n  dword_FFFFFFFF81DCE588 = sub_FFFFFFFF8102AD70();\n  sub_FFFFFFFF81058CD0(64LL, qword_FFFFFFFF81CB6E38, &dword_FFFFFFFF81C12660, 1000LL);\n  result = sub_FFFFFFFF81009120(&qword_FFFFFFFF81DCE580, dword_FFFFFFFF81DCE588);\n  qword_FFFFFFFF81C12640 = result;\n  return result;\n}\n",
    "function_name": "tsc_refine_calibration_work",
    "decompiled_code": "unsigned __int64 __fastcall tsc_refine_calibration_work(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned __int64 refs; // rax\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  unsigned __int64 v11; // rcx\n  unsigned __int64 v12; // r12\n  unsigned __int64 v13; // rdi\n  unsigned __int64 v14; // rcx\n  unsigned int v15; // ecx\n  unsigned __int64 result; // rax\n  unsigned __int64 v17; // rbx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  unsigned __int64 v22[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( tsc_unstable )\n    goto LABEL_14;\n  if ( tsc_start_23383 != -1 )\n  {\n    refs = tsc_read_refs((__int64 *)v22, hpet_23385);\n    v11 = v22[0];\n    if ( ref_start_23384 == v22[0] || tsc_start_23383 == -1 || refs == -1LL )\n      goto LABEL_14;\n    v12 = 1000000 * (refs - tsc_start_23383);\n    if ( hpet_23385 )\n    {\n      if ( ref_start_23384 > v22[0] )\n        v11 = v22[0] + 0x100000000LL;\n      v17 = v11 - ref_start_23384;\n      LODWORD(v14) = v17 * (unsigned int)hpet_readl(4u) / 0xF4240;\n    }\n    else\n    {\n      v13 = -1LL;\n      if ( !(v22[0] | ref_start_23384) )\n      {\nLABEL_12:\n        v15 = tsc_khz;\n        if ( (__int64)abs64((unsigned int)tsc_khz - v13) > tsc_khz / 0x64u )\n          return _clocksource_register_scale((__int64)&clocksource_tsc, 0x3E8u, v15);\n        tsc_khz = v13;\n        printk(\n          (__int64)&unk_FFFFFFFF81989760,\n          a1,\n          a2,\n          a3,\n          a4,\n          v9,\n          v10,\n          a7,\n          a8,\n          (unsigned int)v13 / 0x3E8,\n          (unsigned int)v13 % 0x3E8);\nLABEL_14:\n        v15 = tsc_khz;\n        return _clocksource_register_scale((__int64)&clocksource_tsc, 0x3E8u, v15);\n      }\n      if ( ref_start_23384 > v22[0] )\n        v11 = v22[0] + 0x1000000;\n      v14 = 1000000000 * (v11 - ref_start_23384) / 0x369E99;\n    }\n    v13 = v12 / (unsigned int)v14;\n    goto LABEL_12;\n  }\n  hpet_23385 = is_hpet_enabled();\n  queue_delayed_work_on(0x40u, system_wq, tsc_irqwork, 1000LL, a1, a2, a3, a4, v20, v21, a7, a8, v18, v19);\n  result = tsc_read_refs(&ref_start_23384, hpet_23385);\n  tsc_start_23383 = result;\n  return result;\n}\n",
    "source_code": "static void tsc_refine_calibration_work(struct work_struct *work)\n{\n\tstatic u64 tsc_start = -1, ref_start;\n\tstatic int hpet;\n\tu64 tsc_stop, ref_stop, delta;\n\tunsigned long freq;\n\n\t/* Don't bother refining TSC on unstable systems */\n\tif (check_tsc_unstable())\n\t\tgoto out;\n\n\t/*\n\t * Since the work is started early in boot, we may be\n\t * delayed the first time we expire. So set the workqueue\n\t * again once we know timers are working.\n\t */\n\tif (tsc_start == -1) {\n\t\t/*\n\t\t * Only set hpet once, to avoid mixing hardware\n\t\t * if the hpet becomes enabled later.\n\t\t */\n\t\thpet = is_hpet_enabled();\n\t\tschedule_delayed_work(&tsc_irqwork, HZ);\n\t\ttsc_start = tsc_read_refs(&ref_start, hpet);\n\t\treturn;\n\t}\n\n\ttsc_stop = tsc_read_refs(&ref_stop, hpet);\n\n\t/* hpet or pmtimer available ? */\n\tif (ref_start == ref_stop)\n\t\tgoto out;\n\n\t/* Check, whether the sampling was disturbed by an SMI */\n\tif (tsc_start == ULLONG_MAX || tsc_stop == ULLONG_MAX)\n\t\tgoto out;\n\n\tdelta = tsc_stop - tsc_start;\n\tdelta *= 1000000LL;\n\tif (hpet)\n\t\tfreq = calc_hpet_ref(delta, ref_start, ref_stop);\n\telse\n\t\tfreq = calc_pmtimer_ref(delta, ref_start, ref_stop);\n\n\t/* Make sure we're within 1% */\n\tif (abs(tsc_khz - freq) > tsc_khz/100)\n\t\tgoto out;\n\n\ttsc_khz = freq;\n\tpr_info(\"Refined TSC clocksource calibration: %lu.%03lu MHz\\n\",\n\t\t(unsigned long)tsc_khz / 1000,\n\t\t(unsigned long)tsc_khz % 1000);\n\nout:\n\tclocksource_register_khz(&clocksource_tsc, tsc_khz);\n}",
    "comment": "Refines TSC clocksource calibration by measuring timer frequencies and adjusting the TSC frequency if within 1% accuracy after initial readings.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Enables HPET by configuring the PCI device and setting the appropriate registers if certain conditions are met .\n",
    "cpbcs_sum": "Calculates the current scheduler clock time based on clock frequency, and user context, ensuring it corresponds to a 32-bit factor during the operation.\n",
    "misum_sum": "Calculates and returns the maximum idle time when dividing is below the current clock time.\n",
    "decom_sum": "Calculates elapsed time between hardware counter reads to update and return a cached frequency value, reinitializing measurement state if uninitialized.",
    "cfg_sum": "Calculates time intervals from hardware counters, adjusts for wraparound, validates against thresholds, and updates stored timing data before returning a processed timing result.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary 'push a pointer type.' does not describe any fact-based claim relevant to the source code, which is about refining TSC calibration in a workqueue context. It fails to match any implementation detail or semantics from the provided code, making all claims inaccurate.",
                "The summary 'push a pointer type.' is vague, unrelated to the code, and does not capture the primary purpose or any secondary details of the function. The source code deals with refining the TSC clocksource calibration, checking if the TSC is stable, scheduling delayed work, reading references, calculating frequency, and updating tsc_khz, none of which are addressed by the summary. This results in no accurate claim coverage.",
                "The summary 'push a pointer type.' is pure NOISE\u2014it makes no reference to the actual function `tsc_refine_calibration_work` or its behavior in calibrating the TSC clocksource using HPET/PM timers. There are no ACCURATE claims and the only claim is unrelated to the source code's semantics, giving zero usable insight. Worst failure mode is overwhelming NOISE with no factual alignment."
            ]
        },
        "bint5": {
            "summary": "Enables HPET by configuring the PCI device and setting the appropriate registers if certain conditions are met .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the code enables HPET by configuring a PCI device and setting registers based on conditions, but the source function only checks whether HPET is enabled and uses it for TSC calibration without configuring PCI devices or registers. This is a direct contradiction to the source semantics, making the claim inaccurate and lowering alignment to zero.",
                "The summary claims that the function enables HPET via PCI device configuration and register settings, which is unrelated to the source code. The actual function refines TSC calibration, conditionally reads reference timers, and updates tsc_khz. No PCI configuration or register setup is performed, making the summary entirely inaccurate and missing the primary purpose.",
                "The summary claims the function enables HPET via PCI device configuration and register setting, but the source code does not perform any PCI-level HPET enablement. Instead, it checks if HPET is already enabled, uses it for time reference, and refines TSC calibration. This is a direct contradiction about the primary purpose and key operations, making it a FATAL error with no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Calculates the current scheduler clock time based on clock frequency, and user context, ensuring it corresponds to a 32-bit factor during the operation.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates the current scheduler clock time based on clock frequency and user context with a 32-bit factor, but the source code actually refines TSC clocksource calibration using hardware references like HPET or PM timer, with no scheduler clock or user context involved and no mention of a 32-bit factor. All claims are inaccurate, showing no alignment with the implemented logic.",
                "The summary is inaccurate because it describes calculating a scheduler clock time involving user context and a 32-bit factor, which is not present in the source code. The actual function refines TSC clocksource calibration using reference timers, checks stability, handles edge cases, and updates the TSC frequency if within 1%, then registers it. The primary purpose and key secondary details from the source are entirely missed.",
                "The summary contains a FATAL inaccuracy: it claims the function calculates the current scheduler clock time based on clock frequency and user context with a 32-bit factor, which is not reflected in the source code. The actual function refines TSC clocksource calibration using hardware timers (HPET or PM timer), adjusting frequency and registering the clocksource. There is no mention of scheduler clock time, user context, or 32-bit factor. This misrepresents the primary purpose and key I/O, making the description unreliable and misleading."
            ]
        },
        "misum": {
            "summary": "Calculates and returns the maximum idle time when dividing is below the current clock time.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes a claim about calculating and returning maximum idle time related to division and current clock time, which is not reflected in the source code. The source function refines TSC calibration, checks stability, measures frequency using HPET or pmtimer, and registers the clock source, with no concept of 'maximum idle time' or divisions relative to current clock time. All claims are inaccurate with respect to the implementation.",
                "The summary is entirely inaccurate: it describes calculating and returning a maximum idle time, which is unrelated to the function\u2019s actual purpose of refining TSC clocksource calibration using either HPET or PMTimer references. It misses the primary purpose and all secondary details like conditions for unstable TSC, scheduling delayed work, frequency calculation, tolerance checks, and clocksource registration.",
                "The summary makes an inaccurate claim about calculating and returning maximum idle time, which is unrelated to the source code's actual functionality of refining TSC clocksource calibration. This is a FATAL error because it misstates the primary purpose and key operations of the function, leading to a complete misunderstanding of the code."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581809888,
    "strip_function_name": "sub_FFFFFFFF812D3CE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812D3CE0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // r13\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 (__fastcall *v14)(__int64); // rax\n  unsigned int v15; // ebx\n  __int64 result; // rax\n\n  v9 = *(_QWORD *)(a1 + 144);\n  v10 = a1 - 152;\n  if ( !v9 )\n  {\n    if ( !(unsigned __int8)sub_FFFFFFFF812D3760(\n                             *(_WORD *)(a1 - 92),\n                             *(_WORD *)(a1 - 90),\n                             *(_QWORD **)(a1 - 64),\n                             a2,\n                             a3,\n                             a4,\n                             a5,\n                             a6,\n                             a7,\n                             a8,\n                             a9) )\n    {\nLABEL_10:\n      if ( !*(_QWORD *)(a1 - 128) )\n        sub_FFFFFFFF812D1F30(v10);\n      goto LABEL_6;\n    }\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  }\n  v11 = *(_QWORD *)(v9 + 104);\n  if ( (unsigned __int8)sub_FFFFFFFF812D3760(\n                          *(_WORD *)(a1 - 92),\n                          *(_WORD *)(a1 - 90),\n                          *(_QWORD **)(a1 - 64),\n                          a2,\n                          a3,\n                          a4,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9) )\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( !v11 )\n    goto LABEL_10;\n  *(_BYTE *)(a1 + 1067) &= ~1u;\n  v14 = *(__int64 (__fastcall **)(__int64))(v11 + 48);\n  if ( !v14 || (v15 = v14(a1), sub_FFFFFFFF813F7A40(\"pci_pm_poweroff\", *(_QWORD *)(v11 + 48), v15), (result = v15) == 0) )\n  {\nLABEL_6:\n    sub_FFFFFFFF812DB930(5LL, v10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "pci_pm_poweroff",
    "decompiled_code": "__int64 __fastcall pci_pm_poweroff(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // r13\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 (__fastcall *v14)(__int64); // rax\n  unsigned int v15; // ebx\n  __int64 v16; // rcx\n  int v17; // r8d\n  int v18; // r9d\n  __int64 result; // rax\n\n  v9 = *(_QWORD *)(a1 + 144);\n  v10 = a1 - 152;\n  if ( !v9 )\n  {\n    if ( !(unsigned __int8)pci_has_legacy_pm_support_isra_13(\n                             *(_WORD *)(a1 - 92),\n                             *(_WORD *)(a1 - 90),\n                             *(_QWORD **)(a1 - 64),\n                             a2,\n                             a3,\n                             a4,\n                             a5,\n                             a6,\n                             a7,\n                             a8,\n                             a9) )\n    {\nLABEL_10:\n      if ( !*(_QWORD *)(a1 - 128) )\n        pci_disable_enabled_device(v10);\n      goto LABEL_6;\n    }\n    return pci_legacy_suspend(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  }\n  v11 = *(_QWORD *)(v9 + 104);\n  if ( (unsigned __int8)pci_has_legacy_pm_support_isra_13(\n                          *(_WORD *)(a1 - 92),\n                          *(_WORD *)(a1 - 90),\n                          *(_QWORD **)(a1 - 64),\n                          a2,\n                          a3,\n                          a4,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9) )\n    return pci_legacy_suspend(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( !v11 )\n    goto LABEL_10;\n  *(_BYTE *)(a1 + 1067) &= ~1u;\n  v14 = *(__int64 (__fastcall **)(__int64))(v11 + 48);\n  if ( !v14\n    || (v15 = v14(a1),\n        _suspend_report_result((int)\"pci_pm_poweroff\", *(_QWORD *)(v11 + 48), v15, v16, v17, v18),\n        (result = v15) == 0) )\n  {\nLABEL_6:\n    pci_fixup_device(5LL, v10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n Fixup:\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}",
    "comment": "Handles the power-off process for PCI devices, utilizing legacy support or device-specific power management operations, and fixes up device state afterward.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Suspends a PCI device by invoking the driver 's suspend function or performing a default suspension , while handling legacy power management support .\n",
    "cpbcs_sum": "Freezes the PCI device without IRQ, saves its state, and handles specific BIOS quirks for USB EHCI host controllers.\n",
    "misum_sum": "Freezes the PCI device by invoking the driver's freeze routine or defaults to legacy suspension if legacy support is available.\n",
    "decom_sum": "Manages PCI device power-off by checking conditions, invoking callbacks, and performing fallback shutdown operations when necessary.",
    "cfg_sum": "Handles PCI device power management by validating conditions, invoking related callbacks, and performing power-off or initialization when required.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains an extremely vague and unrelated statement that does not correspond to any fact-based claims about the source code's logic or behavior. No accurate claims can be extracted from it, as it fails to describe the PCI poweroff function or any of its operations, resulting in zero alignment with the evaluation steps.",
                "The summary 'push a pointer type.' does not convey the primary purpose or any meaningful secondary details of the function pci_pm_poweroff. It fails to mention that the function handles PCI device power-off, including checks for legacy PM support, invoking driver-specific poweroff routines, default suspend behavior, and fixup operations. The summary is unrelated to the code semantics, making it inaccurate and providing no CSU coverage.",
                "The summary provides an extremely vague and irrelevant statement that does not describe any function behavior or logic from the source code. It does not mention the PCI device handling, poweroff logic, suspend operations, or fixup steps present in the implementation. This is pure NOISE, with no accurate or meaningful claims to evaluate, resulting in zero alignment."
            ]
        },
        "bint5": {
            "summary": "Suspends a PCI device by invoking the driver 's suspend function or performing a default suspension , while handling legacy power management support .\n",
            "score": [
                0.6,
                0.6,
                0.8
            ],
            "reason": [
                "The summary claims the function suspends the PCI device via the driver\u2019s suspend function or a default suspension, which partially aligns with the source code: the code checks for legacy PM support, uses pci_legacy_suspend, and falls back to pci_pm_default_suspend if no PM ops exist, but it actually calls the driver\u2019s poweroff method rather than a suspend method. This mislabeling of the function as a suspend instead of poweroff reduces accuracy. Handling of legacy PM support is correctly mentioned. Overall, most but not all claims align with the source.",
                "The summary correctly identifies the primary purpose: suspending a PCI device, and notes two main paths\u2014driver suspend function and default suspension\u2014while mentioning legacy power management support. However, it omits important secondary details from the code such as the specific use of the 'poweroff' callback with error handling and reporting, the state_saved field manipulation, and the pci_fixup_device call after suspension. This partial coverage of secondary behavior limits completeness.",
                "The summary accurately states that the function suspends a PCI device either through the driver\u2019s suspend-like power management callback or a default suspension path, and that it accounts for legacy PM support. These details align with the code\u2019s flow: it checks for legacy support, calls either pm->poweroff or pci_pm_default_suspend, and applies pci_fixup_device. There are no factual errors or contradictions, though the wording uses 'suspend' instead of 'poweroff', which is a minor imprecision. The claims are specific, yielding high informational value and strong alignment overall."
            ]
        },
        "cpbcs": {
            "summary": "Freezes the PCI device without IRQ, saves its state, and handles specific BIOS quirks for USB EHCI host controllers.\n",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains claims about freezing the PCI device without IRQ, saving its state, and handling BIOS quirks for USB EHCI host controllers. The source code does save state information via `pci_dev->state_saved` and performs a suspend/fixup, but there is no indication of IRQ freezing or specific BIOS handling for USB EHCI controllers. Most claims are either unsupported or incorrect, with only the 'saves its state' aspect loosely aligning. This results in less than half of the claims being accurate.",
                "The summary is largely inaccurate: the source code does not show freezing without IRQ, specific BIOS quirks, or USB EHCI host controller handling. It involves suspending or powering off a PCI device, optionally using driver-provided `poweroff` callbacks or legacy suspend methods, saving state, and applying generic PCI fixups. The primary purpose is misrepresented, and no accurate claim from the summary maps to the code\u2019s actual behavior.",
                "The summary's claims about freezing the PCI device without IRQ and handling BIOS quirks for USB EHCI host controllers are not reflected in the provided source code, making them inaccurate. The source code focuses on suspending or powering off a PCI device using either legacy support or driver-specific poweroff callbacks, then applying generic fixups, without targeting IRQ handling or USB-specific quirks. These inaccuracies constitute NOISE, with no FATAL errors on primary purpose, but the summary offers little accurate detail to aid understanding."
            ]
        },
        "misum": {
            "summary": "Freezes the PCI device by invoking the driver's freeze routine or defaults to legacy suspension if legacy support is available.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior: it claims the PCI device is frozen via a driver's freeze routine, but the source code uses the driver's 'poweroff' callback or defaults to legacy suspend when legacy support exists. There is a mismatch between 'freeze' and 'poweroff', and the order of checks is also misrepresented. The proportion of accurate claims is below half due to these semantic errors.",
                "The summary misstates the PRIMARY PURPOSE and behavior of the source function. The code performs a power-off sequence for a PCI device, not a freeze, and calls the driver's `poweroff` routine or defaults to legacy suspend if legacy support is present. The summary incorrectly refers to a 'freeze routine,' which does not exist in the code, and omits critical secondary details such as state resetting, default suspend handling when no driver PM ops exist, error reporting, and device fixup. This both contradicts and substantially misses CSU coverage.",
                "The summary inaccurately describes the function\u2019s behavior by claiming it invokes a driver\u2019s freeze routine, while the source code actually calls the driver\u2019s poweroff routine if available. This is a FATAL error affecting key I/O semantics. Although it correctly notes the use of legacy suspension if supported, the primary purpose is misrepresented, leading to high negative impact and very low net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582451776,
    "strip_function_name": "sub_FFFFFFFF81370840",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF81370840(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 v14; // rbx\n  unsigned __int64 v16; // rdi\n  int v17; // r12d\n  int i; // r12d\n  __int64 v19; // rax\n\n  v14 = a2;\n  if ( *(_DWORD *)(a2 + 16) )\n  {\n    if ( *(int *)(a2 + 16) <= 0 )\n    {\n      v16 = *(_QWORD *)(a2 + 24);\n    }\n    else\n    {\n      v16 = *(_QWORD *)(a2 + 24);\n      v17 = 0;\n      do\n      {\n        a2 = *(_QWORD *)(v16 + 8LL * v17);\n        if ( a2 )\n        {\n          sub_FFFFFFFF8137CAD0(a1);\n          v16 = *(_QWORD *)(v14 + 24);\n        }\n        ++v17;\n      }\n      while ( *(_DWORD *)(v14 + 16) > v17 );\n    }\n    sub_FFFFFFFF8112DCD0(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);\n    *(_DWORD *)(v14 + 16) = 0;\n  }\n  if ( *(_DWORD *)(v14 + 4) )\n  {\n    for ( i = 0; i < *(_DWORD *)(v14 + 4); ++i )\n    {\n      v19 = i;\n      sub_FFFFFFFF8112DCD0(\n        *(_QWORD *)(*(_QWORD *)(v14 + 8) + 88 * v19 + 80),\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14,\n        a2,\n        *(__int64 **)(v14 + 8),\n        a4,\n        a5,\n        a6);\n    }\n    sub_FFFFFFFF8112DCD0(*(_QWORD *)(v14 + 8), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);\n    *(_DWORD *)(v14 + 4) = 0;\n  }\n}\n",
    "function_name": "drm_cleanup_buf_error",
    "decompiled_code": "void __fastcall drm_cleanup_buf_error(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        __int64 a5,\n        unsigned __int64 a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 v14; // rbx\n  __int64 *v16; // rdi\n  int v17; // r12d\n  int i; // r12d\n  __int64 v19; // rax\n\n  v14 = a2;\n  if ( *(_DWORD *)(a2 + 16) )\n  {\n    if ( *(int *)(a2 + 16) <= 0 )\n    {\n      v16 = *(__int64 **)(a2 + 24);\n    }\n    else\n    {\n      v16 = *(__int64 **)(a2 + 24);\n      v17 = 0;\n      do\n      {\n        a2 = v16[v17];\n        if ( a2 )\n        {\n          drm_pci_free(a1, (__int64 *)a2, (__int64)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);\n          v16 = *(__int64 **)(v14 + 24);\n        }\n        ++v17;\n      }\n      while ( *(_DWORD *)(v14 + 16) > v17 );\n    }\n    kfree(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3);\n    *(_DWORD *)(v14 + 16) = 0;\n  }\n  if ( *(_DWORD *)(v14 + 4) )\n  {\n    for ( i = 0; i < *(_DWORD *)(v14 + 4); ++i )\n    {\n      v19 = i;\n      kfree(\n        *(__int64 **)(*(_QWORD *)(v14 + 8) + 88 * v19 + 80),\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14,\n        a2,\n        *(__int64 **)(v14 + 8));\n    }\n    kfree(*(__int64 **)(v14 + 8), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3);\n    *(_DWORD *)(v14 + 4) = 0;\n  }\n}\n",
    "source_code": "static void drm_cleanup_buf_error(struct drm_device * dev,\n\t\t\t\t  struct drm_buf_entry * entry)\n{\n\tint i;\n\n\tif (entry->seg_count) {\n\t\tfor (i = 0; i < entry->seg_count; i++) {\n\t\t\tif (entry->seglist[i]) {\n\t\t\t\tdrm_pci_free(dev, entry->seglist[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(entry->seglist);\n\n\t\tentry->seg_count = 0;\n\t}\n\n\tif (entry->buf_count) {\n\t\tfor (i = 0; i < entry->buf_count; i++) {\n\t\t\tkfree(entry->buflist[i].dev_private);\n\t\t}\n\t\tkfree(entry->buflist);\n\n\t\tentry->buf_count = 0;\n\t}\n}",
    "comment": "Cleans up allocated buffer memory and frees associated resources in a DRM device's buffer entry structure.",
    "hext5_sum": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
    "bint5_sum": "The function frees a DRM memory management structure and its associated pages , ensuring proper cleanup of resources .\n",
    "cpbcs_sum": "Frees memory allocated for each baud mapping in the DRM device's resources and the device's resources appropriately.\n",
    "misum_sum": "Frees memory associated with a DRM property, including gamma ranges and their associated gamma ensuring proper cleanup of resources.\n",
    "decom_sum": "Processes and resets elements in two indexed collections by invoking a transformation routine on each entry with provided numeric and floating-point parameters.",
    "cfg_sum": "Processes and iterates over linked and indexed data structures, invokes computation routines with provided parameters, and resets related structure counters after processing.",
    "work_score": {
        "hext5": {
            "summary": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague statement about generating a fragment to relax address/line increments, which does not correspond to any functionality in the source code. The source implements cleanup of DRM buffer entries and freeing allocated memory, with no concept of address or line increments between fragments. All claims in the summary are unrelated to the code, making them inaccurate.",
                "The summary does not mention or align with the source code\u2019s primary purpose, which is to free allocated buffers and reset counters in case of errors. It instead discusses generating a variant fragment for address/line increments, which is unrelated to the function\u2019s behavior. No accurate claims about inputs, outputs, or error handling are present, resulting in no coverage of any critical semantic units.",
                "The summary does not reference or describe the source code functionality at all, instead mentioning generating a variant fragment and relaxing address/line increments, which is unrelated to the buffer cleanup logic implemented in the code. This constitutes pure NOISE with no accurate claims, resulting in zero alignment and no informational gain."
            ]
        },
        "bint5": {
            "summary": "The function frees a DRM memory management structure and its associated pages , ensuring proper cleanup of resources .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary contains a broad, low-information claim about freeing a DRM memory management structure and associated pages. The source code shows the function frees buffers and segments in a DRM buffer entry, which aligns generally with 'cleanup of resources,' making it SAFE but not highly specific. There are no contradictory or irrelevant claims, so all extracted claims are accurate, though lacking detail.",
                "The summary correctly captures the primary purpose of the function as cleaning up and freeing resources related to DRM memory management, which aligns with the code's behavior of freeing segment lists and buffer lists when counts are nonzero. However, it lacks secondary details such as the conditional checks on `seg_count` and `buf_count`, the specific freeing functions used (`drm_pci_free`, `kfree`), and resetting counts to zero. The description is broad and omits these verifiable specifics.",
                "The summary broadly states that the function frees a DRM memory management structure and associated pages, which is a SAFE but low-information claim. It does not contradict the source code, as the implementation does free memory and resources related to seglist and buflist. However, it omits specific details such as looping through seg_count and buf_count, freeing dev_private, and setting counts to zero. The lack of specificity means it provides minimal insight and has low net benefit, with no FATAL inaccuracies but predominantly generic content."
            ]
        },
        "cpbcs": {
            "summary": "Frees memory allocated for each baud mapping in the DRM device's resources and the device's resources appropriately.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as freeing memory for 'baud mapping' and general device resources, which is not reflected in the source code. The source specifically frees segment and buffer lists related to a drm_buf_entry structure, with no reference to baud mapping. This results in 0% of claims being accurate.",
                "The summary incorrectly describes the function as freeing memory for 'baud mapping' in the DRM device's resources, which is unrelated to the source code implementation. The actual function frees allocated segment and buffer memory in a DRM buffer entry and resets counts. This mismatch means the primary purpose is missed and the claims are inaccurate.",
                "The summary contains an inaccurate claim referencing 'baud mapping', which is unrelated to the source code. The function actually frees memory for buffer segments and buffer lists, not anything related to baud or device resources generally. This is a FATAL error affecting the primary purpose of the function, which is memory cleanup of specific buffer structures. No accurate, detailed claims are present to offset this, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Frees memory associated with a DRM property, including gamma ranges and their associated gamma ensuring proper cleanup of resources.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims cleanup of a DRM property, gamma ranges, and gamma data, none of which are implemented in the source code. The source function frees segment and buffer allocations in a drm_buf_entry, not properties or gamma-related resources. All claims are inaccurate, resulting in no alignment with the source.",
                "The summary incorrectly describes the function as freeing memory for a DRM property and gamma ranges, which is unrelated to the actual code. The source code's primary purpose is to clean up buffer entries, freeing PCI segments and buffer private data before resetting counts. The summary misses the primary purpose entirely and contains inaccurate, unrelated claims, resulting in no accurate coverage of the critical semantic units.",
                "The summary claims the function frees memory for a DRM property, including gamma ranges, which directly contradicts the source code. The actual implementation frees segment and buffer memory in a drm_buf_entry structure, not gamma data. This is a FATAL error about the primary purpose of the function, severely reducing reliability. No accurate claims are present to offset the negative impact."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4723024,
    "strip_function_name": "sub_481150",
    "strip_decompiled_code": "__int64 __fastcall sub_481150(__int64 a1, int a2, const char *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rbp\n  __int64 v5; // rcx\n  void *v7; // r15\n  __int64 v8; // r15\n  char **v9; // r14\n\n  result = 2LL;\n  v4 = *(_QWORD *)(a1 + 135592);\n  if ( v4 )\n  {\n    v5 = *(_QWORD *)(a1 + 135576);\n    result = 0LL;\n    if ( v5 )\n    {\n      if ( a2 >= 0 && *(_DWORD *)(a1 + 135560) > a2 )\n      {\n        v7 = *(void **)(v5 + 8LL * a2);\n        if ( v7 )\n        {\n          *(_QWORD *)(a1 + 135592) = v4 + strlen(*(const char **)(v5 + 8LL * a2)) + 1;\n          free(v7);\n          v4 = *(_QWORD *)(a1 + 135592);\n        }\n        v8 = (int)(strlen(a3) + 1);\n        if ( v8 >= v4 )\n        {\n          *(__m128i *)(a1 + 176644) = _mm_load_si128((const __m128i *)&xmmword_512970);\n          strcpy((char *)(a1 + 176708), \"t divided.\");\n          *(__m128i *)(a1 + 176660) = _mm_load_si128((const __m128i *)&xmmword_512980);\n          *(__m128i *)(a1 + 176676) = _mm_load_si128((const __m128i *)&xmmword_512990);\n          *(__m128i *)(a1 + 176692) = _mm_load_si128((const __m128i *)&xmmword_5129A0);\n          sub_4118F0((_DWORD *)a1, 0, (const char *)(a1 + 176644), 0, \"FAILURE\", 0);\n          *(_QWORD *)(a1 + 135592) = 0LL;\n          return 0LL;\n        }\n        else\n        {\n          v9 = (char **)(*(_QWORD *)(a1 + 135576) + 8LL * a2);\n          *v9 = strdup(a3);\n          if ( *(_QWORD *)(*(_QWORD *)(a1 + 135576) + 8LL * a2) )\n          {\n            result = 1LL;\n            *(_QWORD *)(a1 + 135592) = v4 - v8;\n          }\n          else\n          {\n            sub_40FA60(a1, 0LL, 0);\n            return 0xFFFFFFFFLL;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "Xorriso_register_node_target",
    "decompiled_code": "int __fastcall Xorriso_register_node_target(XorrisO *xorriso, int node_idx, char *disk_path, int flag)\n{\n  int result; // eax\n  off_t node_targets_availmem; // rbp\n  void **hln_targets; // rcx\n  void *v8; // r15\n  off_t v9; // r15\n  void **v10; // r14\n\n  result = 2;\n  node_targets_availmem = xorriso->node_targets_availmem;\n  if ( node_targets_availmem )\n  {\n    hln_targets = xorriso->hln_targets;\n    result = 0;\n    if ( hln_targets )\n    {\n      if ( node_idx >= 0 && xorriso->hln_count > node_idx )\n      {\n        v8 = hln_targets[node_idx];\n        if ( v8 )\n        {\n          xorriso->node_targets_availmem = node_targets_availmem + strlen((const char *)hln_targets[node_idx]) + 1;\n          free(v8);\n          node_targets_availmem = xorriso->node_targets_availmem;\n        }\n        v9 = (int)(strlen(disk_path) + 1);\n        if ( v9 >= node_targets_availmem )\n        {\n          *(__m128i *)xorriso->info_text = _mm_load_si128((const __m128i *)&xmmword_512970);\n          strcpy(&xorriso->info_text[64], \"t divided.\");\n          *(__m128i *)&xorriso->info_text[16] = _mm_load_si128((const __m128i *)&xmmword_512980);\n          *(__m128i *)&xorriso->info_text[32] = _mm_load_si128((const __m128i *)&xmmword_512990);\n          *(__m128i *)&xorriso->info_text[48] = _mm_load_si128((const __m128i *)&xmmword_5129A0);\n          Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, severity, 0);\n          xorriso->node_targets_availmem = 0LL;\n          return 0;\n        }\n        else\n        {\n          v10 = &xorriso->hln_targets[node_idx];\n          *v10 = strdup(disk_path);\n          if ( xorriso->hln_targets[node_idx] )\n          {\n            result = 1;\n            xorriso->node_targets_availmem = node_targets_availmem - v9;\n          }\n          else\n          {\n            Xorriso_no_malloc_memory(xorriso, 0LL, 0);\n            return -1;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "int Xorriso_register_node_target(struct XorrisO *xorriso, int node_idx,\n                                 char *disk_path, int flag)\n{\n int l;\n\n if(xorriso->node_targets_availmem == 0)\n   return(2);\n if(xorriso->hln_targets == NULL || node_idx < 0 ||\n    node_idx >= xorriso->hln_count)\n   return(0);\n if(xorriso->hln_targets[node_idx] != NULL) {\n   xorriso->node_targets_availmem+= strlen(xorriso->hln_targets[node_idx]) +1;\n   free(xorriso->hln_targets[node_idx]);\n }\n l= strlen(disk_path);\n if(xorriso->node_targets_availmem <= l + 1) {\n   sprintf(xorriso->info_text,\n \"Hardlink target buffer exceeds -temp_mem_limit. Hardlinks may get divided.\");\n   Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, \"FAILURE\", 0);\n   xorriso->node_targets_availmem= 0;\n   return(0);\n }\n xorriso->hln_targets[node_idx]= strdup(disk_path);\n if(xorriso->hln_targets[node_idx] == NULL) {\n   Xorriso_no_malloc_memory(xorriso, NULL, 0);\n   return(-1);\n }\n xorriso->node_targets_availmem-= (l + 1);\n return(1);\n}",
    "comment": "Registers a hardlink target for a specified node index in the Xorriso structure, managing memory and error handling accordingly.",
    "hext5_sum": "push a floating point type.",
    "bint5_sum": "Adds a new IsoNode to the IsoImage 's directory list , updating the list and managing memory for the node 's ID and type .\n",
    "cpbcs_sum": "Frees allocated memory for an ISO image, including its PID and managing memory and semaphore registers accordingly.\n",
    "misum_sum": "The function manages HFS+ file creator and optional contexts, returning an error if the file name is invalid or memory allocation fails.\n",
    "decom_sum": "Updates a string entry in an internal table by index, adjusting remaining capacity, or logs a failure if the new string exceeds available space.",
    "cfg_sum": "Updates a string in an indexed list with a new value, ensuring length limits, freeing old memory, and returning status codes for success or failure.",
    "work_score": {
        "hext5": {
            "summary": "push a floating point type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains a single vague claim about pushing a floating point type, which is unrelated to the source code. The function deals with registering hardlink node targets, memory availability checks, and string handling, with no floating point operations. This makes the claim entirely inaccurate and irrelevant, yielding no accurate matches.",
                "The summary makes no fact-based claims related to the function's primary purpose or its implementation details. It describes an unrelated action about pushing a floating point type, while the source code concerns registering a hardlink target with memory limit checks, freeing existing targets, error handling, and returning status codes. This results in no coverage of the actual code semantics.",
                "The summary's only claim, about pushing a floating point type, is completely unrelated to the source code\u2019s function, which handles memory management and registration of hardlink target paths. This represents a FATAL mismatch with the primary purpose, yielding no accurate claims or useful information."
            ]
        },
        "bint5": {
            "summary": "Adds a new IsoNode to the IsoImage 's directory list , updating the list and managing memory for the node 's ID and type .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a new IsoNode to an IsoImage's directory list and manages memory for the node's ID and type. The source code shows a function that registers a hardlink target path for a node index, checks memory limits, duplicates the string, frees old memory, and updates available memory counters. There is no evidence in the code of handling an IsoNode or an IsoImage directory list, nor of managing a node's ID and type. All claims are inaccurate and do not match the actual implementation.",
                "The summary incorrectly describes adding an IsoNode to an IsoImage directory list, which is unrelated to the actual function. The source code shows the function registers a hardlink target for an existing node index, manages available memory, handles allocation failures, and returns status codes. None of these behaviors are reflected in the summary, so it misses the primary purpose and all secondary details.",
                "The summary claims the function adds a new IsoNode to an IsoImage's directory list and manages memory for its ID and type, which is entirely inaccurate. The source code is about registering a hardlink target in a struct `XorrisO`, managing available memory, and handling associated strings. This is a FATAL mismatch affecting the primary purpose and key I/O, with no accurate claims present."
            ]
        },
        "cpbcs": {
            "summary": "Frees allocated memory for an ISO image, including its PID and managing memory and semaphore registers accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function frees allocated memory for an ISO image, handles its PID, and manages memory and semaphore registers. The source code shows that it registers a hardlink target for xorriso by managing memory availability, freeing existing target strings, and copying new paths, without any ISO image or PID handling, nor semaphore register operations. All claims in the summary are inaccurate relative to the actual implementation, resulting in no accurate matches.",
                "The summary's claim about freeing memory for an ISO image, PID, and semaphore registers does not align with the source code. The function actually registers a hardlink target for a given node index, handles memory limits, frees existing target memory if necessary, checks allocation success, and updates available memory. The summary misses the primary purpose entirely and contains unrelated details, providing no accurate coverage of the code.",
                "The summary's claims, such as freeing allocated memory for an ISO image, handling its PID, and managing semaphore registers, are not reflected in the source logic. The function actually registers a hardlink target path, checks memory limits, frees/reallocates target strings, and logs failures. These are semantic mismatches, making the claims [INACCURATE] and introducing FATAL errors about the primary purpose and key side effects. This causes high negative impact and no accurate, useful insight."
            ]
        },
        "misum": {
            "summary": "The function manages HFS+ file creator and optional contexts, returning an error if the file name is invalid or memory allocation fails.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary is entirely inaccurate: it describes HFS+ file creator management and filename validation, which are unrelated to the source code. The actual function handles registration of hardlink target paths, checks available memory, manages freeing and allocating memory, and returns specific status codes. None of these details match the summary\u2019s claims, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate: it describes managing HFS+ file creator contexts, which is unrelated to the actual function. The source code handles hardlink target registration, memory checks, and allocation within a xorriso structure. None of those behaviors\u2014memory limit handling, specific return codes, or message submissions\u2014are mentioned. Thus, it fails to capture the primary purpose or any secondary details.",
                "The summary contains purely inaccurate claims unrelated to the source code\u2019s semantics. It describes managing HFS+ file creator and optional contexts, as well as returning an error for invalid file names, none of which are implemented in the function. The actual function handles registering hardlink targets, manages memory limits, and returns various codes based on allocation and validity checks. This is a NOISE-heavy summary with no accurate claims, providing zero useful insight."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4223072,
    "strip_function_name": "sub_407060",
    "strip_decompiled_code": "char *__fastcall sub_407060(__int64 a1, unsigned int a2)\n{\n  char *result; // rax\n  __int16 v3; // dx\n  char *v4; // rax\n\n  result = \"ABS\";\n  if ( a2 == -15 )\n    return result;\n  result = \"COM\";\n  if ( a2 == -14 )\n    return result;\n  result = \"UND\";\n  if ( !a2 )\n    return result;\n  v3 = *(_WORD *)(a1 + 82);\n  if ( a2 == -256 )\n  {\n    if ( v3 == 50 )\n    {\n      result = \"ANSI_COM\";\n      if ( *(_BYTE *)(a1 + 31) == 1 )\n        return result;\n    }\n    else\n    {\n      result = \"SCOM\";\n      if ( v3 == 140 )\n        return result;\n    }\n    goto LABEL_10;\n  }\n  if ( (unsigned __int16)(v3 - 180) > 1u && v3 != 62 || (result = \"LARGE_COM\", a2 != -254) )\n  {\n    if ( a2 == -253 )\n    {\n      result = \"SCOM\";\n      if ( v3 == 8 )\n        return result;\n      goto LABEL_10;\n    }\n    if ( a2 != -252 || (result = \"SUND\", v3 != 8) )\n    {\n      if ( a2 + 256 > 0x1F )\n      {\n        if ( a2 + 224 <= 0x1F )\n        {\n          sprintf(byte_68E680, \"OS [0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else if ( a2 > 0xFFFFFEFF )\n        {\n          sprintf(byte_68E680, \"RSV[0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else\n        {\n          if ( a2 >= *(_DWORD *)(a1 + 100) )\n          {\n            v4 = dcgettext(0LL, \"bad section index[%3d]\", 5);\n            sprintf(byte_68E680, v4, a2);\n          }\n          else\n          {\n            sprintf(byte_68E680, \"%3d\", a2);\n          }\n          return byte_68E680;\n        }\n      }\nLABEL_10:\n      sprintf(byte_68E680, \"PRC[0x%04x]\", (unsigned __int16)a2);\n      return byte_68E680;\n    }\n  }\n  return result;\n}\n",
    "function_name": "get_symbol_index_type",
    "decompiled_code": "const char *__fastcall get_symbol_index_type(Filedata *filedata, unsigned int type)\n{\n  const char *result; // rax\n  unsigned __int16 e_machine; // dx\n  char *v4; // rax\n\n  result = \"ABS\";\n  if ( type == -15 )\n    return result;\n  result = file + 1849;\n  if ( type == -14 )\n    return result;\n  result = file + 1864;\n  if ( !type )\n    return result;\n  e_machine = filedata->file_header.e_machine;\n  if ( type == -256 )\n  {\n    if ( e_machine == 50 )\n    {\n      result = file + 1839;\n      if ( filedata->file_header.e_ident[7] == 1 )\n        return result;\n    }\n    else\n    {\n      result = file + 1848;\n      if ( e_machine == 140 )\n        return result;\n    }\n    goto LABEL_10;\n  }\n  if ( (unsigned __int16)(e_machine - 180) > 1u && e_machine != 62 || (result = file + 1853, type != -254) )\n  {\n    if ( type == -253 )\n    {\n      result = file + 1848;\n      if ( e_machine == 8 )\n        return result;\n      goto LABEL_10;\n    }\n    if ( type != -252 || (result = file + 1863, e_machine != 8) )\n    {\n      if ( type + 256 > 0x1F )\n      {\n        if ( type + 224 <= 0x1F )\n        {\n          sprintf((char *)&buff_17235.file_header.e_version, &file[1880], (unsigned __int16)type);\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n        else if ( type > 0xFFFFFEFF )\n        {\n          sprintf((char *)&buff_17235.file_header.e_version, &file[1892], (unsigned __int16)type);\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n        else\n        {\n          if ( type >= filedata->file_header.e_shnum )\n          {\n            v4 = dcgettext(0LL, &file[1904], 5);\n            sprintf((char *)&buff_17235.file_header.e_version, v4, type);\n          }\n          else\n          {\n            sprintf((char *)&buff_17235.file_header.e_version, &file[1927], type);\n          }\n          return (const char *)&buff_17235.file_header.e_version;\n        }\n      }\nLABEL_10:\n      sprintf((char *)&buff_17235.file_header.e_version, &file[1868], (unsigned __int16)type);\n      return (const char *)&buff_17235.file_header.e_version;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic const char *\nget_symbol_index_type (Filedata * filedata, unsigned int type)\n{\n  static char buff[32];\n\n  switch (type)\n    {\n    case SHN_UNDEF:\treturn \"UND\";\n    case SHN_ABS:\treturn \"ABS\";\n    case SHN_COMMON:\treturn \"COM\";\n    default:\n      if (type == SHN_IA_64_ANSI_COMMON\n\t  && filedata->file_header.e_machine == EM_IA_64\n\t  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)\n\treturn \"ANSI_COM\";\n      else if ((filedata->file_header.e_machine == EM_X86_64\n\t\t|| filedata->file_header.e_machine == EM_L1OM\n\t\t|| filedata->file_header.e_machine == EM_K1OM)\n\t       && type == SHN_X86_64_LCOMMON)\n\treturn \"LARGE_COM\";\n      else if ((type == SHN_MIPS_SCOMMON\n\t\t&& filedata->file_header.e_machine == EM_MIPS)\n\t       || (type == SHN_TIC6X_SCOMMON\n\t\t   && filedata->file_header.e_machine == EM_TI_C6000))\n\treturn \"SCOM\";\n      else if (type == SHN_MIPS_SUNDEFINED\n\t       && filedata->file_header.e_machine == EM_MIPS)\n\treturn \"SUND\";\n      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)\n\tsprintf (buff, \"PRC[0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LOOS && type <= SHN_HIOS)\n\tsprintf (buff, \"OS [0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LORESERVE)\n\tsprintf (buff, \"RSV[0x%04x]\", type & 0xffff);\n      else if (type >= filedata->file_header.e_shnum)\n\tsprintf (buff, _(\"bad section index[%3d]\"), type);\n      else\n\tsprintf (buff, \"%3d\", type);\n      break;\n    }\n\n  return buff;\n}",
    "comment": "Returns a string representation of a symbol index type based on the provided type and file header information.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Maps specific C++ error codes to their corresponding string representations for terminal and terminal error handling in the provided handle data .\n",
    "cpbcs_sum": "Retrieves a string representation of the symbol type based on the provided section type and file type identifier from the ELF header structure.\n",
    "misum_sum": "Retrieves a string representation of the ELF section based on the provided section header and file name.\n",
    "decom_sum": "Returns a descriptive string label for a given section code and related structure fields, handling predefined constants and formatting unknown or reserved values.",
    "cfg_sum": "Generates and returns a descriptive label or formatted string based on the provided code value and specific fields from the given data structure.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes behavior involving a printf formatting character `fmtch`, a `num_bytes` parameter, and hex conversion rules, none of which exist in the source code. The actual implementation converts a `type` value to a string based on ELF section index constants and file header fields, returning a static buffer. All claims in the summary target non-existent code semantics, making them inaccurate.",
                "The summary is entirely inaccurate: it describes parameters like `fmtch` and `num_bytes` and behavior about hex formatting that do not exist in the source code. It fails to capture the primary purpose, which is to return a string representation of a section index type based on constants and machine/OS conditions from `filedata`. None of the critical semantic units from the source are covered.",
                "The summary contains only inaccurate claims (NOISE) that do not correspond to the source code. It incorrectly describes functionality involving printf formatting characters, num_bytes limits, and hex conversion, none of which exist in the provided function. The actual code maps section index types to strings based on constants and conditions, not formatting arbitrary values. The worst failure mode is NOISE overwhelming the description, leading to no accurate, useful information."
            ]
        },
        "bint5": {
            "summary": "Maps specific C++ error codes to their corresponding string representations for terminal and terminal error handling in the provided handle data .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function maps C++ error codes to string representations for terminal error handling, which contradicts the source code. The actual function maps ELF section index constants to specific strings based on type and machine fields, with no mention of C++ error codes or terminal handling. All claims are inaccurate, resulting in no alignment with the implementation.",
                "The summary incorrectly describes the function as mapping C++ error codes related to terminal error handling, which is not reflected in the source code. The source code maps ELF section index type constants to string representations based on the file header's machine and OSABI fields. This mismatch means the primary purpose and all secondary details are missed.",
                "The summary is inaccurate, describing mapping of C++ error codes for terminal error handling, which does not match the source code's actual purpose of mapping ELF section index types to strings based on type values and machine/OS context. This is a FATAL error affecting the primary purpose, resulting in a significant negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves a string representation of the symbol type based on the provided section type and file type identifier from the ELF header structure.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function retrieves a string representation of a symbol type based on the section type and ELF header information, which matches the source code logic. However, it is broad and omits key specifics such as the exact type cases handled and the conditional checks for different architectures. Despite lacking detail, it is factually accurate and non-contradictory, resulting in all claims being accurate but low in specificity.",
                "The summary correctly conveys the primary purpose of the function \u2014 returning a string representation of a symbol type based on the section type and ELF header data \u2014 which matches the source code's behavior. However, it omits key secondary details such as specific mappings for constants (e.g., 'UND', 'ABS', 'COM'), conditional cases for different architectures and OS ABI values, dynamic formatting for ranges like PRC, OS, RSV, and handling of bad section indices. These omissions reduce completeness, though the main purpose is covered.",
                "The summary correctly states that the function returns a string representation of a symbol type based on the section type and ELF header file information, which matches the code\u2019s switch cases and conditional checks using `type` and `file_header` fields. However, it is broad and lacks specifics such as the exact mappings (e.g., 'UND', 'ABS', etc.) and the multiple machine/OSABI condition branches. The claims are accurate but low-info, providing little detailed insight and thus offering low gain. There is no factual error or contradiction, so no FATAL impact, but the lack of specificity limits usefulness."
            ]
        },
        "misum": {
            "summary": "Retrieves a string representation of the ELF section based on the provided section header and file name.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves a string for an ELF section based on a section header and file name, but the source code shows the function uses a numeric section type and Filedata structure fields, not a file name or a section header object directly. The description omits critical details such as branching logic for specific SHN_* constants and machine/OSABI conditions, leading to a mismatch with the code's actual semantics. This makes the claim inaccurate as it does not correctly target the code's behavior.",
                "The summary states that the function retrieves a string representation of the ELF section based on the provided section header and file name, which is inaccurate. The source code shows it takes a Filedata pointer and a type value, returning specific strings or formatted values based on type and machine/OSABI conditions, not using a file name. While it loosely identifies the idea of returning a string related to ELF sections, it misses the primary purpose\u2019s specifics and omits critical details like handling predefined constants, machine-specific cases, formatting with sprintf, and bad section index handling.",
                "The summary is inaccurate because it misstates the primary purpose of the function. The source code returns a string representation of a section index type based on a numeric type value and ELF file header details, not based on a 'section header and file name.' This is a FATAL error affecting the primary purpose, with no accurate claims to offset the negative impact, resulting in unreliable guidance."
            ]
        }
    }
}
{
    "project_name": "grep",
    "function_addr": 38112,
    "strip_function_name": "sub_94E0",
    "strip_decompiled_code": "struct obstack **__fastcall sub_94E0(struct obstack *src, struct obstack *a2)\n{\n  struct obstack *v2; // r15\n  struct obstack *v3; // rbp\n  struct obstack *v4; // r12\n  char *v5; // rbx\n  size_t v6; // r13\n  char v7; // cl\n  struct obstack *v8; // rsi\n  __int64 v9; // rbx\n  struct obstack **result; // rax\n  char *v11; // [rsp+0h] [rbp-68h]\n  char v12; // [rsp+Fh] [rbp-59h]\n  _QWORD v14[9]; // [rsp+20h] [rbp-48h] BYREF\n\n  v2 = src;\n  v3 = 0LL;\n  v14[0] = 0LL;\n  v14[1] = __readfsqword(0x28u);\n  v4 = (struct obstack *)sub_BB00(1LL);\n  v11 = (char *)a2 + (_QWORD)src;\n  do\n  {\n    v5 = (char *)rawmemchr(v2, 10);\n    v6 = v5 - (char *)v2;\n    if ( byte_246CC5 )\n    {\n      v7 = byte_2467A0;\n      if ( v2 > src && byte_2467A0 == 10 )\n      {\n        v2 = (struct obstack *)((char *)v2 - 1);\n      }\n      else\n      {\n        if ( (__int64)(v6 + 1) >= v14[0] )\n        {\n          sub_14930(v3);\n          v14[0] = v5 - (char *)v2;\n          v3 = (struct obstack *)sub_2A3B0(0LL, v14, 2LL, -1LL, 1LL);\n          LOBYTE(v3->chunk_size) = byte_2467A0;\n          v7 = byte_2467A0;\n        }\n        v8 = v2;\n        v12 = v7;\n        v2 = v3;\n        memcpy((char *)&v3->chunk_size + 1, v8, v6);\n        *((_BYTE *)&v3->chunk_size + v6 + 1) = v12;\n      }\n      v6 += 2LL;\n    }\n    sub_AB00(v4, v2, v6);\n    v2 = (struct obstack *)(v5 + 1);\n  }\n  while ( v5 + 1 <= v11 );\n  sub_14930(v3);\n  v9 = sub_B040(v4);\n  sub_B050(v4);\n  result = (struct obstack **)sub_2A1C0(40LL);\n  *result = v4;\n  result[1] = (struct obstack *)v9;\n  result[2] = src;\n  result[4] = 0LL;\n  result[3] = a2;\n  return result;\n}\n",
    "function_name": "Fcompile",
    "decompiled_code": "void *__fastcall Fcompile(char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  char *v4; // r15\n  _BYTE *v5; // rbp\n  kwset *v6; // r12\n  char *v7; // rbx\n  size_t v8; // r13\n  char v9; // cl\n  char *v10; // rsi\n  idx_t v11; // rbx\n  void *result; // rax\n  char *retaddr; // [rsp+68h] [rbp+0h]\n  char v14; // [rsp+77h] [rbp+Fh]\n  idx_t v16; // [rsp+88h] [rbp+20h] BYREF\n  unsigned __int64 v17; // [rsp+90h] [rbp+28h]\n\n  v4 = pattern;\n  v5 = 0LL;\n  v16 = 0LL;\n  v17 = __readfsqword(0x28u);\n  v6 = kwsinit(1);\n  retaddr = &pattern[size];\n  do\n  {\n    v7 = (char *)rawmemchr(v4, 10);\n    v8 = v7 - v4;\n    if ( match_lines )\n    {\n      v9 = eolbyte[0];\n      if ( v4 > pattern && eolbyte[0] == 10 )\n      {\n        --v4;\n      }\n      else\n      {\n        if ( (__int64)(v8 + 1) >= v16 )\n        {\n          rpl_free(v5);\n          v16 = v7 - v4;\n          v5 = xpalloc(0LL, &v16, 2LL, -1LL, 1LL);\n          *v5 = eolbyte[0];\n          v9 = eolbyte[0];\n        }\n        v10 = v4;\n        v14 = v9;\n        v4 = v5;\n        memcpy(v5 + 1, v10, v8);\n        v5[v8 + 1] = v14;\n      }\n      v8 += 2LL;\n    }\n    kwsincr(v6, v4, v8);\n    v4 = v7 + 1;\n  }\n  while ( v7 + 1 <= retaddr );\n  rpl_free(v5);\n  v11 = kwswords(v6);\n  kwsprep(v6);\n  result = xmalloc(0x28uLL);\n  *(_QWORD *)result = v6;\n  *((_QWORD *)result + 1) = v11;\n  *((_QWORD *)result + 2) = pattern;\n  *((_QWORD *)result + 4) = 0LL;\n  *((_QWORD *)result + 3) = size;\n  return result;\n}\n",
    "source_code": "\nvoid *\nFcompile (char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  kwset_t kwset;\n  char *buf = NULL;\n  idx_t bufalloc = 0;\n\n  kwset = kwsinit (true);\n\n  char const *p = pattern;\n  do\n    {\n      char const *sep = rawmemchr (p, '\\n');\n      idx_t len = sep - p;\n\n      if (match_lines)\n        {\n          if (eolbyte == '\\n' && pattern < p)\n            p--;\n          else\n            {\n              if (bufalloc < len + 2)\n                {\n                  free (buf);\n                  bufalloc = len;\n                  buf = xpalloc (NULL, &bufalloc, 2, -1, 1);\n                  buf[0] = eolbyte;\n                }\n              memcpy (buf + 1, p, len);\n              buf[len + 1] = eolbyte;\n              p = buf;\n            }\n          len += 2;\n        }\n      kwsincr (kwset, p, len);\n\n      p = sep + 1;\n    }\n  while (p <= pattern + size);\n\n  free (buf);\n\n  idx_t words = kwswords (kwset);\n  kwsprep (kwset);\n\n  struct kwsearch *kwsearch = xmalloc (sizeof *kwsearch);\n  kwsearch->kwset = kwset;\n  kwsearch->words = words;\n  kwsearch->pattern = pattern;\n  kwsearch->size = size;\n  kwsearch->re = NULL;\n  return kwsearch;\n}",
    "comment": "Processes a pattern string, initializes a keyword set, and returns a structure containing the keyword set and its associated properties.",
    "hext5_sum": "| this will initialize various tables for pattern match and compiles some | | regexps. | '",
    "bint5_sum": "Concatenates two string buffers into a single output array , freeing the first string and returning the combined result .\n",
    "cpbcs_sum": "Appends a new word to a hash table of text, allocating memory and handling potential stack overflow based on the operation's parameter.\n",
    "misum_sum": "Constructs a formatted error message with a specified name and line number, formatting it as a string buffer with optional HTML and priority details.\n",
    "decom_sum": "Splits the source buffer into newline-delimited chunks, conditionally modifies line endings, aggregates them in an obstack, and returns a structured result.",
    "cfg_sum": "Processes a memory buffer line-by-line, conditionally modifies line endings, copies segments into a new buffer, and returns a structured result containing the processed data.",
    "work_score": {
        "hext5": {
            "summary": "| this will initialize various tables for pattern match and compiles some | | regexps. | '",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function initializes tables for pattern matching and compiles regexps. The source shows initialization of a keyword set, memory allocation, and preparation for keyword searching, which aligns loosely with initializing structures for pattern matching, so that part is safe. However, there is no regex compilation happening; the code operates on keyword sets and does not process regular expressions. Thus, only part of the summary is accurate, with less than half of the claims matching the source.",
                "The summary vaguely states that the function initializes tables for pattern matching and compiles regexps, but the source code shows it initializes a keyword set, processes newline-delimited patterns, handles match_lines logic with eolbyte, and prepares a kwsearch struct without compiling regexps. The primary purpose is keyword set compilation, not regex compilation, making the claim inaccurate. Missing all key secondary details.",
                "The summary claims that the function initializes tables for pattern matching and compiles regexps. While initializing structures for pattern matching is accurate, the source code does not compile regexps at all\u2014it uses a keyword set mechanism (kwset) for plain string matching. This is a FATAL inaccuracy targeting the primary purpose of the code, since it misidentifies the matching method. The accurate portion is generic and lacks detail, offering low gain."
            ]
        },
        "bint5": {
            "summary": "Concatenates two string buffers into a single output array , freeing the first string and returning the combined result .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function concatenates two string buffers, frees the first, and returns the combined result. In the source code, the function initializes a keyword set, processes patterns with possible buffer allocation and modification, and returns a kwsearch struct. There is no concatenation of two distinct string buffers, nor is a combined string returned. The described behavior contradicts the actual implementation, making all claims inaccurate.",
                "The summary's claim about concatenating two string buffers and freeing the first is unrelated to the actual function, which compiles a keyword set from a pattern, handles line matches, manages buffer allocation, and returns a structured search object. It misses the primary purpose and all secondary details such as handling eolbyte, looping over lines, and preparing the kwset, making the description inaccurate and non-representative of the source code.",
                "The summary claims the function concatenates two string buffers, frees the first, and returns the combined result. This is entirely inaccurate with respect to the source code, which initializes a keyword set, processes a pattern line-by-line, possibly prepending/appending eolbyte, and returns a kwsearch struct. The claim misidentifies the primary purpose and key I/O, making this a FATAL error with high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Appends a new word to a hash table of text, allocating memory and handling potential stack overflow based on the operation's parameter.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's main claim about appending a word to a hash table and handling stack overflow does not match the source code. The code builds a keyword set using `kwsincr`, manages dynamic memory buffers, and prepares a search structure, but there is no hash table involved and no stack overflow handling logic. This makes the claim inaccurate with respect to the code, resulting in no accurate matches.",
                "The summary incorrectly describes the function as appending a new word to a hash table and handling stack overflow, which does not reflect the source code. The source constructs a keyword set from a pattern string, processes line endings based on match_lines and eolbyte, allocates buffers dynamically, prepares the keyword set, and returns a kwsearch structure. The primary purpose is missed entirely, and none of the specific secondary details from the code are captured.",
                "The summary's claim about appending a word to a hash table and handling stack overflow does not align with the source code, which builds a keyword set using `kwsinit`, processes patterns, and allocates a buffer dynamically without any hash table or stack overflow handling. This is a FATAL error targeting the primary purpose, as it misrepresents the main functionality and data structures in the code."
            ]
        },
        "misum": {
            "summary": "Constructs a formatted error message with a specified name and line number, formatting it as a string buffer with optional HTML and priority details.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claim about constructing a formatted error message with name, line number, HTML, and priority details is completely unrelated to the source code, which implements pattern compilation into a keyword search structure. None of the claims match the implementation semantics, resulting in zero accurate claims.",
                "The summary describes constructing a formatted error message with name, line number, HTML, and priority options, which is entirely unrelated to the source code's actual purpose of compiling a pattern into a keyword search structure. None of the summary's claims align with the function's primary purpose or any secondary details, resulting in no coverage of the code semantics.",
                "The summary describes constructing a formatted error message with name, line number, HTML, and priority details, which is entirely unrelated to the actual source code that initializes a keyword set, processes patterns with newline separators, and prepares a search structure. This is pure NOISE with no accurate claims about the code, leading to no useful alignment and high negative impact due to irrelevance."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583015424,
    "strip_function_name": "sub_FFFFFFFF813FA200",
    "strip_decompiled_code": "__int64 sub_FFFFFFFF813FA200()\n{\n  __int64 v0; // rax\n  bool v1; // bl\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  __int64 result; // rax\n  _QWORD *v6; // r12\n  int v7; // edx\n  char *v8; // rbx\n  _UNKNOWN **v9; // rax\n\n  v0 = sub_FFFFFFFF817928D0(&unk_FFFFFFFF81EA423C);\n  if ( byte_FFFFFFFF81CB8EB8 )\n  {\n    v1 = (_WORD)dword_FFFFFFFF81EA4244 != 0 || dword_FFFFFFFF81EA4240 != HIWORD(dword_FFFFFFFF81EA4244);\n    byte_FFFFFFFF81CB8EB8 = !v1;\n    sub_FFFFFFFF81792660(&unk_FFFFFFFF81EA423C, v0);\n    result = 0LL;\n    if ( v1 )\n    {\n      v6 = 0LL;\n      v7 = 0;\n      v8 = (char *)off_FFFFFFFF81C66FC0 - 8;\n      if ( off_FFFFFFFF81C66FC0 != (_UNKNOWN *)&off_FFFFFFFF81C66FC0 )\n      {\n        do\n        {\n          if ( (v8[200] & 1) != 0 )\n          {\n            sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819C382C, *(_QWORD *)v8, v7, v2, v3, v4);\n            v7 = 1;\n          }\n          else if ( v7 )\n          {\n            v7 = 1;\n          }\n          else if ( v6 )\n          {\n            if ( *((_QWORD *)v8 + 17) > v6[17] )\n              v6 = v8;\n          }\n          else\n          {\n            v6 = v8;\n          }\n          v9 = (_UNKNOWN **)*((_QWORD *)v8 + 1);\n          v8 = (char *)(v9 - 1);\n        }\n        while ( v9 != &off_FFFFFFFF81C66FC0 );\n        if ( !v7 )\n        {\n          if ( v6 )\n            sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819E6C88, *v6, 0, v2, v3, v4);\n        }\n      }\n      return 1LL;\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF81792660(&unk_FFFFFFFF81EA423C, v0);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "pm_wakeup_pending",
    "decompiled_code": "__int64 __fastcall pm_wakeup_pending(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  bool v8; // bl\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  __int64 result; // rax\n  _QWORD *v12; // r12\n  __int64 v13; // rdx\n  char *v14; // rbx\n  _UNKNOWN **v15; // rax\n\n  raw_spin_lock_irqsave(events_lock);\n  if ( events_check_enabled )\n  {\n    v8 = (_WORD)combined_event_count != 0 || saved_count != HIWORD(combined_event_count);\n    events_check_enabled = !v8;\n    raw_spin_unlock_irqrestore(events_lock);\n    result = 0LL;\n    if ( v8 )\n    {\n      v12 = 0LL;\n      v13 = 0LL;\n      v14 = (char *)wakeup_sources - 8;\n      if ( wakeup_sources != (_UNKNOWN *)&wakeup_sources )\n      {\n        do\n        {\n          if ( (v14[200] & 1) != 0 )\n          {\n            printk((__int64)&unk_FFFFFFFF819C382C, a1, a2, a3, a4, v9, v10, a7, a8, *(_QWORD *)v14, v13);\n            v13 = 1LL;\n          }\n          else if ( (_DWORD)v13 )\n          {\n            v13 = 1LL;\n          }\n          else if ( v12 )\n          {\n            if ( *((_QWORD *)v14 + 17) > v12[17] )\n              v12 = v14;\n          }\n          else\n          {\n            v12 = v14;\n          }\n          v15 = (_UNKNOWN **)*((_QWORD *)v14 + 1);\n          v14 = (char *)(v15 - 1);\n        }\n        while ( v15 != &wakeup_sources );\n        if ( !(_DWORD)v13 )\n        {\n          if ( v12 )\n            printk((__int64)&unk_FFFFFFFF819E6C88, a1, a2, a3, a4, v9, v10, a7, a8, *v12);\n        }\n      }\n      return 1LL;\n    }\n  }\n  else\n  {\n    raw_spin_unlock_irqrestore(events_lock);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "bool pm_wakeup_pending(void)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&events_lock, flags);\n\tif (events_check_enabled) {\n\t\tunsigned int cnt, inpr;\n\n\t\tsplit_counters(&cnt, &inpr);\n\t\tret = (cnt != saved_count || inpr > 0);\n\t\tevents_check_enabled = !ret;\n\t}\n\tspin_unlock_irqrestore(&events_lock, flags);\n\n\tif (ret)\n\t\tprint_active_wakeup_sources();\n\n\treturn ret;\n}",
    "comment": "Checks if a wakeup event is pending by comparing counters and prints active wakeup sources if there is a pending event.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "The function checks and updates the power save state of devices that are busy , returning an error if any device is busy .\n",
    "cpbcs_sum": "Flushes the deferred flush command by writing the status to the event list if the offset is active and the current thread.\n",
    "misum_sum": "Checks if the system core is busy and updates the last CPU's mode signal based on the current mode and reference counts.\n",
    "decom_sum": "Checks a status flag, iterates over a linked list of entries, and triggers an update callback for active or most recent inactive entry.",
    "cfg_sum": "Updates a global state flag, iterates through a linked list of entries, and triggers actions based on entry flags or highest-priority timestamp.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague and unrelated statement about pushing a pointer type, which does not correspond to any specific functionality or details in the source code. It fails to describe the purpose or logic of the pm_wakeup_pending function, making all extracted claims inaccurate.",
                "The summary 'push a pointer type.' is unrelated to the actual source code, which implements pm_wakeup_pending to check for pending wakeup events using spinlocks, counters, and printing wakeup sources. The summary misses the primary purpose, does not describe any observable behavior, inputs, outputs, or secondary details, and is completely off-topic.",
                "The summary contains no fact-based claims related to the source code's semantics, purpose, or behavior. Instead, it presents unrelated and vague text ('push a pointer type'), which is pure NOISE and provides zero useful insight. There are no ACCURATE claims to create positive gain, and the content is completely disconnected from the actual function implementation."
            ]
        },
        "bint5": {
            "summary": "The function checks and updates the power save state of devices that are busy , returning an error if any device is busy .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function checks and updates the power save state of busy devices and returns an error if any device is busy. In reality, the source code checks for pending wakeup events based on counters, updates an internal flag, and returns a boolean, not an error code. The device 'busy' description and 'error' return are inaccurate, leaving no factual alignment with the code.",
                "The summary incorrectly states that the function checks and updates the power save state of devices and returns an error if busy, which contradicts the source code. The actual implementation checks for pending wakeup events using counters, updates a flag, optionally prints active wakeup sources, and returns a boolean, not an error. This misses the primary purpose and all key secondary details, making the claim inaccurate.",
                "The summary claims the function checks and updates the power save state of busy devices and returns an error if any device is busy. This is inaccurate: the source code checks wakeup events, not a generic 'power save state', and returns a boolean, not an error. This is a FATAL error affecting the primary purpose and key I/O, making the description misleading and unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Flushes the deferred flush command by writing the status to the event list if the offset is active and the current thread.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes flushing a deferred flush command and writing status to an event list, which is unrelated to the source code\u2019s actual function. The source implements pm_wakeup_pending, checking event counts against saved values under a spin lock, updating a flag, and possibly printing wakeup sources. None of the claims align with this behavior, resulting in no accurate matches.",
                "The summary is entirely inaccurate, describing unrelated behavior about flushing commands, writing status, and thread offsets which do not align with the function's actual purpose of checking for pending wakeup events using counters and a lock. It fails to capture the primary purpose or any secondary details from the source code.",
                "The summary's claim about flushing a deferred flush command, writing status to an event list, and checking offset/current thread is completely unrelated to the source code, which actually checks pending wakeup events using counters and locks and may print active wakeup sources. This is pure NOISE with no accurate alignment to the code semantics, providing no useful insight."
            ]
        },
        "misum": {
            "summary": "Checks if the system core is busy and updates the last CPU's mode signal based on the current mode and reference counts.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function checks if the system core is busy and updates the last CPU's mode signal based on current mode and reference counts. The source code actually checks for pending wakeups using event counters, toggles a flag, and prints active wakeup sources, with no mention of system core busy state, CPU mode signals, or mode/reference counts. All claims are inaccurate, resulting in no alignment with the source.",
                "The summary does not align with the source code's primary purpose. The function checks for pending wakeup events by comparing event counters, updates a flag, and optionally prints active wakeup sources, but there is no indication it monitors CPU mode signals or system core activity. This mismatch means the main purpose is missed, and no secondary details are captured.",
                "The summary's claim that the function checks if the system core is busy and updates a CPU mode signal does not match the source implementation. The code actually checks for pending wakeup events by comparing counters, updates a flag to disable further checks if a wakeup is pending, and prints active wakeup sources. The described CPU mode signal behavior is not present, making this a FATAL inaccuracy about the primary purpose. There are no accurate claims to provide value, resulting in high negative impact."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4331184,
    "strip_function_name": "sub_4216B0",
    "strip_decompiled_code": "char *__fastcall sub_4216B0(const char *a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  char *v7; // rax\n  char *chunk_limit; // rcx\n  char *object_base; // r13\n  char *v10; // rdi\n  char *v11; // rsi\n  char v12; // dl\n  __int64 v13; // rdi\n  char *v15; // [rsp+8h] [rbp-30h]\n\n  ++qword_7E5280;\n  v7 = sub_421280(a1);\n  chunk_limit = stru_7EA840.chunk_limit;\n  if ( (char *)(stru_7EA840.chunk_limit - stru_7EA840.next_free) <= (char *)0x27 )\n  {\n    v15 = v7;\n    obstack_newchunk(&stru_7EA840, 40LL);\n    object_base = stru_7EA840.object_base;\n    chunk_limit = stru_7EA840.chunk_limit;\n    v7 = v15;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  else\n  {\n    object_base = stru_7EA840.object_base;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  *((_BYTE *)&stru_7EA840 + 80) |= 2u;\nLABEL_3:\n  v11 = (char *)(~*(_QWORD *)&stru_7EA840.alignment_mask & (unsigned __int64)&v10[*(_QWORD *)&stru_7EA840.alignment_mask]);\n  stru_7EA840.next_free = v11;\n  if ( (char *)(v11 - (char *)stru_7EA840.chunk) > (char *)(chunk_limit - (char *)stru_7EA840.chunk) )\n  {\n    stru_7EA840.next_free = chunk_limit;\n    v11 = chunk_limit;\n  }\n  v12 = *object_base;\n  v13 = qword_7E5288;\n  stru_7EA840.object_base = v11;\n  *((_QWORD *)object_base + 3) = a4;\n  *((_QWORD *)object_base + 1) = a2;\n  *((_QWORD *)object_base + 4) = a3;\n  *((_QWORD *)object_base + 2) = v7;\n  *object_base = v12 & 0xFA | 1;\n  sub_411620(v13, v7, (__int64)object_base);\n  return object_base;\n}\n",
    "function_name": "local_symbol_make",
    "decompiled_code": "local_symbol *__fastcall local_symbol_make(const char *name, __int64 a2, __int64 a3, __int64 a4)\n{\n  char *v7; // rax\n  char *chunk_limit; // rcx\n  char *object_base; // r13\n  char *v10; // rdi\n  char *v11; // rsi\n  char v12; // dl\n  hash_control *v13; // rdi\n  char *v15; // [rsp+8h] [rbp-30h]\n\n  ++local_symbol_count;\n  v7 = save_symbol_name(name);\n  chunk_limit = notes.chunk_limit;\n  if ( (char *)(notes.chunk_limit - notes.next_free) <= (char *)0x27 )\n  {\n    v15 = v7;\n    obstack_newchunk((__int64)&notes, 0x28uLL);\n    object_base = notes.object_base;\n    chunk_limit = notes.chunk_limit;\n    v7 = v15;\n    v10 = notes.next_free + 40;\n    if ( notes.next_free + 40 != notes.object_base )\n      goto LABEL_3;\n  }\n  else\n  {\n    object_base = notes.object_base;\n    v10 = notes.next_free + 40;\n    if ( notes.next_free + 40 != notes.object_base )\n      goto LABEL_3;\n  }\n  *((_BYTE *)&notes + 80) |= 2u;\nLABEL_3:\n  v11 = (char *)(~notes.alignment_mask & (unsigned __int64)&v10[notes.alignment_mask]);\n  notes.next_free = v11;\n  if ( (char *)(v11 - (char *)notes.chunk) > (char *)(chunk_limit - (char *)notes.chunk) )\n  {\n    notes.next_free = chunk_limit;\n    v11 = chunk_limit;\n  }\n  v12 = *object_base;\n  v13 = local_hash;\n  notes.object_base = v11;\n  *((_QWORD *)object_base + 3) = a4;\n  *((_QWORD *)object_base + 1) = a2;\n  *((_QWORD *)object_base + 4) = a3;\n  *((_QWORD *)object_base + 2) = v7;\n  *object_base = v12 & 0xFA | 1;\n  hash_jam((__int64)v13, v7, object_base);\n  return (local_symbol *)object_base;\n}\n",
    "source_code": "\nstruct local_symbol *\nlocal_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n{\n  const char *name_copy;\n  struct local_symbol *ret;\n\n  ++local_symbol_count;\n\n  name_copy = save_symbol_name (name);\n\n  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n  ret->lsy_flags.sy_local_symbol = 1;\n  ret->lsy_flags.sy_resolved = 0;\n  ret->lsy_name = name_copy;\n  ret->lsy_section = section;\n  local_symbol_set_frag (ret, frag);\n  ret->lsy_value = val;\n\n  hash_jam (local_hash, name_copy, (void *) ret);\n\n  return ret;\n}",
    "comment": "Creates and initializes a local symbol structure, copying its name, setting properties, and storing it in a hash table.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Adds a symbol name to a memory chunk , allocating memory if necessary , and ensuring it does not exceed the maximum chunk size .\n",
    "cpbcs_sum": "Appends a new field operation to a structured header field if the symbol class is greater than one otherwise returns a cloning pointer.\n",
    "misum_sum": "Appends a new normal extension to a linked list of text, initializing its properties and managing memory appropriately.\n",
    "decom_sum": "Allocates or expands an obstack chunk, populates a structured object with provided parameters, updates allocation pointers, and registers the object in a global context.",
    "cfg_sum": "Allocates or reuses an aligned memory chunk, stores provided parameters into it, updates allocation metadata, and marks the chunk as active.",
    "work_score": {
        "hext5": {
            "summary": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
            "score": [
                0.1,
                0.0,
                0.4
            ],
            "reason": [
                "The summary describes handling of input files, deduplication of BFD objects, and prefixing with -l, which are unrelated to the source code. The source implements creation of a local symbol structure and initialization of its fields. None of the summary's claims align with this functionality, resulting in almost no accurate correspondence.",
                "The summary describes handling of input files, duplication checks, and symbol processing, which is unrelated to the source code function. The source code's primary purpose is creating and initializing a local_symbol structure with given parameters, setting its flags, allocating memory, copying the name, setting the section and fragment, and adding it to a hash table. None of these details are reflected in the summary, and there is no mention of the function's actual purpose or behavior. This results in a complete mismatch, with no accurate claims or coverage.",
                "The summary's claims about building an input file node, handling multiple requests, and preventing bfd duplication are unrelated to the source code, which instead allocates and initializes a local symbol struct (setting flags, name, section, value, and adding to a hash). All claims are NOISE, with no FATAL errors about primary purpose. Since there are no accurate insights related to the actual implementation, the net benefit is very low."
            ]
        },
        "bint5": {
            "summary": "Adds a symbol name to a memory chunk , allocating memory if necessary , and ensuring it does not exceed the maximum chunk size .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes functionality related to chunk size limits and conditional allocation, which are not present in the source code. The source creates and initializes a local_symbol struct, copies the name, allocates memory via obstack, sets flags and values, associates a fragment, and stores it in a hash. No mention is made of maximum chunk size checks or conditional allocation as stated. Therefore, none of the claims accurately match the code's semantics.",
                "The summary describes adding a symbol name to a memory chunk with constraints on maximum chunk size, which contradicts the actual code that allocates a local_symbol structure, sets fields like flags, section, value, and frag, and inserts it into a hash table. It misses the primary purpose of creating and initializing a local symbol entry and does not mention key steps such as saving the symbol name, updating the count, or inserting into the hash. The focus on a 'maximum chunk size' and conditional allocation is inaccurate relative to the source.",
                "The summary introduces an inaccurate claim about ensuring the symbol name does not exceed a maximum chunk size, which is not implemented in the source code. It also implies conditional memory allocation 'if necessary', but in the code memory is always allocated via obstack_alloc without such a check. While it loosely mentions adding a symbol name to memory, which is broadly correct, the core description of size checking and allocation conditions is incorrect. This constitutes a FATAL error about the function\u2019s primary behavior, reducing trust in the summary."
            ]
        },
        "cpbcs": {
            "summary": "Appends a new field operation to a structured header field if the symbol class is greater than one otherwise returns a cloning pointer.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about appending a new field operation to a header field and returning a cloning pointer do not match the source code, which creates and initializes a local_symbol structure, sets flags, copies the name, assigns section and value, and stores it in a hash. None of the described operations in the summary align with the implementation details, resulting in no accurate claims.",
                "The summary's claims about appending a field operation to a header field and conditional behavior based on symbol class are entirely unrelated to the source code, which creates and initializes a local_symbol struct, sets flags, stores it in a hash, and returns it. The primary purpose is missed, and none of the actual steps or secondary details from the source are reflected, making all claims inaccurate.",
                "The summary's claims are entirely inaccurate. The source code creates and initializes a local_symbol struct, increments a counter, copies a name, assigns fields, sets a fragment, stores the value, and inserts into a hash. The summary mentions appending to a structured header and conditional cloning based on symbol class, which are unrelated to the actual implementation. This is a FATAL error targeting the primary purpose and I/O incorrectly, resulting in high negative impact with no accurate claims present."
            ]
        },
        "misum": {
            "summary": "Appends a new normal extension to a linked list of text, initializing its properties and managing memory appropriately.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim that the function appends a new normal extension to a linked list of text does not match the source code, which creates and initializes a local_symbol structure, sets flags, copies the name, assigns section and value, and stores it in a hash. The summary misrepresents both the purpose and behavior, yielding 0% accurate claims.",
                "The summary fails to capture the primary purpose of the function, which is to create and initialize a local_symbol structure with name, section, value, frag, flags, and add it to a hash. Instead, it inaccurately describes appending a normal extension to a linked list of text, which is unrelated to the source code semantics. No accurate claims are present to cover the function's behavior.",
                "The summary describes appending an extension to a linked list of text, which does not match the source code's actual behavior of creating and initializing a local_symbol structure, storing it in a hash, and setting its properties. This is a semantic contradiction affecting the primary purpose, making it a FATAL error with high negative impact and no accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586119824,
    "strip_function_name": "sub_FFFFFFFF816F0090",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816F0090(\n        __int64 a1,\n        void (__fastcall *a2)(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10),\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r12\n  __int64 v11; // r14\n  __int64 v12; // r15\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 v15; // rax\n  unsigned __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = *(_QWORD *)(a1 + 568);\n  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL);\n  v12 = v10 + 32;\n  while ( 1 )\n  {\n    sub_FFFFFFFF81792900(v10 + 200);\n    v15 = *(_QWORD *)(v10 + 32);\n    v16 = v15 - 56;\n    if ( v12 == v15 )\n      break;\n    while ( *(_QWORD *)(v15 - 48) != v16 + 8 )\n    {\n      v15 = *(_QWORD *)(v16 + 56);\n      v16 = v15 - 56;\n      if ( v12 == v15 )\n        goto LABEL_7;\n    }\n    *(_DWORD *)(v16 + 48) = -32;\n    _InterlockedIncrement((volatile signed __int32 *)v16);\n    sub_FFFFFFFF816EE8D0(v16, a3, a4, a5, a6, v13, v14, a9, a10);\n    ++*(_BYTE *)(v10 + 200);\n    sub_FFFFFFFF816EF9B0(v16, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n  }\nLABEL_7:\n  ++*(_BYTE *)(v10 + 200);\n  return sub_FFFFFFFF816EF2F0(v11);\n}\n",
    "function_name": "gss_pipe_release",
    "decompiled_code": "__int64 __fastcall gss_pipe_release(\n        __int64 a1,\n        void (__fastcall *a2)(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, int a13, int a14),\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r12\n  __int64 v11; // r14\n  __int64 v12; // r15\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 v15; // rax\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = *(_QWORD *)(a1 + 568);\n  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 848LL);\n  v12 = v10 + 32;\n  while ( 1 )\n  {\n    raw_spin_lock((volatile signed __int16 *)(v10 + 200));\n    v15 = *(_QWORD *)(v10 + 32);\n    v16 = v15 - 56;\n    if ( v12 == v15 )\n      break;\n    while ( *(_QWORD *)(v15 - 48) != v16 + 8 )\n    {\n      v15 = *(_QWORD *)(v16 + 56);\n      v16 = v15 - 56;\n      if ( v12 == v15 )\n        goto LABEL_7;\n    }\n    *(_DWORD *)(v16 + 48) = -32;\n    _InterlockedIncrement((volatile signed __int32 *)v16);\n    _gss_unhash_msg(v16, a3, a4, a5, a6, v13, v14, a9, a10);\n    ++*(_BYTE *)(v10 + 200);\n    gss_release_msg((__int64 *)v16, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n  }\nLABEL_7:\n  ++*(_BYTE *)(v10 + 200);\n  return put_pipe_version(v11);\n}\n",
    "source_code": "\nstatic void\ngss_pipe_release(struct inode *inode)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tstruct gss_upcall_msg *gss_msg;\n\nrestart:\n\tspin_lock(&pipe->lock);\n\tlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\n\n\t\tif (!list_empty(&gss_msg->msg.list))\n\t\t\tcontinue;\n\t\tgss_msg->msg.errno = -EPIPE;\n\t\tatomic_inc(&gss_msg->count);\n\t\t__gss_unhash_msg(gss_msg);\n\t\tspin_unlock(&pipe->lock);\n\t\tgss_release_msg(gss_msg);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&pipe->lock);\n\n\tput_pipe_version(net);\n}",
    "comment": "Releases GSS upcall messages in a pipe by unhashing and incrementing the error count for empty message lists before freeing resources.",
    "hext5_sum": "returns the maximum of all the values returned by handle_file, or exit_trouble if trouble is encountered in opening files. compare the contents of two directories named in cmp. this is a top-level routine; it does everything necessary for diff on two directories. cmp->file[0].desc == -1 says directory cmp->file[0] doesn't exist, but pretend it is empty. likewise for cmp->file[1]. handle_file is a caller-provided subroutine called to handle each file. it gets three operands: cmp, name of file in dir 0, name of file in dir 1. these names are relative to the original working directory. for a file that appears in",
    "bint5_sum": "Releases resources and cleans up a GSS message , ensuring no pending requests are processed before freeing associated memory .\n",
    "cpbcs_sum": "Releases the RPC client associated with a task, removing it from the client's task list and freeing the client memory.\n",
    "misum_sum": "Releases resources associated with an RPC client by iterating through the RPC client and invoking the appropriate protocol's function.\n",
    "decom_sum": "Iterates through a linked list of objects, updates their state with provided parameters, invokes two processing callbacks, and finally returns a computed result.",
    "cfg_sum": "Iterates through linked memory nodes, validates references, updates status and counters, processes each node via callbacks, then finalizes with a cleanup routine.",
    "work_score": {
        "hext5": {
            "summary": "returns the maximum of all the values returned by handle_file, or exit_trouble if trouble is encountered in opening files. compare the contents of two directories named in cmp. this is a top-level routine; it does everything necessary for diff on two directories. cmp->file[0].desc == -1 says directory cmp->file[0] doesn't exist, but pretend it is empty. likewise for cmp->file[1]. handle_file is a caller-provided subroutine called to handle each file. it gets three operands: cmp, name of file in dir 0, name of file in dir 1. these names are relative to the original working directory. for a file that appears in",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "All claims in the summary describe behavior involving functions like handle_file, cmp structure, and directory comparisons, which are unrelated to the gss_pipe_release function in the source code. None of the claims correspond to the locking, list traversal, gss_upcall_msg handling, or pipe version release seen in the code, making them entirely inaccurate.",
                "The summary describes behavior related to comparing directories and handling files via a caller-provided subroutine, which is entirely unrelated to the source code. The source implements gss_pipe_release to release queued upcall messages, manage locking, set error codes, and update pipe version, none of which are reflected in the summary. The summary fails to capture the primary purpose or any secondary details from the source, making all claims inaccurate.",
                "The summary contains multiple detailed claims about directory comparison, file handling via handle_file, handling of missing directories, and diff operations, none of which match the provided source code that manages GSS pipe release, locking, and message cleanup. All claims are NOISE and unrelated to the code's semantics, resulting in overwhelming irrelevance with no accurate content. The worst failure mode is excessive NOISE leading to no usable insight."
            ]
        },
        "bint5": {
            "summary": "Releases resources and cleans up a GSS message , ensuring no pending requests are processed before freeing associated memory .\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly conveys that the function releases resources related to GSS messages and handles cleanup before freeing memory, which aligns with the code's use of gss_release_msg and cleaning up messages with no pending requests. However, it omits other specific operations like setting errno, incrementing the count, unhashing messages, and calling put_pipe_version. Despite these omissions, the core description is accurate, covering more than 80% of the main semantics.",
                "The summary captures the primary purpose of releasing GSS messages and freeing resources, which aligns with the general behavior of the function. However, it omits key secondary details from the source code such as setting the errno to -EPIPE, incrementing the message count, unhashing the message, the specific loop handling empty message lists, and the final call to put_pipe_version. These omissions reduce completeness despite the core purpose being correct.",
                "The summary claims the function releases resources and cleans up a GSS message, which is broadly accurate as it iterates through pending `gss_upcall_msg` structures, sets errors, and releases them. However, the phrase 'ensuring no pending requests are processed before freeing associated memory' is overly generic and slightly misleading: the code processes messages with empty internal lists, not simply based on 'pending request' state, and freeing memory is not explicitly shown but implied via `gss_release_msg`. The claim is SAFE but low-info, lacking specific details like the loop with restart or error setting, resulting in low net benefit."
            ]
        },
        "cpbcs": {
            "summary": "Releases the RPC client associated with a task, removing it from the client's task list and freeing the client memory.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function releases an RPC client tied to a task, removes it from a client's task list, and frees client memory. However, the source code shows `gss_pipe_release` handling release of gss upcall messages from an RPC pipe, setting errors, unhashing, and releasing messages, then updating the pipe version. There is no mention of a task, client task list, or freeing client memory, making all claims inaccurate relative to the implementation.",
                "The summary describes releasing an RPC client tied to a task, removing it from a task list, and freeing memory. This does not match the source code, which iterates over gss_upcall_msg entries in a pipe, marks them with -EPIPE, unhashes and releases them, and updates pipe version info. The primary purpose in the code is handling and releasing upcall messages in a pipe, not RPC client removal, resulting in complete semantic mismatch.",
                "The summary claims that the function releases an RPC client for a task, removes it from the client's task list, and frees client memory. None of these actions are present in the source code. The function actually processes pending GSS upcall messages in a pipe, sets error codes, unhashes and releases messages, and updates pipe version information. These are contradictory to the stated primary purpose, representing a FATAL error targeting the key semantics, thus greatly reducing reliability."
            ]
        },
        "misum": {
            "summary": "Releases resources associated with an RPC client by iterating through the RPC client and invoking the appropriate protocol's function.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as releasing resources associated with an RPC client and invoking a protocol-specific function. The source code shows it iterates through downcall messages in an RPC pipe, updates their error state, unhashes and releases them, then decrements pipe version for the network namespace. This contradicts the summary\u2019s focus on an RPC client and protocol a function, resulting in no accurate claims.",
                "The summary incorrectly describes releasing resources for an RPC client via protocol-specific functions, which does not match the source code's actual behavior of iterating through gss_upcall_msg structures in a pipe, setting an error (-EPIPE), unhashing, and releasing them with locking before updating the pipe version. The primary purpose and key details from the code are missed entirely, making the description inaccurate and non-aligned with the source logic.",
                "The summary inaccurately describes the function as releasing resources for an RPC client and invoking a protocol-specific function, which contradicts the code\u2019s actual behavior. The code iterates through gss_upcall_msg structures in a pipe\u2019s in_downcall list, marks them with an error, increments a count, unhashes and releases them, and finally calls put_pipe_version. There is no iteration over an RPC client or a protocol-specific invocation. This is a FATAL error impacting the primary purpose of the function, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6106942,
    "strip_function_name": "sub_5D2F3E",
    "strip_decompiled_code": "__int64 *__fastcall sub_5D2F3E(\n        __int64 a1,\n        __int64 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  const __m128i *v10; // r13\n  __int64 v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // rax\n  __int64 v15; // r12\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rsi\n  __int64 v20; // rcx\n  __m128i *v21; // rax\n  __int64 *result; // rax\n\n  v10 = (const __m128i *)a2;\n  if ( !a2 )\n    v10 = (const __m128i *)&unk_67933B;\n  LODWORD(v11) = sub_455F70(v10);\n  v14 = sub_51812F((const char *)(v11 + 32), a2, a3, a4, a5, a6, v12, v13, a9, a10);\n  v15 = *(_QWORD *)(a1 + 8);\n  v16 = v14;\n  *(_QWORD *)v14 = v15;\n  *(_QWORD *)(v14 + 8) = *(_QWORD *)a1;\n  *(_BYTE *)(v14 + 24) = (*(_DWORD *)(a1 + 24) & 0xF000) == 0x4000;\n  sub_400520(v14 + 25, v10);\n  v19 = qword_899E98;\n  LODWORD(v20) = v15;\n  if ( !qword_899E98 )\n  {\n    v21 = sub_51816D((const char *)0x9B8, 0LL, a3, a4, a5, a6, v17, v18, a9, a10);\n    v20 = *(_QWORD *)(a1 + 8);\n    qword_899E98 = (__int64)v21;\n    v19 = (__int64)v21;\n  }\n  result = (__int64 *)(v19 + 8LL * ((unsigned int)v20 % 0x137));\n  *(_QWORD *)(v16 + 16) = *result;\n  *result = v16;\n  return result;\n}\n",
    "function_name": "add_to_ino_dev_hashtable",
    "decompiled_code": "__int64 *__fastcall add_to_ino_dev_hashtable(\n        __int64 a1,\n        __int64 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  const __m128i *v10; // r13\n  __int64 v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  __int64 v15; // rax\n  __int64 v16; // rbx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rsi\n  __int64 v20; // rcx\n  __m128i *v21; // rax\n  __int64 *result; // rax\n\n  v10 = (const __m128i *)a2;\n  if ( !a2 )\n    v10 = (const __m128i *)&byte_67933B;\n  LODWORD(v11) = strlen(v10);\n  xmalloc(v11 + 32, a2, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = *(_QWORD *)(a1 + 8);\n  v16 = v15;\n  *(_QWORD *)v15 = v14;\n  *(_QWORD *)(v15 + 8) = *(_QWORD *)a1;\n  *(_BYTE *)(v15 + 24) = (*(_DWORD *)(a1 + 24) & 0xF000) == 0x4000;\n  strcpy((char *)(v15 + 25), v10->m128i_i8);\n  v19 = ino_dev_hashtable;\n  LODWORD(v20) = v14;\n  if ( !ino_dev_hashtable )\n  {\n    v21 = xzalloc(0x9B8uLL, 0LL, a3, a4, a5, a6, v17, v18, a9, a10);\n    v20 = *(_QWORD *)(a1 + 8);\n    ino_dev_hashtable = (__int64)v21;\n    v19 = (__int64)v21;\n  }\n  result = (__int64 *)(v19 + 8LL * ((unsigned int)v20 % 0x137));\n  *(_QWORD *)(v16 + 16) = *result;\n  *result = v16;\n  return result;\n}\n",
    "source_code": "void FAST_FUNC add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name)\n{\n\tint i;\n\tino_dev_hashtable_bucket_t *bucket;\n\n\tif (!name)\n\t\tname = \"\";\n\tbucket = xmalloc(sizeof(ino_dev_hashtable_bucket_t) + strlen(name));\n\tbucket->ino = statbuf->st_ino;\n\tbucket->dev = statbuf->st_dev;\n\tbucket->isdir = !!S_ISDIR(statbuf->st_mode);\n\tstrcpy(bucket->name, name);\n\n\tif (!ino_dev_hashtable)\n\t\tino_dev_hashtable = xzalloc(HASH_SIZE * sizeof(*ino_dev_hashtable));\n\n\ti = hash_inode(statbuf->st_ino);\n\tbucket->next = ino_dev_hashtable[i];\n\tino_dev_hashtable[i] = bucket;\n}",
    "comment": "Adds a new entry to the inode-device hashtable using the provided stat structure and name, allocating memory for the bucket dynamically.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Creates and initializes a new ` grecs_txtacc ` structure , setting its properties and linking it to a specified file or standard output .\n",
    "cpbcs_sum": "Adds a new file to the server list after validating the old and duplicating the new file path.\n",
    "misum_sum": "Adds a new file to the global log list and updates the corresponding variable in the structured data structure.\n",
    "decom_sum": "Initializes a new data entry from given parameters and inserts it into a global hash table keyed by an identifier from the input structure.",
    "cfg_sum": "Creates and links a new structured node using input parameters, initializes defaults if needed, and inserts it into a global indexed hash table.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a single vague claim about 'push a pointer type' which does not correspond to or accurately describe any specific functionality in the provided source code. The source code deals with allocating a bucket structure, setting its fields from a stat buffer, and inserting it into a hash table. The claim is unrelated to these operations, making it inaccurate and yielding 0% accurate coverage.",
                "The summary 'push a pointer type' is vague, does not mention the primary purpose of adding an entry to the ino_dev_hashtable, and ignores all critical semantic details such as handling null names, memory allocation, storing inode and device numbers, determining if it's a directory, and hashing logic. It is not factually aligned with the source code and fails to capture any meaningful aspect of its behavior.",
                "The summary contains a single vague claim that does not target any specific aspect of the source code's semantics or behavior. It fails to mention the function's purpose, parameters, operations, or data structures, and instead introduces unrelated terminology ('push a pointer type'), making it NOISE. With no accurate or detailed claims, there is no positive gain."
            ]
        },
        "bint5": {
            "summary": "Creates and initializes a new ` grecs_txtacc ` structure , setting its properties and linking it to a specified file or standard output .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes creating and initializing a `grecs_txtacc` structure and linking it to a file or standard output, which is completely unrelated to the source code. The source code deals with adding an entry to an inode/device hash table using `struct stat` data, memory allocation, and bucket insertion logic. None of the claims match the source code's semantics, making the proportion of accurate claims 0%.",
                "The summary describes creating and initializing a `grecs_txtacc` structure linked to a file or stdout, which is entirely unrelated to the actual function. The source code adds an inode/device entry into a hashtable using `struct stat` data, allocates memory, sets fields, and handles hashing. The PRIMARY PURPOSE and all secondary details are missed, and the claim is inaccurate since it does not reflect the source code\u2019s semantics.",
                "The summary is entirely inaccurate and describes creating and initializing a `grecs_txtacc` structure linked to a file or standard output, which does not match the source code at all. The actual implementation adds an entry to an inode/device hash table based on a stat structure and a name string. This is a FATAL error affecting the primary purpose of the function, making the response unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Adds a new file to the server list after validating the old and duplicating the new file path.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a new file to a server list after validating and duplicating a file path, which contradicts the source code. The source actually allocates a bucket, stores inode, device, directory flag, and name, initializes a hashtable if needed, and chains the bucket into the correct list based on the inode hash. There is no server list, validation of the old file, or duplication of a file path. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary incorrectly describes adding a file to a server list with validation and duplication of a file path, which does not match the source code's actual purpose of inserting a bucket containing inode, device, directory flag, and name into an inode-device hashtable. This contradicts the code semantics, missing the primary purpose and all secondary details such as handling null name, allocation, hashing, and linking.",
                "The summary is completely inaccurate: it describes adding a file to a 'server list' and validating/duplicating file paths, none of which occur in the source code. The code actually allocates and populates a hashtable bucket with inode, device, directory flag, and name data from a stat buffer, and adds it to a hashed list. This is a FATAL mismatch on the primary purpose, making the response unreliable."
            ]
        },
        "misum": {
            "summary": "Adds a new file to the global log list and updates the corresponding variable in the structured data structure.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a new file to a global log list and updates a variable in a structured data structure, which does not align with the source code. The source function instead allocates and inserts a bucket containing inode, device, directory flag, and name into a hash table keyed by inode, with no concept of a global log list or logging mechanism. Both claims in the summary are inaccurate as they misrepresent the data structures and purpose of the function.",
                "The summary inaccurately describes the function's purpose, claiming it adds a file to a global log list and updates a variable in a structured data structure. In reality, the code adds a bucket containing inode, device, directory flag, and name to a global inode-device hashtable. The mismatched terminology ('log list' vs. hashtable) and omission of specific details like memory allocation, handling NULL names, and hashing logic mean the primary purpose is misrepresented and no secondary details are correctly captured.",
                "The summary claims the function adds a new file to a global log list, which contradicts the source code's actual purpose of adding an entry to an inode-device hashtable. This is a FATAL inaccuracy affecting the primary purpose and key data structures. There are no accurate, specific insights provided, resulting in high negative impact and no net benefit."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5933504,
    "strip_function_name": "sub_5A89C0",
    "strip_decompiled_code": "__int64 __fastcall sub_5A89C0(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v10; // rax\n  _BYTE *v11; // r12\n  unsigned int v12; // r13d\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 v19; // rbx\n  __int64 v20; // rbp\n  __int16 v21; // ax\n  char v23[2]; // [rsp+0h] [rbp-138h] BYREF\n  __int16 v24; // [rsp+2h] [rbp-136h]\n  _WORD v25[148]; // [rsp+10h] [rbp-128h] BYREF\n\n  v10 = sub_51812F((const char *)0x100, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  if ( *(_QWORD *)(a10 + 8) )\n    sub_516747(256LL, a10);\n  v11 = (_BYTE *)v10;\n  v12 = sub_5D081B(*(double *)a1.m128_u64);\n  sub_5D9D86(0LL, v11, 7LL);\n  if ( !sub_5170F0(v11, \"bkeymap\") )\n    sub_51797B(\n      \"not a valid binary keymap\",\n      (__int64)\"bkeymap\",\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8,\n      v23[0]);\n  v19 = 0LL;\n  sub_5D9D86(0LL, v11, 256LL);\n  do\n  {\n    if ( v11[v19] == 1 )\n    {\n      v20 = 0LL;\n      sub_5D9D86(0LL, v25, 256LL);\n      do\n      {\n        v21 = v25[v20];\n        v23[1] = v20++;\n        v23[0] = v19;\n        v24 = v21;\n        sub_4AF0E0(v12, 0x4B47u, (unsigned __int64)v23);\n      }\n      while ( v20 != 128 );\n    }\n    ++v19;\n  }\n  while ( v19 != 256 );\n  return 0LL;\n}\n",
    "function_name": "loadkmap_main",
    "decompiled_code": "__int64 __fastcall loadkmap_main(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  char *v10; // rax\n  __int64 v11; // rdx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  char *v14; // r12\n  unsigned int console_fd_or_die; // r13d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  __int64 v20; // r8\n  __int64 v21; // r9\n  __m128 v22; // xmm4\n  __m128 v23; // xmm5\n  __int64 v24; // rbx\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 v27; // rbp\n  __int16 v28; // ax\n  char v30[2]; // [rsp+0h] [rbp-138h] BYREF\n  __int16 v31; // [rsp+2h] [rbp-136h]\n  _WORD v32[148]; // [rsp+10h] [rbp-128h] BYREF\n\n  xmalloc(0x100uLL, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  if ( *(_QWORD *)(a10 + 8) )\n    bb_show_usage((const char *)0x100, a1, a2, a3, a4, v12, v13, a7, a8);\n  v14 = v10;\n  console_fd_or_die = get_console_fd_or_die(a1, a2, a3, a4, v12, v13, a7, a8, 256LL, a10, v11);\n  xread(0, v14, 7LL, a1, a2, a3, a4, v16, v17, a7, a8);\n  if ( !is_prefixed_with(v14, \"bkeymap\") )\n    bb_error_msg_and_die(\n      (const __m128i *)\"not a valid binary keymap\",\n      (__int64)\"bkeymap\",\n      v18,\n      v19,\n      v20,\n      v21,\n      a1,\n      a2,\n      a3,\n      a4,\n      v22,\n      v23,\n      a7,\n      a8,\n      v30[0]);\n  v24 = 0LL;\n  xread(0, v14, 256LL, a1, a2, a3, a4, *(double *)v22.m128_u64, *(double *)v23.m128_u64, a7, a8);\n  do\n  {\n    if ( v14[v24] == 1 )\n    {\n      v27 = 0LL;\n      xread(0, (char *)v32, 256LL, a1, a2, a3, a4, v25, v26, a7, a8);\n      do\n      {\n        v28 = v32[v27];\n        v30[1] = v27++;\n        v30[0] = v24;\n        v31 = v28;\n        ioctl(console_fd_or_die, 0x4B47u, (unsigned __int64)v30);\n      }\n      while ( v27 != 128 );\n    }\n    ++v24;\n  }\n  while ( v24 != 256 );\n  return 0LL;\n}\n",
    "source_code": "int loadkmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct kbentry ke;\n\tint i, j, fd;\n\tuint16_t ibuff[NR_KEYS];\n/*\tconst char *tty_name = CURRENT_TTY; */\n\tRESERVE_CONFIG_BUFFER(flags, MAX_NR_KEYMAPS);\n\n\t/* When user accidentally runs \"loadkmap FILE\"\n\t * instead of \"loadkmap <FILE\", we end up waiting for input from tty.\n\t * Let's prevent it: */\n\tif (argv[1])\n\t\tbb_show_usage();\n/* bb_warn_ignoring_args(argv[1]); */\n\n\tfd = get_console_fd_or_die();\n/* or maybe:\n\topt = getopt32(argv, \"C:\", &tty_name);\n\tfd = xopen_nonblocking(tty_name);\n*/\n\n\txread(STDIN_FILENO, flags, 7);\n\tif (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))\n\t\tbb_error_msg_and_die(\"not a valid binary keymap\");\n\n\txread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);\n\n\tfor (i = 0; i < MAX_NR_KEYMAPS; i++) {\n\t\tif (flags[i] != 1)\n\t\t\tcontinue;\n\t\txread(STDIN_FILENO, ibuff, NR_KEYS * sizeof(uint16_t));\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tke.kb_index = j;\n\t\t\tke.kb_table = i;\n\t\t\tke.kb_value = ibuff[j];\n\t\t\t/*\n\t\t\t * Note: table[idx:0] can contain special value\n\t\t\t * K_ALLOCATED (marks allocated tables in kernel).\n\t\t\t * dumpkmap saves the value as-is; but attempts\n\t\t\t * to load it here fail, since it isn't a valid\n\t\t\t * key value: it is K(KT_SPEC,126) == 2<<8 + 126,\n\t\t\t * whereas last valid KT_SPEC is\n\t\t\t * K_BARENUMLOCK == K(KT_SPEC,19).\n\t\t\t * So far we just ignore these errors:\n\t\t\t */\n\t\t\tioctl(fd, KDSKBENT, &ke);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t\tRELEASE_CONFIG_BUFFER(flags);\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "comment": "Loads a binary keymap from standard input and updates the keyboard mapping using ioctl calls for each valid keymap.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Executes an ioctl system call and handles errors by logging a message and terminating the program if the call fails .\n",
    "cpbcs_sum": "Displays terminal type information using the provided termios structure and handles both standard and standard input processing each set.\n",
    "misum_sum": "Sets the CPU affinity of a network interface, optionally using ioctl system calls based on command-line arguments and specified flags.\n",
    "decom_sum": "Parses and validates a binary keymap file, then registers all defined keycode-to-scancode mappings using the provided device identifier.",
    "cfg_sum": "Processes a binary keymap file, validates its format, and registers all mapped key codes into the system\u2019s key handling context.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims describe functionality related to converting control characters, using static buffers, and handling Unicode display, none of which are present in the source code. The source implements loading a binary keymap into the console via ioctl calls, reading from stdin, and verifying magic values, so all claims are inaccurate and unrelated.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display are unrelated to the source code, which actually loads a binary keymap into the kernel via ioctl calls. None of the described behaviors match the primary purpose or secondary details of the actual implementation, making all claims inaccurate.",
                "The summary makes claims about replacing control characters with escape sequences, using a static buffer, and handling Unicode display, none of which are implemented in the provided source code. These are all inaccurate and constitute NOISE unrelated to the function\u2019s actual purpose of loading a binary keymap via stdin and setting key entries with ioctl. The worst failure mode is overwhelming NOISE, providing no accurate insight."
            ]
        },
        "bint5": {
            "summary": "Executes an ioctl system call and handles errors by logging a message and terminating the program if the call fails .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the code executes an ioctl system call and terminates with an error message if it fails. While the code does execute ioctl, it does not log a message or terminate on ioctl failure; instead, it ignores errors for certain values. This makes the claim contradictory to the source behavior, and thus inaccurate.",
                "The summary incorrectly states that the function terminates on ioctl failure with an error message, which is not reflected in the source code. In the implementation, ioctl is called without explicit error checking or termination on failure, and potential invalid key values are simply ignored. This misses the primary purpose of loading a binary keymap from stdin, validating its magic header, and setting kernel key table entries, and introduces an inaccurate claim about error handling.",
                "The summary makes a specific claim that the ioctl call is followed by error handling that logs a message and terminates on failure. In the source code, the ioctl calls are made without any error-checking or termination logic afterward; errors are explicitly ignored in certain cases. This is a direct contradiction of actual behavior, making it a FATAL error about a key side effect. The misstatement concerns how failures are handled, which is central to understanding program robustness."
            ]
        },
        "cpbcs": {
            "summary": "Displays terminal type information using the provided termios structure and handles both standard and standard input processing each set.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims about displaying terminal type information using a termios structure and handling standard input are not reflected in the source code, which instead loads a binary keymap from stdin, validates it, and applies it via ioctl. None of the claims in the summary match the actual implementation, resulting in a lack of accurate fact-based alignment.",
                "The summary is entirely inaccurate as it describes displaying terminal type information using a termios structure, which is unrelated to the actual function. The source code loads a binary keymap from stdin, verifies its magic header, reads keymap flags and key data, and uses ioctl to configure keyboard entries. The summary misses the primary purpose and all secondary details, making it completely misaligned with the implementation.",
                "The summary claims the function displays terminal type information using a termios structure and processes standard input sets. These statements are inaccurate because the source code does not involve a termios structure or display terminal type information. Instead, it reads a binary keymap from stdin and loads it into the kernel via ioctl calls. The mismatch targets the primary purpose and key I/O, representing a FATAL error that undermines reliability."
            ]
        },
        "misum": {
            "summary": "Sets the CPU affinity of a network interface, optionally using ioctl system calls based on command-line arguments and specified flags.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary\u2019s claim about setting CPU affinity of a network interface via ioctl and command-line flags is entirely unrelated to the source code, which instead reads and loads a binary keymap into the console keyboard using ioctl calls. None of the summary\u2019s elements match the actual implementation, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate: it describes setting CPU affinity for a network interface with ioctl calls, which bears no relation to the actual source code. The source function loads a binary keymap from stdin, validates its magic prefix, reads keymap data, and uses ioctl to set keyboard entries, not CPU affinity. It misses the primary purpose and all secondary details of the code, resulting in no factual alignment.",
                "The summary is entirely inaccurate; it describes setting CPU affinity of a network interface with ioctl calls and command-line flags, which has no relation to the actual code. The source code instead reads a binary keymap from stdin, validates its magic header, and loads keymap entries into the kernel using ioctl. This mismatch is a FATAL error affecting the primary purpose and key I/O behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582628544,
    "strip_function_name": "sub_FFFFFFFF8139BAC0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8139BAC0(\n        _QWORD *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int v13; // r14d\n  unsigned int v14; // ebx\n  __int64 v15; // rdx\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // [rsp+4h] [rbp-2Ch] BYREF\n\n  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 16LL) + 456LL) + 840LL);\n  if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v9 + 16) + 5LL) - 6) <= 1u )\n  {\n    result = sub_FFFFFFFF8178F4A0(v9 + 8880);\n    if ( !(_DWORD)result )\n    {\n      sub_FFFFFFFF81155B50(\n        a1,\n        (__int64)\"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n      v13 = *(unsigned __int8 *)(v9 + 8743);\n      v14 = 50 * v13;\n      if ( *(_BYTE *)(v9 + 8744) >= *(_BYTE *)(v9 + 8743) )\n      {\n        do\n        {\n          v18 = v13++;\n          sub_FFFFFFFF813DA900(v9, 9LL, &v18);\n          v15 = v14;\n          v14 += 50;\n          sub_FFFFFFFF81155B50(\n            a1,\n            (__int64)\"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n            a2,\n            a3,\n            a4,\n            a5,\n            v16,\n            v17,\n            a8,\n            a9,\n            v15,\n            100 * (unsigned int)(unsigned __int8)v18,\n            100 * (unsigned int)BYTE1(v18));\n        }\n        while ( *(unsigned __int8 *)(v9 + 8744) >= v13 );\n      }\n      sub_FFFFFFFF8178F1B0(v9 + 8880);\n      return 0LL;\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF81155B50(a1, (__int64)\"unsupported on this chipset\\n\", a2, a3, a4, a5, a6, a7, a8, a9);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "i915_ring_freq_table",
    "decompiled_code": "__int64 __fastcall i915_ring_freq_table(\n        _QWORD *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  int v15; // r9d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // r14d\n  unsigned int v19; // ebx\n  __int64 v20; // rdx\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  int v23; // [rsp+4h] [rbp-2Ch] BYREF\n\n  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 16LL) + 456LL) + 840LL);\n  if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v9 + 16) + 5LL) - 6) <= 1u )\n  {\n    result = mutex_lock_interruptible(v9 + 8880);\n    if ( !(_DWORD)result )\n    {\n      seq_printf(\n        a1,\n        (__int64)\"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n      v18 = *(unsigned __int8 *)(v9 + 8743);\n      v19 = 50 * v18;\n      if ( *(_BYTE *)(v9 + 8744) >= *(_BYTE *)(v9 + 8743) )\n      {\n        do\n        {\n          v23 = v18++;\n          sandybridge_pcode_read(v9, 9u, (unsigned int *)&v23, v13, v14, v15, a2, a3, a4, a5, v16, v17, a8, a9);\n          v20 = v19;\n          v19 += 50;\n          seq_printf(\n            a1,\n            (__int64)\"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n            a2,\n            a3,\n            a4,\n            a5,\n            v21,\n            v22,\n            a8,\n            a9,\n            v20,\n            100 * (unsigned int)(unsigned __int8)v23,\n            100 * (unsigned int)BYTE1(v23));\n        }\n        while ( *(unsigned __int8 *)(v9 + 8744) >= v18 );\n      }\n      mutex_unlock(v9 + 8880);\n      return 0LL;\n    }\n  }\n  else\n  {\n    seq_printf(a1, (__int64)\"unsupported on this chipset\\n\", a2, a3, a4, a5, a6, a7, a8, a9);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int i915_ring_freq_table(struct seq_file *m, void *unused)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tint ret;\n\tint gpu_freq, ia_freq;\n\n\tif (!(IS_GEN6(dev) || IS_GEN7(dev))) {\n\t\tseq_printf(m, \"unsupported on this chipset\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->rps.hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\tfor (gpu_freq = dev_priv->rps.min_delay;\n\t     gpu_freq <= dev_priv->rps.max_delay;\n\t     gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsandybridge_pcode_read(dev_priv,\n\t\t\t\t       GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t\t       &ia_freq);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   gpu_freq * GT_FREQUENCY_MULTIPLIER,\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tmutex_unlock(&dev_priv->rps.hw_lock);\n\n\treturn 0;\n}",
    "comment": "Retrieves and prints GPU, effective CPU, and effective Ring frequencies for Intel Gen6 and Gen7 chipsets, while protecting access with a mutex lock.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves and prints swizzle information for Intel graphics devices based on the generation of the Intel graphics device .\n",
    "cpbcs_sum": "Retrieves and displays information about the framebuffer, including size, depth, count, and status, in a sequence file for display.\n",
    "misum_sum": "Retrieves and displays the CPU frequency in a formatted output based on the specified display mode and total frequency values.\n",
    "decom_sum": "Outputs GPU, CPU, and Ring frequencies in MHz if supported by the chipset, otherwise reports unsupported hardware.",
    "cfg_sum": "Reports GPU, CPU, and Ring frequencies for supported chipsets, iterating through frequency steps, formatting output, and handling unsupported hardware with an error message.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains a vague statement about pushing a pointer type, which does not align with or accurately describe the source code's functionality of printing GPU, CPU, and ring frequencies for certain chipsets. No atomic fact-based claims that match the source implementation are present, resulting in no accurate claims.",
                "The summary 'push a pointer type.' is unrelated to the source code\u2019s functionality. It does not capture the primary purpose of listing GPU, CPU, and Ring frequencies for certain chipsets, nor does it address any secondary details such as chipset checks, mutex locking, frequency table reading, or output formatting. The claim is irrelevant noise with no alignment to the implementation.",
                "The summary makes a vague statement unrelated to the function's actual behavior. It does not reference the GPU/CPU/ring frequency table generation, chipset checks, or mutex locking that are central to the code. This is pure NOISE with no accurate claims, yielding no informative value for understanding the source."
            ]
        },
        "bint5": {
            "summary": "Retrieves and prints swizzle information for Intel graphics devices based on the generation of the Intel graphics device .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves and prints swizzle information for Intel graphics devices, which contradicts the source code. The implementation specifically retrieves and prints GPU, CPU, and ring frequency data for Gen6/Gen7 chipsets, not swizzle information. This indicates the single claim is inaccurate, yielding no alignment with the source behavior.",
                "The summary incorrectly describes the function as retrieving and printing swizzle information, which does not align with the source code. The source code actually generates and prints a frequency table for GPU, CPU, and ring based on min/max delay settings for Gen6/Gen7 Intel chipsets. The primary purpose is misidentified, and no secondary details such as chipset checks, locking, or frequency calculation are covered, resulting in no accurate claims.",
                "The summary claims the function retrieves and prints swizzle information for Intel graphics devices, which is inaccurate. The source code shows it prints frequency tables (GPU, CPU, ring frequencies) for Gen6/Gen7 devices, not swizzle data. This is a FATAL error targeting the primary purpose of the function, making the description misleading and unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves and displays information about the framebuffer, including size, depth, count, and status, in a sequence file for display.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves and displays framebuffer information such as size, depth, count, and status, but the source code shows it retrieving and displaying GPU frequency, effective CPU frequency, and ring frequency for specific chipsets. None of the claims in the summary accurately reflect the implementation, resulting in no alignment with the source.",
                "The summary describes retrieving framebuffer information like size, depth, count, and status, which is entirely unrelated to the source code. The source function displays GPU, CPU, and ring frequencies for specific chipsets, with locking and chipset checks. This means the PRIMARY PURPOSE is missed and no accurate claims map to the CSU_LIST.",
                "The summary's claim that the function retrieves and displays framebuffer details such as size, depth, count, and status is entirely inaccurate. The source code shows it displays GPU, CPU, and ring frequency information for specific chipsets, not framebuffer properties. This is a FATAL error targeting the primary purpose and I/O, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Retrieves and displays the CPU frequency in a formatted output based on the specified display mode and total frequency values.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary focuses only on retrieving and displaying CPU frequency based on display mode and total frequency values, which misrepresents the source code. The source code retrieves and displays GPU, effective CPU, and ring frequencies over a range, formatted in a table, and includes chipset checks and locking, which are absent from the summary. This results in a low proportion of accurate claims, with the majority being inaccurate or incomplete.",
                "The summary misrepresents the function's primary purpose. The code retrieves and displays a frequency table containing GPU, CPU, and ring frequencies for supported chipsets, and handles unsupported chipsets, locking, and iteration over a frequency range. The summary only mentions CPU frequency and omits GPU and ring frequencies, chipset checks, iteration over min/max delays, and mutex usage. This misses the main purpose and key secondary details while introducing an inaccurate focus on a 'specified display mode' not present in the code.",
                "The summary is inaccurate because it focuses only on CPU frequency and mentions 'specified display mode' and 'total frequency values,' which do not appear in the source. The function actually retrieves and displays GPU, effective CPU, and effective ring frequencies for Gen6/Gen7 chipsets in a fixed formatted output. This is a FATAL error as it misstates the primary purpose and core output of the code."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4270896,
    "strip_function_name": "sub_412B30",
    "strip_decompiled_code": "int __fastcall sub_412B30(__int64 a1)\n{\n  int result; // eax\n  unsigned int v2; // r8d\n  __int64 v3; // r10\n  __int64 v4; // rbx\n  char v5; // r11\n  char v6; // r9\n  int v7; // eax\n  int v8; // esi\n  int v9; // ecx\n  int v10; // edx\n  FILE *v11; // rdi\n\n  result = dword_7D7484;\n  if ( !dword_7E4F54 && dword_7E4F38 < (unsigned int)dword_7D7484 || !dword_7D7484 )\n    return result;\n  v2 = ++dword_7E4F50;\n  if ( !a1 )\n    goto LABEL_18;\n  v3 = qword_7E4F48;\n  v4 = qword_7E4F40;\n  v5 = 0;\n  v6 = 0;\n  v7 = 10;\n  v8 = 0;\n  v9 = 0;\n  do\n  {\n    v10 = *(_DWORD *)(a1 + 72);\n    if ( v10 != 1 )\n    {\n      if ( v10 == 2 && !v8 )\n      {\n        v3 = *(_QWORD *)(a1 + 80);\n        v5 = 1;\n        v8 = 1;\n      }\nLABEL_9:\n      --v7;\n      a1 = *(_QWORD *)(a1 + 32);\n      if ( !v7 )\n        break;\n      continue;\n    }\n    if ( v9 )\n      goto LABEL_9;\n    --v7;\n    v4 = *(_QWORD *)(a1 + 80);\n    v6 = 1;\n    v9 = 1;\n    a1 = *(_QWORD *)(a1 + 32);\n    if ( !v7 )\n      break;\n  }\n  while ( a1 );\n  if ( v6 )\n    qword_7E4F40 = v4;\n  if ( v5 )\n    qword_7E4F48 = v3;\nLABEL_18:\n  v11 = qword_7E4F68;\n  if ( v2 > 1 )\n  {\n    fputc(12, qword_7E4F68);\n    v2 = dword_7E4F50;\n    v11 = qword_7E4F68;\n  }\n  fprintf(v11, \"%s %s \\t\\t\\tpage %d\\n\", \"GAS LISTING\", (const char *)qword_7E4F58, v2);\n  fprintf(qword_7E4F68, \"%s\\n\", (const char *)qword_7E4F48);\n  result = fprintf(qword_7E4F68, \"%s\\n\", (const char *)qword_7E4F40);\n  dword_7E4F38 = 3;\n  dword_7E4F54 = 0;\n  return result;\n}\n",
    "function_name": "listing_page",
    "decompiled_code": "void __fastcall listing_page(list_info_type *list)\n{\n  __int64 v1; // r8\n  char *edict_arg; // r10\n  char *v3; // rbx\n  char v4; // r11\n  char v5; // r9\n  int v6; // eax\n  int v7; // esi\n  int v8; // ecx\n  edict_enum edict; // edx\n  FILE *v10; // rdi\n\n  if ( !eject && on_page < paper_height || !paper_height )\n    return;\n  v1 = ++page;\n  if ( !list )\n    goto LABEL_18;\n  edict_arg = (char *)title;\n  v3 = (char *)subtitle;\n  v4 = 0;\n  v5 = 0;\n  v6 = 10;\n  v7 = 0;\n  v8 = 0;\n  do\n  {\n    edict = list->edict;\n    if ( edict != edict_enum::EDICT_SBTTL )\n    {\n      if ( edict == edict_enum::EDICT_TITLE && !v7 )\n      {\n        edict_arg = list->edict_arg;\n        v4 = 1;\n        v7 = 1;\n      }\nLABEL_9:\n      --v6;\n      list = list->next;\n      if ( !v6 )\n        break;\n      continue;\n    }\n    if ( v8 )\n      goto LABEL_9;\n    --v6;\n    v3 = list->edict_arg;\n    v5 = 1;\n    v8 = 1;\n    list = list->next;\n    if ( !v6 )\n      break;\n  }\n  while ( list );\n  if ( v5 )\n    subtitle = v3;\n  if ( v4 )\n    title = edict_arg;\nLABEL_18:\n  v10 = list_file;\n  if ( (unsigned int)v1 > 1 )\n  {\n    fputc(12, list_file);\n    v1 = page;\n    v10 = list_file;\n  }\n  fprintf(v10, &byte_4F2711[18], 5187351LL, fn, v1);\n  fprintf(list_file, &byte_4F2711[47], title);\n  fprintf(list_file, &byte_4F2711[47], subtitle);\n  on_page = 3;\n  eject = 0;\n}\n",
    "source_code": "\nstatic void\nlisting_page (list_info_type *list)\n{\n  /* Grope around, see if we can see a title or subtitle edict coming up\n     soon.  (we look down 10 lines of the page and see if it's there)  */\n  if ((eject || (on_page >= (unsigned int) paper_height))\n      && paper_height != 0)\n    {\n      unsigned int c = 10;\n      int had_title = 0;\n      int had_subtitle = 0;\n\n      page++;\n\n      while (c != 0 && list)\n\t{\n\t  if (list->edict == EDICT_SBTTL && !had_subtitle)\n\t    {\n\t      had_subtitle = 1;\n\t      subtitle = list->edict_arg;\n\t    }\n\t  if (list->edict == EDICT_TITLE && !had_title)\n\t    {\n\t      had_title = 1;\n\t      title = list->edict_arg;\n\t    }\n\t  list = list->next;\n\t  c--;\n\t}\n\n      if (page > 1)\n\t{\n\t  fprintf (list_file, \"\\f\");\n\t}\n\n      fprintf (list_file, \"%s %s \\t\\t\\tpage %d\\n\", LISTING_HEADER, fn, page);\n      fprintf (list_file, \"%s\\n\", title);\n      fprintf (list_file, \"%s\\n\", subtitle);\n      on_page = 3;\n      eject = 0;\n    }\n}",
    "comment": "The function checks for titles and subtitles in a list before printing the current page header, title, and subtitle to a file.",
    "hext5_sum": "dump the symbol table.",
    "bint5_sum": "Outputs the source file name and line number for a given line record , while managing buffer states and handling various output conditions .\n",
    "cpbcs_sum": "Identifies the end of the search request in the search structure, returning the first fragment or the best matching physical data.\n",
    "misum_sum": "Displays the usage of a command-line input stream, highlighting the current word, and managing buffer counts for debugging, and writing.\n",
    "decom_sum": "Prints a formatted \"GAS LISTING\" page header with stored title and section strings, updating global page tracking and emitting a form feed between pages.",
    "cfg_sum": "Generates a formatted \u201cGAS LISTING\u201d page header, updates stored listing strings from input records, and writes them with pagination control to an output file.",
    "work_score": {
        "hext5": {
            "summary": "dump the symbol table.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claim 'dump the symbol table' does not match any functionality in the source code, which handles printing listing pages, titles, and subtitles, not dumping a symbol table. This is a clear semantic mismatch with 0% accurate claims.",
                "The summary 'dump the symbol table' is entirely inaccurate because the source function handles listing page formatting, detects upcoming title or subtitle within the next 10 lines, updates page count, outputs headers and titles to a file, and resets state variables. It does not perform any symbol table operations, missing the primary purpose and all secondary details.",
                "The summary contains a single claim that the function dumps the symbol table, which is completely unrelated to the source code's actual implementation of generating and printing a page header with title and subtitle. This is a FATAL error targeting the primary purpose, resulting in high negative impact and no accurate claims."
            ]
        },
        "bint5": {
            "summary": "Outputs the source file name and line number for a given line record , while managing buffer states and handling various output conditions .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as outputting a source file name and line number, managing buffers, and handling output conditions, none of which are reflected in the source code. The source code handles pagination, searches for title/subtitle edicts, and writes headers to a listing file. All claims in the summary contradict the actual implementation, resulting in no accurate claims.",
                "The summary incorrectly describes the function as outputting a source file name and line number with buffer management, which is unrelated to the actual code. The source code's primary purpose is to generate a formatted listing page header and include title/subtitle scanning within a 10-line lookahead when certain page/eject conditions are met. Since the summary misses the primary purpose entirely and introduces unrelated details, no accurate claims align with the implementation.",
                "The summary claims that the function outputs the source file name and line number and manages buffer states, which directly contradicts the code's actual behavior. The code generates a listing page header, checks for title/subtitle edicts within the next 10 lines, and writes these along with the page number to the listing file; there is no handling of buffer states or line record details. This is a FATAL error concerning the primary purpose, making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Identifies the end of the search request in the search structure, returning the first fragment or the best matching physical data.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes a process of ending a search request and returning matching data, which does not correspond to the source code that handles page formatting, extracting title and subtitle from a list, and printing them with page headers. None of the claims are accurate in relation to the actual implementation.",
                "The summary is completely unrelated to the source code\u2019s semantics. The function in the source generates a listing page when certain conditions are met, searches ahead for title and subtitle edicts, updates page counters, and writes formatted output to a file. The summary describes ending a search request and returning data fragments, which does not match the primary purpose or any secondary details. This results in no accurate claims and no coverage of the CSU_LIST.",
                "The summary describes functionality about identifying the end of a search request and returning data fragments, which is unrelated to the source code's actual behavior of handling page breaks, detecting title/subtitle within 10 lines, and printing formatted page headers. This is a clear FATAL error targeting primary purpose and semantics, leading to complete mismatch and making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Displays the usage of a command-line input stream, highlighting the current word, and managing buffer counts for debugging, and writing.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about command-line input stream usage, highlighting the current word, managing buffer counts, and debugging do not align with the source code, which handles listing page formatting, detecting titles/subtitles, writing to a file, and updating pagination variables. None of the claims accurately describe the actual implementation, resulting in 0% accuracy.",
                "The summary makes claims about command-line input streams, highlighting words, and managing buffers for debugging, none of which align with the source code. The source function generates a listing page, checks for title/subtitle within the next 10 lines, updates the page count, and writes formatted output to a file. The summary misses the primary purpose and all critical semantic units of the code, making all claims inaccurate.",
                "The summary claims the code handles command-line input streams, highlights the current word, manages buffer counts for debugging, and writing, but the source code instead processes a listing page by scanning upcoming lines for title/subtitle edicts, increments page numbers, and outputs formatted page headers. All claims are unrelated to the actual semantics, making them NOISE. Since NOISE is overwhelming and there are no ACCURATE claims, the net benefit is very low."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1098480,
    "strip_function_name": "gsl_multifit_fdfsolver_test",
    "strip_decompiled_code": "__int64 __fastcall gsl_multifit_fdfsolver_test(_QWORD *a1, _DWORD *a2, double a3, double a4)\n{\n  __int64 result; // rax\n  __int64 *v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // r8\n  double v10; // xmm1_8\n  __int64 v11; // rdi\n  __int64 v12; // rcx\n  double *v13; // rdx\n  __int64 v14; // rsi\n  double *v15; // rcx\n  __int64 v16; // rax\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm0_8\n\n  *a2 = 0;\n  result = gsl_multifit_test_delta(a1[4], a1[2], a3 * a3, a3);\n  if ( (_DWORD)result )\n  {\n    (*(void (__fastcall **)(_QWORD, _QWORD))(*a1 + 40LL))(a1[8], a1[5]);\n    v7 = (__int64 *)a1[2];\n    v8 = a1[5];\n    v9 = *v7;\n    if ( *v7 )\n    {\n      v10 = 0.0;\n      v11 = 8 * v7[1];\n      v12 = *(_QWORD *)(v8 + 8);\n      v13 = *(double **)(v8 + 16);\n      v14 = 8 * v12;\n      v15 = (double *)v7[2];\n      v16 = 0LL;\n      do\n      {\n        v17 = *v15;\n        ++v16;\n        v15 = (double *)((char *)v15 + v11);\n        v18 = fmax(v17, 1.0) * *v13;\n        v13 = (double *)((char *)v13 + v14);\n        v10 = fmax(fabs(v18), v10);\n      }\n      while ( v9 != v16 );\n    }\n    else\n    {\n      v10 = 0.0;\n    }\n    v19 = gsl_blas_dnrm2(a1[3]);\n    v20 = v19 * (0.5 * v19);\n    if ( v20 > 1.0 )\n      a4 = v20 * a4;\n    if ( a4 < v10 )\n    {\n      return 4294967294LL;\n    }\n    else\n    {\n      *a2 = 2;\n      return 0LL;\n    }\n  }\n  else\n  {\n    *a2 = 1;\n  }\n  return result;\n}\n",
    "function_name": "gsl_multifit_fdfsolver_test",
    "decompiled_code": "__int64 __fastcall gsl_multifit_fdfsolver_test(\n        const gsl_multifit_fdfsolver *s,\n        double xtol,\n        double gtol,\n        const double ftol,\n        int *info)\n{\n  __int64 result; // rax\n  gsl_vector *g; // rsi\n  double *data; // rcx\n  gsl_vector *x; // rax\n  gsl_vector *v11; // rdx\n  size_t size; // r8\n  double v13; // xmm1_8\n  __int64 v14; // rdi\n  size_t stride; // rcx\n  __int64 v16; // rax\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm0_8\n\n  *info = 0;\n  result = ((__int64 (__fastcall *)(gsl_vector *, gsl_vector *, double, double))gsl_multifit_test_delta)(\n             s->dx,\n             s->x,\n             xtol * xtol,\n             xtol);\n  if ( (_DWORD)result )\n  {\n    g = s->g;\n    s->type->gradient(s->state, g);\n    x = s->x;\n    v11 = s->g;\n    size = x->size;\n    if ( x->size )\n    {\n      v13 = 0.0;\n      v14 = 8 * x->stride;\n      stride = v11->stride;\n      v11 = (gsl_vector *)v11->data;\n      g = (gsl_vector *)(8 * stride);\n      data = x->data;\n      v16 = 0LL;\n      do\n      {\n        v17 = *data;\n        ++v16;\n        data = (double *)((char *)data + v14);\n        v18 = fmax(v17, 1.0) * *(double *)&v11->size;\n        v11 = (gsl_vector *)((char *)v11 + (_QWORD)g);\n        v13 = fmax(fabs(v18), v13);\n      }\n      while ( size != v16 );\n    }\n    else\n    {\n      v13 = 0.0;\n    }\n    v19 = ((double (__fastcall *)(gsl_vector *, gsl_vector *, gsl_vector *, double *))gsl_blas_dnrm2)(\n            s->f,\n            g,\n            v11,\n            data);\n    v20 = v19 * (0.5 * v19);\n    if ( v20 > 1.0 )\n      gtol = v20 * gtol;\n    if ( gtol < v13 )\n    {\n      return 4294967294LL;\n    }\n    else\n    {\n      *info = 2;\n      return 0LL;\n    }\n  }\n  else\n  {\n    *info = 1;\n  }\n  return result;\n}\n",
    "source_code": "\nint\ngsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * s,\n                             const double xtol, const double gtol,\n                             const double ftol, int *info)\n{\n  int status;\n  double gnorm, fnorm, phi;\n\n  *info = 0;\n\n  status = gsl_multifit_test_delta(s->dx, s->x, xtol*xtol, xtol);\n  if (status == GSL_SUCCESS)\n    {\n      *info = 1;\n      return GSL_SUCCESS;\n    }\n\n  /* compute gradient g = J^T f */\n  (s->type->gradient) (s->state, s->g);\n\n  /* compute gnorm = max_i( g_i * max(x_i, 1) ) */\n  gnorm = scaled_infnorm(s->x, s->g);\n\n  /* compute fnorm = ||f|| */\n  fnorm = gsl_blas_dnrm2(s->f);\n  phi = 0.5 * fnorm * fnorm;\n\n  if (gnorm <= gtol * GSL_MAX(phi, 1.0))\n    {\n      *info = 2;\n      return GSL_SUCCESS;\n    }\n\n#if 0\n  if (dfnorm <= ftol * GSL_MAX(fnorm, 1.0))\n    {\n      *info = 3;\n      return GSL_SUCCESS;\n    }\n#endif\n\n  return GSL_CONTINUE;\n}",
    "comment": "Evaluates the convergence of a multifit solver by checking parameter changes, gradient norms, and function norms against specified tolerances.",
    "hext5_sum": "gsl_multifit_linear_l() compute discrete approximation to derivative operator of order k on a regular grid of p points, ie: l is (p-k)-by-p",
    "bint5_sum": "Evaluates convergence criteria for a fitting algorithm based on gradient and function norms , returning status codes for success or continuation .\n",
    "cpbcs_sum": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
    "misum_sum": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
    "decom_sum": "Evaluates convergence of a nonlinear least squares solver using delta and norm thresholds, updating status codes based on scaled residual magnitude.",
    "cfg_sum": "Checks solver convergence using delta and residual norms, adjusts tolerance, and returns status code indicating success, continuation, or failure.",
    "work_score": {
        "hext5": {
            "summary": "gsl_multifit_linear_l() compute discrete approximation to derivative operator of order k on a regular grid of p points, ie: l is (p-k)-by-p",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes a function named gsl_multifit_linear_l() performing derivative approximation on a grid, but the source code is for gsl_multifit_fdfsolver_test() testing convergence conditions with xtol, gtol, and ftol. None of the claims in the summary match the semantics or operations in the source; all are unrelated, making the accuracy proportion 0%.",
                "The summary describes a completely different function, `gsl_multifit_linear_l`, and discusses a derivative operator on a grid, which is unrelated to the actual source code. The source function `gsl_multifit_fdfsolver_test` tests convergence of a nonlinear fit solver based on delta, gradient norm, and function norm criteria, updating an info flag and returning a status. The summary contains no accurate claims about the source code's primary purpose or secondary details, resulting in no coverage.",
                "The summary describes a completely different function (gsl_multifit_linear_l) performing derivative approximation on a grid, which is unrelated to the actual source code for gsl_multifit_fdfsolver_test that checks convergence criteria for a solver. This is a FATAL inaccuracy impacting the primary purpose, as none of the claims match the actual implementation's semantics."
            ]
        },
        "bint5": {
            "summary": "Evaluates convergence criteria for a fitting algorithm based on gradient and function norms , returning status codes for success or continuation .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary accurately captures the core purpose of the function \u2014 checking convergence for a fitting algorithm using gradient and function norms and returning success or continuation codes. While it omits specific implementation details such as the initial delta test and info flag values, the stated claims are consistent with the source code and do not contradict it, yielding a high proportion of accurate claims.",
                "The summary correctly identifies the primary purpose of the function as evaluating convergence criteria for a fitting algorithm and returning a success or continuation status, which matches the source code. However, it omits key secondary details such as the initial delta test using xtol, the specific computation of gnorm and phi, the use of gtol scaling, and the distinct info codes indicating the type of convergence. This results in partial coverage of the CSU_LIST.",
                "The summary correctly states that the function evaluates convergence criteria and uses gradient and function norms, aligning with the gradient and fnorm checks in the source. It omits mention of the delta criterion and the multiple distinct info codes, making it broad and lacking detail. There are no contradictions or false statements, so there is no FATAL impact, but the gain is low due to missing specifics on all convergence checks and criteria thresholds."
            ]
        },
        "cpbcs": {
            "summary": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly identifies that the function evaluates convergence criteria in a nonlinear optimization algorithm and uses gradient and function norms to determine success or continuation, which matches the source implementation. Although it omits specifics such as the delta test and the multiple info codes, the described claims are accurate and not contradictory to the code.",
                "The summary correctly identifies the primary purpose: the function tests convergence criteria for a nonlinear optimization by checking gradient and function norms, and returns different status codes. However, it omits key secondary details from the source, such as the initial delta check using xtol, the specific threshold formula using gtol and phi, the assignment of *info codes 1 and 2, and the fact that one criterion (ftol) is disabled. These omissions reduce completeness.",
                "The summary correctly captures the primary purpose of the function\u2014checking convergence criteria for a nonlinear solver using gradient and function norms\u2014and notes that it returns either success or continuation, aligning with the source code. However, it omits specifics such as the xtol-based delta test, details of how gnorm and fnorm are computed, and the role of the info flag. All claims are accurate but are broad SAFE statements with low informational value, resulting in low gain."
            ]
        },
        "misum": {
            "summary": "Evaluates convergence criteria for a nonlinear optimization algorithm based on gradient and function norms, returning status codes for success or continuation.\n",
            "score": [
                0.9,
                0.7,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function evaluates convergence criteria for a nonlinear optimization algorithm and uses gradient and function norms, which matches the code\u2019s use of `gnorm` and `fnorm` checks to determine success. It omits mention of the delta test condition and ignores specific handling of `info` values, but there are no contradictory statements. Most claims align with the source implementation, with minor loss of detail.",
                "The summary correctly identifies the primary purpose as evaluating convergence criteria for a nonlinear optimization algorithm and notes the use of gradient and function norms, which aligns with the code and covers key secondary details like success or continuation status codes. However, it omits specifics such as the initial delta test using xtol, the different info codes for distinct criteria (1 for delta, 2 for gradient), and the unused ftol check. These missing secondary details prevent comprehensive coverage.",
                "The summary makes a broad, correct statement that the function checks convergence using gradient and function norms and returns success or continuation. This aligns with the code\u2019s logic for computing gnorm and fnorm and deciding between GSL_SUCCESS and GSL_CONTINUE, so it's SAFE. However, it omits specifics such as the delta test based on xtol, use of phi scaling, and the setting of *info values. This low level of detail provides little additional insight, resulting in low gain. No contradictory or FATAL claims are present, and NOISE is minimal."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 177248,
    "strip_function_name": "sub_2B460",
    "strip_decompiled_code": "__m128i *__fastcall sub_2B460(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __int128 a7,\n        __int64 a8)\n{\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __m128i *v12; // rbx\n  void *v13; // rdi\n  unsigned int v14; // ecx\n  __m128i v15; // xmm0\n  __int64 v16; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n\n  if ( (_QWORD)a7 )\n  {\n    if ( !*((_QWORD *)&a7 + 1) )\n      return 0LL;\n  }\n  else\n  {\n    if ( *((_QWORD *)&a7 + 1) )\n      return 0LL;\n    a8 = 0LL;\n    *(_QWORD *)&a7 = sub_F2A0;\n    *((_QWORD *)&a7 + 1) = sub_F2B0;\n  }\n  v8 = sub_F2C0(200LL, a2, a3, a4, a5, a6, (__int64 (__fastcall *)(__int64, __int64))a7, SDWORD2(a7), a8);\n  v12 = (__m128i *)v8;\n  if ( v8 )\n  {\n    *(_QWORD *)v8 = 0LL;\n    *(_QWORD *)(v8 + 168) = 0LL;\n    v13 = (void *)((v8 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n    v14 = (unsigned int)(v8 - (_DWORD)v13 + 176) >> 3;\n    memset(v13, 0, 8LL * v14);\n    v15 = _mm_loadu_si128((const __m128i *)&a7);\n    *(_QWORD *)(v8 + 192) = a8;\n    *(__m128i *)(v8 + 176) = v15;\n    v16 = sub_28F50(\n            (__int64)v13 + 8 * v14,\n            a2,\n            v9,\n            0LL,\n            v10,\n            v11,\n            (__int64 (__fastcall *)(__int64, __int64))a7,\n            *((void (__fastcall **)(__int64, void *))&a7 + 1),\n            a8);\n    v12->m128i_i64[0] = v16;\n    if ( v16 )\n      return v12;\n    sub_2B3B0(v12, a2, v17, v18, v19, v20);\n  }\n  return 0LL;\n}\n",
    "function_name": "ZSTD_createCStream_advanced",
    "decompiled_code": "__m128i *__fastcall ZSTD_createCStream_advanced(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __int128 a7,\n        __int64 a8)\n{\n  __int64 v8; // rax\n  __int64 v9; // rdx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __m128i *v12; // rbx\n  void *v13; // rdi\n  unsigned int v14; // ecx\n  __m128i v15; // xmm0\n  __int64 CCtx_advanced; // rax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n\n  if ( (_QWORD)a7 )\n  {\n    if ( !*((_QWORD *)&a7 + 1) )\n      return 0LL;\n  }\n  else\n  {\n    if ( *((_QWORD *)&a7 + 1) )\n      return 0LL;\n    a8 = 0LL;\n    *(_QWORD *)&a7 = ZSTD_defaultAllocFunction;\n    *((_QWORD *)&a7 + 1) = ZSTD_defaultFreeFunction;\n  }\n  v8 = ZSTD_malloc(200LL, a2, a3, a4, a5, a6, (__int64 (__fastcall *)(__int64, __int64))a7, SDWORD2(a7), a8);\n  v12 = (__m128i *)v8;\n  if ( v8 )\n  {\n    *(_QWORD *)v8 = 0LL;\n    *(_QWORD *)(v8 + 168) = 0LL;\n    v13 = (void *)((v8 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n    v14 = (unsigned int)(v8 - (_DWORD)v13 + 176) >> 3;\n    memset(v13, 0, 8LL * v14);\n    v15 = _mm_loadu_si128((const __m128i *)&a7);\n    *(_QWORD *)(v8 + 192) = a8;\n    *(__m128i *)(v8 + 176) = v15;\n    CCtx_advanced = ZSTD_createCCtx_advanced(\n                      (__int64)v13 + 8 * v14,\n                      a2,\n                      v9,\n                      0LL,\n                      v10,\n                      v11,\n                      (__int64 (__fastcall *)(__int64, __int64))a7,\n                      *((void (__fastcall **)(__int64, void *))&a7 + 1),\n                      a8);\n    v12->m128i_i64[0] = CCtx_advanced;\n    if ( CCtx_advanced )\n      return v12;\n    ZSTD_freeCStream(v12, a2, v17, v18, v19, v20);\n  }\n  return 0LL;\n}\n",
    "source_code": "\nZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem)\n{\n    ZSTD_CStream* zcs;\n\n    if (!customMem.customAlloc && !customMem.customFree) customMem = defaultCustomMem;\n    if (!customMem.customAlloc || !customMem.customFree) return NULL;\n\n    zcs = (ZSTD_CStream*)ZSTD_malloc(sizeof(ZSTD_CStream), customMem);\n    if (zcs==NULL) return NULL;\n    memset(zcs, 0, sizeof(ZSTD_CStream));\n    memcpy(&zcs->customMem, &customMem, sizeof(ZSTD_customMem));\n    zcs->cctx = ZSTD_createCCtx_advanced(customMem);\n    if (zcs->cctx == NULL) { ZSTD_freeCStream(zcs); return NULL; }\n    return zcs;\n}",
    "comment": "Creates and initializes a ZSTD_CStream object with custom memory allocation, returning NULL on failure or invalid parameters.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Creates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup .\n",
    "cpbcs_sum": "Creates and initializes a decompression context with custom memory management for advanced decompression context setup.\n",
    "misum_sum": "Allocates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup.\n",
    "decom_sum": "Allocates and initializes a 200-byte structure with function pointers and parameters, then populates it through a secondary initialization routine, returning the structure on success.",
    "cfg_sum": "Initializes a 200-byte data structure with callbacks, zeroes its memory, sets parameters, and builds it, returning the structure or null on failure.",
    "work_score": {
        "hext5": {
            "summary": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains claims entirely unrelated to the source code, describing a lognormal distribution and random number generation rather than the creation and initialization of a ZSTD_CStream with custom memory. None of the claims match or are relevant to the given implementation, resulting in 0% accuracy.",
                "The summary only describes mathematical properties of the lognormal distribution and random number generation, which are completely unrelated to the function in the source code. None of the claims target the source code\u2019s primary purpose or secondary details, so there is no coverage of the CSU_LIST.",
                "The summary contains only mathematical content about the lognormal distribution, which is unrelated to the source code implementing a ZSTD compression stream creation function. All extracted claims are NOISE with no accurate linkage to the code's semantics, offering zero relevant insight. The worst failure mode is overwhelming NOISE, resulting in no net benefit."
            ]
        },
        "bint5": {
            "summary": "Creates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes creation of a ZBUFFv07_DCtx for advanced decompression, but the source code actually creates and initializes a ZSTD_CStream for compression, not decompression, and does not involve a ZBUFF structure. The claim is specific but contradicts core semantics of the implementation, resulting in no accurate claims.",
                "The summary is inaccurate because it describes creating and initializing a ZBUFFv07_DCtx for decompression, whereas the source code creates a ZSTD_CStream for compression with custom memory management. It misses the primary purpose entirely, conflates structure names, and fails to cover key secondary details such as default memory handling, error checks, and creation of a compression context.",
                "The summary incorrectly claims creation of a ZBUFFv07_DCtx for decompression, while the source clearly creates a ZSTD_CStream for compression using a custom memory allocator. This is a FATAL inaccuracy targeting the primary purpose and key output type, making the description unreliable despite referring to custom memory handling."
            ]
        },
        "cpbcs": {
            "summary": "Creates and initializes a decompression context with custom memory management for advanced decompression context setup.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as creating and initializing a decompression context, while the source code clearly shows it creates a compression stream context using `ZSTD_createCStream_advanced`. This is a semantic mismatch targeting code behavior, meaning the claim is inaccurate. As the single claim is inaccurate, the proportion of accurate claims is 0%, placing it well below the 50% threshold.",
                "The summary incorrectly states that the function creates a decompression context, while the source code clearly initializes a compression stream (`ZSTD_CStream`) using custom memory allocators. Although it references custom memory management, the primary purpose is misidentified, causing a failure to capture the correct core functionality. Secondary details such as input validation, default memory handling, and error checks are also missed.",
                "The summary makes a fact-based claim that the function creates and initializes a decompression context, but the source code clearly shows it creates a compression stream (ZSTD_CStream) using ZSTD_createCCtx_advanced. This is a FATAL inaccuracy targeting the primary purpose and key I/O of the function. There are no accurate claims present, so the negative impact is severe and reliability is poor."
            ]
        },
        "misum": {
            "summary": "Allocates and initializes a ZBUFFv07_DCtx structure with custom memory management for advanced decompression context setup.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes allocation and initialization of a ZBUFFv07_DCtx for decompression, whereas the source code allocates and initializes a ZSTD_CStream for compression with custom memory management. This is a semantic mismatch targeting the code but is entirely inaccurate, yielding no accurate claims.",
                "The summary incorrectly describes the function as allocating a ZBUFFv07_DCtx for decompression, whereas the source code creates and initializes a ZSTD_CStream for compression with advanced custom memory handling. This misidentification of both the structure and purpose means the primary function behavior is missed entirely, and no accurate claims map to the actual semantic units in the code.",
                "The summary is inaccurate because it claims the function allocates and initializes a 'ZBUFFv07_DCtx' for decompression, while the source code clearly creates a 'ZSTD_CStream' for compression with custom memory allocators. This is a FATAL error affecting the primary purpose and I/O semantics, leaving no accurate claims and making the content misleading."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 398289,
    "strip_function_name": "sub_613D1",
    "strip_decompiled_code": "__int64 __fastcall sub_613D1(int *a1, int a2, __int64 a3)\n{\n  unsigned __int8 *v4; // rax\n  __int64 v5; // rax\n  unsigned __int8 v7; // [rsp+1Fh] [rbp-39h]\n  unsigned __int64 i; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v9; // [rsp+28h] [rbp-30h]\n  unsigned __int8 *v10; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v11; // [rsp+40h] [rbp-18h]\n  __int64 v12; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v13; // [rsp+50h] [rbp-8h]\n\n  if ( !a2 )\n  {\n    *a1 = 0;\n    return 0LL;\n  }\n  if ( a2 == 1 )\n    return 0LL;\n  v10 = *(unsigned __int8 **)a3;\n  v11 = *(_QWORD *)(a3 + 8);\n  v12 = *(_QWORD *)(a3 + 16);\n  v13 = *(_QWORD *)(a3 + 24);\n  v9 = 0LL;\n  for ( i = 0LL; *a1 != 6 && i < v11 && v9 < v13; ++i )\n  {\n    v4 = v10++;\n    v7 = *v4;\n    if ( *v4 == 13 )\n    {\n      if ( v11 == i + 1 )\n        break;\n      *a1 = sub_61307(*a1, 13);\n      if ( *v10 != 10 )\n        goto LABEL_17;\n    }\n    else\n    {\n      if ( v7 != 46 || *a1 && *a1 != 3 )\n      {\n        *a1 = sub_61307(*a1, v7);\nLABEL_17:\n        v5 = v9++;\n        *(_BYTE *)(v5 + v12) = v7;\n        continue;\n      }\n      if ( v11 == i + 2 )\n        break;\n      *a1 = sub_61307(*a1, 46);\n      if ( *v10 == 13 )\n        goto LABEL_17;\n    }\n  }\n  if ( *a1 == 6 )\n  {\n    v9 -= 2LL;\n    *(_DWORD *)(a3 + 36) = 1;\n  }\n  *(_QWORD *)(a3 + 8) = i;\n  *(_QWORD *)(a3 + 24) = v9;\n  return 0LL;\n}\n",
    "function_name": "_crlfdot_decoder",
    "decompiled_code": "mu_filter_result __cdecl crlfdot_decoder(void *xd, mu_filter_command cmd, mu_filter_io *iobuf)\n{\n  unsigned __int8 *v4; // rax\n  size_t v5; // rax\n  unsigned __int8 c; // [rsp+1Fh] [rbp-39h]\n  size_t i; // [rsp+20h] [rbp-38h]\n  size_t j; // [rsp+28h] [rbp-30h]\n  const unsigned __int8 *iptr; // [rsp+30h] [rbp-28h]\n  size_t isize; // [rsp+40h] [rbp-18h]\n  char *optr; // [rsp+48h] [rbp-10h]\n  size_t osize; // [rsp+50h] [rbp-8h]\n\n  if ( cmd == mu_filter_command::mu_filter_init )\n  {\n    *(_DWORD *)xd = 0;\n    return 0;\n  }\n  if ( cmd == mu_filter_command::mu_filter_done )\n    return 0;\n  iptr = (const unsigned __int8 *)iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n  j = 0LL;\n  for ( i = 0LL; *(_DWORD *)xd != 6 && i < isize && j < osize; ++i )\n  {\n    v4 = (unsigned __int8 *)iptr++;\n    c = *v4;\n    if ( *v4 == 13 )\n    {\n      if ( isize == i + 1 )\n        break;\n      *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, 13);\n      if ( *iptr != 10 )\n        goto LABEL_17;\n    }\n    else\n    {\n      if ( c != 46 || *(_DWORD *)xd && *(_DWORD *)xd != 3 )\n      {\n        *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, c);\nLABEL_17:\n        v5 = j++;\n        optr[v5] = c;\n        continue;\n      }\n      if ( isize == i + 2 )\n        break;\n      *(_DWORD *)xd = new_decode_state(*(crlfdot_decode_state *)xd, 46);\n      if ( *iptr == 13 )\n        goto LABEL_17;\n    }\n  }\n  if ( *(_DWORD *)xd == 6 )\n  {\n    j -= 2LL;\n    iobuf->eof = 1;\n  }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return 0;\n}\n",
    "source_code": "static enum mu_filter_result\n_crlfdot_decoder (void *xd,\n\t\t  enum mu_filter_command cmd,\n\t\t  struct mu_filter_io *iobuf)\n{\n  int *pstate = xd;\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n\n  switch (cmd)\n    {\n    case mu_filter_init:\n      *pstate = crlfdot_decode_init;\n      return mu_filter_ok;\n      \n    case mu_filter_done:\n      return mu_filter_ok;\n      \n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; *pstate != crlfdot_decode_end && i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n\n      if (c == '\\r')\n\t{\n\t  if (i + 1 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr == '\\n')\n\t    continue;\n\t}\n      else if (c == '.' &&\n\t       (*pstate == crlfdot_decode_init ||\n\t\t*pstate == crlfdot_decode_crlf))\n\t{\n\t  /* Make sure we have two more characters in the buffer */\n\t  if (i + 2 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr != '\\r')\n\t    continue;\n\t}\n      else\n\t*pstate = new_decode_state (*pstate, c);\n      optr[j++] = c;\n    }\n  \n  if (*pstate == crlfdot_decode_end)\n    {\n      j -= 2; /* remove the trailing .\\n */\n      iobuf->eof = 1;\n    }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "comment": "Decodes input data by processing CRLF sequences and dots, modifying the state and output buffer accordingly, until reaching the end condition.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes input bytes with specific state transitions , filtering out dots at the beginning of lines and marking end of data with EOF .\n",
    "cpbcs_sum": "Processes input data by mapping key-value pairs to output lines, managing state transitions, and handling errors appropriately.\n",
    "misum_sum": "Processes input data through a filter, transferring valid characters to output until reaching the end-of-file condition or exceeding buffer limits.\n",
    "decom_sum": "Parses bytes from an input buffer with a state machine, copying valid characters to an output buffer and stopping on specific delimiters or completion state.",
    "cfg_sum": "Processes an input byte stream, updates parsing state and buffers, and flags completion upon detecting specific control characters or reaching defined limits.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a vague and generic statement that does not specifically describe the source code's logic or any factual detail about the implementation. It neither matches any identifiable behavior in the source code nor provides accurate technical information, making it irrelevant to the code semantics.",
                "The summary 'push a pointer type' is extremely vague and does not capture the primary purpose or any secondary details of the function, which processes input/output buffers to decode CRLF-dot sequences and manage decoding state. It neither matches the source semantics nor provides fact-based coverage, making it entirely inaccurate.",
                "The summary contains only a vague phrase that does not accurately describe the source code\u2019s function or behavior. It lacks specificity, does not reference the decoding logic, state transitions, or handling of CRLF and dot sequences, and thus constitutes pure NOISE with no factual alignment. This results in no useful insight and high negative impact from irrelevant content."
            ]
        },
        "bint5": {
            "summary": "Processes input bytes with specific state transitions , filtering out dots at the beginning of lines and marking end of data with EOF .\n",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary contains two atomic claims: processing input bytes with specific state transitions, and filtering out dots at the beginning of lines while marking the end of data with EOF. The first claim is accurate, as the code updates a decode state based on characters read. The second is mostly accurate\u2014the code does handle dots at the start of a line and sets EOF when a terminal sequence is reached\u2014though it specifically removes the trailing '.\\n', not arbitrary dots at line starts. Both claims generally align with the source\u2019s logic, yielding a high proportion of accurate statements.",
                "The summary correctly identifies the primary purpose of the function as processing input bytes with state transitions and handling dots at the beginning of lines, as well as marking the end of data with EOF. However, it omits secondary details such as initial and final command handling (mu_filter_init, mu_filter_done), specific CRLF handling logic, buffer boundary checks, and the removal of the trailing '.\\n' sequence. This results in incomplete coverage of the code's behavior beyond the main purpose.",
                "The summary correctly notes that the function processes input bytes with state transitions and marks the end of data by setting EOF. It also accurately describes filtering out dots at the beginning of lines, which matches the code logic where a leading '.' after CRLF or at start triggers conditional skipping before output. These are specific and aligned with the source implementation, with no contradictory or irrelevant claims. The claims provide clear insight into the primary purpose and key side effect of the code, thus yielding high gain."
            ]
        },
        "cpbcs": {
            "summary": "Processes input data by mapping key-value pairs to output lines, managing state transitions, and handling errors appropriately.\n",
            "score": [
                0.2,
                0.1,
                0.3
            ],
            "reason": [
                "The summary's claims about mapping key-value pairs to output lines and handling errors do not match the source code, which processes a byte stream to decode CRLF and dot sequences, updates state based on characters, and manages buffer sizes. Only the mention of managing state transitions loosely aligns with the implementation, making the majority of claims inaccurate.",
                "The summary incorrectly describes the code as processing key-value pairs and handling errors, which contradicts the actual implementation. The function\u2019s primary purpose is decoding CRLF-dot sequences from input to output with state management, and updating buffer sizes and EOF status; none of these specifics are reflected in the summary. It misses the primary purpose and all secondary details, making the claims both inaccurate and irrelevant to the source code.",
                "The summary's claims about mapping key-value pairs, managing state transitions, and handling errors do not match the source code. The function processes a byte stream with CR/LF and dot decoding logic; there is no key-value mapping or explicit error handling beyond returning 'mu_filter_ok'. State transitions are present, but the majority of claims are inaccurate and constitute noise, with no specific or accurate insights into primary purpose or key I/O behavior."
            ]
        },
        "misum": {
            "summary": "Processes input data through a filter, transferring valid characters to output until reaching the end-of-file condition or exceeding buffer limits.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately conveys the broad behavior that the function processes input through a filter and writes characters to output until an EOF condition or buffer limit is reached. While it omits details such as the specific CRLF dot decoding rules and state transitions, it does not contradict the source implementation. This makes it a low-information but safe claim, and since there is only one claim and it is accurate, the proportion of accurate claims is very high.",
                "The summary correctly captures the primary purpose of processing input data through a filter and writing characters to output, aligning with the loop in the source code. However, it omits key secondary details such as specific CRLF and dot handling, state transitions, conditions for breaking out of the loop, trimming trailing characters, and setting the EOF flag. These omissions mean it lacks coverage of important observable behaviors beyond the broad purpose.",
                "The summary states that the function processes input data, transfers valid characters to output, and stops at EOF or buffer limits. This is broadly accurate to the code: the function iterates through input, writes characters to output, and stops when EOF is reached or buffer capacity is exceeded. However, the summary is low-info and omits key specifics such as the CRLF dot decoding logic, state transitions, and special handling of certain characters. There are no contradictory or FATAL errors, but the lack of details makes the gain low, representing a safe but minimal insight scenario. Worst failure mode: Low Gain due to generic description."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4777712,
    "strip_function_name": "sub_48E6F0",
    "strip_decompiled_code": "__int64 __fastcall sub_48E6F0(const char *a1, __int64 a2, _DWORD *a3)\n{\n  void *v4; // rax\n  unsigned int (__fastcall *v5)(int *); // rax\n  __int64 result; // rax\n  __off_t v7; // rbx\n  int v8; // [rsp+Ch] [rbp-8Ch] BYREF\n  _BYTE v9[8]; // [rsp+10h] [rbp-88h] BYREF\n  int fd; // [rsp+18h] [rbp-80h]\n  __int64 v11; // [rsp+30h] [rbp-68h]\n  int v12; // [rsp+40h] [rbp-58h] BYREF\n  __int64 (*v13)(__int64, const char *, ...); // [rsp+48h] [rbp-50h]\n  int v14; // [rsp+50h] [rbp-48h]\n  __int64 (__fastcall *v15)(__int64); // [rsp+58h] [rbp-40h]\n  int v16; // [rsp+60h] [rbp-38h]\n  __int64 (__fastcall *v17)(__int64, int, __int64); // [rsp+68h] [rbp-30h]\n  int v18; // [rsp+70h] [rbp-28h]\n  int v19; // [rsp+78h] [rbp-20h]\n\n  *a3 = 0;\n  v4 = dlopen(a1, 2);\n  if ( !v4 )\n  {\n    dlerror();\n    sub_40CAD0((char *)\"%s\\n\");\n    return 0LL;\n  }\n  v5 = (unsigned int (__fastcall *)(int *))dlsym(v4, \"onload\");\n  if ( v5 )\n  {\n    v12 = 11;\n    v13 = sub_48E3E0;\n    v14 = 5;\n    v15 = sub_48E210;\n    v16 = 8;\n    v17 = sub_48E3A0;\n    v18 = 0;\n    v19 = 0;\n    if ( !v5(&v12) )\n    {\n      *a3 = 1;\n      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x20;\n      if ( qword_714B10 )\n      {\n        v8 = 0;\n        result = sub_48E600((_QWORD *)a2, (__int64)v9);\n        if ( !(_DWORD)result )\n          return result;\n        v11 = a2;\n        v7 = lseek(fd, 0LL, 1);\n        qword_714B10(v9, &v8);\n        lseek(fd, v7, 0);\n        if ( v8 )\n        {\n          *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x10;\n          return 1LL;\n        }\n      }\n    }\n  }\n  return 0LL;\n}\n",
    "function_name": "try_load_plugin",
    "decompiled_code": "__int64 __fastcall try_load_plugin(const char *pname, __int64 a2, bfd *a3)\n{\n  void *v4; // rax\n  unsigned int (__fastcall *v5)(ld_plugin_tv *); // rax\n  __int64 result; // rax\n  __off_t v7; // rbx\n  char *v8; // rax\n  int v9; // [rsp+Ch] [rbp-8Ch] BYREF\n  ld_plugin_input_file v10; // [rsp+10h] [rbp-88h] BYREF\n  ld_plugin_tv tv[4]; // [rsp+40h] [rbp-58h] BYREF\n\n  LODWORD(a3->filename) = 0;\n  v4 = dlopen(pname, 2);\n  if ( !v4 )\n  {\n    v8 = dlerror();\n    bfd_error_handler(\"%s\\n\", v8);\n    return 0LL;\n  }\n  v5 = (unsigned int (__fastcall *)(ld_plugin_tv *))dlsym(v4, &byte_4D3430[22]);\n  if ( v5 )\n  {\n    tv[0].tv_tag = ld_plugin_tag::LDPT_MESSAGE;\n    tv[0].tv_u.tv_string = (const char *)message;\n    tv[1].tv_tag = ld_plugin_tag::LDPT_REGISTER_CLAIM_FILE_HOOK;\n    tv[1].tv_u.tv_string = (const char *)register_claim_file;\n    tv[2].tv_tag = ld_plugin_tag::LDPT_ADD_SYMBOLS;\n    tv[2].tv_u.tv_string = (const char *)add_symbols;\n    tv[3].tv_tag = ld_plugin_tag::LDPT_NULL;\n    tv[3].tv_u.tv_val = 0;\n    if ( !v5(tv) )\n    {\n      LODWORD(a3->filename) = 1;\n      *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x20;\n      if ( claim_file )\n      {\n        v9 = 0;\n        result = bfd_plugin_open_input((_QWORD *)a2, (__int64)&v10);\n        if ( !(_DWORD)result )\n          return result;\n        v10.handle = (void *)a2;\n        v7 = lseek(v10.fd, 0LL, 1);\n        claim_file(&v10, &v9);\n        lseek(v10.fd, v7, 0);\n        if ( v9 )\n        {\n          *(_BYTE *)(a2 + 72) = *(_BYTE *)(a2 + 72) & 0xCF | 0x10;\n          return 1LL;\n        }\n      }\n    }\n  }\n  return 0LL;\n}\n",
    "source_code": "\nstatic int\ntry_load_plugin (const char *pname, bfd *abfd, int *has_plugin_p)\n{\n  void *plugin_handle;\n  struct ld_plugin_tv tv[4];\n  int i;\n  ld_plugin_onload onload;\n  enum ld_plugin_status status;\n\n  *has_plugin_p = 0;\n\n  plugin_handle = dlopen (pname, RTLD_NOW);\n  if (!plugin_handle)\n    {\n      _bfd_error_handler (\"%s\\n\", dlerror ());\n      return 0;\n    }\n\n  onload = dlsym (plugin_handle, \"onload\");\n  if (!onload)\n    goto err;\n\n  i = 0;\n  tv[i].tv_tag = LDPT_MESSAGE;\n  tv[i].tv_u.tv_message = message;\n\n  ++i;\n  tv[i].tv_tag = LDPT_REGISTER_CLAIM_FILE_HOOK;\n  tv[i].tv_u.tv_register_claim_file = register_claim_file;\n\n  ++i;\n  tv[i].tv_tag = LDPT_ADD_SYMBOLS;\n  tv[i].tv_u.tv_add_symbols = add_symbols;\n\n  ++i;\n  tv[i].tv_tag = LDPT_NULL;\n  tv[i].tv_u.tv_val = 0;\n\n  status = (*onload)(tv);\n\n  if (status != LDPS_OK)\n    goto err;\n\n  *has_plugin_p = 1;\n\n  abfd->plugin_format = bfd_plugin_no;\n\n  if (!claim_file)\n    goto err;\n\n  if (!try_claim (abfd))\n    goto err;\n\n  abfd->plugin_format = bfd_plugin_yes;\n\n  return 1;\n\n err:\n  return 0;\n}",
    "comment": "Loads a plugin from a specified path, initializes it, and claims a file if successful, returning the status of the operation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Determines if a given file is a regular file and retrieves its status using the ` is_file ` function .\n",
    "cpbcs_sum": "Creates a Joliet file or deletes an ISO image, populating metadata and file information based on specified options and options.\n",
    "misum_sum": "Lists available data from a file in user-defined format and optionally adds the information to the specified file descriptor.\n",
    "decom_sum": "Loads a shared library, executes its onload handler, and updates device state flags based on handler results and optional file descriptor operations.",
    "cfg_sum": "Loads a shared library, executes its onload routine, updates status flags, and performs additional initialization with file descriptor state management.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' does not correspond to any specific fact-based claim from the source code. It neither reflects the logic, functions, variables, nor flow of the provided function, making it unrelated and thus inaccurate. No accurate claims are present.",
                "The summary 'push a pointer type.' is vague and unrelated to the actual implementation of the function, which loads a plugin via dlopen, sets up plugin callbacks, invokes an onload function, and manages plugin state. It fails to capture the primary purpose or any secondary details from the source code, making it completely inaccurate and non-informative.",
                "The summary 'push a pointer type.' is extremely vague and does not describe the actual source code, which loads a plugin via dlopen/dlsym, sets up ld_plugin_tv tags, invokes onload, and updates plugin_format based on claim checks. This is pure NOISE, offering no accurate or relevant information about the primary purpose, inputs, outputs, or side effects. The worst failure mode is overwhelming NOISE, resulting in no net benefit."
            ]
        },
        "bint5": {
            "summary": "Determines if a given file is a regular file and retrieves its status using the ` is_file ` function .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function determines if a file is regular and retrieves its status using an `is_file` function, but the source code shows no such operation. Instead, it attempts to load a plugin via `dlopen`, sets up a table of hooks, calls `onload`, and updates `has_plugin_p` and `plugin_format`. None of the described behavior appears in the code, making the claim entirely inaccurate.",
                "The summary claims the function checks if a file is regular and retrieves its status using an `is_file` function, which is unrelated to the actual source code. The source code attempts to dynamically load a plugin, invoke its `onload` callback with specific tag-value pairs, and verify plugin claims, returning success or failure. The summary misses the primary purpose entirely and describes behavior not present in the code.",
                "The summary claims the function checks if a file is regular and retrieves its status using an `is_file` function, which is entirely unrelated to the source code. The source code is about dynamically loading a plugin, setting up a table of hooks, calling the plugin's onload callback, and attempting to claim the file via plugin logic. This is a FATAL inaccuracy concerning the primary purpose, making the summary misleading for understanding the function."
            ]
        },
        "cpbcs": {
            "summary": "Creates a Joliet file or deletes an ISO image, populating metadata and file information based on specified options and options.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about creating a Joliet file or deleting an ISO image are entirely unrelated to the source code, which loads a plugin via dlopen/dlsym, sets up plugin callbacks, invokes the plugin's onload function, and manages the plugin state for a bfd object. None of the summary's details match the actual implementation, resulting in no accurate claims.",
                "The summary claims the function creates a Joliet file or deletes an ISO image, which is entirely unrelated to the source code. The source code attempts to dynamically load a plugin, set up plugin communication structures, invoke the plugin's onload function, and attempt to claim a file via plugin hooks. The summary misses the primary purpose and all secondary details, and introduces incorrect functionality not present in the source.",
                "The summary claims the function creates a Joliet file or deletes an ISO image with metadata handling, which is entirely unrelated to the source code. The source code actually loads a plugin via dlopen/dlsym, sets up plugin interface structures, and attempts to claim a file format. This mismatch is a clear FATAL error affecting the primary purpose and key I/O description, resulting in zero reliable information."
            ]
        },
        "misum": {
            "summary": "Lists available data from a file in user-defined format and optionally adds the information to the specified file descriptor.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes listing data from a file in a user-defined format and adding information to a file descriptor, which does not match the source code's actual functionality of dynamically loading a plugin, initializing plugin callbacks, and attempting to claim a file using the plugin. None of the claims align with the code semantics, resulting in no accurate matches.",
                "The summary describes listing data from a file in a user-defined format and adding information to a file descriptor, which is entirely unrelated to the source code. The source implements loading a plugin via dlopen, initializing a table of plugin hooks, invoking the onload function, handling errors, and setting plugin_format based on claim checks. The summary misses the primary purpose and all secondary details, making its claims inaccurate and disconnected from the actual function behavior.",
                "The summary claims the function lists data from a file in a user-defined format and optionally writes to a file descriptor, which is unrelated to the source code's clear purpose of dynamically loading a plugin, initializing via specific hooks, and attempting to claim a BFD object. This is a FATAL inaccuracy targeting primary purpose and key I/O behavior. There are no accurate claims to provide positive gain, making the content misleading and unreliable."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 333840,
    "strip_function_name": "sub_51810",
    "strip_decompiled_code": "__int64 __fastcall sub_51810(__int64 **a1, __int64 a2)\n{\n  __int64 v2; // r12\n  _QWORD *v4; // rbp\n  __int64 *v5; // rax\n  _QWORD *v6; // rbx\n  __int64 v7; // rdi\n  __int64 v8; // rsi\n  _QWORD *v10; // rax\n\n  if ( !a2 )\n    return 0LL;\n  v2 = a2;\n  if ( a2 != *(_QWORD *)(a2 + 64) )\n  {\n    while ( 1 )\n    {\n      if ( *(_DWORD *)(v2 + 8) == 1 )\n      {\n        v4 = *(_QWORD **)(v2 + 96);\n        if ( v4 )\n          break;\n      }\n      v2 = *(_QWORD *)(v2 + 40);\n      if ( !v2 )\n        return 0LL;\nLABEL_5:\n      if ( v2 == *(_QWORD *)(v2 + 64) )\n        return 0LL;\n    }\n    do\n    {\n      v5 = *a1;\n      if ( *a1 && (v6 = (_QWORD *)*v5) != 0LL )\n      {\n        while ( 1 )\n        {\n          v7 = v4[3];\n          v8 = *(_QWORD *)(v6[3] + 24LL);\n          if ( v7 == v8 || (unsigned int)xmlStrEqual(v7, v8) )\n            break;\n          v6 = (_QWORD *)*v6;\n          if ( !v6 )\n            goto LABEL_13;\n        }\n        v10 = sub_51530(a1, 0, 0LL, (__int64)v4, -1);\n        if ( !v10 )\n          return 0xFFFFFFFFLL;\n        *((_DWORD *)v10 + 8) = 0;\n      }\n      else\n      {\nLABEL_13:\n        if ( !sub_51530(a1, 0, 0LL, (__int64)v4, -1) )\n          return 0xFFFFFFFFLL;\n      }\n      v4 = (_QWORD *)*v4;\n    }\n    while ( v4 );\n    v2 = *(_QWORD *)(v2 + 40);\n    if ( v2 )\n      goto LABEL_5;\n  }\n  return 0LL;\n}\n",
    "function_name": "xmlDOMWrapNSNormGatherInScopeNs",
    "decompiled_code": "int __fastcall xmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map, xmlNodePtr node)\n{\n  xmlNodePtr v2; // r12\n  xmlNs *nsDef; // rbp\n  xmlNsMapPtr v5; // rax\n  _QWORD *p_next; // rbx\n  const xmlChar *prefix; // rdi\n  const xmlChar *v8; // rsi\n  xmlNsMapItemPtr v10; // rax\n\n  if ( !node )\n    return 0;\n  v2 = node;\n  if ( node != (xmlNodePtr)node->doc )\n  {\n    while ( 1 )\n    {\n      if ( v2->type == XML_ELEMENT_NODE )\n      {\n        nsDef = v2->nsDef;\n        if ( nsDef )\n          break;\n      }\n      v2 = v2->parent;\n      if ( !v2 )\n        return 0;\nLABEL_5:\n      if ( v2 == (xmlNodePtr)v2->doc )\n        return 0;\n    }\n    do\n    {\n      v5 = *map;\n      if ( *map && (p_next = &v5->first->next) != 0LL )\n      {\n        while ( 1 )\n        {\n          prefix = nsDef->prefix;\n          v8 = *(const xmlChar **)(p_next[3] + 24LL);\n          if ( prefix == v8 || xmlStrEqual__internal_alias(prefix, v8) )\n            break;\n          p_next = (_QWORD *)*p_next;\n          if ( !p_next )\n            goto LABEL_13;\n        }\n        v10 = xmlDOMWrapNsMapAddItem(map, 0, 0LL, nsDef, -1);\n        if ( !v10 )\n          return -1;\n        v10->shadowDepth = 0;\n      }\n      else\n      {\nLABEL_13:\n        if ( !xmlDOMWrapNsMapAddItem(map, 0, 0LL, nsDef, -1) )\n          return -1;\n      }\n      nsDef = nsDef->next;\n    }\n    while ( nsDef );\n    v2 = v2->parent;\n    if ( v2 )\n      goto LABEL_5;\n  }\n  return 0;\n}\n",
    "source_code": "static int\nxmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map,\n\t\t\t\txmlNodePtr node)\n{\n    xmlNodePtr cur;\n    xmlNsPtr ns;\n    xmlNsMapItemPtr mi;\n    int shadowed;\n\n    if ((map == NULL) || (*map != NULL))\n\treturn (-1);\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))\n        return (-1);\n    /*\n    * Get in-scope ns-decls of @parent.\n    */\n    cur = node;\n    while ((cur != NULL) && (cur != (xmlNodePtr) cur->doc)) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    if (cur->nsDef != NULL) {\n\t\tns = cur->nsDef;\n\t\tdo {\n\t\t    shadowed = 0;\n\t\t    if (XML_NSMAP_NOTEMPTY(*map)) {\n\t\t\t/*\n\t\t\t* Skip shadowed prefixes.\n\t\t\t*/\n\t\t\tXML_NSMAP_FOREACH(*map, mi) {\n\t\t\t    if ((ns->prefix == mi->newNs->prefix) ||\n\t\t\t\txmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n\t\t\t\tshadowed = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t    * Insert mapping.\n\t\t    */\n\t\t    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n\t\t\tns, XML_TREE_NSMAP_PARENT);\n\t\t    if (mi == NULL)\n\t\t\treturn (-1);\n\t\t    if (shadowed)\n\t\t\tmi->shadowDepth = 0;\n\t\t    ns = ns->next;\n\t\t} while (ns != NULL);\n\t    }\n\t}\n\tcur = cur->parent;\n    }\n    return (0);\n}",
    "comment": "Gathers in-scope namespace declarations from the given node's ancestors and updates the namespace mapping, avoiding shadowed prefixes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Traverses a linked list of XML nodes , returning the next valid node , or NULL if no further nodes exist .\n",
    "cpbcs_sum": "Deletes a specified element from the shared memory allocator, ensuring no conflicts with defined namespaces, and parameters.\n",
    "misum_sum": "Recursively frees a linked list of XML RelaxNG nodes, creating a new entity if no references remain.\n",
    "decom_sum": "Traverses linked XML-related structures, matching element names and adding missing entries to a list, returning an error code on insertion failure.",
    "cfg_sum": "Traverses linked XML-related structures, matches element names, and inserts new entries into the target list, returning error or success status accordingly.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains only a vague phrase that does not correspond to any specific fact-based claim about the source code\u2019s functionality. It fails to describe the function\u2019s actual purpose of gathering in-scope namespace declarations or any of its conditions/logic, making it unrelated to the code semantics and therefore inaccurate.",
                "The summary 'push a pointer type.' is vague, does not reflect the actual primary purpose or observable behavior of the function. The source code gathers in-scope namespace declarations for a given node, handles null inputs, skips shadowed prefixes, adds mappings, and returns status codes. None of these details are mentioned, and the key semantics are entirely missed.",
                "The summary contains a vague and generic statement that does not accurately describe the source code\u2019s purpose or functionality. It fails to mention key behaviors such as gathering in-scope namespace declarations, handling shadowed namespaces, or returning status codes. This is pure NOISE with no factual alignment, yielding no useful insight for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Traverses a linked list of XML nodes , returning the next valid node , or NULL if no further nodes exist .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's only claim describes traversing a linked list of XML nodes and returning the next valid node or NULL, which does not match the source code's actual functionality of gathering in-scope namespace declarations and building a namespace map. The claim targets code semantics but is entirely inaccurate, resulting in no accurate claims.",
                "The summary incorrectly describes the function as traversing a linked list of XML nodes to return the next valid node or NULL, which contradicts the source code. The actual purpose is to gather in-scope namespace declarations from an XML node\u2019s ancestors into a namespace map, with specific handling for shadowed prefixes and error conditions. The given summary misses the primary purpose and all key secondary details, making it entirely inaccurate.",
                "The summary incorrectly describes the function as traversing a linked list of XML nodes to return the next valid node or NULL, which contradicts the source code. The actual implementation gathers in-scope namespace declarations from the current node's ancestors into a namespace map, returning -1 on error and 0 on success. This is a FATAL error targeting the primary purpose of the function, making the description highly misleading."
            ]
        },
        "cpbcs": {
            "summary": "Deletes a specified element from the shared memory allocator, ensuring no conflicts with defined namespaces, and parameters.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function deletes a specified element from a shared memory allocator, which is inaccurate because the source code does not involve deletion or shared memory allocation at all. The function instead gathers in-scope namespace declarations from a given XML node and inserts them into a map while handling shadowed prefixes. None of the claims in the summary match the code's actual purpose or behavior, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate \u2014 it claims the function deletes an element from a shared memory allocator, which does not match the source code's primary purpose of gathering in-scope namespace declarations from an XML node hierarchy into a namespace map. It also incorrectly references conflict checks and parameters in a generic way instead of describing the actual shadowing and insertion logic. The primary purpose is missed, and no verifiable secondary details are covered.",
                "The summary is entirely inaccurate: it claims deletion of a specified element from a shared memory allocator, which is unrelated to the actual function. The source implements gathering in-scope XML namespace declarations from a node's ancestry and adding them to a namespace map, with shadowing checks. This false description targets the primary purpose and I/O semantics, constituting a FATAL error. No accurate claims are present, so the net benefit is zero."
            ]
        },
        "misum": {
            "summary": "Recursively frees a linked list of XML RelaxNG nodes, creating a new entity if no references remain.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function frees a linked list of XML RelaxNG nodes and creates a new entity if no references remain, but the source code actually gathers in-scope XML namespace declarations into a map, skipping shadowed prefixes. None of the claims in the summary match the source code's semantics, resulting in no accurate statements.",
                "The summary is entirely inaccurate; it describes freeing XML RelaxNG nodes and creating a new entity, which does not match the source code's actual purpose of gathering in-scope XML namespace declarations into a map while checking for shadowed prefixes. It misses the primary purpose and all secondary details, including input validation, iteration through ancestor nodes, shadowed prefix logic, and return value behavior.",
                "The summary's claims about freeing a linked list of XML RelaxNG nodes and creating a new entity if no references remain are completely unrelated to the source code. The function in the source gathers in-scope XML namespace declarations into a map, with no freeing of nodes or entity creation. This is pure NOISE, overwhelming and targeting incorrect semantics, resulting in zero alignment with the primary purpose and key I/O."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584290608,
    "strip_function_name": "sub_FFFFFFFF81531730",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81531730(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        char *a11)\n{\n  __int64 v12; // r14\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // ebx\n  __int64 v16; // rdx\n  char *v17; // r12\n  _UNKNOWN **v18; // rax\n  unsigned __int8 **v19; // rax\n  __int64 v20; // r15\n  __int64 v22; // [rsp+0h] [rbp-38h]\n\n  v12 = sub_FFFFFFFF813F1610(a1);\n  sub_FFFFFFFF8178FDA0(qword_FFFFFFFF81C7B380);\n  sub_FFFFFFFF8178FDA0(v12 + 224);\n  if ( *(_QWORD *)(v12 + 256) )\n  {\n    strcpy(a11, \"none \");\n    v15 = 5;\n    v16 = 5LL;\n  }\n  else\n  {\n    v16 = 7LL;\n    v15 = 7;\n    *(_QWORD *)a11 = 0x205D656E6F6E5BLL;\n  }\n  v17 = (char *)off_FFFFFFFF81C7B360 - 48;\n  if ( off_FFFFFFFF81C7B360 != (_UNKNOWN *)&off_FFFFFFFF81C7B360 )\n  {\n    do\n    {\n      v19 = *(unsigned __int8 ***)(v12 + 256);\n      v20 = *(_QWORD *)v17;\n      if ( !v19 || (unsigned int)sub_FFFFFFFF812B4D60(*v19, *(_BYTE **)v17) )\n        v15 += sub_FFFFFFFF812B84F0((__int64)&a11[v15], -2120451181LL, a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      else\n        v15 += sub_FFFFFFFF812B84F0((__int64)&a11[v15], (__int64)\"[%s] \", a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      v18 = (_UNKNOWN **)*((_QWORD *)v17 + 6);\n      v17 = (char *)(v18 - 6);\n    }\n    while ( v18 != &off_FFFFFFFF81C7B360 );\n    v16 = v15;\n  }\n  v22 = v16;\n  sub_FFFFFFFF810644A0((volatile signed __int64 *)(v12 + 224));\n  sub_FFFFFFFF810644A0(qword_FFFFFFFF81C7B380);\n  *(_WORD *)&a11[v22] = 10;\n  return v15 + 1;\n}\n",
    "function_name": "led_trigger_show",
    "decompiled_code": "__int64 __fastcall led_trigger_show(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        const char *a10,\n        char *a11)\n{\n  __int64 drvdata; // r14\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // ebx\n  __int64 v16; // rdx\n  char *v17; // r12\n  _UNKNOWN **v18; // rax\n  unsigned __int8 **v19; // rax\n  __int64 v20; // r15\n  __int64 v22; // [rsp+0h] [rbp-38h]\n\n  drvdata = dev_get_drvdata(a1);\n  down_read(triggers_list_lock);\n  down_read((volatile signed __int64 *)(drvdata + 224));\n  if ( *(_QWORD *)(drvdata + 256) )\n  {\n    strcpy(a11, \"none \");\n    v15 = 5;\n    v16 = 5LL;\n  }\n  else\n  {\n    v16 = 7LL;\n    v15 = 7;\n    *(_QWORD *)a11 = 0x205D656E6F6E5BLL;\n  }\n  v17 = (char *)trigger_list - 48;\n  if ( trigger_list != (_UNKNOWN *)&trigger_list )\n  {\n    do\n    {\n      v19 = *(unsigned __int8 ***)(drvdata + 256);\n      v20 = *(_QWORD *)v17;\n      if ( v19 && !(unsigned int)strcmp(*v19, *(_BYTE **)v17) )\n      {\n        a10 = \"[%s] \";\n        v15 += sprintf((__int64)&a11[v15], (__int64)\"[%s] \", a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      }\n      else\n      {\n        a10 = \"  Type:   %s \" + 10;\n        v15 += sprintf((__int64)&a11[v15], -2120451181LL, a2, a3, a4, a5, v13, v14, a8, a9, v20);\n      }\n      v18 = (_UNKNOWN **)*((_QWORD *)v17 + 6);\n      v17 = (char *)(v18 - 6);\n    }\n    while ( v18 != &trigger_list );\n    v16 = v15;\n  }\n  v22 = v16;\n  up_read((volatile signed __int64 *)(drvdata + 224), (__int64)a10);\n  up_read(triggers_list_lock, (__int64)a10);\n  *(_WORD *)&a11[v22] = 10;\n  return v15 + 1;\n}\n",
    "source_code": "\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_trigger *trig;\n\tint len = 0;\n\n\tdown_read(&triggers_list_lock);\n\tdown_read(&led_cdev->trigger_lock);\n\n\tif (!led_cdev->trigger)\n\t\tlen += sprintf(buf+len, \"[none] \");\n\telse\n\t\tlen += sprintf(buf+len, \"none \");\n\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\n\t\t\t\t\t\t\ttrig->name))\n\t\t\tlen += sprintf(buf+len, \"[%s] \", trig->name);\n\t\telse\n\t\t\tlen += sprintf(buf+len, \"%s \", trig->name);\n\t}\n\tup_read(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n\n\tlen += sprintf(len+buf, \"\\n\");\n\treturn len;\n}",
    "comment": "Retrieves the current LED trigger state and lists available triggers, marking the active trigger with brackets in the output buffer.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the name of the current LED device and formats it into the provided buffer , returning `` none '' if no LED exists .\n",
    "cpbcs_sum": "Handles CPU online and offline device wakeup functionality by retrieving device information and managing access with device resource management.\n",
    "misum_sum": "Retrieves and formats the names of active LED information for a USB HID device into a buffer for display.\n",
    "decom_sum": "Builds a formatted status string in `a11` describing connected elements, appending per-item details, and returns its final length including newline.",
    "cfg_sum": "Formats a descriptive status string for a given entity by validating associated data entries, appending details, finalizing output, and returning the total length.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains a vague statement that does not reference or describe the actual functionality of the source code, which involves reading locks, iterating over LED triggers, and formatting output. The claim is unrelated to the code's semantics and is thus entirely inaccurate.",
                "The summary 'push a pointer type' is vague, does not reference the function's primary purpose of generating a formatted string of LED triggers, and misses all observable behaviors and secondary details such as list iteration, lock usage, and conditional formatting. It is unrelated to the source code semantics, making it inaccurate and offering zero coverage.",
                "The summary 'push a pointer type.' does not target the source code's semantics at all, making it a NOISE claim. It ignores the actual function purpose of displaying LED trigger names, locks handling, and buffer writing logic. There is zero accurate, relevant information, resulting in overwhelming noise and no positive gain."
            ]
        },
        "bint5": {
            "summary": "Retrieves the name of the current LED device and formats it into the provided buffer , returning `` none '' if no LED exists .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves the name of the current LED device and returns 'none' if no LED exists, which is misleading. In the source code, the function formats trigger names associated with the LED, not the LED device name itself, and returns '[none]' if no trigger is set, not if no LED exists. This introduces a semantic inaccuracy, making the key claims largely incorrect with respect to the implementation.",
                "The summary incorrectly states that the function retrieves the name of the current LED device and returns 'none' if no LED exists, which contradicts the source code. The code actually lists available LED triggers, marking the active one in brackets, and uses '[none]' or 'none' to indicate whether the device has no active trigger, not whether the LED exists. This misinterprets the PRIMARY PURPOSE and fails to cover secondary details such as iteration through trigger_list, formatting with brackets, and lock handling.",
                "The summary claims the function retrieves the name of the current LED device and returns 'none' if no LED exists, which is inaccurate. The source code actually lists all available LED triggers, marking the active one in brackets and printing '[none]' or 'none' when no trigger is assigned, not when no LED exists. This is a FATAL error targeting the primary purpose and output semantics. There are no accurate claims to offset the error, resulting in high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Handles CPU online and offline device wakeup functionality by retrieving device information and managing access with device resource management.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function handles CPU online/offline wakeup and device resource management, but the source code only formats and lists LED triggers for a device. None of the stated functionalities appear in the implementation, so no claims align with the code.",
                "The summary is entirely inaccurate, describing CPU online/offline wakeup handling and device resource management, which does not match the code's actual functionality of listing LED triggers, formatting their names with selection markers, and returning the buffer length while using read locks. It fails to capture the primary purpose or any secondary details from the source implementation.",
                "The summary's claims about handling CPU online/offline and device wakeup are entirely unrelated to the source code, which manages LED triggers via locking and list traversal. All extracted claims are NOISE, with no factual overlap to the actual function's purpose or I/O. The lack of accurate information means the summary provides zero useful insight and is misleading about the primary purpose."
            ]
        },
        "misum": {
            "summary": "Retrieves and formats the names of active LED information for a USB HID device into a buffer for display.\n",
            "score": [
                0.1,
                0.3,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as retrieving LED information for a USB HID device, which is not present in the source code. The code specifically handles LED trigger names for an LED class device, formatting them into a buffer. The mismatch on device type and focus means the single claim is not aligned with the source implementation.",
                "The summary misidentifies the context, stating it works with a USB HID device, which is not supported by the source code; the function operates on LED class devices. While it vaguely captures that names are formatted into a buffer for display, it fails to mention key aspects like showing the current trigger status, iterating through trigger_list, using locks, and specific output formatting ([none]/none). The primary purpose is partially captured but inaccurately scoped, and most secondary details are missed.",
                "The summary incorrectly claims the function handles active LED information for a USB HID device, which is not supported by the source code. The function instead formats the trigger names for an LED class device regardless of USB HID context. This is a FATAL error targeting the primary purpose and key output, overshadowing any accurate elements. There is no high-gain detail provided, and the core description misleads about the source\u2019s role."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585574304,
    "strip_function_name": "sub_FFFFFFFF8166ADA0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8166ADA0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  unsigned __int64 v10; // r12\n  __int64 v11; // rdx\n  unsigned int v12; // r13d\n  int v13; // r14d\n  __int64 v14; // r15\n  __int64 v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  volatile signed __int32 *v18; // rsi\n  unsigned __int64 v19; // r12\n  volatile signed __int32 *v20; // rax\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n\n  v9 = *(_QWORD *)(a1 + 208);\n  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1000LL);\n  v11 = v9 + *(unsigned int *)(a1 + 188);\n  v12 = *(_DWORD *)(v11 + 12);\n  v13 = *(_DWORD *)(v11 + 16);\n  v14 = *(unsigned int *)(a1 + 184) + v9;\n  sub_FFFFFFFF815CE900(a1, *(_DWORD *)(a1 + 216) - v14);\n  v15 = sub_FFFFFFFF81669B20(v10, v12, v13, __ROL2__(*(_WORD *)(v14 + 4), 8), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 184LL));\n  if ( v15 )\n  {\n    v18 = (volatile signed __int32 *)&qword_20;\n    v19 = v15;\n    v20 = (volatile signed __int32 *)sub_FFFFFFFF815CF750(a1, 0x20u, a2, a3, a4, a5, v16, v17, a8, a9);\n    if ( v20 )\n    {\n      v18 = v20;\n      sub_FFFFFFFF81669C50(v19, v20, a2, a3, a4, a5, v25, v26, a8, a9);\n    }\n    if ( !_InterlockedDecrement((volatile signed __int32 *)(v19 + 76)) )\n      sub_FFFFFFFF815CA7D0(v19, v18, v21, v22, v23, v24, a2, a3, a4, a5, v25, v26, a8, a9);\n  }\n}\n",
    "function_name": "ping_rcv",
    "decompiled_code": "void __fastcall ping_rcv(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  unsigned __int64 v10; // r12\n  __int64 v11; // rdx\n  unsigned int v12; // r13d\n  int v13; // r14d\n  __int64 v14; // r15\n  __int64 v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  void (__fastcall *v18)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double); // rsi\n  __int64 v19; // r12\n  volatile signed __int32 *v20; // rax\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n\n  v9 = *(_QWORD *)(a1 + 208);\n  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1000LL);\n  v11 = v9 + *(unsigned int *)(a1 + 188);\n  v12 = *(_DWORD *)(v11 + 12);\n  v13 = *(_DWORD *)(v11 + 16);\n  v14 = *(unsigned int *)(a1 + 184) + v9;\n  skb_push(a1, *(_DWORD *)(a1 + 216) - v14, a2, a3, a4, a5, a6, a7, a8, a9);\n  v15 = ping_v4_lookup(v10, v12, v13, __ROL2__(*(_WORD *)(v14 + 4), 8), *(_DWORD *)(*(_QWORD *)(a1 + 32) + 184LL));\n  if ( v15 )\n  {\n    v18 = (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))&qword_20;\n    v19 = v15;\n    v20 = (volatile signed __int32 *)skb_clone(a1, 0x20u, a2, a3, a4, a5, v16, v17, a8, a9);\n    if ( v20 )\n    {\n      v18 = (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))v20;\n      ping_queue_rcv_skb(v19, v20, a2, a3, a4, a5, v25, v26, a8, a9);\n    }\n    if ( !_InterlockedDecrement((volatile signed __int32 *)(v19 + 76)) )\n      sk_free(v19, v18, v21, v22, v23, v24, a2, a3, a4, a5, v25, v26, a8, a9);\n  }\n}\n",
    "source_code": "\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t__be32 saddr = iph->saddr;\n\t__be32 daddr = iph->daddr;\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),\n\t\t\t    skb->dev->ifindex);\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}",
    "comment": "Processes received ICMP packets, checks for an associated socket, and queues the packet for delivery if a corresponding socket is found.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes ICMP error messages for ping , updates socket error states , and notifies the appropriate socket if errors are relevant to the connection .\n",
    "cpbcs_sum": "Processes an IPv6 packet, updating its payload length and sending it to the appropriate socket buffer based on the specified source address and size.\n",
    "misum_sum": "Processes an IPv6 packet, updating its headers and potentially sending a processed or ICMP based on the provided socket buffer.\n",
    "decom_sum": "Initializes and retrieves indexed data from a structure, processes it with provided parameters, and releases resources when reference count reaches zero.",
    "cfg_sum": "Processes structured data from memory, executes computation routines, synchronizes shared resources, and conditionally performs cleanup after invoking dependent operations.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains only a vague statement ('push a pointer type') which does not clearly reflect the specific operations in the source code. It omits key facts such as the use of skb_push to restore the ICMP header or the handling of sockets, and thus fails to convey accurate code semantics. This makes it low-information and not clearly aligned with the source implementation.",
                "The summary only states 'push a pointer type,' which is extremely vague and does not convey the primary purpose of the function. It misses key aspects such as handling ICMP echo requests, looking up a socket, queuing the packet, and dropping if no socket is found. The claim lacks specific fact-based coverage and does not align with the source code's semantics.",
                "The summary \"push a pointer type\" is vague and fails to convey the core functionality of the source code. It neither accurately describes the key operations (such as handling ICMP packets, looking up a socket, and queuing received data) nor provides any specific, verifiable detail. This is a NOISE-heavy case with no informative ACCURATE claims, leading to low utility for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Processes ICMP error messages for ping , updates socket error states , and notifies the appropriate socket if errors are relevant to the connection .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes ICMP error messages, updates socket error states, and notifies the socket if errors are relevant to the connection. In reality, the source code handles incoming ICMP echo replies (ping responses), looks up the corresponding socket, queues the received packet, and logs debug information. There is no processing of ICMP errors, no updating of socket error states, nor conditional notification based on connection relevance, making all claims inaccurate relative to the implementation.",
                "The summary incorrectly describes the function as processing ICMP error messages and updating socket error states, which contradicts the source code. The actual implementation handles incoming ICMP echo request/reply packets, looks up the socket via ping_v4_lookup, queues the packet if a matching socket exists, and logs debug messages. No error processing or socket error state updates occur, so the primary purpose is missed entirely.",
                "The summary claims the function processes ICMP error messages, updates socket error states, and notifies sockets for relevant errors. In the source code, the function actually handles incoming ICMP echo (ping) packets, looks up the corresponding socket, queues the received packet, or drops it if no socket exists. All claims in the summary are inaccurate and misrepresent the primary purpose and key I/O, constituting FATAL errors. This creates high negative impact with no accurate details to provide useful insight."
            ]
        },
        "cpbcs": {
            "summary": "Processes an IPv6 packet, updating its payload length and sending it to the appropriate socket buffer based on the specified source address and size.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function processes an IPv6 packet, updates its payload length, and routes it by source address and size. However, the source code clearly handles ICMPv4 packets in ping_rcv and does not relate to IPv6 or payload length updates. None of the stated behaviors align with the implementation, indicating nearly all claims are inaccurate.",
                "The summary incorrectly states the function processes an IPv6 packet, while the source code clearly handles ICMP echo requests for IPv4. It also introduces unrelated details such as updating payload length and basing decisions on packet size, which are not present in the implementation. These inaccuracies mean the primary purpose is missed entirely and no accurate claims align with the code.",
                "The summary contains a FATAL inaccuracy: it claims the function processes an IPv6 packet, but the source code clearly handles IPv4 ICMP packets using iphdr and icmphdr. Additionally, the summary references updating payload length, which is not performed in the function. These errors misrepresent the primary purpose and key I/O of the code, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Processes an IPv6 packet, updating its headers and potentially sending a processed or ICMP based on the provided socket buffer.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function processes an IPv6 packet and updates its headers, but the source code clearly shows it handles IPv4 ICMP echo requests (`struct iphdr *iph = ip_hdr(skb)`) and uses IPv4-specific processing via `ping_v4_lookup`. No IPv6 handling is present. The rest of the summary about potentially sending ICMP is vaguely aligned but mis-scoped to IPv6, making the majority of claims inaccurate.",
                "The summary is inaccurate because the source code handles IPv4 ICMP echo requests, not IPv6 packets. It misses the primary purpose of finding an appropriate socket for the incoming packet and queuing it, as well as details on header manipulation and conditional behavior when no socket is found. The mention of 'potentially sending a processed or ICMP' is vague and incorrect in context, failing to align with any critical semantic units in the code.",
                "The summary contains a FATAL inaccuracy: it claims the function processes an IPv6 packet, while the source code clearly handles IPv4 ICMP echo requests (`ping_rcv` using `ip_hdr`, `icmp_hdr`, and `ping_v4_lookup`). This contradicts the primary purpose and I/O of the function. Additionally, the summary mentions updating headers and sending ICMP responses, which is only partially accurate and misses key details like socket lookup and queuing. Due to the critical semantic mismatch on the protocol type, the description is unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584643232,
    "strip_function_name": "sub_FFFFFFFF815878A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815878A0(\n        unsigned __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  char *v10; // rax\n  __int64 v11; // r12\n  char *v12; // r13\n  __int64 v13; // rdx\n  _QWORD *v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  __int64 *v19; // rdx\n  __int64 v20; // rcx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  double (__fastcall *v25)(unsigned __int64); // rax\n\n  result = 4294967274LL;\n  if ( a1 )\n  {\n    v10 = sub_FFFFFFFF81587760((_BYTE *)(a1 + 12), 0, a2, a3, a4, a5, a6, a7, a8, a9);\n    v11 = (__int64)v10;\n    if ( v10 )\n    {\n      v12 = v10 + 88;\n      sub_FFFFFFFF8178F210(v10 + 88);\n      v13 = *(_QWORD *)(a1 + 160);\n      v14 = *(_QWORD **)(a1 + 168);\n      *(_QWORD *)(v13 + 8) = v14;\n      *v14 = v13;\n      *(_QWORD *)(a1 + 160) = 0xDEAD000000000100LL;\n      *(_QWORD *)(a1 + 168) = 0xDEAD000000000200LL;\n      --*(_DWORD *)(v11 + 80);\n      sub_FFFFFFFF8178F1B0(v12);\n      sub_FFFFFFFF81587620(a1, v11, v15, v16, v17, v18);\n      v25 = *(double (__fastcall **)(unsigned __int64))(a1 + 152);\n      if ( v25 )\n        a2 = v25(a1);\n      sub_FFFFFFFF8112DCD0(a1, a2, a3, a4, a5, v23, v24, a8, a9, v11, v19, v20, v21, v22);\n      sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C813E0);\n      --*(_DWORD *)(v11 + 36);\n      sub_FFFFFFFF8178F1B0(&unk_FFFFFFFF81C813E0);\n      return 0LL;\n    }\n    else\n    {\n      return 4294967290LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "snd_seq_device_free",
    "decompiled_code": "__int64 __fastcall snd_seq_device_free(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  char *driver; // rax\n  __int64 v11; // r12\n  __int64 v12; // r13\n  __int64 v13; // rdx\n  __int64 *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 *v17; // rdx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double (__fastcall *v20)(__int64 *); // rax\n\n  result = 4294967274LL;\n  if ( a1 )\n  {\n    driver = find_driver((__int64 *)((char *)a1 + 12), 0, a2, a3, a4, a5, a6, a7, a8, a9);\n    v11 = (__int64)driver;\n    if ( driver )\n    {\n      v12 = (__int64)(driver + 88);\n      mutex_lock((__int64)(driver + 88));\n      v13 = a1[20];\n      v14 = (__int64 *)a1[21];\n      *(_QWORD *)(v13 + 8) = v14;\n      *v14 = v13;\n      a1[20] = 0xDEAD000000000100LL;\n      a1[21] = 0xDEAD000000000200LL;\n      --*(_DWORD *)(v11 + 80);\n      mutex_unlock(v12);\n      free_device((__int64)a1, v11, a2, a3, a4, a5, v15, v16, a8, a9);\n      v20 = (double (__fastcall *)(__int64 *))a1[19];\n      if ( v20 )\n        a2 = v20(a1);\n      kfree(a1, a2, a3, a4, a5, v18, v19, a8, a9, v11, v17);\n      mutex_lock((__int64)&ops_mutex);\n      --*(_DWORD *)(v11 + 36);\n      mutex_unlock((__int64)&ops_mutex);\n      return 0LL;\n    }\n    else\n    {\n      return 4294967290LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "static int snd_seq_device_free(struct snd_seq_device *dev)\n{\n\tstruct ops_list *ops;\n\n\tif (snd_BUG_ON(!dev))\n\t\treturn -EINVAL;\n\n\tops = find_driver(dev->id, 0);\n\tif (ops == NULL)\n\t\treturn -ENXIO;\n\n\t/* remove the device from the list */\n\tmutex_lock(&ops->reg_mutex);\n\tlist_del(&dev->list);\n\tops->num_devices--;\n\tmutex_unlock(&ops->reg_mutex);\n\n\tfree_device(dev, ops);\n\tif (dev->private_free)\n\t\tdev->private_free(dev);\n\tkfree(dev);\n\n\tunlock_driver(ops);\n\n\treturn 0;\n}",
    "comment": "Frees a sequencer device by removing it from the list, releasing resources, and invoking the device's private cleanup function if defined.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Unregisters a synthesizer device from the system , updates the synth device list , and frees associated memory resources .\n",
    "cpbcs_sum": "Unregisters a sound sequence driver by removing it from the list, releasing resources, and removing it from the system.\n",
    "misum_sum": "Unregisters a sound card's audio driver, allocating resources and ensuring proper synchronization with resource management.\n",
    "decom_sum": "Initializes and links an object from a given handle, updates related structures, invokes callbacks, and finalizes state before returning a status code.",
    "cfg_sum": "Initializes and updates an object\u2019s internal links and counters, invokes an optional callback, performs cleanup, and returns a status based on processing success.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains mathematical notation unrelated to the source code, which implements a function for freeing a snd_seq_device structure with mutex locking, list removal, and memory cleanup. None of the claims in the summary reflect any aspect of the code, making all claims inaccurate.",
                "The summary does not contain any fact-based claims about the source code; instead, it presents unrelated mathematical notation. This means it entirely misses the primary purpose of the function, which is to free a sequencer device with associated error handling and resource cleanup, and does not capture any secondary implementation details. The lack of alignment results in no coverage of the CSU_LIST.",
                "The summary contains only a mathematical expression unrelated to the source code semantics. It does not describe the function's primary purpose, I/O, or side effects, resulting in 100% NOISE and no ACCURATE claims. This provides no insight or utility for understanding the implementation."
            ]
        },
        "bint5": {
            "summary": "Unregisters a synthesizer device from the system , updates the synth device list , and frees associated memory resources .\n",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly captures that the function removes a device from a list and frees associated memory, both of which are shown in the code. However, it inaccurately specifies this as a 'synthesizer device' and 'system unregister', which are not confirmed in the source\u2014code refers to a generic snd_seq_device and operates within a driver context. This introduces semantic mismatch, lowering accuracy despite some correct elements.",
                "The summary correctly identifies the primary purpose as removing a device from the system and freeing associated resources, which aligns with the code's function to delete the device from the list and deallocate memory. However, it generalizes the type of device as a 'synthesizer' rather than the 'sequencer device' indicated in the code, which is slightly inaccurate. It also omits secondary details such as input validation with error returns (-EINVAL, -ENXIO), synchronization via mutex, decrementing the device count, invoking a potential private cleanup function, and unlocking the driver. Overall, the primary purpose is captured but important secondary details are missing.",
                "The summary contains mostly accurate generalizations: it describes unregistering a device, updating a device list, and freeing memory, which match the source code flow. However, it inaccurately specifies the device as a 'synthesizer device', which is not indicated in the source\u2014it is a generic sequencer device. This is a FATAL error targeting the primary purpose, because misidentifying the device type could mislead about the function\u2019s application. The rest of the claims are broad and low-detail, providing little technical insight beyond obvious memory management steps."
            ]
        },
        "cpbcs": {
            "summary": "Unregisters a sound sequence driver by removing it from the list, releasing resources, and removing it from the system.\n",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims that the function unregisters a sound sequence driver, but in the source code it specifically frees a snd_seq_device instance, not a driver. While it correctly mentions removing from a list and releasing resources, the 'removing it from the system' and 'unregisters driver' parts are inaccurate to code semantics. This results in less than half of the claims being accurate.",
                "The summary captures the primary purpose broadly\u2014removing a device from a list and releasing resources\u2014but inaccurately frames it as unregistering a sound sequence driver and removing it from the system. The implementation actually unregisters a specific sound sequence device, not the driver, and it includes important secondary details such as input validation, error handling for missing driver ops, mutex locking, decrementing the device count, freeing private resources, and unlocking the driver, which are entirely omitted. This leads to incomplete and partially misleading coverage.",
                "The summary states that the function unregisters a sound sequence driver, which is inaccurate because the code actually frees a specific snd_seq_device instance rather than a driver. This is a FATAL error targeting the primary purpose, as it misidentifies the core operation. While the summary correctly mentions removing from a list and releasing resources, the main subject mismatch reduces reliability significantly."
            ]
        },
        "misum": {
            "summary": "Unregisters a sound card's audio driver, allocating resources and ensuring proper synchronization with resource management.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains a major inaccuracy: the function actually frees and unregisters a sequencer device rather than a sound card\u2019s audio driver, and it releases rather than allocates resources. While it correctly hints at synchronization via mutex locks, most claims are either misaligned with the code semantics or overly vague. Less than half of the claims are accurate.",
                "The summary states that the function unregisters a sound card's audio driver and allocates resources, which is inaccurate: the source code shows the function frees a sequencer device, removes it from a list, decrements device count, releases resources, and calls optional private cleanup. It does involve synchronization with a mutex, but there is no resource allocation\u2014only freeing\u2014so the primary purpose is misrepresented. This results in missing the accurate primary purpose and most secondary details.",
                "The summary inaccurately describes the function as unregistering a sound card's audio driver and allocating resources, which contradicts the source code. The code actually frees a sequencer device, ensures synchronization with a mutex, removes it from the list, and deallocates resources. The mention of 'allocating resources' is incorrect because the function performs deallocation. This is a FATAL in terms of describing the primary purpose and side effects. There are no highly specific accurate claims to offset the inaccuracy, leading to high negative impact."
            ]
        }
    }
}
{
    "project_name": "gettext",
    "function_addr": 38736,
    "strip_function_name": "sub_9750",
    "strip_decompiled_code": "void __fastcall sub_9750(__int64 a1)\n{\n  int v1; // ebp\n  size_t v2; // r12\n  const void *v3; // r14\n  __int64 v4; // rax\n  __int64 v5; // r13\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  unsigned int v8; // esi\n\n  v1 = *(_DWORD *)(a1 + 24);\n  if ( v1 != 1 )\n  {\nLABEL_2:\n    if ( v1 == -1 )\n      return;\n    goto LABEL_3;\n  }\n  v8 = *(unsigned __int16 *)(a1 + 56);\n  if ( (_WORD)v8 )\n  {\n    sub_9650((_QWORD *)a1, v8);\n    v1 = *(_DWORD *)(a1 + 24);\n    *(_WORD *)(a1 + 56) = 0;\n    goto LABEL_2;\n  }\nLABEL_3:\n  v2 = *(_QWORD *)(a1 + 40);\n  if ( v2 )\n  {\n    v3 = *(const void **)(a1 + 32);\n    v4 = xmalloc();\n    *(_BYTE *)v4 = v1;\n    *(_QWORD *)(v4 + 8) = v2;\n    v5 = v4;\n    memcpy((void *)(v4 + 16), v3, v2);\n    v6 = *(_QWORD *)(a1 + 8);\n    if ( v6 == *(_QWORD *)(a1 + 16) )\n    {\n      *(_QWORD *)(a1 + 16) = 2 * v6 + 1;\n      v7 = xrealloc();\n      v6 = *(_QWORD *)(a1 + 8);\n      *(_QWORD *)a1 = v7;\n    }\n    else\n    {\n      v7 = *(_QWORD *)a1;\n    }\n    *(_QWORD *)(a1 + 8) = v6 + 1;\n    *(_QWORD *)(v7 + 8 * v6) = v5;\n  }\n  *(_QWORD *)(a1 + 40) = 0LL;\n}\n",
    "function_name": "mixed_string_buffer_flush_curr",
    "decompiled_code": "void __fastcall mixed_string_buffer_flush_curr(mixed_string_buffer *bp_0)\n{\n  int curr_type; // ebp\n  size_t curr_buflen; // r12\n  char *curr_buffer; // r14\n  __int64 v5; // rax\n  mixed_string_segment *v6; // r13\n  size_t nsegments; // rdx\n  mixed_string_segment **v8; // rax\n  ucs4_t utf16_surr; // esi\n  size_t v10; // rsi\n  mixed_string_segment **segments; // rdi\n\n  curr_type = bp_0->curr_type;\n  if ( curr_type != 1 )\n  {\nLABEL_2:\n    if ( curr_type == -1 )\n      return;\n    goto LABEL_3;\n  }\n  utf16_surr = bp_0->utf16_surr;\n  if ( (_WORD)utf16_surr )\n  {\n    mixed_string_buffer_append_lone_surrogate(bp_0, utf16_surr);\n    curr_type = bp_0->curr_type;\n    bp_0->utf16_surr = 0;\n    goto LABEL_2;\n  }\nLABEL_3:\n  curr_buflen = bp_0->curr_buflen;\n  if ( curr_buflen )\n  {\n    curr_buffer = bp_0->curr_buffer;\n    v5 = ((__int64 (__fastcall *)(size_t))xmalloc)((curr_buflen + 23) & 0xFFFFFFFFFFFFFFF8LL);\n    *(_BYTE *)v5 = curr_type;\n    *(_QWORD *)(v5 + 8) = curr_buflen;\n    v6 = (mixed_string_segment *)v5;\n    memcpy((void *)(v5 + 16), curr_buffer, curr_buflen);\n    nsegments = bp_0->nsegments;\n    if ( nsegments == bp_0->nsegments_allocated )\n    {\n      v10 = 2 * nsegments + 1;\n      segments = bp_0->segments;\n      bp_0->nsegments_allocated = v10;\n      v8 = (mixed_string_segment **)((__int64 (__fastcall *)(mixed_string_segment **, size_t))xrealloc)(\n                                      segments,\n                                      8 * v10);\n      nsegments = bp_0->nsegments;\n      bp_0->segments = v8;\n    }\n    else\n    {\n      v8 = bp_0->segments;\n    }\n    bp_0->nsegments = nsegments + 1;\n    v8[nsegments] = v6;\n  }\n  bp_0->curr_buflen = 0LL;\n}\n",
    "source_code": "static void\nmixed_string_buffer_flush_curr (struct mixed_string_buffer *bp)\n{\n  if (bp->curr_type == utf8_encoded)\n    mixed_string_buffer_flush_utf16_surr (bp);\n  if (bp->curr_type != -1)\n    {\n      if (bp->curr_buflen > 0)\n        {\n          struct mixed_string_segment *segment =\n            segment_alloc (bp->curr_type, bp->curr_buffer, bp->curr_buflen);\n          mixed_string_buffer_add_segment (bp, segment);\n        }\n      bp->curr_buflen = 0;\n    }\n}",
    "comment": "Flushes the current buffer to segments based on its type, handling UTF-8 encoding and resetting the buffer length after addition.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Splits a word or segment from a node in a wordsplit structure , reallocating memory as needed , and clears the segment 's properties .\n",
    "cpbcs_sum": "Appends a unique lines to a dynamically allocated buffer, resizing it as necessary to accommodate the new entry from the stack.\n",
    "misum_sum": "Dynamically adds a new token to the end of a dynamic array, expanding memory if necessary, and handles memory allocation errors.\n",
    "decom_sum": "Constructs and stores a heap-allocated record containing a status byte and copied payload into a dynamically resized queue, resetting temporary state fields.",
    "cfg_sum": "Processes queued data by clearing flags, allocating and copying payload into a dynamic array, expanding storage as needed, and resetting the buffer pointer.",
    "work_score": {
        "hext5": {
            "summary": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes generating a random wiping pass pattern in two stages, which is unrelated to the provided source code that flushes a mixed string buffer, handles UTF-16 surrogate flushing, and manages string segments. None of the claims in the summary match or safely describe the source implementation, resulting in no accurate claims.",
                "The summary describes generating a random wiping pass pattern with selection and shuffling, which is entirely unrelated to the source code. The source function flushes a mixed string buffer, handling UTF-16 surrogates, segment allocation, buffer addition, and resetting length. The summary misses the primary purpose and all key secondary details, making the claims inaccurate and irrelevant to the code's semantics.",
                "The summary describes generating a random wiping pass pattern with multiple passes, which is entirely unrelated to the actual source code that flushes a mixed string buffer and adds segments based on its current type and buffer length. This is pure NOISE without any accurate claims, offering no insight into the actual function."
            ]
        },
        "bint5": {
            "summary": "Splits a word or segment from a node in a wordsplit structure , reallocating memory as needed , and clears the segment 's properties .\n",
            "score": [
                0.1,
                0.0,
                0.2
            ],
            "reason": [
                "The summary discusses splitting a word or segment and reallocating memory in a wordsplit structure, which has no relation to the provided function. The source code focuses on flushing a mixed string buffer, handling UTF-8 and UTF-16 segments, and resetting buffer length. Since none of the summary claims match these operations, almost all claims are inaccurate.",
                "The summary describes splitting a word or segment in a wordsplit structure, reallocating memory, and clearing properties, which does not reflect the source code's primary purpose of flushing the current buffer in a mixed_string_buffer, conditionally converting UTF-8 to UTF-16 surrogate form, creating a segment from existing buffer contents, adding it to the buffer, and resetting the buffer length. None of the summary's claims align with the actual code, resulting in no coverage of primary purpose or secondary details.",
                "The summary describes splitting a word or segment from a wordsplit structure, reallocating memory, and clearing segment properties, which does not match the source code\u2019s actual purpose of flushing the current buffer in a mixed_string_buffer by possibly handling UTF-16 surrogate flushing, allocating a segment, adding it, and resetting buffer length. This is a semantic mismatch targeting the function\u2019s primary purpose, making it a FATAL inaccuracy with no accurate claims and high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Appends a unique lines to a dynamically allocated buffer, resizing it as necessary to accommodate the new entry from the stack.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes appending unique lines to a dynamically allocated buffer and resizing it, which is not reflected in the source code. The source code flushes a mixed string buffer, conditionally processes UTF-16 surrogate sequences, allocates a segment, and resets the buffer length. None of the specific actions in the summary match the actual implementation, making all claims inaccurate.",
                "The summary's claim about appending unique lines to a dynamically allocated buffer and resizing from the stack is unrelated to the source code's actual behavior. The source function flushes the current buffer segment based on its type, potentially handling UTF-16 surrogates, allocating a segment, adding it to a buffer, and resetting length. It misses the primary purpose and specifics of the code, making the claim inaccurate and non-covering.",
                "The summary claims the function appends unique lines to a dynamically allocated buffer, resizing it as necessary and pulling from a stack. This is entirely inaccurate: the source code flushes the current buffer contents into segments based on the current type, optionally handling UTF-8 surrogate pairs, and does not involve unique lines, resizing logic, or a stack. This is a FATAL error because it misrepresents the primary purpose and key I/O behavior."
            ]
        },
        "misum": {
            "summary": "Dynamically adds a new token to the end of a dynamic array, expanding memory if necessary, and handles memory allocation errors.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes adding a token to a dynamic array with possible memory expansion and error handling, which does not align with the source code's actual behavior of flushing a mixed string buffer, converting certain encodings, and adding segments without explicit dynamic memory expansion logic or error handling mentioned. None of the claims are accurate relative to the source code.",
                "The summary describes adding a token to a dynamic array with memory expansion and error handling, which is entirely unrelated to the source code. The actual function flushes the current buffer in a mixed string buffer, handles UTF-16 surrogate flushing if UTF-8 encoded, allocates a segment when buffer length > 0, and resets the buffer length. It does not involve dynamic array expansion or memory allocation error handling. The primary purpose is missed and all claims are inaccurate.",
                "The summary's claims about adding a token to a dynamic array, memory expansion, and allocation error handling are entirely unrelated to the actual code, which flushes a mixed string buffer, processes UTF-16 surrogates, and adds string segments. This represents pure NOISE with no accurate statements about the source code, providing zero relevant insight."
            ]
        }
    }
}
{
    "project_name": "a2ps",
    "function_addr": 4219952,
    "strip_function_name": "sub_406430",
    "strip_decompiled_code": "_QWORD *__fastcall sub_406430(char *src)\n{\n  _QWORD *v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rax\n  _QWORD *v4; // rbp\n  __int64 v5; // rax\n  __int64 v6; // r13\n  __int64 v7; // rax\n  _QWORD *v8; // rax\n  __int64 v9; // rax\n  __int64 v10; // r13\n  __int64 v11; // rax\n  _QWORD *v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // r13\n  __int64 v15; // rax\n  _QWORD *v16; // rax\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  __int64 v19; // rbp\n  __int64 v20; // rax\n  _QWORD *v21; // rax\n\n  v1 = sub_432EA0(32LL);\n  v2 = sub_405DD0(0LL, 0, qword_657768);\n  v3 = sub_438B00(src);\n  *v1 = sub_405CC0(v3, v2);\n  v1[1] = qword_657330;\n  v4 = sub_4061B0((__int64)\"C usual exceptions: strings\", (__int64)\"C usual exceptions: regexps\", 3LL, 3LL);\n  v5 = sub_438B00(\"\\\\'\");\n  v6 = sub_405DD0(v5, 0, qword_657330);\n  v7 = sub_438B00(\"\\\\'\");\n  v8 = sub_405CC0(v7, v6);\n  sub_434A00(*v4, v8);\n  v9 = sub_438B00(\"\\\\\\\\\");\n  v10 = sub_405DD0(v9, 0, qword_657330);\n  v11 = sub_438B00(\"\\\\\\\\\");\n  v12 = sub_405CC0(v11, v10);\n  sub_434A00(*v4, v12);\n  v13 = sub_438B00(\"\\\\\\\"\");\n  v14 = sub_405DD0(v13, 0, qword_657330);\n  v15 = sub_438B00(\"\\\\\\\"\");\n  v16 = sub_405CC0(v15, v14);\n  sub_434A00(*v4, v16);\n  sub_405930(v4);\n  v1[2] = v4;\n  v17 = sub_4061B0((__int64)\"C Close: strings\", (__int64)\"C Close: regex\", 5LL, 5LL);\n  v18 = qword_657768;\n  v1[3] = v17;\n  v19 = sub_405DD0(0LL, 0, v18);\n  v20 = sub_438B00(src);\n  v21 = sub_405CC0(v20, v19);\n  sub_434A00(*(_QWORD *)v1[3], v21);\n  sub_405930((_QWORD *)v1[3]);\n  return v1;\n}\n",
    "function_name": "new_C_string_sequence",
    "decompiled_code": "sequence *new_C_string_sequence()\n{\n  void *v0; // rbx\n  darray *v1; // rbp\n  unsigned __int8 *v2; // rax\n  darray *v3; // rdx\n  const char *v4; // rcx\n  size_t v5; // r8\n  words *v6; // rbp\n  char *v7; // rax\n  darray *v8; // r13\n  unsigned __int8 *v9; // rax\n  darray *v10; // rdx\n  const char *v11; // rcx\n  size_t v12; // r8\n  rule *v13; // rax\n  char *v14; // rax\n  darray *v15; // r13\n  unsigned __int8 *v16; // rax\n  darray *v17; // rdx\n  const char *v18; // rcx\n  size_t v19; // r8\n  rule *v20; // rax\n  char *v21; // rax\n  darray *v22; // r13\n  unsigned __int8 *v23; // rax\n  darray *v24; // rdx\n  const char *v25; // rcx\n  size_t v26; // r8\n  rule *v27; // rax\n  words *v28; // rax\n  const char *v29; // rdx\n  darray *v30; // rbp\n  unsigned __int8 *v31; // rax\n  darray *v32; // rdx\n  const char *v33; // rcx\n  size_t v34; // r8\n  rule *v35; // rax\n\n  v0 = xmalloc(0x20uLL);\n  v1 = rhs_new_single(0LL, da_growth::da_steady, *(const char **)&Plain_fface);\n  v2 = (unsigned __int8 *)xstrdup((const char *)v0);\n  *(_QWORD *)v0 = rule_new_0(v2, v1, v3, v4, v5);\n  *((fface_s *)v0 + 1) = String_fface;\n  v6 = words_new(0x43D522uLL, (da_growth)4445446, 3uLL, (const char *)3);\n  v7 = xstrdup((const char *)v0);\n  v8 = rhs_new_single((size_t)v7, da_growth::da_steady, *(const char **)&String_fface);\n  v9 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v13 = rule_new_0(v9, v8, v10, v11, v12);\n  da_append((darray *)v0, v13);\n  v14 = xstrdup((const char *)v0);\n  v15 = rhs_new_single((size_t)v14, da_growth::da_steady, *(const char **)&String_fface);\n  v16 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v20 = rule_new_0(v16, v15, v17, v18, v19);\n  da_append((darray *)v0, v20);\n  v21 = xstrdup((const char *)v0);\n  v22 = rhs_new_single((size_t)v21, da_growth::da_steady, *(const char **)&String_fface);\n  v23 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v27 = rule_new_0(v23, v22, v24, v25, v26);\n  da_append((darray *)v0, v27);\n  words_finalize(&v6->strings);\n  *((_QWORD *)v0 + 2) = v6;\n  v28 = words_new(0x43D556uLL, (da_growth)4445511, 5uLL, (const char *)5);\n  v29 = (const char *)Plain_fface;\n  *((_QWORD *)v0 + 3) = v28;\n  v30 = rhs_new_single(0LL, da_growth::da_steady, v29);\n  v31 = (unsigned __int8 *)xstrdup((const char *)v0);\n  v35 = rule_new_0(v31, v30, v32, v33, v34);\n  da_append((darray *)v0, v35);\n  words_finalize(*((darray ***)v0 + 3));\n  return (sequence *)v0;\n}\n",
    "source_code": "\nstruct sequence *\nnew_C_string_sequence (const char * delimitor)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n  res->open = rule_new (xustrdup (delimitor), NULL,\n\t\t\trhs_new_single (NULL, 0, Plain_fface),\n\t\t\t__FILE__, __LINE__);\n  res->face = String_fface;\n  res->exceptions = new_C_exceptions ();\n  res->close = words_new (\"C Close: strings\", \"C Close: regex\", 5, 5);\n  words_add_string (res->close,\n\t\t    rule_new (xustrdup (delimitor), NULL,\n\t\t\t      rhs_new_single (NULL, 0, Plain_fface),\n\t\t\t      __FILE__, __LINE__));\n  words_finalize (res->close);\n  return res;\n}",
    "comment": "Creates and initializes a new string sequence structure with a specified delimiter and associated rules for processing strings.",
    "hext5_sum": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
    "bint5_sum": "Creates and initializes a new buffer state for reading input from a specified file .\n",
    "cpbcs_sum": "Initializes a new symbol table for a Debian rule and registers it for use in the ELF file.\n",
    "misum_sum": "Creates and initializes a new symbol table, linking various symbol tables, and managing memory for string variables and string encoding.\n",
    "decom_sum": "Builds and returns a parser configuration for C strings and regex, including escape sequence handling and closing rules based on the provided source pattern.",
    "cfg_sum": "Constructs and returns a structured set of C-language parsing rules, including escape sequence handling and opening/closing string and regex delimiters, from the given input.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about pushing a pointer, use as an engine for ctf_type_visit, resolving input types, recursively visiting struct/union members, and invoking callbacks do not match the source code, which defines a function allocating and initializing a 'struct sequence' with specific fields. None of the claims accurately reflect the actual implementation, resulting in no accurate matches.",
                "The summary describes behavior related to type visiting, recursion over struct/union members, and callback invocation\u2014none of which are present in the source code. The actual implementation allocates and initializes a 'sequence' struct with specific faces, rules, exceptions, and string closers, which is entirely unrelated to the described summary. As a result, no claims in the summary are accurate or aligned with the source\u2019s primary purpose or secondary details.",
                "The summary's claims describe behavior related to type visiting, recursion over struct/union members, and callback invocation, none of which are present in the provided source code. The actual function allocates and initializes a 'struct sequence' for handling delimited strings, with no type resolution or recursive member traversal. All claims are inaccurate and unrelated to the source code, representing overwhelming NOISE with zero accurate alignment, leading to no useful insight for understanding the implementation."
            ]
        },
        "bint5": {
            "summary": "Creates and initializes a new buffer state for reading input from a specified file .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes a buffer for reading input from a file, but the source code actually creates and initializes a 'sequence' structure related to string delimiters. None of the factual elements in the summary align with the code, leading to a complete mismatch between the description and implementation.",
                "The summary incorrectly describes the function as creating and initializing a buffer state for reading from a file, which contradicts the source code. The function actually constructs and initializes a 'sequence' object for handling strings with a specified delimiter, setting up rules, faces, exceptions, and closing words. The claimed file-reading behavior is unrelated to the implementation, missing the primary purpose entirely.",
                "The summary incorrectly describes the function as creating a buffer state for reading from a file, which contradicts the source code. The function actually allocates and initializes a 'sequence' structure with elements for string parsing and delimiter handling. This is a FATAL inaccuracy about the primary purpose and I/O. There are no accurate or detailed claims, so the overall benefit is negative."
            ]
        },
        "cpbcs": {
            "summary": "Initializes a new symbol table for a Debian rule and registers it for use in the ELF file.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary\u2019s claims about initializing a symbol table for a Debian rule and registering it for use in an ELF file do not match the source code, which creates a new C string sequence with opening and closing rules and exceptions. None of the claims are supported by the code, indicating a complete mismatch with the actual implementation.",
                "The summary describes initializing a symbol table for a Debian rule and registering it in an ELF file, which is not represented in the source code. The source function actually allocates and initializes a `struct sequence` with specific rule and face settings, exception handling, and closing words based on a delimiter. The provided summary misses the primary purpose and all key secondary details, and instead introduces unrelated concepts, making its claims inaccurate.",
                "The summary contains only inaccurate claims. It states that the function initializes a symbol table for a Debian rule and registers it for use in an ELF file, which is unrelated to the actual source code. The source code creates a new C string sequence structure with rules, faces, and exceptions, with no mention of symbol tables, Debian rules, or ELF files. These are FATAL inaccuracies about the primary purpose of the function, leading to a high negative impact and making the summary unreliable."
            ]
        },
        "misum": {
            "summary": "Creates and initializes a new symbol table, linking various symbol tables, and managing memory for string variables and string encoding.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function creates and initializes a new symbol table, links symbol tables, and manages memory for string variables and encoding. The source code shows creation of a struct sequence related to handling delimiters, string faces, exceptions, and close rules\u2014no symbol table logic or string encoding management is present. All claims are inaccurate and unrelated to the actual implementation, resulting in no accurate matches.",
                "The summary's claims about creating and initializing a symbol table, linking symbol tables, and managing memory for string variables/encoding do not match the source code. The source code actually allocates and initializes a struct sequence with specific faces, rules, exceptions, and words, not any symbol table logic. The primary purpose and secondary details of the function are entirely missed, and none of the claims are accurate or relevant to the code's semantics.",
                "The summary claims the function creates and initializes a symbol table, links symbol tables, and manages memory for string variables and encoding, which are entirely unrelated to the source code. The actual code initializes a 'sequence' struct with rules, faces, exceptions, and close words based on a delimiter. These are FATAL inaccuracies targeting the primary purpose and key I/O of the function, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5157392,
    "strip_function_name": "sub_4EB210",
    "strip_decompiled_code": "__int64 __fastcall sub_4EB210(_DWORD *a1, int *a2, _QWORD *a3, int *a4, _DWORD *a5, _DWORD *a6)\n{\n  int v6; // eax\n  unsigned int v7; // r10d\n  __int64 result; // rax\n  _BYTE *v13; // rdi\n  unsigned int v14; // [rsp+Ch] [rbp-3Ch]\n  int v15; // [rsp+14h] [rbp-34h] BYREF\n  void *ptr; // [rsp+18h] [rbp-30h] BYREF\n\n  v6 = a1[70];\n  ptr = 0LL;\n  if ( (v6 & 0xFFFFFFBF) == 0x11 || (v7 = v6 - 19, result = 0LL, v7 <= 2) )\n  {\n    result = sub_4EA980(a1, 0, 0LL, 16, 12, &ptr, &v15);\n    v13 = ptr;\n    if ( (int)result > 0 )\n    {\n      if ( v15 > 11 )\n      {\n        v13 = ptr;\n        result = 16LL * (*(_BYTE *)ptr >> 4);\n        *a2 = *(_BYTE *)ptr >> 4;\n        *a3 = result + 7804000;\n        *a4 = *v13 & 0xF;\n        *a5 = (((char)v13[2] >> 5) & 3) + 1;\n        *a6 = ((char)v13[11] | ((char)v13[10] << 8) | ((char)v13[9] << 16))\n            - ((char)v13[7] | ((char)v13[6] << 8) | ((char)v13[5] << 16))\n            + 1;\n        LODWORD(result) = 1;\nLABEL_6:\n        v14 = result;\n        free(v13);\n        return v14;\n      }\n      sub_4E28D0(qword_8182E0, -1, 2, 0x10000000, 0, \"READ DISC STRUCTURE format 10h: Less than 12 bytes\", 0, 0);\n      v13 = ptr;\n      result = 0LL;\n    }\n    if ( v13 )\n      goto LABEL_6;\n  }\n  return result;\n}\n",
    "function_name": "mmc_get_phys_format_info",
    "decompiled_code": "int __fastcall mmc_get_phys_format_info(\n        burn_drive *d,\n        int *disk_category,\n        char **book_name,\n        int *part_version,\n        int *num_layers,\n        int *num_blocks,\n        int flag)\n{\n  int current_profile; // eax\n  unsigned int v8; // r10d\n  int result; // eax\n  char *v14; // rdi\n  __int64 v15; // rax\n  int v16; // [rsp+Ch] [rbp-3Ch]\n  int reply_len; // [rsp+14h] [rbp-34h] BYREF\n  char *reply; // [rsp+18h] [rbp-30h] BYREF\n\n  current_profile = d->current_profile;\n  reply = 0LL;\n  if ( (current_profile & 0xFFFFFFBF) == 0x11 || (v8 = current_profile - 19, result = 0, v8 <= 2) )\n  {\n    result = mmc_read_disc_structure(d, 0, 0LL, 0x10u, 12, &reply, &reply_len);\n    v14 = reply;\n    if ( result > 0 )\n    {\n      if ( reply_len > 11 )\n      {\n        v14 = reply;\n        v15 = 16LL * ((unsigned __int8)*reply >> 4);\n        *disk_category = (unsigned __int8)*reply >> 4;\n        *book_name = (char *)(v15 + 7804000);\n        *part_version = *v14 & 0xF;\n        *num_layers = ((v14[2] >> 5) & 3) + 1;\n        *num_blocks = (v14[11] | (v14[10] << 8) | (v14[9] << 16)) - (v14[7] | (v14[6] << 8) | (v14[5] << 16)) + 1;\n        result = 1;\nLABEL_6:\n        v16 = result;\n        free(v14);\n        return v16;\n      }\n      libdax_msgs_submit(libdax_messenger, -1, 2, 0x10000000, 0, (const XorrisO *)&byte_523516[2618], 0, 0LL);\n      v14 = reply;\n      result = 0;\n    }\n    if ( v14 )\n      goto LABEL_6;\n  }\n  return result;\n}\n",
    "source_code": "int mmc_get_phys_format_info(struct burn_drive *d, int *disk_category,\n\t\t\tchar **book_name, int *part_version, int *num_layers,\n\t\t\tint *num_blocks, int flag)\n{\n\tint ret, reply_len, prf;\n\tchar *reply = NULL;\n\tstatic char book_names[][16] = {\n\t\t\"DVD-ROM\", \"DVD-RAM\", \"DVD-R\", \"DVD-RW\",\n\t\t\"HD DVD-ROM\", \"HD DVD-RAM\", \"HD DVD-R\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW\", \"DVD+R\", \"unknown\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW DL\", \"DVD+R DL\", \"unknown\"\n\t};\n\n\tprf = d->current_profile;\n\tif (!(prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15 ||\n\t      prf == 0x51))\n\t\treturn 0; /* Not a [HD] DVD-R[W] loaded */\n\tret = mmc_read_disc_structure(d, 0, 0, 0x10, 12, &reply,\n\t\t\t\t\t\t\t &reply_len, 0);\n\tif (ret <= 0)\n\t\tgoto ex;\n\tif(reply_len < 12) {\n\t\tlibdax_msgs_submit(libdax_messenger, -1, 0x00000002,\n\t\t\tLIBDAX_MSGS_SEV_DEBUG, LIBDAX_MSGS_PRIO_ZERO,\n\t\t\t\"READ DISC STRUCTURE format 10h: Less than 12 bytes\",\n\t\t\t0, 0);\n\t\t{ret = 0; goto ex;}\n\t}\n\t*disk_category = (reply[0] >> 4) & 0xf;\n\t*book_name = book_names[*disk_category];\n\t*part_version = reply[0] & 0xf;\n\t*num_layers = ((reply[2] >> 5) & 0x3) + 1;\n\t*num_blocks = ((reply[9] << 16) | (reply[10] << 8) | reply[11]) -\n\t              ((reply[5] << 16) | (reply[6] << 8) | reply[7]) + 1;\n\tret = 1;\nex:;\n\tif (reply != NULL)\n\t\tfree(reply);\n\treturn ret;\n}",
    "comment": "Retrieves physical format information of a disc in the drive, including disk category, book name, version, layer count, and block count.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the allocation and free block counts for a Blu-ray disc from the burn drive 's current profile .\n",
    "cpbcs_sum": "Extracts a UTF-16 encoded string from the UTF-16 encoded data, updating the output buffer and length based on the encoded signature type.\n",
    "misum_sum": "Retrieves a 64-bit block number from a burn drive, validating its size and updating the provided data pointer.\n",
    "decom_sum": "Parses a disc structure from a device when specific media types are detected, extracting format, addressing, layer count, and sector range information.",
    "cfg_sum": "Validates disc structure data for specific formats, extracts fields into output parameters, computes offsets, and frees allocated memory after processing.",
    "work_score": {
        "hext5": {
            "summary": "| a this function build the following tree, from regular expression a*:",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes an unrelated claim about building a tree from the regular expression 'a*', which does not match any part of the source code's functionality of retrieving physical format information from a disc drive. The claim is entirely inaccurate and provides no factually correct alignment with the code, resulting in 0% accurate claims.",
                "The summary is entirely unrelated to the given source code. It describes building a tree from a regular expression 'a*', which does not match the function's actual purpose of retrieving physical format information from a DVD drive via MMC commands. The PRIMARY PURPOSE and all secondary details such as profile checks, disc structure reading, error handling, and output assignments are completely missed.",
                "The summary claims the function builds a tree from the regular expression 'a*', which is unrelated to the source code. The actual code reads physical format info from a DVD drive, extracting disk category, book name, part version, number of layers, and block counts. This is a FATAL inaccuracy targeting the primary purpose and key I/O, making the summary unreliable with no accurate claims."
            ]
        },
        "bint5": {
            "summary": "Retrieves the allocation and free block counts for a Blu-ray disc from the burn drive 's current profile .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves allocation and free block counts for a Blu-ray disc, but the source code targets HD/DVD-R[W] media only and computes total blocks from reply data rather than any allocation/free counts. This is a factual mismatch and contradicts the implementation, leaving 0% of claims accurate.",
                "The summary is inaccurate because it claims the function retrieves allocation and free block counts for a Blu-ray disc, whereas the source code specifically handles certain DVD/HD DVD profiles and retrieves physical format information such as disk category, book name, part version, number of layers, and total number of blocks. It misses the primary purpose entirely and introduces incorrect Blu-ray context not supported by the code.",
                "The summary claims the function retrieves Blu-ray disc allocation and free block counts, but the source code shows it handles HD/DVD media profiles (not Blu-ray) and calculates total blocks from disc structure, not separate allocation/free counts. This is a FATAL inaccuracy about the primary purpose and key I/O, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Extracts a UTF-16 encoded string from the UTF-16 encoded data, updating the output buffer and length based on the encoded signature type.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes UTF-16 string extraction and handling of encoded signature types, which is entirely unrelated to the source code. The source code deals with obtaining DVD physical format information, using conditions on current_profile, reading disc structure, and calculating disk properties. None of the claims match the implementation, making them inaccurate.",
                "The summary\u2019s claim about extracting a UTF-16 encoded string and handling an encoded signature type is completely unrelated to the source code, which processes physical format information for DVD/HD DVD discs via profile checks, disc structure reading, and parsing specific fields. It misses the primary purpose and all secondary details, making the claim inaccurate.",
                "The summary is entirely inaccurate because it describes UTF-16 string extraction and encoding handling, which is unrelated to the source code's actual function of retrieving physical format information for DVD media. This is a FATAL error impacting the primary purpose, as the summary misrepresents the key I/O, side effects, and logic. No accurate claims are present, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Retrieves a 64-bit block number from a burn drive, validating its size and updating the provided data pointer.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's core claim that the function retrieves a 64-bit block number from a burn drive is inaccurate, as the source code retrieves multiple physical format details such as disk category, book name, part version, number of layers, and a calculated number of blocks from reply data. There is no 64-bit block number retrieval, nor explicit size validation or updating of a provided data pointer as described. All claims conflict with the source, resulting in no accurate matches.",
                "The summary incorrectly claims the function retrieves a 64-bit block number and validates its size, which contradicts the actual source code. The function determines disc format details such as category, book name, part version, number of layers, and calculates the number of blocks, with specific profile checks and error handling. The provided description misses the primary purpose and key secondary behaviors, making it completely inaccurate.",
                "The summary claims the function retrieves a 64-bit block number, validates its size, and updates a data pointer. This is inaccurate: the source code instead reads disc structure info for certain DVD profiles, extracts fields like disk category, book name, part version, number of layers, and calculates the number of blocks. The block count is not a 64-bit value, and no generic data pointer update occurs. This represents a FATAL error impacting the primary purpose and output description, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5026800,
    "strip_function_name": "sub_4CB3F0",
    "strip_decompiled_code": "__int64 __fastcall sub_4CB3F0(char *s, unsigned int a2)\n{\n  __int16 v2; // bp\n  size_t v3; // rax\n  size_t v4; // rax\n  size_t v5; // rax\n  size_t v6; // rax\n  unsigned int v8[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  v8[0] = a2;\n  v2 = sub_4CAE00(s, v8, 1);\n  if ( (v2 & 0x24) == 0 )\n  {\n    v3 = strlen(s);\n    sprintf(\n      &s[v3],\n      \"user::%c%c%c\\n\",\n      (v8[0] & 0x100) == 0 ? 45 : 114,\n      (v8[0] & 0x80) == 0 ? 45 : 119,\n      (v8[0] & 0x40) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 0x412) == 0 )\n  {\n    v4 = strlen(s);\n    sprintf(\n      &s[v4],\n      \"group::%c%c%c\\n\",\n      (v8[0] & 0x20) == 0 ? 45 : 114,\n      (v8[0] & 0x10) == 0 ? 45 : 119,\n      (v8[0] & 8) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 9) == 0 )\n  {\n    v5 = strlen(s);\n    sprintf(\n      &s[v5],\n      \"other::%c%c%c\\n\",\n      (v8[0] & 4) == 0 ? 45 : 114,\n      (v8[0] & 2) == 0 ? 45 : 119,\n      (v8[0] & 1) == 0 ? 45 : 120);\n  }\n  if ( (v2 & 0x180) != 0 && (v2 & 0x200) == 0 )\n  {\n    v6 = strlen(s);\n    sprintf(\n      &s[v6],\n      \"mask::%c%c%c\\n\",\n      (v8[0] & 0x20) == 0 ? 45 : 114,\n      (v8[0] & 0x10) == 0 ? 45 : 119,\n      (v8[0] & 8) == 0 ? 45 : 120);\n  }\n  return 1LL;\n}\n",
    "function_name": "aaip_add_acl_st_mode",
    "decompiled_code": "__int64 __fastcall aaip_add_acl_st_mode(char *a1, mode_t a2, int flag)\n{\n  __int16 v3; // bp\n  size_t v4; // rax\n  size_t v5; // rax\n  size_t v6; // rax\n  size_t v7; // rax\n  mode_t st_mode[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  st_mode[0] = a2;\n  v3 = aaip_cleanout_st_mode(a1, st_mode, 1);\n  if ( (v3 & 0x24) == 0 )\n  {\n    v4 = strlen(a1);\n    sprintf(\n      &a1[v4],\n      &byte_51F243[22],\n      (st_mode[0] & 0x100) == 0 ? 45 : 114,\n      (st_mode[0] & 0x80) == 0 ? 45 : 119,\n      (st_mode[0] & 0x40) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 0x412) == 0 )\n  {\n    v5 = strlen(a1);\n    sprintf(\n      &a1[v5],\n      &byte_51F243[36],\n      (st_mode[0] & 0x20) == 0 ? 45 : 114,\n      (st_mode[0] & 0x10) == 0 ? 45 : 119,\n      (st_mode[0] & 8) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 9) == 0 )\n  {\n    v6 = strlen(a1);\n    sprintf(\n      &a1[v6],\n      &byte_51F243[51],\n      (st_mode[0] & 4) == 0 ? 45 : 114,\n      (st_mode[0] & 2) == 0 ? 45 : 119,\n      (st_mode[0] & 1) == 0 ? 45 : 120);\n  }\n  if ( (v3 & 0x180) != 0 && (v3 & 0x200) == 0 )\n  {\n    v7 = strlen(a1);\n    sprintf(\n      &a1[v7],\n      &byte_51F243[66],\n      (st_mode[0] & 0x20) == 0 ? 45 : 114,\n      (st_mode[0] & 0x10) == 0 ? 45 : 119,\n      (st_mode[0] & 8) == 0 ? 45 : 120);\n  }\n  return 1LL;\n}\n",
    "source_code": "int aaip_add_acl_st_mode(char *acl_text, mode_t st_mode, int flag)\n{\n char *wpt;\n int tag_types= 0;\n\n tag_types = aaip_cleanout_st_mode(acl_text, &st_mode, 1);\n if(!(tag_types & (4 | 32))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"user::%c%c%c\\n\",\n           st_mode & S_IRUSR ? 'r' : '-',\n           st_mode & S_IWUSR ? 'w' : '-',\n           st_mode & S_IXUSR ? 'x' : '-');\n }\n if(!(tag_types & (2 | 16 | 1024))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"group::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n if(!(tag_types & (1 | 8))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"other::%c%c%c\\n\",\n         st_mode & S_IROTH ? 'r' : '-',\n         st_mode & S_IWOTH ? 'w' : '-',\n         st_mode & S_IXOTH ? 'x' : '-');\n }\n if((tag_types & (128 | 256)) && !(tag_types & 512)) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"mask::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n return(1); \n}",
    "comment": "Adds entries for user, group, other, and mask permissions to an ACL string based on the provided `mode_t` and existing ACL tags.",
    "hext5_sum": "push a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Generates a formatted error message string with user , group , and file permissions based on the provided error code .\n",
    "cpbcs_sum": "Formats and prints a string representation of a specified value into a buffer, including its type and flags based on provided flags.\n",
    "misum_sum": "Formats and prints a time value in a XorrisO structure with optional time zone and additional flags for certain byte usage.\n",
    "decom_sum": "Formats and appends user, group, other, and mask permission strings to the buffer based on the provided access mode flags.",
    "cfg_sum": "Generates user, group, other, and mask permission strings from flag bits in input and appends them to the provided buffer.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving a static buffer, printf formatting character, and conditional hex conversion based on num_bytes, none of which is present in the source code. The source code deals with adding ACL entries to a string based on st_mode bits and tag_types flags. None of the claims in the summary match the source code's semantics, resulting in 0% accurate claims.",
                "The summary describes converting a value into a static buffer using printf formatting, with conditions based on num_bytes, which is unrelated to the source code. The source function modifies an ACL text string based on st_mode permission bits and tag_types, appending specific ACL entries. None of the claims match the primary purpose or secondary details of the source implementation, resulting in no accurate coverage.",
                "The summary describes behavior about pushing a pointer to a static buffer, conversion via printf formatting, and conditional hex formatting based on num_bytes, which is entirely unrelated to the source code. The source function appends ACL entries based on st_mode permissions and tag_types, with no buffer pushing or num_bytes logic. All claims are NOISE and contradict the code\u2019s actual purpose, leading to zero alignment and high negative impact."
            ]
        },
        "bint5": {
            "summary": "Generates a formatted error message string with user , group , and file permissions based on the provided error code .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function generates a formatted error message string based on an error code, but the source code shows it appends ACL entries for user, group, other, and mask permissions based on a mode value, not an error code. This is a semantic mismatch, making the single claim inaccurate.",
                "The summary is inaccurate because it describes generating a formatted error message from an error code, which contradicts the source code\u2019s primary purpose. The function actually appends formatted ACL permission entries for user, group, other, and mask based on a mode value, not an error code, and there is no error message generation. The primary purpose is entirely missed and no secondary details from the implementation are captured.",
                "The summary inaccurately describes the function as generating a formatted error message based on an error code, which contradicts the source code's actual purpose of appending ACL permission entries for user, group, other, and mask based on st_mode bits. This is a FATAL error targeting the primary purpose and I/O, with no accurate claims to offset the misrepresentation."
            ]
        },
        "cpbcs": {
            "summary": "Formats and prints a string representation of a specified value into a buffer, including its type and flags based on provided flags.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary describes generic string formatting of a specified value with type and flags, which does not accurately match the source code\u2019s purpose of appending specific ACL permission lines (user, group, other, mask) derived from st_mode and tag_types conditions. The claims are mostly unrelated to the actual implementation, leading to low alignment.",
                "The summary misses the primary purpose of the function, which is to add ACL entries for user, group, other, and mask based on st_mode bits when missing, into the acl_text buffer. Instead, it gives a generic description of string formatting unrelated to file permissions or tag handling. It correctly notes that the function formats and writes strings, but fails to mention critical conditions, bit checks, or ACL-specific semantics evident in the source code.",
                "The summary is inaccurate because it generically describes formatting a value with type and flags, but the source code actually appends user, group, other, and mask ACL entries based on st_mode bitwise permissions and tag_types conditions. This mismatch targets the core functionality (primary purpose) and misses key I/O semantics, making it a FATAL error with low relevance and no specific alignment to the true implementation."
            ]
        },
        "misum": {
            "summary": "Formats and prints a time value in a XorrisO structure with optional time zone and additional flags for certain byte usage.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes formatting and printing a time value with time zones and byte usage flags, which is entirely unrelated to the source code. The source implements appending ACL entries for user, group, other, and mask based on st_mode bits, with no time-related functionality. All claims are inaccurate, resulting in no alignment with the source.",
                "The summary is entirely inaccurate as it describes formatting and printing a time value in a XorrisO structure, which is unrelated to the source code. The source code function appends user, group, other, and mask ACL permission strings to an ACL text buffer based on st_mode and tag_types conditions. The summary misses the primary purpose and all secondary details, providing no accurate coverage of the implementation.",
                "The summary makes a claim about formatting and printing a time value in a XorrisO structure, which is entirely unrelated to the source code's actual purpose of appending ACL entries based on file mode bits. This is a clear FATAL error about the primary purpose, as it misidentifies the function's core operation, leading to zero alignment with the source semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585619424,
    "strip_function_name": "sub_FFFFFFFF81675DE0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF81675DE0(unsigned int *a1, __int64 a2)\n{\n  int v2; // edx\n  unsigned __int64 result; // rax\n  unsigned int *v6; // r8\n  int *v7; // rdi\n  unsigned __int64 v8; // rcx\n  unsigned int v9; // esi\n  int v10; // eax\n  __int64 v11; // r9\n  __int64 v12; // rax\n  _QWORD *v13; // rax\n\n  v2 = -1;\nLABEL_2:\n  while ( 1 )\n  {\n    result = sub_FFFFFFFF812BE5D0((__int64)&qword_FFFFFFFF81CB6E08, 0x40uLL, v2 + 1);\n    v2 = result;\n    if ( dword_FFFFFFFF81CB7EA8 <= (unsigned int)result )\n      return result;\n    v6 = &a1[2 * (unsigned int)result];\n    v7 = (int *)(qword_FFFFFFFF81CB6720[(unsigned int)result] + 59696);\n    v8 = *((_QWORD *)v6 + 9);\n    if ( v8 < v8 + *a1 )\n    {\n      v9 = 0;\n      while ( 1 )\n      {\n        v10 = *v7;\n        if ( (*v7 & 1) != 0 )\n        {\nLABEL_9:\n          _mm_pause();\n        }\n        else\n        {\n          while ( 1 )\n          {\n            v11 = *(_QWORD *)(v8 + 96);\n            if ( *v7 != v10 )\n              break;\n            v12 = v9++;\n            v13 = (_QWORD *)(a2 + 16 * v12);\n            v13[1] += *(_QWORD *)(v8 + 104);\n            *v13 += v11;\n            v8 += *(unsigned __int16 *)(v8 + 90);\n            if ( v8 >= *((_QWORD *)v6 + 9) + (unsigned __int64)*a1 )\n              goto LABEL_2;\n            v10 = *v7;\n            if ( (*v7 & 1) != 0 )\n              goto LABEL_9;\n          }\n        }\n      }\n    }\n  }\n}\n",
    "function_name": "get_counters",
    "decompiled_code": "unsigned __int64 __fastcall get_counters(unsigned int *a1, __int64 a2)\n{\n  int v2; // edx\n  unsigned __int64 result; // rax\n  unsigned int *v6; // r8\n  int *v7; // rdi\n  unsigned __int64 v8; // rcx\n  unsigned int v9; // esi\n  int v10; // eax\n  __int64 v11; // r9\n  __int64 v12; // rax\n  _QWORD *v13; // rax\n\n  v2 = -1;\nLABEL_2:\n  while ( 1 )\n  {\n    result = find_next_bit((__int64)cpu_possible_mask, 0x40uLL, v2 + 1);\n    v2 = result;\n    if ( nr_cpu_ids <= (unsigned int)result )\n      return result;\n    v6 = &a1[2 * (unsigned int)result];\n    v7 = (int *)(_per_cpu_offset[(unsigned int)result] + 59696);\n    v8 = *((_QWORD *)v6 + 9);\n    if ( v8 < v8 + *a1 )\n    {\n      v9 = 0;\n      while ( 1 )\n      {\n        v10 = *v7;\n        if ( (*v7 & 1) != 0 )\n        {\nLABEL_9:\n          _mm_pause();\n        }\n        else\n        {\n          while ( 1 )\n          {\n            v11 = *(_QWORD *)(v8 + 96);\n            if ( *v7 != v10 )\n              break;\n            v12 = v9++;\n            v13 = (_QWORD *)(a2 + 16 * v12);\n            v13[1] += *(_QWORD *)(v8 + 104);\n            *v13 += v11;\n            v8 += *(unsigned __int16 *)(v8 + 90);\n            if ( v8 >= *((_QWORD *)v6 + 9) + (unsigned __int64)*a1 )\n              goto LABEL_2;\n            v10 = *v7;\n            if ( (*v7 & 1) != 0 )\n              goto LABEL_9;\n          }\n        }\n      }\n    }\n  }\n}\n",
    "source_code": "int get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint cpu = t->cpu_id;\n\tunsigned long long msr;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(stderr, \"Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tt->tsc = rdtsc();\t/* we are running on local CPU of interest */\n\n\tif (has_aperf) {\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\t\tif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\n\t\t\treturn -4;\n\t}\n\n\tif (do_smi) {\n\t\tif (get_msr(cpu, MSR_SMI_COUNT, &msr))\n\t\t\treturn -5;\n\t\tt->smi_count = msr & 0xFFFFFFFF;\n\t}\n\tif (extra_delta_offset32) {\n\t\tif (get_msr(cpu, extra_delta_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_delta32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_delta_offset64)\n\t\tif (get_msr(cpu, extra_delta_offset64, &t->extra_delta64))\n\t\t\treturn -5;\n\n\tif (extra_msr_offset32) {\n\t\tif (get_msr(cpu, extra_msr_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_msr32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_msr_offset64)\n\t\tif (get_msr(cpu, extra_msr_offset64, &t->extra_msr64))\n\t\t\treturn -5;\n\n\t/* collect core counters only for 1st thread in core */\n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\n\t\t\treturn -6;\n\t\tif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t}\n\n\tif (do_snb_cstates)\n\t\tif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\n\t\t\treturn -8;\n\n\tif (do_dts) {\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn -9;\n\t\tc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\n\n\t/* collect package counters only for 1st core in package */\n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\n\t\t\treturn -9;\n\t\tif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\treturn -10;\n\t}\n\tif (do_snb_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\n\t\t\treturn -11;\n\t\tif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\n\t\t\treturn -12;\n\t}\n\tif (do_c8_c9_c10) {\n\t\tif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\n\t\t\treturn -13;\n\t}\n\tif (do_rapl & RAPL_PKG) {\n\t\tif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_CORES) {\n\t\tif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\n\t\t\treturn -14;\n\t\tp->energy_cores = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\n\t\t\treturn -15;\n\t\tp->energy_dram = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->energy_gfx = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_PKG_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_dram_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_ptm) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn -17;\n\t\tp->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\treturn 0;\n}",
    "comment": "Aggregates packet and byte counters from multiple CPU entries into a single counter array based on the provided old counters.",
    "hext5_sum": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
    "bint5_sum": "Inserts an ` xfrm_state_afinfo ` structure into a hash table for each CPU in the specified network namespace .\n",
    "cpbcs_sum": "Updates the total number of sockets in the connection tracking map for a specified network context, incrementing the count for each online CPU.\n",
    "misum_sum": "Initializes the random number generator across network configurations across multiple CPUs while ensuring the hash is within the specified network namespace.\n",
    "decom_sum": "Iterates over data buffers, aggregating 64-bit values into an output array while synchronizing on a lock variable to ensure consistent reads.",
    "cfg_sum": "Iterates through indexed data structures, aggregates values into an output buffer while handling concurrent access, and returns the index status upon completion.",
    "work_score": {
        "hext5": {
            "summary": "generate a variant frag that we can use to relax address/line increments between fragments of the target segment.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary does not contain any fact-based claims related to the provided source code and instead discusses an unrelated concept about relaxing address/line increments between fragments of a target segment. Since none of its content aligns with the actual implementation or behavior in the source snippet, all claims are classified as inaccurate.",
                "The summary is unrelated to the source code, making no fact-based claims about the function's purpose or behavior. It does not reference CPU migration, MSR reads, counter collection, or error handling, and therefore the primary purpose and secondary details are entirely missed.",
                "The summary contains a vague instruction about generating a variant fragment to relax address/line increments, which does not correspond to any specific behavior or semantics in the provided source code. It fails to describe the actual purpose, inputs, or outputs of the function and introduces unrelated concepts, making it pure NOISE with no accurate claims."
            ]
        },
        "bint5": {
            "summary": "Inserts an ` xfrm_state_afinfo ` structure into a hash table for each CPU in the specified network namespace .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes inserting an `xfrm_state_afinfo` structure into a hash table for each CPU in a network namespace, which is unrelated to the source code. The source code instead retrieves various MSR counters, residency states, temperatures, and energy stats for specific threads, cores, and packages. None of the summary's claims align with the implementation, making all extracted claims inaccurate.",
                "The summary describes insertion of an `xfrm_state_afinfo` into a hash table for each CPU in a network namespace, which is unrelated to the source code. The function actually collects various CPU, core, and package counters via MSR reads and handles multiple conditional branches and error codes. The summary misses the primary purpose entirely and contains no accurate claims about the implementation.",
                "The summary describes inserting an `xfrm_state_afinfo` structure into a hash table per CPU in a network namespace, which is entirely unrelated to the source code. The source function `get_counters` reads model-specific registers (MSRs) and gathers performance, residency, and temperature counters for CPU, core, and package contexts. This mismatch is a clear FATAL error concerning the primary purpose of the code, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Updates the total number of sockets in the connection tracking map for a specified network context, incrementing the count for each online CPU.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function updates a connection tracking map\u2019s socket count for a network context, incrementing per online CPU, but the source code instead reads various MSRs and stores hardware performance and energy counters, without any connection tracking or socket-related logic. All claims are inaccurate with respect to the source, resulting in no alignment.",
                "The summary is entirely inaccurate as it describes updating socket counts in a network connection tracking map, which is unrelated to the source code. The source function retrieves various hardware counters from MSRs for a specific CPU/core/package, handles conditional data collection, and returns error codes under certain conditions. The summary misses the primary purpose and all secondary details, failing to cover any critical semantic unit.",
                "The summary is entirely inaccurate compared to the source code. The source function collects various MSR counters related to CPU, core, and package performance and thermal metrics, not socket counts in a connection tracking map or network context. This is a FATAL error concerning the primary purpose, making the description misleading and unreliable."
            ]
        },
        "misum": {
            "summary": "Initializes the random number generator across network configurations across multiple CPUs while ensuring the hash is within the specified network namespace.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about initializing a random number generator, network configurations, multiple CPUs, and network namespaces are entirely unrelated to the source code. The function in the source code collects MSR counters and thermal/energy data for threads, cores, and packages, with no operations involving random number generation or network namespaces. All claims are inaccurate, leading to no alignment with the implementation.",
                "The summary is entirely inaccurate because it describes initializing a random number generator and working with network configurations and namespaces, which are unrelated to the source code. The function in the source collects CPU, core, and package performance counters via MSR reads, handles conditional branches for different metrics, and returns specific error codes. The summary misses the primary purpose and all secondary details, resulting in no claim coverage.",
                "The summary's claims about initializing a random number generator, handling network configurations, and ensuring a hash within a network namespace are entirely unrelated to the source code, which gathers hardware performance and energy counters via MSR reads for specific CPUs, cores, and packages. All claims are NOISE, and none describe actual code behavior, leading to overwhelming irrelevance and zero useful gain."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 491552,
    "strip_function_name": "sub_78020",
    "strip_decompiled_code": "__int64 __fastcall sub_78020(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4, int a5, int a6)\n{\n  __int64 v6; // rax\n  double *v7; // rax\n  int v8; // r8d\n  int v9; // edi\n  __int64 result; // rax\n  _DWORD *v11; // rdx\n  int v12; // esi\n  int v13; // esi\n  __int64 i; // rdx\n  __int64 v15; // [rsp+10h] [rbp-18h]\n  _DWORD *v16; // [rsp+18h] [rbp-10h]\n\n  v6 = a1 + 48;\n  if ( *(char *)a1 < 0 )\n  {\n    v16 = a4;\n    v15 = a3;\n    v6 = ALTVEC_DATAPTR_OR_NULL(a1);\n    a4 = v16;\n    a3 = v15;\n  }\n  if ( v6 )\n    Rf_error((unsigned int)\"method should only handle unexpanded vectors\", a2, a3, (_DWORD)a4, a5, a6);\n  v7 = *(double **)(a1 + 32);\n  v8 = (int)v7[8];\n  v9 = (int)v7[7];\n  result = (unsigned int)(int)v7[6] - a2;\n  if ( result > a3 )\n    result = a3;\n  if ( v8 == 1 )\n  {\n    if ( result > 0 )\n    {\n      v13 = v9 + a2;\n      for ( i = 0LL; i != result; ++i )\n        a4[i] = v13 + i;\n    }\n  }\n  else\n  {\n    if ( v8 != -1 )\n      Rf_error((unsigned int)\"compact sequences with increment %d not supported yet\", v8, a3, (_DWORD)a4, v8, a6);\n    if ( result > 0 )\n    {\n      v11 = &a4[result];\n      v12 = v9 - a2;\n      do\n        *a4++ = v12--;\n      while ( a4 != v11 );\n    }\n  }\n  return result;\n}\n",
    "function_name": "compact_intseq_Get_region",
    "decompiled_code": "__int64 __fastcall compact_intseq_Get_region(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        _DWORD *a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14)\n{\n  __int64 v14; // rax\n  double *v15; // rax\n  __int64 v16; // r8\n  int v17; // edi\n  __int64 result; // rax\n  _DWORD *v19; // rdx\n  int v20; // esi\n  int v21; // esi\n  __int64 i; // rdx\n  __int64 v23; // [rsp+10h] [rbp-18h]\n  _DWORD *v24; // [rsp+18h] [rbp-10h]\n\n  v14 = a1 + 48;\n  if ( *(char *)a1 < 0 )\n  {\n    v24 = a4;\n    v23 = a3;\n    v14 = ALTVEC_DATAPTR_OR_NULL(a1);\n    a4 = v24;\n    a3 = v23;\n  }\n  if ( v14 )\n    Rf_error(\n      (unsigned int)\"method should only handle unexpanded vectors\",\n      a2,\n      a3,\n      (__int64)a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      a12,\n      a13,\n      a14);\n  v15 = *(double **)(a1 + 32);\n  v16 = (unsigned int)(int)v15[8];\n  v17 = (int)v15[7];\n  result = (unsigned int)(int)v15[6] - a2;\n  if ( result > a3 )\n    result = a3;\n  if ( (_DWORD)v16 == 1 )\n  {\n    if ( result > 0 )\n    {\n      v21 = v17 + a2;\n      for ( i = 0LL; i != result; ++i )\n        a4[i] = v21 + i;\n    }\n  }\n  else\n  {\n    if ( (_DWORD)v16 != -1 )\n      Rf_error(\n        (unsigned int)\"compact sequences with increment %d not supported yet\",\n        (unsigned int)v16,\n        a3,\n        (__int64)a4,\n        v16,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        a12,\n        a13,\n        a14);\n    if ( result > 0 )\n    {\n      v19 = &a4[result];\n      v20 = v17 - a2;\n      do\n        *a4++ = v20--;\n      while ( a4 != v19 );\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic R_xlen_t\ncompact_intseq_Get_region(SEXP sx, R_xlen_t i, R_xlen_t n, int *buf)\n{\n    /* should not get here if x is already expanded */\n    CHECK_NOT_EXPANDED(sx);\n\n    SEXP info = COMPACT_SEQ_INFO(sx);\n    R_xlen_t size = COMPACT_INTSEQ_INFO_LENGTH(info);\n    R_xlen_t n1 = COMPACT_INTSEQ_INFO_FIRST(info);\n    int inc = COMPACT_INTSEQ_INFO_INCR(info);\n\n    R_xlen_t ncopy = size - i > n ? n : size - i;\n    if (inc == 1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 + k + i);\n\treturn ncopy;\n    }\n    else if (inc == -1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 - k - i);\n\treturn ncopy;\n    }\n    else\n\terror(\"compact sequences with increment %d not supported yet\", inc);\n}",
    "comment": "Extracts a specified region from a compact integer sequence into a buffer, handling both increasing and decreasing increments.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Retrieves a specified number of sequential double values from a compact sequence in R , based on starting index and increment .\n",
    "cpbcs_sum": "Generates a specified number of sequential integers from a buffer using the provided command, handling negative values and updating the stream's position.\n",
    "misum_sum": "Retrieves a range of double values from a compact sequence and stores it in the provided buffer if not supported by its data.\n",
    "decom_sum": "Generates a sequence of integers from vector metadata with increment 1 or -1, filling the output array and erroring on unsupported increments.",
    "cfg_sum": "Generates a sequence of integers from vector metadata, supporting increments of 1 or -1, and raises errors for unsupported increments or expanded vectors.",
    "work_score": {
        "hext5": {
            "summary": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about list indexes, analyzer behavior, 'dbegetfunclist', and JTable processing do not align with the source code, which deals with copying integer sequence elements into a buffer based on increment values. None of the claims reflect or match the function's actual operations, resulting in no accurate correspondence.",
                "The summary makes no accurate, fact-based claims about the source code. It describes list indexing, database function calls, and table generation unrelated to the actual implementation, which processes a compact integer sequence to fill a buffer based on parameters and handles unsupported increments with an error. The primary purpose and key secondary details are entirely missed, and all claims are inaccurate noise.",
                "The summary\u2019s claims about returning an index from a list, invoking dbegetfunclist, and working with JTable data bear no relation to the actual source code, which processes compact integer sequences in R and copies a range into a buffer based on sequence parameters. This is pure NOISE with no accurate alignment to code semantics, offering no useful insight and overwhelming any potential gain."
            ]
        },
        "bint5": {
            "summary": "Retrieves a specified number of sequential double values from a compact sequence in R , based on starting index and increment .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as retrieving sequential double values, while the source code clearly operates on integers stored in an int buffer. The mention of R and use of starting index and increment is broadly accurate, but the data type mismatch and over-generalization reduce alignment. Only a portion of the claim aligns with the implementation, giving less than half accuracy.",
                "The summary misses the primary purpose, which is to retrieve integer values from a compact integer sequence into a provided buffer, and it inaccurately describes them as double values. It omits key secondary details such as handling of positive and negative increments, calculation of copy length, and error handling for unsupported increments. While it mentions starting index and increment, the incorrect data type and lack of coverage for critical behaviors significantly affect accuracy.",
                "The summary contains a key inaccuracy: it describes retrieving 'sequential double values', whereas the source code clearly retrieves integers (stored in `buf` as `int`). This is a FATAL error affecting the primary I/O type. While it correctly notes that the sequence is based on starting index and increment, this accurate part is low-info and does not offset the critical semantic mismatch. The worst failure mode is FATAL since the primary data type returned is misrepresented."
            ]
        },
        "cpbcs": {
            "summary": "Generates a specified number of sequential integers from a buffer using the provided command, handling negative values and updating the stream's position.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as generating integers from a buffer via a 'provided command' and updating a stream position, which are not present in the source code. The actual code reads sequence info from a compact integer sequence, handles forward and reverse increments, and writes integers into a provided buffer. While it mentions handling negative values (which loosely aligns with inc == -1), most claims are incorrect or unrelated to the code's semantics, resulting in a low proportion of accurate statements.",
                "The summary incorrectly describes the function as generating integers from a buffer and updating a stream's position, which is not present in the source code. The source code actually fills a provided buffer with elements from a compact integer sequence based on starting value, increment of 1 or -1, and requested length, and raises an error for unsupported increments. The primary purpose and key secondary details such as increment handling and error behavior are missed entirely.",
                "The summary contains multiple inaccuracies: it claims the function generates integers from a buffer when in fact it writes integers into the provided buffer based on a compact sequence's start and increment; it mentions handling negative values and updating a stream position, neither of which are present in the code. These are FATAL errors affecting the primary purpose of the code, making the summary unreliable."
            ]
        },
        "misum": {
            "summary": "Retrieves a range of double values from a compact sequence and stores it in the provided buffer if not supported by its data.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function retrieves double values, while the source code clearly retrieves integers, casting values to int before storing in the buffer. It also misrepresents the control flow by suggesting the retrieval happens only if data is not supported, whereas in the code unsupported increments trigger an error. These inaccuracies mean the majority of claims contradict the source implementation.",
                "The summary incorrectly states that the function retrieves double values, while the source clearly handles integers. It also misrepresents behavior by mentioning unsupported ranges being stored in the buffer, whereas the actual code raises an error for unsupported increments. The PRIMARY PURPOSE of copying integer subsequences into a buffer when the compact sequence is not expanded is missed, and no secondary details like handling of positive and negative increments or bounds calculation are covered.",
                "The summary contains a FATAL inaccuracy regarding the PRIMARY PURPOSE: it claims the function retrieves double values, while the source code clearly retrieves integers (via int casts) from a compact integer sequence. Additionally, the conditional about 'if not supported by its data' is misleading; the actual logic only throws an error for unsupported increment values, not as a general retrieval condition. These contradictions severely undermine reliability, and there is no high-gain accurate information provided."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 427568,
    "strip_function_name": "sub_68630",
    "strip_decompiled_code": "_BOOL8 __fastcall sub_68630(__int64 a1, int a2)\n{\n  if ( !a1 || (*(_BYTE *)(a1 + 172) & 4) == 0 )\n  {\n    if ( (a2 & 0xFFFFFFDF) - 65 > 0x19\n      && a2 != 95\n      && a2 != 58\n      && (unsigned int)(a2 - 192) > 0x16\n      && (unsigned int)(a2 - 216) > 0x1E\n      && (unsigned int)(a2 - 248) > 0x207\n      && (unsigned int)(a2 - 880) > 0xD\n      && (unsigned int)(a2 - 895) > 0x1C80\n      && (unsigned int)(a2 - 8204) > 1\n      && (unsigned int)(a2 - 8304) > 0x11F\n      && (unsigned int)(a2 - 11264) > 0x3EF\n      && (unsigned int)(a2 - 12289) > 0xA7FE\n      && (unsigned int)(a2 - 63744) > 0x4CF\n      && (unsigned int)(a2 - 65008) > 0x20D )\n    {\n      return (unsigned int)(a2 - 0x10000) <= 0xDFFFF;\n    }\n    return 1LL;\n  }\n  if ( a2 <= 255 )\n  {\n    if ( (a2 & 0xFFFFFFDF) - 65 > 0x19\n      && (unsigned int)(a2 - 192) > 0x16\n      && (unsigned int)(a2 - 216) > 0x1E\n      && a2 <= 247 )\n    {\n      return (a2 == 58) | (unsigned __int8)(a2 == 95);\n    }\n    return 1LL;\n  }\n  return (unsigned int)xmlCharInRange((unsigned int)a2, &xmlIsBaseCharGroup)\n      || (unsigned int)(a2 - 19968) <= 0x51A5\n      || a2 == 12295\n      || (unsigned int)(a2 - 12321) <= 8;\n}\n",
    "function_name": "xmlIsDocNameStartChar",
    "decompiled_code": "int __fastcall xmlIsDocNameStartChar(xmlDocPtr doc, int c)\n{\n  __int64 v2; // rax\n\n  if ( !doc || (doc->properties & 4) == 0 )\n  {\n    if ( (c & 0xFFFFFFDF) - 65 > 0x19\n      && c != 95\n      && c != 58\n      && (unsigned int)(c - 192) > 0x16\n      && (unsigned int)(c - 216) > 0x1E\n      && (unsigned int)(c - 248) > 0x207\n      && (unsigned int)(c - 880) > 0xD\n      && (unsigned int)(c - 895) > 0x1C80\n      && (unsigned int)(c - 8204) > 1\n      && (unsigned int)(c - 8304) > 0x11F\n      && (unsigned int)(c - 11264) > 0x3EF\n      && (unsigned int)(c - 12289) > 0xA7FE\n      && (unsigned int)(c - 63744) > 0x4CF\n      && (unsigned int)(c - 65008) > 0x20D )\n    {\n      return (unsigned int)(c - 0x10000) <= 0xDFFFF;\n    }\n    goto LABEL_24;\n  }\n  if ( c <= 255 )\n  {\n    if ( (c & 0xFFFFFFDF) - 65 > 0x19 && (unsigned int)(c - 192) > 0x16 && (unsigned int)(c - 216) > 0x1E && c <= 247 )\n    {\n      LODWORD(v2) = c == 58 || c == 95;\n      return v2;\n    }\nLABEL_24:\n    LODWORD(v2) = 1;\n    return v2;\n  }\n  if ( xmlCharInRange__internal_alias(c, &xmlIsBaseCharGroup) || (unsigned int)(c - 19968) <= 0x51A5 || c == 12295 )\n    LODWORD(v2) = 1;\n  else\n    return (unsigned int)(c - 12321) <= 8;\n  return v2;\n}\n",
    "source_code": "\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}",
    "comment": "Determines if a character is a valid starting character for an XML document name based on XML-1.0 specifications or old document properties.",
    "hext5_sum": "returns true iff pnote1 overlaps or adjoins pnote2.",
    "bint5_sum": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties .\n",
    "cpbcs_sum": "Validates whether a character can be the start of an XML name based on the defined document and defined character ranges.\n",
    "misum_sum": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties.\n",
    "decom_sum": "Validates whether a given Unicode code point is an acceptable XML name character based on specific ASCII, Latin, and multibyte character ranges.",
    "cfg_sum": "Validates whether a given character code is an allowed XML name character, considering object flags and specific Unicode and ASCII ranges.",
    "work_score": {
        "hext5": {
            "summary": "returns true iff pnote1 overlaps or adjoins pnote2.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The single claim in the summary asserts that the function returns true if one note overlaps or adjoins another, which is entirely unrelated to the actual source code logic checking whether a character is a valid XML document name start character. This is a clear contradiction and no claims align with the source, resulting in zero accuracy.",
                "The summary describes behavior related to checking if two notes overlap or adjoin, which is unrelated to the actual function that determines if a character is a valid starting character for a document name according to XML specifications. This is a clear semantic contradiction and misses the primary purpose and all secondary details from the source code.",
                "The summary contains a single claim stating the function returns true if one note overlaps or adjoins another. This is entirely inaccurate and unrelated to the source code, which checks whether a character is a valid start character for an XML document name. The claim is pure NOISE and misrepresents the primary purpose, resulting in high negative impact."
            ]
        },
        "bint5": {
            "summary": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function validates whether a character is a valid document name character according to XML specifications or legacy rules, which aligns with the code's check for standard XML ranges when a certain property is unset and legacy rules otherwise. The wording matches the purpose without contradicting the implementation, making it accurate.",
                "The summary captures the main purpose: checking if a character is valid for an XML document name, and it mentions the influence of document properties (which select between XML 1.0 updated rules and legacy rules). However, it omits key implementation details such as the specific conditions used for legacy mode (IS_LETTER, '_' and ':') and the precise Unicode ranges for the newer checks, so coverage of secondary details is incomplete.",
                "The summary accurately reflects the function\u2019s primary purpose: checking if a character is valid as a starting character for a document name based on XML specifications or legacy rules, depending on document properties. It is broadly correct and does not contradict the source code, but lacks specific details such as the exact character ranges and the distinction between XML versions implemented. This results in low informational gain without any fatal errors."
            ]
        },
        "cpbcs": {
            "summary": "Validates whether a character can be the start of an XML name based on the defined document and defined character ranges.\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly describes that the function checks whether a character is a valid starting character for an XML name, and that this is determined by the document context and character ranges. All major function behaviors are captured accurately without introducing incorrect or irrelevant details, showing strong alignment with the source code.",
                "The summary correctly identifies the primary purpose of the function\u2014to determine if a character is a valid starting character for an XML name based on the document and character ranges. However, it lacks secondary details from the source code such as the distinction between new XML 1.0 checks and old ones when `XML_DOC_OLD10` is set, the specific ranges and constants checked, and the explicit handling for `NULL` documents. This omission reduces completeness despite the accuracy of the core purpose.",
                "The summary correctly states that the function validates if a character is a valid start for an XML name, considering the document properties and predefined character ranges. This matches the implementation, which checks different ranges based on whether the document uses newer XML 1.0 rules or an older definition. However, the claim is broad and lacks specific details about the conditional logic, the 'old10' property check, and exact Unicode ranges, making it low-info. No inaccuracies are present, but the low specificity means limited gain."
            ]
        },
        "misum": {
            "summary": "Validates whether a character is a valid document name character according to XML specifications or legacy rules based on the document properties.\n",
            "score": [
                0.7,
                0.6,
                0.2
            ],
            "reason": [
                "The summary claims the function validates a character against XML specifications or legacy rules based on document properties. While it captures the general purpose and distinction between XML 1.0 updated rules and legacy rules, it inaccurately states 'document name character' instead of 'document name start character'. This is a semantic difference, as the source code strictly checks whether a character is valid at the start of a document name. This minor inaccuracy reduces precision, but most of the claim aligns with the source code\u2019s logic.",
                "The summary correctly captures the primary purpose: checking if a character is valid as a document name start character in XML, with behavior depending on document properties for legacy vs updated rules. However, it misses key secondary details such as the specific character ranges checked under updated XML 1.0 rules, the use of IS_LETTER macro in legacy mode, and how NULL document pointers are handled. This omission reduces completeness despite accurately conveying the core intent.",
                "The summary conflates two distinct checks in the source code: name start characters vs general name characters. In the implementation, the function only verifies if the character is valid as a starting character according to either updated XML 1.0 production rules or legacy rules based on document properties. The phrase 'valid document name character' in the summary is inaccurate because it broadens the purpose beyond start-character validation, which is a key semantic of the function\u2014this is a FATAL error involving the primary purpose. While the summary does mention legacy rules and document properties, the core misrepresentation significantly reduces reliability."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578947024,
    "strip_function_name": "sub_FFFFFFFF81018DD0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81018DD0(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // r13\n  __int64 result; // rax\n  _QWORD *v4; // rax\n  __int64 v5; // rdx\n  int v6; // edx\n  int v7; // eax\n  __int64 v8; // rcx\n  __int64 v9; // rax\n\n  v1 = sub_FFFFFFFF813F1610(a1 + 152);\n  v2 = *(_QWORD *)(v1 + 264);\n  result = *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 208LL);\n  if ( dword_FFFFFFFF81C19640[result] == *(_DWORD *)v1 )\n  {\n    sub_FFFFFFFF813F1880(a1 + 152, 0LL);\n    sub_FFFFFFFF81792900(&byte_FFFFFFFF81DCE870);\n    v4 = *(_QWORD **)(v1 + 376);\n    v5 = *(_QWORD *)(v1 + 368);\n    *(_QWORD *)(v5 + 8) = v4;\n    *v4 = v5;\n    *(_QWORD *)(v1 + 368) = 0xDEAD000000000100LL;\n    *(_QWORD *)(v1 + 376) = 0xDEAD000000000200LL;\n    ++byte_FFFFFFFF81DCE870;\n    v6 = -1;\n    while ( 1 )\n    {\n      v7 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E08, 64LL, v6 + 1);\n      v6 = v7;\n      if ( v7 >= dword_FFFFFFFF81CB7EA8 )\n        break;\n      v8 = *(_QWORD *)(v2 + 224);\n      v9 = qword_FFFFFFFF81CB6720[v7];\n      if ( *(_QWORD *)(v8 + v9) == v1 )\n      {\n        *(_QWORD *)(v9 + v8) = 0LL;\n        _InterlockedDecrement((volatile signed __int32 *)(v1 + 24));\n      }\n    }\n    if ( *(_DWORD *)(v1 + 24) != 1 && !byte_FFFFFFFF81CAC4FC )\n    {\n      sub_FFFFFFFF8103BB80(\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3253LL);\n      byte_FFFFFFFF81CAC4FC = 1;\n    }\n    return sub_FFFFFFFF8112DCD0(v1);\n  }\n  else if ( !byte_FFFFFFFF81CAC4FD )\n  {\n    result = sub_FFFFFFFF8103BB80(\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3237LL);\n    byte_FFFFFFFF81CAC4FD = 1;\n  }\n  return result;\n}\n",
    "function_name": "uncore_pci_remove",
    "decompiled_code": "void __fastcall uncore_pci_remove(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  unsigned __int64 drvdata; // rbx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // r13\n  _QWORD *v17; // rax\n  __int64 *v18; // rdx\n  __int64 v19; // rsi\n  unsigned int next_bit; // eax\n  __int64 v21; // rcx\n  __int64 v22; // r8\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  __int64 v26; // rcx\n  __int64 v27; // rax\n\n  drvdata = dev_get_drvdata(a1 + 152);\n  v16 = *(_QWORD *)(drvdata + 264);\n  if ( pcibus_to_physid[*(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 208LL)] == *(_DWORD *)drvdata )\n  {\n    dev_set_drvdata(a1 + 152, 0LL, a2, a3, a4, a5, v14, v15, a8, a9);\n    raw_spin_lock((volatile signed __int16 *)&uncore_box_lock);\n    v17 = *(_QWORD **)(drvdata + 376);\n    v18 = *(__int64 **)(drvdata + 368);\n    v18[1] = (__int64)v17;\n    *v17 = v18;\n    *(_QWORD *)(drvdata + 368) = 0xDEAD000000000100LL;\n    *(_QWORD *)(drvdata + 376) = 0xDEAD000000000200LL;\n    ++uncore_box_lock;\n    LODWORD(v18) = -1;\n    while ( 1 )\n    {\n      v19 = 64LL;\n      next_bit = find_next_bit((__int64)cpu_possible_mask, 0x40uLL, (int)v18 + 1);\n      v18 = (__int64 *)next_bit;\n      if ( (int)next_bit >= nr_cpu_ids )\n        break;\n      v26 = *(_QWORD *)(v16 + 224);\n      v27 = _per_cpu_offset[next_bit];\n      if ( *(_QWORD *)(v26 + v27) == drvdata )\n      {\n        *(_QWORD *)(v27 + v26) = 0LL;\n        _InterlockedDecrement((volatile signed __int32 *)(drvdata + 24));\n      }\n    }\n    if ( *(_DWORD *)(drvdata + 24) != 1 && !_warned_29878 )\n    {\n      v19 = 3253LL;\n      warn_slowpath_null((__int64)\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3253, next_bit, v21, v22, v23);\n      _warned_29878 = 1;\n    }\n    kfree(drvdata, a2, a3, a4, a5, v24, v25, a8, a9, v19, v18, v21, v22, v23);\n  }\n  else if ( !_warned_29862 )\n  {\n    warn_slowpath_null((__int64)\"arch/x86/kernel/cpu/perf_event_intel_uncore.c\", 3237, v9, v10, v12, v13);\n    _warned_29862 = 1;\n  }\n}\n",
    "source_code": "\nstatic void uncore_pci_remove(struct pci_dev *pdev)\n{\n\tstruct intel_uncore_box *box = pci_get_drvdata(pdev);\n\tstruct intel_uncore_pmu *pmu = box->pmu;\n\tint cpu, phys_id = pcibus_to_physid[pdev->bus->number];\n\n\tif (WARN_ON_ONCE(phys_id != box->phys_id))\n\t\treturn;\n\n\tpci_set_drvdata(pdev, NULL);\n\n\traw_spin_lock(&uncore_box_lock);\n\tlist_del(&box->list);\n\traw_spin_unlock(&uncore_box_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (*per_cpu_ptr(pmu->box, cpu) == box) {\n\t\t\t*per_cpu_ptr(pmu->box, cpu) = NULL;\n\t\t\tatomic_dec(&box->refcnt);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&box->refcnt) != 1);\n\tkfree(box);\n}",
    "comment": "Removes an uncore PCI device, updates reference counts, and frees associated resources while ensuring proper synchronization in a multi-CPU environment.",
    "hext5_sum": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Removes a PCI device from its bus if it is the only user , otherwise drops the device .\n",
    "cpbcs_sum": "Disables a specified CPU's PMU if it is not currently active and removes the associated device.\n",
    "misum_sum": "Unregisters a hardware performance monitoring unit if it is not currently present and unregisters the associated driver link.\n",
    "decom_sum": "Unregisters an Intel uncore performance event, cleans up linked structures, updates counters, and logs errors if unexpected state conditions are detected.",
    "cfg_sum": "Validates a CPU uncore performance event against expected type, unlinks and cleans associated data structures, updates state flags, and finalizes event removal.",
    "work_score": {
        "hext5": {
            "summary": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary talks about the structure of a stack frame in the Intel world, including frame pointers, arguments, return addresses, and local variables. These claims do not correspond to or describe anything in the provided source code, which concerns removing a PCI device and managing uncore PMU data structures. All claims are unrelated to the source semantics, resulting in no accurate matches.",
                "The summary discusses stack frame structure in the Intel architecture, which is unrelated to the source code provided. The source function handles removal of a PCI device\u2019s uncore structure, including driver data cleanup, locking operations, per-CPU pointer updates, reference counting, and freeing memory. None of these CSU_LIST elements are mentioned in the summary, and the PRIMARY PURPOSE is entirely missed. The summary is pure noise with no accurate claims about the code\u2019s semantics.",
                "The summary makes fact-based claims about stack frame layout in the Intel architecture, which are unrelated to the provided source code that handles PCI device removal and resource cleanup in the uncore driver. All claims are NOISE, with no alignment to code semantics, primary purpose, or I/O. This results in an overwhelming negative impact from irrelevant content and provides no usable insight into the actual implementation."
            ]
        },
        "bint5": {
            "summary": "Removes a PCI device from its bus if it is the only user , otherwise drops the device .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function removes a PCI device from its bus if it is the only user, otherwise drops the device. This is inaccurate because the source code does not involve checking whether the device is the only user before removal; instead, it removes driver data, deletes the device from a list under a lock, updates per-CPU pointers, decrements a reference count, warns if the count is not 1, and frees the structure. The 'only user' condition and 'drops the device' are not reflected in the code logic, making the claim largely inaccurate.",
                "The summary inaccurately states the behavior as removing a PCI device only if it is the sole user, otherwise dropping it, which contradicts the code. The source code unconditionally performs cleanup after checking a phys_id mismatch, with no logic about multiple users. This misses the primary purpose of safely removing and cleaning up the uncore PCI device and fails to capture secondary details such as WARN_ON_ONCE checks, locking, list removal, per-CPU pointer clear, and refcount management.",
                "The summary claims the function removes a PCI device from its bus only if it is the sole user, otherwise drops the device. This is inaccurate: the source code does not remove the device from its bus in that conditional manner, but always proceeds with cleanup if the phys_id matches, involving list removal, pointer nullification, reference count decrement, and memory freeing. The primary purpose and logic flow are misstated, constituting a FATAL error about key I/O behavior. There are no accurate claims to provide value."
            ]
        },
        "cpbcs": {
            "summary": "Disables a specified CPU's PMU if it is not currently active and removes the associated device.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function disables a specified CPU's PMU if it is not currently active, which is inaccurate since the source code does not perform an 'inactive' check or conditional disable; instead, it removes a PCI device's associated structures, clears per-CPU pointers, decrements a reference count, and frees memory. The claim about removing the associated device is broadly safe. Overall, less than half of the claims align accurately with the code.",
                "The summary incorrectly describes the function as disabling a CPU's PMU if inactive, which is not present in the source. The actual implementation removes an uncore PCI device, with steps including driver data cleanup, list and lock handling, per-CPU pointer updates, and freeing memory. This mismatch means the primary purpose is missed, and specific secondary behaviors are not addressed.",
                "The summary inaccurately claims that the function disables a CPU\u2019s PMU and checks for active CPUs, which does not occur in the source code. The actual implementation removes an uncore PCI device, cleans up driver data, and frees memory. This misrepresentation directly targets the core purpose, indicating a FATAL misunderstanding with no accurate insights to offset it."
            ]
        },
        "misum": {
            "summary": "Unregisters a hardware performance monitoring unit if it is not currently present and unregisters the associated driver link.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function unregisters a hardware performance monitoring unit only if it is not currently present, which is inaccurate because the source code removes `intel_uncore_box` unconditionally, with checks on `phys_id` but not presence status. It also claims it unregisters the associated driver link, which loosely matches the code's `pci_set_drvdata` and list removal, but the core condition in the summary misrepresents the implementation. Overall, most claims contradict the code\u2019s actual behavior, resulting in low accuracy.",
                "The summary incorrectly states that the function unregisters a PMU only if it is not present, which contradicts the source code. The code always cleans up driver data for the PCI device, removes the uncore box from a list, clears per-CPU pointers, decrements reference counts, and frees memory, with a WARN_ON_ONCE check for mismatched phys_id. The primary purpose and actual sequence of cleanup operations are not captured, and critical details like locking, refcount handling, and error checks are completely missed.",
                "The summary's claim that the function unregisters a hardware performance monitoring unit if it is not currently present is inaccurate; the source code removes the given PCI device's uncore PMU regardless of presence, checking phys_id for consistency instead. The 'unregisters the associated driver link' portion is vaguely aligned with pci_set_drvdata(NULL) and list_del operations, but lacks specificity and misrepresents the actual teardown steps. The primary purpose is misstated, which is a FATAL error impacting understanding of key I/O behavior."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5511035,
    "strip_function_name": "sub_54177B",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_54177B(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  unsigned int v17; // ebp\n  __int64 v18; // rcx\n  char *v19; // rdx\n  unsigned __int64 result; // rax\n  char v21; // [rsp+0h] [rbp-28h]\n  int v22[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  while ( 1 )\n  {\n    v10 = sub_518073(v22);\n    v17 = v10;\n    if ( v10 <= 0 )\n      break;\n    if ( HIDWORD(qword_89A670) )\n      sub_54218B((unsigned int)v10);\n    if ( DWORD1(xmmword_89A678) )\n      --DWORD1(xmmword_89A678);\n    if ( (_DWORD)qword_89A670 )\n    {\n      if ( (v22[0] & 0x7F) != 0 )\n      {\n        v13 = (v22[0] & 0x7Fu) + 1;\n        v18 = v22[0] & 0x7F;\n        v19 = \"?exit\";\n        LOBYTE(v13) = (char)((v22[0] & 0x7F) + 1) >> 1;\n        if ( (char)v13 > 0 )\n          v19 = \"signal\";\n        else\n          v18 = 0LL;\n      }\n      else\n      {\n        v18 = BYTE1(v22[0]);\n        v19 = \"?exit\" + 1;\n      }\n      a10 = v17;\n      sub_517A10(\"end %d %s %d\", v17, (__int64)v19, v18, v13, v14, a1, a2, a3, a4, v15, v16, a7, a8, v21);\n    }\n  }\n  result = (unsigned int)qword_89A670;\n  if ( (_DWORD)qword_89A670 )\n    return sub_54173A(a1, a2, a3, a4, v15, v16, a7, a8, (__int64)v22, a10, v11, v12, v13, v14, v21);\n  return result;\n}\n",
    "function_name": "sig_child_handler",
    "decompiled_code": "unsigned __int64 __fastcall sig_child_handler(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  unsigned int v17; // ebp\n  __int64 v18; // rcx\n  char *v19; // rdx\n  unsigned __int64 result; // rax\n  char v21; // [rsp+0h] [rbp-28h]\n  int v22[7]; // [rsp+Ch] [rbp-1Ch] BYREF\n\n  while ( 1 )\n  {\n    v10 = wait_any_nohang(v22);\n    v17 = v10;\n    if ( v10 <= 0 )\n      break;\n    if ( *(_DWORD *)&bb_common_bufsiz1[4] )\n      ipsvd_perhost_remove(\n        v10,\n        *(double *)a1.m128_u64,\n        *(double *)a2.m128_u64,\n        *(double *)a3.m128_u64,\n        *(double *)a4.m128_u64,\n        *(double *)v15.m128_u64,\n        *(double *)v16.m128_u64,\n        *(double *)a7.m128_u64,\n        *(double *)a8.m128_u64);\n    if ( HIDWORD(xmmword_89A678) )\n      --HIDWORD(xmmword_89A678);\n    if ( *(_DWORD *)bb_common_bufsiz1 )\n    {\n      if ( (v22[0] & 0x7F) != 0 )\n      {\n        v13 = (v22[0] & 0x7Fu) + 1;\n        v18 = v22[0] & 0x7F;\n        v19 = \"?exit\";\n        LOBYTE(v13) = (char)((v22[0] & 0x7F) + 1) >> 1;\n        if ( (char)v13 > 0 )\n          v19 = \"signal\";\n        else\n          v18 = 0LL;\n      }\n      else\n      {\n        v18 = BYTE1(v22[0]);\n        v19 = \"?exit\" + 1;\n      }\n      a10 = v17;\n      bb_error_msg(\n        (const __m128i *)\"end %d %s %d\",\n        v17,\n        (__int64)v19,\n        v18,\n        v13,\n        v14,\n        a1,\n        a2,\n        a3,\n        a4,\n        v15,\n        v16,\n        a7,\n        a8,\n        v21);\n    }\n  }\n  result = *(unsigned int *)bb_common_bufsiz1;\n  if ( *(_DWORD *)bb_common_bufsiz1 )\n    return connection_status(a1, a2, a3, a4, v15, v16, a7, a8, (__int64)v22, a10, v11, v12, v13, v14, v21);\n  return result;\n}\n",
    "source_code": "\nstatic void sig_child_handler(int sig_no UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint l;\n\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"child\");\n\twhile ((pid = wait_any_nohang(&wstat)) > 0) {\n\t\tfor (l = 0; l < dirn; ++l) {\n\t\t\tif (dir[l].ppid == pid) {\n\t\t\t\tdir[l].ppid = 0;\n\t\t\t\tprocessorstop(&dir[l]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "comment": "Handles SIGCHLD signals by cleaning up and processing terminated child processes that match entries in the directory.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reaps child processes , logs their exit statuses or signals , and updates the process list accordingly .\n",
    "cpbcs_sum": "Updates the receive window with new size, manages previous settings, and logs the received data if it differs from the current one.\n",
    "misum_sum": "Displays the status of active jobs in a formatted manner, allowing signal handling and preventing recursive mode settings.\n",
    "decom_sum": "Processes input events, logs termination or signal messages based on event codes, and triggers follow-up handling when active state is set.",
    "cfg_sum": "Processes input events, logs termination or signal details, performs cleanup if required, and returns a status indicating whether further handling is needed.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary 'push a pointer type.' does not correspond to any fact-based claims about the source code. It is vague, does not describe the signal handler logic or child process handling in the code, and provides no accurate information relevant to the source implementation. All claims are effectively noise, resulting in no alignment with the evaluation steps.",
                "The summary 'push a pointer type' does not match or address the source code's primary purpose or behavior. The source handles SIGCHLD signals, performs non-blocking waits for child processes, updates a process list, and stops associated processors. The summary is vague, unrelated to signal handling or process management, and provides no coverage of primary or secondary semantic details.",
                "The summary makes a generic and irrelevant statement about 'push a pointer type' which does not align with the source code's purpose of handling SIGCHLD signals and cleaning up child processes. This is pure NOISE with no ACCURATE claims, offering zero insight and failing to reflect any key semantics or I/O of the source implementation."
            ]
        },
        "bint5": {
            "summary": "Reaps child processes , logs their exit statuses or signals , and updates the process list accordingly .\n",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary contains three claims: that the function reaps child processes, logs their exit statuses or signals, and updates the process list. The first claim is accurate as the loop uses wait_any_nohang to reap children. The second claim is inaccurate because the code logs only a fixed message when verbose is enabled, not specific exit statuses or signals. The third claim is accurate in that it updates the process list by setting ppid to 0 and stopping the processor for matching entries. Two of the three claims are accurate, producing a proportion around 66%, indicating mixed reliability.",
                "The summary correctly identifies the primary purpose of reaping child processes and updating the process list, which aligns with the loop using wait_any_nohang and updating dir[l].ppid. However, it inaccurately states that the function logs exit statuses or signals; the code only logs that a child signal was received when verbose is true, without exit/status details. It also omits secondary details such as the for-loop over dirn entries, the specific processorstop call, and the break condition. This yields partial coverage of the CSU_LIST with one notable inaccuracy on logging specifics.",
                "The summary correctly states that the function reaps child processes and updates a process list, which align with the loop using wait_any_nohang and setting dir[l].ppid to 0. However, it inaccurately claims that the code logs exit statuses or signals; in fact, it only logs a generic message when verbose is enabled, without reporting specific statuses or signals. This is a FATAL error since it misrepresents a key side effect related to logging behavior, which is part of the primary purpose description."
            ]
        },
        "cpbcs": {
            "summary": "Updates the receive window with new size, manages previous settings, and logs the received data if it differs from the current one.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes updating a receive window, managing settings, and logging changes, which are unrelated to the source code. The source code handles SIGCHLD signals, waits for terminated child processes, updates process parent IDs, and stops processors. All claims in the summary are inaccurate because they do not reflect any functionality from the provided code.",
                "The summary's claims about updating a receive window, managing settings, and logging received data are entirely unrelated to the source code, which handles SIGCHLD signals, waits for terminated child processes, and stops associated processors. This misses the primary purpose and all secondary details of the actual implementation, making the claims inaccurate and providing no coverage of relevant facts.",
                "The summary's claims about updating a receive window, managing settings, and logging received data do not match the source code, which handles a SIGCHLD signal, waits for terminated child processes, resets process IDs, and stops related processors. All claims are NOISE targeting unrelated functionality, with no accurate details about the actual signal handling logic, leading to overwhelming misinformation and no useful insight."
            ]
        },
        "misum": {
            "summary": "Displays the status of active jobs in a formatted manner, allowing signal handling and preventing recursive mode settings.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims it displays the status of active jobs in a formatted manner and prevents recursive mode settings, neither of which are reflected in the source code. The source instead handles SIGCHLD signals, iterates over child PIDs, stops associated processors, and updates state. These discrepancies mean none of the claims align with the actual implementation.",
                "The summary incorrectly describes the function as displaying the status of active jobs and handling mode settings, which is not reflected in the source code. The actual implementation is a signal handler for SIGCHLD that processes terminated child processes, updates their status, and stops associated processors. This means the primary purpose and critical secondary details, such as looping through child processes, matching ppid, and calling processorstop, are entirely missed. No accurate claims are present to map to the CSU_LIST.",
                "The summary makes broad claims about displaying active jobs and preventing recursive mode settings, which are not present in the source code. The source code handles SIGCHLD signals, waits for child processes to exit, and stops associated processors, but there is no job display or recursive mode logic. These mismatches are FATAL because they misrepresent the primary purpose and key behavior of the function, leading to unreliable understanding."
            ]
        }
    }
}
{
    "project_name": "bash",
    "function_addr": 947520,
    "strip_function_name": "rl_arrow_keys",
    "strip_decompiled_code": "__int64 __fastcall rl_arrow_keys(const char *a1)\n{\n  unsigned int v1; // ebp\n  int key; // eax\n  unsigned int v3; // ebx\n  const unsigned __int16 *v4; // rdx\n  __int32_t v5; // eax\n  bool v6; // cc\n\n  rl_readline_state |= 0x40uLL;\n  v1 = 1;\n  key = rl_read_key();\n  rl_readline_state &= ~0x40uLL;\n  if ( key < 0 )\n    return v1;\n  v3 = key;\n  v4 = *__ctype_b_loc();\n  v5 = v3;\n  if ( (v4[(unsigned __int8)v3] & 0x200) == 0 )\n  {\n    v6 = (int)v3 <= 66;\n    if ( v3 != 66 )\n      goto LABEL_4;\nLABEL_12:\n    rl_get_next_history((unsigned int)a1, v3);\n    return 0LL;\n  }\n  v5 = (*__ctype_toupper_loc())[(unsigned __int8)v3];\n  v6 = v5 <= 66;\n  if ( v5 == 66 )\n    goto LABEL_12;\nLABEL_4:\n  if ( v6 )\n  {\n    if ( v5 == 65 )\n    {\n      rl_get_previous_history((unsigned int)a1, v3);\n      return 0LL;\n    }\n  }\n  else\n  {\n    if ( v5 == 67 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v1 = rl_byte_oriented) != 0 )\n      {\n        rl_forward_byte((int)a1);\n        return 0;\n      }\n      else\n      {\n        rl_forward_char((const char *)(unsigned int)a1, v3);\n      }\n      return v1;\n    }\n    if ( v5 == 68 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v1 = rl_byte_oriented) != 0 )\n      {\n        v1 = 0;\n        rl_backward_byte((const char *)(unsigned int)a1);\n      }\n      else\n      {\n        rl_backward_char((const char *)(unsigned int)a1, v3);\n      }\n      return v1;\n    }\n  }\n  rl_ding(a1);\n  return 0LL;\n}\n",
    "function_name": "rl_arrow_keys",
    "decompiled_code": "int __fastcall rl_arrow_keys(int count, int key)\n{\n  int v2; // ebp\n  int v3; // eax\n  int v4; // ebx\n  const unsigned __int16 *v5; // rdx\n  __int32_t v6; // eax\n  bool v7; // cc\n\n  rl_readline_state |= 0x40uLL;\n  v2 = 1;\n  v3 = rl_read_key();\n  rl_readline_state &= ~0x40uLL;\n  if ( v3 < 0 )\n    return v2;\n  v4 = v3;\n  v5 = *__ctype_b_loc();\n  v6 = v4;\n  if ( (v5[(unsigned __int8)v4] & 0x200) == 0 )\n  {\n    v7 = v4 <= 66;\n    if ( v4 != 66 )\n      goto LABEL_4;\nLABEL_12:\n    rl_get_next_history(count, v4);\n    return 0;\n  }\n  v6 = (*__ctype_toupper_loc())[(unsigned __int8)v4];\n  v7 = v6 <= 66;\n  if ( v6 == 66 )\n    goto LABEL_12;\nLABEL_4:\n  if ( v7 )\n  {\n    if ( v6 == 65 )\n    {\n      rl_get_previous_history(count, v4);\n      return 0;\n    }\n  }\n  else\n  {\n    if ( v6 == 67 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v2 = rl_byte_oriented) != 0 )\n      {\n        rl_forward_byte(count, v4);\n        return 0;\n      }\n      else\n      {\n        rl_forward_char(count, v4);\n      }\n      return v2;\n    }\n    if ( v6 == 68 )\n    {\n      if ( __ctype_get_mb_cur_max() <= 1 || (v2 = rl_byte_oriented) != 0 )\n      {\n        v2 = 0;\n        rl_backward_byte(count, v4);\n      }\n      else\n      {\n        rl_backward_char(count, v4);\n      }\n      return v2;\n    }\n  }\n  rl_ding();\n  return 0;\n}\n",
    "source_code": "\nint\nrl_arrow_keys (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (ch < 0)\n    return (1);\n\n  switch (_rl_to_upper (ch))\n    {\n    case 'A':\n      rl_get_previous_history (count, ch);\n      break;\n\n    case 'B':\n      rl_get_next_history (count, ch);\n      break;\n\n    case 'C':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, ch);\n      else\n\trl_forward_byte (count, ch);\n      break;\n\n    case 'D':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_backward_char (count, ch);\n      else\n\trl_backward_byte (count, ch);\n      break;\n\n    default:\n      rl_ding ();\n    }\n\n  return 0;\n}",
    "comment": "Handles arrow key inputs to navigate command history or move the cursor forward/backward, depending on the key pressed and character encoding.",
    "hext5_sum": "get a pointer to struct dis386 with a valid name.",
    "bint5_sum": "Handles arrow keys input , converting them to uppercase or lowercase , and retrieves the corresponding key while managing state transitions .\n",
    "cpbcs_sum": "Processes a key input, validates it against a key, and checks for conflicts with a key sequence or retrieves the corresponding key sequence if not found.\n",
    "misum_sum": "Reads a character from a multibyte string, handling multibyte characters and returning the corresponding character value.\n",
    "decom_sum": "Handles arrow key input in readline, executing history navigation or cursor movement based on key codes and terminal character encoding settings.",
    "cfg_sum": "Handles arrow key inputs for command history navigation and cursor movement, supporting multibyte characters and falling back to byte-wise operations when necessary.",
    "work_score": {
        "hext5": {
            "summary": "get a pointer to struct dis386 with a valid name.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about obtaining a pointer to a struct dis386 with a valid name is entirely unrelated to the provided source code, which processes arrow key input in readline. This constitutes a semantic mismatch, so none of the claims are accurate.",
                "The summary describes obtaining a pointer to a struct dis386 with a valid name, which is entirely unrelated to the provided source code's purpose of handling arrow key input and executing navigation or movement functions. The summary fails to capture the primary purpose, input handling, or any secondary details from the source code, making it completely inaccurate.",
                "The summary claims that the function retrieves a pointer to a struct dis386, which has no connection to the source code. The actual function processes arrow key input and manipulates command-line history and cursor movement. This is a FATAL inaccuracy touching the primary purpose, resulting in very low alignment with evaluation steps."
            ]
        },
        "bint5": {
            "summary": "Handles arrow keys input , converting them to uppercase or lowercase , and retrieves the corresponding key while managing state transitions .\n",
            "score": [
                0.3,
                0.3,
                0.5
            ],
            "reason": [
                "The summary claims that the function converts arrow keys to uppercase or lowercase and retrieves the corresponding key. In the source code, the function does call `_rl_to_upper` to convert key input but not for lowercase, and it processes specific arrow key codes to execute navigation functions, not merely retrieve keys. The summary omits important details like the switch cases for A/B/C/D and incorrectly implies lowercase conversion. It correctly notes state management at the start and end, but overall less than half of the claims match the actual implementation.",
                "The summary vaguely notes handling arrow key input and managing state transitions, but incorrectly claims converting keys between uppercase/lowercase \u2014 the code only converts to uppercase via _rl_to_upper. It omits key behavioral details such as reading a key, specific cases for history navigation, forward/backward movement dependent on multibyte and byte-oriented settings, handling invalid keys by ringing a bell, and the return values in different conditions. While it references state management, it misses most critical semantics, including the primary purpose of mapping arrow keys to specific actions.",
                "The summary's claims are partially inaccurate. The code processes arrow key input by reading a character, managing readline state, and mapping specific key codes to history navigation, character/byte movement, or a ding. However, the summary incorrectly says it converts keys to uppercase or lowercase\u2014actually it only converts to uppercase using _rl_to_upper, not both cases. It also vaguely states 'retrieves the corresponding key' without noting the concrete actions taken, missing implementation specifics. There is no fatal misstatement about primary purpose/I/O, but the main description is generic and partly wrong, resulting in low-info gain and some NOISE."
            ]
        },
        "cpbcs": {
            "summary": "Processes a key input, validates it against a key, and checks for conflicts with a key sequence or retrieves the corresponding key sequence if not found.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function validates input against a key and checks or retrieves key sequences, which does not align with the source code. The source function reads a key input, maps certain key codes (A, B, C, D) to specific actions like navigating history or moving the cursor, and rings a bell otherwise. None of the described 'conflict checking' or 'key sequence retrieval' behavior is present. All extracted claims are inaccurate, resulting in no accurate match.",
                "The summary describes validating a key against another key and handling key sequences, which is not reflected in the source code. The actual function reads a character from input, interprets arrow key codes, and performs cursor or history navigation with specific conditions for multi-byte handling, none of which are correctly captured. The primary purpose of processing arrow key inputs is missed entirely, and there is no mention of secondary details like function calls for navigation or error handling when ch < 0.",
                "The summary introduces actions like validating input against a key, checking for conflicts, and retrieving a key sequence, none of which are in the source code. The actual function reads a key, determines its arrow key type, and moves through history or cursor accordingly. These discrepancies target the semantics of the code and misrepresent its primary purpose, constituting a FATAL error on key I/O and core logic. No accurate claims remain to provide useful insight."
            ]
        },
        "misum": {
            "summary": "Reads a character from a multibyte string, handling multibyte characters and returning the corresponding character value.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function reads a character from a multibyte string and returns its value, which does not accurately reflect the source code. The source code reads a key input, processes arrow key commands, and performs navigation or editing actions based on the input. There is mention of multibyte handling in the code, but returning the corresponding character value is incorrect. Most of the claims are inaccurate in describing the function's primary purpose, resulting in low accuracy.",
                "The summary incorrectly describes the function as reading a character from a multibyte string and returning its value, which contradicts the source code. The source shows that it reads a key input, processes arrow key commands for history navigation or cursor movement, and does not simply return the character value. It misses the primary purpose and key secondary details such as handling specific arrow keys, state management, and multibyte vs byte-oriented conditions.",
                "The summary claims the function reads a character from a multibyte string and returns the corresponding character value, which is inaccurate. The source code shows it reads a key input via rl_read_key, processes arrow key input for history navigation or cursor movement depending on multibyte handling, and returns status codes, not the character value. This is a FATAL error affecting the primary purpose and key I/O semantics. No accurate claims are present, leading to high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584059008,
    "strip_function_name": "sub_FFFFFFFF814F8E80",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814F8E80(\n        __int64 a1,\n        int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rdx\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  unsigned __int64 v21; // rax\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  unsigned int v24; // [rsp+2Ch] [rbp-44h]\n  __int64 v25; // [rsp+34h] [rbp-3Ch] BYREF\n\n  result = sub_FFFFFFFF8178F4A0(a1 + 480);\n  if ( !(_DWORD)result )\n  {\n    if ( *(_DWORD *)(a1 + 840) != a2 )\n    {\n      v16 = *(unsigned int *)(a1 + 984);\n      if ( (_DWORD)v16 )\n      {\n        LODWORD(result) = -22;\n      }\n      else if ( a2 )\n      {\n        sub_FFFFFFFF814F8710((_QWORD *)a1, a1 + 472, (__int64)&v25);\n        v21 = sub_FFFFFFFF814F7990(a1, (int)a1 + 472, v17, v18, v19, v20, v25);\n        *(_QWORD *)(a1 + 832) = 1000000000LL;\n        *(_QWORD *)(a1 + 824) = v21 + 1000000000;\n        LODWORD(result) = sub_FFFFFFFF814F8A70(a1, a1 + 784, a3, a4, a5, a6, v22, v23, a9, a10);\n      }\n      else\n      {\n        sub_FFFFFFFF814F8C00((_QWORD *)a1, a1 + 784, v16, v11, v12, v13, a3, a4, a5, a6, v14, v15, a9, a10);\n        LODWORD(result) = 0;\n      }\n    }\n    v24 = result;\n    sub_FFFFFFFF8178F1B0(a1 + 480);\n    return v24;\n  }\n  return result;\n}\n",
    "function_name": "rtc_update_irq_enable",
    "decompiled_code": "__int64 __fastcall rtc_update_irq_enable(\n        __int64 a1,\n        int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int v13; // edx\n  int v14; // ecx\n  int v15; // r8d\n  int v16; // r9d\n  __int64 v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // [rsp+2Ch] [rbp-44h]\n  __int64 v21; // [rsp+34h] [rbp-3Ch] BYREF\n\n  result = mutex_lock_interruptible(a1 + 480);\n  if ( !(_DWORD)result )\n  {\n    if ( *(_DWORD *)(a1 + 840) != a2 )\n    {\n      if ( *(_DWORD *)(a1 + 984) )\n      {\n        LODWORD(result) = -22;\n      }\n      else if ( a2 )\n      {\n        _rtc_read_time_isra_3((_QWORD *)a1, a1 + 472, (__int64)&v21);\n        v17 = rtc_tm_to_ktime(a1, (int)a1 + 472, v13, v14, v15, v16, v21);\n        *(_QWORD *)(a1 + 832) = 1000000000LL;\n        *(_QWORD *)(a1 + 824) = v17 + 1000000000;\n        LODWORD(result) = rtc_timer_enqueue((_QWORD *)a1, a1 + 784, a3, a4, a5, a6, v18, v19, a9, a10);\n      }\n      else\n      {\n        rtc_timer_remove((_QWORD *)a1, a1 + 784, a3, a4, a5, a6, v11, v12, a9, a10);\n        LODWORD(result) = 0;\n      }\n    }\n    v20 = result;\n    mutex_unlock(a1 + 480);\n    return v20;\n  }\n  return result;\n}\n",
    "source_code": "\nint rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tif (enabled == 0 && rtc->uie_irq_active) {\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, 0);\n\t}\n#endif\n\t/* make sure we're changing state */\n\tif (rtc->uie_rtctimer.enabled == enabled)\n\t\tgoto out;\n\n\tif (rtc->uie_unsupported) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (enabled) {\n\t\tstruct rtc_time tm;\n\t\tktime_t now, onesec;\n\n\t\t__rtc_read_time(rtc, &tm);\n\t\tonesec = ktime_set(1, 0);\n\t\tnow = rtc_tm_to_ktime(tm);\n\t\trtc->uie_rtctimer.node.expires = ktime_add(now, onesec);\n\t\trtc->uie_rtctimer.period = ktime_set(1, 0);\n\t\terr = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);\n\t} else\n\t\trtc_timer_remove(rtc, &rtc->uie_rtctimer);\n\nout:\n\tmutex_unlock(&rtc->ops_lock);\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\t/*\n\t * Enable emulation if the driver did not provide\n\t * the update_irq_enable function pointer or if returned\n\t * -EINVAL to signal that it has been configured without\n\t * interrupts or that are not available at the moment.\n\t */\n\tif (err == -EINVAL)\n\t\terr = rtc_dev_update_irq_enable_emul(rtc, enabled);\n#endif\n\treturn err;\n\n}",
    "comment": "Updates the RTC interrupt state, enabling or disabling the timer based on the provided flag, while handling potential emulation requirements.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Disables a specified RTC timer , disables it , and sets the next alarm if available , while ensuring thread safety with a mutex lock .\n",
    "cpbcs_sum": "Sets the alarm timer for an evdev client, validating the new timer and timer before unlocking the new timer mutex.\n",
    "misum_sum": "Manages the RTC timer for a real-time clock timer while ensuring it is ready and adjusting for thread safety.\n",
    "decom_sum": "Updates hardware state when a mode change is requested, recalculating timing parameters or resetting configuration, then releases the associated synchronization lock.",
    "cfg_sum": "Updates device state when the target mode changes, invoking configuration routines or reset operations and returning success or error codes accordingly.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only a vague and unrelated phrase that does not accurately describe any part of the source code's functionality. It fails to identify specific actions in the implementation, such as mutex locking, enabling/disabling timers, or handling emulation, resulting in no accurate claims.",
                "The summary 'push a pointer type' is vague, lacks any fact-based claims related to the source code, and does not reflect the function's primary purpose of enabling or disabling RTC update IRQs under certain conditions with mutex locking, timer manipulation, and optional emulation handling. It misses all critical semantic units and contains no accurate mapping to source behavior.",
                "The summary 'push a pointer type' is entirely unrelated to the provided source code, which implements RTC update interrupt enabling logic. It contains no accurate claims, and constitutes pure NOISE with no insight into the code's functionality, purpose, or I/O. The worst failure mode is overwhelming NOISE, yielding zero benefit."
            ]
        },
        "bint5": {
            "summary": "Disables a specified RTC timer , disables it , and sets the next alarm if available , while ensuring thread safety with a mutex lock .\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function sets the next alarm if available and focuses on disabling the RTC timer, while the source code supports both enabling and disabling the timer and specifically sets the expiration for periodic updates rather than an alarm. The mutex lock detail is accurate, but the rest of the summary omits and misrepresents significant aspects, leading to less than half of the claims being accurate.",
                "The summary correctly notes that the function manages an RTC timer and uses a mutex lock for thread safety, which aligns with the primary purpose. However, it repeats 'disables' unnecessarily and omits key secondary details from the source code, such as handling both enable and disable states, checking if the state change is necessary, dealing with unsupported conditions, setting timer expiry and period when enabling, removing timers when disabling, and conditional emulation paths based on configuration and error codes. The explanation lacks coverage of error handling and CONFIG_RTC_INTF_DEV_UIE_EMUL logic critical to the implementation.",
                "The summary is inaccurate because it oversimplifies and misrepresents the function\u2019s behavior. The source code conditionally enables or disables the RTC update interrupt, with several guard checks, emulation paths, and specific handling for unsupported configurations. The summary omits enabling logic, emulation, and error handling, and incorrectly describes always setting the next alarm if available. This is a semantic contradiction on primary purpose (changing update IRQ state), which is a FATAL error despite correct mention of mutex lock for thread safety."
            ]
        },
        "cpbcs": {
            "summary": "Sets the alarm timer for an evdev client, validating the new timer and timer before unlocking the new timer mutex.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function sets an alarm timer for an evdev client and validates timers with a mutex. The source code instead enables or disables the RTC update interrupt, possibly emulated, using various RTC-specific checks and operations; it does not interact with evdev clients or alarm timers. The mutex usage is related to ops_lock, not a 'new timer mutex'. All claims are inaccurate and do not match the implementation.",
                "The summary is inaccurate: it claims the function sets an alarm timer for an evdev client, which is not reflected in the source code. The actual code enables or disables the RTC update interrupt, handles emulation, validates state changes, and manages timers accordingly. The summary omits these behaviors and introduces unrelated concepts like 'evdev client', thus missing the primary purpose and all key secondary details.",
                "The summary makes a broad, inaccurate claim about setting an alarm timer for an evdev client, which is unrelated to the actual function purpose. The source code is about enabling or disabling RTC update interrupts with validation, mutex locking, and optional emulation handling. The summary\u2019s reference to an evdev client and alarm timer is a semantic mismatch (FATAL) targeting the primary purpose incorrectly, with no accurate supporting claims."
            ]
        },
        "misum": {
            "summary": "Manages the RTC timer for a real-time clock timer while ensuring it is ready and adjusting for thread safety.\n",
            "score": [
                0.3,
                0.3,
                0.5
            ],
            "reason": [
                "The summary contains only a broad statement about managing an RTC timer and ensuring readiness and thread safety. While the mutex usage aligns with the thread safety claim, it omits key specific behaviors from the source code such as conditional handling for emulation, checking unsupported state, and the enqueue/remove of the timer based on 'enabled'. The lack of detail means most atomic claims are too general, giving limited direct semantic coverage of the implementation, resulting in less than half of claims being precise and accurate.",
                "The summary captures a vague notion of managing the RTC timer and mentions thread safety, which loosely aligns with the mutex usage in the code. However, it misses the primary purpose of enabling or disabling update interrupts, as well as critical secondary details such as handling unsupported cases, emulation paths, and specific timer period settings. The lack of precision and omission of key behaviors reduces alignment significantly.",
                "The summary contains only a broad SAFE claim about managing an RTC timer and ensuring thread safety, which loosely aligns with the source code\u2019s use of mutexes and enabling/disabling the RTC update interrupt. However, it lacks specificity about the key control flow, such as handling emulation mode, checking unsupported states, and timer configuration, and does not introduce any FATAL inaccuracies. The net benefit is low due to minimal detail, representing low gain."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 359616,
    "strip_function_name": "sub_57CC0",
    "strip_decompiled_code": "__int64 __fastcall sub_57CC0(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rax\n  char *v5; // rax\n  int v6; // edx\n  unsigned int v7; // eax\n  socklen_t optlen; // [rsp+Ch] [rbp-8Ch] BYREF\n  _BYTE optval[68]; // [rsp+10h] [rbp-88h] BYREF\n  int v11; // [rsp+54h] [rbp-44h]\n  int v12; // [rsp+58h] [rbp-40h]\n  int v13; // [rsp+60h] [rbp-38h]\n  int v14; // [rsp+70h] [rbp-28h]\n  unsigned __int64 v15; // [rsp+78h] [rbp-20h]\n\n  v15 = __readfsqword(0x28u);\n  v4 = *(_QWORD *)(a1 + 8);\n  optlen = 104;\n  if ( getsockopt(*(_DWORD *)(v4 + 24), 6, 11, optval, &optlen) == -1 )\n  {\n    *(_BYTE *)(a2 + 3) |= 0x40u;\n    return 0LL;\n  }\n  else\n  {\n    v5 = (char *)ngx_pnalloc(*(_QWORD **)(a1 + 88), 0xBuLL);\n    *(_QWORD *)(a2 + 8) = v5;\n    if ( v5 )\n    {\n      if ( a3 == 1 )\n      {\n        v6 = v12;\n      }\n      else if ( a3 )\n      {\n        if ( a3 == 2 )\n        {\n          v6 = v13;\n        }\n        else if ( a3 == 3 )\n        {\n          v6 = v14;\n        }\n        else\n        {\n          v6 = 0;\n        }\n      }\n      else\n      {\n        v6 = v11;\n      }\n      v7 = ((unsigned int)ngx_sprintf(v5, \"%uD\", v6) - *(_DWORD *)(a2 + 8)) & 0xFFFFFFF | *(_DWORD *)a2 & 0xF0000000;\n      *(_DWORD *)a2 = v7;\n      *(_BYTE *)(a2 + 3) = HIBYTE(v7) & 0x8F | 0x10;\n      return 0LL;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n}\n",
    "function_name": "ngx_http_variable_tcpinfo",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)\n{\n  ngx_connection_t *connection; // rax\n  u_char *v5; // rax\n  uint32_t tcpi_rttvar; // edx\n  unsigned int v7; // eax\n  socklen_t len; // [rsp+Ch] [rbp-8Ch] BYREF\n  tcp_info ti; // [rsp+10h] [rbp-88h] BYREF\n  unsigned __int64 v11; // [rsp+78h] [rbp-20h]\n\n  v11 = __readfsqword(0x28u);\n  connection = r->connection;\n  len = 104;\n  if ( getsockopt(connection->fd, 6, 11, &ti, &len) == -1 )\n  {\n    *((_BYTE *)v + 3) |= 0x40u;\n    return 0LL;\n  }\n  else\n  {\n    v5 = (u_char *)ngx_pnalloc(r->pool, 0xBuLL);\n    v->data = v5;\n    if ( v5 )\n    {\n      if ( data == 1 )\n      {\n        tcpi_rttvar = ti.tcpi_rttvar;\n      }\n      else if ( data )\n      {\n        if ( data == 2 )\n        {\n          tcpi_rttvar = ti.tcpi_snd_cwnd;\n        }\n        else if ( data == 3 )\n        {\n          tcpi_rttvar = ti.tcpi_rcv_space;\n        }\n        else\n        {\n          tcpi_rttvar = 0;\n        }\n      }\n      else\n      {\n        tcpi_rttvar = ti.tcpi_rtt;\n      }\n      v7 = ((unsigned int)ngx_sprintf(v5, \"%uD\", tcpi_rttvar) - LODWORD(v->data)) & 0xFFFFFFF | *(_DWORD *)v & 0xF0000000;\n      *(_DWORD *)v = v7;\n      *((_BYTE *)v + 3) = HIBYTE(v7) & 0x8F | 0x10;\n      return 0LL;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n}\n",
    "source_code": "\nstatic ngx_int_t\nngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)\n{\n    struct tcp_info  ti;\n    socklen_t        len;\n    uint32_t         value;\n\n    len = sizeof(struct tcp_info);\n    if (getsockopt(r->connection->fd, IPPROTO_TCP, TCP_INFO, &ti, &len) == -1) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    switch (data) {\n    case 0:\n        value = ti.tcpi_rtt;\n        break;\n\n    case 1:\n        value = ti.tcpi_rttvar;\n        break;\n\n    case 2:\n        value = ti.tcpi_snd_cwnd;\n        break;\n\n    case 3:\n        value = ti.tcpi_rcv_space;\n        break;\n\n    /* suppress warning */\n    default:\n        value = 0;\n        break;\n    }\n\n    v->len = ngx_sprintf(v->data, \"%uD\", value) - v->data;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}",
    "comment": "Retrieves TCP connection statistics like RTT, RTT variance, send window size, or receive space and stores the result in an HTTP variable.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Checks for connection errors on a socket to an upstream server , handling both kqueue and standard socket error retrieval methods .\n",
    "cpbcs_sum": "Creates a socket for reading from a specified server, ensuring it is not already created and handling errors appropriately.\n",
    "misum_sum": "Retrieves the number of connections from an upstream server and stores it in the variable structure for future use.\n",
    "decom_sum": "Retrieves TCP connection information via `getsockopt`, formats a selected metric as a string, and updates the provided output structure accordingly.",
    "cfg_sum": "Retrieves TCP connection metrics via `getsockopt`, formats the selected value, updates status flags, and handles memory allocation or error conditions.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
            "score": [
                0.0,
                0.1,
                0.0
            ],
            "reason": [
                "The summary describes grouping nodes into destinations and setting associated nodes and characters, as well as returning a count or -1 on error. None of these claims align with the source code, which handles TCP info retrieval using getsockopt, selects specific tcp_info fields, formats them, and sets HTTP variable attributes. The summary is entirely unrelated to the function's semantics.",
                "The summary describes behavior involving grouping nodes into destinations and setting characters, which does not align with the source function. The source code retrieves TCP socket info, selects specific fields based on a 'data' parameter, formats them into a variable value, and handles errors when getsockopt or memory allocation fails. The summary misses the primary purpose entirely and contains unrelated domain-specific details, resulting in no accurate claim coverage.",
                "The summary's claims are entirely unrelated to the source code. The code retrieves TCP connection info via getsockopt, formats a specific TCP metric into a string, and sets the variable fields, while the summary discusses destinations, nodes, and character acceptance with a function returning counts or errors. This is pure NOISE with no accurate claims extracted from the source, leading to complete mismatch and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Checks for connection errors on a socket to an upstream server , handling both kqueue and standard socket error retrieval methods .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function checks for connection errors on a socket to an upstream server and uses both kqueue and standard socket error retrieval methods. The source code actually retrieves TCP connection metrics using getsockopt with TCP_INFO and does not involve error checking, upstream server logic, or kqueue. All claims are inaccurate relative to the code.",
                "The summary claims the function checks for connection errors using kqueue and standard socket methods, but the code actually retrieves TCP information via getsockopt and populates a variable value based on specific TCP metrics. The described behavior in the summary mismatches the code\u2019s primary purpose and its secondary details entirely, resulting in no accurate coverage.",
                "The summary claims that the code checks for connection errors on a socket to an upstream server and handles both kqueue and standard error methods, which is directly contradicted by the source. The actual code retrieves TCP connection metrics (rtt, rttvar, snd_cwnd, rcv_space) via getsockopt using TCP_INFO, with no logic for kqueue or upstream error handling. This is a FATAL misrepresentation of the primary purpose, as it misstates the key I/O and functionality."
            ]
        },
        "cpbcs": {
            "summary": "Creates a socket for reading from a specified server, ensuring it is not already created and handling errors appropriately.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes creating a socket for reading from a specified server and ensuring it is not already created, which is unrelated to the actual code. The source code retrieves TCP information via getsockopt from an existing connection, allocates memory, and writes values based on the requested data type. None of the summary\u2019s claims match the implementation; all claims are inaccurate.",
                "The summary misrepresents the function entirely, describing socket creation and server reading, which is not in the source. The code retrieves TCP connection info using getsockopt, selects specific fields based on input, formats them, and populates the ngx_http_variable_value_t structure with error handling. The primary purpose and secondary details from the code are missed, and the single claim is inaccurate and unrelated to the actual behavior.",
                "The summary claims the function creates a socket for reading from a specified server, ensures it is not already created, and handles errors. In reality, the source function does not create sockets or connect to a server; it retrieves TCP info from an existing connection's file descriptor via getsockopt and formats specific fields into a string. This is a FATAL error about the primary purpose, as it completely misidentifies the function's role and key I/O, leading to unreliable understanding."
            ]
        },
        "misum": {
            "summary": "Retrieves the number of connections from an upstream server and stores it in the variable structure for future use.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function retrieves the number of connections from an upstream server, which is inaccurate. The source code actually obtains TCP connection information (e.g., RTT, RTT variance, send congestion window, receive space) from the current socket using getsockopt. None of the described behavior about upstream connections is present, making the claim contradict the implementation.",
                "The summary incorrectly states that the function retrieves the number of connections from an upstream server, which does not match the source code. The code actually gathers TCP-related metrics (RTT, RTT variance, send congestion window, receive space) from the current connection via getsockopt. This is a semantic mismatch, missing the primary purpose entirely and not covering any secondary implementation details.",
                "The summary's claim that the function retrieves the number of connections from an upstream server is inaccurate and contradicts the source code. The actual implementation retrieves TCP-level metrics such as RTT, RTT variance, send congestion window, or receive space using getsockopt on the current connection, not an upstream connection count. This is a FATAL error targeting the function\u2019s primary purpose, leaving no accurate claims and causing high negative impact."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5042992,
    "strip_function_name": "sub_4CF330",
    "strip_decompiled_code": "__int64 __fastcall sub_4CF330(__int64 a1)\n{\n  const char *v2; // rdi\n  FILE *v3; // rax\n  FILE *v4; // rax\n  __int64 result; // rax\n  int *v6; // rax\n  __int64 v7; // rbp\n  int *v8; // rax\n\n  v2 = *(const char **)(a1 + 16);\n  if ( !v2 || !*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 32) )\n  {\n    *(__m128i *)(a1 + 188) = _mm_load_si128((const __m128i *)&xmmword_51F490);\n    strcpy((char *)(a1 + 236), \" or outfile.\");\n    *(__m128i *)(a1 + 204) = _mm_load_si128((const __m128i *)&xmmword_51F4A0);\n    *(__m128i *)(a1 + 220) = _mm_load_si128((const __m128i *)&xmmword_51F4B0);\n    sub_4CFBA0(a1, a1 + 188, 0LL);\n    return 0LL;\n  }\n  v3 = fopen(v2, \"wb\");\n  *(_QWORD *)(a1 + 48) = v3;\n  if ( !v3 )\n  {\n    v6 = __errno_location();\n    v7 = a1 + 188;\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 16),\n      (unsigned int)*v6);\nLABEL_12:\n    sub_4CFBA0(a1, v7, 0LL);\n    return 0LL;\n  }\n  v4 = fopen(*(const char **)(a1 + 24), \"wb\");\n  *(_QWORD *)(a1 + 40) = v4;\n  if ( !v4 )\n  {\n    v8 = __errno_location();\n    v7 = a1 + 188;\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 24),\n      (unsigned int)*v8);\n    goto LABEL_12;\n  }\n  result = sub_4D0600(a1, *(_QWORD *)(a1 + 48), v4);\n  if ( (int)result > 0 )\n    return 1LL;\n  return result;\n}\n",
    "function_name": "libjte_write_header",
    "decompiled_code": "__int64 __fastcall libjte_write_header(__int64 a1)\n{\n  const char *v2; // rdi\n  FILE *v3; // rax\n  FILE *v4; // rax\n  __int64 result; // rax\n  int *v6; // rax\n  const char *v7; // rbp\n  int *v8; // rax\n\n  v2 = *(const char **)(a1 + 16);\n  if ( !v2 || !*(_QWORD *)(a1 + 24) || !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 32) )\n  {\n    *(__m128i *)(a1 + 188) = _mm_load_si128((const __m128i *)&xmmword_51F490);\n    strcpy((char *)(a1 + 236), \" or outfile.\");\n    *(__m128i *)(a1 + 204) = _mm_load_si128((const __m128i *)&xmmword_51F4A0);\n    *(__m128i *)(a1 + 220) = _mm_load_si128(xmmword_51F4B0);\n    libjte_add_msg_entry(a1, (const char *)(a1 + 188), 0);\n    return 0LL;\n  }\n  v3 = fopen(v2, byte_51F41B);\n  *(_QWORD *)(a1 + 48) = v3;\n  if ( !v3 )\n  {\n    v6 = __errno_location();\n    v7 = (const char *)(a1 + 188);\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 16),\n      (unsigned int)*v6);\nLABEL_12:\n    libjte_add_msg_entry(a1, v7, 0);\n    return 0LL;\n  }\n  v4 = fopen(*(const char **)(a1 + 24), byte_51F41B);\n  *(_QWORD *)(a1 + 40) = v4;\n  if ( !v4 )\n  {\n    v8 = __errno_location();\n    v7 = (const char *)(a1 + 188);\n    sprintf(\n      (char *)(a1 + 188),\n      \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n      *(_QWORD *)(a1 + 24),\n      (unsigned int)*v8);\n    goto LABEL_12;\n  }\n  result = write_jt_header(a1, *(FILE **)(a1 + 48), v4);\n  if ( (int)result > 0 )\n    return 1LL;\n  return result;\n}\n",
    "source_code": "\nint libjte_write_header(struct libjte_env *o)\n{\n    int ret;\n\n    if (o->jtemplate_out == NULL || o->jjigdo_out == NULL ||\n        o->outfile == NULL || o->jmd5_list == NULL) {\n        sprintf(o->message_buffer,\n               \"Undefined: template_path, jigdo_path, md5_paths, or outfile.\");\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    \n    o->jttemplate = fopen(o->jtemplate_out, \"wb\");\n    if (o->jttemplate == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n                o->jtemplate_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    o->jtjigdo = fopen(o->jjigdo_out, \"wb\");\n    if (o->jtjigdo == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n                o->jjigdo_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n\n    ret = write_jt_header(o, o->jttemplate, o->jtjigdo);\n    if (ret <= 0)\n        return ret;\n    return 1;\n}",
    "comment": "Initializes output files for a template and jigdo, checks for errors, and writes the header using the provided environment structure.",
    "hext5_sum": "add the prefix to the client.",
    "bint5_sum": "Writes a GNU tar long filename to a specified file or stdout if no filename is provided , ensuring proper initialization and error handling .\n",
    "cpbcs_sum": "Opens a directory for reading and writing at the first file for the specified path if not already created.\n",
    "misum_sum": "Clones a dynamic library structure, initializes its properties, and manages its state and attributes while ensuring proper resource management and mutex handling.\n",
    "decom_sum": "Opens specified template and jigdo output files for writing, reports errors if unsuccessful, and processes them with a file-handling routine.",
    "cfg_sum": "Opens specified template and jigdo files for writing after validating inputs, reports errors if opening fails, and processes them to generate output.",
    "work_score": {
        "hext5": {
            "summary": "add the prefix to the client.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary does not make any fact-based claims about the source code\u2019s behavior or implementation. It is unrelated to the provided function, which deals with writing template and jigdo headers and handling file operations. This results in 0% accurate claims.",
                "The summary does not contain any fact-based claims relevant to the source code. It provides an unrelated statement ('add the prefix to the client') that fails to identify the primary purpose of the function or any secondary details such as file opening, error handling, or message logging. There is no accurate mapping to the code's behavior, resulting in no coverage of critical semantic units.",
                "The summary makes a vague claim about adding a prefix to the client, which is unrelated to the source code's functionality of opening files and writing a header. This is pure NOISE, with no ACCURATE claims extracted. The worst failure mode is overwhelming NOISE, providing no benefit to understanding the key I/O or side effects in the code."
            ]
        },
        "bint5": {
            "summary": "Writes a GNU tar long filename to a specified file or stdout if no filename is provided , ensuring proper initialization and error handling .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly claims the function writes a GNU tar long filename to a file or stdout, which is not reflected in the source code. The code opens specified template and jigdo output files for writing, checks for null pointers, writes headers via write_jt_header, and handles errors, but has no GNU tar-specific logic or stdout fallback. This means the core claim is inaccurate, with only a minor alignment in mentioning initialization and error handling.",
                "The summary incorrectly states that the function writes a GNU tar long filename to a file or stdout, which is unrelated to the actual code. The function\u2019s primary purpose is to open two specified output files (template and jigdo) and write headers using `write_jt_header`, with extensive error handling for missing paths or failed file openings. None of these core behaviors are accurately captured in the summary, leading to a mismatch on both the primary purpose and key secondary details.",
                "The summary claims the function writes a GNU tar long filename to a file or stdout, which is unsupported by the source. The code writes headers to two output files (template and jigdo) using write_jt_header, with no GNU tar logic or stdout handling present. This is a FATAL error because it misstates the primary purpose of the function. While it correctly notes error handling initialization, the central claim is inaccurate, significantly reducing reliability."
            ]
        },
        "cpbcs": {
            "summary": "Opens a directory for reading and writing at the first file for the specified path if not already created.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function opens a directory for reading and writing, which is inaccurate because the source code actually opens specific files (template and jigdo) for writing in binary mode after checking for null parameters. There is no directory handling or reading logic, so the claim contradicts the source semantics. All claims are inaccurate, yielding no alignment.",
                "The summary incorrectly claims that the function opens a directory for reading and writing, which contradicts the source code's actual behavior of opening specific files (template and jigdo) for writing and handling missing paths or open failures. It misses the primary purpose and all secondary details, such as conditional checks and error messaging.",
                "The summary claims the function opens a directory for reading and writing, which directly contradicts the source code that opens two specific files (template and jigdo) for writing in binary mode. This is a FATAL error impacting the primary purpose and key I/O description, as it misrepresents the core functionality."
            ]
        },
        "misum": {
            "summary": "Clones a dynamic library structure, initializes its properties, and manages its state and attributes while ensuring proper resource management and mutex handling.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function clones a dynamic library structure, initializes properties, manages state and attributes, and handles mutexes. None of these actions are present in the source code, which instead performs null checks on file path members, opens files for writing, logs errors, and calls a header-writing function. The claims are unrelated to the code\u2019s actual semantics, resulting in no accurate matches.",
                "The summary is entirely inaccurate, as it describes cloning a dynamic library and mutex handling, none of which appear in the source code. The function in the source code checks for required file paths, opens output files for writing, logs errors if openings fail, and writes a header. The summary fails to capture the primary purpose of writing headers to files and ignores key secondary details such as error handling and file operations.",
                "The summary's claims about cloning a dynamic library structure, initializing properties, managing state/attributes, and handling mutexes are inaccurate, as the source code actually opens specific output files, writes a header, and logs errors. These are FATAL misrepresentations of the primary purpose and key side effects, with no accurate claims aligned to the code, leading to high negative impact and no positive gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585972544,
    "strip_function_name": "sub_FFFFFFFF816CC140",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816CC140(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // ecx\n  int v3; // edx\n  int v4; // edx\n  unsigned __int8 v5; // dl\n\n  if ( (*(_DWORD *)a1 & 0xE0) == 0 || (result = 917505LL, (*(_DWORD *)a1 & 0xE0) == 0xE0) )\n  {\n    if ( (unsigned __int8)*(_DWORD *)a1 == 255 )\n    {\n      v5 = *(_BYTE *)(a1 + 1) & 0xF;\n      result = 131106LL;\n      if ( v5 != 2 )\n      {\n        result = 327746LL;\n        if ( v5 != 5 )\n        {\n          result = (__int64)&unk_10012;\n          if ( v5 != 1 )\n            return (v5 << 16) | 2u;\n        }\n      }\n    }\n    else\n    {\n      result = 131105LL;\n      v2 = *(_DWORD *)a1 & 0xC0FF;\n      if ( v2 != 33022 )\n      {\n        result = 327745LL;\n        if ( v2 != 49406 )\n        {\n          result = 917505LL;\n          if ( (*(_DWORD *)a1 & 0xFE) != 0xFC && !*(_QWORD *)a1 )\n          {\n            v3 = *(_DWORD *)(a1 + 8);\n            if ( v3 )\n            {\n              if ( v3 == -65536 )\n                return 921600LL;\n            }\n            else\n            {\n              v4 = *(_DWORD *)(a1 + 12);\n              result = 0LL;\n              if ( v4 )\n              {\n                result = 917633LL;\n                if ( v4 == 0x1000000 )\n                  return 131089LL;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "__ipv6_addr_type",
    "decompiled_code": "__int64 __fastcall _ipv6_addr_type(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // ecx\n  int v3; // edx\n  int v4; // edx\n  unsigned __int8 v5; // dl\n\n  if ( (*(_DWORD *)a1 & 0xE0) == 0 || (result = 917505LL, (*(_DWORD *)a1 & 0xE0) == 0xE0) )\n  {\n    if ( (unsigned __int8)*(_DWORD *)a1 == 255 )\n    {\n      v5 = *(_BYTE *)(a1 + 1) & 0xF;\n      result = 131106LL;\n      if ( v5 != 2 )\n      {\n        result = 327746LL;\n        if ( v5 != 5 )\n        {\n          result = (__int64)&unk_10012;\n          if ( v5 != 1 )\n            return (v5 << 16) | 2u;\n        }\n      }\n    }\n    else\n    {\n      result = 131105LL;\n      v2 = *(_DWORD *)a1 & 0xC0FF;\n      if ( v2 != 33022 )\n      {\n        result = 327745LL;\n        if ( v2 != 49406 )\n        {\n          result = 917505LL;\n          if ( (*(_DWORD *)a1 & 0xFE) != 0xFC && !*(_QWORD *)a1 )\n          {\n            v3 = *(_DWORD *)(a1 + 8);\n            if ( v3 )\n            {\n              if ( v3 == -65536 )\n                return 921600LL;\n            }\n            else\n            {\n              v4 = *(_DWORD *)(a1 + 12);\n              result = 0LL;\n              if ( v4 )\n              {\n                result = 917633LL;\n                if ( v4 == 0x1000000 )\n                  return 131089LL;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint __ipv6_addr_type(const struct in6_addr *addr)\n{\n\t__be32 st;\n\n\tst = addr->s6_addr32[0];\n\n\t/* Consider all addresses with the first three bits different of\n\t   000 and 111 as unicasts.\n\t */\n\tif ((st & htonl(0xE0000000)) != htonl(0x00000000) &&\n\t    (st & htonl(0xE0000000)) != htonl(0xE0000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\n\n\tif ((st & htonl(0xFF000000)) == htonl(0xFF000000)) {\n\t\t/* multicast */\n\t\t/* addr-select 3.1 */\n\t\treturn (IPV6_ADDR_MULTICAST |\n\t\t\tipv6_addr_scope2type(IPV6_ADDR_MC_SCOPE(addr)));\n\t}\n\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFE800000))\n\t\treturn (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFEC00000))\n\t\treturn (IPV6_ADDR_SITELOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_SITELOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFE000000)) == htonl(0xFC000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t\t\t/* RFC 4193 */\n\n\tif ((addr->s6_addr32[0] | addr->s6_addr32[1]) == 0) {\n\t\tif (addr->s6_addr32[2] == 0) {\n\t\t\tif (addr->s6_addr32[3] == 0)\n\t\t\t\treturn IPV6_ADDR_ANY;\n\n\t\t\tif (addr->s6_addr32[3] == htonl(0x00000001))\n\t\t\t\treturn (IPV6_ADDR_LOOPBACK | IPV6_ADDR_UNICAST |\n\t\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t/* addr-select 3.4 */\n\n\t\t\treturn (IPV6_ADDR_COMPATv4 | IPV6_ADDR_UNICAST |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t\t}\n\n\t\tif (addr->s6_addr32[2] == htonl(0x0000ffff))\n\t\t\treturn (IPV6_ADDR_MAPPED |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t}\n\n\treturn (IPV6_ADDR_UNICAST |\n\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.4 */\n}",
    "comment": "Determines the IPv6 address type (unicast, multicast, link-local, site-local, loopback, or any) based on the address structure and specific bit patterns.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Determines the IPv6 protocol type based on the provided socket address structure , returning specific constants for IPv4 and IPv6 protocols .\n",
    "cpbcs_sum": "Determines whether a remote address is a local address based on its type and address family, returning specific error codes for invalid inputs.\n",
    "misum_sum": "Validates the type of a given IPv6 address based on its type, returning a bitmask for various error types or unknown types.\n",
    "decom_sum": "Evaluates header and field values in a binary structure to identify format type and returns corresponding constant codes for recognized patterns.",
    "cfg_sum": "Evaluates specific bit patterns and field values in a memory block to return predefined status codes for recognized hardware or protocol identifiers.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary 'push a pointer type' does not reflect any of the specific IPv6 address classification logic in the source code. It is vague, unrelated to the source function\u2019s behavior, and fails to provide accurate fact-based claims tied to the code semantics, resulting in no accurate claims.",
                "The summary 'push a pointer type.' is vague, unrelated to the function\u2019s actual purpose of determining the IPv6 address type based on its binary prefix, and does not capture any primary or secondary semantic details from the source code. It fails to mention address classification logic, constants, or scope handling, resulting in no accurate claim mapping.",
                "The summary contains only a vague, generic statement ('push a pointer type') that does not reference the function's logic, key I/O, or side effects in the source code. This is pure NOISE with no factual alignment, offering no useful details for understanding the function. Since it provides no accurate claims and does not address the primary purpose of IPv6 address type determination, the net benefit is zero."
            ]
        },
        "bint5": {
            "summary": "Determines the IPv6 protocol type based on the provided socket address structure , returning specific constants for IPv4 and IPv6 protocols .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the code as determining IPv4 and IPv6 protocol types, whereas the source function classifies IPv6 addresses into specific categories like unicast, multicast, link-local, site-local, loopback, and others based on bit patterns in the address. It does not determine general 'protocol' type, nor does it handle IPv4 directly except for IPv4-mapped/compatible IPv6 addresses. This is a semantic mismatch, and no claims in the summary align precisely with the actual implementation.",
                "The summary incorrectly states that the function determines IPv6 protocol type based on a socket address and returns constants for IPv4 and IPv6 protocols. In reality, the function inspects an IPv6 address (struct in6_addr) to classify it as unicast, multicast, link-local, site-local, loopback, etc., and assigns corresponding scope/type constants, not generic IPv4/IPv6 protocol constants. This misses the primary purpose and key branch logic entirely, making the claim inaccurate.",
                "The summary makes an inaccurate claim by stating the function returns constants for IPv4 and IPv6 protocols, while the source code actually classifies IPv6 addresses into types such as unicast, multicast, link-local, site-local, loopback, and others based on address patterns. This is a FATAL error affecting the primary purpose because the code does not determine generic protocol type but rather address type/scope. There are no accurate or detailed claims to offset the negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Determines whether a remote address is a local address based on its type and address family, returning specific error codes for invalid inputs.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary is inaccurate because it describes determining if a remote address is local and returning error codes for invalid inputs, which is not reflected in the source code. The function in the source code classifies IPv6 addresses into specific types and scopes, without any remote/local distinction or error code handling. None of the claims align with the actual implementation.",
                "The summary is inaccurate as it misstates the primary purpose. The function determines the IPv6 address type and scope using specific bitmask checks, not whether a remote address is local based on type and address family. It also does not return error codes for invalid inputs, but rather returns constants representing IPv6 address categories. No secondary details or address classification logic are captured.",
                "The summary inaccurately describes the function's purpose, claiming it checks if a remote address is local and returns error codes. In reality, the code inspects the first bits of an IPv6 address to classify its type and scope, returning type flags rather than error codes. This is a FATAL error undermining understanding of the primary purpose and key outputs, with no accurate claims to offset the impact."
            ]
        },
        "misum": {
            "summary": "Validates the type of a given IPv6 address based on its type, returning a bitmask for various error types or unknown types.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's purpose, implying it returns bitmasks for error or unknown types, whereas the source code classifies IPv6 addresses into specific types and scopes without handling errors. The only partially accurate element is that it determines address types, but the details are largely incorrect. This yields a low proportion of accurate claims.",
                "The summary misrepresents the function's primary purpose by suggesting it deals with error or unknown types, which is inaccurate. The source code determines the IPv6 address type (unicast, multicast, link-local, site-local, loopback, etc.) and returns a corresponding bitmask with scope information. The summary fails to mention these specific classifications and scope handling, missing both the primary purpose and key secondary details.",
                "The summary inaccurately describes the function\u2019s behavior, claiming it returns bitmasks for error or unknown types, which contradicts the source code. The function determines IPv6 address categories (unicast, multicast, link-local, site-local, loopback, etc.) and returns corresponding bitmask values representing these categories and scopes, with no error handling or 'unknown' type logic. This is a FATAL error affecting the primary purpose, and there are no accurate, high-value claims to offset the negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581218960,
    "strip_function_name": "sub_FFFFFFFF81243890",
    "strip_decompiled_code": "_UNKNOWN **__fastcall sub_FFFFFFFF81243890(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  __int64 v6; // rax\n  void *v7; // r13\n  __int64 v8; // rbx\n  _QWORD *v9; // rdx\n  _UNKNOWN **result; // rax\n  void *v11; // rdx\n  _QWORD *v12; // rdx\n\n  v6 = *(_QWORD *)(a1 + 8);\n  v7 = (void *)(a1 + 8);\n  v8 = a2;\n  if ( a1 + 8 == v6 )\n  {\n    if ( _InterlockedIncrement((volatile signed __int32 *)a1) <= 1 && !byte_FFFFFFFF81CAC61F )\n    {\n      sub_FFFFFFFF8103BB80((__int64)\"include/linux/kref.h\", 47, a3, a4, a5, a6);\n      byte_FFFFFFFF81CAC61F = 1;\n    }\n  }\n  else\n  {\n    v9 = *(_QWORD **)(a1 + 16);\n    *(_QWORD *)(v6 + 8) = v9;\n    *v9 = v6;\n    *(_QWORD *)(a1 + 8) = v7;\n    *(_QWORD *)(a1 + 16) = v7;\n  }\n  result = &off_FFFFFFFF81C49EA0;\n  if ( a2 != -1 )\n  {\n    v8 = qword_FFFFFFFF81CC2000 + a2;\n    if ( qword_FFFFFFFF81CC2000 + a2 == -1 )\n      v8 = 0LL;\n    result = (_UNKNOWN **)off_FFFFFFFF81C49EA0;\n    if ( off_FFFFFFFF81C49EA0 != (_UNKNOWN *)&off_FFFFFFFF81C49EA0 )\n    {\n      do\n      {\n        v11 = result[7];\n        if ( v8 - (__int64)v11 < 0 )\n          break;\n        if ( v11 == (void *)-1LL )\n          break;\n        result = (_UNKNOWN **)*result;\n      }\n      while ( result != &off_FFFFFFFF81C49EA0 );\n    }\n  }\n  v12 = result[1];\n  result[1] = v7;\n  *(_QWORD *)(a1 + 8) = result;\n  *(_QWORD *)(a1 + 16) = v12;\n  *v12 = v7;\n  *(_QWORD *)(a1 + 64) = v8;\n  return result;\n}\n",
    "function_name": "nlmsvc_insert_block_locked",
    "decompiled_code": "_UNKNOWN **__fastcall nlmsvc_insert_block_locked(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rax\n  void *v11; // r13\n  __int64 v12; // rbx\n  _QWORD *v13; // rdx\n  _UNKNOWN **result; // rax\n  void *v15; // rdx\n  _QWORD *v16; // rdx\n\n  v10 = *(_QWORD *)(a1 + 8);\n  v11 = (void *)(a1 + 8);\n  v12 = a2;\n  if ( a1 + 8 == v10 )\n  {\n    if ( _InterlockedIncrement((volatile signed __int32 *)a1) <= 1 && !_warned_11206_2 )\n    {\n      warn_slowpath_null(\"include/linux/kref.h\", 0x2Fu, a3, a4, a5, a6, a7, a8, a9, a10);\n      _warned_11206_2 = 1;\n    }\n  }\n  else\n  {\n    v13 = *(_QWORD **)(a1 + 16);\n    *(_QWORD *)(v10 + 8) = v13;\n    *v13 = v10;\n    *(_QWORD *)(a1 + 8) = v11;\n    *(_QWORD *)(a1 + 16) = v11;\n  }\n  result = &nlm_blocked_0;\n  if ( a2 != -1 )\n  {\n    v12 = _vvar_beginning_hack + a2;\n    if ( _vvar_beginning_hack + a2 == -1 )\n      v12 = 0LL;\n    result = (_UNKNOWN **)nlm_blocked_0;\n    if ( nlm_blocked_0 != (_UNKNOWN *)&nlm_blocked_0 )\n    {\n      do\n      {\n        v15 = result[7];\n        if ( v12 - (__int64)v15 < 0 )\n          break;\n        if ( v15 == (void *)-1LL )\n          break;\n        result = (_UNKNOWN **)*result;\n      }\n      while ( result != &nlm_blocked_0 );\n    }\n  }\n  v16 = result[1];\n  result[1] = v11;\n  *(_QWORD *)(a1 + 8) = result;\n  *(_QWORD *)(a1 + 16) = v16;\n  *v16 = v11;\n  *(_QWORD *)(a1 + 64) = v12;\n  return result;\n}\n",
    "source_code": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
    "comment": "Inserts a network lock block into a sorted list based on its scheduled time, managing its reference count and handling the list initialization.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Inserts a new lock into a block list or updates an existing lock if the block is already in the list .\n",
    "cpbcs_sum": "Decreases the reference count of an NFS file and updates the expiration count if the count reaches zero.\n",
    "misum_sum": "Adds a new lock state to a linked list and updates its list based on its reference count and reference count.\n",
    "decom_sum": "Updates a doubly linked list entry for the given object, adjusting reference counts and storing an offset-based value into the object's data.",
    "cfg_sum": "Maintains and updates a doubly-linked list of nodes, adjusting references and counters, and logs an event when the last reference is released.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes generating LEB128 values with sign control, which is unrelated to the source code\u2019s implementation of inserting a lock block into a list with timing logic. None of the claims in the summary align with the semantics or operations in the provided function, resulting in no accurate matches.",
                "The summary is entirely inaccurate; it describes generating LEB128 fragments for encoding, which is unrelated to the source code that manages inserting an NLM block into a linked list with specific timing logic. It misses the primary purpose and all secondary implementation details from the source code.",
                "The summary claims the function generates fragments for emitting a LEB128 value with sign indicating sleb or uleb, which is unrelated to the actual source code. The source code handles inserting an nlm_block into a linked list with timing logic, not encoding numerical values. This is a NOISE failure mode with no accurate claims, leading to no positive gain from the summary."
            ]
        },
        "bint5": {
            "summary": "Inserts a new lock into a block list or updates an existing lock if the block is already in the list .\n",
            "score": [
                0.3,
                0.4,
                0.2
            ],
            "reason": [
                "The summary claims that the function inserts a new lock into a block list or updates an existing lock if the block is already present. While the code does insert the block into the nlm_blocked list, it does not perform updates to an existing lock's state; instead, it either increments the reference count or reinitializes the list entry before reinserting. The 'update' aspect is inaccurate, so only part of the claim aligns with the source, resulting in low accuracy.",
                "The summary captures the primary purpose of inserting a block into a list but inaccurately states that it updates an existing lock, which is not reflected in the source code. The code instead handles removal if already in the list, manages reference counts, positions based on time constraints, and sets the 'when' field. It omits secondary details such as handling of NLM_NEVER, jiffies adjustment, and ordering logic. This results in partial and partly incorrect coverage of the function's semantics.",
                "The summary claims the function inserts a new lock into a block list or updates an existing lock if already present. The source code deals with inserting an nlm_block into the nlm_blocked list, recalculating 'when', and reordering it, but there is no functionality for directly updating an existing lock beyond possibly repositioning it. The reference to 'lock' instead of 'block' is imprecise, and the 'updates' wording misrepresents the actual logic, making this a FATAL error regarding the primary purpose. There are no accurate, high-gain specifics to offset this fault."
            ]
        },
        "cpbcs": {
            "summary": "Decreases the reference count of an NFS file and updates the expiration count if the count reaches zero.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function decreases the reference count of an NFS file and updates expiration when the count reaches zero. In the source code, the function works with nlm_block structures, adjusts reference counts using kref_get (which increases, not decreases), and orders them in a blocked list based on a time parameter. There is no handling of NFS file reference decreases or expiration count updates, making the stated claims completely inaccurate.",
                "The summary is entirely inaccurate: the function does not decrease an NFS file reference count or update an expiration count. Instead, it manipulates a linked list of nlm_block structures, adjusts reference counts only conditionally by incrementing (not decrementing), and positions the block in the blocked list based on timing logic. This misses the primary purpose and all secondary details from the source code.",
                "The summary claims that the function decreases the reference count of an NFS file and updates an expiration count when the count reaches zero. This is inaccurate: the source code does not operate on NFS files or decrease any reference counts. Instead, it manipulates a list of nlm_block structures, potentially increasing the reference count when the block list is empty, and sets a time value for ordering. This is a FATAL error regarding the primary purpose, leading to a severe mismatch."
            ]
        },
        "misum": {
            "summary": "Adds a new lock state to a linked list and updates its list based on its reference count and reference count.\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary claims that the function adds a new lock state to a linked list and updates its list based on its reference count, repeating 'reference count' unnecessarily. While the linked list addition is accurate, the description of updates being based on reference count is misleading; the source shows it checks whether the list is empty to decide between incrementing the reference count or reinitializing the list node. The repetition indicates low clarity, and the omission of timing and ordering logic reduces accuracy. Less than half of the stated claims fully align with the code.",
                "The summary incorrectly describes the function as adding a new lock state to a linked list and updating based on reference count twice, while the source code deals with inserting an nlm_block into the nlm_blocked list, conditionally adjusting its reference count or removing it from its list, and setting its scheduled time based on the 'when' parameter and jiffies. The summary misses the primary purpose involving time ordering and placement in the blocked list, and provides redundant, low-information content that doesn\u2019t reflect critical behavioral details from the code.",
                "The summary contains a redundant and unclear claim about updating the list based on reference count, but omits key details such as conditional repositioning depending on the 'when' value, handling of NLM_NEVER, or the use of jiffies for time ordering. While 'adds a new lock state to a linked list' loosely matches inserting a block into nlm_blocked, the vague and repetitive description leads to mostly NOISE and lacks high-value specifics, resulting in low net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579976560,
    "strip_function_name": "sub_FFFFFFFF81114370",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81114370(__int64 a1)\n{\n  _QWORD *v1; // r13\n  _QWORD *v2; // rax\n  _QWORD *v3; // rbx\n  __int64 v4; // rdx\n  _QWORD *v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rbx\n\n  if ( sub_FFFFFFFF81064450((volatile signed __int64 *)(a1 + 112)) )\n    BUG();\n  if ( dword_FFFFFFFF81C3BE20 == 1 )\n    BUG();\n  v1 = *(_QWORD **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    do\n    {\n      if ( v1[17] )\n      {\n        v2 = (_QWORD *)v1[15];\n        v3 = v2 - 2;\n        if ( v1 + 15 != v2 )\n        {\n          do\n          {\n            v4 = v3[1];\n            if ( (*(_QWORD *)(*(_QWORD *)v4 + 48LL) & 1) != 0 )\n            {\n              if ( !_bittestandreset((signed __int32 *)(*(_QWORD *)v4 + 48LL), 0) )\n                BUG();\n              sub_FFFFFFFF810644C0((volatile signed __int64 *)(*(_QWORD *)v4 + 8LL));\n            }\n            v5 = (_QWORD *)v3[2];\n            v3 = v5 - 2;\n          }\n          while ( v1 + 15 != v5 );\n        }\n      }\n      v6 = v1[20];\n      if ( v6 )\n      {\n        v7 = *(_QWORD *)(v6 + 208);\n        if ( v7 )\n        {\n          if ( (*(_QWORD *)(v7 + 120) & 0x8000000) != 0 )\n          {\n            sub_FFFFFFFF8178F1B0(v7 + 56);\n            if ( !_interlockedbittestandreset((volatile signed __int32 *)(v7 + 120), 0x1Bu) )\n              BUG();\n          }\n        }\n      }\n      v1 = (_QWORD *)v1[2];\n    }\n    while ( v1 );\n  }\n  return sub_FFFFFFFF8178F1B0(&dword_FFFFFFFF81C3BE20);\n}\n",
    "function_name": "mm_drop_all_locks",
    "decompiled_code": "__int64 __fastcall mm_drop_all_locks(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // r13\n  _QWORD *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  _QWORD *v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rbx\n\n  if ( down_read_trylock((volatile signed __int64 *)(a1 + 112)) )\n    BUG();\n  if ( mm_all_locks_mutex == 1 )\n    BUG();\n  v2 = *(_QWORD **)a1;\n  if ( *(_QWORD *)a1 )\n  {\n    do\n    {\n      if ( v2[17] )\n      {\n        v3 = (_QWORD *)v2[15];\n        v4 = v3 - 2;\n        if ( v2 + 15 != v3 )\n        {\n          do\n          {\n            v5 = v4[1];\n            if ( (*(_QWORD *)(*(_QWORD *)v5 + 48LL) & 1) != 0 )\n            {\n              if ( !_bittestandreset((signed __int32 *)(*(_QWORD *)v5 + 48LL), 0) )\n                BUG();\n              up_write((volatile signed __int64 *)(*(_QWORD *)v5 + 8LL), a2);\n            }\n            v6 = (_QWORD *)v4[2];\n            v4 = v6 - 2;\n          }\n          while ( v2 + 15 != v6 );\n        }\n      }\n      v7 = v2[20];\n      if ( v7 )\n      {\n        v8 = *(_QWORD *)(v7 + 208);\n        if ( v8 )\n        {\n          if ( (*(_QWORD *)(v8 + 120) & 0x8000000) != 0 )\n          {\n            mutex_unlock(v8 + 56);\n            if ( !_interlockedbittestandreset((volatile signed __int32 *)(v8 + 120), 0x1Bu) )\n              BUG();\n          }\n        }\n      }\n      v2 = (_QWORD *)v2[2];\n    }\n    while ( v2 );\n  }\n  return mutex_unlock((__int64)&mm_all_locks_mutex);\n}\n",
    "source_code": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
    "comment": "Releases all locks on virtual memory areas and their associated anonymous virtual memory structures in the specified memory management structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases all virtual memory areas associated with a vmap_area , ensuring proper memory management during the process .\n",
    "cpbcs_sum": "The function waits for all active virtual memory areas in the given virtual memory area if any child processes are available.\n",
    "misum_sum": "Reschedules a virtual memory area by clearing notification info, verifying all active virtual memory areas and updating their status and memory mappings accordingly.\n",
    "decom_sum": "Iterates over linked structures to clear specific status bits, release associated resources, and finalize by resetting a global control flag.",
    "cfg_sum": "Validates and processes linked object structures, resetting specific status bits and invoking cleanup routines, terminating with an error if integrity checks fail.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only a vague statement that does not reference any factual elements of the source code. It neither describes the function behavior, parameters, nor its logic, and thus all extracted claims are unrelated to the code, making them inaccurate.",
                "The summary 'push a pointer type' is unrelated to the source code, which is a function unlocking various memory-related locks in a mm_struct after checking mutex and semaphore states. It misses the primary purpose entirely, contains no accurate claims, and does not address any observable behavior or secondary details from the implementation.",
                "The summary contains a single claim, 'push a pointer type,' which does not describe any aspect of the given source code. The function handles unlocking VM-related locks and mutexes, not pushing pointers. This makes the claim entirely irrelevant (NOISE), providing no insight and possibly misleading about purpose or behavior. The worst failure mode is NOISE, leading to minimal net benefit."
            ]
        },
        "bint5": {
            "summary": "Releases all virtual memory areas associated with a vmap_area , ensuring proper memory management during the process .\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function releases all virtual memory areas associated with a 'vmap_area', but the source code operates on 'vm_area_struct' objects linked to an 'mm_struct', unlocking anon_vma and mapping resources. The mention of 'vmap_area' is inaccurate and misidentifies the object type in the implementation, resulting in a fact error. There are no clearly accurate claims, as the core semantics are misstated.",
                "The summary incorrectly refers to a 'vmap_area' instead of the 'vm_area_struct' instances processed in the code, which makes the primary purpose description inaccurate. It fails to mention critical details, such as unlocking anon_vma structures, unlocking associated file mappings, the precondition checks using BUG_ON, and releasing mm_all_locks_mutex. This lack of correct terminology and omission of key behaviors means the summary neither captures the primary purpose accurately nor covers secondary details.",
                "The summary incorrectly states the function deals with 'vmap_area', which is not present in the source code and misrepresents the actual target (vm_area_struct linked via mm->mmap). This constitutes a FATAL error affecting the primary purpose of the function. While the summary broadly references releasing virtual memory areas, it fails to accurately capture the specific locks and structures involved, offering low detail and misleading context."
            ]
        },
        "cpbcs": {
            "summary": "The function waits for all active virtual memory areas in the given virtual memory area if any child processes are available.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function waits for all active virtual memory areas and considers child processes, but the source code does not perform any waiting nor check for child processes. Instead, it iterates over VMAs and releases associated locks. This makes the claims contradictory to the actual implementation, resulting in no accurate claims.",
                "The summary is inaccurate as it describes waiting for active virtual memory areas and references child processes, which are not present in the source code. The function actually iterates over all VMAs in the given mm_struct and unlocks associated anon_vma and file mappings before unlocking a mutex. This misses the primary purpose entirely and introduces unrelated behavior, providing no accurate claim coverage.",
                "The summary makes an inaccurate claim about waiting for active virtual memory areas in the presence of child processes, which is not supported by the source code. The actual implementation iterates over VMAs to release locks (anon_vma and mapping locks) and then unlocks a global mutex, with no logic related to waiting or child processes. This is a FATAL error targeting the primary purpose of the function, severely misrepresenting its behavior."
            ]
        },
        "misum": {
            "summary": "Reschedules a virtual memory area by clearing notification info, verifying all active virtual memory areas and updating their status and memory mappings accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains several fact-based claims, such as rescheduling a virtual memory area, clearing notification info, and updating memory mappings. However, these claims do not match the source code implementation, which instead iterates through VMAs to unlock associated anon_vma and file mappings, and releases a global lock. None of the summary\u2019s specifics about rescheduling or notification info are reflected in the code, making all claims inaccurate according to the evaluation steps.",
                "The summary incorrectly describes the function as rescheduling a virtual memory area and clearing notification info, which is not supported by the source code. The actual purpose is to drop all locks associated with the given memory descriptor, involving checks on lock states, iterating over VMAs, and unlocking anon_vma and file mappings, followed by unlocking a global mutex. The summary misses the primary purpose entirely and introduces unrelated, inaccurate operations.",
                "The summary introduces actions such as 'rescheduling a virtual memory area,' 'clearing notification info,' and 'updating status,' which are not present in the source code, making these claims INACCURATE (FATAL) to key semantics. The source code actually unlocks anon_vma and file mappings for all VMAs, with mutex handling, not rescheduling or clearing notifications. These mismatches affect the primary purpose, resulting in high negative impact and no accurate, high-gain details."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584964832,
    "strip_function_name": "sub_FFFFFFFF815D60E0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815D60E0(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  __int64 *v14; // rdx\n  __int64 v16; // rsi\n  unsigned __int64 v17; // rdi\n  int v18; // eax\n  __int64 v19; // rdi\n  __int64 v21; // rdi\n\n  v14 = (__int64 *)a1[2];\n  if ( v14 )\n  {\n    a12 = a1[1];\n    *(_WORD *)v14 = *(_WORD *)(a12 + 208) + *(_DWORD *)(a12 + 196) - (_WORD)v14;\n  }\n  v16 = *((unsigned int *)a1 + 6);\n  if ( (_DWORD)v16 && (unsigned int)sub_FFFFFFFF812C91D0((_DWORD *)a1[1], v16, 40LL, a1 + 6) )\n  {\n    v17 = a1[4];\n  }\n  else\n  {\n    v16 = *((unsigned int *)a1 + 7);\n    v17 = a1[4];\n    if ( !(_DWORD)v16\n      || !v17\n      || (v18 = sub_FFFFFFFF812C91D0((_DWORD *)a1[1], v16, *((unsigned int *)a1 + 10), (__int64 *)a1[4]),\n          v17 = a1[4],\n          !v18) )\n    {\n      sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, a6, a7, a8, a9, v16, v14, a12, a13, a14);\n      v19 = *a1;\n      a1[4] = 0LL;\n      *((_DWORD *)a1 + 10) = 0;\n      sub_FFFFFFFF81792870(v19);\n      return 0LL;\n    }\n  }\n  sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, a6, a7, a8, a9, v16, v14, a12, a13, a14);\n  v21 = *a1;\n  a1[4] = 0LL;\n  *((_DWORD *)a1 + 10) = 0;\n  sub_FFFFFFFF81792870(v21);\n  return 0xFFFFFFFFLL;\n}\n",
    "function_name": "gnet_stats_finish_copy",
    "decompiled_code": "__int64 __fastcall gnet_stats_finish_copy(\n        __int64 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 *v9; // rdx\n  __int64 v11; // rsi\n  __int64 *v12; // rdi\n  int v13; // eax\n  _BYTE *v14; // rdi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  _BYTE *v20; // rdi\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n\n  v9 = (__int64 *)a1[2];\n  if ( v9 )\n    *(_WORD *)v9 = *(_WORD *)(a1[1] + 208) + *(_DWORD *)(a1[1] + 196) - (_WORD)v9;\n  v11 = *((unsigned int *)a1 + 6);\n  if ( (_DWORD)v11 && (unsigned int)nla_put((_DWORD *)a1[1], v11, 40, a1 + 6) )\n  {\n    v12 = (__int64 *)a1[4];\n  }\n  else\n  {\n    v11 = *((unsigned int *)a1 + 7);\n    v12 = (__int64 *)a1[4];\n    if ( !(_DWORD)v11\n      || !v12\n      || (v13 = nla_put((_DWORD *)a1[1], v11, *((_DWORD *)a1 + 10), (__int64 *)a1[4]), v12 = (__int64 *)a1[4], !v13) )\n    {\n      kfree(v12, a2, a3, a4, a5, a6, a7, a8, a9, v11, v9);\n      v14 = (_BYTE *)*a1;\n      a1[4] = 0LL;\n      *((_DWORD *)a1 + 10) = 0;\n      raw_spin_unlock_bh(v14, v11, v15, v16, v17, v18);\n      return 0LL;\n    }\n  }\n  kfree(v12, a2, a3, a4, a5, a6, a7, a8, a9, v11, v9);\n  v20 = (_BYTE *)*a1;\n  a1[4] = 0LL;\n  *((_DWORD *)a1 + 10) = 0;\n  raw_spin_unlock_bh(v20, v11, v21, v22, v23, v24);\n  return 0xFFFFFFFFLL;\n}\n",
    "source_code": "int\ngnet_stats_finish_copy(struct gnet_dump *d)\n{\n\tif (d->tail)\n\t\td->tail->nla_len = skb_tail_pointer(d->skb) - (u8 *)d->tail;\n\n\tif (d->compat_tc_stats)\n\t\tif (gnet_stats_copy(d, d->compat_tc_stats, &d->tc_stats,\n\t\t\tsizeof(d->tc_stats)) < 0)\n\t\t\treturn -1;\n\n\tif (d->compat_xstats && d->xstats) {\n\t\tif (gnet_stats_copy(d, d->compat_xstats, d->xstats,\n\t\t\td->xstats_len) < 0)\n\t\t\treturn -1;\n\t}\n\n\tspin_unlock_bh(d->lock);\n\treturn 0;\n}",
    "comment": "Finalizes the statistics copy process by updating lengths and copying compatible statistics into the provided structures before unlocking the spinlock.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Decreases the receive buffer count and frees the sk_buff structure if it is no longer in use .\n",
    "cpbcs_sum": "Releases resources associated with a socket buffer, including NAPI data and timeout data, and conditionally deallocates their memory.\n",
    "misum_sum": "Adds a dirty log to a sound structure, replacing existing log entries, and notifying the buffer and length of the packets.\n",
    "decom_sum": "Validates object state and parameters, processes it with provided coordinates, then releases resources and returns status indicating success or failure.",
    "cfg_sum": "Processes and validates structure fields, updates memory, calls processing routines, performs cleanup, and returns a success or failure status based on validation results.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only a mathematical expression unrelated to the function implementation in the source code. No fact-based claims about the function\u2019s behavior, parameters, or operations are present, resulting in 0% accurate claims.",
                "The summary contains only a mathematical expression unrelated to the function in the source code. It does not capture the primary purpose of the function, which is finalizing the copy of network statistics, handling compatibility structures, managing errors, and unlocking a spinlock. No fact-based claims align with any semantic units in the source, resulting in no coverage.",
                "The summary contains only a mathematical expression unrelated to the source code's logic or behavior. None of the claims describe the function's implementation, inputs, outputs, or side effects, resulting in complete NOISE and zero alignment with the evaluation steps. There are no ACCURATE claims and no informational gain."
            ]
        },
        "bint5": {
            "summary": "Decreases the receive buffer count and frees the sk_buff structure if it is no longer in use .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims a decrease in receive buffer count and freeing of the sk_buff structure when unused, but the source code does not perform either action. Instead, it adjusts the nla_len of a tail pointer, copies statistics data, and unlocks a spinlock. This makes the claim fully inaccurate and unrelated to the actual function behavior, resulting in no accurate claims.",
                "The summary claims the function decreases a receive buffer count and frees an sk_buff if unused, which is unrelated to the source code. The actual implementation updates length fields for tail entries, copies statistics for compatibility, unlocks a spinlock, and returns a status code. The summary misses the primary purpose and all secondary details, making its claims inaccurate and non-representative of the source's semantics.",
                "The summary claims the function decreases the receive buffer count and frees the sk_buff if unused, which directly contradicts the source code. The implementation does not perform buffer count decrement or freeing; instead it updates length fields, copies statistics, unlocks a spinlock, and returns a status. This is a FATAL error impacting the primary purpose of the function (its core operations), resulting in high negative impact and no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Releases resources associated with a socket buffer, including NAPI data and timeout data, and conditionally deallocates their memory.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function releases resources associated with a socket buffer, including NAPI and timeout data, and deallocates memory, but the source code does not perform these operations. Instead, it adjusts lengths, conditionally copies statistics, unlocks a spinlock, and returns a status. All claims are inaccurate as they contradict the code\u2019s semantics.",
                "The summary makes claims about releasing resources, NAPI data, timeout data, and deallocating memory, none of which are reflected in the source code. The actual function deals with finalizing a netlink stats copy: adjusting 'nla_len' if 'tail' is set, copying stats conditionally based on compatibility flags, unlocking a spinlock, and returning status. The summary misses the primary purpose and introduces unrelated and inaccurate behavior, leading to no accurate coverage of the CSU_LIST.",
                "The summary makes several specific claims about releasing resources for a socket buffer, including NAPI data and timeout data, and conditional memory deallocation. None of these behaviors are supported by the source code, which instead adjusts lengths, copies statistics conditionally, and unlocks a spinlock. These errors directly contradict the key purpose and side effects of the function, representing FATAL inaccuracies about primary purpose and core functionality. There are no accurate claims to offset the high negative impact."
            ]
        },
        "misum": {
            "summary": "Adds a dirty log to a sound structure, replacing existing log entries, and notifying the buffer and length of the packets.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about adding a dirty log to a sound structure, replacing log entries, and notifying buffer/packet length do not align with the source code. The function in the source performs network statistics copying and updates lengths in data structures related to network dumping, without any operations on sound structures or dirty logs. All claims are therefore inaccurate, leading to a complete mismatch with the implementation.",
                "The summary's claims about adding a dirty log to a sound structure and replacing log entries are unrelated to the function's actual purpose, which is to finalize copying statistics in a gnet_dump structure, update lengths, handle possible copy failures, and release a lock. None of the summary details match the source code semantics, indicating it misses both the primary purpose and all secondary details.",
                "The summary's claims are completely inaccurate. It describes adding a dirty log to a sound structure and replacing log entries, which is unrelated to the actual function. The source code deals with updating lengths in a gnet statistics dump, copying compatibility stats, unlocking a spinlock, and returning status codes. This represents a FATAL error targeting the primary purpose and key I/O, making the content unreliable with no positive gain."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5660876,
    "strip_function_name": "sub_5660CC",
    "strip_decompiled_code": "_BOOL8 __fastcall sub_5660CC(__m128 a1, __m128 a2, __m128 a3, __m128 a4, double a5, double a6, __m128 a7, __m128 a8)\n{\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __m128 v11; // xmm4\n  __m128 v12; // xmm5\n  _BOOL8 result; // rax\n  signed int v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  char v25; // [rsp+0h] [rbp-B8h]\n  int v26; // [rsp+Ch] [rbp-ACh] BYREF\n  _QWORD v27[2]; // [rsp+10h] [rbp-A8h] BYREF\n  struct stat v28; // [rsp+20h] [rbp-98h] BYREF\n\n  if ( (unsigned int)sub_4AD1D0(1u, \"check\", &v28) == -1 )\n  {\n    result = 1LL;\n    if ( *(_DWORD *)qword_89A630 != 2 )\n    {\n      sub_5174F5(\n        (__int64)\"warning: can't stat %s/check\",\n        *(_QWORD *)xmmword_89A678,\n        qword_89A630,\n        v8,\n        v9,\n        v10,\n        a1,\n        a2,\n        a3,\n        a4,\n        v11,\n        v12,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v27[0] = \"./check\";\n    v27[1] = 0LL;\n    v14 = sub_5DC1ED(v27);\n    if ( v14 > 0 )\n    {\n      if ( (unsigned int)sub_518044(v14, &v26, 0) == -1 )\n      {\n        sub_5174F5(\n          (__int64)\"warning: can't %s child %s/check\",\n          (__int64)\"wait for\",\n          *(_QWORD *)xmmword_89A678,\n          v20,\n          v21,\n          v22,\n          a1,\n          a2,\n          a3,\n          a4,\n          v23,\n          v24,\n          a7,\n          a8,\n          v25);\n        return 0LL;\n      }\n      else\n      {\n        return BYTE1(v26) == 0;\n      }\n    }\n    else\n    {\n      sub_5174F5(\n        (__int64)\"warning: can't %s child %s/check\",\n        6757469LL,\n        *(_QWORD *)xmmword_89A678,\n        v15,\n        v16,\n        v17,\n        a1,\n        a2,\n        a3,\n        a4,\n        v18,\n        v19,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "checkscript",
    "decompiled_code": "_BOOL8 __fastcall checkscript(__m128 a1, __m128 a2, __m128 a3, __m128 a4, double a5, double a6, __m128 a7, __m128 a8)\n{\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __m128 v11; // xmm4\n  __m128 v12; // xmm5\n  _BOOL8 result; // rax\n  pid_t v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  char v25; // [rsp+0h] [rbp-B8h]\n  int v26; // [rsp+Ch] [rbp-ACh] BYREF\n  __int64 v27[2]; // [rsp+10h] [rbp-A8h] BYREF\n  struct stat v28; // [rsp+20h] [rbp-98h] BYREF\n\n  if ( (unsigned int)xstat(1u, \"check\", &v28) == -1 )\n  {\n    result = 1LL;\n    if ( *(_DWORD *)bb_errno != 2 )\n    {\n      bb_perror_msg(\n        \"warning: can't stat %s/check\",\n        *(_QWORD *)xmmword_89A678,\n        bb_errno,\n        v8,\n        v9,\n        v10,\n        a1,\n        a2,\n        a3,\n        a4,\n        v11,\n        v12,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v27[0] = (__int64)\"./check\";\n    v27[1] = 0LL;\n    v14 = spawn(v27, *(double *)a1.m128_u64);\n    if ( v14 > 0 )\n    {\n      if ( (unsigned int)safe_waitpid(v14, &v26, 0) == -1 )\n      {\n        bb_perror_msg(\n          \"warning: can't %s child %s/check\",\n          (__int64)\"wait for\",\n          *(_QWORD *)xmmword_89A678,\n          v20,\n          v21,\n          v22,\n          a1,\n          a2,\n          a3,\n          a4,\n          v23,\n          v24,\n          a7,\n          a8,\n          v25);\n        return 0LL;\n      }\n      else\n      {\n        return BYTE1(v26) == 0;\n      }\n    }\n    else\n    {\n      bb_perror_msg(\n        \"warning: can't %s child %s/check\",\n        6757469LL,\n        *(_QWORD *)xmmword_89A678,\n        v15,\n        v16,\n        v17,\n        a1,\n        a2,\n        a3,\n        a4,\n        v18,\n        v19,\n        a7,\n        a8,\n        v25);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int checkscript(void)\n{\n\tchar *prog[2];\n\tstruct stat s;\n\tint pid, w;\n\n\tif (stat(\"check\", &s) == -1) {\n\t\tif (errno == ENOENT) return 1;\n\t\tbb_perror_msg(WARN\"can't stat %s/check\", *service);\n\t\treturn 0;\n\t}\n\t/* if (!(s.st_mode & S_IXUSR)) return 1; */\n\tprog[0] = (char*)\"./check\";\n\tprog[1] = NULL;\n\tpid = spawn(prog);\n\tif (pid <= 0) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"run\", *service);\n\t\treturn 0;\n\t}\n\twhile (safe_waitpid(pid, &w, 0) == -1) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"wait for\", *service);\n\t\treturn 0;\n\t}\n\treturn WEXITSTATUS(w) == 0;\n}",
    "comment": "Checks for the existence of the \"check\" script, executes it, and returns true if it exits successfully.",
    "hext5_sum": "returns true upon success, false otherwise. copy object file ibfd onto obfd.",
    "bint5_sum": "The function manages signal traps by setting , resetting , or displaying handlers for specified signals based on command-line arguments .\n",
    "cpbcs_sum": "Executes a specified command with arguments, checks for errors, and handles interrupt states and errors related to process file operations.\n",
    "misum_sum": "Waits for a child process to change state or removal of files, returning true if no devices are found.\n",
    "decom_sum": "Checks for the presence of a \"./check\" file, executes it if found, and returns success based on the child process exit status.",
    "cfg_sum": "Checks the existence of the \"./check\" file, executes it as a child process, waits for completion, and returns success or failure status.",
    "work_score": {
        "hext5": {
            "summary": "returns true upon success, false otherwise. copy object file ibfd onto obfd.",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary includes two distinct claims: 1) the function returns true upon success and false otherwise, and 2) it copies an object file from ibfd onto obfd. The first claim partially aligns with the source, as the function returns 1 (true) or 0 (false) depending on conditions, but also has a specific check on WEXITSTATUS, so it\u2019s broadly accurate but omits important detail. The second claim is entirely unrelated to the source code, which deals with executing a 'check' script and not copying object files. This results in less than half of the claims being accurate.",
                "The summary misses the primary purpose of checking and executing the './check' script, and instead introduces an unrelated action about copying an object file, which is not present in the source code. It fails to mention key behaviors such as stat'ing the file, spawning the process, error handling, and interpreting the exit status. The claims are inaccurate and do not cover any critical semantic units from the source.",
                "The summary contains one claim about return behavior that is broadly accurate but vague, and another claim about copying an object file which is completely unrelated to the source code (NOISE). The unrelated claim overwhelms the limited accurate content, providing low informational value and misrepresenting code semantics. The worst failure mode is excessive NOISE without high-detail positives."
            ]
        },
        "bint5": {
            "summary": "The function manages signal traps by setting , resetting , or displaying handlers for specified signals based on command-line arguments .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function manages signal traps and handles specified signals based on command-line arguments, but the source code shows no signal handling logic, argument parsing, or trap management. Instead, the code checks for a 'check' file, spawns a process, waits for it, and returns an exit status. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary describes managing signal traps via command-line arguments, which is entirely unrelated to the source code logic. The source code checks for the existence of a 'check' script, executes it, handles errors from stat, spawn, and wait, and returns its exit status. The summary does not mention the primary purpose of running and verifying the script, nor any secondary details such as error handling or process creation, and is therefore inaccurate and provides no coverage.",
                "The summary claims the function manages signal traps via setting, resetting, or displaying handlers based on CLI arguments. This is entirely inaccurate, as the source code actually checks for a 'check' script, spawns it, waits for completion, and returns an exit status. The claim does not target the actual semantics of the code and introduces unrelated functionality, representing a FATAL error about the primary purpose."
            ]
        },
        "cpbcs": {
            "summary": "Executes a specified command with arguments, checks for errors, and handles interrupt states and errors related to process file operations.\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary contains broad statements that do not accurately match the source code. The function specifically checks for the existence of a './check' executable, spawns it without additional arguments, waits for its completion, and handles errors during file stat and process execution. The summary's claim about executing a specified command with arguments and handling interrupt states is unsupported, and its mention of process file operations is vague. Few claims align with actual implementation, leading to low accuracy.",
                "The summary incorrectly states that the function executes a specified command with arguments, which is inaccurate since the code always runs './check' with no arguments. It omits the primary purpose of verifying the existence of the 'check' file and interpreting its exit status. It also misses key secondary details such as specific error handling for ENOENT, logging through bb_perror_msg, and process spawning/waiting logic. The focus on 'interrupt states' and 'process file operations' is vague and not clearly aligned with the actual implementation, leading to poor correspondence with the source code.",
                "The summary contains mostly inaccurate claims. The source code specifically runs a fixed './check' script without arbitrary arguments, and there is no evidence of handling interrupt states beyond basic waitpid error checks. The claims about executing a specified command with arguments and process file operations are broad and misleading, introducing NOISE that outweighs the accurate notion that it checks for errors. No FATAL errors about primary purpose or key I/O are present, but the gain is low due to lack of specificity and prevalence of off-target descriptions."
            ]
        },
        "misum": {
            "summary": "Waits for a child process to change state or removal of files, returning true if no devices are found.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function waits for a child process or removal of files and returns true if no devices are found. The source code actually runs a './check' script if it exists, waits for it to complete, and returns true if it exits with status 0. There is no mention of device detection or removal of files in the implementation, making the core claims inaccurate.",
                "The summary is inaccurate because it describes waiting for child process state changes or file removal related to detecting devices, which does not match the source code. The function actually checks for the presence of a 'check' file, handles stat errors, runs a './check' executable, waits for it to finish, and returns based on its exit status. The summary misses the primary purpose and all key secondary details from the source code.",
                "The summary makes two specific claims: (1) waits for a child process to change state or removal of files, and (2) returns true if no devices are found. In the source code, the function waits for a spawned child process running './check' to exit and then returns true if its exit status is 0. There is no logic for 'removal of files' or 'no devices'\u2014these are inaccurate and misrepresent the primary purpose. This is a FATAL error on core behavior (key I/O and purpose), making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586474832,
    "strip_function_name": "sub_FFFFFFFF81746B50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81746B50(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rdx\n  unsigned int v11; // ecx\n  __int64 result; // rax\n  __int64 v13; // rax\n\n  v10 = *(_QWORD *)(a2 + 48);\n  v11 = *(_DWORD *)(v10 + 2136);\n  if ( *(_BYTE *)(v10 + 2374) )\n  {\n    if ( v11 == 2 )\n      return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n    if ( v11 == 3 )\n    {\n      BYTE1(v13) = 2;\nLABEL_12:\n      if ( (v13 & 0x200) == 0 )\n        return 4294967201LL;\n      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 464) + 144LL) + 168LL) )\n        return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\nLABEL_7:\n      if ( !*(_QWORD *)(v10 + 1192) || (*(_BYTE *)(a1 + 57) & 1) != 0 && (*(_BYTE *)(a2 + 32) & 4) != 0 )\n        return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n      return 4294967201LL;\n    }\n  }\n  result = 4294967201LL;\n  if ( v11 > 0xA )\n    return result;\n  v13 = 1LL << v11;\n  if ( ((1LL << v11) & 0x586) == 0 )\n  {\n    if ( (v13 & 8) != 0 )\n      goto LABEL_7;\n    goto LABEL_12;\n  }\n  return sub_FFFFFFFF81738B20(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n",
    "function_name": "ieee80211_scan",
    "decompiled_code": "__int64 __fastcall ieee80211_scan(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rdx\n  unsigned int v11; // ecx\n  __int64 result; // rax\n  __int64 v13; // rax\n\n  v10 = *(_QWORD *)(a2 + 48);\n  v11 = *(_DWORD *)(v10 + 2136);\n  if ( *(_BYTE *)(v10 + 2374) )\n  {\n    if ( v11 == 2 )\n      return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n    if ( v11 == 3 )\n    {\n      BYTE1(v13) = 2;\nLABEL_12:\n      if ( (v13 & 0x200) == 0 )\n        return 4294967201LL;\n      if ( *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v10 + 464) + 144LL) + 168LL) )\n        return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\nLABEL_7:\n      if ( !*(_QWORD *)(v10 + 1192) || (*(_BYTE *)(a1 + 57) & 1) != 0 && (*(_BYTE *)(a2 + 32) & 4) != 0 )\n        return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n      return 4294967201LL;\n    }\n  }\n  result = 4294967201LL;\n  if ( v11 > 0xA )\n    return result;\n  v13 = 1LL << v11;\n  if ( ((1LL << v11) & 0x586) == 0 )\n  {\n    if ( (v13 & 8) != 0 )\n      goto LABEL_7;\n    goto LABEL_12;\n  }\n  return ieee80211_request_scan(v10 - 16, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n",
    "source_code": "\nstatic int ieee80211_scan(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = IEEE80211_WDEV_TO_SUB_IF(req->wdev);\n\n\tswitch (ieee80211_vif_type_p2p(&sdata->vif)) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (sdata->local->ops->hw_scan)\n\t\t\tbreak;\n\t\t/*\n\t\t * FIXME: implement NoA while scanning in software,\n\t\t * for now fall through to allow scanning only when\n\t\t * beaconing hasn't been configured yet\n\t\t */\n\tcase NL80211_IFTYPE_AP:\n\t\t/*\n\t\t * If the scan has been forced (and the driver supports\n\t\t * forcing), don't care about being beaconing already.\n\t\t * This will create problems to the attached stations (e.g. all\n\t\t * the  frames sent while scanning on other channel will be\n\t\t * lost)\n\t\t */\n\t\tif (sdata->u.ap.beacon &&\n\t\t    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||\n\t\t     !(req->flags & NL80211_SCAN_FLAG_AP)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ieee80211_request_scan(sdata, req);\n}",
    "comment": "Handles scanning requests for various Wi-Fi interface types, ensuring appropriate conditions are met before initiating a scan.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Manages TDLS operations for peer stations , enabling links , disabling links , and rejecting unsupported setups or discoveries based on station type .\n",
    "cpbcs_sum": "Initiates connection-related actions for a station based on specified conditions and security checks, enforcing conditions on transmission and conditions accordingly.\n",
    "misum_sum": "Handles TDLS operations for association and supported Intel uncore station based on supported conditions received and conditions in a wireless environment.\n",
    "decom_sum": "Evaluates object state and type flags to decide whether to invoke the main processing routine or return an error code.",
    "cfg_sum": "Determines whether to execute a secondary processing routine or return an error code based on object state flags, type identifiers, and memory-linked conditions.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary 'push a pointer type' is vague, lacks atomic fact-based claims, and does not map to the source code's scanning logic or conditional handling of interface types. It neither accurately captures the function's purpose nor aligns with its semantics, making it effectively noise.",
                "The summary 'push a pointer type' does not reflect the primary purpose or any secondary details of the source function, which handles Wi-Fi scan requests based on interface type, beacon configuration, and hardware capabilities. It neither accurately describes the function\u2019s observable behavior nor its implementation specifics, making it irrelevant and inaccurate for evaluation.",
                "The summary 'push a pointer type' is entirely unrelated to the source code, which implements an IEEE 802.11 scan function with interface type checks and conditional returns. This is pure NOISE with no factual accuracy or insight about the code, providing zero benefit."
            ]
        },
        "bint5": {
            "summary": "Manages TDLS operations for peer stations , enabling links , disabling links , and rejecting unsupported setups or discoveries based on station type .\n",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary focuses on TDLS operations such as enabling/disabling links and rejecting unsupported setups, which are unrelated to the source code. The source code handles IEEE 802.11 scan requests with specific logic for interface types and conditions, not TDLS. All fact-based claims in the summary are inaccurate with respect to the code.",
                "The summary incorrectly describes TDLS link management operations, which are unrelated to the source code\u2019s actual behavior. The function in the source code handles scanning requests for different interface types, including conditions for AP and P2P GO modes, and returns an error when unsupported. It misses the primary purpose entirely and introduces unrelated features, resulting in no accurate claims.",
                "The summary's claims about managing TDLS operations, enabling/disabling links, and handling unsupported setups are entirely unrelated to the provided source code, which implements an 802.11 scan request handling function based on interface type. All claims are NOISE with no accurate alignment to the code, resulting in zero informational value."
            ]
        },
        "cpbcs": {
            "summary": "Initiates connection-related actions for a station based on specified conditions and security checks, enforcing conditions on transmission and conditions accordingly.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary makes broad claims about initiating connection-related actions, conditions, and security checks, but the source code specifically performs scan request handling for different interface types without explicit mention of security checks or transmission enforcement. Most claims are inaccurate or irrelevant to the actual code semantics, with little alignment beyond a vague sense of conditional handling.",
                "The summary incorrectly describes the function as initiating connection-related actions with security checks, which does not align with the source code\u2019s actual scanning behavior for various interface types and handling of specific conditions like beaconing and driver capabilities. It misses the primary purpose of performing a scan request based on interface type and flags, and omits all secondary details about interface-specific conditions and error handling.",
                "The summary contains mostly inaccurate and vague claims. It describes 'connection-related actions' and 'security checks', which do not align with the source code\u2019s actual purpose of performing a scan request based on interface type and flags. This is a FATAL error targeting the primary purpose, as the function\u2019s key I/O is about initiating scanning, not managing connection security conditions or transmission. No accurate, detailed claims are found, resulting in high negative impact and no gain."
            ]
        },
        "misum": {
            "summary": "Handles TDLS operations for association and supported Intel uncore station based on supported conditions received and conditions in a wireless environment.\n",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's claims about handling TDLS operations and Intel uncore stations are unrelated to the source code, which implements scanning logic for different interface types in a wireless environment. None of the claims accurately reflect the code's behavior, leading to 0% accurate claims.",
                "The summary is entirely inaccurate as it describes TDLS operations, Intel uncore station, and general wireless environment conditions, none of which are present in the source code. The source implements scanning for various interface types with conditions related to beaconing and hardware support, which the summary fails to capture. It does not mention the primary purpose of the function or any verifiable secondary details from the source.",
                "The summary's claims about TDLS operations, association handling, and Intel uncore station support are unrelated to the source code, which deals with initiating a scan in various wireless interface modes and conditional restrictions. All claims are NOISE, providing no accurate alignment with the code's actual function. This results in low reliability due to overwhelming irrelevance."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580367808,
    "strip_function_name": "sub_FFFFFFFF81173BC0",
    "strip_decompiled_code": "char __fastcall sub_FFFFFFFF81173BC0(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _WORD *v10; // rdx\n  __int64 v11; // rax\n  __int64 v13; // r13\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  _QWORD *v16; // rsi\n  _QWORD *v17; // rcx\n  __int64 v18; // rdi\n  __int64 *v19; // rdx\n  __int64 v20; // rcx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n\n  v10 = *(_WORD **)(a1 + 32);\n  LOWORD(v11) = *v10 & 0xF000;\n  if ( (_WORD)v11 == 0x4000 )\n  {\n    v11 = sub_FFFFFFFF81172A10(qword_FFFFFFFF81CB89F0, (__int64)v10);\n    v13 = v11;\n    if ( v11 )\n    {\n      sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C3FC40);\n      sub_FFFFFFFF81792900(v13 + 32);\n      v16 = *(_QWORD **)(v13 + 112);\n      v17 = (_QWORD *)(v13 + 112);\n      if ( v16 )\n      {\n        while ( v16[3] != a2 || a1 != v16[2] )\n        {\n          v17 = v16;\n          v16 = (_QWORD *)*v16;\n          if ( !v16 )\n            goto LABEL_9;\n        }\n        v18 = qword_FFFFFFFF81CB8A00;\n        *v17 = *v16;\n        sub_FFFFFFFF8112DAA0(v18, (unsigned __int64)v16, a3, a4, a5, a6, v14, v15, a9, a10);\n        sub_FFFFFFFF81173AB0(v13);\n      }\nLABEL_9:\n      ++*(_BYTE *)(v13 + 32);\n      if ( !*(_QWORD *)(v13 + 112) )\n      {\n        v16 = (_QWORD *)qword_FFFFFFFF81CB89F0;\n        sub_FFFFFFFF81173110(v13, qword_FFFFFFFF81CB89F0);\n      }\n      sub_FFFFFFFF8178F1B0(&unk_FFFFFFFF81C3FC40);\n      LOBYTE(v11) = sub_FFFFFFFF81172E40(v13, (__int64)v16, v19, v20, v21, v22, a3, a4, a5, a6, v23, v24, a9, a10);\n    }\n  }\n  return v11;\n}\n",
    "function_name": "dnotify_flush",
    "decompiled_code": "char __fastcall dnotify_flush(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _WORD *v10; // rdx\n  __int64 inode_mark; // rax\n  __int64 v13; // r13\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 *v16; // rsi\n  __int64 *v17; // rcx\n  __int64 v18; // rdi\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n\n  v10 = *(_WORD **)(a1 + 32);\n  LOWORD(inode_mark) = *v10 & 0xF000;\n  if ( (_WORD)inode_mark == 0x4000 )\n  {\n    inode_mark = fsnotify_find_inode_mark(dnotify_group, (__int64)v10);\n    v13 = inode_mark;\n    if ( inode_mark )\n    {\n      mutex_lock((__int64)&dnotify_mark_mutex);\n      raw_spin_lock((volatile signed __int16 *)(v13 + 32));\n      v16 = *(__int64 **)(v13 + 112);\n      v17 = (__int64 *)(v13 + 112);\n      if ( v16 )\n      {\n        while ( v16[3] != a2 || a1 != v16[2] )\n        {\n          v17 = v16;\n          v16 = (__int64 *)*v16;\n          if ( !v16 )\n            goto LABEL_9;\n        }\n        v18 = dnotify_struct_cache;\n        *v17 = *v16;\n        kmem_cache_free(v18, v16, a3, a4, a5, a6, v14, v15, a9, a10);\n        dnotify_recalc_inode_mask(v13);\n      }\nLABEL_9:\n      ++*(_BYTE *)(v13 + 32);\n      if ( !*(_QWORD *)(v13 + 112) )\n      {\n        v16 = (__int64 *)dnotify_group;\n        fsnotify_destroy_mark(v13, dnotify_group, a3, a4, a5, a6, v14, v15, a9, a10);\n      }\n      mutex_unlock((__int64)&dnotify_mark_mutex);\n      LOBYTE(inode_mark) = fsnotify_put_mark(v13, (__int64)v16, v19, a3, a4, a5, a6, v20, v21, a9, a10);\n    }\n  }\n  return inode_mark;\n}\n",
    "source_code": "void dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_mark_mutex */\n\tif (dn_mark->dn == NULL)\n\t\tfsnotify_destroy_mark(fsn_mark, dnotify_group);\n\n\tmutex_unlock(&dnotify_mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n}",
    "comment": "Removes a dnotify structure associated with a file if the owner ID matches, and cleans up the corresponding fsnotify mark if no more notifications exist.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Removes an inotify mark from a group , updating flags and freeing associated resources if the mark is no longer in use .\n",
    "cpbcs_sum": "Releases a sysfs file system by decrementing its reference count and freeing its associated resources if it reaches zero and Releases locks.\n",
    "misum_sum": "Removes a node from a red-black tree and frees the associated memory if it matches the specified node and is not empty.\n",
    "decom_sum": "Removes a matching entry from a linked list, updates related structures, and triggers follow-up processing when a specific header field equals 0x4000.",
    "cfg_sum": "Removes a matching entry from an internal linked list, updates usage counters, performs cleanup operations, and invokes follow-up processing routines.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains a vague and unrelated statement that does not reflect the semantics or specifics of the source code. It fails to identify any accurate claims about the function, its parameters, or control flow, and does not correspond to the implementation. This results in 0% accurate claims.",
                "The summary 'push a pointer type.' is vague and unrelated to the source code's actual purpose of flushing dnotify marks from an inode. It neither captures the primary purpose nor any secondary details such as locking, mark destruction, or memory freeing. This results in no accurate claim coverage of the source code's semantics.",
                "The summary claim 'push a pointer type' is vague, contextless, and does not describe the function's actual purpose or behavior in the source code. It is categorized as NOISE because it does not target the semantics of the code\u2014there is no pushing of a pointer in the implementation. With no accurate claims and entirely irrelevant content, the net benefit is zero and the worst failure mode is overwhelming NOISE."
            ]
        },
        "bint5": {
            "summary": "Removes an inotify mark from a group , updating flags and freeing associated resources if the mark is no longer in use .\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary is inaccurate because it refers to an 'inotify mark' while the source code deals with 'dnotify' marks. This misidentification targets code semantics and contradicts the actual implementation. Although freeing resources and removing marks when no longer in use is correct, the majority of the claims are undermined by the incorrect subsystem reference, resulting in less than half of the claims being accurate.",
                "The summary identifies a removal of a file-system notification mark and freeing resources when unused, which loosely matches the code\u2019s primary purpose of removing a dnotify mark for a specific file/owner and freeing it if no longer present. However, it inaccurately labels the mark as 'inotify' instead of 'dnotify' and omits critical secondary details such as checks for directory type, locating the specific inode mark, use of locking (mutex and spinlock), and recalculating the inode mask before destruction. These omissions reduce completeness and precision.",
                "The summary claim that the function removes an inotify mark is inaccurate, as the code actually deals with dnotify marks via a dnotify_group, not inotify. This is a FATAL error affecting the primary purpose. While the summary mentions freeing resources when no longer in use, which matches the freeing of dnotify_struct and destroying the mark, the core identification of the type of mark is wrong, making the description misleading about its purpose."
            ]
        },
        "cpbcs": {
            "summary": "Releases a sysfs file system by decrementing its reference count and freeing its associated resources if it reaches zero and Releases locks.\n",
            "score": [
                0.1,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function releases a sysfs file system by decrementing its reference count and freeing resources when it reaches zero, which is unrelated to the actual implementation. The source code instead manages dnotify marks for directories, removes them for a specific owner/file, frees their memory, recalculates inode masks, and handles locking. While the mention of releasing locks is accurate, the majority of the claims are incorrect and unrelated to the code, resulting in a low accuracy proportion.",
                "The summary claims the function releases a sysfs file system and decrements its reference count, which contradicts the source code that handles flushing dnotify marks from an inode if it is a directory and matches specific owner/file criteria. The summary omits the primary purpose and all critical semantic details such as the directory check, mark lookup, lock handling, removal of matching entries, recalculation of the inode mask, and destruction of marks. This makes the claims inaccurate and results in no alignment with the actual implementation.",
                "The summary inaccurately describes the function as releasing a sysfs file system and managing reference counts, which contradicts the source code. The actual code handles cleanup of dnotify marks tied to a file and owner ID within the dnotify/fsnotify subsystem. The only partially aligned part is mentioning lock release (mutex_unlock/spin_unlock), which is correct but low-value. The dominant failure mode is FATAL because the summary misidentifies the primary purpose and key I/O semantics, resulting in very low alignment and reliability."
            ]
        },
        "misum": {
            "summary": "Removes a node from a red-black tree and frees the associated memory if it matches the specified node and is not empty.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes removing a node from a red-black tree and freeing its memory, which does not align with the source code. The actual implementation removes a matching dnotify_struct from a linked list associated with an inode, guarded by mutex and spin locks, and then frees resources. There is no red-black tree manipulation in the code, making the claim specific but incorrect. This results in 0% accurate claims.",
                "The summary incorrectly describes the function as removing a node from a red-black tree, which contradicts the source code. The actual implementation flushes dnotify marks for a given file and owner, involving checks for directory inodes, locking mechanisms, removal from a linked list, freeing memory, and potentially destroying the inode mark. This mismatch means the primary purpose is missed and no accurate secondary details are provided.",
                "The summary inaccurately describes the function\u2019s behavior, claiming it removes a node from a red-black tree, which is not supported by the source code. The actual code deals with removing a dnotify_struct from a linked list under locks, freeing memory, recalculating inode masks, and potentially destroying a mark. This is a FATAL error affecting the primary purpose, as it misrepresents the data structure and key operation. No accurate claims are present, resulting in high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578918368,
    "strip_function_name": "sub_FFFFFFFF81011DE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81011DE0(__int64 a1)\n{\n  unsigned __int64 v1; // r12\n  __int64 *v2; // r13\n  unsigned int v3; // r14d\n  signed int v4; // ebx\n  unsigned __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v8; // [rsp+8h] [rbp-B8h]\n  _BYTE v9[32]; // [rsp+10h] [rbp-B0h] BYREF\n  __int64 v10; // [rsp+30h] [rbp-90h]\n  __int64 v11; // [rsp+50h] [rbp-70h]\n  __int64 v12; // [rsp+58h] [rbp-68h]\n  __int64 v13; // [rsp+68h] [rbp-58h]\n  __int64 v14; // [rsp+70h] [rbp-50h]\n  __int64 v15; // [rsp+78h] [rbp-48h]\n  __int64 v16; // [rsp+80h] [rbp-40h]\n  __int64 v17; // [rsp+88h] [rbp-38h]\n  __int64 v18; // [rsp+90h] [rbp-30h]\n\n  v1 = __readgsqword(0xBC08u) + 43488;\n  ((void (__fastcall *)(__int64, __int64))off_FFFFFFFF81CB6AB8[37])(832LL, 1024LL);\n  if ( dword_FFFFFFFF81CB550C <= 0 )\n  {\n    return 0;\n  }\n  else\n  {\n    v2 = (__int64 *)v1;\n    v3 = 0;\n    v4 = 0;\n    do\n    {\n      if ( _bittest((const signed __int32 *)(v1 + 512), v4) )\n      {\n        v8 = *v2;\n        v5 = sub_FFFFFFFF81010A60(*v2);\n        if ( !_bittest64((const __int64 *)&v5, (unsigned int)(dword_FFFFFFFF81CB5514 - 1)) )\n        {\n          ++v3;\n          v10 = 0LL;\n          v13 = 0LL;\n          v14 = 0LL;\n          v15 = 0LL;\n          v16 = 0LL;\n          v6 = *(_QWORD *)(v8 + 384);\n          v17 = 0LL;\n          v18 = 0LL;\n          v12 = 0LL;\n          v11 = v6;\n          if ( (unsigned int)sub_FFFFFFFF81011590(v8) )\n          {\n            if ( (unsigned int)sub_FFFFFFFF810E2950(v8, v9, a1) )\n              sub_FFFFFFFF81010AE0(v8, 0);\n          }\n        }\n      }\n      else\n      {\n        v3 -= (_bittestandreset((signed __int32 *)(v1 + 520), v4) == 0) - 1;\n      }\n      ++v4;\n      ++v2;\n    }\n    while ( dword_FFFFFFFF81CB550C > v4 );\n    if ( v3 )\n      __incgsdword(0xEB1Cu);\n  }\n  return v3;\n}\n",
    "function_name": "x86_pmu_handle_irq",
    "decompiled_code": "__int64 __fastcall x86_pmu_handle_irq(__int64 a1)\n{\n  unsigned __int64 v1; // r12\n  _BYTE *v2; // rsi\n  __int64 *v3; // r13\n  unsigned int v4; // r14d\n  signed int v5; // ebx\n  unsigned __int64 v6; // rax\n  __int64 v7; // r8\n  int v8; // r9d\n  unsigned __int64 v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  __int64 v15; // [rsp+8h] [rbp-B8h]\n  _BYTE v16[32]; // [rsp+10h] [rbp-B0h] BYREF\n  __int64 v17; // [rsp+30h] [rbp-90h]\n  __int64 v18; // [rsp+50h] [rbp-70h]\n  __int64 v19; // [rsp+58h] [rbp-68h]\n  __int64 v20; // [rsp+68h] [rbp-58h]\n  __int64 v21; // [rsp+70h] [rbp-50h]\n  __int64 v22; // [rsp+78h] [rbp-48h]\n  __int64 v23; // [rsp+80h] [rbp-40h]\n  __int64 v24; // [rsp+88h] [rbp-38h]\n  __int64 v25; // [rsp+90h] [rbp-30h]\n\n  v1 = __readgsqword(0xBC08u) + 43488;\n  v2 = (_BYTE *)&unk_400;\n  (*((void (__fastcall **)(__int64, __int64))apic + 37))(832LL, 1024LL);\n  if ( dword_FFFFFFFF81CB550C <= 0 )\n  {\n    return 0;\n  }\n  else\n  {\n    v3 = (__int64 *)v1;\n    v4 = 0;\n    v5 = 0;\n    do\n    {\n      if ( _bittest((const signed __int32 *)(v1 + 512), v5) )\n      {\n        v15 = *v3;\n        v6 = x86_perf_event_update(*v3);\n        v9 = (unsigned int)(dword_FFFFFFFF81CB5514 - 1);\n        if ( !_bittest64((const __int64 *)&v6, v9) )\n        {\n          ++v4;\n          v17 = 0LL;\n          v20 = 0LL;\n          v21 = 0LL;\n          v22 = 0LL;\n          v23 = 0LL;\n          v10 = *(_QWORD *)(v15 + 384);\n          v24 = 0LL;\n          v25 = 0LL;\n          v19 = 0LL;\n          v18 = v10;\n          if ( (unsigned int)x86_perf_event_set_period(\n                               v15,\n                               (__int64)v2,\n                               v9,\n                               (unsigned int)dword_FFFFFFFF81CB5514,\n                               v7,\n                               v8) )\n          {\n            v2 = v16;\n            if ( (unsigned int)perf_event_overflow(v15, (__int64)v16, a1, v11, v12, v13) )\n            {\n              v2 = 0LL;\n              x86_pmu_stop(v15, 0);\n            }\n          }\n        }\n      }\n      else\n      {\n        v4 -= (_bittestandreset((signed __int32 *)(v1 + 520), v5) == 0) - 1;\n      }\n      ++v5;\n      ++v3;\n    }\n    while ( dword_FFFFFFFF81CB550C > v5 );\n    if ( v4 )\n      __incgsdword(0xEB1Cu);\n  }\n  return v4;\n}\n",
    "source_code": "\nint x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
    "comment": "Handles performance monitoring unit interrupts by checking active counters, updating event values, and managing event overflows, while ensuring proper NMI handling.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Captures the user-space call chain by traversing the stack frames from the current register state while enforcing stack depth limits .\n",
    "cpbcs_sum": "Handles machine check events by scheduling error codes and invoking a message to each active CPU in the Linux kernel.\n",
    "misum_sum": "Drains and frees all active performance monitoring events for a given CPU while handling interrupts and managing event synchronization.\n",
    "decom_sum": "Iterates over active objects, performs conditional processing and resets, and increments a global counter for successfully handled entries.",
    "cfg_sum": "Iterates over a set of memory-mapped entries, evaluates bit flags and conditions, updates counters, and triggers specific actions on qualifying entries.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving string conversion, printf formatting, and a static buffer, which is unrelated to the source code that handles x86 performance monitoring interrupts. None of the claims align with the source code semantics, resulting in no accurate matches.",
                "The summary is entirely inaccurate; it describes behavior involving string conversion, printf formatting, and byte limits, none of which appear in the source code. The actual function handles performance monitoring unit interrupts, updates counters, processes event overflows, and returns the number of handled interrupts. The summary misses the primary purpose and all secondary details, with no claims matching the code semantics.",
                "All claims in the summary are inaccurate as they describe functionality involving a static buffer, printf formatting, and byte limits, which is entirely unrelated to the source code\u2019s purpose of handling x86 PMU interrupts. This is a FATAL mismatch because the primary purpose and key I/O behavior are misrepresented, leaving no accurate information to aid understanding."
            ]
        },
        "bint5": {
            "summary": "Captures the user-space call chain by traversing the stack frames from the current register state while enforcing stack depth limits .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes claims about capturing a user-space call chain and traversing stack frames, which are unrelated to the source code. The actual function handles performance monitoring unit (PMU) interrupt processing, updates counter values, and manages event overflow logic. None of the summary\u2019s descriptions match or align with these behaviors, resulting in no accurate claims.",
                "The summary talks about traversing user-space stack frames and enforcing stack depth limits, which does not align with the source code. The function in the source handles performance monitoring unit (PMU) interrupts, processes hardware events, and updates counters. None of these behaviors, inputs, or outputs relate to capturing call chains, so the summary misses the primary purpose and all secondary details.",
                "The summary claims the function captures a user-space call chain by traversing stack frames with depth limits, which is entirely unrelated to the source code. The actual implementation handles x86 performance monitoring unit interrupts, updates counters, processes overflow events, and increments an interrupt statistic. This is a FATAL error affecting the primary purpose of the function, making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Handles machine check events by scheduling error codes and invoking a message to each active CPU in the Linux kernel.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's main claims about handling machine check events, scheduling error codes, and invoking a message to each active CPU do not align with the source code, which actually handles performance monitoring unit interrupts by processing active counters. None of the claims accurately reflect the implementation's semantics, resulting in no ACCURATE matches.",
                "The summary incorrectly describes the function as handling machine check events, scheduling error codes, and messaging CPUs, which does not align with the source code. The actual implementation handles performance monitoring unit (PMU) interrupts, processes active counters, updates event values, manages overflow conditions, and increments interrupt statistics. The primary purpose and relevant secondary details in the code are entirely missed, making the claims inaccurate.",
                "The summary claims the function handles machine check events by scheduling error codes and sending messages to CPUs, which is inaccurate. The source code actually handles performance monitoring unit (PMU) interrupts/NMI events, processes active hardware counters, and updates statistics. This is a FATAL error since it misstates the primary purpose and key I/O behavior, leading to misleading understanding."
            ]
        },
        "misum": {
            "summary": "Drains and frees all active performance monitoring events for a given CPU while handling interrupts and managing event synchronization.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. The source code handles performance monitoring interrupts by updating counters, processing overflows, and stopping events when needed, but it does not drain or free all active events or perform a full synchronization operation. The claims in the summary largely contradict actual semantics, resulting in very low alignment.",
                "The summary inaccurately describes the function as draining and freeing performance monitoring events, which does not match the source code. The actual code handles performance monitoring unit interrupts by iterating over active counters, updating event values, detecting overflows, and possibly stopping events, but does not free resources or drain events. While it mentions handling interrupts, it misses the primary purpose of processing PMU overflow events and managing related data, leading to a mismatch with core semantics.",
                "The summary incorrectly claims that the function 'drains and frees' all active performance monitoring events, which contradicts the source code. The implementation handles PMU interrupts by updating counters, managing overflow, and stopping events as needed, but it does not free them. This is a FATAL inaccuracy targeting the primary purpose. No accurate, specific details are provided, so there is high negative impact and low positive gain."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4229088,
    "strip_function_name": "sub_4087E0",
    "strip_decompiled_code": "__int64 __fastcall sub_4087E0(__int64 a1, const char *a2, char a3)\n{\n  char *v4; // rax\n  char *v5; // rbx\n  int v6; // ebp\n  int v8; // r13d\n  __int64 v9; // rbp\n  char *v10; // rax\n  regex_t *v11; // r13\n  char *v12; // rax\n\n  v4 = (char *)calloc(1uLL, 0x2002uLL);\n  if ( !v4 )\n    return (unsigned int)-1;\n  v5 = v4;\n  v6 = 0;\n  if ( strlen(a2) <= 0xFFF )\n  {\n    v6 = sub_408140(a1, 0);\n    if ( v6 > 0 )\n    {\n      v8 = a3 & 3;\n      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 96LL);\n      switch ( v8 )\n      {\n        case 1:\n          *(_DWORD *)(v9 + 12) = 13;\n          break;\n        case 2:\n          *(_DWORD *)(v9 + 12) = 16;\n          break;\n        case 3:\n          *(_DWORD *)(v9 + 12) = 20;\n          v12 = strdup(a2);\n          *(_QWORD *)(v9 + 16) = v12;\n          if ( v12 )\n          {\n            v6 = 1;\n            goto LABEL_3;\n          }\n          goto LABEL_15;\n        default:\n          *(_DWORD *)(v9 + 12) = 1;\n          break;\n      }\n      v10 = strdup(a2);\n      *(_QWORD *)(v9 + 16) = v10;\n      if ( v10 )\n      {\n        v11 = (regex_t *)calloc(1uLL, 0x40uLL);\n        if ( v11 )\n        {\n          sub_40E8D0(a2, v5, 0LL);\n          if ( regcomp(v11, v5, 0) )\n          {\n            v6 = 0;\n            free(v11);\n          }\n          else\n          {\n            *(_QWORD *)(v9 + 24) = v11;\n            v6 = 1;\n          }\n          goto LABEL_3;\n        }\n      }\nLABEL_15:\n      v6 = -1;\n    }\n  }\nLABEL_3:\n  free(v5);\n  return (unsigned int)v6;\n}\n",
    "function_name": "Findjob_set_name_expr",
    "decompiled_code": "__int64 __fastcall Findjob_set_name_expr(FindjoB *a1, char *a2, char a3)\n{\n  char *v4; // rax\n  char *v5; // rbx\n  int v6; // ebp\n  int v8; // r13d\n  ExprtesT *test; // rbp\n  char *v10; // rax\n  regex_t *v11; // r13\n  char *v12; // rax\n\n  v4 = (char *)calloc(1uLL, 0x2002uLL);\n  if ( !v4 )\n    return (unsigned int)-1;\n  v5 = v4;\n  v6 = 0;\n  if ( strlen(a2) <= 0xFFF )\n  {\n    v6 = Findjob_default_and(a1, 0);\n    if ( v6 > 0 )\n    {\n      v8 = a3 & 3;\n      test = a1->cursor->test;\n      switch ( v8 )\n      {\n        case 1:\n          test->test_type = 13;\n          break;\n        case 2:\n          test->test_type = 16;\n          break;\n        case 3:\n          test->test_type = 20;\n          v12 = strdup(a2);\n          test->arg1 = v12;\n          if ( v12 )\n          {\n            v6 = 1;\n            goto LABEL_3;\n          }\n          goto LABEL_15;\n        default:\n          test->test_type = 1;\n          break;\n      }\n      v10 = strdup(a2);\n      test->arg1 = v10;\n      if ( v10 )\n      {\n        v11 = (regex_t *)calloc(1uLL, 0x40uLL);\n        if ( v11 )\n        {\n          Xorriso__bourne_to_reg(a2, v5, 0);\n          if ( regcomp(v11, v5, 0) )\n          {\n            v6 = 0;\n            free(v11);\n          }\n          else\n          {\n            test->arg2 = v11;\n            v6 = 1;\n          }\n          goto LABEL_3;\n        }\n      }\nLABEL_15:\n      v6 = -1;\n    }\n  }\nLABEL_3:\n  free(v5);\n  return (unsigned int)v6;\n}\n",
    "source_code": "int Findjob_set_name_expr(struct FindjoB *o, char *name_expr, int flag)\n{\n char *regexpr= NULL;\n regex_t *name_re;\n struct ExprtesT *t;\n int ret;\n\n regexpr= TSOB_FELD(char, 2*SfileadrL+2);\n if(regexpr == NULL)\n   {ret= -1; goto ex;}\n if(strlen(name_expr)>=SfileadrL)\n   {ret= 0; goto ex;};\n\n ret= Findjob_default_and(o, 0);\n if(ret <= 0)\n   goto ex;\n t= o->cursor->test;\n t->test_type= 1;\n if ((flag & 3) == 1)\n   t->test_type= 13;\n else if((flag & 3) == 2)\n   t->test_type= 16;\n else if((flag & 3) == 3)\n   t->test_type= 20;\n t->arg1= strdup(name_expr);\n if(t->arg1 == NULL)\n   {ret= -1; goto ex;};\n\n if((flag & 3) == 3)\n   {ret= 1; goto ex;}\n\n name_re= (regex_t *) calloc(1, sizeof(regex_t));\n if(name_re == NULL)\n   {ret= -1; goto ex;};\n Xorriso__bourne_to_reg(name_expr, regexpr, 0);\n if(regcomp(name_re, regexpr, 0) != 0) {\n   free((char *) name_re);\n   {ret= 0; goto ex;};\n }\n t->arg2= name_re;\n ret= 1;\nex:;\n Xorriso_free_meM(regexpr);\n return(ret);\n}",
    "comment": "Constructs a regex from a given name expression and updates a job's testing criteria based on a specified flag, returning success status.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a pattern to exclusion lists in a filesystem based on specified flags and conditions , allocating memory for the new pattern .\n",
    "cpbcs_sum": "Sets the application type and corresponding objects in a FindjoB structure based on provided flags, ensuring valid boot file paths.\n",
    "misum_sum": "Sets the file name in a structure based on the provided file name, caching the mode and managing memory allocation and errors.\n",
    "decom_sum": "Compiles a given string into a regex, stores it with a mode code and pattern copy in a structure, returning success or error status.",
    "cfg_sum": "Compiles a regex pattern from the provided string, configures related parameters based on a mode flag, and returns success or error status.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains only one vague claim ('push a pointer type') that does not correspond to any specific behavior in the source code. The function instead manipulates structures, flags, and regex data, not pointer pushing semantics. Thus, none of the factual content aligns with the code implementation.",
                "The summary 'push a pointer type.' does not capture the primary purpose or any secondary details of the source code. The function sets up a test structure with a name expression, processes flags to determine test type, compiles a regex, handles memory allocation errors, and returns status codes. The summary is entirely unrelated to these semantics, making it inaccurate and offering no coverage of the CSU_LIST.",
                "The summary 'push a pointer type.' is vague and does not connect to any specific aspect of the source code semantics. It fails to describe the function's primary purpose, key inputs/outputs, or side effects, resulting in pure noise with no factual alignment or useful detail. The worst failure mode is NOISE, with no accurate claims extracted."
            ]
        },
        "bint5": {
            "summary": "Adds a pattern to exclusion lists in a filesystem based on specified flags and conditions , allocating memory for the new pattern .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary's claim that the function adds a pattern to exclusion lists in a filesystem is inaccurate, as the source code shows it sets up a test structure with a regex compiled from the provided name expression\u2014not managing filesystem exclusion lists. While it correctly notes memory allocation for a pattern via strdup and calloc, the central action is misrepresented, resulting in less than half of the claims being aligned with the code.",
                "The summary incorrectly states that the function adds a pattern to exclusion lists in a filesystem, which contradicts the source code. The source code shows that the function sets up a job test expression with a regex pattern based on flags, allocates memory, performs length checks, handles errors, and compiles the regex; there is no indication of managing exclusion lists. This misrepresentation means the primary purpose is missed, and the specifics in the summary do not align with actual behavior.",
                "The summary claims the function adds a pattern to exclusion lists in a filesystem, which is not supported by the source code; this is a FATAL error targeting the primary purpose, since the actual function sets up a test on a job object with regex compilation and flag-based behavior, not exclusion lists. The only partially accurate element is the mention of allocating memory for a pattern, but this is overshadowed by the incorrect high-level description of its purpose."
            ]
        },
        "cpbcs": {
            "summary": "Sets the application type and corresponding objects in a FindjoB structure based on provided flags, ensuring valid boot file paths.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function sets an application type and corresponding objects based on flags and ensures valid boot file paths. While part of this is accurate \u2014 the function does set a test_type in the FindjoB structure based on the flag \u2014 the mention of 'application type' and 'boot file paths' is inaccurate or misleading, as the code deals with test_type values, name expressions, allocation, and regex compilation, not boot file paths. Only part of the claim aligns with the source code, resulting in less than half of the claim content being accurate.",
                "The summary incorrectly frames the function as setting an application type and ensuring valid boot file paths, which does not match the source code. The actual implementation initializes a test object in a FindjoB structure, assigns test types based on the flag, duplicates the name expression, compiles it into a regex, and handles related memory allocation and error cases. The summary misses the primary purpose of preparing and validating a regex from the name expression and setting the test object, and introduces unrelated concepts like 'boot file paths,' making its main claim inaccurate.",
                "The summary claims it ensures valid boot file paths, which is inaccurate because the source code validates the length of the provided name expression and compiles it into a regex, not boot file paths. This is a FATAL error as it misstates the primary purpose and I/O of the function. The part about setting application type based on provided flags loosely aligns with setting test_type, but terminology like 'application type' is misleading given it actually sets test types in an ExprtesT struct. Overall, the inaccuracies outweigh any safe details."
            ]
        },
        "misum": {
            "summary": "Sets the file name in a structure based on the provided file name, caching the mode and managing memory allocation and errors.\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary claims the function sets a file name in a structure, which partially aligns with the code's behavior of assigning name_expr to t->arg1, but it incorrectly mentions caching the mode and omits key behaviors such as setting test_type based on flag and compiling a regex. The reference to caching the mode is inaccurate as there is no mode caching mechanism in the source code. Overall, less than half of the claims accurately reflect the implementation.",
                "The summary fails to capture the primary purpose of the function, which is setting up a test structure in a FindjoB object using a name expression, determining test type from flag values, compiling a regex, and handling memory allocation and error paths. It incorrectly generalizes the operation as setting a file name and caching mode, which is not evident in the source code, and omits critical secondary details such as regex compilation, flag-based branching, and cleanup.",
                "The summary makes a broad claim about setting a file name in a structure, which is loosely aligned with the code storing the provided name_expr in t->arg1. However, it inaccurately adds noise by mentioning caching the mode, a behavior not present in the source, and omits key specifics such as regex compilation, flag-based test_type changes, and error handling steps. The worst failure mode is NOISE due to irrelevant or unsupported claims outweighing accurate content, and the gain is low because the accurate part is generic."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583342224,
    "strip_function_name": "sub_FFFFFFFF81449E90",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81449E90(__int64 a1, char a2)\n{\n  __int64 result; // rax\n  int v4; // esi\n  unsigned __int16 v5; // cx\n  unsigned __int16 v6; // cx\n  unsigned int v7; // ecx\n  int v8; // [rsp+0h] [rbp-18h] BYREF\n  unsigned int v9[5]; // [rsp+4h] [rbp-14h] BYREF\n\n  result = *(_QWORD *)(a1 + 3024);\n  if ( (result & 0x40) != 0 )\n  {\n    result = *(unsigned int *)(a1 + 3412);\n    if ( (*(_QWORD *)(a1 + 3024) & 0x2000LL) == 0 || (result & 0x20) == 0 )\n    {\n      if ( (result & 0x40) != 0 )\n      {\n        result = sub_FFFFFFFF81448B00(a1, *(unsigned __int8 *)(a1 + 3404), 31, &v8);\n        if ( !(_DWORD)result )\n        {\n          HIBYTE(v6) = BYTE1(v8);\n          LOBYTE(v6) = v8 | 0x80;\n          sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 31, v6);\n          if ( !(unsigned int)sub_FFFFFFFF81448B00(a1, *(unsigned __int8 *)(a1 + 3404), 27, v9) )\n          {\n            if ( a2 )\n              v7 = v9[0] | 0x20;\n            else\n              v7 = v9[0] & 0xFFFFFFDF;\n            v9[0] = v7;\n            sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 27, v7);\n          }\n          return sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 31, v8);\n        }\n      }\n      else\n      {\n        v4 = *(unsigned __int8 *)(a1 + 3404);\n        if ( *(_DWORD *)(a1 + 3232) >> 12 == 22404 && a2 )\n        {\n          sub_FFFFFFFF81448910(a1, v4, 28, 0x941Du);\n          v5 = -22495;\n        }\n        else\n        {\n          sub_FFFFFFFF81448910(a1, v4, 28, 0x941Fu);\n          v5 = a2 == 0 ? -22527 : -22495;\n        }\n        return sub_FFFFFFFF81448910(a1, *(unsigned __int8 *)(a1 + 3404), 28, v5);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "tg3_phy_toggle_apd",
    "decompiled_code": "__int64 __fastcall tg3_phy_toggle_apd(__int64 a1, char a2)\n{\n  __int64 result; // rax\n  int v4; // esi\n  unsigned __int16 v5; // cx\n  unsigned __int16 v6; // cx\n  unsigned int v7; // ecx\n  int v8; // [rsp+0h] [rbp-18h] BYREF\n  unsigned int v9[5]; // [rsp+4h] [rbp-14h] BYREF\n\n  result = *(_QWORD *)(a1 + 3024);\n  if ( (result & 0x40) != 0 )\n  {\n    result = *(unsigned int *)(a1 + 3412);\n    if ( (*(_QWORD *)(a1 + 3024) & 0x2000LL) == 0 || (result & 0x20) == 0 )\n    {\n      if ( (result & 0x40) != 0 )\n      {\n        result = _tg3_readphy(a1, *(unsigned __int8 *)(a1 + 3404), 31, &v8);\n        if ( !(_DWORD)result )\n        {\n          HIBYTE(v6) = BYTE1(v8);\n          LOBYTE(v6) = v8 | 0x80;\n          _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 31, v6);\n          if ( !(unsigned int)_tg3_readphy(a1, *(unsigned __int8 *)(a1 + 3404), 27, v9) )\n          {\n            if ( a2 )\n              v7 = v9[0] | 0x20;\n            else\n              v7 = v9[0] & 0xFFFFFFDF;\n            v9[0] = v7;\n            _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 27, v7);\n          }\n          return _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 31, v8);\n        }\n      }\n      else\n      {\n        v4 = *(unsigned __int8 *)(a1 + 3404);\n        if ( *(_DWORD *)(a1 + 3232) >> 12 == 22404 && a2 )\n        {\n          _tg3_writephy(a1, v4, 28, 0x941Du);\n          v5 = -22495;\n        }\n        else\n        {\n          _tg3_writephy(a1, v4, 28, 0x941Fu);\n          v5 = a2 == 0 ? -22527 : -22495;\n        }\n        return _tg3_writephy(a1, *(unsigned __int8 *)(a1 + 3404), 28, v5);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)\n{\n\tu32 reg;\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    (tg3_flag(tp, 5717_PLUS) &&\n\t     (tp->phy_flags & TG3_PHYFLG_MII_SERDES)))\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\ttg3_phy_fet_toggle_apd(tp, enable);\n\t\treturn;\n\t}\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_SCR5_SEL |\n\t      MII_TG3_MISC_SHDW_SCR5_LPED |\n\t      MII_TG3_MISC_SHDW_SCR5_DLPTLM |\n\t      MII_TG3_MISC_SHDW_SCR5_SDTL |\n\t      MII_TG3_MISC_SHDW_SCR5_C125OE;\n\tif (tg3_asic_rev(tp) != ASIC_REV_5784 || !enable)\n\t\treg |= MII_TG3_MISC_SHDW_SCR5_DLLAPD;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_APD_SEL |\n\t      MII_TG3_MISC_SHDW_APD_WKTM_84MS;\n\tif (enable)\n\t\treg |= MII_TG3_MISC_SHDW_APD_ENABLE;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n}",
    "comment": "Toggles the APD feature of a PHY interface based on device flags and configurations, writing appropriate values to the hardware registers.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Configures the MAC mode for a network device based on specific conditions and flags , ensuring compatibility with hardware specifications .\n",
    "cpbcs_sum": "Toggles the auxiliary control register based on the current PHY register in the tg3 device, writing or power-down bit accordingly.\n",
    "misum_sum": "Configures the PHY auto-negotiation settings based on the power management capabilities and auto-negotiation mask, adjusting for link status and link speed accordingly.\n",
    "decom_sum": "Updates device control registers based on status flags, adjusting bitfields and issuing configuration commands depending on the input flag and hardware state.",
    "cfg_sum": "Updates device register values based on specific status and control flags, modifying bits according to input parameter and hardware state conditions.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague statement unrelated to the semantics or implementation in the source code. It does not describe any actual behavior, condition, or logic from the function and instead introduces an irrelevant concept. No fact-based claims from the summary can be matched accurately to the given code.",
                "The summary 'push a pointer type.' is unrelated to the source code. It does not address the function\u2019s primary purpose, which is to toggle the PHY's Auto Power Down feature based on specific hardware flags and conditions. No fact-based claims are made about inputs, outputs, or behavior, so it fails to capture any CSU_LIST elements.",
                "The summary 'push a pointer type.' is completely unrelated to the source code, which configures PHY settings for a tg3 network device. It does not describe any operation, I/O, or side effect present in the implementation, making it pure NOISE. There are no ACCURATE claims, and the worst failure mode is overwhelming NOISE, leading to no useful insight."
            ]
        },
        "bint5": {
            "summary": "Configures the MAC mode for a network device based on specific conditions and flags , ensuring compatibility with hardware specifications .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function configures the MAC mode based on conditions and hardware compatibility, but the source code actually toggles PHY auto power-down and related settings. The summary's main claim is inaccurate because it misidentifies the core functionality, resulting in no accurate alignment with the source code.",
                "The summary incorrectly states that the function configures the MAC mode, while the source code clearly toggles the PHY's Automatic Power Down (APD) settings based on hardware flags and ASIC revision. It misses the primary purpose entirely and does not capture any secondary details like conditional early returns, PHY FET-specific handling, or the different register configurations when enabling or disabling APD. The claim is thus inaccurate and provides no useful coverage of the actual implementation.",
                "The summary contains a single claim stating that the function configures the MAC mode for a network device, which is inaccurate. The source code shows the function toggles Auto Power Down (APD) for the PHY based on hardware flags and conditions, not MAC mode configuration. This is a FATAL error targeting the primary purpose of the function, with no accurate claims providing value."
            ]
        },
        "cpbcs": {
            "summary": "Toggles the auxiliary control register based on the current PHY register in the tg3 device, writing or power-down bit accordingly.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as toggling an auxiliary control register based on the current PHY register, but the source code shows it writes specific shadow register values determined by device flags and enable state, not based on reading a current register. This mismatch means the claim targets semantics but is incorrect, leading to no accurate claims.",
                "The summary vaguely mentions toggling an auxiliary control register and writing a power-down bit, but it misses the primary purpose which is specifically toggling the Auto Power-Down (APD) feature for tg3 PHY based on capability flags and hardware revision. It fails to capture key secondary details such as early returns for certain chip revisions or PHY types, conditional register flag settings based on ASIC revision and enable state, and the two distinct tg3_writephy calls with different configurations. The description is too generic and omits critical implementation logic tied to the source code.",
                "The summary makes an inaccurate claim about toggling the auxiliary control register based on the current PHY register, which does not match the source code. The function instead manipulates specific shadow registers (MII_TG3_MISC_SHDW) and sets bits related to APD and other PHY features, without reading the current PHY register to determine behavior. This is a FATAL error affecting the primary purpose, as it fundamentally misstates the function\u2019s key operations."
            ]
        },
        "misum": {
            "summary": "Configures the PHY auto-negotiation settings based on the power management capabilities and auto-negotiation mask, adjusting for link status and link speed accordingly.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function configures PHY auto-negotiation settings based on power management capabilities, auto-negotiation mask, link status, and link speed. In reality, the source code toggles the PHY's Auto Power Down feature depending on hardware flags and revision, without handling auto-negotiation, link status, or link speed. All claims in the summary are inaccurate because they misrepresent the actual purpose and logic of the function.",
                "The summary claims the function configures PHY auto-negotiation based on power management, link status, and speed, but the source code shows it toggles Auto Power Down (APD) with specific register manipulations and conditional checks for hardware flags and ASIC revisions. The summary misses the primary purpose entirely and contains inaccuracies about auto-negotiation, making it unrelated to the actual implementation.",
                "The summary claims the function configures PHY auto-negotiation settings and adjusts for link status and speed, but the source code actually toggles PHY Auto Power Down (APD) modes based on hardware flags and ASIC revisions, with no mention of auto-negotiation or link status/speed adjustments. This is a FATAL inaccuracy affecting the primary purpose, causing significant misrepresentation of the code's main function."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581900960,
    "strip_function_name": "sub_FFFFFFFF812EA0A0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF812EA0A0(\n        unsigned int a1,\n        unsigned int a2,\n        unsigned int a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  unsigned int v18; // eax\n  unsigned int v19; // eax\n  __int64 *v20; // rdx\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n\n  v14 = (unsigned int *)sub_FFFFFFFF8112CA50(\n                          (_QWORD *)qword_FFFFFFFF81E8C710,\n                          0x80D0u,\n                          160LL,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9,\n                          a10,\n                          a11,\n                          a12);\n  if ( v14 )\n  {\n    v17 = v14;\n    *v14 = a1;\n    v14[1] = a2;\n    sub_FFFFFFFF812E9D70(257, a3, v14, 0LL, a5, a6, a7, a8, v15, v16, a11, a12);\n    *(_DWORD *)(a4 + 12) = a1;\n    *(_DWORD *)(a4 + 16) = a2;\n    v18 = v17[25];\n    *(_DWORD *)(a4 + 8) = a3;\n    *(_DWORD *)(a4 + 20) = v18;\n    *(_DWORD *)(a4 + 24) = v17[26];\n    *(_DWORD *)(a4 + 28) = v17[27];\n    *(_DWORD *)(a4 + 32) = v17[28];\n    *(_DWORD *)(a4 + 36) = v17[29];\n    *(_DWORD *)(a4 + 40) = v17[30];\n    v19 = v17[31];\n    *(_DWORD *)(a4 + 52) = 0;\n    *(_QWORD *)(a4 + 44) = v19;\n    sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a5, a6, a7, a8, v24, v25, a11, a12, a3, v20, v21, v22, v23);\n  }\n}\n",
    "function_name": "calc_mode_timings",
    "decompiled_code": "void __fastcall calc_mode_timings(\n        unsigned int a1,\n        unsigned int a2,\n        unsigned int a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int *v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int *v17; // rbx\n  unsigned int v18; // eax\n  unsigned int v19; // eax\n  __int64 *v20; // rdx\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n\n  v14 = (unsigned int *)kmem_cache_alloc_trace(\n                          (__int64 *)qword_FFFFFFFF81E8C710,\n                          32976LL,\n                          160LL,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9,\n                          a10,\n                          a11,\n                          a12);\n  if ( v14 )\n  {\n    v17 = v14;\n    *v14 = a1;\n    v14[1] = a2;\n    fb_get_mode(257, a3, v14, 0LL, a5, a6, a7, a8, v15, v16, a11, a12);\n    *(_DWORD *)(a4 + 12) = a1;\n    *(_DWORD *)(a4 + 16) = a2;\n    v18 = v17[25];\n    *(_DWORD *)(a4 + 8) = a3;\n    *(_DWORD *)(a4 + 20) = v18;\n    *(_DWORD *)(a4 + 24) = v17[26];\n    *(_DWORD *)(a4 + 28) = v17[27];\n    *(_DWORD *)(a4 + 32) = v17[28];\n    *(_DWORD *)(a4 + 36) = v17[29];\n    *(_DWORD *)(a4 + 40) = v17[30];\n    v19 = v17[31];\n    *(_DWORD *)(a4 + 52) = 0;\n    *(_QWORD *)(a4 + 44) = v19;\n    kfree((__int64 *)v17, a5, a6, a7, a8, v21, v22, a11, a12, a3, v20);\n  }\n}\n",
    "source_code": "\nstatic void calc_mode_timings(int xres, int yres, int refresh,\n\t\t\t      struct fb_videomode *mode)\n{\n\tstruct fb_var_screeninfo *var;\n\n\tvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\n\n\tif (var) {\n\t\tvar->xres = xres;\n\t\tvar->yres = yres;\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,\n\t\t\t    refresh, var, NULL);\n\t\tmode->xres = xres;\n\t\tmode->yres = yres;\n\t\tmode->pixclock = var->pixclock;\n\t\tmode->refresh = refresh;\n\t\tmode->left_margin = var->left_margin;\n\t\tmode->right_margin = var->right_margin;\n\t\tmode->upper_margin = var->upper_margin;\n\t\tmode->lower_margin = var->lower_margin;\n\t\tmode->hsync_len = var->hsync_len;\n\t\tmode->vsync_len = var->vsync_len;\n\t\tmode->vmode = 0;\n\t\tmode->sync = 0;\n\t\tkfree(var);\n\t}\n}",
    "comment": "Calculates video mode timings based on resolution and refresh rate, populating the provided fb_videomode structure with these settings.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Allocates and initializes a framebuffer console structure with specified dimensions , display modes , and character widths , handling memory allocation failures .\n",
    "cpbcs_sum": "Schedules a deferred execution of a framebuffer helper device by allocating memory and copying data between the specified port and port.\n",
    "misum_sum": "Adds a new PCI device to the bus's state, allocating memory and setting up linked lists for the specified device list.\n",
    "decom_sum": "Allocates a 160-byte structure, initializes it with input parameters, updates a target data block\u2019s fields, then performs a final processing and cleanup operation.",
    "cfg_sum": "Allocates and initializes a structured data block with input parameters, updates multiple fields in a target structure, and finalizes through a cleanup subroutine.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary discusses generating LEB128 values with parameters for signed or unsigned encoding, which is unrelated to the source code that calculates video mode timings by setting resolution, refresh rates, and screen margins. None of the claims in the summary match or reflect the implementation details of the provided function, resulting in 0% accuracy.",
                "The summary is completely unrelated to the source code. The source function calculates and assigns video mode timings based on resolution and refresh rate, while the summary describes generating LEB128 values with a sign flag, which targets a different purpose and behavior entirely. No accurate claims about the source code are present, meaning the primary purpose and all secondary details are missed.",
                "The summary describes generating LEB128 values with sign handling, which is unrelated to the source code's purpose of calculating display mode timings and populating a fb_videomode struct. This is a NOISE case with no accurate claims, creating very low informational value and no connection to the actual code logic."
            ]
        },
        "bint5": {
            "summary": "Allocates and initializes a framebuffer console structure with specified dimensions , display modes , and character widths , handling memory allocation failures .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function allocates and initializes a framebuffer console structure, sets display modes, and handles character widths, but the source code shows it allocates a fb_var_screeninfo structure, sets resolution and timing values into an fb_videomode, and does not involve a console structure or character widths. It also does not explicitly handle memory allocation failures beyond a null check. Most claims are inaccurate or not grounded in the code.",
                "The summary incorrectly describes the function as dealing with a framebuffer console structure and character widths, which do not appear in the source code. While it notes memory allocation, it does not capture the actual primary purpose: computing and populating an fb_videomode structure's timing fields based on resolution and refresh rate after invoking fb_get_mode. It also misses secondary details such as copying specific timing margins, sync lengths, and cleanup via kfree. The misidentification of the structure type and extra unrelated details make most claims inaccurate.",
                "The summary incorrectly claims the function initializes a framebuffer console structure and includes character widths, which is not present in the source code. The code actually allocates a fb_var_screeninfo structure, populates it and a fb_videomode structure with resolution and timing values, and frees the memory. This is a FATAL inaccuracy regarding the primary purpose. While 'handling memory allocation failures' is partially safe, the main functional description is wrong, resulting in high negative impact and no reliable gain."
            ]
        },
        "cpbcs": {
            "summary": "Schedules a deferred execution of a framebuffer helper device by allocating memory and copying data between the specified port and port.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as scheduling deferred execution of a framebuffer helper device and copying data between ports, which is not reflected in the source code. The source code performs immediate calculation of video mode timings by allocating a struct, setting resolution fields, calling fb_get_mode, copying calculated timing parameters into the mode struct, and freeing the allocated memory. None of the claims in the summary accurately represent these operations, resulting in no accurate claims.",
                "The summary is inaccurate because it describes scheduling deferred execution of a framebuffer helper device and copying data between ports, which is unrelated to the actual function. The source code calculates framebuffer mode timings by allocating a fb_var_screeninfo struct, populating it with resolution and refresh values, calling fb_get_mode, and transferring those timing parameters to the fb_videomode structure before freeing memory. The summary misses the primary purpose and all secondary details.",
                "The summary's main claims about scheduling deferred execution and copying between ports are inaccurate; the source code actually allocates a framebuffer variable structure, sets resolution and refresh values, obtains mode timings, copies these into the mode struct, and frees memory. These differences represent FATAL errors about the primary purpose, as the summary misrepresents the core operation. There are no accurate details matching the code, resulting in high negative impact and no net benefit."
            ]
        },
        "misum": {
            "summary": "Adds a new PCI device to the bus's state, allocating memory and setting up linked lists for the specified device list.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function adds a new PCI device, allocates memory, and sets up linked lists, which is entirely unrelated to the source code. The source implements video mode timing calculations, allocates a fb_var_screeninfo, populates struct fb_videomode fields, and frees memory. None of the claims accurately target the actual code semantics, resulting in 0% accurate claims.",
                "The summary describes adding a PCI device, memory allocation, and linked list setup, none of which match the source code\u2019s actual purpose of calculating and populating display mode timings based on resolution and refresh rate. It misses the primary purpose entirely and introduces unrelated concepts, making all claims inaccurate and irrelevant to the source code.",
                "The summary claims the function adds a PCI device, allocates memory, and sets up linked lists for a device list, which is entirely unrelated to the source code. The actual function calculates video mode timings, sets resolution and sync parameters, and frees allocated memory. This is a FATAL error about the primary purpose, as it completely misstates the function's domain and key I/O."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4810656,
    "strip_function_name": "sub_4967A0",
    "strip_decompiled_code": "__int64 __fastcall sub_4967A0(_QWORD *a1, _DWORD *a2, int a3)\n{\n  _DWORD *v4; // rbp\n  void *v6; // rdi\n  __int64 result; // rax\n  void *v8; // rax\n  unsigned int v9; // [rsp+Ch] [rbp-2Ch]\n  _QWORD *v10; // [rsp+10h] [rbp-28h] BYREF\n  __int64 v11[4]; // [rsp+18h] [rbp-20h] BYREF\n\n  v4 = a2;\n  v10 = 0LL;\n  if ( a2 )\n  {\n    v6 = (void *)a1[629];\n    if ( v6 )\n      goto LABEL_3;\nLABEL_14:\n    v8 = calloc(0x8000uLL, 1uLL);\n    a1[629] = v8;\n    if ( !v8 )\n      return 4029743098LL;\nLABEL_17:\n    v11[0] = (__int64)v4;\n    result = sub_4957F0(a1 + 629, a1 + 630, (__int64)v4);\n    if ( (int)result < 0 )\n      return result;\n    goto LABEL_4;\n  }\n  v4 = (_DWORD *)a1[1];\n  v6 = (void *)a1[629];\n  if ( !v6 )\n    goto LABEL_14;\nLABEL_3:\n  if ( (a3 & 1) == 0 )\n  {\n    memset(v6, 0, 0x8000uLL);\n    goto LABEL_17;\n  }\nLABEL_4:\n  result = sub_490240(v4, &v10);\n  if ( (int)result >= 0 )\n  {\n    while ( (unsigned int)sub_490300((__int64 (__fastcall ***)(_QWORD))v10, (__int64)v11) == 1 )\n    {\n      result = sub_4957F0(a1 + 629, a1 + 630, v11[0]);\n      if ( (int)result >= 0 )\n      {\n        if ( (unsigned int)sub_48FF60(v11[0]) )\n          continue;\n        result = sub_4967A0(a1, v11[0], a3 | 1u);\n        if ( (int)result >= 0 )\n          continue;\n      }\n      goto LABEL_10;\n    }\n    result = 1LL;\nLABEL_10:\n    if ( v10 )\n    {\n      v9 = result;\n      sub_490D40(v10);\n      return v9;\n    }\n  }\n  return result;\n}\n",
    "function_name": "img_collect_inos",
    "decompiled_code": "int __fastcall img_collect_inos(__int64 a1, IsoDir *a2, int a3)\n{\n  IsoDir *v4; // rbp\n  void *v6; // rdi\n  int result; // eax\n  void *v8; // rax\n  int v9; // [rsp+Ch] [rbp-2Ch]\n  IsoDirIter *iter; // [rsp+10h] [rbp-28h] BYREF\n  IsoNode *node; // [rsp+18h] [rbp-20h] BYREF\n\n  v4 = a2;\n  iter = 0LL;\n  if ( a2 )\n  {\n    v6 = *(void **)(a1 + 5032);\n    if ( v6 )\n      goto LABEL_3;\nLABEL_14:\n    v8 = calloc(0x8000uLL, 1uLL);\n    *(_QWORD *)(a1 + 5032) = v8;\n    if ( !v8 )\n      return -265224198;\nLABEL_17:\n    node = &v4->node;\n    result = img_register_ino((IsoImage *)(a1 + 5032), (IsoNode *)(a1 + 5040), &v4->node);\n    if ( result < 0 )\n      return result;\n    goto LABEL_4;\n  }\n  v4 = *(IsoDir **)(a1 + 8);\n  v6 = *(void **)(a1 + 5032);\n  if ( !v6 )\n    goto LABEL_14;\nLABEL_3:\n  if ( (a3 & 1) == 0 )\n  {\n    memset(v6, 0, 0x8000uLL);\n    goto LABEL_17;\n  }\nLABEL_4:\n  result = iso_dir_get_children(v4, &iter);\n  if ( result >= 0 )\n  {\n    while ( iso_dir_iter_next(iter, &node) == 1 )\n    {\n      result = img_register_ino((IsoImage *)(a1 + 5032), (IsoNode *)(a1 + 5040), node);\n      if ( result >= 0 )\n      {\n        if ( iso_node_get_type(node) )\n          continue;\n        result = img_collect_inos(a1, (IsoDir *)node, a3 | 1);\n        if ( result >= 0 )\n          continue;\n      }\n      goto ex;\n    }\n    result = 1;\nex:\n    if ( iter )\n    {\n      v9 = result;\n      iso_dir_iter_free(iter);\n      return v9;\n    }\n  }\n  return result;\n}\n",
    "source_code": "int img_collect_inos(IsoImage *image, IsoDir *dir, int flag)\n{\n    int ret, register_dir = 1;\n    IsoDirIter *iter = NULL;\n    IsoNode *node;\n    IsoDir *subdir;\n\n    if (dir == NULL)\n        dir = image->root;\n    if (image->used_inodes == NULL) {\n        image->used_inodes = calloc(ISO_USED_INODE_RANGE / 8, 1);\n        if (image->used_inodes == NULL)\n            return ISO_OUT_OF_MEM;\n    } else if(!(flag & 1)) {\n        memset(image->used_inodes, 0, ISO_USED_INODE_RANGE / 8);\n    } else {\n        register_dir = 0;\n    }\n    if (register_dir) {\n        node = (IsoNode *) dir;\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            return ret;\n    }\n\n    ret = iso_dir_get_children(dir, &iter);\n    if (ret < 0)\n        return ret;\n    while (iso_dir_iter_next(iter, &node) == 1 ) {\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            goto ex;\n        if (iso_node_get_type(node) == LIBISO_DIR) {\n            subdir = (IsoDir *) node;\n            ret = img_collect_inos(image, subdir, flag | 1);\n            if (ret < 0)\n                goto ex;\n        }\n    }\n    ret = 1;\nex:;\n    if (iter != NULL)\n        iso_dir_iter_free(iter);\n    return ret;\n}",
    "comment": "Registers inodes for an ISO image and its subdirectories, initializing used inode tracking if necessary.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Sets the unique identifier for an ISO image , allocating memory for it and optionally updating it with the provided IsoNode .\n",
    "cpbcs_sum": "Recursively traverses ISO nodes based on LBA entries, devices, and symbolic them into a dynamically allocated result for further processing.\n",
    "misum_sum": "Updates the `IsoNode` pointers and volume time of an ISO image, managing memory and filesystem pointers based on the specified conditions.\n",
    "decom_sum": "Recursively processes and writes 32KB data blocks to a buffer, traversing child elements while skipping those flagged, and cleans up allocated resources.",
    "cfg_sum": "Allocates or clears a 32KB buffer, processes and recursively handles data entries, and releases resources while returning status codes on success or failure.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary makes multiple claims about returning the number of destinations, grouping nodes into destinations, and setting nodes and characters for each destination. None of these align with the source code, which instead registers inodes recursively in a directory tree and returns an integer status code without handling 'destinations' or character sets. All claims are inaccurate, resulting in no alignment.",
                "The summary's claims are entirely inaccurate relative to the source code. It describes functionality about destinations, setting nodes to dests_node[i], and characters accepted by destinations, none of which exist in the provided implementation. The source code collects and registers inodes recursively in directory structures, manages memory for used_inodes, and returns error codes or success status, but the summary does not mention these behaviors at all, resulting in a complete miss of the primary purpose.",
                "The summary contains multiple INACCURATE claims. It asserts the function returns the number of destinations or -1, whereas the code returns 1 on success or a negative error code on failure. It also describes grouping nodes into destinations and setting destination-specific node data and accepted characters, none of which are present in the source implementation. These are FATAL errors affecting the primary purpose and I/O behavior. There are no ACCURATE claims that match the actual logic of inode registration and directory traversal, resulting in high negative impact and no positive gain."
            ]
        },
        "bint5": {
            "summary": "Sets the unique identifier for an ISO image , allocating memory for it and optionally updating it with the provided IsoNode .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function sets a unique identifier for an ISO image, allocates memory for it, and optionally updates it with a provided IsoNode. In the source code, the function actually allocates memory for used inodes if needed, optionally resets it, registers directories and nodes, and recursively iterates through subdirectories, but it does not set a unique identifier or update with a provided IsoNode in the sense described. This indicates the claim is largely inaccurate and contradicts the source implementation.",
                "The summary misrepresents the primary purpose of the function, describing it as setting a unique identifier and updating it with a provided IsoNode. In reality, the code recursively collects and registers inode numbers for directories in an ISO image, allocates memory for the inode tracking array when necessary, and handles iteration over directory contents. The summary misses critical details such as recursion, directory iteration, conditional handling based on the flag, and error handling. It fails to capture any accurate claim aligned with the source code\u2019s semantics.",
                "The summary claims the function sets a unique identifier for an ISO image and optionally updates it with a provided IsoNode. In reality, the function collects and registers inode numbers from directories, allocates memory for the used_inodes bitmap, and recursively processes subdirectories. The described behavior in the summary is inaccurate and misrepresents the primary purpose and key I/O of the function, constituting a FATAL error."
            ]
        },
        "cpbcs": {
            "summary": "Recursively traverses ISO nodes based on LBA entries, devices, and symbolic them into a dynamically allocated result for further processing.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function operates based on LBA entries and devices, and symbolically represents them, which is not reflected in the source code. The code instead recursively traverses directory nodes, manages inode registration, and allocates memory for tracking used inodes. Since the summary's main assertions are inaccurate and do not match the actual implementation, none of its claims are accurate.",
                "The summary is inaccurate because it describes traversal based on LBA entries, devices, and symbolic links, none of which are present in the source code. The code actually recursively registers inode numbers for directories within an ISO image, manages memory allocation for the used_inodes array, and handles iteration over directory contents with error checking. The summary misses the primary purpose and all secondary details from the source implementation.",
                "The summary contains mostly inaccurate claims. It references LBA entries, devices, and symbolic processing, none of which are present in the source code. The function actually traverses ISO directory nodes recursively and registers inodes; no mention is made of LBA, devices, or symbolic links. These are FATAL inaccuracies since they misrepresent the primary purpose and core logic, leading to a misleading understanding. There are no accurate, specific claims that match the source code, resulting in high negative impact and zero positive gain."
            ]
        },
        "misum": {
            "summary": "Updates the `IsoNode` pointers and volume time of an ISO image, managing memory and filesystem pointers based on the specified conditions.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function updates IsoNode pointers and volume time, and manages memory and filesystem pointers based on conditions. The source code shows it initializes or resets the used_inodes bitmap, registers inodes, iterates directory children, and recurses into subdirectories. There is no handling of volume time, and although IsoNode pointers are processed, the described memory and filesystem pointer management is only partially aligned. Most claims are inaccurate or unsubstantiated by the source, with less than half being accurate.",
                "The summary claims the function updates IsoNode pointers and volume time, which is inaccurate because the source code does not manipulate volume time at all. The primary purpose, as shown in the source, is recursively collecting and registering inodes for directories in an ISO image, with memory allocation and optional resetting of the used_inodes array. The summary misses this primary purpose entirely and introduces unrelated behavior, resulting in no accurate coverage of the critical semantic units.",
                "The summary contains a major factual error: it claims the function updates `IsoNode` pointers and the volume time of an ISO image, but the source code does not manipulate volume time at all and does not perform generic pointer updates\u2014rather, it registers inode numbers for directory entries and manages a bitmap in `used_inodes`. This is a FATAL inaccuracy about the primary purpose, leading to unreliable guidance. No accurate, high-value specifics are present to offset the error."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 705888,
    "strip_function_name": "sub_AC560",
    "strip_decompiled_code": "__int64 __fastcall sub_AC560(__int64 a1, _BYTE *a2, __int64 a3)\n{\n  int v4; // edx\n  void *v5; // rax\n  __int64 v6; // rbp\n  __int64 v7; // rcx\n  int v8; // edx\n  __int64 v9; // rax\n  __int64 result; // rax\n  int v11; // edx\n\n  v4 = *(_DWORD *)(a1 + 72);\n  if ( v4 )\n  {\n    v6 = *(int *)(a1 + 76);\n    v5 = *(void **)(a1 + 104);\n    if ( v4 > (int)v6 + 1 )\n      goto LABEL_4;\n    v11 = 2 * v4;\n    *(_DWORD *)(a1 + 72) = v11;\n    v5 = xmlRealloc(v5, 16LL * v11);\n    if ( v5 )\n    {\n      *(_QWORD *)(a1 + 104) = v5;\n      goto LABEL_3;\n    }\n    sub_ABCB0(0LL, (__int64)\"pushing input string\");\n    result = (unsigned int)(*(_DWORD *)(a1 + 72) / 2);\n    *(_DWORD *)(a1 + 72) = result;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 72) = 4;\n    v5 = xmlMalloc(0x40uLL);\n    *(_QWORD *)(a1 + 104) = v5;\n    if ( v5 )\n    {\nLABEL_3:\n      v6 = *(int *)(a1 + 76);\nLABEL_4:\n      *((_QWORD *)v5 + 2 * v6) = xmlStrdup(a2);\n      v7 = *(_QWORD *)(a1 + 104);\n      v8 = *(_DWORD *)(a1 + 76);\n      v9 = 16LL * v8;\n      *(_QWORD *)(v7 + v9 + 8) = a3;\n      result = v7 + v9 + 16;\n      *(_DWORD *)(a1 + 76) = v8 + 1;\n      *(_QWORD *)result = 0LL;\n      *(_QWORD *)(result + 8) = 0LL;\n      return result;\n    }\n    result = sub_ABCB0(0LL, (__int64)\"pushing input string\");\n    *(_DWORD *)(a1 + 72) = 0;\n  }\n  return result;\n}\n",
    "function_name": "xmlFARegExecSaveInputString",
    "decompiled_code": "void __fastcall xmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value, void *data)\n{\n  int inputStackMax; // edx\n  xmlRegInputTokenPtr inputStack; // rax\n  __int64 inputStackNr; // rbp\n  xmlRegInputTokenPtr v7; // rcx\n  int v8; // edx\n  __int64 v9; // rax\n  xmlRegInputToken *v10; // rax\n  int v11; // edx\n\n  inputStackMax = exec->inputStackMax;\n  if ( inputStackMax )\n  {\n    inputStackNr = exec->inputStackNr;\n    inputStack = exec->inputStack;\n    if ( inputStackMax > (int)inputStackNr + 1 )\n      goto LABEL_4;\n    v11 = 2 * inputStackMax;\n    exec->inputStackMax = v11;\n    inputStack = (xmlRegInputTokenPtr)xmlRealloc(inputStack, 16LL * v11);\n    if ( inputStack )\n    {\n      exec->inputStack = inputStack;\n      goto LABEL_3;\n    }\n    xmlRegexpErrMemory(0LL, \"pushing input string\");\n    exec->inputStackMax /= 2;\n  }\n  else\n  {\n    exec->inputStackMax = 4;\n    inputStack = (xmlRegInputTokenPtr)xmlMalloc(0x40uLL);\n    exec->inputStack = inputStack;\n    if ( inputStack )\n    {\nLABEL_3:\n      inputStackNr = exec->inputStackNr;\nLABEL_4:\n      inputStack[inputStackNr].value = xmlStrdup__internal_alias(value);\n      v7 = exec->inputStack;\n      v8 = exec->inputStackNr;\n      v9 = v8;\n      v7[v9].data = data;\n      v10 = &v7[v9 + 1];\n      exec->inputStackNr = v8 + 1;\n      v10->value = 0LL;\n      v10->data = 0LL;\n      return;\n    }\n    xmlRegexpErrMemory(0LL, \"pushing input string\");\n    exec->inputStackMax = 0;\n  }\n}\n",
    "source_code": "\nstatic void\nxmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value,\n\t                    void *data) {\n#ifdef DEBUG_PUSH\n    printf(\"saving value: %d:%s\\n\", exec->inputStackNr, value);\n#endif\n    if (exec->inputStackMax == 0) {\n\texec->inputStackMax = 4;\n\texec->inputStack = (xmlRegInputTokenPtr)\n\t    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (exec->inputStack == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax = 0;\n\t    return;\n\t}\n    } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {\n\txmlRegInputTokenPtr tmp;\n\n\texec->inputStackMax *= 2;\n\ttmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,\n\t\t\texec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (tmp == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax /= 2;\n\t    return;\n\t}\n\texec->inputStack = tmp;\n    }\n    exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);\n    exec->inputStack[exec->inputStackNr].data = data;\n    exec->inputStackNr++;\n    exec->inputStack[exec->inputStackNr].value = NULL;\n    exec->inputStack[exec->inputStackNr].data = NULL;\n}",
    "comment": "Stores an input string and associated data in a dynamically expanding stack within the xmlRegExecCtxt structure.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Pushes a new step onto the parser context 's stack , reallocating memory if necessary , and initializes it with the provided name and namespace .\n",
    "cpbcs_sum": "Pushes a new xmlNode pointer onto the stack while managing memory allocation and incrementing the size of the regex atom list.\n",
    "misum_sum": "Pushes a new node onto the context's state, reallocating memory if necessary, and updates the current token accordingly.\n",
    "decom_sum": "Adds a duplicated XML string and associated metadata to a dynamically resized array within a parsing context.",
    "cfg_sum": "Adds a duplicated input string and associated data to a dynamically resized array, allocating or resizing memory as needed and handling allocation failures.",
    "work_score": {
        "hext5": {
            "summary": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary focuses on building and handling input files with language-specific symbol checks and avoiding duplicates, which does not align with the source code's functionality of saving input strings into a stack for regex execution. None of the claims correspond to the actual memory allocation, stack handling, or value duplication seen in the source. This results in no accurate claims.",
                "The summary describes building and managing input file nodes with considerations like symbol handling, duplicate avoidance, and linker prefixes, which are unrelated to the actual source code. The source code implements saving an input string into a stack within an XML regular expression execution context, handling dynamic allocation and memory errors. The primary purpose and secondary details in the source are entirely missed, and none of the claims align accurately with the implementation.",
                "The summary's claims refer to building and managing input files, symbol handling, and avoiding duplicate BFD objects, which are unrelated to the source code's actual function of saving an input string into a regex execution context's stack with possible memory allocation/reallocation. All claims are NOISE, with no accurate reflection of the code's primary purpose, I/O, or side effects. The worst failure mode is overwhelming NOISE, and there is no gain from accurate details."
            ]
        },
        "bint5": {
            "summary": "Pushes a new step onto the parser context 's stack , reallocating memory if necessary , and initializes it with the provided name and namespace .\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary describes pushing a step with a name and namespace, but the source code shows saving an input string and associated data to the stack, handling memory allocation and initialization with NULL values. The summary\u2019s mention of 'name and namespace' is inaccurate and not reflected in the code, resulting in a low proportion of accurate claims.",
                "The summary captures a general idea of pushing onto a context stack and handling memory allocation, which aligns with the primary purpose of the code. However, it inaccurately describes the stored data as 'name and namespace' instead of the actual string value and associated data pointer. This mismatch means it covers the main stack-pushing behavior but misses secondary details such as handling initial allocation vs. reallocation, debug logging, error handling on memory allocation failure, and setting terminating NULL entries.",
                "The summary introduces specific semantics not present in the source code, such as pushing a step with a 'name' and 'namespace'. The actual function saves an input string and associated data into the execution context\u2019s input stack, handling allocation and reallocation as needed. The mismatch is a FATAL error because it misstates the primary purpose and key I/O, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Pushes a new xmlNode pointer onto the stack while managing memory allocation and incrementing the size of the regex atom list.\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the code\u2019s behavior: it claims to push an xmlNode pointer to a stack and adjust a regex atom list, whereas the source code pushes an input string (xmlChar*) and associated data to an input token stack, with memory reallocation as needed. None of the claims match the actual implementation, resulting in no accurate claims.",
                "The summary incorrectly claims that the function pushes an xmlNode pointer and deals with a regex atom list, which does not match the source code\u2019s actual behavior. The function pushes an input string and associated data into an internal input stack, handling dynamic memory allocation and stack expansion, but there is no involvement with xmlNode or regex atom lists. This misidentification of primary purpose means the core semantics are missed.",
                "The summary incorrectly states that the function pushes an xmlNode pointer and increments a regex atom list. In reality, the code pushes an input token (value and data) onto an input stack, duplicating the string and managing dynamic memory for the stack. This is a FATAL error because it misidentifies both the primary purpose and key data structures, leading to a misleading understanding of the code's core behavior. No accurate claims are present, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Pushes a new node onto the context's state, reallocating memory if necessary, and updates the current token accordingly.\n",
            "score": [
                0.2,
                0.6,
                0.5
            ],
            "reason": [
                "The summary claims that the function pushes a new node onto the context's state and updates the current token, but the source code actually pushes an input token (value/data) onto an input stack, not a 'node' or an abstract context state. While it correctly notes memory reallocation when necessary, the description of what is pushed and updated is inaccurate, leading to fewer than half of the claims matching the source implementation with precision.",
                "The summary captures the primary purpose of saving a new token into the execution context and mentions memory reallocation if needed, which aligns with the source code's behavior of managing the input stack array. However, it omits important secondary details such as initial allocation when the stack is empty, handling of memory allocation failures via error reporting and early returns, duplication of the input string, setting associated data, incrementing the stack index, and appending a terminating NULL token. These omissions reduce completeness despite the primary purpose being correct.",
                "The summary makes a broad, somewhat inaccurate claim by describing the operation as 'pushing a new node onto the context's state' rather than accurately stating it saves an input string into the execution context's input stack. It omits specifics such as duplicating the string, handling memory allocation errors, and setting default NULL values for the next stack slot. While memory reallocation is mentioned, details about the actual data saved and its placement in the stack are missing, leading to low informational value. The worst failure mode is NOISE due to vague and misleading terminology rather than a direct contradiction of key I/O semantics."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 256800,
    "strip_function_name": "sub_3EB20",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_3EB20(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  unsigned __int64 result; // rax\n  int v6; // edx\n  _DWORD *v7; // rcx\n  _DWORD *v8; // rdx\n  __int64 v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rsi\n  __int64 v12; // rcx\n  int v13; // edx\n\n  v4 = sub_3EAC0(*(_QWORD *)a3);\n  result = sub_265E0(*(unsigned __int8 **)(a3 + 8));\n  v6 = *(_DWORD *)v4;\n  if ( *(_DWORD *)v4 )\n  {\n    if ( (int)result > 0 )\n    {\n      v7 = *(_DWORD **)(v4 + 24);\n      v8 = v7 + 1;\n      v9 = (__int64)&v7[(unsigned int)(result - 1) + 1];\n      while ( 1 )\n      {\n        ++*v7;\n        v7 = v8;\n        if ( v8 == (_DWORD *)v9 )\n          break;\n        ++v8;\n      }\n    }\n    if ( (int)result < *(_DWORD *)(v4 + 8) )\n    {\n      v10 = *(_QWORD *)(v4 + 32);\n      v11 = *(_QWORD *)(v4 + 24);\n      result = (int)result;\n      do\n      {\n        ++*(_DWORD *)(v10 + 4 * result);\n        *(_DWORD *)(v11 + 4 * result++) = 1;\n      }\n      while ( *(_DWORD *)(v4 + 8) > (int)result );\n    }\n  }\n  else\n  {\n    result = *(unsigned int *)(v4 + 8);\n    if ( (int)result <= 0 )\n      goto LABEL_10;\n    v12 = *(_QWORD *)(v4 + 24);\n    result = 1LL;\n    do\n    {\n      *(_DWORD *)(v12 + 4 * result - 4) = 1;\n      v13 = result++;\n    }\n    while ( *(_DWORD *)(v4 + 8) > v13 );\n  }\n  v6 = *(_DWORD *)v4;\nLABEL_10:\n  *(_DWORD *)v4 = v6 + 1;\n  return result;\n}\n",
    "function_name": "statPush",
    "decompiled_code": "void __fastcall statPush(sqlite3_context *context, int argc, sqlite3_value **argv)\n{\n  _QWORD *v4; // rbx\n  __int64 v5; // rax\n  int v6; // edx\n  _DWORD *v7; // rcx\n  _DWORD *v8; // rdx\n  __int64 v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rsi\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  int v14; // edx\n\n  v4 = sqlite3_value_blob(*argv);\n  LODWORD(v5) = sqlite3VdbeIntValue(argv[1]);\n  v6 = *(_DWORD *)v4;\n  if ( *(_DWORD *)v4 )\n  {\n    if ( (int)v5 > 0 )\n    {\n      v7 = (_DWORD *)v4[3];\n      v8 = v7 + 1;\n      v9 = (__int64)&v7[(unsigned int)(v5 - 1) + 1];\n      while ( 1 )\n      {\n        ++*v7;\n        v7 = v8;\n        if ( v8 == (_DWORD *)v9 )\n          break;\n        ++v8;\n      }\n    }\n    if ( (int)v5 < *((_DWORD *)v4 + 2) )\n    {\n      v10 = v4[4];\n      v11 = v4[3];\n      v5 = (int)v5;\n      do\n      {\n        ++*(_DWORD *)(v10 + 4 * v5);\n        *(_DWORD *)(v11 + 4 * v5++) = 1;\n      }\n      while ( *((_DWORD *)v4 + 2) > (int)v5 );\n    }\n  }\n  else\n  {\n    if ( *((int *)v4 + 2) <= 0 )\n      goto LABEL_10;\n    v12 = v4[3];\n    v13 = 1LL;\n    do\n    {\n      *(_DWORD *)(v12 + 4 * v13 - 4) = 1;\n      v14 = v13++;\n    }\n    while ( *((_DWORD *)v4 + 2) > v14 );\n  }\n  v6 = *(_DWORD *)v4;\nLABEL_10:\n  *(_DWORD *)v4 = v6 + 1;\n}\n",
    "source_code": "static void statPush(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i;\n\n  /* The three function arguments */\n  Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);\n  int iChng = sqlite3_value_int(argv[1]);\n\n  UNUSED_PARAMETER( argc );\n  UNUSED_PARAMETER( context );\n  assert( p->nCol>0 );\n  assert( iChng<p->nCol );\n\n  if( p->nRow==0 ){\n    /* This is the first call to this function. Do initialization. */\n    for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;\n  }else{\n    /* Second and subsequent calls get processed here */\n    samplePushPrevious(p, iChng);\n\n    /* Update anDLt[], anLt[] and anEq[] to reflect the values that apply\n    ** to the current row of the index. */\n    for(i=0; i<iChng; i++){\n      p->current.anEq[i]++;\n    }\n    for(i=iChng; i<p->nCol; i++){\n      p->current.anDLt[i]++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n      p->current.anLt[i] += p->current.anEq[i];\n#endif\n      p->current.anEq[i] = 1;\n    }\n  }\n  p->nRow++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n  if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){\n    sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));\n  }else{\n    sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),\n                                       sqlite3_value_blob(argv[2]));\n  }\n  p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;\n#endif\n\n#ifdef SQLITE_ENABLE_STAT4\n  {\n    tRowcnt nLt = p->current.anLt[p->nCol-1];\n\n    /* Check if this is to be a periodic sample. If so, add it. */\n    if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){\n      p->current.isPSample = 1;\n      p->current.iCol = 0;\n      sampleInsert(p, &p->current, p->nCol-1);\n      p->current.isPSample = 0;\n    }\n\n    /* Update the aBest[] array. */\n    for(i=0; i<(p->nCol-1); i++){\n      p->current.iCol = i;\n      if( i>=iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i]) ){\n        sampleCopy(p, &p->aBest[i], &p->current);\n      }\n    }\n  }\n#endif\n}",
    "comment": "Processes statistical data by updating counts and tracking samples based on input changes and row identifiers within a given dataset structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Converts an SQLite value to a JSON formatted string and returns it with a JSON subtype in the context .\n",
    "cpbcs_sum": "Converts an input string to a structured structure by assigning individual bits and handling back references as needed.\n",
    "misum_sum": "Inserts a new Lua stack into the Lua stack at the specified index and increments the stack count.\n",
    "decom_sum": "Updates indexed counters and flags in a data structure based on a computed position value, then increments the structure\u2019s primary operation counter.",
    "cfg_sum": "Updates internal counters and status arrays based on input indices, ensuring bounds checking, then increments a main counter before returning the final index.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains only a vague statement about pushing a pointer type, which does not accurately reflect the detailed operations in the source code such as initialization, updating arrays, handling periodic samples, or rowid processing. It lacks specificity and does not match the actual semantics, making it inaccurate and low-information.",
                "The summary is overly vague and does not capture the primary purpose of the function, which is to update statistical accumulators and handle sampling logic for index analysis based on provided arguments. It only mentions 'push a pointer type', which neither reflects the actual operations nor aligns with source code semantics, missing all critical details including initialization, updates to arrays, conditional sampling, and rowid handling.",
                "The summary contains a single vague claim that the function 'pushes a pointer type', which is overly broad and does not align with the actual semantics of the source code. The source performs complex initialization and updates on a Stat4Accum structure, including incrementing counters, invoking helper functions, and managing sampling logic. The claim is low\u2011info, potentially misleading if taken as the primary purpose, and provides no specific, accurate insight. This is predominantly NOISE with no GOLD details, resulting in low net benefit."
            ]
        },
        "bint5": {
            "summary": "Converts an SQLite value to a JSON formatted string and returns it with a JSON subtype in the context .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function converts an SQLite value to a JSON formatted string and returns it with a JSON subtype, but the source code shows it processes statistical accumulation in SQLite's ANALYZE feature, updating arrays and handling sampling logic. None of the described JSON operations appear in the source, making the claim entirely inaccurate.",
                "The summary is entirely inaccurate as it describes converting an SQLite value to a JSON string, which is unrelated to the source code. The function in the source code processes statistical accumulation for index sampling (Stat4Accum), updates counters, handles initial vs subsequent calls, and performs sampling logic, with no JSON formatting involved. This misses the primary purpose and all secondary details from the implementation.",
                "The summary claims the function converts an SQLite value to a JSON formatted string and returns it, which is entirely inaccurate. The source code shows that the function processes statistical sampling data within SQLite internals, updating counters and sample arrays, not performing any JSON conversion. This is a FATAL error as it misrepresents the primary purpose and output of the function, making the description highly misleading and unusable."
            ]
        },
        "cpbcs": {
            "summary": "Converts an input string to a structured structure by assigning individual bits and handling back references as needed.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claim about converting an input string to a structured structure with bit assignments and handling back references does not align with the source code, which processes statistical accumulations for SQLite index analysis, updates counters, and manages periodic samples. None of the described operations in the summary match the actual function's semantics, resulting in no accurate claims.",
                "The summary is entirely inaccurate: it describes converting an input string to a structured format with bit assignments and back references, which is unrelated to the source code\u2019s primary purpose of updating statistical accumulators for index analysis. It misses key details such as initialization on first call, updating arrays anEq, anDLt, and anLt, handling rowid setting, periodic sampling, and updating best samples. No CSU from the source is covered.",
                "The summary is entirely inaccurate (NOISE), describing conversion of a string to a structured object with bit assignments and back references, which has no relation to the actual code. The source function processes statistical accumulation data from sqlite3_value arguments, updates counters and samples for database indices, with no string parsing or bit manipulation. This mismatch means there is overwhelming NOISE and zero accurate claims, leading to low reliability."
            ]
        },
        "misum": {
            "summary": "Inserts a new Lua stack into the Lua stack at the specified index and increments the stack count.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims insertion of a new Lua stack at a specified index and incrementing a stack count, which is unrelated to the SQLite statPush function in the source code. The source handles initialization and updating of statistical arrays, sample insertion, and rowid manipulation, with no Lua-related functionality. All fact-based claims are inaccurate against the source context.",
                "The summary is entirely inaccurate, describing Lua stack manipulation, which is unrelated to the SQLite-specific statPush function in the source. It misses the primary purpose of updating statistical tracking structures (Stat4Accum) and handling sampling logic, row count increments, and conditional compilation branches. No claims from the summary align with any critical semantic units of the actual code.",
                "The summary claims the function inserts a new Lua stack at a specified index and increments the stack count, which is entirely unrelated to the source code. The source code operates on SQLite's Stat4Accum structure to update statistical counters and manage sampling, not Lua stacks. This is a FATAL error impacting the primary purpose and key operations of the function, providing no accurate insight and introducing complete misinformation."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582062956,
    "strip_function_name": "sub_FFFFFFFF8131196C",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8131196C(__int64 a1, __int16 a2, _BYTE *a3, unsigned __int8 a4)\n{\n  _BYTE *v5; // r15\n  unsigned int v6; // ebx\n  unsigned int i; // r12d\n  unsigned int v8; // r12d\n  char v9; // r15\n  int v10; // r8d\n  __int64 v11; // rdx\n  __int64 v12; // rsi\n  int v14; // [rsp+4h] [rbp-3Ch]\n  int v15; // [rsp+Ch] [rbp-34h] BYREF\n  _QWORD v16[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  if ( a2 == 10 )\n  {\n    v8 = 3;\n    if ( a4 != 1 )\n    {\n      v8 = 10;\n      if ( a4 != 4 )\n        v8 = 20;\n    }\n    v15 = 0;\n    v9 = 1;\n    v6 = 0;\n    do\n    {\n      v16[0] = a1;\n      v10 = 0;\n      do\n      {\n        v14 = v10;\n        sub_FFFFFFFF8132329F(v16[0], 10LL, v16, &v15);\n        v10 = v14 + 1;\n      }\n      while ( v14 + 1 < v8 );\n      if ( !v15 && v9 )\n      {\n        v9 = 1;\n      }\n      else\n      {\n        v11 = v6++;\n        a3[v11] = v15 + 48;\n        v9 = 0;\n      }\n      --v8;\n    }\n    while ( v8 );\n  }\n  else\n  {\n    if ( a2 != 16 )\n      return 0LL;\n    v5 = a3;\n    v6 = 2 * a4;\n    for ( i = v6 - 1; i != -1; --i )\n    {\n      v12 = 4 * i;\n      *v5++ = sub_FFFFFFFF813222E0(a1, v12);\n    }\n  }\n  if ( !v6 )\n  {\n    *a3 = 48;\n    v6 = 1;\n  }\n  a3[v6] = 0;\n  return v6;\n}\n",
    "function_name": "acpi_ex_convert_to_ascii",
    "decompiled_code": "__int64 __fastcall acpi_ex_convert_to_ascii(\n        unsigned __int64 a1,\n        __int16 a2,\n        char *a3,\n        unsigned __int8 a4,\n        __int64 a5,\n        int a6)\n{\n  char *v7; // r15\n  unsigned int v8; // ebx\n  unsigned int i; // r12d\n  unsigned int v10; // r12d\n  char v11; // r15\n  int v12; // r8d\n  __int64 v13; // rdx\n  char v14; // si\n  int v16; // [rsp+4h] [rbp-3Ch]\n  int v17; // [rsp+Ch] [rbp-34h] BYREF\n  unsigned __int64 v18[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  if ( a2 == 10 )\n  {\n    v10 = 3;\n    if ( a4 != 1 )\n    {\n      v10 = 10;\n      if ( a4 != 4 )\n        v10 = 20;\n    }\n    v17 = 0;\n    v11 = 1;\n    v8 = 0;\n    do\n    {\n      v18[0] = a1;\n      v12 = 0;\n      do\n      {\n        v16 = v12;\n        acpi_ut_short_divide(v18[0], 0xAu, v18, &v17, v12, a6);\n        v12 = v16 + 1;\n      }\n      while ( v16 + 1 < v10 );\n      if ( !v17 && v11 )\n      {\n        v11 = 1;\n      }\n      else\n      {\n        v13 = v8++;\n        a3[v13] = v17 + 48;\n        v11 = 0;\n      }\n      --v10;\n    }\n    while ( v10 );\n  }\n  else\n  {\n    if ( a2 != 16 )\n      return 0LL;\n    v7 = a3;\n    v8 = 2 * a4;\n    for ( i = v8 - 1; i != -1; --i )\n    {\n      v14 = 4 * i;\n      *v7++ = acpi_ut_hex_to_ascii_char(a1, v14);\n    }\n  }\n  if ( !v8 )\n  {\n    *a3 = 48;\n    v8 = 1;\n  }\n  a3[v8] = 0;\n  return v8;\n}\n",
    "source_code": "\nstatic u32\nacpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 data_width)\n{\n\tu64 digit;\n\tu32 i;\n\tu32 j;\n\tu32 k = 0;\n\tu32 hex_length;\n\tu32 decimal_length;\n\tu32 remainder;\n\tu8 supress_zeros;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tswitch (base) {\n\tcase 10:\n\n\t\t/* Setup max length for the decimal number */\n\n\t\tswitch (data_width) {\n\t\tcase 1:\n\t\t\tdecimal_length = ACPI_MAX8_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdecimal_length = ACPI_MAX32_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\tdefault:\n\t\t\tdecimal_length = ACPI_MAX64_DECIMAL_DIGITS;\n\t\t\tbreak;\n\t\t}\n\n\t\tsupress_zeros = TRUE;\t/* No leading zeros */\n\t\tremainder = 0;\n\n\t\tfor (i = decimal_length; i > 0; i--) {\n\n\t\t\t/* Divide by nth factor of 10 */\n\n\t\t\tdigit = integer;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t(void)acpi_ut_short_divide(digit, 10, &digit,\n\t\t\t\t\t\t\t   &remainder);\n\t\t\t}\n\n\t\t\t/* Handle leading zeros */\n\n\t\t\tif (remainder != 0) {\n\t\t\t\tsupress_zeros = FALSE;\n\t\t\t}\n\n\t\t\tif (!supress_zeros) {\n\t\t\t\tstring[k] = (u8) (ACPI_ASCII_ZERO + remainder);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 16:\n\n\t\t/* hex_length: 2 ascii hex chars per data byte */\n\n\t\thex_length = ACPI_MUL_2(data_width);\n\t\tfor (i = 0, j = (hex_length - 1); i < hex_length; i++, j--) {\n\n\t\t\t/* Get one hex digit, most significant digits first */\n\n\t\t\tstring[k] =\n\t\t\t    (u8) acpi_ut_hex_to_ascii_char(integer,\n\t\t\t\t\t\t\t   ACPI_MUL_4(j));\n\t\t\tk++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Since leading zeros are suppressed, we must check for the case where\n\t * the integer equals 0\n\t *\n\t * Finally, null terminate the string and return the length\n\t */\n\tif (!k) {\n\t\tstring[0] = ACPI_ASCII_ZERO;\n\t\tk = 1;\n\t}\n\n\tstring[k] = 0;\n\treturn ((u32) k);\n}",
    "comment": "Converts a given integer to its ASCII representation in either decimal or hexadecimal format based on specified parameters and returns the string length.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Converts an ACPI operand object to a buffer , handling integer and string types , while ensuring proper memory management and error checking .\n",
    "cpbcs_sum": "Converts single indirect data to a string representation of an embedded address, handling special cases for uninitialized and other environments.\n",
    "misum_sum": "Converts an AML buffer to an AML byte stream, extracting parameters like POSIX and node ID, and allocating memory for the data.\n",
    "decom_sum": "Converts numeric data from the source address into a null\u2011terminated decimal or hexadecimal string based on the specified format and output length.",
    "cfg_sum": "Converts device data for mode 10 or 16 into zero-padded ASCII representation, storing results in a buffer and returning the string length.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function returns a filled buffer or null if a character lacks a name and that it looks up a Unicode character\u2019s name in uppercase ASCII. The source code shows the function converts an integer to an ASCII string in base 10 or 16, handles leading zeros, and returns its length. There is no Unicode name lookup or conditional null return based on character names, so the claims are unrelated and inaccurate.",
                "The summary is entirely inaccurate, describing behavior about Unicode character name lookups and null returns when no name exists, which is unrelated to the source code's actual purpose of converting an integer to an ASCII string representation in decimal or hexadecimal format. It misses the primary purpose and all secondary implementation details from the source code.",
                "The summary is entirely inaccurate: it describes looking up the name of a Unicode character in uppercase ASCII and returning a buffer or null, which does not match the source code\u2019s actual behavior of converting an integer to an ASCII string in decimal or hexadecimal format with suppression of leading zeros. This is a FATAL error impacting the primary purpose and key I/O, leaving no accurate claims."
            ]
        },
        "bint5": {
            "summary": "Converts an ACPI operand object to a buffer , handling integer and string types , while ensuring proper memory management and error checking .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function converts an ACPI operand object to a buffer and handles integer and string types with memory management and error checking. In reality, the source code shows a function that converts an integer value to its ASCII representation in decimal or hexadecimal form, with no operand object handling, string type processing, or explicit memory management/error checking. All main claims contradict the implementation, resulting in a complete mismatch with the source.",
                "The summary is inaccurate because it describes converting an ACPI operand object with type handling, memory management, and error checking, none of which are present in the source code. The source function converts a numeric integer value to an ASCII string representation in either decimal or hex format, using specified data width, without any operand object handling or explicit memory allocation/error validation. It misses the primary purpose and all critical implementation details.",
                "The summary claims the function converts an ACPI operand object to a buffer, handles integer and string types, and ensures memory management and error checking. The source code, however, shows the function converts an integer to an ASCII string in either decimal or hexadecimal format, with no handling of operand objects, no string type conversion, and no explicit memory management or error checking beyond basic bounds and termination. This is a FATAL inaccuracy targeting the primary purpose of the code, making the description misleading and unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Converts single indirect data to a string representation of an embedded address, handling special cases for uninitialized and other environments.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function converts 'single indirect data' to a string representation of an 'embedded address' with handling for special cases like 'uninitialized and other environments'. These descriptions do not align with the source code, which actually converts numeric integers to ASCII strings (decimal or hexadecimal) based on base and data width, with suppression of leading zeros and null termination. None of the claims are accurate as they misinterpret the function's purpose and behavior.",
                "The summary incorrectly describes the function as converting indirect data to an embedded address string and handling uninitialized/environment-specific cases, which is not present in the source. The actual code converts numeric integers to ASCII strings in decimal or hexadecimal form, suppressing leading zeros, null-terminating, and handling zero values. This mismatch means the primary purpose and all secondary details from the source are missed.",
                "The summary claims the function converts 'single indirect data' to a string representation of an 'embedded address' and handles uninitialized/environmental cases, which does not match the source code's actual purpose of converting integers to ASCII strings in decimal or hexadecimal form, with leading zero suppression. This is a FATAL inaccuracy targeting the primary purpose, making the description misleading and unreliable."
            ]
        },
        "misum": {
            "summary": "Converts an AML buffer to an AML byte stream, extracting parameters like POSIX and node ID, and allocating memory for the data.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function converts an AML buffer to a byte stream, extracts POSIX and node ID parameters, and allocates memory. None of these operations are present in the source code. The actual code converts an integer to an ASCII string in decimal or hexadecimal form, suppressing leading zeros and handling null termination. All claims are inaccurate relative to the source, resulting in no accurate matches.",
                "The summary is completely inaccurate: the source code converts an integer to an ASCII string representation in decimal or hexadecimal format, handling data width and leading zeros, while the summary describes converting an AML buffer to a byte stream with unrelated parameters like POSIX and node ID. It misses the primary purpose and all secondary details from the actual implementation.",
                "The summary makes claims about converting an AML buffer to an AML byte stream, extracting POSIX and node ID, and allocating memory. None of these operations appear in the source code, which instead converts integers to ASCII in decimal or hexadecimal format. This is a complete and specific contradiction of the primary purpose, constituting a FATAL error regarding key I/O and functionality."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 332016,
    "strip_function_name": "sub_510F0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_510F0(__int64 *a1, __int64 a2, __int64 *a3)\n{\n  __int64 v5; // rdi\n  unsigned __int8 *v6; // r14\n  unsigned __int8 *v7; // rbp\n  __int64 v8; // r12\n  int v9; // r13d\n  unsigned int v10; // eax\n  unsigned __int8 *v11; // r15\n  __int64 *v13; // rax\n  __int64 v14; // r9\n  __int64 v15; // [rsp+8h] [rbp-60h]\n  __int64 v17; // [rsp+18h] [rbp-50h]\n  int v18; // [rsp+24h] [rbp-44h] BYREF\n  unsigned __int64 v19; // [rsp+28h] [rbp-40h]\n\n  v5 = *a3;\n  v19 = __readfsqword(0x28u);\n  v6 = (unsigned __int8 *)sub_3EA40(v5, 1);\n  v15 = sub_3EA40(a3[1], 1);\n  if ( v6 )\n  {\n    v7 = v6;\n    v8 = 0LL;\n    v9 = 3;\n    v17 = *(_QWORD *)(*a1 + 40);\n    if ( *v6 )\n    {\n      do\n      {\n        v10 = v8;\n        v11 = v7;\n        do\n        {\n          v11 += (int)v10;\n          v10 = sub_2AB80(v11, &v18);\n        }\n        while ( v18 == 162 );\n        if ( v18 == 122 || v18 == 107 )\n        {\n          v9 = 0;\n        }\n        else if ( ++v9 == 2 && (v18 == 74 || v18 == 137 || v18 == 5) )\n        {\n          v13 = sub_505E0(v17, \"%.*s\\\"%w\\\"%s\", v7 - v6, v6, v15, &v7[v8]);\n          sub_39D70(a1, v13, 0xFFFFFFFFLL, 1u, sub_17950, v14);\n          return __readfsqword(0x28u) ^ v19;\n        }\n        v7 = v11;\n        v8 = v10;\n      }\n      while ( *v11 );\n    }\n  }\n  return __readfsqword(0x28u) ^ v19;\n}\n",
    "function_name": "renameTriggerFunc",
    "decompiled_code": "void __fastcall renameTriggerFunc(sqlite3_context *context, int NotUsed, sqlite3_value **argv)\n{\n  sqlite3_value *v5; // rdi\n  const unsigned __int8 *v6; // r14\n  const unsigned __int8 *v7; // rbp\n  __int64 v8; // r12\n  int v9; // r13d\n  int v10; // eax\n  const unsigned __int8 *v11; // r15\n  char *v12; // rax\n  const void *v13; // [rsp+8h] [rbp-60h]\n  sqlite3 *db; // [rsp+18h] [rbp-50h]\n  int token; // [rsp+24h] [rbp-44h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v5 = *argv;\n  v17 = __readfsqword(0x28u);\n  v6 = (const unsigned __int8 *)sqlite3ValueText(v5, 1u);\n  v13 = sqlite3ValueText(argv[1], 1u);\n  if ( v6 )\n  {\n    v7 = v6;\n    v8 = 0LL;\n    v9 = 3;\n    db = context->pOut->db;\n    if ( *v6 )\n    {\n      do\n      {\n        v10 = v8;\n        v11 = v7;\n        do\n        {\n          v11 += v10;\n          v10 = sqlite3GetToken(v11, &token);\n        }\n        while ( token == 162 );\n        if ( token == 122 || token == 107 )\n        {\n          v9 = 0;\n        }\n        else if ( ++v9 == 2 && (token == 74 || token == 137 || token == 5) )\n        {\n          v12 = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", v7 - v6, v6, v13, &v7[v8]);\n          setResultStrOrError(context, v12, -1, 1u, (void (*)(void *))sqlite3MallocSize);\n          return;\n        }\n        v7 = v11;\n        v8 = (unsigned int)v10;\n      }\n      while ( *v11 );\n    }\n  }\n}\n",
    "source_code": "static void renameTriggerFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  int dist = 3;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TRIGGER \n  ** statement is that the table name is the first token that is immediately\n  ** preceded by either TK_ON or TK_DOT and immediately followed by one\n  ** of TK_WHEN, TK_BEGIN or TK_FOR.\n  */\n  if( zSql ){\n    do {\n\n      if( !*zCsr ){\n        /* Ran out of input before finding the table name. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      }while( token==TK_SPACE );\n      assert( len>0 );\n\n      /* Variable 'dist' stores the number of tokens read since the most\n      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN \n      ** token is read and 'dist' equals 2, the condition stated above\n      ** to be met.\n      **\n      ** Note that ON cannot be a database, table or column name, so\n      ** there is no need to worry about syntax like \n      ** \"CREATE TRIGGER ... ON ON.ON BEGIN ...\" etc.\n      */\n      dist++;\n      if( token==TK_DOT || token==TK_ON ){\n        dist = 0;\n      }\n    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );\n\n    /* Variable tname now contains the token that is the old table-name\n    ** in the CREATE TRIGGER statement.\n    */\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", (int)(((u8*)tname.z) - zSql),\n       zSql, zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}",
    "comment": "Replaces the old table name in a CREATE TRIGGER SQL statement with a new table name provided as an argument.",
    "hext5_sum": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
    "bint5_sum": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name , returning it as a string .\n",
    "cpbcs_sum": "Encodes a SQL CREATE TABLE into Base64 format and appends the result to a specified database file.\n",
    "misum_sum": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name, returning the result as a string.\n",
    "decom_sum": "Parses a byte stream, searching for specific code sequences, and triggers formatted message processing when target opcode patterns are detected.",
    "cfg_sum": "Parses and scans an input byte sequence for specific codes, formatting and dispatching a constructed message when predefined pattern and state conditions are met.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer to the recorded location. this function is used as the engine for ctf_type_visit, below. we resolve the input type, recursively invoke ourself for each type member if the type is a struct or union, and returns non-zero, we abort and percolate the error code back up to the top. then invoke the callback function on the current type. if any callback",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes functionality related to type resolution, recursion over struct/union members, and callback invocation, which bears no relation to the provided source code implementing logic to locate and replace a table name in a CREATE TRIGGER statement. All claims are unrelated and inaccurate with respect to the source implementation.",
                "The summary is entirely inaccurate, describing behavior related to type resolution, recursive visits, and callbacks for CTF structures, which has no relation to the actual source code. The function in the source code parses a CREATE TRIGGER SQL statement to locate and replace the table name, with specific token handling logic, none of which is mentioned in the summary. It fails to capture the primary purpose or any secondary details of the function.",
                "The summary's claims are entirely unrelated to the source code. It describes behavior about type resolution, recursion over struct/union members, and callback invocation for ctf_type_visit, which has no connection to the SQLite trigger renaming implementation provided. All extracted claims are NOISE, with no accurate or relevant mapping to the code's I/O, control flow, or primary purpose. The worst failure mode is overwhelming NOISE, leading to zero useful insight for understanding the actual function."
            ]
        },
        "bint5": {
            "summary": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name , returning it as a string .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function processes a SQL CREATE TABLE statement and replaces the first non-space token with a new table name. This is inaccurate because the source code specifically handles CREATE TRIGGER statements, locating the table name based on preceding TK_ON or TK_DOT tokens and following TK_WHEN, TK_FOR, or TK_BEGIN tokens. The 'first non-space token' detail does not match the token search logic in the implementation, and the statement about CREATE TABLE targets code semantics incorrectly. Most claims are inaccurate, resulting in low alignment.",
                "The summary is inaccurate because it describes extracting the first non-space token from a CREATE TABLE statement, whereas the source code processes a CREATE TRIGGER statement to locate the table name preceded by TK_ON or TK_DOT and followed by TK_WHEN, TK_FOR, or TK_BEGIN. It omits the primary purpose of identifying the old table name within trigger SQL and replacing it with a new name, and misses key secondary details such as token-based parsing logic, handling of NULL input, and how the output string is constructed.",
                "The summary incorrectly states that the function operates on a CREATE TABLE statement, while the source code clearly processes a CREATE TRIGGER SQL statement by locating the old table name based on specific token rules. This is a FATAL error impacting the primary purpose. Additionally, it oversimplifies the logic by describing only the extraction of the first non-space token, ignoring the token search criteria and context-dependent replacement. Minimal accurate detail is provided, making it unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Encodes a SQL CREATE TABLE into Base64 format and appends the result to a specified database file.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function encodes a SQL CREATE TABLE statement into Base64 and appends it to a database file, which is entirely inaccurate. The source code actually parses a CREATE TRIGGER SQL statement to find and replace the table name, then returns the modified SQL string via SQLite APIs. No Base64 encoding or file appending occurs, meaning 0% of the claims align with the implementation.",
                "The summary is entirely inaccurate, describing Base64 encoding of a CREATE TABLE statement and appending it to a database file, which is unrelated to the source code. The source function processes a CREATE TRIGGER SQL statement to replace the table name using token parsing and outputs the modified SQL, so the primary purpose is missed and none of the actual implementation details are captured.",
                "The summary claims the function encodes a SQL CREATE TABLE statement into Base64 and appends it to a database file, which is entirely unrelated to the actual implementation. The source code operates on a CREATE TRIGGER statement, locates the table name within it, and constructs a modified SQL string, with no Base64 encoding or file append operations. This is a FATAL error affecting the primary purpose, leading to a highly inaccurate and misleading description."
            ]
        },
        "misum": {
            "summary": "Extracts the first non-space token from a SQL CREATE TABLE statement and formats it with a new table name, returning the result as a string.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function processes a SQL CREATE TABLE statement, whereas the source code clearly operates on a CREATE TRIGGER statement. It also misrepresents the token extraction logic, which is based on finding the table name preceded by TK_ON or TK_DOT and followed by TK_WHEN, TK_BEGIN, or TK_FOR, not simply the first non-space token. These inaccuracies mean a low proportion of claims match the source implementation.",
                "The summary is inaccurate because it describes processing a CREATE TABLE statement and extracting the first non-space token, whereas the source code actually processes a CREATE TRIGGER statement, identifies the old table name based on specific token patterns (TK_ON/TK_DOT before and TK_WHEN/TK_FOR/TK_BEGIN after), and replaces it with a new table name. This misses the primary purpose entirely, and omits critical secondary details such as the token matching logic and handling of end-of-input cases.",
                "The summary contains a FATAL inaccuracy: it states the function processes a SQL CREATE TABLE statement, but the source clearly shows it operates on a CREATE TRIGGER statement. This contradicts the primary purpose of the code. Additionally, it incorrectly describes extracting the first non-space token, whereas the implementation locates a specific table name token based on preceding and following trigger keywords. These errors undermine reliability, despite the partially correct note about replacing the table name and returning a formatted string."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581578592,
    "strip_function_name": "sub_FFFFFFFF8129B560",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8129B560(__int64 a1, __int64 a2, __int64 a3)\n{\n  int v4; // eax\n  unsigned __int64 v5; // rbx\n  unsigned __int64 v6; // rax\n  __int64 v7; // rsi\n  unsigned __int64 v8; // rbx\n  __int64 v10; // r13\n  __int64 v11; // r12\n  __int64 v12; // rsi\n  __int64 v13; // rsi\n  unsigned int v14; // edx\n  __int64 result; // rax\n  unsigned int v16; // [rsp+10h] [rbp-40h] BYREF\n  int v17; // [rsp+14h] [rbp-3Ch] BYREF\n  __int64 v18; // [rsp+18h] [rbp-38h] BYREF\n  __int64 v19[6]; // [rsp+20h] [rbp-30h] BYREF\n\n  v4 = *(unsigned __int8 *)(a1 + 1404);\n  v5 = *(unsigned __int16 *)(a2 + 42);\n  v16 = 0;\n  v18 = 0LL;\n  v19[0] = 0LL;\n  v17 = v4;\n  v6 = *(unsigned __int16 *)(a2 + 40);\n  v7 = *(_QWORD *)(a2 + 88) + 16 * v5;\n  if ( v5 >= v6 )\n    return 0LL;\n  v8 = v5 + 1;\n  v10 = a2;\n  v11 = 16 * v8;\n  sub_FFFFFFFF8129B260(a1, v7, a3, &v18, v19, &v16, &v17);\n  while ( 1 )\n  {\n    v12 = v11;\n    v11 += 16LL;\n    v13 = *(_QWORD *)(v10 + 88) + v12;\n    if ( *(unsigned __int16 *)(v10 + 40) <= v8 )\n      break;\n    ++v8;\n    sub_FFFFFFFF8129B260(a1, v13, a3, &v18, v19, &v16, &v17);\n  }\n  if ( v19[0] )\n    *(_QWORD *)v19[0] = *(_QWORD *)v19[0] & 0xFFFFFFFFFFFFFFFCLL | 2;\n  v14 = *(_DWORD *)(v10 + 44);\n  result = v16;\n  if ( v14 )\n  {\n    if ( v14 < v16 )\n      BUG();\n  }\n  return result;\n}\n",
    "function_name": "blk_bio_map_sg",
    "decompiled_code": "__int64 __fastcall blk_bio_map_sg(__int64 a1, __int64 a2, __int64 a3)\n{\n  int v4; // eax\n  unsigned __int64 v5; // rbx\n  unsigned __int64 v6; // rax\n  __int64 v7; // rsi\n  unsigned __int64 v8; // rbx\n  __int64 v10; // r13\n  __int64 v11; // r12\n  __int64 v12; // rsi\n  __int64 v13; // rsi\n  unsigned int v14; // edx\n  __int64 result; // rax\n  unsigned int v16; // [rsp+10h] [rbp-40h] BYREF\n  int v17; // [rsp+14h] [rbp-3Ch] BYREF\n  __int64 v18; // [rsp+18h] [rbp-38h] BYREF\n  unsigned __int64 v19[6]; // [rsp+20h] [rbp-30h] BYREF\n\n  v4 = *(unsigned __int8 *)(a1 + 1404);\n  v5 = *(unsigned __int16 *)(a2 + 42);\n  v16 = 0;\n  v18 = 0LL;\n  v19[0] = 0LL;\n  v17 = v4;\n  v6 = *(unsigned __int16 *)(a2 + 40);\n  v7 = *(_QWORD *)(a2 + 88) + 16 * v5;\n  if ( v5 >= v6 )\n    return 0LL;\n  v8 = v5 + 1;\n  v10 = a2;\n  v11 = 16 * v8;\n  _blk_segment_map_sg(a1, v7, a3, &v18, v19, &v16, &v17);\n  while ( 1 )\n  {\n    v12 = v11;\n    v11 += 16LL;\n    v13 = *(_QWORD *)(v10 + 88) + v12;\n    if ( *(unsigned __int16 *)(v10 + 40) <= v8 )\n      break;\n    ++v8;\n    _blk_segment_map_sg(a1, v13, a3, &v18, v19, &v16, &v17);\n  }\n  if ( v19[0] )\n    *(_QWORD *)v19[0] = *(_QWORD *)v19[0] & 0xFFFFFFFFFFFFFFFCLL | 2;\n  v14 = *(_DWORD *)(v10 + 44);\n  result = v16;\n  if ( v14 )\n  {\n    if ( v14 < v16 )\n      BUG();\n  }\n  return result;\n}\n",
    "source_code": "int blk_bio_map_sg(struct request_queue *q, struct bio *bio,\n\t\t   struct scatterlist *sglist)\n{\n\tstruct bio_vec *bvec, *bvprv;\n\tstruct scatterlist *sg;\n\tint nsegs, cluster;\n\tunsigned long i;\n\n\tnsegs = 0;\n\tcluster = blk_queue_cluster(q);\n\n\tbvprv = NULL;\n\tsg = NULL;\n\tbio_for_each_segment(bvec, bio, i) {\n\t\t__blk_segment_map_sg(q, bvec, sglist, &bvprv, &sg,\n\t\t\t\t     &nsegs, &cluster);\n\t} /* segments in bio */\n\n\tif (sg)\n\t\tsg_mark_end(sg);\n\n\tBUG_ON(bio->bi_phys_segments && nsegs > bio->bi_phys_segments);\n\treturn nsegs;\n}",
    "comment": "Maps segments of a block I/O bio to a scatter-gather list, updating the number of segments and handling physical segment constraints.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Merges a bio into a request if the total sector count does not exceed the maximum allowed , updating segments and handling merge flags accordingly .\n",
    "cpbcs_sum": "Calculates and returns the number of free pages in a memory block for a given bio in a request structure.\n",
    "misum_sum": "Maps a bio into a scatter-gather table based on merging operator types and updates the position accordingly.\n",
    "decom_sum": "Processes consecutive 16-byte entries from a table, updates a status field, and validates the processed count against a stored limit.",
    "cfg_sum": "Processes sequential entries from a table, updates status flags, validates count against a limit, and triggers an error if the limit is exceeded.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about returning a filled buffer or null based on a Unicode character's name and looking up a name in uppercase ASCII have no relation to the source code, which processes block I/O segments using scatter-gather lists. All extracted claims are INACCURATE and do not target the actual code semantics.",
                "The summary describes returning a buffer with a Unicode character name in uppercase ASCII and handling null if no name exists. This is entirely unrelated to the source code, which processes a bio structure into a scatter-gather list, counts segments, and enforces constraints. The summary misses the primary purpose and all secondary details, and its claims are inaccurate with respect to the source code semantics.",
                "The summary claims the function returns a filled buffer or null based on a Unicode character name lookup in uppercase ASCII, which is completely unrelated to the source code. The actual code maps segments from a bio to a scatter-gather list, counts them, possibly marks the end, and returns the segment count. These are FATAL inaccuracies targeting the primary purpose and key I/O of the function, resulting in high negative impact."
            ]
        },
        "bint5": {
            "summary": "Merges a bio into a request if the total sector count does not exceed the maximum allowed , updating segments and handling merge flags accordingly .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function merges a bio into a request with sector count checks and merge flag handling, but the source code shows it maps bio segments into a scatterlist without merging requests or checking sector counts explicitly. None of the primary claims accurately reflect the implementation, resulting in a low accuracy proportion.",
                "The summary is inaccurate as it describes merging a bio into a request based on sector count limits and merge flags, which is not present in the source code. The actual function maps bio segments into a scatterlist, counts the segments, marks the end of the scatterlist, and checks against bio->bi_phys_segments. The primary purpose from the source is missed entirely, and no secondary details are correctly captured.",
                "The summary's main claim about merging a bio into a request based on sector count and handling merge flags is inaccurate, as the source code does not perform request-level merging or compare sector counts; instead, it maps bio segments to a scatterlist and tracks segment counts. This is a FATAL error impacting the primary purpose. No accurate claims are present to provide any meaningful insight, resulting in high negative impact and zero net benefit."
            ]
        },
        "cpbcs": {
            "summary": "Calculates and returns the number of free pages in a memory block for a given bio in a request structure.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's sole claim about calculating and returning the number of free pages in a memory block is inaccurate. The source code iterates over bio segments, maps them to a scatter-gather list, marks the end, and returns the number of segments, not free pages. This is a semantic contradiction, meaning none of the claims align with the actual implementation.",
                "The summary incorrectly states that the function calculates the number of free pages in a memory block for a given bio, which contradicts the source code. The actual function maps segments from a bio to a scatter-gather list, counts the segments, marks the end of the scatterlist, checks for consistency with bio->bi_phys_segments, and returns the number of segments. The primary purpose and key secondary details are completely missed, leading to no accurate claim coverage.",
                "The summary makes a specific factual claim about calculating and returning the number of free pages in a memory block, which contradicts the source code. The actual function maps bio segments to a scatterlist, counts segments, and returns that count, with no mention of free pages or memory blocks. This is a FATAL error impacting the primary purpose and key output of the function."
            ]
        },
        "misum": {
            "summary": "Maps a bio into a scatter-gather table based on merging operator types and updates the position accordingly.\n",
            "score": [
                0.1,
                0.5,
                0.5
            ],
            "reason": [
                "The summary claims the mapping is based on merging operator types and that it updates the position accordingly, but the source code does not reference merging operator types or explicit position updates. The code maps a bio into a scatterlist by iterating over segments, using blk_queue_cluster for clustering and marking the end, returning the number of segments. None of the specific claims match the source semantics, resulting in no accurate claims.",
                "The summary captures the general idea of mapping a bio into a scatter-gather table, which aligns with the PRIMARY PURPOSE of the function. However, it introduces an unsupported detail about 'merging operator types' that is not present in the source code, making this portion inaccurate. It also omits important secondary details such as use of blk_queue_cluster, looping over bio segments, marking the end scatterlist entry, and the BUG_ON safety check. This results in incomplete coverage of secondary behaviors.",
                "The summary claim that the function maps a bio into a scatter-gather table is broadly accurate, but the mention of 'based on merging operator types' is unsupported and misleading, as the source code uses clustering logic via blk_queue_cluster and a helper function rather than any operator type concept. There is no detail about the key loop over bio segments, the sg_mark_end call, or the return value, resulting in low informational gain. The worst failure mode is NOISE from the incorrect 'merging operator types' reference, and while not fatal, it reduces reliability significantly."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4204144,
    "strip_function_name": "sub_402670",
    "strip_decompiled_code": "int __fastcall sub_402670(unsigned int sig)\n{\n  unsigned int v1; // ebx\n  __pid_t v2; // ebp\n  double v3; // xmm0_8\n  int result; // eax\n  int *v5; // rbp\n  int v6; // r12d\n  bool v7; // zf\n  __int64 v8; // rbp\n  char *v9; // rax\n  double v10; // [rsp+8h] [rbp-40h]\n  _BYTE v11[56]; // [rsp+10h] [rbp-38h] BYREF\n\n  v1 = sig;\n  if ( sig == 14 )\n  {\n    v1 = signo;\n    dword_60A534 = 1;\n  }\n  v2 = pid;\n  if ( !pid )\n    _exit(v1 + 128);\n  v3 = *(double *)&qword_60A528;\n  if ( *(double *)&qword_60A528 == 0.0 )\n  {\n    if ( !byte_60A520 )\n      goto LABEL_6;\n    goto LABEL_9;\n  }\n  v10 = *(double *)&qword_60A528;\n  v3 = *(double *)&qword_60A528;\n  v5 = __errno_location();\n  v6 = *v5;\n  signo = 9;\n  sub_4024F0(0, v10);\n  v7 = byte_60A520 == 0;\n  qword_60A528 = 0LL;\n  *v5 = v6;\n  if ( !v7 )\n  {\nLABEL_9:\n    if ( (unsigned int)sub_406510(v1, v11, v3) )\n      __snprintf_chk();\n    v8 = sub_404C70(qword_60A518);\n    v9 = dcgettext(0LL, \"sending signal %s to command %s\", 5);\n    error(0, 0, v9, v11, v8);\n  }\n  v2 = pid;\n  if ( !pid )\n    signal(v1, (__sighandler_t)1);\nLABEL_6:\n  result = kill(v2, v1);\n  if ( !byte_60A522 )\n  {\n    signal(v1, (__sighandler_t)1);\n    result = kill(0, v1);\n    if ( v1 != 9 && v1 != 18 )\n    {\n      if ( !v2 )\n        signal(18, (__sighandler_t)1);\n      kill(v2, 18);\n      signal(18, (__sighandler_t)1);\n      return kill(0, 18);\n    }\n  }\n  return result;\n}\n",
    "function_name": "cleanup",
    "decompiled_code": "void __fastcall cleanup(unsigned int a1, double a2, double a3)\n{\n  unsigned int v3; // ebx\n  __pid_t v4; // ebp\n  double v5; // xmm0_8\n  int *v6; // rbp\n  int v7; // r12d\n  bool v8; // zf\n  char *v9; // rsi\n  char *v10; // rbp\n  char *v11; // rax\n  double v12; // [rsp+8h] [rbp-40h]\n  char signame[56]; // [rsp+10h] [rbp-38h] BYREF\n\n  v3 = a1;\n  if ( a1 == 14 )\n  {\n    v3 = term_signal;\n    timed_out = 1;\n  }\n  v4 = monitored_pid;\n  if ( !monitored_pid )\n    _exit(v3 + 128);\n  v5 = kill_after;\n  if ( kill_after == 0.0 )\n  {\n    if ( !verbose )\n      goto LABEL_6;\n    goto LABEL_9;\n  }\n  v12 = kill_after;\n  v5 = kill_after;\n  v6 = __errno_location();\n  v7 = *v6;\n  term_signal = 9;\n  settimeout(v12, a3, 0);\n  v8 = !verbose;\n  kill_after = 0.0;\n  *v6 = v7;\n  if ( !v8 )\n  {\nLABEL_9:\n    v9 = signame;\n    if ( (unsigned int)sig2str((char *)v3, signame) )\n    {\n      v9 = (char *)19;\n      __snprintf_chk();\n    }\n    v10 = quote(command, v9);\n    v11 = dcgettext(0LL, &msgid[351], 5);\n    error(0, 0, v11, signame, v10, v5, a3);\n  }\n  v4 = monitored_pid;\n  if ( !monitored_pid )\n    signal(v3, (__sighandler_t)1);\nLABEL_6:\n  kill(v4, v3);\n  if ( !foreground )\n  {\n    signal(v3, (__sighandler_t)1);\n    kill(0, v3);\n    if ( v3 != 9 && v3 != 18 )\n    {\n      if ( !v4 )\n        signal(18, (__sighandler_t)1);\n      kill(v4, 18);\n      signal(18, (__sighandler_t)1);\n      kill(0, 18);\n    }\n  }\n}\n",
    "source_code": "\nstatic void\ncleanup (void)\n{\n  if (close (STDIN_FILENO) < 0)\n    die (EXIT_FAILURE, errno, _(\"closing input file %s\"), quoteaf (input_file));\n\n  /* Don't remove this call to close, even though close_stdout\n     closes standard output.  This close is necessary when cleanup\n     is called as part of a signal handler.  */\n  if (close (STDOUT_FILENO) < 0)\n    die (EXIT_FAILURE, errno,\n         _(\"closing output file %s\"), quoteaf (output_file));\n}",
    "comment": "Cleans up temporary nodes by unlinking their associated names and resets the temporary head pointer to NULL.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Handles SIGINT or SIGTERM signals by executing corresponding actions , adjusting exit codes , and managing process states based on signal actions .\n",
    "cpbcs_sum": "The function handles termination signals in a child process by forking, managing signals and executing a specified termination signal.\n",
    "misum_sum": "Handles signals by writing the appropriate output to a child process based on the specified exit code, while managing interrupts and process group ID.\n",
    "decom_sum": "Sends specified signals to a process or command, logs the action, and handles special cases for termination and continue signals.",
    "cfg_sum": "Handles process signaling by sending specified or overridden signals to a target PID, with logging, error handling, and optional retries based on global flags.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary consists of a vague and unrelated statement that does not address any fact-based details from the source code. It neither matches nor describes the cleanup function, file descriptor handling, nor error reporting in the provided implementation, resulting in no accurate claims.",
                "The summary 'push a pointer type' is completely unrelated to the source code, which defines a cleanup function closing standard input/output and handling errors. It misses the primary purpose, provides no accurate claims, and contains no coverage of secondary details such as error handling or rationale comments.",
                "The summary 'push a pointer type.' does not relate to the source code, which is a cleanup function closing standard input and output and handling errors. This is pure NOISE with no fact-based alignment, offering no insight or value about the actual implementation. The worst failure mode is overwhelming NOISE, with no accurate claims present."
            ]
        },
        "bint5": {
            "summary": "Handles SIGINT or SIGTERM signals by executing corresponding actions , adjusting exit codes , and managing process states based on signal actions .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes handling SIGINT or SIGTERM signals, adjusting exit codes, and managing process states, which are not present in the source code. The source code only defines a cleanup function that closes standard input and output files and handles errors, without any signal handling logic. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary incorrectly describes signal handling, exit code adjustments, and process state management, none of which are present in the source code. The function strictly closes standard input and output file descriptors and reports errors with `die()`. The PRIMARY PURPOSE of performing cleanup by closing file descriptors is completely missed, resulting in no alignment with the source implementation.",
                "The summary claims the function handles SIGINT or SIGTERM, adjusts exit codes, and manages process states based on signal actions, but the source code only shows a cleanup function that closes stdin and stdout and calls error handling on failure. These are unrelated to signal handling, making the claims inaccurate. This is a FATAL error because it misrepresents the primary purpose of the function."
            ]
        },
        "cpbcs": {
            "summary": "The function handles termination signals in a child process by forking, managing signals and executing a specified termination signal.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function handles termination signals in a child process by forking, managing signals, and executing a specified termination signal. None of these details align with the source code, which simply closes standard input and output and reports errors if these operations fail. The summary targets code semantics but contradicts them completely, resulting in no accurate claims.",
                "The summary claims the function handles termination signals, forks, and manages signals in a child process, which does not match the source code. The source code shows a cleanup function that closes stdin and stdout, and reports errors via die(). None of the summary's claims align with the primary purpose or observable behavior, so coverage is absent.",
                "The summary claims that the function deals with termination signals in a child process, involving forking and signal management. This is completely inaccurate, as the source code shows a static cleanup function that closes stdin and stdout, handling potential errors, without any signal handling or process forking logic. This is a FATAL error affecting the primary purpose description, resulting in high negative impact and no accurate claims."
            ]
        },
        "misum": {
            "summary": "Handles signals by writing the appropriate output to a child process based on the specified exit code, while managing interrupts and process group ID.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about handling signals, writing output to a child process, managing interrupts, and process group ID do not match the source code, which only closes standard input and output and handles errors via 'die'. None of the claims accurately reflect the code's functionality, resulting in no alignment with the source implementation.",
                "The summary's claims about handling signals, writing output to a child process, managing interrupts, and process group IDs are not reflected in the source code. The actual code solely closes STDIN and STDOUT, with error handling through the die function, particularly for signal handler scenarios. None of the summary's claims accurately describe the primary purpose or secondary details present in the source, leading to no coverage.",
                "The summary contains only inaccurate claims. It incorrectly describes signal handling, writing output to a child process, managing interrupts, and process group ID, none of which are present in the source code. The actual code simply closes STDIN and STDOUT and reports errors, with a note about use in a signal handler, but no child process communication or process group logic. This represents a FATAL error affecting the primary purpose and semantics, leading to high negative impact and zero alignment with the source."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579215456,
    "strip_function_name": "sub_FFFFFFFF8105A660",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8105A660(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r13\n  int v11; // r15d\n  volatile signed __int32 *v12; // rcx\n  volatile signed __int32 *v13; // rdx\n  __int64 v14; // rsi\n  signed int v15; // eax\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  int v20; // ebx\n  int v21; // eax\n\n  v9 = sub_FFFFFFFF81104FD0(32LL, 8LL);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = -1;\n  sub_FFFFFFFF8103F360(32LL);\n  while ( 1 )\n  {\n    v15 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E00, 64LL, v11 + 1);\n    v11 = v15;\n    if ( v15 >= dword_FFFFFFFF81CB7EA8 )\n      break;\n    v12 = (volatile signed __int32 *)(qword_FFFFFFFF81CB6720[v15] + v10);\n    *(_QWORD *)v12 = 0xFFFFFFFE0LL;\n    v13 = v12;\n    v14 = qword_FFFFFFFF81CB6E38;\n    v12 += 2;\n    *((_QWORD *)v13 + 3) = a1;\n    *((_QWORD *)v13 + 1) = v12;\n    *((_QWORD *)v13 + 2) = v12;\n    sub_FFFFFFFF81058570(v15, v14, v13, a2, a3, a4, a5, v18, v19, a8, a9, (__int64)v12, v16, v17);\n  }\n  v20 = -1;\n  while ( 1 )\n  {\n    v21 = sub_FFFFFFFF812BE5D0(&qword_FFFFFFFF81CB6E00, 64LL, v20 + 1);\n    v20 = v21;\n    if ( v21 >= dword_FFFFFFFF81CB7EA8 )\n      break;\n    sub_FFFFFFFF81058D70((unsigned __int64 *)(qword_FFFFFFFF81CB6720[v21] + v10));\n  }\n  sub_FFFFFFFF8103F3A0();\n  sub_FFFFFFFF811040F0(v10);\n  return 0LL;\n}\n",
    "function_name": "schedule_on_each_cpu",
    "decompiled_code": "__int64 __fastcall schedule_on_each_cpu(\n        unsigned __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r13\n  int v11; // r15d\n  unsigned __int64 *v12; // rcx\n  unsigned __int64 *v13; // rdx\n  __int64 v14; // rsi\n  signed int next_bit; // eax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // ebx\n  int v19; // eax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v9 = _alloc_percpu(0x20uLL, 8uLL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = -1;\n  get_online_cpus(32LL, 8LL);\n  while ( 1 )\n  {\n    next_bit = find_next_bit((__int64)cpu_online_mask[0], 0x40uLL, v11 + 1);\n    v11 = next_bit;\n    if ( next_bit >= nr_cpu_ids )\n      break;\n    v12 = (unsigned __int64 *)(_per_cpu_offset[next_bit] + v10);\n    *v12 = 0xFFFFFFFE0LL;\n    v13 = v12;\n    v14 = system_wq;\n    ++v12;\n    v13[3] = a1;\n    v13[1] = (unsigned __int64)v12;\n    v13[2] = (unsigned __int64)v12;\n    queue_work_on(next_bit, v14, v13, a2, a3, a4, a5, v16, v17, a8, a9);\n  }\n  v18 = -1;\n  while ( 1 )\n  {\n    v19 = find_next_bit((__int64)cpu_online_mask[0], 0x40uLL, v18 + 1);\n    v18 = v19;\n    if ( v19 >= nr_cpu_ids )\n      break;\n    flush_work((unsigned __int64 *)(_per_cpu_offset[v19] + v10), 64LL, a2, a3, a4, a5, v20, v21, a8, a9);\n  }\n  put_online_cpus(a2, a3, a4, a5, v20, v21, a8, a9);\n  free_percpu(v10, a2, a3, a4, a5, v22, v23, a8, a9);\n  return 0LL;\n}\n",
    "source_code": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
    "comment": "Schedules a specified work function on each online CPU and waits for their completion before freeing allocated resources.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Allocates and initializes a workqueue by finding a free workqueue associated with the given PID namespace .\n",
    "cpbcs_sum": "Adds a work item to a scheduling domain list and notifies the work queue if it exceeds a maximum of CPU stop reason.\n",
    "misum_sum": "Resizes the scheduling work count and schedules an work item to handle CPU in the system.\n",
    "decom_sum": "Initializes and configures 64 indexed structures with provided parameters, processes them, then cleans up allocated resources and finalizes the operation.",
    "cfg_sum": "Initializes per-index structures with provided parameters, processes each entry, then iterates again to release resources before returning success or allocation error.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains a vague and unrelated phrase that does not reflect any fact-based claim about the source code\u2019s logic, parameters, or operations. It does not align with function semantics such as CPU iteration, work scheduling, or memory management. As it fails to provide accurate or relevant claims, none are marked ACCURATE.",
                "The summary 'push a pointer type.' does not capture the primary purpose of the function, which schedules and executes a work function on each online CPU, handling allocation, scheduling, flushing, and cleanup. It is entirely unrelated to the source code's semantics and provides no accurate atomic claims, resulting in no coverage.",
                "The summary contains a single vague statement that does not match or describe the source code\u2019s actual functionality. It introduces NOISE and fails to address the primary purpose, key inputs/outputs, or side effects of scheduling work on each CPU. No accurate claims are present, resulting in no useful insight."
            ]
        },
        "bint5": {
            "summary": "Allocates and initializes a workqueue by finding a free workqueue associated with the given PID namespace .\n",
            "score": [
                0.1,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function allocates and initializes a workqueue associated with a given PID namespace, but the source code shows it allocates per-CPU work_struct objects and schedules work on each CPU without any PID namespace involvement. This is a semantic mismatch, making the claim inaccurate and not aligned with the actual implementation.",
                "The summary incorrectly describes the function as allocating and initializing a workqueue tied to a PID namespace, which is not reflected in the source code. The actual implementation allocates per-CPU work_structs, initializes them with a given function, schedules work on each online CPU, flushes them, and frees resources. The primary purpose and critical steps from the source are missed, and the given claim is both inaccurate and unrelated to the actual CPU-based scheduling logic.",
                "The summary\u2019s claim that the function allocates and initializes a workqueue associated with a PID namespace is inaccurate, as the source code allocates per-CPU work structures and schedules a work function on each online CPU without any PID namespace involvement. This is a FATAL error targeting the primary purpose of the code since it misidentifies the core functionality, leading to unreliable understanding."
            ]
        },
        "cpbcs": {
            "summary": "Adds a work item to a scheduling domain list and notifies the work queue if it exceeds a maximum of CPU stop reason.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim that the function adds a work item to a scheduling domain list and notifies the work queue based on exceeding a maximum CPU stop reason is inaccurate. The source code shows that it allocates per-CPU work structures, schedules them on each online CPU, flushes them, and frees the structures; there is no mention of a scheduling domain list, CPU stop reason thresholds, or notification logic tied to such a condition. All claims fail to match the implementation.",
                "The summary describes adding a work item to a scheduling domain list and notifying a work queue based on a maximum CPU stop reason, which does not match the source code's primary purpose of scheduling a given function to run and flushing work on each online CPU. It misses core behaviors such as allocating per-CPU work structures, iterating over online CPUs, initializing work, scheduling it on each CPU, flushing, and freeing resources. Since the claims are inaccurate, there is no coverage of the primary purpose or secondary details.",
                "The summary makes a specific claim about adding a work item to a scheduling domain list and notifying the work queue based on a 'maximum of CPU stop reason', which is not present in the source code. The actual function allocates per-CPU work structures, initializes them with a given function, schedules them on each online CPU, flushes them, and cleans up. The described behavior contradicts the implementation, targeting core semantics inaccurately (FATAL) and omitting the actual steps and purpose. This severe misrepresentation undermines reliability."
            ]
        },
        "misum": {
            "summary": "Resizes the scheduling work count and schedules an work item to handle CPU in the system.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as resizing the scheduling work count, which is not present in the source code. The actual code allocates per-CPU work structures, schedules a work item on each CPU, flushes them, and then frees resources. Only the mention of scheduling a work item for CPU handling is loosely accurate, resulting in less than half of the claims being correct.",
                "The summary incorrectly describes the function as resizing a scheduling work count, which is not present in the source code. The actual primary purpose is to schedule and execute a given work function on each online CPU, including allocating per-CPU work structures, scheduling work, flushing it, and freeing structures. While the summary vaguely mentions scheduling a work item for CPUs, it omits critical details such as allocation, iteration over online CPUs, work initialization, flushing, and cleanup, and introduces inaccurate resizing behavior.",
                "The summary claims the function 'resizes the scheduling work count,' which is inaccurate and not supported by the source code, as the function does not perform any resizing operation. It also states that it schedules a work item to handle CPU, which is overly vague and partially accurate, as the code schedules work on each online CPU with provided functions. The presence of the incorrect resizing claim is a FATAL error targeting the primary purpose, leading to high negative impact and unreliable summary."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580409840,
    "strip_function_name": "sub_FFFFFFFF8117DFF0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8117DFF0(_DWORD *a1, __int64 a2)\n{\n  __int64 v2; // r11\n  __int64 v3; // r10\n  __int64 v4; // r9\n  __int64 v5; // rbx\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // rdx\n  __int64 result; // rax\n\n  v2 = *(_QWORD *)(a2 + 16);\n  v3 = *(_QWORD *)(a2 + 24);\n  v4 = *(_QWORD *)(a2 + 32);\n  v5 = *(_QWORD *)(a2 + 8);\n  v6 = *(_QWORD *)(a2 + 72);\n  if ( ((v6 | v5 | v4 | v3 | v2) & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v7 = *(_QWORD *)(a2 + 40);\n  if ( v7 != -1 && (v7 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v8 = *(_QWORD *)(a2 + 48);\n  if ( v8 != -1 && (v8 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  if ( (__PAIR128__(-(__int64)__CFADD__(a1, 64LL), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n      - (unsigned __int64)(a1 + 16)) >> 64 )\n    return 4294967282LL;\n  *a1 = *(_QWORD *)a2;\n  a1[1] = v5;\n  a1[2] = v2;\n  a1[3] = v3;\n  a1[4] = v4;\n  a1[5] = v7;\n  a1[6] = v8;\n  a1[9] = *(_QWORD *)(a2 + 64);\n  a1[7] = *(_DWORD *)(a2 + 56);\n  a1[8] = *(_DWORD *)(a2 + 60);\n  a1[10] = v6;\n  a1[11] = *(_QWORD *)(a2 + 80);\n  v9 = sub_FFFFFFFF812BA550(a1 + 12, 16LL);\n  result = 0LL;\n  if ( v9 )\n    return 4294967282LL;\n  return result;\n}\n",
    "function_name": "put_compat_statfs",
    "decompiled_code": "__int64 __fastcall put_compat_statfs(_DWORD *a1, __int64 a2)\n{\n  __int64 v2; // r11\n  __int64 v3; // r10\n  __int64 v4; // r9\n  __int64 v5; // rbx\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // rdx\n  __int64 result; // rax\n\n  v2 = *(_QWORD *)(a2 + 16);\n  v3 = *(_QWORD *)(a2 + 24);\n  v4 = *(_QWORD *)(a2 + 32);\n  v5 = *(_QWORD *)(a2 + 8);\n  v6 = *(_QWORD *)(a2 + 72);\n  if ( ((v6 | v5 | v4 | v3 | v2) & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v7 = *(_QWORD *)(a2 + 40);\n  if ( v7 != -1 && (v7 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  v8 = *(_QWORD *)(a2 + 48);\n  if ( v8 != -1 && (v8 & 0xFFFFFFFF00000000LL) != 0 )\n    return 4294967221LL;\n  if ( (__PAIR128__(-(__int64)__CFADD__(a1, 64LL), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n      - (unsigned __int64)(a1 + 16)) >> 64 )\n    return 4294967282LL;\n  *a1 = *(_QWORD *)a2;\n  a1[1] = v5;\n  a1[2] = v2;\n  a1[3] = v3;\n  a1[4] = v4;\n  a1[5] = v7;\n  a1[6] = v8;\n  a1[9] = *(_QWORD *)(a2 + 64);\n  a1[7] = *(_DWORD *)(a2 + 56);\n  a1[8] = *(_DWORD *)(a2 + 60);\n  a1[10] = v6;\n  a1[11] = *(_QWORD *)(a2 + 80);\n  v9 = _clear_user((_QWORD *)a1 + 6, 0x10uLL);\n  result = 0LL;\n  if ( v9 )\n    return 4294967282LL;\n  return result;\n}\n",
    "source_code": "\nstatic int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\t\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tif (!access_ok(VERIFY_WRITE, ubuf, sizeof(*ubuf)) ||\n\t    __put_user(kbuf->f_type, &ubuf->f_type) ||\n\t    __put_user(kbuf->f_bsize, &ubuf->f_bsize) ||\n\t    __put_user(kbuf->f_blocks, &ubuf->f_blocks) ||\n\t    __put_user(kbuf->f_bfree, &ubuf->f_bfree) ||\n\t    __put_user(kbuf->f_bavail, &ubuf->f_bavail) ||\n\t    __put_user(kbuf->f_files, &ubuf->f_files) ||\n\t    __put_user(kbuf->f_ffree, &ubuf->f_ffree) ||\n\t    __put_user(kbuf->f_namelen, &ubuf->f_namelen) ||\n\t    __put_user(kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) ||\n\t    __put_user(kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]) ||\n\t    __put_user(kbuf->f_frsize, &ubuf->f_frsize) ||\n\t    __put_user(kbuf->f_flags, &ubuf->f_flags) ||\n\t    __clear_user(ubuf->f_spare, sizeof(ubuf->f_spare)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "comment": "Validates and transfers filesystem statistics from kernel to user space, ensuring no overflow occurs for 32-bit fields.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Converts a POSIX file lock request into an absolute lock range for a specified file , validating offsets and length constraints .\n",
    "cpbcs_sum": "Validates and updates the address for a kernel user and group IDs, ensuring security checks and checking for overflow conditions.\n",
    "misum_sum": "Copies data from a user-space compatible file to a user-space compatible `msghdr` structure, checking for access errors and updating the tail pointer.\n",
    "decom_sum": "Validates that several 64-bit fields contain only 32-bit values, copies them into a target buffer, and performs a final 16-byte integrity check.",
    "cfg_sum": "Validates multiple 64-bit fields for 32-bit constraints, copies them into a destination buffer, and returns specific error codes on validation failures.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving control character replacement, escape sequences, static buffers, and Unicode display handling, none of which relate to the function in the source code. The function instead performs size checks, overflow detection, and safely copies filesystem statistics to a user buffer. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary describes text processing, replacing control characters, handling Unicode, and using a static buffer, which does not match any aspect of the source code. The source function writes filesystem statistics to a user-provided structure, performing overflow checks and user-space memory access, with no relation to string escaping or Unicode handling. This is a complete mismatch with the PRIMARY PURPOSE and all secondary details of the actual implementation.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display do not match the source code, which deals with copying filesystem statistics to a user space structure and performing overflow checks. These are all inaccurate (NOISE) and unrelated to the primary purpose, with no specific or accurate insights into the actual implementation, resulting in high negative impact due to irrelevance."
            ]
        },
        "bint5": {
            "summary": "Converts a POSIX file lock request into an absolute lock range for a specified file , validating offsets and length constraints .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes converting a POSIX file lock request into an absolute lock range with validation of offsets and length, which is unrelated to the source code\u2019s functionality. The source implements `put_compat_statfs`, which handles copying filesystem statistics to a user buffer with overflow checks and access validation. All claims in the summary are inaccurate and do not match the code semantics.",
                "The summary is entirely inaccurate: it describes converting a POSIX file lock request, which is unrelated to the source code\u2019s actual purpose of copying a compat_statfs struct to user space while checking for overflow and write access. It misses the primary purpose and all secondary details, providing no coverage of the code\u2019s behavior.",
                "The summary describes converting a POSIX file lock request to an absolute lock range with offset and length validation, which is entirely unrelated to the actual function. The source code handles putting a compat_statfs structure to user space with checks for 32-bit overflow and write access, not file locking. This is a FATAL error affecting the primary purpose, making the summary misleading and unusable."
            ]
        },
        "cpbcs": {
            "summary": "Validates and updates the address for a kernel user and group IDs, ensuring security checks and checking for overflow conditions.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly claims the function validates and updates kernel user and group IDs, which is unrelated to the source code. The source function puts filesystem statistics into a user-provided struct and checks for overflow in 32-bit fields. No claims in the summary accurately reflect the code's behavior, so the proportion of accurate claims is effectively zero.",
                "The summary incorrectly describes the function as handling kernel user and group IDs, which is unrelated to the actual source code. The primary purpose of the function is to copy filesystem statistics from a kernel structure to a user structure, performing overflow checks for 32-bit fields and verifying write access. Since the summary misses this purpose entirely and provides a mismatched description, no accurate claims can be mapped to the CSUs.",
                "The summary is inaccurate about the function\u2019s purpose; it claims the code validates and updates kernel user and group IDs with security checks, but the actual code handles copying a compat_statfs structure to user space, with access checks and 32-bit overflow detection for filesystem statistics. This is a FATAL error targeting the primary purpose, leading to severe misrepresentation and making the summary unreliable."
            ]
        },
        "misum": {
            "summary": "Copies data from a user-space compatible file to a user-space compatible `msghdr` structure, checking for access errors and updating the tail pointer.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function copies data from a compatible file to a compatible `msghdr` structure, checks access errors, and updates a tail pointer. None of these elements match the source code, which instead copies data from a kernel `kstatfs` structure to a user-space `compat_statfs` structure, performs overflow checks, and ensures safe user-space writes. All extracted claims are inaccurate relative to the implementation.",
                "The summary is entirely inaccurate: it describes copying from a compatible file to a `msghdr` structure and updating a tail pointer, which has no relation to the actual code. The source function writes `kstatfs` values into a user-space `compat_statfs` buffer, performs size and overflow checks, and manages access and error codes. The primary purpose and all secondary details from the source are missed, with the summary introducing unrelated concepts.",
                "The summary is entirely inaccurate: it describes copying data to a `msghdr` structure and updating a tail pointer, which is unrelated to the function\u2019s actual purpose of copying `kstatfs` fields to a user-space `compat_statfs` structure with overflow and access checks. This is a FATAL error affecting the primary purpose and key I/O, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 174800,
    "strip_function_name": "sub_2AAD0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_2AAD0(_DWORD *a1, __int64 a2, unsigned __int64 a3, char *a4, size_t a5)\n{\n  unsigned __int64 v6; // rbx\n  int v8; // eax\n  unsigned __int64 v9; // r14\n  unsigned __int64 v10; // rbp\n  __int64 v11; // r12\n  _DWORD *v12; // r14\n  unsigned __int64 v13; // rbx\n  int v14; // eax\n\n  v6 = sub_2A570((__int64)a1, a2, a3, a4, a5, 1, 1u);\n  if ( sub_F240(v6) )\n    return v6;\n  v8 = a1[13];\n  v9 = -11LL;\n  if ( v8 )\n  {\n    v10 = a3 - v6;\n    v11 = v6 + a2;\n    if ( v8 == 1 )\n    {\n      v9 = sub_13AA0(v11, v10, a1[21], a1[28], a1[29], 0LL, 0);\n      if ( sub_F240(v9) )\n        goto LABEL_10;\n      v10 -= v9;\n      a1[13] = 2;\n      v12 = (_DWORD *)(v11 + v9);\n    }\n    else\n    {\n      v12 = (_DWORD *)(v6 + a2);\n      if ( v8 == 3 )\n        goto LABEL_8;\n    }\n    if ( v10 <= 3 )\n      goto LABEL_14;\n    *v12 = 1;\n    v10 -= 3LL;\n    v12 = (_DWORD *)((char *)v12 + 3);\nLABEL_8:\n    if ( !a1[29] )\n    {\nLABEL_9:\n      a1[13] = 0;\n      v9 = (unsigned __int64)v12 - v11;\n      goto LABEL_10;\n    }\n    v14 = sub_EFE0((__int64)(a1 + 40));\n    if ( v10 > 3 )\n    {\n      *v12++ = v14;\n      goto LABEL_9;\n    }\nLABEL_14:\n    v9 = -12LL;\n  }\nLABEL_10:\n  v13 = v9 + v6;\n  if ( sub_F240(v9) )\n    return v9;\n  return v13;\n}\n",
    "function_name": "ZSTD_compressEnd",
    "decompiled_code": "size_t __fastcall ZSTD_compressEnd(_DWORD *a1, __int64 a2, unsigned __int64 a3, char *a4, size_t a5)\n{\n  size_t v6; // rbx\n  int v8; // eax\n  unsigned __int64 v9; // r14\n  unsigned __int64 v10; // rbp\n  __int64 v11; // r12\n  _DWORD *v12; // r14\n  unsigned __int64 v13; // rbx\n  int v14; // eax\n\n  v6 = ZSTD_compressContinue_internal((__int64)a1, a2, a3, a4, a5, 1, 1u);\n  if ( ZSTD_isError(v6) )\n    return v6;\n  v8 = a1[13];\n  v9 = -11LL;\n  if ( v8 )\n  {\n    v10 = a3 - v6;\n    v11 = v6 + a2;\n    if ( v8 == 1 )\n    {\n      v9 = ZSTD_writeFrameHeader_isra_7(v11, v10, a1[21], a1[28], a1[29], 0LL, 0);\n      if ( ZSTD_isError(v9) )\n        goto LABEL_10;\n      v10 -= v9;\n      a1[13] = 2;\n      v12 = (_DWORD *)(v11 + v9);\n    }\n    else\n    {\n      v12 = (_DWORD *)(v6 + a2);\n      if ( v8 == 3 )\n        goto LABEL_8;\n    }\n    if ( v10 <= 3 )\n      goto LABEL_14;\n    *v12 = 1;\n    v10 -= 3LL;\n    v12 = (_DWORD *)((char *)v12 + 3);\nLABEL_8:\n    if ( !a1[29] )\n    {\nLABEL_9:\n      a1[13] = 0;\n      v9 = (unsigned __int64)v12 - v11;\n      goto LABEL_10;\n    }\n    v14 = ZSTD_XXH64_digest((__int64)(a1 + 40));\n    if ( v10 > 3 )\n    {\n      *v12++ = v14;\n      goto LABEL_9;\n    }\nLABEL_14:\n    v9 = -12LL;\n  }\nLABEL_10:\n  v13 = v9 + v6;\n  if ( ZSTD_isError(v9) )\n    return v9;\n  return v13;\n}\n",
    "source_code": "\n\nsize_t ZSTD_compressEnd (ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize)\n{\n    size_t endResult;\n    size_t const cSize = ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1, 1);\n    if (ZSTD_isError(cSize)) return cSize;\n    endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);\n    if (ZSTD_isError(endResult)) return endResult;\n    return cSize + endResult;\n}",
    "comment": "Compresses data using a continuation method, writes an epilogue, and returns the total compressed size or an error code if the process fails.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Compresses a data block using a specific compression strategy and returns the compressed size or an error code if unsuccessful .\n",
    "cpbcs_sum": "Reads data from a specified offset into an image buffer, handling offsets and managing buffer states.\n",
    "misum_sum": "Processes input data by checking for partial fields and adjusting the last block in the XorrisO structure based on the specified boundary type.\n",
    "decom_sum": "Processes a buffer with staged state handling, writing control bytes and optional data based on fields in `a1`, and returns the total processed length or an error code.",
    "cfg_sum": "Processes a data buffer based on internal state, performing conditional transformations and updates, then returns either an error code or the total processed length.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior related to multibyte character string width and handling of non-printable characters, which does not match the source code's implementation of ZSTD_compressEnd for compression and epilogue writing. None of the fact-based claims in the summary align with the actual code semantics, resulting in no accurate matches.",
                "The summary is entirely inaccurate, describing behavior about multibyte string column widths and unprintable character rejection, which is unrelated to the source code. The source implements a compression finalization function that calls internal compression, writes an epilogue, and handles errors. The primary purpose is missed and none of the critical semantic units are covered.",
                "The summary's claims are entirely unrelated to the source code, which deals with compressing data using ZSTD and writing an epilogue. The summary incorrectly describes functionality about multibyte character string widths and unprintable character handling, which is a clear contradiction to the actual implementation. This is a FATAL error affecting the primary purpose of the function, making the description unreliable."
            ]
        },
        "bint5": {
            "summary": "Compresses a data block using a specific compression strategy and returns the compressed size or an error code if unsuccessful .\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function compresses data and returns either the compressed size or an error code, aligning with the source code's call to a compression function, error checks, and return value logic. However, it omits specifics of the function's multi-step process (continuation compression and epilogue writing) and describes the compression strategy vaguely without confirming details from the source. Most claims are broadly accurate but low in specificity, and none are contradictory.",
                "The summary captures the primary purpose of the function, which is to compress data and return either the compressed size or an error code. However, it omits important secondary details from the source code, such as the use of `ZSTD_compressContinue_internal` with specific parameters, the sequential epilogue writing via `ZSTD_writeEpilogue`, and the handling of multiple error checks. These omissions reduce completeness despite the primary purpose being covered.",
                "The summary makes a broad claim that the function compresses a data block and returns the compressed size or an error code, which is generally accurate but lacks specifics from the source code, such as the use of ZSTD_compressContinue_internal with finalization flags, the writing of an epilogue, and calculation of the total size. There are no contradictory or FATAL errors, but the information is low-detail and unhelpful for deeper understanding, resulting in low net benefit due to its generic nature."
            ]
        },
        "cpbcs": {
            "summary": "Reads data from a specified offset into an image buffer, handling offsets and managing buffer states.\n",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary describes reading data from a specific offset into an image buffer and managing buffer states, which is unrelated to the source code. The function in the source code performs compression finalization by continuing compression, writing an epilogue, and returning the combined size, without any handling of image buffers or offsets. All claims are inaccurate as they contradict the actual code semantics.",
                "The summary describes reading data from an offset into an image buffer, which is unrelated to the source code\u2019s actual purpose of finalizing compression with ZSTD_compressEnd, writing an epilogue, and handling potential errors. It misses the primary purpose entirely and provides no accurate coverage of inputs, outputs, or error handling present in the source code.",
                "The summary describes reading data from an offset into an image buffer and managing buffer states, which is unrelated to the actual source code. The source code compresses input data using ZSTD_compressContinue_internal, writes an epilogue, and returns the combined size. This mismatch is a clear NOISE issue targeting wrong functionality, with no accurate claims about compression or buffer handling as implemented. The worst failure mode is NOISE, and the net benefit is very low due to the total lack of relevant, accurate insight."
            ]
        },
        "misum": {
            "summary": "Processes input data by checking for partial fields and adjusting the last block in the XorrisO structure based on the specified boundary type.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes operations involving partial fields, last block adjustments, and a 'XorrisO' structure with boundary types, which are not present in the source code. The source code handles compression continuation, error checking, and writing an epilogue in the ZSTD_compressEnd function. None of the claims align with the actual implementation, resulting in no accurate claims.",
                "The summary describes processing input data, partial fields, and adjusting a block within an unrelated 'XorrisO' structure, which does not appear in the provided source code. The source code implements ZSTD_compressEnd, which continues compression, checks for compression errors, writes an epilogue, and returns the total size. The summary misses the primary purpose and all key secondary details, and contains inaccurate claims unrelated to the code.",
                "The summary contains a claim about processing partial fields and adjusting a last block in an 'XorrisO' structure, which does not match the source code. The source function performs compression continuation, writes an epilogue, and returns the total compressed size\u2014there is no mention of partial fields, boundary types, or any 'XorrisO' structure. This is a FATAL inaccuracy about the primary purpose of the code, leading to high negative impact and making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581012544,
    "strip_function_name": "sub_FFFFFFFF81211240",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF81211240(__int64 a1, int a2, int a3, __int64 a4)\n{\n  unsigned int v4; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v6; // rcx\n\n  *(_DWORD *)(a1 + 24) = a4;\n  v4 = 1000 * a3 / 0xAu;\n  result = v4;\n  *(_QWORD *)a1 = v4;\n  if ( a2 != 17 )\n  {\n    if ( a2 != 256 && a2 != 6 )\n      BUG();\n    if ( (_DWORD)a4 )\n    {\n      a4 = (unsigned int)a4;\n      if ( !v4 )\n      {\nLABEL_7:\n        *(_QWORD *)a1 = 60000LL;\n        result = 60000LL;\nLABEL_8:\n        *(_QWORD *)(a1 + 16) = result;\n        v6 = result + result * a4;\n        if ( v6 > 0x927C0 )\n        {\n          *(_QWORD *)(a1 + 8) = 600000LL;\n        }\n        else\n        {\n          if ( v6 < result )\n            v6 = result;\n          *(_QWORD *)(a1 + 8) = v6;\n        }\n        *(_BYTE *)(a1 + 28) = 0;\n        return result;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 24) = 2;\n      a4 = 2LL;\n      if ( !v4 )\n        goto LABEL_7;\n    }\n    if ( v4 > 0x927C0 )\n    {\n      *(_QWORD *)a1 = 600000LL;\n      result = 600000LL;\n    }\n    goto LABEL_8;\n  }\n  if ( !(_DWORD)a4 )\n    *(_DWORD *)(a1 + 24) = 3;\n  if ( v4 )\n  {\n    if ( v4 > 0xEA60 )\n      *(_QWORD *)a1 = 60000LL;\n  }\n  else\n  {\n    *(_QWORD *)a1 = 1100LL;\n  }\n  *(_QWORD *)(a1 + 8) = 60000LL;\n  *(_BYTE *)(a1 + 28) = 1;\n  return result;\n}\n",
    "function_name": "nfs_init_timeout_values",
    "decompiled_code": "unsigned __int64 __fastcall nfs_init_timeout_values(__int64 a1, int a2, int a3, __int64 a4)\n{\n  unsigned int v4; // edx\n  unsigned __int64 result; // rax\n  unsigned __int64 v6; // rcx\n\n  *(_DWORD *)(a1 + 24) = a4;\n  v4 = 1000 * a3 / 0xAu;\n  result = v4;\n  *(_QWORD *)a1 = v4;\n  if ( a2 != 17 )\n  {\n    if ( a2 != 256 && a2 != 6 )\n      BUG();\n    if ( (_DWORD)a4 )\n    {\n      a4 = (unsigned int)a4;\n      if ( !v4 )\n      {\nLABEL_7:\n        *(_QWORD *)a1 = 60000LL;\n        result = 60000LL;\nLABEL_8:\n        *(_QWORD *)(a1 + 16) = result;\n        v6 = result + result * a4;\n        if ( v6 > 0x927C0 )\n        {\n          *(_QWORD *)(a1 + 8) = 600000LL;\n        }\n        else\n        {\n          if ( v6 < result )\n            v6 = result;\n          *(_QWORD *)(a1 + 8) = v6;\n        }\n        *(_BYTE *)(a1 + 28) = 0;\n        return result;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 24) = 2;\n      a4 = 2LL;\n      if ( !v4 )\n        goto LABEL_7;\n    }\n    if ( v4 > 0x927C0 )\n    {\n      *(_QWORD *)a1 = 600000LL;\n      result = 600000LL;\n    }\n    goto LABEL_8;\n  }\n  if ( !(_DWORD)a4 )\n    *(_DWORD *)(a1 + 24) = 3;\n  if ( v4 )\n  {\n    if ( v4 > 0xEA60 )\n      *(_QWORD *)a1 = 60000LL;\n  }\n  else\n  {\n    *(_QWORD *)a1 = 1100LL;\n  }\n  *(_QWORD *)(a1 + 8) = 60000LL;\n  *(_BYTE *)(a1 + 28) = 1;\n  return result;\n}\n",
    "source_code": "void nfs_init_timeout_values(struct rpc_timeout *to, int proto,\n\t\t\t\t    unsigned int timeo, unsigned int retrans)\n{\n\tto->to_initval = timeo * HZ / 10;\n\tto->to_retries = retrans;\n\n\tswitch (proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_TCP_RETRANS;\n\t\tif (to->to_initval == 0)\n\t\t\tto->to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_TCP_TIMEOUT;\n\t\tto->to_increment = to->to_initval;\n\t\tto->to_maxval = to->to_initval + (to->to_increment * to->to_retries);\n\t\tif (to->to_maxval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_maxval = NFS_MAX_TCP_TIMEOUT;\n\t\tif (to->to_maxval < to->to_initval)\n\t\t\tto->to_maxval = to->to_initval;\n\t\tto->to_exponential = 0;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_UDP:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_UDP_RETRANS;\n\t\tif (!to->to_initval)\n\t\t\tto->to_initval = NFS_DEF_UDP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_UDP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_maxval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_exponential = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "comment": "Initializes timeout values for NFS RPC transport depending on the protocol type, setting retries, initial timeout, and limits accordingly.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Sets the expiration time for an NFS cache based on the specified type , ensuring it does not exceed the maximum cache size .\n",
    "cpbcs_sum": "Decodes a sector from a byte stream, verifying its type and length length, and ensuring valid cookie types and alignment.\n",
    "misum_sum": "Calculates a PCI power level based on specified source, pixel for a given byte size, and optional clock constraints.\n",
    "decom_sum": "Configures timing and mode parameters in a structure based on input codes, setting delays, multipliers, and flags with bounds checking and defaults.",
    "cfg_sum": "Configures timing parameters based on inputs, clamps values within limits, updates related fields, and halts execution on unsupported mode codes.",
    "work_score": {
        "hext5": {
            "summary": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes mathematical properties of the lognormal distribution, which is unrelated to the source code defining NFS timeout initialization logic in C. None of the claims reference or match the implementation details such as transport types, timeout calculations, or retries, making all claims inaccurate with respect to the source code.",
                "The summary contains mathematical details about the lognormal distribution, which are unrelated to the NFS timeout initialization code. It misses the primary purpose of the function\u2014setting timeout and retry values based on transport type\u2014and omits all secondary details such as handling TCP vs UDP constants, limits, increments, and error handling. All claims are noise, with no accurate mapping to the source code semantics.",
                "The summary discusses the mathematical form of a lognormal distribution and related statistical concepts, which have no relation to the source code\u2019s function for initializing NFS RPC timeout values based on protocol, retries, and timeouts. All claims are NOISE, with no accurate alignment to the code semantics. This results in overwhelming irrelevant content and zero useful insight into the implementation."
            ]
        },
        "bint5": {
            "summary": "Sets the expiration time for an NFS cache based on the specified type , ensuring it does not exceed the maximum cache size .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function sets an expiration time for an NFS cache based on type and limits it to a maximum cache size, which does not match the source. The code initializes RPC timeout values for NFS transports (TCP/UDP), not cache expiration, and references maximum timeout values rather than cache size. All claims target code semantics but are incorrect, so none are accurate.",
                "The summary is inaccurate because it describes setting an NFS cache expiration time and maximum cache size, which are unrelated to the source code's actual purpose of initializing RPC timeout values for different NFS transport protocols with specific defaults, limits, and retry logic. It misses the primary function purpose and provides no accurate coverage of key parameters or conditions.",
                "The summary claims the function sets an expiration time for an NFS cache, which is inaccurate as the code sets RPC timeout values for NFS based on transport protocol, retries, and timeouts, not cache expiration or size. This is a FATAL error affecting the primary purpose and key I/O, leaving no accurate claims to provide value."
            ]
        },
        "cpbcs": {
            "summary": "Decodes a sector from a byte stream, verifying its type and length length, and ensuring valid cookie types and alignment.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes decoding a sector from a byte stream with checks for type, length, cookie types, and alignment, which is entirely unrelated to the source code that initializes NFS RPC timeout values based on protocol, retries, and timeouts. None of the claims in the summary match the functionality of the source code, resulting in no accurate claims.",
                "The summary describes decoding a sector from a byte stream with checks on type, length, cookie validity, and alignment, which is entirely unrelated to the source code's purpose of initializing NFS RPC timeout values based on protocol, constants, and retries. It misses the primary purpose and all secondary details of the source implementation, making the claims inaccurate.",
                "The summary claims the function decodes a sector from a byte stream, verifies type and length, and checks cookie types and alignment, which is entirely unrelated to the actual source code. The source initializes RPC timeout values for NFS based on protocol and input parameters, with no sector decoding or cookie validation. This is a clear FATAL error targeting the primary purpose of the function, rendering the description misleading and unusable."
            ]
        },
        "misum": {
            "summary": "Calculates a PCI power level based on specified source, pixel for a given byte size, and optional clock constraints.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function calculates a PCI power level based on source, pixel, byte size, and clock constraints, which is entirely unrelated to the source code. The actual code initializes NFS timeout values based on protocol, timeouts, and retries, with no mention of PCI, pixels, byte size, or clock constraints. All claims are inaccurate, resulting in no accurate matches.",
                "The summary is completely inaccurate, describing PCI power level calculations with pixels and clock constraints, which are unrelated to the source code. The source function initializes NFS RPC timeout values based on protocol type, handling retries, default constants, and max timeout conditions. The summary misses the primary purpose entirely and contains unrelated details, providing no accurate coverage of any critical semantic units.",
                "The summary claims the function calculates a PCI power level with pixel and byte size considerations, which is entirely unrelated to the source code. The source code initializes NFS timeout and retry values based on transport protocol. This is a FATAL error affecting the primary purpose, providing zero useful details and misrepresenting the function entirely."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4222432,
    "strip_function_name": "sub_406DE0",
    "strip_decompiled_code": "int __fastcall sub_406DE0(FILE *stream, unsigned __int64 a2)\n{\n  int result; // eax\n  unsigned __int64 v3; // rbx\n  __int64 v4; // rbp\n  unsigned __int64 v5; // rax\n  int v6; // eax\n  unsigned __int64 v7; // rbp\n  unsigned __int64 v8[517]; // [rsp+0h] [rbp-1028h] BYREF\n\n  result = 0;\n  if ( a2 )\n  {\n    v3 = a2;\n    v4 = sub_4073A0();\n    if ( v4 )\n    {\n      while ( 1 )\n      {\n        if ( sub_405D60(stream, v8) )\n        {\n          v5 = v8[0];\n          if ( v8[0] )\n          {\n            if ( v8[0] > v3 )\n              v5 = v3;\n            stream->_IO_read_ptr += v5;\n            v3 -= v5;\n            if ( !v3 )\n              return 0;\n            v4 -= v5;\n            if ( !v4 )\n              goto LABEL_16;\n          }\n        }\n        if ( fgetc(stream) == -1 )\n          return -(ferror(stream) != 0);\n        if ( !--v3 )\n          return 0;\n        if ( !--v4 )\n          goto LABEL_16;\n      }\n    }\n    else\n    {\nLABEL_16:\n      v6 = fileno(stream);\n      if ( v6 < 0 || lseek(v6, 0LL, 1) < 0 )\n      {\n        while ( 1 )\n        {\n          v7 = 4096LL;\n          if ( v3 <= 0x1000 )\n            v7 = v3;\n          if ( v7 > __fread_chk() )\n            break;\n          v3 -= v7;\n          if ( !v3 )\n            return 0;\n        }\n        return -(ferror(stream) != 0);\n      }\n      else\n      {\n        return sub_405D90(stream, v3, 1);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "freadseek",
    "decompiled_code": "int __fastcall freadseek(FILE *a1, unsigned __int64 a2)\n{\n  int result; // eax\n  unsigned __int64 v3; // rbx\n  size_t v4; // rbp\n  size_t v5; // rax\n  int v6; // eax\n  unsigned __int64 v7; // rbp\n  size_t buf[517]; // [rsp+0h] [rbp-1028h] BYREF\n\n  result = 0;\n  if ( a2 )\n  {\n    v3 = a2;\n    v4 = freadahead(a1);\n    if ( v4 )\n    {\n      while ( 1 )\n      {\n        if ( freadptr(a1, buf) )\n        {\n          v5 = buf[0];\n          if ( buf[0] )\n          {\n            if ( buf[0] > v3 )\n              v5 = v3;\n            a1->_IO_read_ptr += v5;\n            v3 -= v5;\n            if ( !v3 )\n              return 0;\n            v4 -= v5;\n            if ( !v4 )\n              goto LABEL_16;\n          }\n        }\n        if ( fgetc(a1) == -1 )\n          return -(ferror(a1) != 0);\n        if ( !--v3 )\n          return 0;\n        if ( !--v4 )\n          goto LABEL_16;\n      }\n    }\n    else\n    {\nLABEL_16:\n      v6 = fileno(a1);\n      if ( v6 < 0 || lseek(v6, 0LL, 1) < 0 )\n      {\n        while ( 1 )\n        {\n          v7 = 4096LL;\n          if ( v3 <= 0x1000 )\n            v7 = v3;\n          if ( v7 > __fread_chk() )\n            break;\n          v3 -= v7;\n          if ( !v3 )\n            return 0;\n        }\n        return -(ferror(a1) != 0);\n      }\n      else\n      {\n        return rpl_fseeko(a1, v3, 1);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint\nfreadseek (FILE *fp, size_t offset)\n{\n  size_t total_buffered;\n  int fd;\n\n  if (offset == 0)\n    return 0;\n\n  /* Seek over the already read and buffered input as quickly as possible,\n     without doing any system calls.  */\n  total_buffered = freadahead (fp);\n  /* This loop is usually executed at most twice: once for ungetc buffer (if\n     present) and once for the main buffer.  */\n  while (total_buffered > 0)\n    {\n      size_t buffered;\n\n      if (freadptr (fp, &buffered) != NULL && buffered > 0)\n        {\n          size_t increment = (buffered < offset ? buffered : offset);\n\n          freadptrinc (fp, increment);\n          offset -= increment;\n          if (offset == 0)\n            return 0;\n          total_buffered -= increment;\n          if (total_buffered == 0)\n            break;\n        }\n      /* Read one byte.  If we were reading from the ungetc buffer, this\n         switches the stream back to the main buffer.  */\n      if (fgetc (fp) == EOF)\n        goto eof;\n      offset--;\n      if (offset == 0)\n        return 0;\n      total_buffered--;\n    }\n\n  /* Test whether the stream is seekable or not.  */\n  fd = fileno (fp);\n  if (fd >= 0 && lseek (fd, 0, SEEK_CUR) >= 0)\n    {\n      /* FP refers to a regular file.  fseek is most efficient in this case.  */\n      return fseeko (fp, offset, SEEK_CUR);\n    }\n  else\n    {\n      /* FP is a non-seekable stream, possibly not even referring to a file\n         descriptor.  Read OFFSET bytes explicitly and discard them.  */\n      char buf[4096];\n\n      do\n        {\n          size_t count = (sizeof (buf) < offset ? sizeof (buf) : offset);\n          if (fread (buf, 1, count, fp) < count)\n            goto eof;\n          offset -= count;\n        }\n      while (offset > 0);\n\n      return 0;\n   }\n\n eof:\n  /* EOF, or error before or while reading.  */\n  if (ferror (fp))\n    return EOF;\n  else\n    /* Encountered EOF.  */\n    return 0;\n}",
    "comment": "The function efficiently skips a specified number of bytes in a FILE stream, handling buffered input and seeking on regular files when possible.",
    "hext5_sum": "| copy input file to output file, while encoding it. | '",
    "bint5_sum": "Reads a specified number of bytes from a file stream into a buffer , handling EOF and end-of-file conditions appropriately .\n",
    "cpbcs_sum": "Reads data from a file stream into a buffer, handling both buffered and binary formats while returning the number of bytes read.\n",
    "misum_sum": "Reads the contents of a file stream into a buffer, adjusting for zero if necessary, while handling specific error conditions.\n",
    "decom_sum": "Skips forward a specified number of bytes in a FILE stream using buffered reads, direct reads, or seeking depending on stream capabilities.",
    "cfg_sum": "Reads and discards up to a specified number of bytes from a file stream using buffered or unbuffered methods until the limit is reached or an error occurs.",
    "work_score": {
        "hext5": {
            "summary": "| copy input file to output file, while encoding it. | '",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function copies an input file to an output file while encoding it, which is not reflected in the source code. The code implements 'freadseek', which seeks ahead in a FILE stream, possibly skipping buffered data or reading and discarding bytes, with no copying or encoding functionality. This is a direct contradiction, resulting in no accurate claims.",
                "The summary claims the function copies an input file to an output file while encoding it, which directly contradicts the source code. The actual implementation seeks forward by a given offset in a FILE stream, using buffered data, fseek when possible, or reading and discarding bytes otherwise, with EOF and error handling. The summary misses the primary purpose entirely and introduces unrelated behavior, making it inaccurate.",
                "The summary claims the function copies an input file to an output file while encoding it, which directly contradicts the source code. The code's primary purpose is to advance a file stream pointer by a given offset, optimizing buffered reads and using seek operations where possible, not to copy or encode files. This is a FATAL error impacting the primary purpose, leaving no accurate claims and rendering the summary unreliable."
            ]
        },
        "bint5": {
            "summary": "Reads a specified number of bytes from a file stream into a buffer , handling EOF and end-of-file conditions appropriately .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly claims the function reads bytes into a buffer, whereas the source code shows it primarily skips over buffered data or reads and discards bytes to advance the file position. Handling of EOF is mentioned correctly, but the core functionality is misrepresented, making most claims inaccurate.",
                "The summary incorrectly states that the function reads bytes into a buffer, whereas the source code shows it actually skips/advances the read position by the given offset using buffered data, seeking, or reading and discarding data. This misrepresents the primary purpose. While EOF handling is mentioned, the handling of seekable vs non-seekable streams, buffered data optimization, and multiple branches is missing, resulting in both inaccuracy and poor coverage.",
                "The summary incorrectly states that the function reads a specified number of bytes into a buffer, whereas the actual code primarily skips over bytes from a file stream without necessarily delivering them to a caller-provided buffer. This is a FATAL error affecting the primary purpose of the function. While the mention of handling EOF is accurate, the core operation is misrepresented, resulting in high negative impact and unreliable interpretation."
            ]
        },
        "cpbcs": {
            "summary": "Reads data from a file stream into a buffer, handling both buffered and binary formats while returning the number of bytes read.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains a single claim stating that the function reads data from a file stream into a buffer and returns the number of bytes read, handling both buffered and binary formats. This is inaccurate: the source code does not aim to return the number of bytes read nor differentiate buffered vs binary formats; instead, it seeks forward through the stream by offset, handling buffered data, regular files, and non-seekable streams. Therefore, none of the claims match the source code's semantics.",
                "The summary is inaccurate because it describes reading data into a buffer and returning the number of bytes read, which contradicts the source code's actual primary purpose of skipping (seeking past) a specified number of bytes in a FILE stream. It omits all key secondary details such as optimized buffered skipping, handling seekable vs. non-seekable streams, explicit discarding of data, and EOF/error handling. The primary behavior is missed entirely, resulting in no meaningful coverage.",
                "The summary inaccurately describes the function's purpose as reading data into a buffer and returning the number of bytes read. In reality, the function seeks forward in a file stream by a given offset, leveraging buffered data and differing behavior for seekable vs non-seekable streams, and returns 0, EOF, or fseeko result rather than the number of bytes read. This is a FATAL error affecting the primary purpose description, with no accurate claims to offset the negative impact."
            ]
        },
        "misum": {
            "summary": "Reads the contents of a file stream into a buffer, adjusting for zero if necessary, while handling specific error conditions.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as reading file contents into a buffer, whereas the source code shows it skips forward in a file stream by a given offset using buffered data, fseek, or reading/discarding bytes. It omits key operations like seeking, handling non-seekable streams, and EOF logic. Because the main claim contradicts core semantics, very few of the claims are accurate.",
                "The summary inaccurately describes the function as reading the contents of a file stream into a buffer, which contradicts the code\u2019s actual primary purpose of efficiently skipping over a specified number of bytes in a stream by using buffered data, seeking, or reading/discarding data. It misses the primary purpose entirely and omits key secondary behaviors such as handling seekable vs non-seekable streams, EOF handling, and using buffered reads to minimize system calls.",
                "The summary inaccurately states that the function reads the contents of a file stream into a buffer; in reality, the code attempts to skip over data in the stream using buffered reads, seeks, and discards rather than loading the full contents. This is a FATAL error affecting the primary purpose. While it mentions handling specific error conditions, that part is broadly accurate but low detail. The dominant issue is the incorrect depiction of the main operation, leading to high negative impact."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 821280,
    "strip_function_name": "sub_C8820",
    "strip_decompiled_code": "char **__fastcall sub_C8820(char *s, const char *a2, int a3, int a4)\n{\n  char **v6; // rax\n  char **v7; // rbx\n  char *v8; // rax\n  char *v9; // rbp\n  size_t v10; // rax\n  char *v11; // rax\n  char *v12; // rax\n  unsigned int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n\n  v6 = (char **)malloc(0x1E8uLL);\n  if ( !v6 )\n  {\nLABEL_7:\n    v14 = (unsigned int)dcgettext(0LL, \"allocation of xzfile connection failed\", 5);\n    Rf_error(v14, (unsigned int)\"allocation of xzfile connection failed\", v15, v16, v17, v18);\n  }\n  v7 = v6;\n  v8 = (char *)malloc(7uLL);\n  v9 = v8;\n  *v7 = v8;\n  if ( !v8 )\n  {\nLABEL_6:\n    free(v7);\n    goto LABEL_7;\n  }\n  strcpy(v8, \"xzfile\");\n  v10 = strlen(s);\n  v11 = (char *)malloc(v10 + 1);\n  v7[1] = v11;\n  if ( !v11 )\n  {\n    free(v9);\n    goto LABEL_6;\n  }\n  Rf_init_con((__int64)v7, s, 0, a2);\n  *((_DWORD *)v7 + 12) = 0;\n  v7[8] = (char *)sub_C7D20;\n  v7[9] = (char *)sub_C4BF0;\n  v7[11] = (char *)dummy_vfprintf;\n  v7[13] = (char *)sub_C4B90;\n  v7[12] = (char *)dummy_fgetc;\n  v7[14] = (char *)sub_C2950;\n  v7[16] = (char *)sub_C2740;\n  v7[17] = (char *)sub_C4A30;\n  v7[18] = (char *)sub_C4920;\n  v12 = (char *)calloc(0x2840uLL, 1uLL);\n  v7[55] = v12;\n  *((_DWORD *)v12 + 38) = a3;\n  *((_DWORD *)v12 + 37) = a4;\n  return v7;\n}\n",
    "function_name": "newxzfile",
    "decompiled_code": "char **__fastcall newxzfile(\n        char *s,\n        const char *a2,\n        int a3,\n        int a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        __m128 a8,\n        double a9,\n        double a10,\n        __m128 a11,\n        __m128 a12)\n{\n  char **v14; // rax\n  char **v15; // rbx\n  char *v16; // rax\n  char *v17; // rbp\n  size_t v18; // rax\n  char *v19; // rax\n  char *v20; // rax\n  unsigned int v22; // eax\n  __int64 v23; // rdx\n  __int64 v24; // rcx\n  __int64 v25; // r8\n  __int64 v26; // r9\n  __m128 v27; // xmm4\n  __m128 v28; // xmm5\n\n  v14 = (char **)malloc(0x1E8uLL);\n  if ( !v14 )\n  {\nLABEL_7:\n    v22 = (unsigned int)dcgettext(0LL, \"allocation of xzfile connection failed\", 5);\n    Rf_error(\n      v22,\n      (__int64)\"allocation of xzfile connection failed\",\n      v23,\n      v24,\n      v25,\n      v26,\n      a5,\n      a6,\n      a7,\n      a8,\n      v27,\n      v28,\n      a11,\n      a12);\n  }\n  v15 = v14;\n  v16 = (char *)malloc(7uLL);\n  v17 = v16;\n  *v15 = v16;\n  if ( !v16 )\n  {\nLABEL_6:\n    free(v15);\n    goto LABEL_7;\n  }\n  strcpy(v16, \"xzfile\");\n  v18 = strlen(s);\n  v19 = (char *)malloc(v18 + 1);\n  v15[1] = v19;\n  if ( !v19 )\n  {\n    free(v17);\n    goto LABEL_6;\n  }\n  Rf_init_con((__int64)v15, s, 0, a2);\n  *((_DWORD *)v15 + 12) = 0;\n  v15[8] = (char *)xzfile_open;\n  v15[9] = (char *)xzfile_close;\n  v15[11] = (char *)dummy_vfprintf;\n  v15[13] = (char *)xzfile_fgetc_internal;\n  v15[12] = (char *)dummy_fgetc;\n  v15[14] = (char *)null_seek;\n  v15[16] = (char *)null_fflush;\n  v15[17] = (char *)xzfile_read;\n  v15[18] = (char *)xzfile_write;\n  v20 = (char *)calloc(0x2840uLL, 1uLL);\n  v15[55] = v20;\n  *((_DWORD *)v20 + 38) = a3;\n  *((_DWORD *)v20 + 37) = a4;\n  return v15;\n}\n",
    "source_code": "\nstatic Rconnection\nnewxzfile(const char *description, const char *mode, int type, int compress)\n{\n    Rconnection new;\n    new = (Rconnection) malloc(sizeof(struct Rconn));\n    if(!new) error(_(\"allocation of xzfile connection failed\"));\n    new->class = (char *) malloc(strlen(\"xzfile\") + 1);\n    if(!new->class) {\n\tfree(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    strcpy(new->class, \"xzfile\");\n    new->description = (char *) malloc(strlen(description) + 1);\n    if(!new->description) {\n\tfree(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    init_con(new, description, CE_NATIVE, mode);\n\n    new->canseek = FALSE;\n    new->open = &xzfile_open;\n    new->close = &xzfile_close;\n    new->vfprintf = &dummy_vfprintf;\n    new->fgetc_internal = &xzfile_fgetc_internal;\n    new->fgetc = &dummy_fgetc;\n    new->seek = &null_seek;\n    new->fflush = &null_fflush;\n    new->read = &xzfile_read;\n    new->write = &xzfile_write;\n    new->private = (void *) malloc(sizeof(struct xzfileconn));\n    memset(new->private, 0, sizeof(struct xzfileconn));\n    if(!new->private) {\n\tfree(new->description); free(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    ((Rxzfileconn) new->private)->type = type;\n    ((Rxzfileconn) new->private)->compress = compress;\n    return new;\n}",
    "comment": "Allocates and initializes a new xzfile connection, setting its properties and handling memory for class, description, and private data structures.",
    "hext5_sum": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
    "bint5_sum": "Creates and initializes an xzfile connection with specified description , mode , and compression level , allocating necessary resources .\n",
    "cpbcs_sum": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
    "misum_sum": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
    "decom_sum": "Initializes and returns an xzfile connection structure, setting file handlers and parameters, and allocating associated buffers for compressed file operations.",
    "cfg_sum": "Initializes an xzfile connection structure, setting function pointers and parameters, while handling memory allocation errors and freeing resources on failure.",
    "work_score": {
        "hext5": {
            "summary": "build a new input file node for the language. there are several ways in which we treat an input file, eg, we only look at symbols, or prefix it with a -l etc. we can be supplied with requests for input files more than once; foo.o(.data) etc, so when asked for a file we check that we haven't got it already so we don't duplicate the bfd.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary\u2019s claims about handling input files, checking for duplicates, and treating symbols are unrelated to the source code, which is about allocating and initializing an xzfile Rconnection object. None of the claims match the code\u2019s semantics, resulting in no accurate matches.",
                "The summary describes behavior related to handling input files, duplicate checks, and symbol processing, which is unrelated to the provided source code. The source function creates and initializes an xzfile connection, handling memory allocation, setting fields, and configuring function pointers. None of the fact-based claims in the summary align with the primary purpose or secondary details of the source, resulting in no coverage of CSUs.",
                "The summary describes building an input file node, handling duplicate files, and specific linker-like behaviors such as prefixing with '-l' and checking symbols. None of these claims match the source code, which allocates and initializes an 'xzfile' Rconnection with function pointers, memory allocations, and compression settings. All summary claims are unrelated to the actual code's purpose, creating overwhelming NOISE and offering no accurate or useful insight."
            ]
        },
        "bint5": {
            "summary": "Creates and initializes an xzfile connection with specified description , mode , and compression level , allocating necessary resources .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary states that the function creates and initializes an xzfile connection with a description, mode, and compression level, allocating necessary resources. These details align with the source code: the function allocates memory, sets its class to 'xzfile', stores the description, initializes via init_con, and sets the compress parameter. Although the summary omits mention of the 'type' parameter and does not detail all the function pointers setup, its claims are accurate and consistent with the implementation.",
                "The summary correctly captures the primary purpose of creating and initializing an xzfile connection with given parameters and allocating resources, which matches the core function behavior. However, it omits secondary details such as specific error handling for allocation failures, initialization of various function pointers, setting of canseek to FALSE, and assignment of type and compress values, resulting in incomplete coverage.",
                "The summary correctly states that the function creates and initializes an xzfile connection with a specified description, mode, and compression level while allocating resources. These details align with the source code, which sets up fields, assigns function pointers, handles memory allocation, and stores type/compression parameters. The claim is accurate but broad, lacking specifics like error handling paths or exact struct fields, so it offers only low informational gain without any factual errors."
            ]
        },
        "cpbcs": {
            "summary": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as creating a 'gzfile' connection, while the source clearly shows it creates an 'xzfile' connection. Although it correctly notes allocation of resources and initialization with a description, mode, and compression level, the key identification of the file type is wrong, making a core claim incorrect. This results in less than half of the claims being accurate.",
                "The summary inaccurately identifies the connection type as 'gzfile' instead of 'xzfile', contradicting the source code's PRIMARY PURPOSE. While it mentions initialization with description, mode, and compression, it misses key secondary details like type parameter handling, specific function pointer assignments, and the various error handling branches for resource allocation failures. The critical mislabeling of the connection type prevents it from accurately capturing the primary function behavior.",
                "The summary incorrectly states that the function creates a 'gzfile' connection, while the source code clearly initializes an 'xzfile' connection. This is a FATAL inaccuracy targeting the primary purpose. Additionally, the summary omits specific implementation details such as setting function pointers and handling allocation failures, providing only a vague, low-information description. The worst failure mode is FATAL, as the core object type is misrepresented."
            ]
        },
        "misum": {
            "summary": "Creates and initializes a new gzfile connection with specified description, mode, and compression level, allocating necessary resources.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as creating a 'gzfile' connection, while the source code clearly creates and initializes an 'xzfile' connection. Although it correctly notes resource allocation and parameter usage, the core file type detail is wrong, leading to a critical semantic error in the primary claim.",
                "The summary incorrectly states that the function creates a 'gzfile' connection, while the source code clearly creates and initializes an 'xzfile' connection. This is a factual error targeting the primary purpose, making the claim inaccurate. Although it mentions allocating resources and using description, mode, and compression parameters, the core identification of the connection type is wrong, so it fails to capture the primary purpose.",
                "The summary incorrectly states that the function creates a gzfile connection, while the source code clearly creates an xzfile connection. This is a FATAL error targeting the primary purpose of the function. Although it mentions allocation of resources and use of description, mode, and compression level, these accurate elements are overshadowed by the core misidentification, making the overall output unreliable."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1108176,
    "strip_function_name": "gsl_multifit_linear_applyW",
    "strip_decompiled_code": "__int64 __fastcall gsl_multifit_linear_applyW(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)\n{\n  __int64 v5; // rbp\n  __int64 i; // r12\n  double v9; // xmm1_8\n  double *v10; // rbx\n  _QWORD *v12; // [rsp+0h] [rbp-78h]\n  double x; // [rsp+8h] [rbp-70h]\n  _BYTE v14[104]; // [rsp+10h] [rbp-68h] BYREF\n\n  v5 = *a3;\n  if ( *a3 == *a1 )\n  {\n    if ( a2 && v5 != *a2 )\n    {\n      gsl_error(\"weight vector does not match X\", \"multireg.c\", 90LL, 19LL);\n      return 19LL;\n    }\n    else if ( v5 == *a4 && a4[1] == a1[1] )\n    {\n      if ( v5 == *a5 )\n      {\n        if ( a1 != a4 )\n        {\n          v12 = a3;\n          gsl_matrix_memcpy(a4, a1);\n          a3 = v12;\n        }\n        if ( a3 != a5 )\n          gsl_vector_memcpy(a5, a3);\n        if ( a2 && v5 )\n        {\n          for ( i = 0LL; i != v5; ++i )\n          {\n            x = *(double *)(a2[2] + i * 8LL * a2[1]);\n            gsl_matrix_row(v14, a4, i);\n            v9 = 0.0;\n            v10 = (double *)(a5[2] + i * 8LL * a5[1]);\n            if ( x >= 0.0 )\n              v9 = sqrt(x);\n            gsl_vector_scale(v14, v9);\n            *v10 = v9 * *v10;\n          }\n        }\n        return 0LL;\n      }\n      else\n      {\n        gsl_error(\"Wy vector must be length n\", \"multireg.c\", 98LL, 19LL);\n        return 19LL;\n      }\n    }\n    else\n    {\n      gsl_error(\"WX matrix dimensions do not match X\", \"multireg.c\", 94LL, 19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    gsl_error(\"y vector does not match X\", \"multireg.c\", 86LL, 19LL);\n    return 19LL;\n  }\n}\n",
    "function_name": "gsl_multifit_linear_applyW",
    "decompiled_code": "__int64 __fastcall gsl_multifit_linear_applyW(\n        const gsl_matrix *X,\n        _QWORD *a2,\n        const gsl_vector *y,\n        const gsl_matrix *a4,\n        const gsl_vector *a5,\n        __int64 a6,\n        __int64 a7,\n        __int64 a8)\n{\n  size_t size; // rbp\n  __int64 v11; // r12\n  double v12; // xmm1_8\n  double *v13; // rbx\n  const gsl_vector *retaddr; // [rsp+78h] [rbp+0h]\n  double v16; // [rsp+80h] [rbp+8h]\n\n  size = y->size;\n  if ( y->size == X->size1 )\n  {\n    if ( a2 && size != *a2 )\n    {\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"weight vector does not match X\",\n        \"multireg.c\",\n        90LL,\n        19LL);\n      return 19LL;\n    }\n    else if ( size == a4->size1 && a4->size2 == X->size2 )\n    {\n      if ( size == a5->size )\n      {\n        if ( X != a4 )\n        {\n          retaddr = y;\n          ((void (__fastcall *)(const gsl_matrix *, const gsl_matrix *))gsl_matrix_memcpy)(a4, X);\n          y = retaddr;\n        }\n        if ( y != a5 )\n          ((void (__fastcall *)(const gsl_vector *, const gsl_vector *))gsl_vector_memcpy)(a5, y);\n        if ( a2 && size )\n        {\n          v11 = 0LL;\n          retaddr = (const gsl_vector *)&a8;\n          do\n          {\n            v16 = *(double *)(a2[2] + v11 * 8LL * a2[1]);\n            ((void (__fastcall *)(const gsl_vector *, const gsl_matrix *, __int64))gsl_matrix_row)(retaddr, a4, v11);\n            v12 = 0.0;\n            v13 = (double *)((char *)a5->data + v11 * 8 * a5->stride);\n            if ( v16 >= 0.0 )\n              v12 = sqrt(v16);\n            ++v11;\n            ((void (__fastcall *)(const gsl_vector *, double))gsl_vector_scale)(retaddr, v12);\n            *v13 = v12 * *v13;\n          }\n          while ( size != v11 );\n        }\n        return 0LL;\n      }\n      else\n      {\n        ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n          \"Wy vector must be length n\",\n          \"multireg.c\",\n          98LL,\n          19LL);\n        return 19LL;\n      }\n    }\n    else\n    {\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"WX matrix dimensions do not match X\",\n        \"multireg.c\",\n        94LL,\n        19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"y vector does not match X\",\n      \"multireg.c\",\n      86LL,\n      19LL);\n    return 19LL;\n  }\n}\n",
    "source_code": "\nint\ngsl_multifit_linear_applyW(const gsl_matrix * X,\n                           const gsl_vector * w,\n                           const gsl_vector * y,\n                           gsl_matrix * WX,\n                           gsl_vector * Wy)\n{\n  const size_t n = X->size1;\n  const size_t p = X->size2;\n\n  if (n != y->size)\n    {\n      GSL_ERROR(\"y vector does not match X\", GSL_EBADLEN);\n    }\n  else if (w != NULL && n != w->size)\n    {\n      GSL_ERROR(\"weight vector does not match X\", GSL_EBADLEN);\n    }\n  else if (n != WX->size1 || p != WX->size2)\n    {\n      GSL_ERROR(\"WX matrix dimensions do not match X\", GSL_EBADLEN);\n    }\n  else if (n != Wy->size)\n    {\n      GSL_ERROR(\"Wy vector must be length n\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i;\n\n      /* copy WX = X; Wy = y if distinct pointers */\n      if (WX != X)\n        gsl_matrix_memcpy(WX, X);\n      if (Wy != y)\n        gsl_vector_memcpy(Wy, y);\n\n      if (w != NULL)\n        {\n          /* construct WX = sqrt(W) X and Wy = sqrt(W) y */\n          for (i = 0; i < n; ++i)\n            {\n              double wi = gsl_vector_get(w, i);\n              double swi;\n              gsl_vector_view row = gsl_matrix_row(WX, i);\n              double *yi = gsl_vector_ptr(Wy, i);\n\n              if (wi < 0.0)\n                wi = 0.0;\n\n              swi = sqrt(wi);\n              gsl_vector_scale(&row.vector, swi);\n              *yi *= swi;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "comment": "Applies weighted transformations to input matrix X and vector y, storing results in WX and Wy, respectively, while handling potential dimension mismatches.",
    "hext5_sum": "apply weight matrix to (x,y) ls system inputs: x - least squares matrix n-by-p w - weight vector n-by-1 or null for w = i y - right hand side n-by-1 wx - (output) sqrt(w) x, n-by-p wy - (output) sqrt(w) y, n-by-1 notes: 1) if w = null, on output wx = x and wy = y 2) it is allowed for wx = x and wy = y for in-place transform",
    "bint5_sum": "Applies a weighted least squares fitting step to the input vector X , updating the solution vector Y based on the computed weight .\n",
    "cpbcs_sum": "Solves a linear system using singular value decomposition with provided L and V, singular values from the input vector x.\n",
    "misum_sum": "Calculates the generalized cross-validation (GCV) curve values for a linear model using its index and a permutation, storing the result in vector x.\n",
    "decom_sum": "Validates dimensional consistency of input vectors/matrices and applies square-root weight scaling to X and y data in a weighted linear regression.",
    "cfg_sum": "Validates size compatibility of input vectors and matrices, copies data, and applies weights with scaling, returning error on dimension or length mismatches.",
    "work_score": {
        "hext5": {
            "summary": "apply weight matrix to (x,y) ls system inputs: x - least squares matrix n-by-p w - weight vector n-by-1 or null for w = i y - right hand side n-by-1 wx - (output) sqrt(w) x, n-by-p wy - (output) sqrt(w) y, n-by-1 notes: 1) if w = null, on output wx = x and wy = y 2) it is allowed for wx = x and wy = y for in-place transform",
            "score": [
                0.9,
                0.6,
                0.9
            ],
            "reason": [
                "The summary captures core facts from the source code accurately: it describes applying a weight matrix to X and Y, the dimensions of X, w, and y, the output formulas WX = sqrt(w) X and Wy = sqrt(w) y, and that null w results in WX = X and Wy = Y. It also correctly notes the allowance for in-place transformation. These align with the code\u2019s behavior and checks, with no contradictions detected, meaning nearly all claims are accurate.",
                "The summary correctly captures the primary purpose of applying weights to the least-squares system and notes in-place transformation when outputs share memory with inputs. It accurately describes behavior when the weight vector is null and the resulting scaling using sqrt(w). However, it omits key secondary details from the source code, such as the specific dimension validation checks for X, y, w, WX, and Wy, and handling of negative weights by treating them as zero. These omissions reduce completeness despite the accurate coverage of the main functionality.",
                "The summary contains accurate, specific claims about the function\u2019s role in applying weights to a least squares system, including the dimensions of inputs and outputs, behavior when `w` is null, and allowance for in-place transformation. These details align well with the source code, which checks input sizes, handles null weights, and allows `WX`/`Wy` to reference the same memory as `X`/`y`. No claims are inaccurate or contradictory, and the level of detail provides high gain to an engineer reading it."
            ]
        },
        "bint5": {
            "summary": "Applies a weighted least squares fitting step to the input vector X , updating the solution vector Y based on the computed weight .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function applies a weighted least squares fitting step and updates a solution vector based on computed weights, which is misleading. The source code does not perform a fitting step; it simply validates input dimensions and applies weights to X and y, producing WX and Wy. The mention of a 'solution vector' and 'computed weight' is inaccurate, as the weights are provided by the input vector w and no fitting is performed. This means the claim contradicts the actual semantics, with little alignment to the code.",
                "The summary incorrectly describes the function as performing a weighted least squares fitting step and updating a solution vector, which contradicts the source code\u2019s actual purpose of preparing weighted matrix and vector copies (WX and Wy) from inputs, with various dimension checks and optional scaling by sqrt of weights. It fails to capture the primary purpose and ignores key secondary details like error handling, input dimension validation, and data copying steps.",
                "The summary makes a specific claim that the function applies a weighted least squares fitting step and updates the solution vector Y based on computed weights. This is inaccurate because the source code does not perform any fitting; it only applies weights by scaling rows of X and elements of y to produce WX and Wy. This constitutes a FATAL error about the primary purpose, misrepresenting core functionality."
            ]
        },
        "cpbcs": {
            "summary": "Solves a linear system using singular value decomposition with provided L and V, singular values from the input vector x.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function solves a linear system using singular value decomposition with provided L and V and singular values from input vector x. The source code instead checks dimension consistency, copies matrices/vectors, and applies weights by scaling with the square root of w. There is no use of SVD, L, V, or singular values, making the only claim entirely inaccurate.",
                "The summary claims the function solves a linear system using SVD with matrices L and V and singular values from vector x, but the source code shows it applies weights to X and y for linear fitting, performs dimension checks, and scales rows and elements using sqrt of weights. There is no SVD, L, V, or x in the implementation, making the claim entirely inaccurate and missing the primary purpose.",
                "The summary makes a highly specific claim about solving a linear system using singular value decomposition, which is entirely inaccurate given the source code. The actual function applies weights to a matrix and vector for linear fitting, with no SVD or solving operations present. This is a FATAL error about the primary purpose of the function, providing no accurate or useful insight."
            ]
        },
        "misum": {
            "summary": "Calculates the generalized cross-validation (GCV) curve values for a linear model using its index and a permutation, storing the result in vector x.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates generalized cross-validation (GCV) curve values using an index and permutation, storing results in vector x. The source code clearly implements weight application to a linear model design matrix and response vector, with checks on dimensions and scaling by sqrt of weights, and contains no GCV computation or use of index/permutation. All claims are inaccurate and unrelated to the source code semantics.",
                "The summary describes calculating GCV curve values for a linear model, which is entirely unrelated to the source code. The source code applies weight vector adjustments to matrix X and vector y, with dimension checks and error handling, but no mention of GCV or permutations. This indicates a complete mismatch between the summary and actual function behavior, missing the primary purpose entirely.",
                "The summary claims the function calculates generalized cross-validation (GCV) curve values for a linear model using an index and permutation, which directly contradicts the source code. The source function applies weights to a design matrix and response vector, including dimension checks, copying data, and scaling by sqrt of weights. This is a FATAL error about the primary purpose and key outputs, with no accurate claims present and no force multipliers to aid understanding."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 1837504,
    "strip_function_name": "sub_1C09C0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_1C09C0(\n        __int64 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  int v9; // edx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // [rsp+8h] [rbp-130h] BYREF\n  char s[128]; // [rsp+10h] [rbp-128h] BYREF\n  char addr[136]; // [rsp+90h] [rbp-A8h] BYREF\n  unsigned __int64 v23; // [rsp+118h] [rbp-20h]\n\n  v9 = *(_DWORD *)(a1 + 8);\n  v23 = __readfsqword(0x28u);\n  switch ( v9 )\n  {\n    case 2:\n      (*(void (__fastcall **)(__int64, __int64 *, __int64, _QWORD))(a1 + 24))(a1, &v20, 8LL, 0LL);\n      break;\n    case 3:\n      *(double *)a2.m128_u64 = (*(double (__fastcall **)(__int64, char *, __int64, _QWORD))(a1 + 24))(\n                                 a1,\n                                 addr,\n                                 8LL,\n                                 0LL);\n      sub_1B2D70(addr, a2, a3, a4, a5, v11, v12, a8, a9);\n      break;\n    case 1:\n      sub_1C0900(a1, (__int64)s, a2, a3, a4, a5, a6, a7, a8, a9);\n      if ( sscanf(s, \"%127s\", addr) != 1\n        || strcmp(addr, \"NA\")\n        && strcmp(addr, \"NaN\")\n        && (a2 = (__m128)*(unsigned __int64 *)&R_PosInf, strcmp(addr, \"Inf\"))\n        && strcmp(addr, \"-Inf\")\n        && sscanf(addr, \"%lg\", &v20) != 1 )\n      {\n        v13 = (unsigned int)dcgettext(0LL, \"read error\", 5);\n        Rf_error(v13, (__int64)\"read error\", v14, v15, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9);\n      }\n      break;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "function_name": "InReal",
    "decompiled_code": "unsigned __int64 __fastcall InReal(\n        __int64 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  int v9; // edx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  unsigned int v13; // eax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  __int64 v20; // [rsp+8h] [rbp-130h] BYREF\n  char s[128]; // [rsp+10h] [rbp-128h] BYREF\n  char addr[136]; // [rsp+90h] [rbp-A8h] BYREF\n  unsigned __int64 v23; // [rsp+118h] [rbp-20h]\n\n  v9 = *(_DWORD *)(a1 + 8);\n  v23 = __readfsqword(0x28u);\n  switch ( v9 )\n  {\n    case 2:\n      (*(void (__fastcall **)(__int64, __int64 *, __int64, _QWORD, double, double, double, double, double, double, double, double))(a1 + 24))(\n        a1,\n        &v20,\n        8LL,\n        0LL,\n        *(double *)a2.m128_u64,\n        *(double *)a3.m128_u64,\n        *(double *)a4.m128_u64,\n        *(double *)a5.m128_u64,\n        a6,\n        a7,\n        *(double *)a8.m128_u64,\n        *(double *)a9.m128_u64);\n      break;\n    case 3:\n      *(double *)a2.m128_u64 = (*(double (__fastcall **)(__int64, char *, __int64, _QWORD, double, double, double, double, double, double, double, double))(a1 + 24))(\n                                 a1,\n                                 addr,\n                                 8LL,\n                                 0LL,\n                                 *(double *)a2.m128_u64,\n                                 *(double *)a3.m128_u64,\n                                 *(double *)a4.m128_u64,\n                                 *(double *)a5.m128_u64,\n                                 a6,\n                                 a7,\n                                 *(double *)a8.m128_u64,\n                                 *(double *)a9.m128_u64);\n      R_XDRDecodeDouble(addr, a2, a3, a4, a5, v11, v12, a8, a9);\n      break;\n    case 1:\n      InWord_constprop_30(a1, (__int64)s, a2, a3, a4, a5, a6, a7, a8, a9);\n      if ( sscanf(s, \"%127s\", addr) != 1\n        || strcmp(addr, \"NA\")\n        && strcmp(addr, \"NaN\")\n        && (a2 = (__m128)*(unsigned __int64 *)&R_PosInf, strcmp(addr, \"Inf\"))\n        && strcmp(addr, \"-Inf\")\n        && sscanf(addr, \"%lg\", &v20) != 1 )\n      {\n        v13 = (unsigned int)dcgettext(0LL, \"read error\", 5);\n        Rf_error(v13, (__int64)\"read error\", v14, v15, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9);\n      }\n      break;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "source_code": "\nstatic double InReal(R_inpstream_t stream)\n{\n    char word[128];\n    char buf[128];\n    double d;\n\n    switch (stream->type) {\n    case R_pstream_ascii_format:\n\tInWord(stream, word, sizeof(word));\n\tif(sscanf(word, \"%127s\", buf) != 1) error(_(\"read error\"));\n\tif (strcmp(buf, \"NA\") == 0)\n\t    return NA_REAL;\n\telse if (strcmp(buf, \"NaN\") == 0)\n\t    return R_NaN;\n\telse if (strcmp(buf, \"Inf\") == 0)\n\t    return R_PosInf;\n\telse if (strcmp(buf, \"-Inf\") == 0)\n\t    return R_NegInf;\n\telse\n\t    if(\n#ifdef Win32\n\t\ttrio_sscanf(buf, \"%lg\", &d)\n#else\n\t\tsscanf(buf, \"%lg\", &d)\n#endif\n\t\t!= 1) error(_(\"read error\"));\n\treturn d;\n    case R_pstream_binary_format:\n\tstream->InBytes(stream, &d, sizeof(double));\n\treturn d;\n    case R_pstream_xdr_format:\n\tstream->InBytes(stream, buf, R_XDR_DOUBLE_SIZE);\n\treturn R_XDRDecodeDouble(buf);\n    default:\n\treturn NA_REAL;\n    }\n}",
    "comment": "Reads a double value from a specified input stream format (ASCII, binary, or XDR) and handles special cases like NA, NaN, and infinity.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reads an integer from a given input stream in ASCII , binary , or XDR format , returning NA_INTEGER for `` NA '' or on error .\n",
    "cpbcs_sum": "Reads a string from a file, handling special cases for \"NA\" and MPFR floats based on the read parameter.\n",
    "misum_sum": "Reads a double from a connection, handling special cases like integers, and MPFR floats differently and replacing invalid ones on error.\n",
    "decom_sum": "Parses numeric or special string values from input based on type code and handles conversion errors by raising a localized \u201cread error\u201d.",
    "cfg_sum": "Processes and validates numerical or special string inputs, invoking appropriate handlers for types 1\u20133, and throws an error on invalid or unrecognized values.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains only the vague phrase 'push a pointer type,' which does not describe or align with the actual source code behavior of reading doubles from various stream formats. It fails to identify any accurate, fact-based claims about the implementation, resulting in 0% accurate claims.",
                "The summary 'push a pointer type' is vague, does not address the primary purpose of the function, and is unrelated to the source code semantics. The source code reads a double value from different stream formats, handles special constants (NA, NaN, Inf), and processes errors, none of which are captured in the summary. This results in no accurate claims and zero coverage of critical semantic units.",
                "The summary's single claim 'push a pointer type' is unrelated to the source code, which implements reading a double value from different stream formats. This is a NOISE failure, as it does not describe any actual functionality, input/output handling, or side effects from the code. There are no ACCURATE claims, so the net benefit is zero."
            ]
        },
        "bint5": {
            "summary": "Reads an integer from a given input stream in ASCII , binary , or XDR format , returning NA_INTEGER for `` NA '' or on error .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function reads an integer and returns NA_INTEGER, while the source code clearly reads a double and returns NA_REAL. The formats mentioned (ASCII, binary, XDR) are correct, but the data type and special value handling are inaccurately described, resulting in most claims being incorrect.",
                "The summary inaccurately describes the function as reading an integer and returning NA_INTEGER, whereas the source code reads a double and returns NA_REAL, with specific handling for 'NA', 'NaN', 'Inf', and '-Inf'. It also omits key details such as special value parsing, binary and XDR decoding steps, and uses the wrong data type, making the core purpose misrepresented.",
                "The summary contains a FATAL inaccuracy: it claims the function reads an integer and returns NA_INTEGER, while the source code clearly reads a double and returns NA_REAL along with other special double values (NaN, Inf, -Inf). This directly contradicts the primary purpose and key I/O semantics of the code, making the description misleading for understanding its behavior. The most severe issue is the FATAL error concerning the data type and return value, which undermines reliability."
            ]
        },
        "cpbcs": {
            "summary": "Reads a string from a file, handling special cases for \"NA\" and MPFR floats based on the read parameter.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function reads a string from a file and handles special cases for \"NA\" and MPFR floats. While it is accurate that the function handles special cases like \"NA\", \"NaN\", \"Inf\", and \"-Inf\", there is no mention or evidence in the source code of handling MPFR floats, making that claim inaccurate. The summary also inaccurately generalizes the input as from a file, whereas the source handles data from different stream formats. Overall, less than half of the claims are accurate.",
                "The summary misstates the source code\u2019s primary purpose and behavior. The function reads a double from a stream in different formats (ASCII, binary, XDR), handles specific string cases like 'NA', 'NaN', 'Inf', and '-Inf', and uses format-specific parsing, but there is no mention of MPFR floats in the code. It also omits key format handling and error checks, thus missing both the primary purpose and critical secondary details.",
                "The summary claims the function reads a string from a file and handles special cases for 'NA' and MPFR floats based on the read parameter. The source code shows it reads from an input stream, not necessarily a file, and handles 'NA', 'NaN', 'Inf', and '-Inf', with no mention of MPFR floats. The MPFR part is incorrect (FATAL error on key behavior) and the 'file' detail is misleading. The only accurate portion is that special cases are handled, but specifics and correctness are poor, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Reads a double from a connection, handling special cases like integers, and MPFR floats differently and replacing invalid ones on error.\n",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary incorrectly describes handling of integers and MPFR floats, which are not present in the source code. The function specifically reads doubles and handles special string values like 'NA', 'NaN', 'Inf', and '-Inf', with different formats (ASCII, binary, XDR). Only the part about reading a double and handling special cases is accurate, while the rest is inaccurate, leading to less than half of the claims being correct.",
                "The summary incorrectly states that the function handles integers and MPFR floats, which is not present in the source code. The actual implementation reads a double from various stream formats (ASCII, binary, XDR), handles specific string constants like 'NA', 'NaN', 'Inf', and '-Inf', and returns appropriate special values or errors. The summary fails to capture the primary purpose and key secondary details like format-specific branches and error handling, and introduces inaccurate details unrelated to the code.",
                "The summary claims handling of special cases like integers and MPFR floats, which is not present in the source code, making these statements inaccurate and unrelated to actual semantics. The function reads doubles from a stream, with special string cases for NA, NaN, Inf, and binary/XDR formats, but no integer or MPFR-specific logic. These are NOISE and misrepresent behavior, overshadowing any accurate detail. The worst failure mode is NOISE dominance, and there are no specific, accurate force multipliers present."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581761552,
    "strip_function_name": "sub_FFFFFFFF812C8010",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812C8010(\n        _QWORD *a1,\n        __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        unsigned int a5,\n        int a6)\n{\n  __int64 v6; // rdx\n  _QWORD *v7; // rax\n  __int64 result; // rax\n  int v11; // ecx\n  int v12; // r8d\n  int v13; // r9d\n  _QWORD *v14; // rdx\n  __int64 v15; // rdx\n  int v16; // edx\n  int v17; // ecx\n  int v18; // r8d\n  int v19; // r9d\n\n  v6 = ((a2 + 0x160000000000LL) >> 6 << 12) + a3;\n  if ( a5 == 3 )\n    BUG();\n  v7 = (_QWORD *)a1[33];\n  if ( v7 && *v7 >= v6 + a4 - 1 && !dword_FFFFFFFF81E9B810 )\n    return v6;\n  result = sub_FFFFFFFF812C79B0((__int64)a1, qword_FFFFFFFF81E9B850, v6, a4, a5, a6);\n  if ( result == -1 )\n  {\n    LODWORD(v15) = -2120450907;\n    if ( a1 )\n    {\n      v15 = a1[10];\n      if ( !v15 )\n        v15 = a1[2];\n    }\n    sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF819B4830, a4, v15, v11, v12, v13);\n    if ( a4 > 0x8000 )\n    {\n      switch ( a5 )\n      {\n        case 0u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA accessed\\n\", a4, v16, v17, v18, v19);\n        case 2u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA written\\n\", a4, v16, v17, v18, v19);\n        case 1u:\n          sub_FFFFFFFF8178A51B((unsigned int)\"DMA: Random memory could be DMA read\\n\", a4, v16, v17, v18, v19);\n      }\n    }\n    return qword_FFFFFFFF81E9B838;\n  }\n  v14 = (_QWORD *)a1[33];\n  if ( !v14 || result + a4 - 1 > *v14 )\n  {\n    sub_FFFFFFFF812C7C70((__int64)a1, result, a4, a5);\n    return qword_FFFFFFFF81E9B838;\n  }\n  return result;\n}\n",
    "function_name": "swiotlb_map_page",
    "decompiled_code": "__int64 __fastcall swiotlb_map_page(\n        _QWORD *a1,\n        __int64 a2,\n        __int64 a3,\n        unsigned __int64 a4,\n        unsigned int a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  __int64 v13; // rdx\n  _QWORD *v14; // rax\n  __int64 result; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  _QWORD *v20; // rdx\n  char *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v13 = ((a2 + 0x160000000000LL) >> 6 << 12) + a3;\n  if ( a5 == 3 )\n    BUG();\n  v14 = (_QWORD *)a1[33];\n  if ( v14 && *v14 >= v13 + a4 - 1 && !swiotlb_force )\n    return v13;\n  result = swiotlb_tbl_map_single((__int64)a1, io_tlb_start, v13, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( result == -1 )\n  {\n    v21 = \"?\";\n    if ( a1 )\n    {\n      v21 = (char *)a1[10];\n      if ( !v21 )\n        v21 = (char *)a1[2];\n    }\n    printk((__int64)&unk_FFFFFFFF819B4830, a6, a7, a8, a9, v18, v19, a12, a13, a4, v21);\n    if ( a4 > 0x8000 )\n    {\n      switch ( a5 )\n      {\n        case 0u:\n          panic((__int64)\"DMA: Random memory could be DMA accessed\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n        case 2u:\n          panic((__int64)\"DMA: Random memory could be DMA written\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n        case 1u:\n          panic((__int64)\"DMA: Random memory could be DMA read\\n\", a6, a7, a8, a9, v22, v23, a12, a13);\n      }\n    }\n    return io_tlb_overflow_buffer;\n  }\n  v20 = (_QWORD *)a1[33];\n  if ( !v20 || result + a4 - 1 > *v20 )\n  {\n    swiotlb_tbl_unmap_single((__int64)a1, result, a4, a5);\n    return io_tlb_overflow_buffer;\n  }\n  return result;\n}\n",
    "source_code": "dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    struct dma_attrs *attrs)\n{\n\tphys_addr_t map, phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (dma_capable(dev, dev_addr, size) && !swiotlb_force)\n\t\treturn dev_addr;\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\tmap = map_single(dev, phys, size, dir);\n\tif (map == SWIOTLB_MAP_ERROR) {\n\t\tswiotlb_full(dev, size, dir, 1);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\tdev_addr = phys_to_dma(dev, map);\n\n\t/* Ensure that the address returned is DMA'ble */\n\tif (!dma_capable(dev, dev_addr, size)) {\n\t\tswiotlb_tbl_unmap_single(dev, map, size, dir);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\treturn dev_addr;\n}",
    "comment": "Maps a page of memory for DMA access, handling bounce buffers if the device cannot directly access the address.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Allocates memory for a resource within a specified range , ensuring alignment and checking for existing resources before returning the new address .\n",
    "cpbcs_sum": "Maps a physical address to a device, checking for valid range conflicts with existing PCI IDs and handling errors accordingly.\n",
    "misum_sum": "Checks if an NFS page is within allowed for the specified address range in NFS pages, checking for resource availability and memory allocation errors.\n",
    "decom_sum": "Validates and maps a memory range for DMA access based on type and size, logging warnings and invoking handlers on failure or unsafe conditions.",
    "cfg_sum": "Validates and initializes a DMA memory mapping for a given address range, triggering errors or warnings on invalid access types or size violations.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' is overly vague and does not accurately reflect the source code, which implements a DMA mapping function with bounce buffer handling and address capability checks. The claim does not target the actual code semantics, making it irrelevant and inaccurate.",
                "The summary 'push a pointer type.' is vague, does not reference or describe the actual functionality of the swiotlb_map_page function, and fails to capture its primary purpose of mapping a page for DMA with bounce buffer handling. It does not convey any accurate or relevant fact-based claims tied to the source code\u2019s observable behavior or secondary details.",
                "The summary 'push a pointer type.' is unrelated to the actual function's purpose and implementation. It introduces NOISE by failing to describe any of the DMA mapping logic, device address checks, or bounce buffer handling in the source code. There are no accurate claims, and the worst failure mode is excessive NOISE, making the summary uninformative."
            ]
        },
        "bint5": {
            "summary": "Allocates memory for a resource within a specified range , ensuring alignment and checking for existing resources before returning the new address .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function allocates memory within a specified range, ensures alignment, and checks for existing resources before returning a new address. In the source code, the function maps a page for DMA, checks DMA capability, and uses a bounce buffer if necessary, but there is no explicit resource range allocation, alignment logic, or pre-existing resource check. The claims do not accurately describe the implementation, resulting in a low proportion of accurate statements.",
                "The summary inaccurately describes the function as allocating memory within a specified range and ensuring alignment, which is not reflected in the source code. The actual function maps a page for DMA, checks if it can directly use the device address, and otherwise allocates and maps a bounce buffer with error handling. Key elements such as DMA capability checks, bounce buffer allocation, error paths, and address conversions are all missing or misrepresented in the summary, and the primary purpose is not correctly captured.",
                "The summary claims the function allocates memory within a specified range, ensures alignment, and checks for existing resources before returning a new address. These details do not match the source code semantics. The function maps a page for DMA, potentially using bounce buffers, checks DMA capability, and handles errors, but it does not perform arbitrary resource allocation, alignment enforcement, or check for pre-existing resources. This is a FATAL inaccuracy about the primary purpose of the function, significantly misrepresenting the I/O behavior and intent."
            ]
        },
        "cpbcs": {
            "summary": "Maps a physical address to a device, checking for valid range conflicts with existing PCI IDs and handling errors accordingly.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims address mapping to a device, which aligns broadly with the function's purpose, but introduces an inaccurate detail about checking for range conflicts with existing PCI IDs, which is not present in the source code. It also omits key steps from the implementation, such as bounce buffer allocation, DMA capability checks, and overflow handling. The majority of the claims are either inaccurate or too vague to be verified, resulting in low alignment.",
                "The summary incorrectly states that the function checks for PCI ID conflicts, which is not present in the source code. The source code maps a physical address to a DMA address, verifies DMA capability, optionally uses a bounce buffer, and handles mapping errors. While the summary loosely touches on mapping an address to a device, it misses the primary purpose related to DMA mapping and omits handling bounce buffers and specific error cases, making most of its claims inaccurate.",
                "The summary contains a FATAL inaccuracy: it claims to check for valid range conflicts with existing PCI IDs, which is not present in the source code. The actual implementation checks DMA capability and may use a bounce buffer if necessary, without any PCI ID logic. This incorrect focus on PCI conflicts misrepresents the primary purpose of the function, which is central to its key I/O behavior. The summary also omits accurate specifics about mapping and error handling, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Checks if an NFS page is within allowed for the specified address range in NFS pages, checking for resource availability and memory allocation errors.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as working with NFS pages and address ranges, whereas the source code handles DMA mapping for a given page, offset, and size, involving bounce buffers and capability checks. None of the fact-based claims align with the actual semantics of the provided implementation, resulting in no accurate matches.",
                "The summary is inaccurate because it refers to NFS pages, address range validation, and resource checks, none of which are present in the source code. The function in the source code maps a page for DMA using swiotlb, checks DMA capabilities, applies bounce buffering when necessary, and handles mapping errors. The primary purpose and key secondary details from the source are not captured at all, so completeness is zero.",
                "The summary's claims are inaccurate. It states the function checks NFS page address ranges, resource availability, and memory allocation errors, which contradicts the source code. The actual code maps a physical page for DMA, checks DMA capability, and handles bounce buffering; NFS is unrelated. This is a FATAL error affecting the primary purpose, as the main function's role is misrepresented."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578866352,
    "strip_function_name": "sub_FFFFFFFF810052B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810052B0(int a1, __int64 a2, void *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v4; // rbx\n  __int64 v5; // r14\n  __int64 v6; // r15\n  void *v7; // rax\n  int v8; // eax\n  __int64 v9; // r14\n  unsigned __int64 v10; // r13\n\n  if ( a1 == 1 )\n    return sub_FFFFFFFF81004E80(a2, (__int64)a3, 1);\n  if ( a1 > 1 )\n  {\n    if ( a1 != 2 )\n    {\n      if ( a1 == 17 )\n        return sub_FFFFFFFF81004E80(a2, (__int64)a3, 0);\n      return 4294967258LL;\n    }\n    v4 = 128LL;\n    if ( (unsigned __int64)a3 <= 0x80 )\n      v4 = (unsigned __int64)a3;\n    if ( !sub_FFFFFFFF812BA5B0(a2, v4) )\n      return (unsigned int)v4;\n    return 4294967282LL;\n  }\n  if ( a1 )\n    return 4294967258LL;\n  v5 = *(_QWORD *)(__readgsqword(0xA7C0u) + 616);\n  result = 0LL;\n  if ( *(_DWORD *)(v5 + 744) )\n  {\n    v6 = v5 + 752;\n    v7 = &unk_10000;\n    if ( a3 <= &unk_10000 )\n      v7 = a3;\n    v4 = (unsigned __int64)v7;\n    sub_FFFFFFFF8178F210(v5 + 752);\n    v8 = *(_DWORD *)(v5 + 744);\n    v9 = *(_QWORD *)(v5 + 736);\n    v10 = 8 * v8;\n    if ( v10 > v4 )\n      v10 = v4;\n    sub_FFFFFFFF81790F30();\n    if ( (unsigned int)sub_FFFFFFFF812B8AE0(a2, v9, (unsigned int)v10) )\n    {\n      sub_FFFFFFFF8178F1B0(v6);\n    }\n    else\n    {\n      sub_FFFFFFFF8178F1B0(v6);\n      if ( v10 == v4 )\n        return (unsigned int)v4;\n      if ( !sub_FFFFFFFF812BA5B0(a2 + v10, v4 - v10) )\n        return (unsigned int)v4;\n    }\n    return 4294967282LL;\n  }\n  return result;\n}\n",
    "function_name": "sys_modify_ldt",
    "decompiled_code": "__int64 __fastcall sys_modify_ldt(\n        int a1,\n        _QWORD *a2,\n        void *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  void *v14; // rbx\n  __int64 v15; // r14\n  __int64 v16; // r15\n  void *v17; // rax\n  __int64 v18; // rdi\n  int v19; // eax\n  __int64 v20; // r14\n  unsigned __int64 v21; // r13\n\n  if ( a1 == 1 )\n    return write_ldt((__int64)a2, (__int64)a3, 1, a4, a5, a6, a7, a8, a9, a10, a11);\n  if ( a1 > 1 )\n  {\n    if ( a1 != 2 )\n    {\n      if ( a1 == 17 )\n        return write_ldt((__int64)a2, (__int64)a3, 0, a4, a5, a6, a7, a8, a9, a10, a11);\n      return 4294967258LL;\n    }\n    v14 = &unk_80;\n    if ( (unsigned __int64)a3 <= 0x80 )\n      v14 = a3;\n    if ( !clear_user(a2, (unsigned __int64)v14) )\n      return (unsigned int)v14;\n    return 4294967282LL;\n  }\n  if ( a1 )\n    return 4294967258LL;\n  v15 = *(_QWORD *)(__readgsqword(0xA7C0u) + 616);\n  result = 0LL;\n  if ( *(_DWORD *)(v15 + 744) )\n  {\n    v16 = v15 + 752;\n    v17 = &unk_10000;\n    if ( a3 <= &unk_10000 )\n      v17 = a3;\n    v18 = v15 + 752;\n    v14 = v17;\n    mutex_lock(v15 + 752);\n    v19 = *(_DWORD *)(v15 + 744);\n    v20 = *(_QWORD *)(v15 + 736);\n    v21 = 8 * v19;\n    if ( v21 > (unsigned __int64)v14 )\n      v21 = (unsigned __int64)v14;\n    cond_resched(v18, (__int64)a3);\n    if ( (unsigned int)copy_to_user((__int64)a2, v20, (unsigned int)v21) )\n    {\n      mutex_unlock(v16);\n    }\n    else\n    {\n      mutex_unlock(v16);\n      if ( (void *)v21 == v14 )\n        return (unsigned int)v14;\n      if ( !clear_user((_QWORD *)((char *)a2 + v21), (unsigned __int64)v14 - v21) )\n        return (unsigned int)v14;\n    }\n    return 4294967282LL;\n  }\n  return result;\n}\n",
    "source_code": "\nasmlinkage int sys_modify_ldt(int func, void __user *ptr,\n\t\t\t      unsigned long bytecount)\n{\n\tint ret = -ENOSYS;\n\n\tswitch (func) {\n\tcase 0:\n\t\tret = read_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 1:\n\t\tret = write_ldt(ptr, bytecount, 1);\n\t\tbreak;\n\tcase 2:\n\t\tret = read_default_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 0x11:\n\t\tret = write_ldt(ptr, bytecount, 0);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "comment": "The function modifies the local descriptor table (LDT) by reading or writing its entries based on the specified operation code.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sets the floating-point registers of a target task based on the CPU 's FPU capability and copies them to user space .\n",
    "cpbcs_sum": "Sets the CPU affinity for a specified task if the provided value is a valid and the conditions are met.\n",
    "misum_sum": "Retrieves the program counter for a specified task and copies it to user space, handling both system call and stack unwinding.\n",
    "decom_sum": "Processes commands to transfer data between a memory buffer and a target address, handling specific command types, size limits, and error conditions.",
    "cfg_sum": "Processes commands based on the request type to transfer data or validate memory regions, returning success length or specific error codes accordingly.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only a vague statement about pushing a pointer type, which does not accurately describe any of the specific functionality or semantics present in the source code. It fails to capture the system call implementation, the switch-case handling of different func values, or the read/write LDT logic, making it irrelevant and not fact-based in relation to the code.",
                "The summary's sole claim 'push a pointer type' does not address the source code's primary purpose of handling different LDT modification functions based on the value of 'func', nor does it mention any secondary details like specific function calls, return values, or constants. It is unrelated to the semantics of the code and thus offers no accurate coverage.",
                "The summary contains only a vague phrase ('push a pointer type') that does not accurately describe the function's purpose, logic, or I/O from the source code. It introduces NOISE with no factual alignment to the code's sys_modify_ldt implementation. There are no ACCURATE claims, resulting in zero net benefit and unreliable guidance."
            ]
        },
        "bint5": {
            "summary": "Sets the floating-point registers of a target task based on the CPU 's FPU capability and copies them to user space .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes setting floating-point registers based on FPU capability and copying them to user space, which is unrelated to the source code that handles different operations on the Local Descriptor Table (LDT) via read and write functions. All claims in the summary are inaccurate, as they do not reflect the code's purpose or functionality.",
                "The summary describes setting floating-point registers and copying them to user space, which does not align with the source code. The source implements sys_modify_ldt to read or write LDT entries based on a function code, with no reference to FPU or floating-point registers. This is a clear contradiction, missing the primary purpose entirely and containing only inaccurate claims.",
                "The summary's claim about setting floating-point registers and copying them to user space is completely unrelated to the source code, which handles modifying the LDT based on a function code with cases for reading and writing LDT entries. This is a NOISE error that targets the wrong semantics, resulting in zero alignment with the primary purpose. The worst failure mode is overwhelming NOISE, with no accurate claims present, hence no useful insight for understanding the code."
            ]
        },
        "cpbcs": {
            "summary": "Sets the CPU affinity for a specified task if the provided value is a valid and the conditions are met.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims functionality about setting CPU affinity, which is unrelated to the source code that handles modifying the local descriptor table via different function codes. None of the summary's claims match the source code's semantics, making them inaccurate.",
                "The summary's claim about setting CPU affinity for a task does not match the source code, which handles modifying the Local Descriptor Table via various read/write functions based on the 'func' argument. This is a direct contradiction to the implementation's primary purpose, meaning the claim is inaccurate and fails to capture any correct semantic details.",
                "The summary claims the function sets CPU affinity for a specified task, which directly contradicts the source code. The source code implements sys_modify_ldt, handling functions to read or write the Local Descriptor Table, unrelated to CPU affinity. This is a FATAL error, as it misidentifies the primary purpose and key I/O behavior of the function, providing no accurate claims."
            ]
        },
        "misum": {
            "summary": "Retrieves the program counter for a specified task and copies it to user space, handling both system call and stack unwinding.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves a program counter for a specified task and copies it to user space, handling system call and stack unwinding. The source code clearly shows sys_modify_ldt, which reads or writes the Local Descriptor Table based on the func parameter and does not involve fetching a program counter or handling stack unwinding. All extracted claims are inaccurate and contradict source code semantics, resulting in no alignment with the actual implementation.",
                "The summary describes retrieving a program counter and copying it to user space with stack unwinding, which is entirely unrelated to the source code. The source implements sys_modify_ldt, handling different LDT read/write operations based on the func argument, returning results accordingly. The primary purpose is completely missed and none of the secondary details from the code are covered.",
                "The summary claims that the function retrieves the program counter for a specified task and copies it to user space, involving system call and stack unwinding, which is entirely unrelated to the source code. The source implements sys_modify_ldt, switching on function codes to read or write the Local Descriptor Table, with no mention of program counters or stack unwinding. This is a FATAL error on the primary purpose, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583707408,
    "strip_function_name": "sub_FFFFFFFF814A3110",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814A3110(\n        __int64 a1,\n        int a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v12; // eax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n\n  if ( a2 != 1 )\n  {\n    if ( a2 != 2 )\n    {\n      sub_FFFFFFFF813EE640(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        \"usb_set_lpm_timeout\");\n      return 4294967274LL;\n    }\n    v12 = sub_FFFFFFFF814A2E70(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            0x18u);\n    if ( v12 >= 0 )\n    {\n      *(_DWORD *)(a1 + 1028) = a3;\n      return 0LL;\n    }\n    goto LABEL_8;\n  }\n  if ( a3 != 255 && (int)a3 > 127 )\n  {\n    sub_FFFFFFFF813EE640(\n      (_QWORD *)(a1 + 136),\n      (__int64)\"Failed to set %s timeout to 0x%x, which is a reserved value.\\n\",\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      \"U1\",\n      a3);\n    return 4294967274LL;\n  }\n  else\n  {\n    v12 = sub_FFFFFFFF814A2E70(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            0x17u);\n    if ( v12 < 0 )\n    {\nLABEL_8:\n      sub_FFFFFFFF813EE640(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"Failed to set %s timeout to 0x%x,error code %i\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        v13,\n        v14,\n        a10,\n        a11,\n        off_FFFFFFFF81889200[a2],\n        a3,\n        (unsigned int)v12);\n      return 4294967280LL;\n    }\n    *(_DWORD *)(a1 + 1012) = a3;\n    return 0LL;\n  }\n}\n",
    "function_name": "usb_set_lpm_timeout",
    "decompiled_code": "__int64 __fastcall usb_set_lpm_timeout(\n        __int64 a1,\n        int a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v12; // eax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n\n  if ( a2 != 1 )\n  {\n    if ( a2 != 2 )\n    {\n      dev_warn(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        a8,\n        a9,\n        a10,\n        a11,\n        \"usb_set_lpm_timeout\");\n      return 4294967274LL;\n    }\n    v12 = set_port_feature(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            24,\n            a4,\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11);\n    if ( v12 >= 0 )\n    {\n      *(_DWORD *)(a1 + 1028) = a3;\n      return 0LL;\n    }\n    goto LABEL_8;\n  }\n  if ( a3 != 255 && (int)a3 > 127 )\n  {\n    dev_warn(\n      (_QWORD *)(a1 + 136),\n      (__int64)\"Failed to set %s timeout to 0x%x, which is a reserved value.\\n\",\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11,\n      \"U1\",\n      a3);\n    return 4294967274LL;\n  }\n  else\n  {\n    v12 = set_port_feature(\n            *(_DWORD **)(a1 + 56),\n            *(unsigned __int8 *)(a1 + 890) | (unsigned __int16)((_WORD)a3 << 8),\n            23,\n            a4,\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11);\n    if ( v12 < 0 )\n    {\nLABEL_8:\n      dev_warn(\n        (_QWORD *)(a1 + 136),\n        (__int64)\"Failed to set %s timeout to 0x%x,error code %i\\n\",\n        a4,\n        a5,\n        a6,\n        a7,\n        v13,\n        v14,\n        a10,\n        a11,\n        usb3_lpm_names[a2],\n        a3,\n        (unsigned int)v12);\n      return 4294967280LL;\n    }\n    *(_DWORD *)(a1 + 1012) = a3;\n    return 0LL;\n  }\n}\n",
    "source_code": "\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}",
    "comment": "Sets the low power mode timeout for a USB device based on the specified USB 3.0 link state, validating the timeout value before applying it.",
    "hext5_sum": "one. do not maintain a hash table. (it will be regenerated if this run of deflate switches away from z_rle.) =========================================================================== for z_rle, simply look for runs of bytes, generate matches only of distance",
    "bint5_sum": "Sets the LPM timeout for USB devices in U1 or U2 states while adjusting the device 's timeout value accordingly .\n",
    "cpbcs_sum": "Configures a USB interface by enabling or disabling it based on the specified port type and handles errors for invalid devices.\n",
    "misum_sum": "Sets the USB interface descriptor and flag in the OHCI controller, handling errors if the device is already set.\n",
    "decom_sum": "Sets the USB device\u2019s U1 or U2 power state timeout, validating values and reporting errors for invalid states or failed hardware commands.",
    "cfg_sum": "Sets USB U1 or U2 power state timeout after validating parameters, invoking a configuration command, and logging errors with appropriate status codes on failure.",
    "work_score": {
        "hext5": {
            "summary": "one. do not maintain a hash table. (it will be regenerated if this run of deflate switches away from z_rle.) =========================================================================== for z_rle, simply look for runs of bytes, generate matches only of distance",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary discusses hash table maintenance and z_rle compression behavior, which are unrelated to the source code that handles USB 3.0 Link Power Management timeout settings for U1 and U2 states. All claims fail to reflect the semantics of the given function, resulting in no accurate matches.",
                "The summary is entirely unrelated to the source code, describing hash table behavior and z_rle compression instead of the USB LPM timeout setting logic in the code. It fails to capture the primary purpose or any secondary details such as handling U1/U2 states, timeouts, reserved values, or error codes.",
                "The summary contains statements about z_rle compression, hash tables, and runs of bytes, which are unrelated to the usb_set_lpm_timeout function in the source code. There are no accurate claims about the code\u2019s purpose, inputs, outputs, or behavior. The content is entirely NOISE, overwhelming the evaluation with irrelevant details and offering no useful insight for understanding the source implementation."
            ]
        },
        "bint5": {
            "summary": "Sets the LPM timeout for USB devices in U1 or U2 states while adjusting the device 's timeout value accordingly .\n",
            "score": [
                1.0,
                0.5,
                0.5
            ],
            "reason": [
                "The summary makes two key claims: that the function sets the LPM timeout for USB devices in U1 or U2 states, and that it adjusts the device's timeout value accordingly. Both claims align with the source code, which sets timeouts specifically for U1 and U2 states, and updates the corresponding timeout fields in udev. No contradictions or irrelevant information are present, making all claims accurate.",
                "The summary correctly identifies the primary purpose of setting the LPM timeout for USB devices in U1 or U2 states and notes that the device's timeout value is adjusted accordingly. However, it omits important secondary details from the source code, such as handling invalid states with warnings and specific error codes, reserved timeout value checks, the use of different feature constants for U1 and U2, and updates to separate u1_params or u2_params fields. These omissions reduce completeness despite correctly capturing the main function behavior.",
                "The summary correctly states that the function sets the LPM timeout for USB devices in U1 or U2 states and adjusts the device's timeout value, which matches the source code behavior. However, it omits specific constraints, warnings, and error handling present in the code, making the claim broad and low-detail. There are no factual inaccuracies or contradictions, but the lack of specificity limits usefulness, resulting in a safe yet low-gain output. The worst failure mode is low gain due to broadness rather than noise or fatal errors."
            ]
        },
        "cpbcs": {
            "summary": "Configures a USB interface by enabling or disabling it based on the specified port type and handles errors for invalid devices.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function configures a USB interface by enabling or disabling it based on port type and handles errors for invalid devices, which is inaccurate. The source code specifically sets LPM timeouts for USB3 U1/U2 link states, validates timeout values, and handles errors for unsupported states or failed feature settings, not enabling/disabling interfaces or checking for invalid devices. None of the summary\u2019s claims closely match the code semantics, resulting in low alignment.",
                "The summary is inaccurate because it describes enabling or disabling a USB interface based on port type, which is not the function's purpose. The source code sets Link Power Management (LPM) timeouts for USB3 U1 or U2 states, with specific checks for reserved values and error handling. The primary purpose and key details like valid states, constants, and specific error codes are entirely missed, resulting in no accurate claim coverage.",
                "The summary incorrectly describes the function as enabling or disabling a USB interface based on port type, which contradicts the source code. The actual implementation sets LPM timeout values for USB3 U1 or U2 states and validates them, returning errors for invalid states or reserved timeouts. This is a FATAL error regarding the primary purpose of the function, as it misrepresents core I/O behavior and key side effects. No accurate claims are present, resulting in high negative impact and zero reliable insight."
            ]
        },
        "misum": {
            "summary": "Sets the USB interface descriptor and flag in the OHCI controller, handling errors if the device is already set.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function sets a USB interface descriptor and flag in the OHCI controller and handles errors if the device is already set. In reality, the code sets LPM timeouts for USB3 U1/U2 states on a usb_device, checks for reserved values, and handles errors from set_port_feature. The summary is entirely unrelated to the implementation, making all claims inaccurate.",
                "The summary describes setting a USB interface descriptor and flag in an OHCI controller with error handling for already set devices, which is unrelated to the actual source code. The source code sets the LPM timeout for USB3 U1/U2 states, validates parameters, and updates device timeout attributes, with specific error handling. The summary fails to capture the primary purpose or any secondary details, making it entirely inaccurate.",
                "The summary describes setting a USB interface descriptor and flag in an OHCI controller with error handling for an already set device, which is unrelated to the actual function's purpose of setting USB3 LPM timeout values for U1 or U2 states. This is a complete mismatch with the source code semantics, making it a FATAL error affecting the primary purpose. No accurate claims are present, resulting in high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586047952,
    "strip_function_name": "sub_FFFFFFFF816DE7D0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF816DE7D0(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r13\n  __int64 v11; // rax\n  __int64 v12; // rbx\n  __int64 v13; // rax\n  unsigned int v14; // edi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n\n  v10 = -12LL;\n  v11 = sub_FFFFFFFF8112CA50((_QWORD *)qword_FFFFFFFF81E8C710, 0x50u, 160LL, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( !v11 )\n    return v10;\n  v12 = v11;\n  v10 = v11;\n  sub_FFFFFFFF816DD6B0(v11, (unsigned int *)a2, a1, (__int64)&off_FFFFFFFF818D0040);\n  *(_QWORD *)(v12 + 72) = 2LL;\n  v13 = *(_QWORD *)(a2 + 8);\n  if ( !v13 )\n  {\n    v16 = 0LL;\n    *(_DWORD *)(v12 + 88) = *(_DWORD *)(a2 + 4);\n    goto LABEL_8;\n  }\n  v14 = *(_DWORD *)(v13 + 4);\n  *(_DWORD *)(v12 + 88) = *(_DWORD *)(a2 + 4);\n  if ( v14 <= 0x10 )\n  {\n    if ( v14 )\n      goto LABEL_5;\n    v16 = 0LL;\nLABEL_8:\n    *(_DWORD *)(v12 + 4 * v16 + 92) = -1;\n    return v10;\n  }\n  v14 = 16;\nLABEL_5:\n  v15 = 0LL;\n  LODWORD(v16) = 0;\n  do\n  {\n    v16 = (unsigned int)(v16 + 1);\n    *(_DWORD *)(v12 + v15 + 92) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 144LL) + v15);\n    v15 += 4LL;\n  }\n  while ( (unsigned int)v16 < v14 );\n  if ( (_DWORD)v16 != 16 )\n    goto LABEL_8;\n  return v10;\n}\n",
    "function_name": "unx_create_cred",
    "decompiled_code": "__int64 __fastcall unx_create_cred(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // r13\n  __int64 *v11; // rax\n  __int64 *v12; // rbx\n  __int64 v13; // rax\n  unsigned int v14; // edi\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n\n  v10 = -12LL;\n  v11 = kmem_cache_alloc_trace((__int64 *)qword_FFFFFFFF81E8C710, 80LL, 160LL, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( !v11 )\n    return v10;\n  v12 = v11;\n  v10 = (__int64)v11;\n  rpcauth_init_cred((__int64)v11, (unsigned int *)a2, a1, (__int64)&unix_credops);\n  v12[9] = 2LL;\n  v13 = *(_QWORD *)(a2 + 8);\n  if ( !v13 )\n  {\n    v16 = 0LL;\n    *((_DWORD *)v12 + 22) = *(_DWORD *)(a2 + 4);\n    goto LABEL_8;\n  }\n  v14 = *(_DWORD *)(v13 + 4);\n  *((_DWORD *)v12 + 22) = *(_DWORD *)(a2 + 4);\n  if ( v14 <= 0x10 )\n  {\n    if ( v14 )\n      goto LABEL_5;\n    v16 = 0LL;\nLABEL_8:\n    *((_DWORD *)v12 + v16 + 23) = -1;\n    return v10;\n  }\n  v14 = 16;\nLABEL_5:\n  v15 = 0LL;\n  LODWORD(v16) = 0;\n  do\n  {\n    v16 = (unsigned int)(v16 + 1);\n    *(_DWORD *)((char *)v12 + v15 + 92) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 144LL) + v15);\n    v15 += 4LL;\n  }\n  while ( (unsigned int)v16 < v14 );\n  if ( (_DWORD)v16 != 16 )\n    goto LABEL_8;\n  return v10;\n}\n",
    "source_code": "\nstatic struct rpc_cred *\nunx_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\n{\n\tstruct unx_cred\t*cred;\n\tunsigned int groups = 0;\n\tunsigned int i;\n\n\tdprintk(\"RPC:       allocating UNIX cred for uid %d gid %d\\n\",\n\t\t\tfrom_kuid(&init_user_ns, acred->uid),\n\t\t\tfrom_kgid(&init_user_ns, acred->gid));\n\n\tif (!(cred = kmalloc(sizeof(*cred), GFP_NOFS)))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpcauth_init_cred(&cred->uc_base, acred, auth, &unix_credops);\n\tcred->uc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\n\n\tif (acred->group_info != NULL)\n\t\tgroups = acred->group_info->ngroups;\n\tif (groups > NFS_NGROUPS)\n\t\tgroups = NFS_NGROUPS;\n\n\tcred->uc_gid = acred->gid;\n\tfor (i = 0; i < groups; i++)\n\t\tcred->uc_gids[i] = GROUP_AT(acred->group_info, i);\n\tif (i < NFS_NGROUPS)\n\t\tcred->uc_gids[i] = INVALID_GID;\n\n\treturn &cred->uc_base;\n}",
    "comment": "Allocates and initializes a UNIX credential structure with user and group identifiers based on provided authentication credentials.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Creates and initializes an RPC credential structure for RPC authentication using provided user and group credentials .\n",
    "cpbcs_sum": "Creates and initializes a GSS credential structure for IPv6 by allocating a socket and configuring the associated IP address and comparison functions.\n",
    "misum_sum": "Registers an RPC client with the specified network namespace and sets up the corresponding net sysctl table in the net namespace.\n",
    "decom_sum": "Allocates and initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a provided data block, and updates defaults.",
    "cfg_sum": "Allocates and initializes a structured object from input parameters, copies related data arrays, and sets default values when optional input data is absent.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains a vague and low-information claim ('push a pointer type') that does not accurately reflect the semantics or operations in the source code. It does not capture any specific fact about credential allocation, initialization, or group handling shown in the source, making it entirely irrelevant to the actual implementation.",
                "The summary 'push a pointer type' is vague, does not capture the primary purpose of the function, and does not align with the source code's actual behavior of allocating and initializing a UNIX RPC credential with user and group information. It fails to mention any critical details such as memory allocation, initialization routines, limits on group count, or returned pointer semantics.",
                "The summary contains only a vague phrase that does not describe any specific fact-based claim from the source code. It does not address the function's purpose, input/output, or internal logic, making it pure NOISE. There are no accurate claims present, and the lack of useful information means there is no positive gain."
            ]
        },
        "bint5": {
            "summary": "Creates and initializes an RPC credential structure for RPC authentication using provided user and group credentials .\n",
            "score": [
                1.0,
                0.5,
                0.5
            ],
            "reason": [
                "The summary makes a single broad claim that the function creates and initializes an RPC credential for authentication using supplied user and group credentials. This aligns with the source code, which allocates a UNIX credential structure, initializes it with user (uid/gid) and group information, and sets appropriate flags. The claim is accurate, though it lacks finer details, making it safe but not highly specific.",
                "The summary correctly identifies the primary purpose of the function as creating and initializing an RPC credential structure for authentication using user and group credentials, which matches the source code. However, it omits important secondary details such as allocation of memory with kmalloc, error handling for memory allocation failure, setting of specific flags, limiting groups to NFS_NGROUPS, initializing gids including INVALID_GID for unused slots, and calling rpcauth_init_cred. These omissions reduce completeness despite accurate primary purpose coverage.",
                "The summary's single claim \u2014 that the function creates and initializes an RPC credential structure for authentication using provided user and group credentials \u2014 is broadly correct and aligns with the code's actual behavior. This is a SAFE, low-info statement without contradictions, covering the primary purpose but lacking specific implementation details such as group limits or memory allocation method. No FATAL errors are present, but the gain is low due to its generic nature."
            ]
        },
        "cpbcs": {
            "summary": "Creates and initializes a GSS credential structure for IPv6 by allocating a socket and configuring the associated IP address and comparison functions.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims that the function creates and initializes a GSS credential for IPv6 by allocating a socket and configuring IP-related functionality, which is entirely inconsistent with the source code. The source code actually allocates and initializes a UNIX RPC credential, sets credential flags, assigns gids from group_info, and uses unrelated RPC authentication operations. None of the summary's core claims match the implementation, resulting in no accurate claims.",
                "The summary is entirely inaccurate as it describes creation of a GSS credential for IPv6 involving socket allocation and IP configuration, which is unrelated to the source code. The source code actually allocates and initializes a UNIX RPC credential structure and sets group information. The primary purpose and all secondary details from the source are missed, resulting in no alignment.",
                "The summary claims the function creates and initializes a GSS credential for IPv6 with socket allocation and IP configuration, which directly contradicts the source code. The source code instead allocates and initializes a UNIX RPC credential based on user and group information, with no networking or IPv6 aspects. This is a FATAL error targeting the primary purpose, making the summary highly misleading and unusable."
            ]
        },
        "misum": {
            "summary": "Registers an RPC client with the specified network namespace and sets up the corresponding net sysctl table in the net namespace.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes registering an RPC client and setting up a sysctl table in a network namespace, which is unrelated to the source code. The source function allocates and initializes a UNIX RPC credential based on provided UID, GID, and group info, without any operations on RPC client registration or network namespaces. All claims are inaccurate and do not match the code semantics.",
                "The summary is entirely inaccurate; it describes registering an RPC client and setting up a net sysctl table in a network namespace, which has no relation to the source code. The actual function allocates and initializes a UNIX RPC credential, sets credential flags, copies group IDs with a limit, and handles allocation errors. The primary purpose and all key secondary details of the source are missed, and none of the claims map to the source code's semantics.",
                "The summary's sole claim about registering an RPC client and setting up a net sysctl table is unrelated to the source, which actually allocates and initializes a UNIX RPC credential based on provided UID, GID, and group info. This is a FATAL inaccuracy affecting the primary purpose, causing high negative impact. No accurate claims are present to offset the error."
            ]
        }
    }
}
{
    "project_name": "inetutils",
    "function_addr": 4228896,
    "strip_function_name": "sub_408720",
    "strip_decompiled_code": "void sub_408720()\n{\n  struct sockaddr *v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // [rsp-8h] [rbp-10h]\n\n  sub_408600(211, \"%s FTP server status:\", (const char *)qword_624A28);\n  if ( !dword_624EC4 )\n    printf(\"     ftpd (%s) %s\\r\\n\", \"GNU inetutils\", \"1.9.4\");\n  printf(\"     Connected to %s\", ptr);\n  getnameinfo(&unk_624A40, addr_len, host, 0x401u, 0LL, 0, 1);\n  if ( ((*__ctype_b_loc())[*ptr] & 0x800) == 0 )\n    printf(\" (%s)\", host);\n  puts(\"\\r\");\n  printf(\"     Session timeout is %d seconds\\r\\n\", seconds);\n  if ( dword_624F30 )\n  {\n    if ( (_DWORD)qword_624F28 )\n      puts(\"     Logged in anonymously\\r\");\n    else\n      printf(\"     Logged in as %s\\r\\n\", user);\n  }\n  else if ( dword_624504 )\n  {\n    puts(\"     Waiting for password\\r\");\n  }\n  else\n  {\n    puts(\"     Waiting for user name\\r\");\n  }\n  printf(\"     TYPE: %s\", (const char *)*(&off_624040 + SHIDWORD(qword_623FD0)));\n  if ( (unsigned int)(HIDWORD(qword_623FD0) - 1) <= 1 )\n  {\n    printf(\", FORM: %s\", (const char *)*(&off_624020 + (int)qword_623FD0));\n    if ( HIDWORD(qword_623FD0) != 4 )\n      goto LABEL_12;\n  }\n  else if ( HIDWORD(qword_623FD0) != 4 )\n  {\n    goto LABEL_12;\n  }\n  printf(\" %d\", 8);\nLABEL_12:\n  printf(\"; STRUcture: %s; transfer MODE: %s\\r\\n\", off_624008[0], off_623FE8[0]);\n  if ( dword_623FB8 == -1 )\n  {\n    if ( fd == -1 )\n    {\n      if ( dword_623FBC )\n      {\n        puts(\"     No data connection\\r\");\n        goto LABEL_16;\n      }\n      printf(\"     PORT\");\n      v0 = &unk_6249A0;\n    }\n    else\n    {\n      printf(\"     in Passive mode\");\n      v0 = &stru_624620;\n    }\n    printf(\n      \" (%d,%d,%d,%d,%d,%d)\\r\\n\",\n      (unsigned __int8)v0->sa_data[2],\n      (unsigned __int8)v0->sa_data[3],\n      (unsigned __int8)v0->sa_data[4],\n      (unsigned __int8)v0->sa_data[5],\n      (unsigned __int8)v0->sa_data[0],\n      (unsigned __int8)v0->sa_data[1]);\n    v1 = v2;\n  }\n  else\n  {\n    puts(\"     Data connection open\\r\");\n  }\nLABEL_16:\n  sub_4082C0(211, \"End of status\", v1);\n}\n",
    "function_name": "statcmd",
    "decompiled_code": "void __cdecl statcmd()\n{\n  sockaddr_storage *v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // [rsp-8h] [rbp-10h]\n\n  lreply(211, &byte_41D254[115], hostname);\n  if ( !no_version )\n    printf(&byte_41D254[157], 4313827LL, 4313821LL);\n  printf(\"     Connected to %s\", cred.remotehost);\n  getnameinfo((const struct sockaddr *)&his_addr, his_addrlen, addrstr, 0x401u, 0LL, 0, 1);\n  if ( ((*__ctype_b_loc())[*cred.remotehost] & 0x800) == 0 )\n    printf(\" (%s)\", addrstr);\n  puts(s);\n  printf(\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if ( cred.logged_in )\n  {\n    if ( cred.guest )\n      puts(\"     Logged in anonymously\\r\");\n    else\n      printf(\"     Logged in as %s\\r\\n\", cred.name);\n  }\n  else if ( askpasswd )\n  {\n    puts(aWaitingForPass);\n  }\n  else\n  {\n    puts(&s[2]);\n  }\n  printf(&s[30], typenames[type]);\n  if ( (unsigned int)(type - 1) <= 1 )\n  {\n    printf(&s[44], formnames[form]);\n    if ( type != 4 )\n      goto LABEL_12;\n  }\n  else if ( type != 4 )\n  {\n    goto LABEL_12;\n  }\n  printf(&s[55], 8LL);\nLABEL_12:\n  printf(\"; STRUcture: %s; transfer MODE: %s\\r\\n\", strunames[1], modenames[1]);\n  if ( data == -1 )\n  {\n    if ( pdata == -1 )\n    {\n      if ( usedefault )\n      {\n        puts(&s[140]);\n        goto LABEL_16;\n      }\n      printf(&s[107]);\n      v0 = &data_dest;\n    }\n    else\n    {\n      printf(&s[86]);\n      v0 = &pasv_addr;\n    }\n    printf(\n      &s[117],\n      (unsigned __int8)v0->__ss_padding[2],\n      (unsigned __int8)v0->__ss_padding[3],\n      (unsigned __int8)v0->__ss_padding[4],\n      (unsigned __int8)v0->__ss_padding[5],\n      (unsigned __int8)v0->__ss_padding[0],\n      (unsigned __int8)v0->__ss_padding[1]);\n    v1 = v2;\n  }\n  else\n  {\n    puts(&s[59]);\n  }\nLABEL_16:\n  reply(211, &s[165], v1);\n}\n",
    "source_code": "\nvoid\nstatcmd (void)\n{\n  struct sockaddr_storage *sin;\n  unsigned char *a, *p;\n\n  lreply (211, \"%s FTP server status:\", hostname);\n  if (!no_version)\n    printf (\"     ftpd (%s) %s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n  printf (\"     Connected to %s\", cred.remotehost);\n  (void) getnameinfo ((struct sockaddr *) &his_addr, his_addrlen,\n\t\t      addrstr, sizeof (addrstr), NULL, 0, NI_NUMERICHOST);\n  if (!isdigit (cred.remotehost[0]))\n    printf (\" (%s)\", addrstr);\n  printf (\"\\r\\n\");\n  printf (\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if (cred.logged_in)\n    {\n      if (cred.guest)\n\tprintf (\"     Logged in anonymously\\r\\n\");\n      else\n\tprintf (\"     Logged in as %s\\r\\n\", cred.name);\n    }\n  else if (askpasswd)\n    printf (\"     Waiting for password\\r\\n\");\n  else\n    printf (\"     Waiting for user name\\r\\n\");\n  printf (\"     TYPE: %s\", typenames[type]);\n  if (type == TYPE_A || type == TYPE_E)\n    printf (\", FORM: %s\", formnames[form]);\n  if (type == TYPE_L)\n#ifdef CHAR_BIT\n    printf (\" %d\", CHAR_BIT);\n#else\n# if NBBY == 8\n    printf (\" %d\", NBBY);\n# else\n    printf (\" %d\", bytesize);\t/* need definition! */\n# endif\n#endif\n  printf (\"; STRUcture: %s; transfer MODE: %s\\r\\n\",\n\t  strunames[stru], modenames[stru_mode]);\n  if (data != -1)\n    printf (\"     Data connection open\\r\\n\");\n  else if (pdata != -1)\n    {\n      printf (\"     in Passive mode\");\n      sin = &pasv_addr;\n      goto printaddr;\n    }\n  else if (usedefault == 0)\n    {\n      printf (\"     PORT\");\n      sin = &data_dest;\n    printaddr:\n      a = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_addr;\n      p = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_port;\n#define UC(b) (((int) b) & 0xff)\n      printf (\" (%d,%d,%d,%d,%d,%d)\\r\\n\", UC (a[0]),\n\t      UC (a[1]), UC (a[2]), UC (a[3]), UC (p[0]), UC (p[1]));\n#undef UC\n    }\n  else\n    printf (\"     No data connection\\r\\n\");\n  reply (211, \"End of status\");\n}",
    "comment": "Displays the current status of the FTP server, including connection details, session timeout, user login status, data connection status, and transfer settings.",
    "hext5_sum": "print the first n statements in statement list s to stderr. if n == 0, nothing is printed. if n < 0, the entire list is printed. intended to be called from gdb.",
    "bint5_sum": "Displays the FTP server status , including server name , timeout information , and authentication details , while handling session management and error reporting .\n",
    "cpbcs_sum": "Handles unexpected characters by sending a signal to the appropriate stream or remote host based on client authentication and server configurations.\n",
    "misum_sum": "Displays a formatted error message with a formatted error message and status information, including usage details and received options.\n",
    "decom_sum": "Outputs the current FTP server status, including software version, connection info, login state, transfer settings, and data connection mode.",
    "cfg_sum": "Displays the current FTP server status, including connection details, login state, transfer settings, and data connection information in a formatted output.",
    "work_score": {
        "hext5": {
            "summary": "print the first n statements in statement list s to stderr. if n == 0, nothing is printed. if n < 0, the entire list is printed. intended to be called from gdb.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes printing a list of statements to stderr with behavior based on the value of n, intended for use from gdb. None of these claims match the source code, which implements an FTP server status command that formats and prints connection, login, and transfer details to stdout. The summary is entirely unrelated to the code, making all claims inaccurate.",
                "The summary describes printing elements of a list to stderr based on a parameter n, with conditions for n == 0 and n < 0, and notes it is intended for gdb use. None of these claims align with the source code, which outputs detailed FTP server status information including server name, version, connection info, login state, transfer type, structure, mode, and data connection details. The primary purpose and all secondary details of the actual code are missed entirely, making the summary inaccurate and irrelevant to the source implementation.",
                "The summary entirely misrepresents the source code\u2019s purpose, describing printing statements to stderr from a list in a GDB context, while the actual function outputs FTP server status information via printf and reply, with no relation to stderr, statement lists, or GDB. This is a FATAL error affecting the primary purpose and key I/O, making the summary unreliable."
            ]
        },
        "bint5": {
            "summary": "Displays the FTP server status , including server name , timeout information , and authentication details , while handling session management and error reporting .\n",
            "score": [
                0.5,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly notes that the function displays FTP server status, server name, timeout information, and authentication details, which align with the code's output logic. However, it inaccurately adds claims about session management and error reporting, which are not present in the source code. This mix results in less than full accuracy as only part of the claims are supported by the implementation.",
                "The summary captures the primary purpose of displaying FTP server status and mentions server name, timeout, and authentication details, which align with the code. However, it inaccurately adds 'error reporting' as a feature, which is not present, and omits several key secondary details such as type/form/structure/mode information, data connection states, and IP/port display logic. These omissions reduce completeness despite correct coverage of the core intent.",
                "The summary contains mostly broad, low-information SAFE claims: it correctly notes displaying server name, timeout, and authentication details, matching the code\u2019s output. However, it introduces NOISE by mentioning 'session management' and 'error reporting,' which are not present in the source function. There are no FATAL errors affecting primary purpose or key I/O, but the lack of specific, detailed GOLD claims results in low gain."
            ]
        },
        "cpbcs": {
            "summary": "Handles unexpected characters by sending a signal to the appropriate stream or remote host based on client authentication and server configurations.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function handles unexpected characters by sending a signal to a stream or remote host depending on authentication and configurations, which is not reflected in the source code. The source code produces status output for an FTP server, displaying information such as version, connections, login state, transfer type, and data connection status, with no handling of unexpected characters nor signaling mechanism. The claim is inaccurate and unrelated to actual implementation, resulting in no accurate claims.",
                "The summary does not describe the primary purpose of the function, which is to print FTP server status information (including version, connection details, timeout, logged-in user type, transfer settings, and data connection state). Instead, it inaccurately claims handling of unexpected characters and signal sending, which is not present in the source code. This results in no accurate coverage of critical semantic units.",
                "The summary claims the function handles unexpected characters by sending a signal, which is unrelated to the actual code. The source code prints FTP server status information such as version, connection details, user login state, transfer modes, and data connection state. There is no logic for detecting unexpected characters or sending signals. This is a FATAL inaccuracy targeting primary purpose, making the summary misleading and unreliable."
            ]
        },
        "misum": {
            "summary": "Displays a formatted error message with a formatted error message and status information, including usage details and received options.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as displaying a formatted error message, which is not present in the source code. The function outputs FTP server status information such as hostname, connection details, login status, transfer type, and data connection state, but not usage details or received options. None of the claims align with the actual implementation, resulting in no accurate claims.",
                "The summary is inaccurate as it describes displaying a formatted error message and usage details, which are not in the source code. The function actually outputs FTP server status information such as hostname, version, connection details, login state, transfer settings, and data connection info. The primary purpose is missed entirely and there is no coverage of key secondary details from the source.",
                "The summary contains a major inaccuracy: it claims the function displays a formatted error message with usage details and received options, but the source code actually outputs FTP server status information, session details, connection mode, and login state. This is a FATAL error concerning the primary purpose, making the summary misleading and unusable for understanding the key I/O behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584590896,
    "strip_function_name": "sub_FFFFFFFF8157AC30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8157AC30(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  __int64 v13; // r13\n  __int64 v14; // rax\n  unsigned __int64 v15; // rbx\n  void *v16; // r15\n  __int64 v17; // rdx\n  __int64 result; // rax\n  _QWORD v19[6]; // [rsp+8h] [rbp-30h] BYREF\n\n  v13 = *(_QWORD *)(a1 + 320);\n  v14 = *(_QWORD *)(v13 + 888);\n  if ( v14 )\n  {\n    v15 = (unsigned int)(*(_DWORD *)(v14 + 20) * *(_DWORD *)(v14 + 36)) >> 3;\n    if ( !a4 )\n    {\n      v16 = *(void **)(v13 + 832);\n      sub_FFFFFFFF81790F30(a1);\n      v17 = sub_FFFFFFFF812B8B10(v16, a2, (unsigned int)a3);\n      result = -14LL;\n      if ( v17 )\n        return result;\n      a2 = *(_QWORD *)(v13 + 832);\n    }\n    result = sub_FFFFFFFF8157D640(a1, a2, a3 / v15, v19);\n    if ( result >= 0 )\n    {\n      result = sub_FFFFFFFF8157D760(a1, v19[0], result);\n      if ( result > 0 )\n        result *= v15;\n    }\n  }\n  else\n  {\n    result = sub_FFFFFFFF8157AB50(\n               a1,\n               a2,\n               (__int64)(8 * a3) / *(unsigned int *)(v13 + 152),\n               a4,\n               a5,\n               a6,\n               a7,\n               a8,\n               a9,\n               a10,\n               a11,\n               a12);\n    if ( result > 0 )\n      return *(unsigned int *)(v13 + 152) * result / 8;\n  }\n  return result;\n}\n",
    "function_name": "snd_pcm_oss_write2",
    "decompiled_code": "__int64 __fastcall snd_pcm_oss_write2(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        __int64 a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        __int64 a13,\n        int a14)\n{\n  __int64 v15; // r13\n  __int64 v16; // rax\n  unsigned __int64 v17; // rbx\n  __int64 v18; // r15\n  __int64 v19; // rdx\n  __int64 result; // rax\n  __int64 v21[6]; // [rsp+8h] [rbp-30h] BYREF\n\n  v15 = *(_QWORD *)(a1 + 320);\n  v16 = *(_QWORD *)(v15 + 888);\n  if ( v16 )\n  {\n    v17 = (unsigned int)(*(_DWORD *)(v16 + 20) * *(_DWORD *)(v16 + 36)) >> 3;\n    if ( !(_DWORD)a4 )\n    {\n      v18 = *(_QWORD *)(v15 + 832);\n      cond_resched(a1, a2);\n      v19 = copy_from_user(v18, a2, (unsigned int)a3);\n      result = -14LL;\n      if ( v19 )\n        return result;\n      a2 = *(_QWORD *)(v15 + 832);\n    }\n    result = snd_pcm_plug_client_channels_buf(a1, a2, a3 / v17, v21);\n    if ( result >= 0 )\n    {\n      result = snd_pcm_plug_write_transfer(a1, v21[0], result);\n      if ( result > 0 )\n        result *= v17;\n    }\n  }\n  else\n  {\n    result = snd_pcm_oss_write3(\n               a1,\n               a2,\n               (__int64)(8 * a3) / *(unsigned int *)(v15 + 152),\n               a4,\n               a5,\n               a6,\n               a7,\n               a8,\n               a9,\n               a10,\n               a11,\n               a12,\n               a13,\n               a14);\n    if ( result > 0 )\n      return *(unsigned int *)(v15 + 152) * result / 8;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic ssize_t snd_pcm_oss_write2(struct snd_pcm_substream *substream, const char *buf, size_t bytes, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t frames, frames1;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first) {\n\t\tstruct snd_pcm_plugin_channel *channels;\n\t\tsize_t oss_frame_bytes = (runtime->oss.plugin_first->src_width * runtime->oss.plugin_first->src_format.channels) / 8;\n\t\tif (!in_kernel) {\n\t\t\tif (copy_from_user(runtime->oss.buffer, (const char __force __user *)buf, bytes))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = runtime->oss.buffer;\n\t\t}\n\t\tframes = bytes / oss_frame_bytes;\n\t\tframes1 = snd_pcm_plug_client_channels_buf(substream, (char *)buf, frames, &channels);\n\t\tif (frames1 < 0)\n\t\t\treturn frames1;\n\t\tframes1 = snd_pcm_plug_write_transfer(substream, channels, frames1);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames1 * oss_frame_bytes;\n\t} else\n#endif\n\t{\n\t\tframes = bytes_to_frames(runtime, bytes);\n\t\tframes1 = snd_pcm_oss_write3(substream, buf, frames, in_kernel);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames_to_bytes(runtime, frames1);\n\t}\n\treturn bytes;\n}",
    "comment": "Writes audio data from a buffer to a PCM substream, handling potential OSS plugin processing and user-kernel memory copying.",
    "hext5_sum": "calculate the number of columns needed to represent the current set of files in the current display width.",
    "bint5_sum": "Reads audio data from a PCM substream , handling either user space or kernel space buffers with optional plugin processing .\n",
    "cpbcs_sum": "Reads audio data from a PCM substream, handling either user space or kernel space buffers with optional plugin processing.\n",
    "misum_sum": "Writes audio data to a PCM substream, handling user space and kernel space if allocation is available.\n",
    "decom_sum": "Processes a data block by converting its size to element count and delegating either hardware-buffer transfer or software-based processing based on configuration.",
    "cfg_sum": "Processes data buffers by dividing into chunks, conditionally transforming or forwarding them, and returning a size-adjusted result based on format and conversion parameters.",
    "work_score": {
        "hext5": {
            "summary": "calculate the number of columns needed to represent the current set of files in the current display width.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes calculating the number of columns for file display width, which is unrelated to the source code's implementation of audio data writing in snd_pcm_oss_write2. The claim does not align with any functionality in the provided code, making it entirely inaccurate.",
                "The summary is entirely inaccurate, describing a function that calculates display columns, which is unrelated to the actual code. The source code handles audio data writing in the OSS PCM subsystem, including plugin handling, copying from user space, frame and byte conversions, and delegating to other write functions. The summary misses the primary purpose and all secondary details, yielding no factual alignment.",
                "The summary's claim about calculating columns for file display width is entirely unrelated to the source code, which handles audio buffer writing in a PCM OSS context. This is a pure NOISE failure mode with no accurate or relevant details matching the implementation, resulting in no useful gain for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Reads audio data from a PCM substream , handling either user space or kernel space buffers with optional plugin processing .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function reads audio data from a PCM substream and handles both user and kernel space buffers, which matches the code's branching logic based on the 'in_kernel' flag. It also notes optional plugin processing, aligning with the conditional block guarded by CONFIG_SND_PCM_OSS_PLUGINS. All claims are accurate and directly tied to the source code behavior, with no inaccuracies present.",
                "The summary correctly identifies the primary purpose: writing audio data to a PCM substream and handling buffers from either user or kernel space with optional plugin processing, which matches the source code\u2019s branching logic and plugin handling. However, it omits secondary details such as specific error handling for copy_from_user, conversion between bytes and frames, conditional paths when plugins are not used, and return value semantics based on frame processing results.",
                "The summary captures the general function behavior\u2014reading audio data from a PCM substream and distinguishing between user-space and kernel-space buffers, along with optional plugin processing\u2014without contradicting the source code. These are broad SAFE claims that align with the code\u2019s use of buffer handling via `copy_from_user` when not in kernel space, and plugin-specific logic when `plugin_first` is set. However, the summary lacks specific details on frame and byte conversions, error handling, and the precise sequence of operations, resulting in low informational value. The worst failure mode here is low gain rather than inaccuracies."
            ]
        },
        "cpbcs": {
            "summary": "Reads audio data from a PCM substream, handling either user space or kernel space buffers with optional plugin processing.\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly captures the function's purpose of writing audio data to a PCM substream and notes the distinction between user space and kernel space buffers, aligning with the code's use of `copy_from_user` when `in_kernel` is false. It also mentions optional plugin processing, which matches the plugin-first conditional block. All claims are grounded in the source and accurate, indicating a high proportion of correct facts.",
                "The summary correctly captures the primary purpose: writing audio data to a PCM substream with handling for user space and kernel space buffers and optional plugin processing. However, it omits important secondary details such as error handling via return codes, frame-to-byte conversion logic, specific plugin-related data transformations, and branching based on plugin presence. The coverage of key constants like oss_frame_bytes and use of helper functions for data transfer is missing, reducing completeness.",
                "The summary contains a single broad claim that the function reads audio data from a PCM substream, handling both user and kernel space buffers with optional plugin processing. This is largely accurate: the code processes PCM data, copies from user space if needed, adjusts for plugins, and handles in-kernel buffers. However, the claim is generic and lacks specific implementation details such as frame calculations or function calls, offering low informational value. There are no inaccurate or contradictory elements, so negative impact is minimal, but the low gain results in limited utility."
            ]
        },
        "misum": {
            "summary": "Writes audio data to a PCM substream, handling user space and kernel space if allocation is available.\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly identifies that the function writes audio data to a PCM substream and handles both user-space and kernel-space scenarios, which matches the source implementation. However, it omits important specifics such as plugin handling, conversion between bytes and frames, and error handling, making the description broad and low in detail. The claims present are safe but lack high specificity, with no contradictory elements, yielding a high proportion of accurate statements.",
                "The summary captures the primary purpose of writing audio data to a PCM substream and notes handling between user space and kernel space, which aligns broadly with the source code\u2019s check for `in_kernel` and `copy_from_user` logic. However, it omits key secondary details such as the OSS plugin handling path, calculation of frames based on format width and channels, error returns when frame counts are less than or equal to zero, and the fallback path using `snd_pcm_oss_write3`. The mention of 'allocation is available' is vague and not present in the source code, reducing precision.",
                "The summary makes a broad SAFE claim that the function writes audio data to a PCM substream and deals with user space vs kernel space, which matches the general purpose of the source code. However, it omits key specifics such as plugin handling, frame calculations, and error returns. There are no contradictory statements, but the information gain is low, as it provides little detail beyond a generic description. The worst failure mode is low-info NOISE rather than any FATAL errors."
            ]
        }
    }
}
{
    "project_name": "texinfo",
    "function_addr": 128992,
    "strip_function_name": "sub_1F7E0",
    "strip_decompiled_code": "__int64 __fastcall sub_1F7E0(__int64 a1, int a2)\n{\n  __int64 v2; // r12\n  unsigned int v3; // ebx\n  const char *v5; // rbx\n  const char *v6; // rdi\n  __int64 v7; // r12\n  __int64 v8; // rax\n  char *v10; // rax\n\n  v2 = *(_QWORD *)(a1 + 48);\n  v3 = *(_DWORD *)(v2 + 56) & 0x50;\n  if ( v3 )\n    return 1;\n  if ( a2 == 1 )\n    return (unsigned int)sub_1CEF0(\"Prev\", a1) == 0;\n  if ( a2 == 2 )\n  {\n    sub_1C2E0((__int64)\"%s\", (const char *)qword_24BF28);\n    return 1;\n  }\n  if ( a2 )\n    return v3;\n  v5 = *(const char **)(v2 + 72);\n  if ( v5 )\n  {\n    if ( strncasecmp(*(const char **)(v2 + 72), \"(dir)\", 5uLL) )\n    {\n      v6 = *(const char **)(v2 + 80);\n      if ( !v6 || !strcmp(v6, v5) )\n        return (unsigned int)sub_1CEF0(\"Up\", a1) == 0;\n      v7 = *(_QWORD *)(a1 + 296);\n      if ( (unsigned int)sub_1CEF0(\"Prev\", a1) )\n      {\n        v3 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 56LL) & 0x200;\n        if ( v3 )\n        {\n          return 0;\n        }\n        else\n        {\n          do\n            v8 = sub_1ABF0(a1, 0x30u);\n          while ( v8 && (unsigned int)sub_1EED0((const char ***)a1, v8) );\n          sub_1C940((__int64 *)(a1 + 288), (_QWORD *)(a1 + 296), v7, *(_DWORD *)(a1 + 296) - 1);\n        }\n        return v3;\n      }\n      return 1;\n    }\nLABEL_21:\n    v3 = 1;\n    v10 = dcgettext(0LL, \"No 'Prev' or 'Up' for this node within this document\", 5);\n    sub_1C2E0((__int64)\"%s\", v10);\n    return v3;\n  }\n  if ( !*(_QWORD *)(v2 + 80) )\n    goto LABEL_21;\n  return (unsigned int)sub_1CEF0(\"Prev\", a1) == 0;\n}\n",
    "function_name": "backward_move_node_structure",
    "decompiled_code": "int __fastcall backward_move_node_structure(WINDOW *window, int behaviour)\n{\n  NODE *node; // r12\n  int v3; // ebx\n  const char *up; // rbx\n  const char *prev; // rdi\n  size_t hist_index; // r12\n  REFERENCE *v8; // rax\n  char *v10; // rax\n\n  node = window->node;\n  v3 = node->flags & 0x50;\n  if ( v3 )\n    return 1;\n  if ( behaviour == 1 )\n    return info_handle_pointer(\"Prev\", window) == 0;\n  if ( behaviour == 2 )\n  {\n    info_error(\"%s\", msg_at_node_top);\n    return 1;\n  }\n  if ( behaviour )\n    return v3;\n  up = node->up;\n  if ( up )\n  {\n    if ( strncasecmp(node->up, \"(dir)\", 5uLL) )\n    {\n      prev = node->prev;\n      if ( !prev || !strcmp(prev, up) )\n        return info_handle_pointer(\"Up\", window) == 0;\n      hist_index = window->hist_index;\n      if ( info_handle_pointer(\"Prev\", window) )\n      {\n        v3 = window->node->flags & 0x200;\n        if ( v3 )\n          return 0;\n        do\n          v8 = select_menu_digit(window, 0x30u);\n        while ( v8 && info_select_reference(window, v8) );\n        cleanup_history((WINDOW *)&window->hist, &window->hist_index, hist_index, LODWORD(window->hist_index) - 1);\n        return v3;\n      }\n      return 1;\n    }\nLABEL_21:\n    v3 = 1;\n    v10 = dcgettext(0LL, \"No 'Prev' or 'Up' for this node within this document\", 5);\n    info_error(\"%s\", v10);\n    return v3;\n  }\n  if ( !node->prev )\n    goto LABEL_21;\n  return info_handle_pointer(\"Prev\", window) == 0;\n}\n",
    "source_code": "static int\nbackward_move_node_structure (WINDOW *window, int behaviour)\n{\n  if (window->node->flags & (N_IsInternal | N_IsManPage))\n    return 1;\n\n  switch (behaviour)\n    {\n    case IS_PageOnly:\n      info_error (\"%s\", msg_at_node_top);\n      return 1;\n\n    case IS_NextOnly:\n      return !info_handle_pointer (\"Prev\", window);\n      break;\n\n    case IS_Continuous:\n      if (window->node->up)\n        {\n          /* If up is the dir node, we are at the top node.\n             Don't do anything. */\n          if (!strncasecmp (window->node->up, \"(dir)\", strlen (\"(dir)\")))\n            {\n              info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n              return 1;\n            }\n          /* If 'Prev' and 'Up' are the same, we are at the first node\n             of the 'Up' node's menu. Go to up node. */\n          else if (window->node->prev\n              && !strcmp(window->node->prev, window->node->up))\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n          /* Otherwise, go to 'Prev' node and go down the last entry\n             in the menus as far as possible. */\n          else if (window->node->prev)\n            {\n              int starting_hist_index = window->hist_index;\n              if (!info_handle_pointer (\"Prev\", window))\n                return 1;\n              if (!(window->node->flags & N_IsIndex))\n                {\n                  while (1)\n                    {\n                      REFERENCE *entry = select_menu_digit (window, '0');\n                      if (!entry)\n                        break;\n                      if (!info_select_reference (window, entry))\n                        break;\n                    }\n                  /* Don't include intermediate nodes in the window's\n                     history.  */\n                  cleanup_history (window, starting_hist_index,\n                                   window->hist_index - 1);\n                }\n            }\n          else /* 'Up' but no 'Prev' */\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n        }\n      else if (window->node->prev) /* 'Prev' but no 'Up' */\n        {\n          if (!info_handle_pointer (\"Prev\", window))\n            return 1;\n        }\n      else\n        {\n          info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n          return 1;\n        }\n\n      break; /* case IS_Continuous: */\n    }\n  return 0;\n}",
    "comment": "Handles backward navigation in a document's node structure based on specified behavior, managing transitions to previous or upward nodes as necessary.",
    "hext5_sum": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
    "bint5_sum": "Processes the `` Prev '' and `` Next '' attributes of a given node , printing relevant messages based on specified string comparisons .\n",
    "cpbcs_sum": "Validates and updates the existence of a linked list based on its parent directory and current leaf depth status.\n",
    "misum_sum": "Sets file attributes for a specified job based on the provided mode and path type, sending a message if found.\n",
    "decom_sum": "Determines navigation actions for document nodes, handling 'Prev' and 'Up' commands, directory checks, and displaying messages when navigation targets are unavailable.",
    "cfg_sum": "Determines navigation behavior within a document or directory by checking node attributes and executing actions for \u201cPrev\u201d or \u201cUp\u201d commands based on conditions.",
    "work_score": {
        "hext5": {
            "summary": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's claims concern FTP PASV command responses and historical context from RFC959, which are unrelated to the source code's logic for navigating nodes in an info document. None of the claims are about or match the source code semantics, making them inaccurate under the evaluation criteria.",
                "The summary discusses historical context about the PASV command in RFC959 and a specific 425 response, which is unrelated to the source code implementing backward movement within a WINDOW structure. It makes no claims about the function\u2019s primary purpose, control flow, behaviors, or any CSU from the source. Therefore, it fails to capture any relevant or accurate details from the code.",
                "The summary\u2019s claims about FTP PASV command responses and historical communications are entirely unrelated to the given source code, which implements navigation logic within an Info document viewer. All claims are NOISE, with no connection to code semantics, key I/O, or side effects. This results in overwhelming irrelevant content and zero useful insight into the source, yielding low net benefit."
            ]
        },
        "bint5": {
            "summary": "Processes the `` Prev '' and `` Next '' attributes of a given node , printing relevant messages based on specified string comparisons .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function processes 'Prev' and 'Next' attributes of a given node, but the source code only handles 'Prev' along with 'Up' and does not reference a 'Next' attribute at all. This makes the main claim factually incorrect, with little accurate alignment to the actual control flow and conditions in the source code.",
                "The summary vaguely describes processing 'Prev' and 'Next' attributes with messages based on string comparisons, but misses the primary purpose of backward navigation through node structures with branching on behaviour values (IS_PageOnly, IS_NextOnly, IS_Continuous). It omits key secondary details such as handling internal/manpage nodes, specific conditions when 'Up' and 'Prev' are the same, menu traversal, history cleanup, and multiple error-message cases. The mention of 'Next' is inaccurate since the code does not process a 'Next' pointer in backward navigation.",
                "The summary claims the function processes 'Prev' and 'Next' attributes and prints messages based on string comparisons. The source code does handle 'Prev' and uses string comparisons for conditions, but it does not handle 'Next' at all\u2014only 'Prev' and 'Up'. This is an inaccurate (FATAL) claim about the function's key purpose, directly contradicting its I/O behavior. While the mention of message printing from string comparisons is accurate, the inclusion of a false 'Next' reference heavily undermines reliability."
            ]
        },
        "cpbcs": {
            "summary": "Validates and updates the existence of a linked list based on its parent directory and current leaf depth status.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claim about validating and updating a linked list based on parent directory and leaf depth does not match the source code, which handles navigation between nodes in an Info document according to flags and pointer relationships. None of the claims in the summary accurately reflect the code\u2019s behavior, resulting in no accurate matches.",
                "The summary is inaccurate because it describes validating and updating a linked list based on directory and leaf depth, which is unrelated to the source code. The source function navigates an Info document's node structure according to the 'Prev' and 'Up' pointers and behavior modes, with specific error handling. The primary purpose and all secondary details from the code are missed, so there is no coverage.",
                "The summary makes a claim about validating and updating a linked list based on parent directory and leaf depth status, which does not match the source code's actual behavior of handling navigation between nodes in an Info document using 'Prev' and 'Up' references. This is a FATAL inaccuracy targeting the primary purpose, making the description misleading and unrelated to key I/O and side effects."
            ]
        },
        "misum": {
            "summary": "Sets file attributes for a specified job based on the provided mode and path type, sending a message if found.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes setting file attributes for a job, mode, and path type, which is unrelated to the source code's actual behavior of navigating nodes in a window structure. None of the claims align with the source code semantics, resulting in no accurate matches.",
                "The summary is entirely unrelated to the source code. The function in the source navigates backwards between nodes in a WINDOW structure based on behaviour flags, handling cases for internal/manpage nodes, 'Prev' and 'Up' navigation, and reporting errors when navigation is not possible. The summary incorrectly describes file attribute setting for a job, which does not match any logic or purpose in the source. This fails to capture the primary purpose and all secondary details.",
                "The summary makes claims about setting file attributes for a job, using a mode and path type, and sending a message, which are completely unrelated to the source code. The function in the source handles moving through nodes in an info window based on behaviour and navigational pointers, not file attributes or jobs. All extracted claims are NOISE, overwhelming any possible accurate content, with zero alignment to the code semantics."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1120848,
    "strip_function_name": "sub_111A50",
    "strip_decompiled_code": "__m128i *__fastcall sub_111A50(const __m128i *a1, __int64 a2, __int64 a3)\n{\n  __m128i *v4; // rbx\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __m128i v9; // xmm0\n  __int64 v10; // rax\n  __m128i v11; // xmm0\n\n  v4 = (__m128i *)calloc(1uLL, 0x98uLL);\n  if ( v4 )\n  {\n    v5 = gsl_vector_alloc(a3);\n    v4[1].m128i_i64[0] = v5;\n    if ( v5 )\n    {\n      v6 = gsl_vector_alloc(a3);\n      v4[1].m128i_i64[1] = v6;\n      if ( v6 )\n      {\n        v7 = gsl_vector_alloc(a3);\n        v4[4].m128i_i64[0] = v7;\n        if ( v7 )\n        {\n          v8 = gsl_vector_alloc(a2);\n          v4[4].m128i_i64[1] = v8;\n          if ( v8 )\n          {\n            v9 = _mm_loadu_si128(a1);\n            v10 = a1[4].m128i_i64[0];\n            v4->m128i_i64[0] = a2;\n            v4[5] = v9;\n            v4->m128i_i64[1] = a3;\n            v11 = _mm_loadu_si128(a1 + 1);\n            v4[9].m128i_i64[0] = v10;\n            v4[6] = v11;\n            v4[7] = _mm_loadu_si128(a1 + 2);\n            v4[8] = _mm_loadu_si128(a1 + 3);\n          }\n          else\n          {\n            v4 = 0LL;\n            gsl_error(\"failed to allocate space for workn\", \"dogleg.c\", 109LL, 8LL);\n          }\n        }\n        else\n        {\n          v4 = 0LL;\n          gsl_error(\"failed to allocate space for workp\", \"dogleg.c\", 103LL, 8LL);\n        }\n      }\n      else\n      {\n        v4 = 0LL;\n        gsl_error(\"failed to allocate space for dx_sd\", \"dogleg.c\", 97LL, 8LL);\n      }\n    }\n    else\n    {\n      v4 = 0LL;\n      gsl_error(\"failed to allocate space for dx_gn\", \"dogleg.c\", 91LL, 8LL);\n    }\n  }\n  else\n  {\n    gsl_error(\"failed to allocate dogleg state\", \"dogleg.c\", 85LL, 8LL);\n  }\n  return v4;\n}\n",
    "function_name": "dogleg_alloc",
    "decompiled_code": "__m128i *__fastcall dogleg_alloc(const __m128i *a1, __int64 a2, __int64 a3)\n{\n  __m128i *v4; // rbx\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __m128i v9; // xmm0\n  __int64 v10; // rax\n  __m128i v11; // xmm0\n\n  v4 = (__m128i *)calloc(1uLL, 0x98uLL);\n  if ( v4 )\n  {\n    v5 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n    v4[1].m128i_i64[0] = v5;\n    if ( v5 )\n    {\n      v6 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n      v4[1].m128i_i64[1] = v6;\n      if ( v6 )\n      {\n        v7 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a3);\n        v4[4].m128i_i64[0] = v7;\n        if ( v7 )\n        {\n          v8 = ((__int64 (__fastcall *)(__int64))gsl_vector_alloc)(a2);\n          v4[4].m128i_i64[1] = v8;\n          if ( v8 )\n          {\n            v9 = _mm_loadu_si128(a1);\n            v10 = a1[4].m128i_i64[0];\n            v4->m128i_i64[0] = a2;\n            v4[5] = v9;\n            v4->m128i_i64[1] = a3;\n            v11 = _mm_loadu_si128(a1 + 1);\n            v4[9].m128i_i64[0] = v10;\n            v4[6] = v11;\n            v4[7] = _mm_loadu_si128(a1 + 2);\n            v4[8] = _mm_loadu_si128(a1 + 3);\n          }\n          else\n          {\n            v4 = 0LL;\n            ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n              \"failed to allocate space for workn\",\n              \"dogleg.c\",\n              109LL,\n              8LL);\n          }\n        }\n        else\n        {\n          v4 = 0LL;\n          ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n            \"failed to allocate space for workp\",\n            \"dogleg.c\",\n            103LL,\n            8LL);\n        }\n      }\n      else\n      {\n        v4 = 0LL;\n        ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n          \"failed to allocate space for dx_sd\",\n          \"dogleg.c\",\n          97LL,\n          8LL);\n      }\n    }\n    else\n    {\n      v4 = 0LL;\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n        \"failed to allocate space for dx_gn\",\n        \"dogleg.c\",\n        91LL,\n        8LL);\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"failed to allocate dogleg state\",\n      \"dogleg.c\",\n      85LL,\n      8LL);\n  }\n  return v4;\n}\n",
    "source_code": "\nstatic void *\ndogleg_alloc (const void * params, const size_t n, const size_t p)\n{\n  dogleg_state_t *state;\n  \n  state = calloc(1, sizeof(dogleg_state_t));\n  if (state == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate dogleg state\", GSL_ENOMEM);\n    }\n\n  state->dx_gn = gsl_vector_alloc(p);\n  if (state->dx_gn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_gn\", GSL_ENOMEM);\n    }\n\n  state->dx_sd = gsl_vector_alloc(p);\n  if (state->dx_sd == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_sd\", GSL_ENOMEM);\n    }\n\n  state->workp1 = gsl_vector_alloc(p);\n  if (state->workp1 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp1\", GSL_ENOMEM);\n    }\n\n  state->workp2 = gsl_vector_alloc(p);\n  if (state->workp2 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp2\", GSL_ENOMEM);\n    }\n\n  state->workn = gsl_vector_alloc(n);\n  if (state->workn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workn\", GSL_ENOMEM);\n    }\n\n  state->n = n;\n  state->p = p;\n  state->params = *(const gsl_multilarge_nlinear_parameters *) params;\n\n  return state;\n}",
    "comment": "Allocates memory for a dogleg optimization state and its associated vectors, initializing parameters for nonlinear optimization.",
    "hext5_sum": "a := a + u b^h where u is upper triangular",
    "bint5_sum": "Allocates and initializes a trust_state_t structure and its associated vectors for nonlinear least squares fitting using provided parameters .\n",
    "cpbcs_sum": "Allocates memory for a Levenberg-Marquardt optimization state, including vectors for work, function values, velocity, and acceleration based on provided parameters.\n",
    "misum_sum": "Allocates and initializes a GSL multifit nonlinear workspace with memory for work, vectors and vectors for nonlinear least squares fitting\n",
    "decom_sum": "Allocates and initializes a dogleg algorithm state structure with multiple GSL vectors and parameters, reporting specific errors on allocation failures.",
    "cfg_sum": "Initializes a dogleg algorithm state by allocating required GSL vectors, copying input parameters, and reporting specific errors if any allocation fails.",
    "work_score": {
        "hext5": {
            "summary": "a := a + u b^h where u is upper triangular",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes a mathematical operation involving an upper triangular matrix, which is unrelated to the source code's functionality. The source code implements memory allocation for a dogleg_state_t structure and associated vectors, with error handling. None of the atomic claims from the summary align with the source implementation, resulting in no accurate matches.",
                "The summary presents a mathematical formula unrelated to the source code's purpose or behavior. The source function allocates and initializes a dogleg_state_t structure with multiple vectors, handles memory allocation failures, and stores parameters, but none of these critical semantic units are described. The summary fails to capture the primary purpose or any secondary details and instead provides content that is completely disconnected from the implementation.",
                "The summary presents a mathematical update formula unrelated to the source code\u2019s functionality. The function in the source code allocates and initializes a dogleg_state_t structure with multiple gsl_vector fields and error handling, not performing any arithmetic update like 'a := a + u b^h'. This constitutes NOISE, with no factual, accurate claims about the code, resulting in no alignment and zero net benefit."
            ]
        },
        "bint5": {
            "summary": "Allocates and initializes a trust_state_t structure and its associated vectors for nonlinear least squares fitting using provided parameters .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly names the allocated structure as trust_state_t instead of dogleg_state_t, which contradicts the source code. While it accurately states that vectors are allocated and initialized using provided parameters, the context of 'nonlinear least squares fitting' is not directly confirmed in the code. This yields a low proportion of accurate claims, well below half.",
                "The summary incorrectly names the allocated structure as 'trust_state_t' instead of 'dogleg_state_t', making the core claim inaccurate regarding the PRIMARY PURPOSE. While it notes allocation and initialization with provided parameters, it misidentifies the context ('nonlinear least squares fitting') which is not explicitly confirmed in the code. Secondary details such as the specific vectors allocated, their dimensions (p, n), and error handling are entirely omitted.",
                "The summary incorrectly names the allocated structure as 'trust_state_t' instead of 'dogleg_state_t', constituting a FATAL error on the primary purpose. The rest of the description about allocating associated vectors for nonlinear least squares fitting broadly matches the code and is SAFE, but the key structural misidentification severely undermines reliability."
            ]
        },
        "cpbcs": {
            "summary": "Allocates memory for a Levenberg-Marquardt optimization state, including vectors for work, function values, velocity, and acceleration based on provided parameters.\n",
            "score": [
                0.2,
                0.3,
                0.2
            ],
            "reason": [
                "The summary claims the function allocates a Levenberg-Marquardt optimization state with vectors for work, function values, velocity, and acceleration. The source code allocates a dogleg_state_t structure with vectors named dx_gn, dx_sd, workp1, workp2, and workn, and sets n, p, and params. The description of function values, velocity, and acceleration is unsupported by the code, and the algorithm mentioned (Levenberg-Marquardt) is different from the dogleg method in the source. Only the general idea of allocating vectors for work and parameters is accurate, resulting in less than half of the claims being correct.",
                "The summary captures the general idea of allocating an optimization state but misidentifies the algorithm as Levenberg-Marquardt rather than the dogleg method. It also incorrectly describes the allocated vectors as relating to work, function values, velocity, and acceleration, while the code allocates dx_gn, dx_sd, several work vectors of specified sizes, and copies parameter values. Although it hints at the primary purpose broadly, the details are inaccurate and key specifics such as error handling and exact vector roles are missing.",
                "The summary contains a FATAL inaccuracy: it describes allocation for a 'Levenberg-Marquardt optimization state' with vectors for 'function values, velocity, and acceleration,' but the code actually allocates a 'dogleg_state_t' with specific vectors named dx_gn, dx_sd, workp1, workp2, and workn, none of which are labeled or used for velocity/acceleration. This misidentifies the PRIMARY PURPOSE and misrepresents the actual structures, providing misleading semantics and no specific correct details."
            ]
        },
        "misum": {
            "summary": "Allocates and initializes a GSL multifit nonlinear workspace with memory for work, vectors and vectors for nonlinear least squares fitting\n",
            "score": [
                0.2,
                0.6,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function allocates a GSL multifit nonlinear workspace, while the source code actually allocates a `dogleg_state_t` structure specific to a nonlinear algorithm. Although it mentions allocating memory for vectors, it does not accurately describe the specific vectors (`dx_gn`, `dx_sd`, `workp1`, `workp2`, `workn`) or their purposes. The mention of 'nonlinear least squares fitting' is plausible but overly generic and mislabels the context, leading to a low proportion of accurate claims.",
                "The summary correctly identifies that the function allocates and initializes a workspace for nonlinear least squares fitting, matching the primary purpose of creating and populating a dogleg_state_t structure with various gsl_vector allocations. However, it lacks secondary details such as the specific vectors allocated (dx_gn, dx_sd, workp1, workp2, workn), explicit handling of memory allocation errors using GSL_ERROR_NULL, and storing of parameters n, p, and params. It also incorrectly generalizes the workspace as a 'GSL multifit nonlinear' one without naming the specific dogleg state type, which could be misleading.",
                "The summary contains a key inaccuracy: it describes allocating a 'GSL multifit nonlinear workspace for nonlinear least squares fitting,' but the code actually allocates a dogleg_state_t structure with vectors for a nonlinear optimization step, not specifically a GSL multifit workspace for least squares fitting. This is a FATAL error affecting the primary purpose description. While it notes memory allocation for work vectors, the mismatch in identifying the type and intended use of the allocated structure undermines accuracy."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 259168,
    "strip_function_name": "ngx_os_init",
    "strip_decompiled_code": "__int64 __fastcall ngx_os_init(\n        _QWORD *a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  int v11; // eax\n  unsigned __int64 v12; // rax\n  __int64 i; // rdx\n  __int64 v14; // rax\n  __int64 v15; // rax\n  int *v16; // rax\n  __int64 v17; // r8\n  __int64 v18; // r9\n  __m128 v19; // xmm4\n  __m128 v20; // xmm5\n\n  if ( ngx_os_specific_init() || ngx_init_setproctitle(a1, a2, a3, a4, a5, v9, v10, a8, a9) )\n    return -1LL;\n  v11 = getpagesize();\n  ngx_cacheline_size = 64LL;\n  ngx_pagesize = v11;\n  v12 = (unsigned __int64)v11 >> 1;\n  if ( v12 )\n  {\n    for ( i = ngx_pagesize_shift + 1; ; ++i )\n    {\n      v12 >>= 1;\n      if ( !v12 )\n        break;\n    }\n    ngx_pagesize_shift = i;\n  }\n  v14 = ngx_ncpu;\n  if ( !ngx_ncpu )\n  {\n    v14 = sysconf(84);\n    ngx_ncpu = v14;\n  }\n  if ( v14 <= 0 )\n    ngx_ncpu = 1LL;\n  v15 = sysconf(190);\n  if ( v15 > 0 )\n    ngx_cacheline_size = v15;\n  ngx_cpuinfo();\n  if ( getrlimit64(RLIMIT_NOFILE, &rlmt) == -1 )\n  {\n    if ( *a1 > 1uLL )\n    {\n      v16 = __errno_location();\n      ngx_log_error_core(\n        2uLL,\n        (__int64)a1,\n        *v16,\n        (unsigned int)\"getrlimit(RLIMIT_NOFILE) failed\",\n        v17,\n        v18,\n        a2,\n        a3,\n        a4,\n        a5,\n        v19,\n        v20,\n        a8,\n        a9);\n    }\n    return -1LL;\n  }\n  ngx_inherited_nonblocking = 1LL;\n  ngx_max_sockets = rlmt.rlim_cur;\n  srandom(*(_DWORD *)(ngx_cached_time + 8) ^ *(_DWORD *)ngx_cached_time ^ (ngx_pid << 16));\n  return 0LL;\n}\n",
    "function_name": "ngx_os_init",
    "decompiled_code": "ngx_int_t __fastcall ngx_os_init(ngx_log_t *log)\n{\n  int v1; // eax\n  unsigned __int64 v2; // rax\n  ngx_uint_t i; // rdx\n  __int64 v4; // rax\n  __int64 v5; // rax\n  int *v6; // rax\n\n  if ( ngx_os_specific_init(log) || ngx_init_setproctitle(log) )\n    return -1LL;\n  v1 = getpagesize();\n  ngx_cacheline_size = 64LL;\n  ngx_pagesize = v1;\n  v2 = (unsigned __int64)v1 >> 1;\n  if ( v2 )\n  {\n    for ( i = ngx_pagesize_shift + 1; ; ++i )\n    {\n      v2 >>= 1;\n      if ( !v2 )\n        break;\n    }\n    ngx_pagesize_shift = i;\n  }\n  v4 = ngx_ncpu;\n  if ( !ngx_ncpu )\n  {\n    v4 = sysconf(84);\n    ngx_ncpu = v4;\n  }\n  if ( v4 <= 0 )\n    ngx_ncpu = 1LL;\n  v5 = sysconf(190);\n  if ( v5 > 0 )\n    ngx_cacheline_size = v5;\n  ngx_cpuinfo();\n  if ( getrlimit64(__rlimit_resource::RLIMIT_NOFILE, (struct rlimit64 *)&rlmt) == -1 )\n  {\n    if ( log->log_level > 1 )\n    {\n      v6 = __errno_location();\n      ngx_log_error_core(2uLL, log, *v6, \"getrlimit(RLIMIT_NOFILE) failed\");\n    }\n    return -1LL;\n  }\n  ngx_inherited_nonblocking = 1LL;\n  ngx_max_sockets = rlmt.rlim_cur;\n  srandom(LODWORD(ngx_cached_time->msec) ^ LODWORD(ngx_cached_time->sec) ^ (ngx_pid << 16));\n  return 0LL;\n}\n",
    "source_code": "\n\nngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    ngx_time_t  *tp;\n    ngx_uint_t   n;\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    long         size;\n#endif\n\n#if (NGX_HAVE_OS_SPECIFIC_INIT)\n    if (ngx_os_specific_init(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_init_setproctitle(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_pagesize = getpagesize();\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n    if (ngx_ncpu == 0) {\n        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n#endif\n\n    if (ngx_ncpu < 1) {\n        ngx_ncpu = 1;\n    }\n\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n    if (size > 0) {\n        ngx_cacheline_size = size;\n    }\n#endif\n\n    ngx_cpuinfo();\n\n    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, errno,\n                      \"getrlimit(RLIMIT_NOFILE) failed\");\n        return NGX_ERROR;\n    }\n\n    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n\n#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n    ngx_inherited_nonblocking = 1;\n#else\n    ngx_inherited_nonblocking = 0;\n#endif\n\n    tp = ngx_timeofday();\n    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}",
    "comment": "Initializes operating system parameters, retrieves CPU information, sets process title, and configures resource limits for a server application.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the OS library , sets environment variables , and prepares for cache management in the NGINX framework .\n",
    "cpbcs_sum": "Initializes the system by allocating memory, setting up signal handling and registering system core operations.\n",
    "misum_sum": "Initializes the per-CPU memory management system by allocating memory for the current memory, setting defaults for processor management.\n",
    "decom_sum": "Initializes OS-specific settings, determines page and cache sizes, configures CPU info, checks file descriptor limits, and seeds the random number generator.",
    "cfg_sum": "Initializes OS-specific settings, determines CPU and memory parameters, configures resource limits, and seeds randomness, returning -1 on any initialization failure.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only the vague phrase 'push a pointer type,' which does not match or accurately describe any specific functionality or semantics from the provided source code. It neither captures relevant details about initialization, system calls, or variable assignments, resulting in 0% accurate claims.",
                "The summary 'push a pointer type' does not reflect the primary purpose or any secondary details of the source code, which initializes OS-specific settings, retrieves system limits, and configures runtime parameters. It is unrelated to observable behavior or implementation specifics, making it inaccurate and providing no coverage of critical semantic units.",
                "The summary 'push a pointer type.' is vague and does not reflect any actual behavior or purpose of the provided source code. It is [INACCURATE] as it makes no relevant or factual claim about the initialization process, system calls, or configuration performed in ngx_os_init. The worst failure mode is NOISE, with no accurate claims to provide insight, resulting in no net benefit."
            ]
        },
        "bint5": {
            "summary": "Initializes the OS library , sets environment variables , and prepares for cache management in the NGINX framework .\n",
            "score": [
                0.3,
                0.4,
                0.4
            ],
            "reason": [
                "The summary's claims about initializing the OS library are broadly aligned with the function's role, but it inaccurately states that environment variables are set, which is not reflected in the source code. It also omits key specifics such as page size calculation, processor count retrieval, cache line size configuration, and file descriptor limits. The 'prepares for cache management' claim is partially accurate given the cacheline size setup, but overall more than half of the claims lack precise grounding in the source.",
                "The summary broadly states that the function initializes the OS library, sets environment variables, and prepares for cache management, which loosely aligns with the general initialization purpose but misses critical specifics from the source code. It omits details such as process title initialization, fetching page size and CPU count, handling error conditions, setting socket limits, random number seeding, and calling OS-specific initialization functions. The summary also inaccurately mentions 'environment variables,' which is not reflected in the code, making it partially inaccurate.",
                "The summary contains mostly inaccurate claims. It incorrectly states that the function sets environment variables, which is not reflected in the source code, and that it prepares for cache management in a broad, vague way that does not match actual detailed behavior, such as obtaining pagesize and cache line size and initializing CPU info. There is no mention of crucial operations like process title initialization, file descriptor limit retrieval, or random seed setup. The inaccuracies are mainly NOISE, leading to low informational value and minimal alignment with the source semantics."
            ]
        },
        "cpbcs": {
            "summary": "Initializes the system by allocating memory, setting up signal handling and registering system core operations.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function allocates memory, sets up signal handling, and registers system core operations. None of these actions are reflected in the actual source code, which initializes OS-specific features, sets process title, determines page size, CPU info, max sockets, cache line size, and seeds the random number generator. All claims in the summary are inaccurate with respect to the implementation.",
                "The summary describes memory allocation, signal handling, and registering core operations, none of which are present in the source code. The actual implementation initializes OS-specific settings, process title, page size, CPU/cache info, file descriptor limits, and randomness seed. Since the summary misses the primary purpose and contains inaccurate claims unrelated to the code, it fails to capture any correct, verifiable details.",
                "The summary makes specific claims about allocating memory, setting up signal handling, and registering system core operations, none of which are present in the source code. The function instead initializes process title, queries system information (page size, CPU count, cache line size), retrieves resource limits, sets nonblocking mode, seeds the random number generator, and returns OK or ERROR based on conditions. These mismatched claims target the core purpose inaccurately, causing a FATAL error on the primary purpose."
            ]
        },
        "misum": {
            "summary": "Initializes the per-CPU memory management system by allocating memory for the current memory, setting defaults for processor management.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes a per-CPU memory management system and allocates memory, which is not reflected in the source code. The implementation instead sets process title, retrieves page size, cache line size, CPU count, resource limits, and seeds the random number generator. None of the summary's key statements about memory allocation or per-CPU memory management are accurate. Therefore, the proportion of accurate claims is 0%, indicating complete mismatch.",
                "The summary claims the function initializes a per-CPU memory management system and allocates memory for the current memory, which is inaccurate. The source code shows it performs OS-specific initialization, sets process title, retrieves system parameters (page size, CPU count, cache line size), sets up CPU info, file descriptor limits, and a random seed \u2014 not memory allocation or per-CPU memory management. It misses the primary purpose and all key secondary details, leading to a mismatch with the implementation.",
                "The summary claims the function initializes a per-CPU memory management system and allocates memory for current memory, which is not reflected in the source code. The actual implementation initializes OS-level environment for Nginx, including setting process title, determining page size, CPU count, cache line size, file descriptor limits, inherited non-blocking behavior, and seeding the random number generator. The mismatch is a FATAL error targeting the primary purpose of the function, as it misrepresents key operations entirely."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585363328,
    "strip_function_name": "sub_FFFFFFFF81637580",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81637580(__int64 a1, __int64 a2, int a3, int a4)\n{\n  int v4; // r8d\n  int v5; // ebx\n  __int64 result; // rax\n  __int64 v7; // r9\n  unsigned int v8; // r9d\n  unsigned int v9; // r8d\n  __int64 v10; // rdx\n\n  v4 = *(_DWORD *)(a2 + 64);\n  v5 = v4 - a3;\n  if ( v4 - a3 >= 0 )\n  {\n    result = 1LL;\n    if ( a4 - *(_DWORD *)(a2 + 68) >= 0 )\n      return result;\n  }\n  v7 = *(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200);\n  result = 0LL;\n  if ( *(unsigned __int16 *)(v7 + 4) <= 1u || a3 - *(_DWORD *)(a2 + 68) >= 0 )\n    return result;\n  v8 = *(unsigned __int16 *)(v7 + 2);\n  if ( v5 < 0 )\n  {\n    v9 = a3 - v4;\n    if ( v8 > v9 )\n    {\n      v10 = v8;\n      goto LABEL_12;\n    }\n  }\n  else\n  {\n    v9 = a4 - v4;\n    if ( v8 > v9 )\n      return 4294967274LL;\n  }\n  if ( v9 <= v8 )\n  {\n    v10 = v9;\nLABEL_12:\n    result = sub_FFFFFFFF81641390(a1, a2, v10, v8);\n    if ( (int)result >= 0 )\n      return v5 >= 0;\n    return result;\n  }\n  v10 = v8 * (v9 / v8);\n  if ( v5 >= 0 )\n    goto LABEL_12;\n  if ( v9 <= (unsigned int)v10 )\n    goto LABEL_12;\n  v10 = v8 + (unsigned int)v10;\n  result = 0LL;\n  if ( (unsigned int)v10 < *(_DWORD *)(a2 + 104) )\n    goto LABEL_12;\n  return result;\n}\n",
    "function_name": "tcp_match_skb_to_sack",
    "decompiled_code": "__int64 __fastcall tcp_match_skb_to_sack(\n        __int64 a1,\n        __int64 a2,\n        int a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  int v12; // r8d\n  int v13; // ebx\n  __int64 result; // rax\n  __int64 v15; // r9\n  unsigned int v16; // r9d\n  unsigned int v17; // ecx\n  __int64 v18; // r8\n  __int64 v19; // rdx\n  unsigned int v20; // edx\n\n  v12 = *(_DWORD *)(a2 + 64);\n  v13 = v12 - a3;\n  if ( v12 - a3 >= 0 )\n  {\n    result = 1LL;\n    if ( a4 - *(_DWORD *)(a2 + 68) >= 0 )\n      return result;\n  }\n  v15 = *(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200);\n  result = 0LL;\n  if ( *(unsigned __int16 *)(v15 + 4) <= 1u || a3 - *(_DWORD *)(a2 + 68) >= 0 )\n    return result;\n  v16 = *(unsigned __int16 *)(v15 + 2);\n  if ( v13 < 0 )\n  {\n    v20 = a3 - v12;\n    v18 = v20;\n    if ( v16 > v20 )\n    {\n      v19 = v16;\n      goto LABEL_12;\n    }\n  }\n  else\n  {\n    v17 = a4 - v12;\n    v18 = v17;\n    if ( v16 > v17 )\n      return 4294967274LL;\n  }\n  if ( (unsigned int)v18 <= v16 )\n  {\n    v19 = (unsigned int)v18;\nLABEL_12:\n    result = tcp_fragment(a1, a2, v19, v16, v18, v16, a5, a6, a7, a8, a9, a10, a11, a12);\n    if ( (int)result >= 0 )\n      return v13 >= 0;\n    return result;\n  }\n  v19 = v16 * ((unsigned int)v18 / v16);\n  if ( v13 >= 0 )\n    goto LABEL_12;\n  if ( (unsigned int)v18 <= (unsigned int)v19 )\n    goto LABEL_12;\n  v19 = v16 + (unsigned int)v19;\n  result = 0LL;\n  if ( (unsigned int)v19 < *(_DWORD *)(a2 + 104) )\n    goto LABEL_12;\n  return result;\n}\n",
    "source_code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}",
    "comment": "Determines if a TCP segment belongs to the SACK range and fragments it accordingly based on MSS and sequence numbers.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Validates TCP acknowledgment by checking sequence numbers , sequence numbers , and acknowledgment conditions in a socket buffer .\n",
    "cpbcs_sum": "Validates TCP MSS options in a packet against specified criteria and alignment, returning errors for invalid conditions.\n",
    "misum_sum": "Validates the TCP window size in a connection tracking table and adds it to the appropriate socket.\n",
    "decom_sum": "Validates position parameters against structure bounds, then conditionally invokes a data transfer routine using calculated offsets and block sizes.",
    "cfg_sum": "Validates positional offsets against stored limits, adjusts parameters, and triggers a state update routine, returning success or specific error codes based on threshold checks.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a vague statement unrelated to the source code\u2019s actual behavior. It does not describe any facts about tcp_match_skb_to_sack or its logic, meaning none of its claims align with the source implementation. As a result, there are no accurate claims to consider.",
                "The summary 'push a pointer type.' is unrelated to the source code's purpose, which is determining if a TCP segment matches a SACK block and potentially fragmenting the skb. It neither captures the primary purpose nor any secondary details, making it entirely inaccurate and non-informative in this context.",
                "The summary consists of a vague phrase unrelated to the source code semantics. It does not accurately describe the function's purpose, inputs, outputs, or logic, thus falling into the NOISE category. There are no specific or useful claims that provide insight, and the lack of alignment with the actual TCP SACK matching and fragmentation logic results in minimal informational value."
            ]
        },
        "bint5": {
            "summary": "Validates TCP acknowledgment by checking sequence numbers , sequence numbers , and acknowledgment conditions in a socket buffer .\n",
            "score": [
                0.3,
                0.5,
                0.5
            ],
            "reason": [
                "The summary contains a single broad claim about validating TCP acknowledgments through sequence number and acknowledgment checks. While it loosely reflects the code\u2019s comparison of sequence numbers to determine in_sack, it omits critical implementation details such as MSS handling, packet length calculations, fragmentation, and specific conditions tied to SACK logic. The phrasing is vague, lacking clear alignment with concrete code semantics, resulting in low accuracy proportion.",
                "The summary vaguely states that the function validates TCP acknowledgment using sequence numbers and conditions, which loosely matches the primary purpose of determining if a skb falls within a SACK block. However, it repeats 'sequence numbers' redundantly, omits key secondary details such as handling multi-packet skbs, MSS-based fragmentation, return values (-EINVAL, error codes), and rounding logic. It lacks specificity about in_sack logic and edge case handling, resulting in incomplete coverage despite capturing the high-level purpose.",
                "The summary makes a very broad claim about validating TCP acknowledgments via sequence number checks in a socket buffer. While this is loosely related to the function's behavior, it omits critical details such as packet fragmentation, MSS alignment, and the specific in_sack logic. The claim is too generic to be clearly inaccurate but provides minimal insight, resulting in low informational gain. The worst failure mode is NOISE due to the lack of specificity."
            ]
        },
        "cpbcs": {
            "summary": "Validates TCP MSS options in a packet against specified criteria and alignment, returning errors for invalid conditions.\n",
            "score": [
                0.2,
                0.3,
                0.2
            ],
            "reason": [
                "The summary makes a broad claim about validating TCP MSS options, which is partially misleading. The source function primarily determines whether a TCP segment falls within a specified SACK range and, if certain conditions are met, performs fragmentation considering MSS alignment. While it does return errors for invalid packet length conditions, it is not focused on validating TCP MSS options in a generic sense. This results in low alignment, as the main semantics of SACK matching are omitted and replaced by an inaccurate emphasis on MSS validation.",
                "The summary broadly states that the function validates TCP MSS options against certain criteria and returns errors for invalid conditions, which loosely aligns with parts of the code where MSS is checked and errors like -EINVAL are returned. However, it misses the primary purpose of matching a TCP segment against a SACK range and fragmenting the skb when necessary. It omits key secondary details such as sequence range checks, handling multi-packet skbs, rounding lengths to MSS boundaries, and the specific branching logic. The description is too general and lacks coverage of the observable behavior defined in the source.",
                "The summary makes a broad claim about validating TCP MSS options, which is inaccurate because the function matches a TCP skb to a SACK range and conditionally fragments it based on packet length and MSS, not validating TCP MSS options per se. This is a FATAL error since it misrepresents the primary purpose and key logic of the code. There are no accurate specifics that match the implementation, so the net benefit is very low."
            ]
        },
        "misum": {
            "summary": "Validates the TCP window size in a connection tracking table and adds it to the appropriate socket.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function validates TCP window size and updates a connection tracking table, adding to a socket. The source code does not perform TCP window size validation or interact with a connection tracking table; it instead checks if a TCP segment falls within a SACK range and potentially fragments the skb accordingly. All claims are inaccurate with respect to the function's semantics.",
                "The summary is entirely inaccurate: it describes validating the TCP window size and updating a connection tracking table, which are unrelated to the actual function. The source code\u2019s primary purpose is to check if a TCP segment is within specified sequence boundaries for SACK processing and possibly fragment it, with handling for multi-packet sk_buffs, MSS alignment, and error returns. None of these critical semantics are mentioned in the summary, so the primary purpose is missed and no accurate claims are made.",
                "The summary claims the function validates the TCP window size and updates a connection tracking table, which is unrelated to the source code. The actual code determines whether a TCP segment falls within a SACK block and may fragment the skb based on MSS, with no reference to window size or connection tracking. This is a FATAL inaccuracy targeting the primary purpose, making the description misleading for understanding the code."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5729178,
    "strip_function_name": "sub_576B9A",
    "strip_decompiled_code": "__int64 __fastcall sub_576B9A(\n        __int64 a1,\n        int a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13)\n{\n  bool v14; // zf\n  __int64 v15; // rdi\n  int v16; // ebx\n  __int64 v17; // rbx\n  _QWORD *v18; // rax\n  int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // rax\n  _QWORD *v23; // r13\n\n  v14 = *(_BYTE *)(a1 + 21) == 0;\n  v15 = *(_QWORD *)a1;\n  if ( v14 )\n  {\n    LODWORD(v17) = *(_DWORD *)(a1 + 8) - ((8 * a2 + 120) & 0xFFFFFF80);\n    if ( (a2 & 0xF) == 0 )\n    {\n      v20 = *(_DWORD *)(a1 + 12);\n      v17 = (int)v17;\n      v21 = (unsigned int)(v20 + 128);\n      *(_DWORD *)(a1 + 12) = v21;\n      v22 = sub_51814E(v15, (const char *)(v20 + 129), v21, a12, a13, a3, a4, a5, a6, a7, a8, a9, a10);\n      *(_QWORD *)a1 = v22;\n      v23 = (_QWORD *)(v22 + 8LL * a2);\n      sub_4004F0(v23 + 16, v23);\n      *(_DWORD *)(a1 + 8) += 128;\n      v18 = v23;\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v16 = *(_DWORD *)(a1 + 8);\n    *(_BYTE *)(a1 + 21) = 0;\n    LODWORD(v17) = v16 - ((8 * a2 + 128) & 0xFFFFFF80);\n  }\n  v17 = (int)v17;\n  v18 = (_QWORD *)(v15 + 8LL * a2);\nLABEL_4:\n  *(_BYTE *)(a1 + 20) = 0;\n  *v18 = v17;\n  return (unsigned int)(a2 + 1);\n}\n",
    "function_name": "o_save_ptr_helper",
    "decompiled_code": "__int64 __fastcall o_save_ptr_helper(\n        __int64 a1,\n        int a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10,\n        __int64 a11,\n        __int64 a12,\n        unsigned __int64 a13)\n{\n  bool v14; // zf\n  const char *v15; // rdi\n  int v16; // ebx\n  __int64 v17; // rbx\n  char *v18; // rax\n  int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // rax\n  __int64 v23; // r13\n\n  v14 = *(_BYTE *)(a1 + 21) == 0;\n  v15 = *(const char **)a1;\n  if ( v14 )\n  {\n    LODWORD(v17) = *(_DWORD *)(a1 + 8) - ((8 * a2 + 120) & 0xFFFFFF80);\n    if ( (a2 & 0xF) == 0 )\n    {\n      v20 = *(_DWORD *)(a1 + 12);\n      v17 = (int)v17;\n      v21 = (unsigned int)(v20 + 128);\n      *(_DWORD *)(a1 + 12) = v21;\n      xrealloc(v15, v20 + 129, v21, a12, a13, a3, a4, a5, a6, a7, a8, a9, a10);\n      *(_QWORD *)a1 = v22;\n      v23 = v22 + 8LL * a2;\n      memmove((void *)(v23 + 128), (const void *)v23, (int)v17);\n      *(_DWORD *)(a1 + 8) += 128;\n      v18 = (char *)v23;\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v16 = *(_DWORD *)(a1 + 8);\n    *(_BYTE *)(a1 + 21) = 0;\n    LODWORD(v17) = v16 - ((8 * a2 + 128) & 0xFFFFFF80);\n  }\n  v17 = (int)v17;\n  v18 = (char *)&v15[8 * a2];\nLABEL_4:\n  *(_BYTE *)(a1 + 20) = 0;\n  *(_QWORD *)v18 = v17;\n  return (unsigned int)(a2 + 1);\n}\n",
    "source_code": "static int o_save_ptr_helper(o_string *o, int n)\n{\n\tchar **list = (char**)o->data;\n\tint string_start;\n\tint string_len;\n\n\tif (!o->has_empty_slot) {\n\t\tstring_start = ((n + 0xf) & ~0xf) * sizeof(list[0]);\n\t\tstring_len = o->length - string_start;\n\t\tif (!(n & 0xf)) { /* 0, 0x10, 0x20...? */\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (growing)\\n\", n, string_len, string_start);\n\t\t\t/* list[n] points to string_start, make space for 16 more pointers */\n\t\t\to->maxlen += 0x10 * sizeof(list[0]);\n\t\t\to->data = xrealloc(o->data, o->maxlen + 1);\n\t\t\tlist = (char**)o->data;\n\t\t\tmemmove(list + n + 0x10, list + n, string_len);\n\t\t\to->length += 0x10 * sizeof(list[0]);\n\t\t} else {\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d\\n\",\n\t\t\t\t\tn, string_len, string_start);\n\t\t}\n\t} else {\n\t\t/* We have empty slot at list[n], reuse without growth */\n\t\tstring_start = ((n+1 + 0xf) & ~0xf) * sizeof(list[0]); /* NB: n+1! */\n\t\tstring_len = o->length - string_start;\n\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (empty slot)\\n\",\n\t\t\t\tn, string_len, string_start);\n\t\to->has_empty_slot = 0;\n\t}\n\to->has_quoted_part = 0;\n\tlist[n] = (char*)(uintptr_t)string_len;\n\treturn n + 1;\n}",
    "comment": "Reallocates string storage for a list, handles empty slots, and updates the length and state of the string data structure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adjusts the position of a pipe or retrieves its current position , ensuring it remains within valid boundaries for reading or writing .\n",
    "cpbcs_sum": "Allocates a buffer, copies a character from a linked list, and resets buffer sizes in an HTTP caching state.\n",
    "misum_sum": "Allocates a new nameserver buffer, dynamically resizing the next URB if necessary, and updates the last segment position accordingly.\n",
    "decom_sum": "Updates an indexed entry in a memory block, allocating and initializing a new 128\u2011byte slot if needed, and returns the next index.",
    "cfg_sum": "Adjusts buffer offsets and state flags, invokes a data processing routine when alignment conditions are met, and updates entry values before returning the next index.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains only a vague statement, 'push a pointer type,' which does not accurately reflect the specific implementation details in the source code. The function manipulates a list of string pointers, adjusts memory allocation when needed, handles empty slots, and returns an updated index, none of which are captured. The claim is too broad and low-information to be tagged as accurate, resulting in no meaningful alignment with the source.",
                "The summary is overly vague, stating only that a pointer type is pushed, which misses the primary purpose of the function\u2014managing and possibly expanding a list of pointers within an o_string structure, handling empty slots, adjusting memory allocation, updating length and flags, and computing string_start/string_len. It fails to capture any observable behavior, conditions, or secondary details such as growth when n is divisible by 16, use of xrealloc, memmove, or flag changes.",
                "The summary contains a single vague claim that does not accurately describe the function\u2019s detailed behavior. It ignores key operations such as reallocating memory, adjusting list slots, handling the empty slot condition, and managing string offsets. This is NOISE with very low informational value and no FATAL contradiction, leading to low gain and poor alignment with the evaluation steps."
            ]
        },
        "bint5": {
            "summary": "Adjusts the position of a pipe or retrieves its current position , ensuring it remains within valid boundaries for reading or writing .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes adjusting or retrieving the position of a pipe and ensuring boundaries for reading or writing, which is unrelated to the source code. The source code manages string pointer offsets, memory reallocation, and slot handling in a data structure, with no concepts of pipes or I/O boundaries. All claims are inaccurate, resulting in complete misalignment.",
                "The summary describes adjusting or retrieving the position of a pipe and ensuring valid boundaries for I/O, which is unrelated to the source code. The function actually manages a list of string pointers in a custom object, handling memory reallocation, slot reuse, and updating state flags. The summary misses the primary purpose entirely and introduces an inaccurate domain context.",
                "The summary's single claim about adjusting or retrieving a pipe position within boundaries for I/O is completely unrelated to the actual code, which manages an array of string pointers, reallocates memory, and updates internal length and state flags. This is pure NOISE, with no accurate alignment to the source's primary purpose or key behaviors, resulting in no useful insight and misleading context."
            ]
        },
        "cpbcs": {
            "summary": "Allocates a buffer, copies a character from a linked list, and resets buffer sizes in an HTTP caching state.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about allocating a buffer, copying a character from a linked list, and resetting buffer sizes in an HTTP caching state are inaccurate. The source code deals with managing an array of string pointers, handling growth or reuse based on empty slots, and updating metadata fields. None of the stated actions or HTTP caching context are present in the implementation, resulting in 0% accurate claims.",
                "The summary contains claims unrelated to the actual code. The function does not allocate a generic buffer or copy a character from a linked list, nor does it operate on an HTTP caching state. Instead, the code manages a dynamic array of string pointers within an `o_string` structure, reallocating memory for 16 additional pointers when necessary, handling empty slots, and updating internal length and flags. The primary purpose and all secondary details in the source are missed, making the summary entirely inaccurate.",
                "The summary\u2019s claims are entirely inaccurate. The source function does not allocate a buffer in the described sense, does not copy a character from a linked list, and has no relation to HTTP caching state or resetting buffer sizes. Instead, it manipulates a list of string pointers in an o_string structure, reallocating space in blocks of 16, shifting entries with memmove, and updating metadata flags. These errors are FATAL because they misstate the primary purpose and key operations of the code."
            ]
        },
        "misum": {
            "summary": "Allocates a new nameserver buffer, dynamically resizing the next URB if necessary, and updates the last segment position accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary introduces concepts such as a 'nameserver buffer' and 'URB' that are absent from the source code, which instead manipulates a list of string pointers within an o_string structure and resizes memory when needed. It fails to accurately reflect the actual pointer arithmetic, memory reallocation, and flag updates present in the implementation, resulting in no fact-based claims aligning with the source.",
                "The summary contains inaccurate claims not grounded in the source code. It describes allocating a nameserver buffer, resizing a URB, and updating a last segment position\u2014none of which match the function\u2019s actual purpose. The source code handles pointer list management within an o_string, conditionally reallocating to make space for additional pointers or reusing an empty slot, and updating specific object fields. The summary fails to capture the primary purpose and omits all secondary details, resulting in no accurate coverage.",
                "The summary contains multiple inaccurate claims that contradict the source code\u2019s actual semantics. It describes allocating a nameserver buffer, resizing a URB, and updating a last segment position\u2014none of which occur in the provided function. The code actually manipulates an array of string pointers, adjusts capacity in blocks of 16 when needed, and updates pointer positions based on available slots. These are FATAL errors impacting the primary purpose and key I/O understanding, resulting in high negative impact and zero alignment with the source logic."
            ]
        }
    }
}
{
    "project_name": "datamash",
    "function_addr": 31920,
    "strip_function_name": "sub_7CB0",
    "strip_decompiled_code": "void __fastcall sub_7CB0(void *ptr)\n{\n  __int64 v1; // r12\n  unsigned __int64 v2; // rbp\n  void *v4; // rdi\n  bool v5; // zf\n  __int64 v6; // r12\n  unsigned __int64 v7; // rbp\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  void *v10; // r13\n  void **v11; // rbp\n  void **v12; // r12\n  void *v13; // rdi\n\n  if ( !ptr )\n    __assert_fail(\"p != NULL\", \"src/op-parser.c\", 0x319u, \"datamash_ops_free\");\n  v1 = 0LL;\n  v2 = 0LL;\n  while ( *((_QWORD *)ptr + 2) > v2 )\n  {\n    ++v2;\n    v4 = *(void **)(*((_QWORD *)ptr + 1) + v1 + 16);\n    v1 += 24LL;\n    free(v4);\n  }\n  free(*((void **)ptr + 1));\n  v5 = *((_QWORD *)ptr + 5) == 0LL;\n  *((_QWORD *)ptr + 1) = 0LL;\n  if ( !v5 )\n  {\n    v6 = 0LL;\n    v7 = 0LL;\n    do\n    {\n      ++v7;\n      v8 = v6 + *((_QWORD *)ptr + 4);\n      v6 += 192LL;\n      sub_96F0(v8);\n    }\n    while ( *((_QWORD *)ptr + 5) > v7 );\n  }\n  free(*((void **)ptr + 4));\n  v9 = qword_222938;\n  *((_QWORD *)ptr + 4) = 0LL;\n  v10 = qword_222948;\n  if ( v9 )\n  {\n    v11 = (void **)((char *)qword_222948 + 16);\n    v12 = (void **)((char *)qword_222948 + 32 * v9 + 16);\n    do\n    {\n      v13 = *v11;\n      v11 += 4;\n      free(v13);\n    }\n    while ( v12 != v11 );\n  }\n  free(v10);\n  qword_222948 = 0LL;\n  qword_222940 = 0LL;\n  qword_222938 = 0LL;\n  free(qword_222930);\n  qword_222928 = 0LL;\n  qword_222920 = 0LL;\n  free(ptr);\n}\n",
    "function_name": "datamash_ops_free",
    "decompiled_code": "void __fastcall datamash_ops_free(datamash_ops *p)\n{\n  __int64 v1; // r12\n  size_t i; // rbp\n  char *name; // rdi\n  bool v5; // zf\n  __int64 v6; // r12\n  size_t v7; // rbp\n  fieldop *v8; // rdi\n  size_t v9; // rax\n  parser_field_t *v10; // r13\n  char **p_name; // rbp\n  char **v12; // r12\n  char *v13; // rdi\n\n  if ( p )\n  {\n    v1 = 0LL;\n    for ( i = 0LL; p->num_grps > i; ++i )\n    {\n      name = p->grps[v1++].name;\n      ((void (__fastcall *)(char *))unk_28E0)(name);\n    }\n    ((void (__fastcall *)(group_column_t *))unk_28E0)(p->grps);\n    v5 = p->num_ops == 0;\n    p->grps = 0LL;\n    if ( !v5 )\n    {\n      v6 = 0LL;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        v8 = &p->ops[v6++];\n        field_op_free(v8);\n      }\n      while ( p->num_ops > v7 );\n    }\n    ((void (__fastcall *)(fieldop *))unk_28E0)(p->ops);\n    v9 = fields_used;\n    p->ops = 0LL;\n    v10 = fields;\n    if ( v9 )\n    {\n      p_name = &fields->name;\n      v12 = &fields[v9].name;\n      do\n      {\n        v13 = *p_name;\n        p_name += 4;\n        ((void (__fastcall *)(char *))unk_28E0)(v13);\n      }\n      while ( v12 != p_name );\n    }\n    ((void (__fastcall *)(parser_field_t *))unk_28E0)(v10);\n    fields = 0LL;\n    fields_alloc = 0LL;\n    fields_used = 0LL;\n    ((void (__fastcall *)(parser_param_t *))unk_28E0)(params);\n    params_alloc = 0LL;\n    params_used = 0LL;\n    JUMPOUT(0x28E0LL);\n  }\n  __assert_fail(\"p != NULL\", \"src/op-parser.c\", 0x319u, \"datamash_ops_free\");\n}\n",
    "source_code": "\nvoid\ndatamash_ops_free ( struct datamash_ops* p )\n{\n  assert (p != NULL);                            /* LCOV_EXCL_LINE */\n  for (size_t i=0; i<p->num_grps; ++i)\n    free (p->grps[i].name);\n  free (p->grps);\n  p->grps = NULL;\n\n  #ifndef _STANDALONE_\n  for (size_t i=0; i<p->num_ops; ++i)\n    field_op_free (&p->ops[i]);\n  #endif\n\n  free (p->ops);\n  p->ops = NULL;\n\n  for  (size_t i=0; i<_fields_used; ++i) {\n    free (_fields[i].name);\n  }\n  free (_fields);\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  free (_params);\n  _params_alloc = 0;\n  _params_used = 0;\n\n  free (p);\n}",
    "comment": "Frees allocated memory for operation groups, fields, parameters, and the datamash_ops structure while ensuring no memory leaks occur.",
    "hext5_sum": "add a value (from input) to the current field operation.",
    "bint5_sum": "Frees all allocated memory associated with the ` datamash_ops ` structure and its associated data structures .\n",
    "cpbcs_sum": "Frees all allocated memory for a DFA structure and its associated variables in a thread-safe manner.\n",
    "misum_sum": "Frees all memory allocated for all types and their associated resources when the count exceeds the defined limit.\n",
    "decom_sum": "Frees all dynamically allocated memory associated with operation parsing structures and global buffers, then resets related counters and pointers to zero.",
    "cfg_sum": "Frees all dynamically allocated resources tied to an operation parser, resets related fields, and clears associated global data structures and counters.",
    "work_score": {
        "hext5": {
            "summary": "add a value (from input) to the current field operation.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a value from input to the current field operation, which directly contradicts the source code. The implementation strictly frees allocated memory for groups, operations, fields, and parameters, without performing any addition or input handling. As the single claim is entirely inaccurate, none of the claims are accurate.",
                "The summary incorrectly states that the function adds a value to the current field operation, whereas the source code shows it frees memory associated with a datamash_ops structure and its components. This misses the primary purpose entirely and introduces a contradictory claim unrelated to the actual code behavior.",
                "The summary claims the function adds a value from input to the current field operation, which is directly contradictory to the source code behavior. The actual implementation frees allocated memory in various structures and sets pointers to NULL, with no addition or modification of field operations. This is a FATAL error targeting the primary purpose of the function, making the description highly misleading."
            ]
        },
        "bint5": {
            "summary": "Frees all allocated memory associated with the ` datamash_ops ` structure and its associated data structures .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function frees all allocated memory for the `datamash_ops` structure and its related data structures. The source code confirms multiple `free` calls for the structure members (`grps`, `ops`, `_fields`, `_params`) and the structure itself, matching the broad claim without contradiction. As this single atomic claim is accurate, the proportion of accurate claims exceeds 80%, showing strong alignment.",
                "The summary correctly captures the primary purpose of the function \u2014 freeing all allocated memory related to the `datamash_ops` structure and associated data \u2014 which aligns with the source code's behavior. However, it omits secondary details such as freeing group names, conditionally calling `field_op_free` when not in standalone mode, resetting pointers to NULL, and clearing allocation/usage counters for `_fields` and `_params`. This lack of specificity limits completeness despite accurate primary purpose coverage.",
                "The summary makes a single broad SAFE claim that the function frees all allocated memory for the `datamash_ops` structure and related data. This matches the source code\u2019s behavior of freeing names, group arrays, operation arrays, global fields, parameters, and the structure itself. There are no contradictory or irrelevant statements, but the claim lacks specific details about the exact fields and conditions, resulting in low informational gain. The worst failure mode is absent as there is no FATAL or NOISE present."
            ]
        },
        "cpbcs": {
            "summary": "Frees all allocated memory for a DFA structure and its associated variables in a thread-safe manner.\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as freeing a DFA structure and emphasizes thread safety, neither of which is reflected in the source code. The code actually frees memory for a 'datamash_ops' structure and its fields, parameters, groups, and operations, with no thread-safety mechanisms. Both claims in the summary are inaccurate, resulting in no accurate correspondence to the source.",
                "The summary incorrectly describes the function as freeing a DFA structure and being thread-safe, neither of which is supported by the source code. The source code shows memory deallocation for a 'datamash_ops' struct, its groups, operations, and related global arrays, with no DFA implementation or explicit thread-safety mechanisms. While it matches the general idea of freeing allocated memory, the misidentified structure type and added thread-safety claim make it inaccurate and fail to capture the primary purpose precisely.",
                "The summary claims the function frees memory for a DFA structure and does so in a thread-safe manner. This is inaccurate: the source code deals with freeing a 'datamash_ops' structure, not a DFA, and there is no indication of thread-safety mechanisms (e.g., locks). The DFA and thread-safety references are semantic errors targeting the primary purpose and behavior, making them FATAL inaccuracies. No accurate claims are present, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Frees all memory allocated for all types and their associated resources when the count exceeds the defined limit.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that memory freeing occurs only when counts exceed a defined limit, but the source code frees all allocated resources unconditionally without checking for limits. This is a direct contradiction of the code\u2019s semantics, meaning the claim is inaccurate and does not align with the implementation.",
                "The summary incorrectly describes the function as freeing memory only when a count exceeds a defined limit, which contradicts the source code. The actual implementation always frees all related resources for the provided struct regardless of any limit condition. This misstatement misses the primary purpose and key details such as freeing group names, operations, global fields, parameters, and resetting related counters.",
                "The summary makes a specific claim about freeing memory only when counts exceed a defined limit, which is inaccurate because the source code unconditionally frees allocated resources without any threshold check. This is a FATAL error affecting the primary purpose description. There are no accurate claims present, resulting in high negative impact and no net benefit."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4524560,
    "strip_function_name": "sub_450A10",
    "strip_decompiled_code": "__int64 __fastcall sub_450A10(__int64 a1)\n{\n  __int64 v1; // rbp\n  __int64 v2; // r8\n  char v3; // al\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int v6; // eax\n  __int64 v7; // [rsp+8h] [rbp-30h]\n  __int64 v8[4]; // [rsp+18h] [rbp-20h] BYREF\n\n  v1 = *(_QWORD *)(a1 + 40);\n  v8[0] = 0LL;\n  v2 = *(_QWORD *)(v1 + 296);\n  if ( !v2 )\n    return 1LL;\n  if ( *(char ***)(v2 + 104) == &off_70B6D0 )\n    goto LABEL_12;\n  v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n  if ( !v3 )\n    goto LABEL_12;\n  if ( v3 != 64 )\n  {\nLABEL_5:\n    if ( v3 == (char)0x80 )\n    {\n      v7 = v2;\n      v6 = sub_4509B0(a1);\n      v2 = v7;\n      if ( !v6 )\n        goto LABEL_12;\n    }\n    result = sub_490F80(a1, *(_QWORD *)(a1 + 80), (int)\"__GNU_EH_FRAME_HDR\", 1, v2, 0, 0LL, 0, 0, (__int64)v8);\n    if ( !(_DWORD)result )\n      return result;\n    v5 = v8[0];\n    *(_BYTE *)(v8[0] + 99) |= 2u;\n    *(_BYTE *)(v5 + 97) = 2;\n    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8LL) + 864LL)\n                                                      + 432LL))(\n      a1,\n      v5,\n      1LL);\n    if ( !*(_DWORD *)(v1 + 308) )\n      *(_DWORD *)(v1 + 324) = 1;\n    return 1LL;\n  }\n  if ( (unsigned int)sub_450950(a1) )\n  {\n    v2 = *(_QWORD *)(v1 + 296);\n    v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n    goto LABEL_5;\n  }\n  v2 = *(_QWORD *)(v1 + 296);\nLABEL_12:\n  *(_DWORD *)(v2 + 32) |= 0x8000u;\n  result = 1LL;\n  *(_QWORD *)(v1 + 296) = 0LL;\n  return result;\n}\n",
    "function_name": "_bfd_elf_maybe_strip_eh_frame_hdr",
    "decompiled_code": "bfd_boolean __fastcall bfd_elf_maybe_strip_eh_frame_hdr(bfd_link_info *info)\n{\n  bfd_link_hash_table *hash; // rbp\n  __int64 newfunc; // r8\n  char v3; // al\n  bfd_boolean result; // eax\n  bfd_link_hash_entry *v5; // rsi\n  bfd_boolean v6; // eax\n  __int64 v7; // [rsp+8h] [rbp-30h]\n  bfd_link_hash_entry *bh_0; // [rsp+18h] [rbp-20h] BYREF\n\n  hash = info->hash;\n  bh_0 = 0LL;\n  newfunc = (__int64)hash[4].table.newfunc;\n  if ( !newfunc )\n    return 1;\n  if ( *(_QWORD *)(newfunc + 104) == 7386832LL )\n    goto LABEL_12;\n  v3 = *((_BYTE *)info + 3) & 0xC0;\n  if ( !v3 )\n    goto LABEL_12;\n  if ( v3 != 64 )\n  {\nLABEL_5:\n    if ( v3 == (char)0x80 )\n    {\n      v7 = newfunc;\n      v6 = bfd_elf_eh_frame_entry_present(info);\n      newfunc = v7;\n      if ( !v6 )\n        goto LABEL_12;\n    }\n    result = bfd_generic_link_add_one_symbol(\n               (__int64)info,\n               (__int64)info->output_bfd,\n               &byte_4C719F[15],\n               1u,\n               newfunc,\n               0LL,\n               0LL,\n               0,\n               0LL,\n               &bh_0);\n    if ( !result )\n      return result;\n    v5 = bh_0;\n    BYTE3(bh_0[1].u.c.p) |= 2u;\n    BYTE1(v5[1].u.c.p) = 2;\n    (*((void (__fastcall **)(bfd_link_info *, bfd_link_hash_entry *, __int64))info->output_bfd->xvec->backend_data + 54))(\n      info,\n      v5,\n      1LL);\n    if ( !HIDWORD(hash[4].table.memory) )\n      *((_DWORD *)&hash[4].table + 9) = 1;\n    return 1;\n  }\n  if ( bfd_elf_eh_frame_present(info) )\n  {\n    newfunc = (__int64)hash[4].table.newfunc;\n    v3 = *((_BYTE *)info + 3) & 0xC0;\n    goto LABEL_5;\n  }\n  newfunc = (__int64)hash[4].table.newfunc;\nLABEL_12:\n  *(_DWORD *)(newfunc + 32) |= 0x8000u;\n  result = 1;\n  hash[4].table.newfunc = 0LL;\n  return result;\n}\n",
    "source_code": "\nbfd_boolean\n_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *htab;\n  struct eh_frame_hdr_info *hdr_info;\n  struct bfd_link_hash_entry *bh = NULL;\n  struct elf_link_hash_entry *h;\n\n  htab = elf_hash_table (info);\n  hdr_info = &htab->eh_info;\n  if (hdr_info->hdr_sec == NULL)\n    return TRUE;\n\n  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section)\n      || info->eh_frame_hdr_type == 0\n      || (info->eh_frame_hdr_type == DWARF2_EH_HDR\n\t  && !_bfd_elf_eh_frame_present (info))\n      || (info->eh_frame_hdr_type == COMPACT_EH_HDR\n\t  && !_bfd_elf_eh_frame_entry_present (info)))\n    {\n      hdr_info->hdr_sec->flags |= SEC_EXCLUDE;\n      hdr_info->hdr_sec = NULL;\n      return TRUE;\n    }\n\n  /* Add a hidden symbol so that systems without access to PHDRs can\n     find the table.  */\n  if (! (_bfd_generic_link_add_one_symbol\n\t (info, info->output_bfd, \"__GNU_EH_FRAME_HDR\", BSF_LOCAL,\n\t  hdr_info->hdr_sec, 0, NULL, FALSE, FALSE, &bh)))\n    return FALSE;\n\n  h = (struct elf_link_hash_entry *) bh;\n  h->def_regular = 1;\n  h->other = STV_HIDDEN;\n  get_elf_backend_data\n    (info->output_bfd)->elf_backend_hide_symbol (info, h, TRUE);\n\n  if (!hdr_info->frame_hdr_is_compact)\n    hdr_info->u.dwarf.table = TRUE;\n  return TRUE;\n}",
    "comment": "Modifies the header section flags and adds a hidden symbol if specific conditions for EH frame header presence are not met.",
    "hext5_sum": "returns the number of operands rather than calculating it every time.",
    "bint5_sum": "Determines if a relocation should be forcibly applied based on its type and associated flags in the ELF binary .\n",
    "cpbcs_sum": "Issues a critical operation on an ISO image if conditions are met, handling specific conditions for the specified drive.\n",
    "misum_sum": "Marks the immediate as dirty, updates its attributes based on the section of the specified ELF backend data.\n",
    "decom_sum": "Handles loading and registering the `__GNU_EH_FRAME_HDR` section for an object based on status flags, or marks and clears its unwind information on failure.",
    "cfg_sum": "Processes target object headers based on control flags, performs integrity checks, updates related structures, triggers a handler, and marks initialization status.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of operands rather than calculating it every time.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claim about returning the number of operands rather than calculating it every time is entirely unrelated to the source code, which deals with managing the .eh_frame_hdr section in ELF linking. No part of the implementation involves operands, so all claims are inaccurate.",
                "The summary makes an unrelated and inaccurate claim about returning the number of operands, which is not reflected anywhere in the source code. The function in the source handles stripping the .eh_frame_hdr section under certain conditions and manages symbol creation, not operand counting. It fails to capture the primary purpose or any secondary details from the code.",
                "The summary's claim that the function returns the number of operands is completely unrelated to the source code, which handles stripping or adding ELF frame header information. This is pure NOISE, with no accurate claims about the implementation and zero alignment to key inputs, outputs, or side effects. The worst failure mode is overwhelming NOISE, leading to no useful gain for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Determines if a relocation should be forcibly applied based on its type and associated flags in the ELF binary .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim about deciding whether a relocation should be applied based on its type and flags does not match the source code, which instead manages the presence and potential removal of the .eh_frame_hdr section in an ELF binary and adds a hidden symbol if needed. The single claim is inaccurate and unrelated to the actual logic implemented.",
                "The summary claim about forcing relocation based on type and flags is unrelated to the actual code, which checks conditions to strip or retain the .eh_frame_hdr section, adds a hidden symbol, and adjusts section properties. It misses the primary purpose entirely and provides inaccurate semantics tied to relocation, which the source code does not handle.",
                "The summary makes a specific claim about determining relocation application based on type and flags, which is unrelated to the actual function in the source code. The source code checks conditions for stripping or creating an ELF .eh_frame_hdr section and manipulating symbols, not relocation handling. This is a FATAL error targeting the primary purpose incorrectly, leading to high negative impact and no useful accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Issues a critical operation on an ISO image if conditions are met, handling specific conditions for the specified drive.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function operates on an ISO image for a specified drive, which is entirely unrelated to the source code. The source code manipulates ELF linking structures, conditionally excludes sections, and adds a hidden symbol, with no reference to ISO images or drives. All extracted claims are inaccurate, leading to a complete mismatch.",
                "The summary incorrectly describes the function as performing a critical operation on an ISO image and handling conditions for a specified drive, which is unrelated to the actual source code. The source code deals with potentially stripping the .eh_frame_hdr section from an ELF file based on specific checks, adding a hidden symbol for systems without PHDR access, and setting flags accordingly. The summary misses the primary purpose and all secondary details, making its claims inaccurate and irrelevant to the actual implementation.",
                "The summary's claim that the function issues a critical operation on an ISO image for a specified drive is completely unrelated to the source code, which is about conditionally stripping or adding symbols to an ELF .eh_frame_hdr section during linking. This is pure NOISE with no accurate claims, leading to zero alignment and no useful information gained."
            ]
        },
        "misum": {
            "summary": "Marks the immediate as dirty, updates its attributes based on the section of the specified ELF backend data.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claim that the function 'marks the immediate as dirty' and 'updates its attributes based on the section of the specified ELF backend data' does not match the source code. The code manipulates an eh_frame header section, strips it under certain conditions, adds a hidden symbol, sets symbol visibility, and possibly marks a table flag, but never marks an 'immediate' as dirty. This is a semantic mismatch and most of the claims are inaccurate, resulting in very low alignment.",
                "The summary does not capture the primary purpose of the function, which is to potentially strip the .eh_frame_hdr section based on specific conditions, add a hidden symbol for systems without PHDRs, and update related ELF header attributes. Instead, it incorrectly describes unrelated behavior ('marks the immediate as dirty'), which is not present in the source code. This results in no accurate claims and complete misalignment with the actual implementation.",
                "The summary is highly inaccurate (NOISE) because it does not reflect the actual logic of the function, which manipulates the eh_frame_hdr section based on various conditions, adds a hidden symbol, and updates flags and symbol attributes. There is no concept of 'marking the immediate as dirty' in the source, and the described 'updates its attributes based on the section of the specified ELF backend data' is vague, mismatched with the detailed condition checks and symbol handling in the code. The worst failure mode is overwhelming NOISE with no factual match to the source implementation, resulting in low net benefit."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 39007,
    "strip_function_name": "sub_985F",
    "strip_decompiled_code": "__int64 __fastcall sub_985F(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+18h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+30h] [rbp-40h]\n  int v9[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v10[4]; // [rsp+50h] [rbp-20h] BYREF\n  int v11; // [rsp+54h] [rbp-1Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-18h]\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  sub_4EC0((__int64)v10, *(_QWORD *)(a1 + 8), abs32(*(_DWORD *)(a1 + 4)));\n  if ( ((v11 != 0) & (unsigned int)*v12) == 0 )\n    __assert_fail(\"mpz_odd_p (n)\", \"mini-gmp/mini-gmp.c\", 0xD88u, \"gmp_stronglucas\");\n  if ( sub_8DB1((int *)a2, (__int64)v10, 2uLL) )\n    return 0LL;\n  if ( *(_DWORD *)(a2 + 4) == 1 )\n    v3 = **(_QWORD **)(a2 + 8) - 1LL;\n  else\n    v3 = -1LL;\n  v7 = v3;\n  v6 = 3LL;\n  do\n  {\n    if ( v6 >= v7 )\n    {\n      if ( v6 == -1LL )\n        return 1LL;\n      else\n        return 2LL;\n    }\n    v6 += 2LL;\n    v8 = sub_74BB((__int64)v10, v6);\n    if ( !v8 )\n      return 0LL;\n  }\n  while ( (unsigned int)sub_92C2(v8, v6) == 1 );\n  sub_4834((__int64)v9);\n  v5 = sub_B280(v10, 0LL);\n  if ( (v6 & 2) != 0 )\n    v4 = (v6 >> 2) + 1;\n  else\n    v4 = -(__int64)(v6 >> 2);\n  if ( !sub_955F(v9, (int *)a2, v4, v5, (__int64)v10) )\n  {\n    while ( v9[1] )\n    {\n      if ( !--v5 )\n        break;\n      sub_94D4(v9, (int *)a2, (__int64)v10);\n    }\n  }\n  sub_48C3((__int64)v9);\n  return v5 != 0;\n}\n",
    "function_name": "gmp_stronglucas",
    "decompiled_code": "__int64 __fastcall gmp_stronglucas(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+18h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+30h] [rbp-40h]\n  int v9[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v10[4]; // [rsp+50h] [rbp-20h] BYREF\n  int v11; // [rsp+54h] [rbp-1Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-18h]\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  mpz_roinit_normal_n((__int64)v10, *(_QWORD *)(a1 + 8), abs32(*(_DWORD *)(a1 + 4)));\n  if ( ((v11 != 0) & (unsigned int)*v12) == 0 )\n    __assert_fail(\"mpz_odd_p (n)\", \"mini-gmp/mini-gmp.c\", 0xD88u, \"gmp_stronglucas\");\n  if ( mpz_root((int *)a2, (__int64)v10, 2uLL) )\n    return 0LL;\n  if ( *(_DWORD *)(a2 + 4) == 1 )\n    v3 = **(_QWORD **)(a2 + 8) - 1LL;\n  else\n    v3 = -1LL;\n  v7 = v3;\n  v6 = 3LL;\n  do\n  {\n    if ( v6 >= v7 )\n    {\n      if ( v6 == -1LL )\n        return 1LL;\n      else\n        return 2LL;\n    }\n    v6 += 2LL;\n    v8 = mpz_tdiv_ui((__int64)v10, v6);\n    if ( !v8 )\n      return 0LL;\n  }\n  while ( (unsigned int)gmp_jacobi_coprime(v8, v6) == 1 );\n  mpz_init((__int64)v9);\n  v5 = mpz_scan0(v10, 0LL);\n  if ( (v6 & 2) != 0 )\n    v4 = (v6 >> 2) + 1;\n  else\n    v4 = -(__int64)(v6 >> 2);\n  if ( !gmp_lucas_mod(v9, (int *)a2, v4, v5, (__int64)v10) )\n  {\n    while ( v9[1] )\n    {\n      if ( !--v5 )\n        break;\n      gmp_lucas_step_k_2k(v9, (int *)a2, (__int64)v10);\n    }\n  }\n  mpz_clear((__int64)v9);\n  return v5 != 0;\n}\n",
    "source_code": "static int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D; /* The absolute value is stored. */\n  long Q;\n  mp_limb_t tl;\n\n  /* Test on the absolute value. */\n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */\n  if (mpz_root (Qk, n, 2))\n    return 0; /* A square is composite. */\n\n  /* Check Ds up to square root (in case, n is prime)\n     or avoid overflows */\n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */\n  /* For those Ds we have (D/n) = (n/|D|) */\n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */\n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */\n  b0 = mpz_scan0 (n, 0);\n\n  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */\n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t/* If Ud != 0 */\n    while (V->_mp_size != 0 && --b0 != 0)\t/* while Vk != 0 */\n      /* V <- V ^ 2 - 2Q^k */\n      /* Q^{2k} = (Q^k)^2 */\n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}",
    "comment": "Determines if an odd integer is prime using the Lucas-Lehmer test and computes the Lucas sequence value based on specific parameters.",
    "hext5_sum": "parameters. assumes x > 0.",
    "bint5_sum": "Calculates the Hamming distance between two multi-precision integers by counting differing bits in their binary representations .\n",
    "cpbcs_sum": "Calculates the Lucas sequence modulo n using parameters U, V, and Q, returning a logical value indicating whether the result is zero.\n",
    "misum_sum": "Calculates the absolute difference between two arbitrary precision integers, returning special cases for zero and negative values.\n",
    "decom_sum": "Performs a strong Lucas probable prime test on the given odd integer using helper functions and returns the primality result.",
    "cfg_sum": "Performs a strong Lucas primality test on a given number, validating oddness, checking conditions, and returning results based on test outcomes.",
    "work_score": {
        "hext5": {
            "summary": "parameters. assumes x > 0.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The only claim in the summary is that the function assumes x > 0. The source code does not explicitly enforce x > 0, instead it operates on the absolute value of x and asserts that it is odd. This makes the claim inaccurate, resulting in no accurate claims in the summary.",
                "The summary only states that the function has parameters and assumes x > 0, which does not match or cover the primary purpose of the source code\u2014implementing a strong Lucas primality test on the absolute value of x with specific conditions, iterations, and return values. It misses both the main functionality and all secondary details such as handling squares, choosing D, Jacobi checks, and Lucas sequence steps. The claim about x > 0 is inaccurate since the code explicitly works on the absolute value, allowing negative inputs.",
                "The summary contains only a vague statement about parameters, suggesting x > 0, which is not explicitly stated in the source code. The code operates on the absolute value of x and asserts that it is odd; positivity is not required. This makes the single claim inaccurate (FATAL) because it misstates a key input assumption. There are no accurate or detailed claims to provide positive gain."
            ]
        },
        "bint5": {
            "summary": "Calculates the Hamming distance between two multi-precision integers by counting differing bits in their binary representations .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The single claim in the summary describes calculating the Hamming distance between two multi-precision integers, which is unrelated to the source code. The source actually performs a strong Lucas probable prime test, checking properties of an integer \u2018n\u2019 and computing sequence values. The claim directly targets code semantics but is entirely incorrect, resulting in no accurate claims.",
                "The summary incorrectly describes the function as calculating the Hamming distance between two multi-precision integers, which does not match the source code. The source code implements a strong Lucas probable prime test on a single integer, involving checks for squareness, Jacobi symbol calculations, and Lucas sequence steps. The primary purpose and all secondary details are missed, making the response entirely inaccurate.",
                "The summary makes a single specific claim about calculating the Hamming distance between two multi-precision integers, which is completely unrelated to the source code. The source implements a strong Lucas probable prime test, not bitwise comparison for Hamming distance. This is a FATAL error targeting the primary purpose incorrectly, making the description highly misleading."
            ]
        },
        "cpbcs": {
            "summary": "Calculates the Lucas sequence modulo n using parameters U, V, and Q, returning a logical value indicating whether the result is zero.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function calculates the Lucas sequence using U, V, and Q and returns a logical value indicating whether the result is zero. The source code shows it performs a strong Lucas primality test with V and Q as parameters, but no variable U is used, and the return value is based on b0, not directly on whether the result is zero. This means the majority of claims are inaccurate, with very limited alignment to the actual implementation.",
                "The summary incorrectly describes the primary purpose and behavior of the function. The source code defines `gmp_stronglucas` which tests the primality of `n` using a strong Lucas probable prime test, including pre-checks for being a square, specific selection of D values, and iterative Lucas sequence steps. It does not generically calculate the Lucas sequence using parameters U, V, and Q, nor simply return whether the result is zero; the return value represents a composite/prime determination. The core purpose and key logic, such as D selection and early return conditions, are omitted, indicating both inaccuracy and missed coverage.",
                "The summary inaccurately states that the function calculates the Lucas sequence modulo n using parameters U, V, and Q, and returns whether the result is zero. This is a FATAL error because it misrepresents the primary purpose and output: the actual function gmp_stronglucas selects a parameter D based on Jacobi symbol tests, computes Q from D, runs a Lucas sequence-based primality test, and returns a non-zero/zero integer depending on primality conditions rather than a simple zero check. There are no accurate claims, and the mismatch concerns the key semantics of the function."
            ]
        },
        "misum": {
            "summary": "Calculates the absolute difference between two arbitrary precision integers, returning special cases for zero and negative values.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates the absolute difference between two arbitrary precision integers with special handling for zero and negative values, which does not match the source code. The actual function implements a strong Lucas primality test, working with factors, Jacobi symbols, and modular sequences, with no logic for computing absolute differences. All claims are inaccurate relative to the code.",
                "The summary is entirely inaccurate as it describes calculating the absolute difference between two integers with special handling for zero and negative values, which bears no relation to the source code. The source implements a strong Lucas probable prime test for a given number, involving Jacobi symbol checks, quadratic form calculations, and Lucas sequence steps. The primary purpose and all critical secondary details in the code are missed.",
                "The summary is entirely inaccurate: it claims the function calculates the absolute difference between two arbitrary precision integers with special handling for zero and negative values, which contradicts the source code. The code actually implements a strong Lucas probable prime test, involving Jacobi symbol checks, Lucas sequence steps, and composite checks, not any arithmetic difference calculation. This is a FATAL error targeting the primary purpose and semantics of the function, leading to high negative impact and making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 660608,
    "strip_function_name": "ec_GFp_simple_group_get_curve",
    "strip_decompiled_code": "__int64 __fastcall ec_GFp_simple_group_get_curve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5)\n{\n  _DWORD *v9; // r8\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  int v12; // eax\n  _BYTE *v13; // rax\n  _DWORD *ptr; // [rsp+8h] [rbp-40h]\n  _DWORD *ptra; // [rsp+8h] [rbp-40h]\n\n  if ( a2 && !BN_copy(a2, a1 + 104) )\n    return 0LL;\n  if ( !a3 && !a4 )\n    return 1LL;\n  if ( *(_QWORD *)(*(_QWORD *)a1 + 288LL) )\n  {\n    v9 = 0LL;\n    if ( a5 )\n    {\nLABEL_8:\n      if ( !a3\n        || (ptr = v9,\n            LODWORD(v10) = 0,\n            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                    a1,\n                    a3,\n                    a1 + 152,\n                    a5),\n            v9 = ptr,\n            v11) )\n      {\n        LODWORD(v10) = 1;\n        if ( a4 )\n        {\n          ptra = v9;\n          v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                  a1,\n                  a4,\n                  a1 + 176,\n                  a5);\n          v9 = ptra;\n          v10 = v12 != 0;\n        }\n      }\n      if ( v9 )\n        BN_CTX_free(v9);\n      return v10;\n    }\n    v13 = BN_CTX_new();\n    a5 = v13;\n    if ( v13 )\n    {\n      v9 = v13;\n      goto LABEL_8;\n    }\n    return 0LL;\n  }\n  if ( a3 && !BN_copy(a3, a1 + 152) )\n    return 0LL;\n  if ( !a4 )\n    return 1LL;\n  return BN_copy(a4, a1 + 176) != 0;\n}\n",
    "function_name": "ec_GFp_simple_group_get_curve",
    "decompiled_code": "_BOOL8 __fastcall ec_GFp_simple_group_get_curve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5)\n{\n  _DWORD *v9; // r8\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  int v12; // eax\n  _BYTE *v13; // rax\n  _DWORD *ptr; // [rsp+8h] [rbp-40h]\n  _DWORD *ptra; // [rsp+8h] [rbp-40h]\n\n  if ( a2 && !BN_copy(a2, a1 + 104) )\n    return 0LL;\n  if ( !a3 && !a4 )\n    return 1LL;\n  if ( *(_QWORD *)(*(_QWORD *)a1 + 288LL) )\n  {\n    v9 = 0LL;\n    if ( a5 )\n    {\nLABEL_8:\n      if ( !a3\n        || (ptr = v9,\n            LODWORD(v10) = 0,\n            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                    a1,\n                    a3,\n                    a1 + 152,\n                    a5),\n            v9 = ptr,\n            v11) )\n      {\n        LODWORD(v10) = 1;\n        if ( a4 )\n        {\n          ptra = v9;\n          v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                  a1,\n                  a4,\n                  a1 + 176,\n                  a5);\n          v9 = ptra;\n          v10 = v12 != 0;\n        }\n      }\n      if ( v9 )\n        BN_CTX_free(v9);\n      return v10;\n    }\n    v13 = BN_CTX_new();\n    a5 = v13;\n    if ( v13 )\n    {\n      v9 = v13;\n      goto LABEL_8;\n    }\n    return 0LL;\n  }\n  if ( a3 && !BN_copy(a3, a1 + 152) )\n    return 0LL;\n  if ( !a4 )\n    return 1LL;\n  return BN_copy(a4, a1 + 176) != 0;\n}\n",
    "source_code": "\n\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret = 0;\n\tBN_CTX *new_ctx = NULL;\n\t\n\tif (p != NULL)\n\t\t{\n\t\tif (!BN_copy(p, &group->field)) return 0;\n\t\t}\n\n\tif (a != NULL || b != NULL)\n\t\t{\n\t\tif (group->meth->field_decode)\n\t\t\t{\n\t\t\tif (ctx == NULL)\n\t\t\t\t{\n\t\t\t\tctx = new_ctx = BN_CTX_new();\n\t\t\t\tif (ctx == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(a, &group->a)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(b, &group->b)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tret = 1;\n\t\n err:\n\tif (new_ctx)\n\t\tBN_CTX_free(new_ctx);\n\treturn ret;\n\t}",
    "comment": "Retrieves the elliptic curve parameters (field, a, and b) from the specified EC_GROUP structure into provided BIGNUM variables.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Extracts the elliptic curve parameters from a given group , including the field , a , and b , into the provided EC_GROUP structure .\n",
    "cpbcs_sum": "Extracts the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and manages a temporary BN_CTX context.\n",
    "misum_sum": "Retrieves the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and returns the result in the output structure.\n",
    "decom_sum": "Retrieves the elliptic curve group\u2019s prime field parameters a, b, and p into provided BIGNUMs, using BN_copy or field-specific conversion with optional BN_CTX.",
    "cfg_sum": "Retrieves elliptic curve parameters from the group, copying big numbers into outputs using BN_copy and optional BN_CTX allocation with proper cleanup.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior related to multibyte character string handling and rejection of unprintable characters, which is entirely unrelated to the source code's functionality of retrieving curve parameters from an EC_GROUP structure. None of the claims align factually with the source implementation, resulting in no accurate claims.",
                "The summary describes functionality related to measuring the column width of a multibyte character string and handling non-printable characters, which is unrelated to the source code. The source function retrieves the curve parameters (p, a, b) from an EC_GROUP structure, managing BN_CTX allocation and decoding fields. The summary misses the primary purpose entirely and contains irrelevant details, so there is no accurate claim coverage.",
                "The summary's claims about counting columns for multibyte strings and rejecting unprintable characters are entirely unrelated to the source code, which retrieves elliptic curve parameters (p, a, b) from an EC_GROUP structure. All claims are NOISE, with no accurate match to the code's primary purpose or I/O, resulting in overwhelming irrelevance and zero useful insight."
            ]
        },
        "bint5": {
            "summary": "Extracts the elliptic curve parameters from a given group , including the field , a , and b , into the provided EC_GROUP structure .\n",
            "score": [
                0.1,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims that the function extracts elliptic curve parameters (field, a, and b) into the provided EC_GROUP structure, but in reality the source code takes values from the EC_GROUP and copies/decodes them into provided BIGNUM arguments. This is a semantic reversal of the data flow and misrepresents the function\u2019s purpose, making the claim inaccurate.",
                "The summary correctly identifies that the function extracts elliptic curve parameters p, a, and b from the given EC_GROUP, capturing the primary purpose. However, it inaccurately states that the parameters are extracted into the provided EC_GROUP structure, whereas in reality they are copied into provided BIGNUM arguments, missing important details about conditional decoding, BN_CTX creation, error handling, and resource cleanup. This leads to partial coverage of secondary details.",
                "The summary contains a key inaccuracy: it states that the function extracts parameters into the provided EC_GROUP structure, whereas the source shows the function extracts parameters from the EC_GROUP into provided BIGNUM pointers. This contradicts the primary purpose and I/O direction, making it a FATAL error. No accurate claims provide meaningful gain."
            ]
        },
        "cpbcs": {
            "summary": "Extracts the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and manages a temporary BN_CTX context.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function extracts projective coordinates (x, y, z) of an elliptic curve point, which is inaccurate since the source code retrieves and possibly decodes the curve parameters p, a, and b, not point coordinates. While the mention of managing a temporary BN_CTX context is accurate, the majority of the key claims about the function's purpose and data handled are incorrect, resulting in less than half of the claims aligning with the source.",
                "The summary incorrectly describes the function as extracting projective coordinates (x, y, z) of an elliptic curve point, which contradicts the source. The source code retrieves curve parameters p, a, and b from an EC_GROUP, decodes them if needed, and manages a temporary BN_CTX context. While the BN_CTX management part is accurate, the primary purpose and key operations are misrepresented, missing critical details about handling the inputs and the distinction between copying and decoding parameters.",
                "The summary makes a FATAL error by claiming the function extracts projective coordinates (x, y, z) of an elliptic curve point, while the source code actually retrieves curve parameters (p, a, b) from an EC_GROUP. This contradicts the primary purpose and key I/O of the function. While it correctly notes management of a temporary BN_CTX context, the main functional description is incorrect, causing high negative impact."
            ]
        },
        "misum": {
            "summary": "Retrieves the projective coordinates (x, y, z) of an elliptic curve point, decoding them if necessary, and returns the result in the output structure.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves projective coordinates (x, y, z) of an elliptic curve point, which is inaccurate. The source code instead copies or decodes curve parameters p, a, and b from an EC_GROUP object, not point coordinates. This mismatch means the factual content of the summary contradicts the actual code semantics, resulting in no accurate claims.",
                "The summary incorrectly describes retrieving projective coordinates (x, y, z) of a curve point, which is not present in the source code. The actual function retrieves the curve parameters p, a, and b from an EC_GROUP and optionally decodes them, with handling for BN_CTX allocation and cleanup. The PRIMARY PURPOSE and key secondary details from the source are entirely missed, making the claims inaccurate and unrelated to the actual implementation.",
                "The summary claims the function retrieves projective coordinates (x, y, z) of an elliptic curve point, which is inaccurate because the source code retrieves the curve parameters p, a, and b from an EC_GROUP structure, not point coordinates. This is a FATAL error affecting the primary purpose and key I/O description, leaving no accurate claims to provide positive gain."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5338357,
    "strip_function_name": "sub_5174F5",
    "strip_decompiled_code": "__int64 __fastcall sub_5174F5(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  __int64 v17; // rdi\n  __int64 v18; // rax\n  _DWORD v20[2]; // [rsp+8h] [rbp-D0h] BYREF\n  char *v21; // [rsp+10h] [rbp-C8h]\n  char *v22; // [rsp+18h] [rbp-C0h]\n  char v23; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v24; // [rsp+28h] [rbp-B0h]\n  __int64 v25; // [rsp+30h] [rbp-A8h]\n  __int64 v26; // [rsp+38h] [rbp-A0h]\n  __int64 v27; // [rsp+40h] [rbp-98h]\n  __int64 v28; // [rsp+48h] [rbp-90h]\n  __m128 v29; // [rsp+50h] [rbp-88h]\n  __m128 v30; // [rsp+60h] [rbp-78h]\n  __m128 v31; // [rsp+70h] [rbp-68h]\n  __m128 v32; // [rsp+80h] [rbp-58h]\n  __m128 v33; // [rsp+90h] [rbp-48h]\n  __m128 v34; // [rsp+A0h] [rbp-38h]\n  __m128 v35; // [rsp+B0h] [rbp-28h]\n  __m128 v36; // [rsp+C0h] [rbp-18h]\n\n  v24 = a2;\n  v25 = a3;\n  v26 = a4;\n  v27 = a5;\n  v28 = a6;\n  if ( v15 )\n  {\n    v29 = a7;\n    v30 = a8;\n    v31 = a9;\n    v32 = a10;\n    v33 = a11;\n    v34 = a12;\n    v35 = a13;\n    v36 = a14;\n  }\n  v20[0] = 8;\n  v20[1] = 48;\n  v21 = &a15;\n  v22 = &v23;\n  v17 = *(unsigned int *)qword_89A630;\n  v18 = 0LL;\n  if ( (_DWORD)v17 )\n    v18 = sub_455D70(\n            v17,\n            *(double *)a7.m128_u64,\n            *(double *)a8.m128_u64,\n            *(double *)a9.m128_u64,\n            *(double *)a10.m128_u64,\n            *(double *)a11.m128_u64,\n            *(double *)a12.m128_u64,\n            *(double *)a13.m128_u64,\n            *(double *)a14.m128_u64);\n  return sub_5176F5(a1, v20, v18);\n}\n",
    "function_name": "bb_perror_msg",
    "decompiled_code": "unsigned __int64 __fastcall bb_perror_msg(\n        const char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  const __m128i *v16; // rax\n  _QWORD v18[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v19; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v20; // [rsp+28h] [rbp-B0h]\n  __int64 v21; // [rsp+30h] [rbp-A8h]\n  __int64 v22; // [rsp+38h] [rbp-A0h]\n  __int64 v23; // [rsp+40h] [rbp-98h]\n  __int64 v24; // [rsp+48h] [rbp-90h]\n  __m128 v25; // [rsp+50h] [rbp-88h]\n  __m128 v26; // [rsp+60h] [rbp-78h]\n  __m128 v27; // [rsp+70h] [rbp-68h]\n  __m128 v28; // [rsp+80h] [rbp-58h]\n  __m128 v29; // [rsp+90h] [rbp-48h]\n  __m128 v30; // [rsp+A0h] [rbp-38h]\n  __m128 v31; // [rsp+B0h] [rbp-28h]\n  __m128 v32; // [rsp+C0h] [rbp-18h]\n\n  v20 = a2;\n  v21 = a3;\n  v22 = a4;\n  v23 = a5;\n  v24 = a6;\n  if ( v15 )\n  {\n    v25 = a7;\n    v26 = a8;\n    v27 = a9;\n    v28 = a10;\n    v29 = a11;\n    v30 = a12;\n    v31 = a13;\n    v32 = a14;\n  }\n  v18[0] = 0x3000000008LL;\n  v18[1] = &a15;\n  v18[2] = &v19;\n  v16 = 0LL;\n  if ( *(_DWORD *)bb_errno )\n    v16 = (const __m128i *)strerror(\n                             *(_DWORD *)bb_errno,\n                             *(double *)a7.m128_u64,\n                             *(double *)a8.m128_u64,\n                             *(double *)a9.m128_u64,\n                             *(double *)a10.m128_u64,\n                             *(double *)a11.m128_u64,\n                             *(double *)a12.m128_u64,\n                             *(double *)a13.m128_u64,\n                             *(double *)a14.m128_u64);\n  return bb_verror_msg(\n           a1,\n           v18,\n           v16,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           *(double *)a11.m128_u64,\n           *(double *)a12.m128_u64,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "source_code": "\nvoid FAST_FUNC bb_perror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\t/* Guard against \"<error message>: Success\" */\n\tbb_verror_msg(s, p, errno ? strerror(errno) : NULL);\n\tva_end(p);\n}",
    "comment": "Logs an error message along with the string representation of the current errno value, using a variable argument list for additional context.",
    "hext5_sum": "push a pointer to the recorded location. this function gives unspecified results in multibyte locales.",
    "bint5_sum": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
    "cpbcs_sum": "Logs a message at a specified error level using a variable argument list to the `crondlog` function.\n",
    "misum_sum": "Logs a formatted message at level 4 using a variable argument list to pass the `crondlog` function.\n",
    "decom_sum": "Processes eight double-precision values into a computed result and forwards it with configuration parameters to another routine for further handling.",
    "cfg_sum": "Prepares vector and scalar parameters, optionally initializes state, computes a transformation, and forwards results to another routine for final processing.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer to the recorded location. this function gives unspecified results in multibyte locales.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's claims about pushing a pointer to a recorded location and unspecified results in multibyte locales are not supported by the provided source code, which simply formats and prints an error message using variable arguments and strerror. None of the claims accurately reflect the function\u2019s semantics, resulting in no accurate claims.",
                "The summary does not describe the primary purpose or observable behavior of the function, which formats and prints an error message using variable arguments and errno. Instead, it makes unrelated statements about pointer pushing and multibyte locale behavior that are not supported by the source code. No accurate claims are present, resulting in no coverage of critical semantic units.",
                "The summary's claims about pushing a pointer to a recorded location and unspecified results in multibyte locales do not match the source code, which defines a function for printing error messages via bb_verror_msg with errno handling. Both claims are NOISE, as they neither accurately reflect the function's purpose nor its I/O behavior, resulting in overwhelming irrelevant information with no useful insight."
            ]
        },
        "bint5": {
            "summary": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function formats and sends an error message using a variable argument list to `bb_verror_msg`, which matches the code's behavior of using `va_list` and calling `bb_verror_msg`. It omits some specifics (like the conditional `errno` check), but does not introduce inaccuracies, so the proportion of accurate claims is very high.",
                "The summary correctly captures the primary purpose of formatting and sending an error message via bb_verror_msg with variable arguments, matching the source implementation. However, it omits key secondary details such as guarding against displaying 'Success' when errno is zero, the use of strerror(errno) for obtaining the error string, and the va_list handling steps. This incompleteness limits full coverage of the function's behavior.",
                "The summary correctly states that the function formats and sends an error message to `bb_verror_msg` using a variable argument list, which matches the source code behavior. However, it omits the specific conditional logic involving `errno` and `strerror(errno)`, providing only a broad, low-information SAFE claim. No inaccuracies or contradictions are present, but the gain is low due to lack of detail."
            ]
        },
        "cpbcs": {
            "summary": "Logs a message at a specified error level using a variable argument list to the `crondlog` function.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function logs a message at a specified error level to the `crondlog` function, but the source code shows it calls `bb_verror_msg` with a variable argument list and an error string, and contains no reference to `crondlog` or an error level parameter. The mismatch indicates the claims are targeted at code semantics but are incorrect, resulting in no accurate claims.",
                "The summary incorrectly describes the function as logging at a specified error level to `crondlog`, which is not present in the source code. The actual implementation calls `bb_verror_msg` with a `va_list`, guarding against displaying 'Success' as an error. This inaccuracy means the PRIMARY PURPOSE is missed and no correct secondary details are covered.",
                "The summary makes a highly specific but incorrect claim about logging to the `crondlog` function at a specified error level, which contradicts the source code where `bb_perror_msg` calls `bb_verror_msg` and not `crondlog`. This is a FATAL error affecting the primary purpose and key side effect of the function. There are no accurate claims to offset this, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Logs a formatted message at level 4 using a variable argument list to pass the `crondlog` function.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly claims that the function logs at level 4 using `crondlog`, which is not reflected in the source code. The source code shows `bb_perror_msg` calling `bb_verror_msg` with a variable argument list and handling error messages via `errno` and `strerror`, with no mention of logging levels or `crondlog`. This makes the only claim in the summary inaccurate.",
                "The summary is inaccurate because it claims the function logs at level 4 using `crondlog`, which does not appear anywhere in the source code. The actual function uses `vb_verror_msg` with a variable argument list and conditionally includes an error string based on `errno`. The primary purpose of handling error messaging is missed entirely, and no secondary details from the source code are captured.",
                "The summary contains a FATAL inaccuracy: it claims the function logs at level 4 using `crondlog`, which is neither present nor implied in the source code. The actual implementation uses `bb_verror_msg` and formats an error message based on `errno`. There are no accurate claims matching the code, so the description misrepresents the primary purpose and core I/O behavior."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581460656,
    "strip_function_name": "sub_FFFFFFFF8127E8B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8127E8B0(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 result; // rax\n  __int64 **v15; // r12\n  __int64 v16; // rsi\n  __int64 *v17; // rbx\n  __int64 *v18; // rdx\n  __int64 v19; // rcx\n  int v20; // r8d\n  int v21; // r9d\n  unsigned int v22; // r13d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 *v25; // rdx\n  __int64 v26; // rcx\n  int v27; // r8d\n  int v28; // r9d\n  double v29; // xmm4_8\n  double v30; // xmm5_8\n\n  if ( !LODWORD(dword_FFFFFFFF81E9AB00[0]) )\n    return 0LL;\n  v15 = (__int64 **)(a1 + 24);\n  v16 = *(_QWORD *)(a2 + 24);\n  v17 = (__int64 *)(a1 + 48);\n  v22 = sub_FFFFFFFF812709E0(a1 + 24, v16, a3, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6);\n  if ( v22\n    || (v16 = a1 + 24, v22 = sub_FFFFFFFF812707B0(v17, v15, a7, a8, a9, a10, v23, v24, a13, a14), result = 0LL, v22) )\n  {\n    sub_FFFFFFFF81270E80((__int64)v15, v16, v18, v19, v20, v21, a7, a8, a9, a10, v23, v24, a13, a14);\n    sub_FFFFFFFF81270E80((__int64)v17, v16, v25, v26, v27, v28, a7, a8, a9, a10, v29, v30, a13, a14);\n    return v22;\n  }\n  return result;\n}\n",
    "function_name": "mls_import_netlbl_cat",
    "decompiled_code": "__int64 __fastcall mls_import_netlbl_cat(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  __int64 **v12; // r12\n  __int64 v13; // rsi\n  __int64 **v14; // rbx\n  __int64 *v15; // rdx\n  unsigned int v16; // r13d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n\n  if ( !LODWORD(policydb[0]) )\n    return 0LL;\n  v12 = (__int64 **)(a1 + 24);\n  v13 = *(_QWORD *)(a2 + 24);\n  v14 = (__int64 **)(a1 + 48);\n  v16 = ebitmap_netlbl_import(a1 + 24, v13, a3, a4, a5, a6, a7, a8, a9, a10, a11);\n  if ( v16 || (v13 = a1 + 24, v16 = ebitmap_cpy(v14, v12, a4, a5, a6, a7, v17, v18, a10, a11), result = 0LL, v16) )\n  {\n    ebitmap_destroy((__int64)v12, v13, v15, a4, a5, a6, a7, v17, v18, a10, a11);\n    ebitmap_destroy((__int64)v14, v13, v19, a4, a5, a6, a7, v20, v21, a10, a11);\n    return v16;\n  }\n  return result;\n}\n",
    "source_code": "int mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t &context->range.level[0].cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\tebitmap_destroy(&context->range.level[1].cat);\n\treturn rc;\n}",
    "comment": "Imports and copies the MLS category attributes into the context structure if MLS is enabled, handling errors by destroying allocated resources.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Inserts a conditional type rule into the SELinux access vector table while ensuring no conflicting rules exist in the table .\n",
    "cpbcs_sum": "Exports the MLS category table by converting its name to the security attribute representation and handling potential errors during the process.\n",
    "misum_sum": "Exports a context identified by its name into the provided security context, detaching security attributes, and security attributes, while handling errors appropriately.\n",
    "decom_sum": "Checks a global initialization flag, performs two geometric or collision tests, and updates two associated data structures before returning the test result.",
    "cfg_sum": "Determines processing status by checking a global flag, performing two geometric or state computations, updating structures, and returning the computed status code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary 'push a pointer type.' does not accurately reflect any part of the source code's semantics. The function deals with importing MLS categories into a context structure, conditional returns, copying bitmaps, and handling failures, with no operations involving pushing a pointer type. This makes the single claim entirely inaccurate per the evaluation steps.",
                "The summary 'push a pointer type' is vague, does not reference the function's primary purpose of importing and copying MLS category bitmaps into a context based on security attributes, and misses all secondary details such as MLS enable check, error handling, and resource cleanup. It does not target the source code semantics at all, making it entirely inaccurate.",
                "The summary 'push a pointer type.' does not describe any aspect of the source code\u2019s logic, parameters, or behavior. It fails to mention the MLS-enabled check, the import and copy of category bitmaps, or the error handling. This is pure NOISE with no accurate claims, thus providing no relevant insight and offering zero benefit."
            ]
        },
        "bint5": {
            "summary": "Inserts a conditional type rule into the SELinux access vector table while ensuring no conflicting rules exist in the table .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes a specific claim about inserting a conditional type rule into the SELinux access vector table, which is not reflected in the source code. The source function deals with importing and copying MLS category bits into a context range using ebitmap functions, not manipulating access vector tables or conditional type rules. All claims in the summary are inaccurate relative to the implementation.",
                "The summary describes inserting a conditional type rule into the SELinux access vector table and checking for conflicts, which is entirely unrelated to the actual code. The source function handles importing MLS category bitmaps from a netlabel security attribute when MLS is enabled, copies them to another level, and performs cleanup on failure. The primary purpose and all secondary details in the source are missed, and the claims are inaccurate with respect to the implementation.",
                "The summary's claim about inserting a conditional type rule into the SELinux access vector table is entirely unrelated to the actual code, which imports MLS categories from a netlabel security attribute and handles copying and cleanup. This is a NOISE failure targeting incorrect semantics, with no accurate claims to provide insight, resulting in zero net benefit."
            ]
        },
        "cpbcs": {
            "summary": "Exports the MLS category table by converting its name to the security attribute representation and handling potential errors during the process.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function exports an MLS category table by converting a name to a security attribute representation, which is inaccurate because the source code imports MLS category data from secattr into the context and does not perform any name conversion. While it mentions handling potential errors, which matches the code's error handling, most of the semantic description is incorrect, resulting in less than half of the claims being accurate.",
                "The summary incorrectly describes the function\u2019s primary purpose as exporting an MLS category table and converting its name to a security attribute representation, which contradicts the source code. The actual implementation imports MLS category data from secattr into the context when MLS is enabled, copies categories to a second level, and cleans up on failure. The summary misses core logic such as the import process, the MLS enabled check, copying categories, and destruction on error, and instead provides unrelated, inaccurate details.",
                "The summary claims that the function exports an MLS category table by converting its name to a security attribute representation, which is inaccurate because the source code imports MLS category information from the security attribute into the context rather than exporting it or converting a name. This is a FATAL error targeting the primary purpose of the function, as it misstates the direction of data flow and the core operation. While error handling is mentioned correctly, the main functional description is wrong, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Exports a context identified by its name into the provided security context, detaching security attributes, and security attributes, while handling errors appropriately.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as exporting a context by name and detaching security attributes, which does not match the source code. The actual code imports MLS categories from a provided security attribute struct into a context and duplicates them, with cleanup on failure. None of the claims match the actual code semantics, resulting in 0% accurate claims.",
                "The summary describes exporting a context by name and detaching security attributes, which does not match the source code\u2019s actual primary purpose of importing MLS category bitmaps from a security attribute into a context. It misses key implementation details such as checking if MLS is enabled, copying category bitmaps for both levels, and cleaning up on failure. The claims are inaccurate and do not cover the primary purpose or secondary behaviors.",
                "The summary's claims are inaccurate: it describes exporting a context by name and detaching security attributes, which contradicts the source code. The function actually imports MLS category bits from secattr into the context and copies them, with cleanup on failure. This is a FATAL error targeting the primary purpose and key I/O, as the described operation is completely different from the implemented functionality. No accurate claims remain to provide benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582734064,
    "strip_function_name": "sub_FFFFFFFF813B56F0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813B56F0(\n        _QWORD *a1,\n        unsigned int a2,\n        char a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  char v12; // r14\n  int v13; // r12d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 result; // rax\n  char *v17; // r9\n  char *v18; // r8\n\n  v12 = a3;\n  v13 = *(_DWORD *)(a1[a2 + 1065] + 2172LL);\n  if ( !a2 && (a1[947] & 1) != 0 )\n  {\n    if ( (unsigned __int8)sub_FFFFFFFF813D9840(*a1) >= (unsigned __int8)(v13 != 15) )\n    {\n      v12 = 1;\nLABEL_5:\n      result = sub_FFFFFFFF8138E6A0((__int64)a1, *(_DWORD *)a1[2] + (v13 << 12) + 458760);\n      if ( v12 == (int)result < 0 )\n        return result;\n      v18 = \"off\";\n      v17 = \"off\";\n      if ( (int)result < 0 )\n        v17 = \"on\";\n      if ( v12 )\n        v18 = \"on\";\n      return sub_FFFFFFFF8103BAE0(\n               (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n               1241,\n               (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n               a4,\n               a5,\n               a6,\n               a7,\n               v14,\n               v15,\n               a10,\n               a11,\n               a2 + 65,\n               v18,\n               v17);\n    }\n    goto LABEL_9;\n  }\n  result = sub_FFFFFFFF813D9840(*a1);\n  if ( (unsigned __int8)result >= (unsigned __int8)(v13 != 15) )\n    goto LABEL_5;\n  if ( a3 )\n  {\nLABEL_9:\n    v17 = \"off\";\n    v18 = \"on\";\n    return sub_FFFFFFFF8103BAE0(\n             (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n             1241,\n             (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n             a4,\n             a5,\n             a6,\n             a7,\n             v14,\n             v15,\n             a10,\n             a11,\n             a2 + 65,\n             v18,\n             v17);\n  }\n  return result;\n}\n",
    "function_name": "assert_pipe",
    "decompiled_code": "char __fastcall assert_pipe(\n        __int64 *a1,\n        unsigned int a2,\n        char a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  char v12; // r14\n  int v13; // r12d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  char *v17; // r9\n  char *v18; // r8\n\n  v12 = a3;\n  v13 = *(_DWORD *)(a1[a2 + 1065] + 2172);\n  if ( a2 || (a1[947] & 1) == 0 )\n  {\n    LOBYTE(v16) = intel_using_power_well(*a1);\n    if ( (unsigned __int8)v16 >= (unsigned __int8)(v13 != 15) )\n      goto LABEL_5;\n    if ( !a3 )\n      return v16;\nLABEL_9:\n    v17 = \"off\";\n    v18 = \"on\";\n    goto LABEL_14;\n  }\n  if ( (unsigned __int8)intel_using_power_well(*a1) < (unsigned __int8)(v13 != 15) )\n    goto LABEL_9;\n  v12 = 1;\nLABEL_5:\n  v16 = i915_read32((__int64)a1, *(_DWORD *)a1[2] + (v13 << 12) + 458760);\n  if ( v12 == v16 < 0 )\n    return v16;\n  v18 = \"off\";\n  v17 = \"off\";\n  if ( v16 < 0 )\n    v17 = \"on\";\n  if ( v12 )\n    v18 = \"on\";\nLABEL_14:\n  LOBYTE(v16) = warn_slowpath_fmt(\n                  \"drivers/gpu/drm/i915/intel_display.c\",\n                  0x4D9u,\n                  (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n                  a4,\n                  a5,\n                  a6,\n                  a7,\n                  v14,\n                  v15,\n                  a10,\n                  a11,\n                  a2 + 65,\n                  v18,\n                  v17);\n  return v16;\n}\n",
    "source_code": "\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum pipe pipe, bool state)\n{\n\tint reg;\n\tu32 val;\n\tbool cur_state;\n\tenum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,\n\t\t\t\t\t\t\t\t      pipe);\n\n\t/* if we need the pipe A quirk it must be always on */\n\tif (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)\n\t\tstate = true;\n\n\tif (!intel_using_power_well(dev_priv->dev) &&\n\t    cpu_transcoder != TRANSCODER_EDP) {\n\t\tcur_state = false;\n\t} else {\n\t\treg = PIPECONF(cpu_transcoder);\n\t\tval = I915_READ(reg);\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\t}\n\n\tWARN(cur_state != state,\n\t     \"pipe %c assertion failure (expected %s, current %s)\\n\",\n\t     pipe_name(pipe), state_string(state), state_string(cur_state));\n}",
    "comment": "Asserts the state of a specified display pipe in the Intel graphics driver, ensuring it matches the expected enablement state.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Enables or disables the PLL for a specified display plane and updates relevant PLL configurations based on the device generation and capabilities .\n",
    "cpbcs_sum": "Inserts a specified display port into the corresponding Northbridge pipe based on the provided value, ensuring valid port status and memory allocation.\n",
    "misum_sum": "Asserts the status of a specified register on an Intel i915 device, handling errors and conditions appropriately.\n",
    "decom_sum": "Checks an Intel GPU display pipe\u2019s state against the expected value and logs an assertion failure if the current state does not match.",
    "cfg_sum": "Validates GPU display pipe state against expected conditions and logs assertion failures with detailed status when mismatches are detected.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior related to string processing, control characters, static buffers, and Unicode display handling, which is entirely unrelated to the source code that performs pipe state assertion in a graphics driver. None of the claims match or are supported by the implementation, making them all inaccurate.",
                "The summary does not describe the primary purpose or any secondary details of the source code. The source function asserts whether a given display pipe's state matches an expected state, with specific handling for PIPE_A quirks and power well usage, and issues a warning if mismatched. The summary instead discusses replacing control characters, using static buffers, and Unicode handling, which are unrelated and do not match the implementation at all.",
                "The summary's claims describe string processing involving control character replacement, escape sequences, static buffers, and Unicode handling, none of which match the source code's logic for asserting pipe states in a graphics driver. All claims are NOISE, with no accurate alignment to the source implementation. The lack of relevant or correct information makes the description unreliable and of zero benefit."
            ]
        },
        "bint5": {
            "summary": "Enables or disables the PLL for a specified display plane and updates relevant PLL configurations based on the device generation and capabilities .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function enables or disables a PLL for a display plane and updates PLL configurations based on device generation, which does not align with the source code. The code actually asserts the expected and current state of a display pipe, with conditional handling for specific quirks and power well usage, and does not manipulate PLLs or update PLL configurations. All claims are inaccurate, resulting in no accurate matches.",
                "The summary incorrectly describes enabling or disabling the PLL and updating PLL configurations, which is not present in the source code. The actual function asserts whether a given display pipe's state matches the expected state, with special handling for PIPE_A quirks and conditions based on power wells and transcoders. The primary purpose is missed entirely, and no accurate claims are made regarding the observable behavior or conditions within the code.",
                "The summary claims the function enables or disables the PLL and updates PLL configurations, which is contradictory to the source. The code instead checks the current state of a display pipe, applies a quirk for PIPE_A, reads a register to determine its status, and issues a warning if it differs from the expected state. This is a FATAL inaccuracy affecting the primary purpose of the function, leading to high negative impact with no accurate claims present."
            ]
        },
        "cpbcs": {
            "summary": "Inserts a specified display port into the corresponding Northbridge pipe based on the provided value, ensuring valid port status and memory allocation.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function inserts a specified display port into a Northbridge pipe, ensures valid port status, and manages memory allocation. The source code actually asserts that a display pipe (not a port) is in a specific state, with checks for quirks, power wells, and register reads, and does not involve inserting ports, Northbridge functionality, or memory allocation. None of the claims in the summary match the implementation, resulting in all being inaccurate.",
                "The summary is entirely inaccurate because it describes inserting a display port and handling memory allocation, which are unrelated to the source code. The actual function checks the current state of a specific display pipe against an expected state, applies a quirk for PIPE_A, evaluates power conditions, reads register values to determine pipe enablement, and issues a warning if mismatched. The primary purpose is missed, and none of the actual key secondary details from the code are reflected.",
                "The summary claims the function inserts a specified display port into a Northbridge pipe and manages port status and memory allocation. These statements do not align with the source code, which actually checks and asserts the state of a given display pipe, with no insertion, Northbridge references, or memory allocation. This is a FATAL error targeting the primary purpose, as it misrepresents the core functionality, leading to high negative impact and making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Asserts the status of a specified register on an Intel i915 device, handling errors and conditions appropriately.\n",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary claims the function asserts the status of a specified register, which is broadly accurate since it reads PIPECONF and checks its enable state. However, it omits key implementation specifics such as the conditional handling for PIPE_A quirks, power well usage, and CPU transcoder checks, while 'handling errors' is misleading because the code only warns rather than implementing error handling. This results in a mix of accurate but overly general and partly inaccurate claims, with roughly half matching the source semantics.",
                "The summary misses the primary purpose, which is to assert the state of a specified display pipe rather than a generic register. It omits key secondary details such as handling the PIPE_A quirk, checking power well usage, special handling for TRANSCODER_EDP, and reading PIPECONF to determine current state. The claim is overly broad and does not specifically match the source code's observable contract or semantics.",
                "The summary claims the function asserts the status of a specified register, which is partially inaccurate because the source code checks the state of a display pipe via related registers and warns on mismatches, not generically any register. The mention of handling errors and conditions is overly broad and adds little insight, making it a SAFE but low-info statement. This is mostly NOISE due to lack of specificity and failure to highlight the key purpose and nuances such as PIPE_A quirk handling or the EDP transcoder condition."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583666752,
    "strip_function_name": "sub_FFFFFFFF81499240",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81499240(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rbx\n  unsigned int v10; // r14d\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned int v17; // r13d\n  unsigned int v18; // ebx\n  bool v19; // zf\n  __int64 v20; // rsi\n  int v22; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v23[100]; // [rsp+4h] [rbp-64h] BYREF\n\n  v9 = a1 + 488;\n  sub_FFFFFFFF8178F210(a1 + 488);\n  if ( !*(_BYTE *)(a1 + 344) )\n  {\n    v10 = -11;\n    sub_FFFFFFFF8178F1B0(v9);\n    return v10;\n  }\n  v10 = sub_FFFFFFFF8149AA70(a1);\n  if ( v10 )\n  {\n    sub_FFFFFFFF8178F1B0(v9);\n    return (unsigned int)-11;\n  }\n  sub_FFFFFFFF8178F1B0(v9);\n  if ( (unsigned int)sub_FFFFFFFF8149CC00(a1, &v22) || !v22 )\n    return 4294967277LL;\n  if ( (unsigned int)sub_FFFFFFFF8149D590(a1, 255LL, 6LL, v23) )\n  {\n    *(_WORD *)(a1 + 28) = 1;\n    sub_FFFFFFFF81498E40(a1, 0LL, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9);\n    return v10;\n  }\n  v17 = v23[0];\n  v18 = 0;\n  v19 = v23[0] == 0;\n  *(_WORD *)(a1 + 28) = v23[0];\n  if ( v19 )\n    return v10;\n  do\n  {\n    v20 = v18++;\n    sub_FFFFFFFF81498E40(a1, v20, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9);\n  }\n  while ( v17 > v18 );\n  return v10;\n}\n",
    "function_name": "pcmcia_card_add",
    "decompiled_code": "__int64 __fastcall pcmcia_card_add(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rbx\n  unsigned int v10; // r14d\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // r13d\n  unsigned int v22; // ebx\n  bool v23; // zf\n  int v24; // esi\n  unsigned int v26; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v27[100]; // [rsp+4h] [rbp-64h] BYREF\n\n  v9 = a1 + 488;\n  mutex_lock(a1 + 488);\n  if ( !*(_BYTE *)(a1 + 344) )\n  {\n    v10 = -11;\n    mutex_unlock(v9);\n    return v10;\n  }\n  v10 = pcmcia_validate_mem(a1);\n  if ( v10 )\n  {\n    mutex_unlock(v9);\n    return (unsigned int)-11;\n  }\n  mutex_unlock(v9);\n  if ( (unsigned int)pccard_validate_cis(a1, &v26, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9) || !v26 )\n    return 4294967277LL;\n  if ( (unsigned int)pccard_read_tuple(a1, 255LL, 6, (__int64)v27, a2, a3, a4, a5, v17, v18, a8, a9) )\n  {\n    *(_WORD *)(a1 + 28) = 1;\n    pcmcia_device_add(a1, 0, a2, a3, a4, a5, v19, v20, a8, a9);\n    return v10;\n  }\n  v21 = v27[0];\n  v22 = 0;\n  v23 = v27[0] == 0;\n  *(_WORD *)(a1 + 28) = v27[0];\n  if ( v23 )\n    return v10;\n  do\n  {\n    v24 = v22++;\n    pcmcia_device_add(a1, v24, a2, a3, a4, a5, v19, v20, a8, a9);\n  }\n  while ( v21 > v22 );\n  return 0LL;\n}\n",
    "source_code": "\n\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\n{\n\tcistpl_longlink_mfc_t mfc;\n\tunsigned int no_funcs, i, no_chains;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!(s->resource_setup_done)) {\n\t\tdev_dbg(&s->dev,\n\t\t\t   \"no resources available, delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\n\tif (pcmcia_validate_mem(s)) {\n\t\tdev_dbg(&s->dev, \"validating mem resources failed, \"\n\t\t       \"delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\tret = pccard_validate_cis(s, &no_chains);\n\tif (ret || !no_chains) {\n\t\tdev_dbg(&s->dev, \"invalid CIS or invalid resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\n\t\tno_funcs = mfc.nfn;\n\telse\n\t\tno_funcs = 1;\n\ts->functions = no_funcs;\n\n\tfor (i = 0; i < no_funcs; i++)\n\t\tpcmcia_device_add(s, i);\n\n\treturn ret;\n}",
    "comment": "Adds a PCMCIA card to the socket after validating resources and reading its function information from the card's CIS.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Enables a PCMCIA device by configuring its socket state , memory , I/O windows , and setting up necessary configuration registers .\n",
    "cpbcs_sum": "Sets the receive mode for a PCMCIA device by validating the provided value and ensuring no valid port is registered and previously registered.\n",
    "misum_sum": "Updates the PHY device configuration if it differs from the specified socket is present and the device is present in a network device.\n",
    "decom_sum": "Initializes device state, verifies readiness, retrieves a byte count, and processes each byte with provided floating-point parameters before returning status.",
    "cfg_sum": "Validates device readiness, retrieves configuration data, processes each data entry with provided parameters, updates status flags, and returns a completion or error code.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior related to Unicode character name lookup and buffer handling, which is completely unrelated to the source code's implementation of adding a PCMCIA card, validating resources, and reading function tuples. All claims in the summary are inaccurate as they do not match any aspect of the source code.",
                "The summary is entirely inaccurate, describing behavior about looking up a Unicode character name and returning a buffer, which has no relation to the actual function. The source code deals with adding a PCMCIA card, resource validation, and device initialization, none of which are mentioned in the summary. It fails to capture the primary purpose or any secondary details from the source code.",
                "The summary contains only NOISE: it describes a function that returns a buffer or null based on a Unicode character name lookup in uppercase ASCII, which is entirely unrelated to the source code. The source function handles adding a PCMCIA card with resource validation and CIS parsing, with no Unicode or buffer semantics. This is a complete mismatch, indicating the worst failure mode as NOISE that overwhelms the content, offering no accurate claims and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Enables a PCMCIA device by configuring its socket state , memory , I/O windows , and setting up necessary configuration registers .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims detailed configuration of socket state, memory, I/O windows, and registers, but the source code focuses on validation of memory resources, CIS, determining the number of functions, and adding devices. There is no evidence of explicit I/O window setup or register configuration in the implementation, making the claims largely inaccurate with little alignment to actual code behavior.",
                "The summary claims the function configures socket state, memory, I/O windows, and configuration registers to enable a PCMCIA device. However, the source code shows the function primarily validates resources, checks CIS data, determines the number of functions on the card, and calls pcmcia_device_add for each \u2014 with no explicit configuration register setup or direct memory/I/O window configuration. The primary purpose of validation and adding devices is missed, making the claims inaccurate and not aligned with the actual implementation.",
                "The summary inaccurately describes the function as enabling a PCMCIA device by configuring socket state, memory, I/O windows, and registers, which contradicts the source code. The code instead checks resource readiness, validates memory, validates CIS, determines the number of functions, and calls pcmcia_device_add for each\u2014there is no direct configuration of I/O windows or registers. This is a FATAL error affecting the primary purpose, leading to high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Sets the receive mode for a PCMCIA device by validating the provided value and ensuring no valid port is registered and previously registered.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes setting a receive mode and checking for valid ports, which is unrelated to the source function. The source code adds a PCMCIA card, performs resource checks, validates memory, parses CIS tuples, and adds device functions. None of these actions involve a 'receive mode' or port registration, making the claims entirely inaccurate.",
                "The summary does not match the source code's primary purpose or behavior. The function adds a PCMCIA card by performing resource checks, validating memory and CIS data, determining the number of functions, and adding devices. The summary incorrectly describes setting a receive mode and port registration, which are unrelated to the implementation. This is a fundamental mismatch, missing both the primary purpose and secondary details.",
                "The summary's claim about setting a 'receive mode' and checking for a valid port is entirely unrelated to the actual code, which adds a PCMCIA card after validating resources and reading function tuples. This represents a FATAL error targeting the primary purpose and core I/O behavior, making the summary misleading and unusable for understanding the implementation."
            ]
        },
        "misum": {
            "summary": "Updates the PHY device configuration if it differs from the specified socket is present and the device is present in a network device.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims about updating PHY device configuration and network device presence are unrelated to the source code, which deals with adding a PCMCIA card, checking resources, validating CIS, reading function tuples, and adding devices. None of the claims match any part of the actual implementation, making them entirely inaccurate.",
                "The summary describes updating a PHY device configuration in a network context, which is unrelated to the source code's actual purpose. The function in the source code handles adding a PCMCIA card to a socket, validating resources, reading CIS tuples, and adding devices. None of these semantics are correctly reflected in the summary, making all claims inaccurate and missing the primary purpose entirely.",
                "The summary is entirely inaccurate, describing updates to a PHY device configuration in a network context, which is unrelated to the source code's actual function. The source code deals with adding a PCMCIA card, validating resources, and reading card tuples, not network devices or PHY configurations. This is a FATAL error affecting the primary purpose, resulting in a completely misleading description."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 1219488,
    "strip_function_name": "cms_SignedData_final",
    "strip_decompiled_code": "__int64 __fastcall cms_SignedData_final(__int64 *a1, int *a2)\n{\n  int v2; // r12d\n  unsigned int *v3; // r13\n  __int64 v4; // rbx\n  int v6; // eax\n  _BYTE *v7; // rax\n  char *v8; // [rsp+18h] [rbp-D0h]\n  void *v9; // [rsp+18h] [rbp-D0h]\n  int v10; // [rsp+2Ch] [rbp-BCh] BYREF\n  void *v11[6]; // [rsp+30h] [rbp-B8h] BYREF\n  char v12[72]; // [rsp+60h] [rbp-88h] BYREF\n  unsigned __int64 v13; // [rsp+A8h] [rbp-40h]\n\n  v2 = 0;\n  v13 = __readfsqword(0x28u);\n  v3 = (unsigned int *)CMS_get0_SignerInfos(a1);\n  if ( (int)sk_num(v3) <= 0 )\n  {\nLABEL_16:\n    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16LL) = 0;\n    return 1LL;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = sk_value((__int64)v3, v2);\n      EVP_MD_CTX_init(v11);\n      if ( !*(_QWORD *)(v4 + 64) )\n        break;\n      if ( !(unsigned int)cms_DigestAlgorithm_find_ctx((__int64 *)v11, a2, *(_QWORD **)(v4 + 16)) )\n        goto LABEL_4;\n      if ( (int)CMS_signed_get_attr_count(v4) < 0 )\n      {\n        v6 = EVP_PKEY_size(*(_QWORD *)(v4 + 64));\n        v7 = CRYPTO_malloc(v6, (__int64)\"cms_sd.c\", 0x295u);\n        if ( !v7 )\n        {\n          ERR_put_error(0x2Eu, 150, 65, (__int64)\"cms_sd.c\", 665);\n          goto LABEL_4;\n        }\n        v9 = v7;\n        if ( !(unsigned int)EVP_SignFinal(v11, (__int64)v7, &v10, *(_QWORD *)(v4 + 64)) )\n        {\n          ERR_put_error(0x2Eu, 150, 139, (__int64)\"cms_sd.c\", 671);\n          CRYPTO_free(v9);\nLABEL_4:\n          EVP_MD_CTX_cleanup((__int64 *)v11);\n          return 0LL;\n        }\n        ASN1_STRING_set0(*(_QWORD *)(v4 + 40), (__int64)v9, v10);\n      }\n      else\n      {\n        v8 = **(char ***)(a1[1] + 16);\n        if ( !(unsigned int)EVP_DigestFinal_ex(v11, (__int64)v12, &v10)\n          || !CMS_signed_add1_attr_by_NID(v4, 0x33u, 4u, v12, v10)\n          || (int)CMS_signed_add1_attr_by_NID(v4, 0x32u, 6u, v8, -1) <= 0\n          || !(unsigned int)CMS_SignerInfo_sign(v4) )\n        {\n          goto LABEL_4;\n        }\n      }\n      ++v2;\n      EVP_MD_CTX_cleanup((__int64 *)v11);\n      if ( v2 >= (int)sk_num(v3) )\n        goto LABEL_16;\n    }\n    ERR_put_error(0x2Eu, 150, 133, (__int64)\"cms_sd.c\", 629);\n    return 0LL;\n  }\n}\n",
    "function_name": "cms_SignedData_final",
    "decompiled_code": "__int64 __fastcall cms_SignedData_final(__int64 *a1, int *a2)\n{\n  int v2; // r12d\n  unsigned int *v3; // r13\n  __int64 v4; // rbx\n  int v6; // eax\n  _BYTE *v7; // rax\n  char *v8; // [rsp+18h] [rbp-D0h]\n  void *v9; // [rsp+18h] [rbp-D0h]\n  int v10; // [rsp+2Ch] [rbp-BCh] BYREF\n  void *v11[6]; // [rsp+30h] [rbp-B8h] BYREF\n  char v12[72]; // [rsp+60h] [rbp-88h] BYREF\n  unsigned __int64 v13; // [rsp+A8h] [rbp-40h]\n\n  v2 = 0;\n  v13 = __readfsqword(0x28u);\n  v3 = (unsigned int *)CMS_get0_SignerInfos(a1);\n  if ( (int)sk_num(v3) <= 0 )\n  {\nLABEL_16:\n    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16LL) = 0;\n    return 1LL;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = sk_value((__int64)v3, v2);\n      EVP_MD_CTX_init(v11);\n      if ( !*(_QWORD *)(v4 + 64) )\n        break;\n      if ( !(unsigned int)cms_DigestAlgorithm_find_ctx((__int64 *)v11, a2, *(_QWORD **)(v4 + 16)) )\n        goto LABEL_4;\n      if ( (int)CMS_signed_get_attr_count(v4) < 0 )\n      {\n        v6 = EVP_PKEY_size(*(_QWORD *)(v4 + 64));\n        v7 = CRYPTO_malloc(v6, (__int64)\"cms_sd.c\", 0x295u);\n        if ( !v7 )\n        {\n          ERR_put_error(0x2Eu, 150, 65, (__int64)\"cms_sd.c\", 665);\n          goto LABEL_4;\n        }\n        v9 = v7;\n        if ( !(unsigned int)EVP_SignFinal((__int64 *)v11, (__int64)v7, &v10, *(_QWORD *)(v4 + 64)) )\n        {\n          ERR_put_error(0x2Eu, 150, 139, (__int64)\"cms_sd.c\", 671);\n          CRYPTO_free(v9);\nLABEL_4:\n          EVP_MD_CTX_cleanup((__int64 *)v11);\n          return 0LL;\n        }\n        ASN1_STRING_set0(*(_QWORD *)(v4 + 40), (__int64)v9, v10);\n      }\n      else\n      {\n        v8 = **(char ***)(a1[1] + 16);\n        if ( !(unsigned int)EVP_DigestFinal_ex(v11, (__int64)v12, &v10)\n          || !CMS_signed_add1_attr_by_NID(v4, 0x33u, 4u, v12, v10)\n          || (int)CMS_signed_add1_attr_by_NID(v4, 0x32u, 6u, v8, -1) <= 0\n          || !(unsigned int)CMS_SignerInfo_sign(v4) )\n        {\n          goto LABEL_4;\n        }\n      }\n      ++v2;\n      EVP_MD_CTX_cleanup((__int64 *)v11);\n      if ( v2 >= (int)sk_num(v3) )\n        goto LABEL_16;\n    }\n    ERR_put_error(0x2Eu, 150, 133, (__int64)\"cms_sd.c\", 629);\n    return 0LL;\n  }\n}\n",
    "source_code": "\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n\t{\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tCMS_SignerInfo *si;\n\tint i;\n\tsinfos = CMS_get0_SignerInfos(cms);\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tif (!cms_SignerInfo_content_sign(cms, si, chain))\n\t\t\treturn 0;\n\t\t}\n\tcms->d.signedData->encapContentInfo->partial = 0;\n\treturn 1;\n\t}",
    "comment": "Finalizes the signing process for all signer information in the CMS_ContentInfo structure by signing the content and marking it as complete.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Finalizes the signer information structure by generating a digital signature , encoding it , and storing it in the provided CMS_SignerInfo structure .\n",
    "cpbcs_sum": "Verifies the digital signature of a PKCS7 structure using the provided context and signature algorithm after validating the key.\n",
    "misum_sum": "Generates a temporary key of specified digest algorithms using the provided EVP_PKEY structure and stores it in an EVP_PKEY structure.\n",
    "decom_sum": "Generates and finalizes CMS signer information by computing digests or signatures, adding required signed attributes, and storing results for all signers.",
    "cfg_sum": "Finalizes CMS SignedData by iterating through signers, generating or adding signature attributes, handling errors, and returning success or failure status.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a filled buffer or null based on a Unicode character's name in uppercase ASCII are completely unrelated to the source code, which handles CMS signed data finalization. None of the claims accurately describe the function's purpose or behavior, resulting in zero alignment with the source.",
                "The summary describes functionality related to looking up a Unicode character name and returning it in uppercase ASCII, with null for missing names. This is entirely unrelated to the source code, which signs CMS content and updates internal state. The claims are inaccurate and do not capture the primary purpose or any secondary details of the source function.",
                "The summary's claims describe returning a buffer or null based on a Unicode character name lookup, which is entirely unrelated to the source code that finalizes CMS signed data structures and performs signing operations. All claims are [INACCURATE] as they target different functionality, creating overwhelming NOISE with no accurate insights. There is no positive alignment or useful information for understanding the given function."
            ]
        },
        "bint5": {
            "summary": "Finalizes the signer information structure by generating a digital signature , encoding it , and storing it in the provided CMS_SignerInfo structure .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function generates a digital signature, encodes it, and stores it in the CMS_SignerInfo structure. The source code only shows iteration over signer infos, calling cms_SignerInfo_content_sign, updating a partial flag, and returning success, without explicit evidence of encoding operations or detailed finalization as described. These extra details go beyond what can be confirmed from the source, making most claims inaccurate and only partially aligning with the observed behavior.",
                "The summary inaccurately describes the function\u2019s purpose by claiming it generates, encodes, and stores a digital signature in the CMS_SignerInfo structure, which is not explicitly shown in the source code. The actual code iterates over signer infos, calls a signing helper, updates a 'partial' flag, and returns success or failure. This means the primary purpose is misrepresented and key implementation details such as iteration over signers and flag manipulation are missing, resulting in low alignment with the evaluation steps.",
                "The summary claims that the function generates a digital signature, encodes it, and stores it in the CMS_SignerInfo structure, which is inaccurate. The source code instead iterates over signer infos, invokes another function to sign content, sets a 'partial' flag to 0, and returns status. The described encoding and storing steps are not evidenced, making this a FATAL error concerning the primary purpose. The incorrect characterization of the core operation yields high negative impact with no reliable gain."
            ]
        },
        "cpbcs": {
            "summary": "Verifies the digital signature of a PKCS7 structure using the provided context and signature algorithm after validating the key.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function verifies a digital signature on a PKCS7 structure using a signature algorithm and key validation, which contradicts the source code. The implementation actually signs content for all signer infos and updates the partial flag to 0, with no verification logic or PKCS7-specific handling present. All claims are inaccurate, leading to a very low accuracy proportion.",
                "The summary incorrectly describes the function as verifying a digital signature for a PKCS7 structure, whereas the source code shows it iterates through signer infos and signs the content via `cms_SignerInfo_content_sign`, then marks the content as complete. The PRIMARY PURPOSE of signing the content is missed, and the PKCS7 reference is inaccurate given the code operates on CMS structures. No secondary details such as iteration over signers or setting `partial` to 0 are captured.",
                "The summary claims the function verifies a digital signature on a PKCS7 structure using a provided context and signature algorithm after key validation. This is inaccurate: the source code shows the function iterates over signer infos, signs content via cms_SignerInfo_content_sign, and marks partial as 0\u2014it does not perform signature verification or key validation. The incorrect primary purpose is a FATAL error affecting the core semantics."
            ]
        },
        "misum": {
            "summary": "Generates a temporary key of specified digest algorithms using the provided EVP_PKEY structure and stores it in an EVP_PKEY structure.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes functionality related to generating a temporary key with digest algorithms and EVP_PKEY structures, which is unrelated to the source code. The source code finalizes CMS signed data by iterating over signer infos, signing content, and marking content as complete. None of the claims in the summary are accurate with respect to the implementation, resulting in 0% accurate claims.",
                "The summary describes generating a temporary key with digest algorithms and storing it in an EVP_PKEY structure, which is entirely unrelated to the source code. The source function finalizes CMS SignedData by iterating over signer infos, signing content, updating a 'partial' flag, and returning a success status. The summary misses the primary purpose and all secondary details, making the claims inaccurate and non-covering.",
                "The summary describes generating a temporary key with digest algorithms and storing it in an EVP_PKEY structure, which is entirely unrelated to the actual source code. The source function finalizes signed data by iterating over signer infos, signing content, and marking the content as complete. This is a clear FATAL error targeting the primary purpose and semantics of the function, resulting in high negative impact with no accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585401680,
    "strip_function_name": "sub_FFFFFFFF81640B50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81640B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  unsigned int v6; // r12d\n  __int64 v7; // rcx\n  __int64 v8; // rcx\n  unsigned int v9; // edx\n  __int64 result; // rax\n\n  v6 = a3;\n  v7 = *(unsigned int *)(a2 + 200);\n  if ( (*(_BYTE *)(a2 + 124) & 2) == 0 )\n    goto LABEL_2;\n  v8 = *(_QWORD *)(a2 + 208) + v7;\n  if ( (unsigned __int16)*(_DWORD *)(v8 + 36) != 1 && !byte_FFFFFFFF81CAC6A7 )\n  {\n    sub_FFFFFFFF8103BB80((__int64)\"net/ipv4/tcp_output.c\", 993, a3, v8, a5, a6);\n    byte_FFFFFFFF81CAC6A7 = 1;\n    v7 = *(unsigned int *)(a2 + 200);\nLABEL_2:\n    v8 = *(_QWORD *)(a2 + 208) + v7;\n  }\n  v9 = *(_DWORD *)(a2 + 104);\n  if ( v9 > v6\n    && *(_DWORD *)(a1 + 304) << 16 == (*(_QWORD *)(a1 + 288) & (int)(*(_DWORD *)(a1 + 304) << 16))\n    && (*(_BYTE *)(a2 + 124) & 0xC) != 0 )\n  {\n    *(_WORD *)(v8 + 4) = (v9 + v6 - 1) / v6;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = v6;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = *(_DWORD *)(a1 + 304);\n  }\n  else\n  {\n    *(_WORD *)(v8 + 4) = 1;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = 0;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = 0;\n  }\n  return result;\n}\n",
    "function_name": "tcp_set_skb_tso_segs",
    "decompiled_code": "__int64 __fastcall tcp_set_skb_tso_segs(\n        __int64 a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v12; // rcx\n  __int64 v13; // rcx\n  unsigned int v14; // edx\n  __int64 result; // rax\n\n  v12 = *(unsigned int *)(a2 + 200);\n  if ( (*(_BYTE *)(a2 + 124) & 2) == 0 )\n    goto LABEL_2;\n  v13 = *(_QWORD *)(a2 + 208) + v12;\n  if ( (unsigned __int16)*(_DWORD *)(v13 + 36) != 1 && !_warned_45322 )\n  {\n    warn_slowpath_null(\"net/ipv4/tcp_output.c\", 0x3E1u, a4, a5, a6, a7, a8, a9, a10, a11);\n    _warned_45322 = 1;\n    v12 = *(unsigned int *)(a2 + 200);\nLABEL_2:\n    v13 = *(_QWORD *)(a2 + 208) + v12;\n  }\n  v14 = *(_DWORD *)(a2 + 104);\n  if ( v14 > a3\n    && *(_DWORD *)(a1 + 304) << 16 == (*(_QWORD *)(a1 + 288) & (int)(*(_DWORD *)(a1 + 304) << 16))\n    && (*(_BYTE *)(a2 + 124) & 0xC) != 0 )\n  {\n    *(_WORD *)(v13 + 4) = (v14 + a3 - 1) / a3;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = a3;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = *(_DWORD *)(a1 + 304);\n  }\n  else\n  {\n    *(_WORD *)(v13 + 4) = 1;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = 0;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = 0;\n  }\n  return result;\n}\n",
    "source_code": "static void tcp_set_skb_tso_segs(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int mss_now)\n{\n\tif (skb->len <= mss_now || !sk_can_gso(sk) ||\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\t/* Avoid the costly divide in the normal\n\t\t * non-TSO case.\n\t\t */\n\t\tskb_shinfo(skb)->gso_segs = 1;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t} else {\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss_now);\n\t\tskb_shinfo(skb)->gso_size = mss_now;\n\t\tskb_shinfo(skb)->gso_type = sk->sk_gso_type;\n\t}\n}",
    "comment": "Sets the TCP segmentation offload parameters for a socket buffer based on its length and the maximum segment size.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Calculates the TCP transmission unit ( PMTU ) for a given socket buffer based on its header and socket parameters .\n",
    "cpbcs_sum": "Copies TCP packets from the source socket to the destination buffer, ensuring the buffer is not fragmented and the specified socket.\n",
    "misum_sum": "Adds a TCP segment to a socket buffer, adjusting fragment sizes and timestamp based on the TCP segment and segment length.\n",
    "decom_sum": "Configures TCP packet header fields based on connection state and segment size before transmission, enforcing checks and logging unexpected header conditions once.",
    "cfg_sum": "Updates TCP segment header fields based on connection state and validation checks, triggering debug logging if unexpected conditions occur, and returns the segment offset.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes functionality related to multibyte character string processing and handling of non-printable characters, which is entirely unrelated to the TCP segmentation logic implemented in the source code. None of the claims align with the function\u2019s purpose or operations, resulting in all claims being inaccurate.",
                "The summary describes behavior related to measuring multibyte character string width and handling non-printable characters, which is entirely unrelated to the source code\u2019s actual TCP segmentation logic for setting gso_segs, gso_size, and gso_type based on conditions. It fails to capture the primary purpose or any secondary details from the source code, making the claims inaccurate and irrelevant.",
                "The summary's claims describe functionality related to multibyte character string processing and handling non-printable characters, which is completely unrelated to the source code that sets TCP GSO segment parameters based on MSS and socket capabilities. All claims are NOISE, with no accurate match to the implementation, resulting in overwhelming irrelevance and zero useful insight."
            ]
        },
        "bint5": {
            "summary": "Calculates the TCP transmission unit ( PMTU ) for a given socket buffer based on its header and socket parameters .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates the TCP transmission unit (PMTU) based on header and socket parameters, which is inaccurate. The source code sets `gso_segs`, `gso_size`, and `gso_type` for TSO behavior depending on conditions, and does not compute PMTU. All extracted claims from the summary describe semantics not supported by the code, resulting in 0% accurate claims.",
                "The summary misstates the primary purpose: the function sets TSO segment parameters (gso_segs, gso_size, gso_type) based on skb length, MSS, and socket capability, rather than calculating PMTU. No accurate claims map to critical semantic units in the source code, and important secondary details like conditional checks and specific assignments are missed entirely.",
                "The summary claims the function calculates the TCP transmission unit (PMTU), which is inaccurate. The source code shows it sets GSO segmentation details (gso_segs, gso_size, gso_type) based on MSS and socket capabilities, not PMTU calculation. This is a FATAL error affecting the primary purpose of the function, leading to high negative impact and minimal accurate information."
            ]
        },
        "cpbcs": {
            "summary": "Copies TCP packets from the source socket to the destination buffer, ensuring the buffer is not fragmented and the specified socket.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function copies TCP packets from a source socket to a destination buffer and avoids fragmentation, which does not align with the source code. The source code sets segmentation parameters (`gso_segs`, `gso_size`, `gso_type`) based on conditions, but performs no packet copying. All claims in the summary are inaccurate, resulting in 0% accuracy.",
                "The summary's description of copying TCP packets from a source socket to a destination buffer is inaccurate, as the source code does not perform any packet copying. Instead, it sets GSO segment, size, and type fields in the skb based on MSS, socket capabilities, and checksum state. The summary misses the primary purpose entirely and provides details unrelated to the actual behavior, resulting in no coverage of critical semantic units.",
                "The summary incorrectly describes the function as copying TCP packets from a source socket to a destination buffer, which is not reflected in the source code. The actual implementation sets segmentation parameters for a socket buffer depending on its length and socket GSO capability, not performing any data copying. This is a FATAL inaccuracy about the primary purpose, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Adds a TCP segment to a socket buffer, adjusting fragment sizes and timestamp based on the TCP segment and segment length.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function adds a TCP segment to a socket buffer and adjusts fragment sizes and timestamp based on the TCP segment and length. In reality, the source code does not add a TCP segment, nor does it handle timestamps; it sets GSO segment count, size, and type based on length and conditions. Only the broad idea of adjusting fragment sizes is loosely accurate, making most claims inaccurate.",
                "The summary incorrectly states that the function adds a TCP segment and adjusts timestamp, which is not present in the source code. The actual purpose is to set segmentation parameters (`gso_segs`, `gso_size`, `gso_type`) based on conditions involving packet length, GSO capability, and checksum status. The summary misses the primary purpose, misrepresents functionality, and omits key branch conditions and specific field assignments.",
                "The summary claims that the function adds a TCP segment to a socket buffer and adjusts fragment sizes and timestamp, but the source code does not add any segment or manipulate timestamps. Instead, it sets gso_segs, gso_size, and gso_type based on conditions related to MSS and GSO capability. These inaccuracies target the primary purpose and semantics of the function, making them FATAL errors with high negative impact."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 450304,
    "strip_function_name": "sub_6DF00",
    "strip_decompiled_code": "__int64 __fastcall sub_6DF00(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v5; // rbp\n  __int64 v6; // rax\n  __int64 v7; // rdi\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  unsigned int v11; // eax\n  int v12; // edx\n  int v13; // ecx\n  int v14; // r8d\n  int v15; // r9d\n  unsigned int v16; // eax\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  char v21[8200]; // [rsp+0h] [rbp-2028h] BYREF\n  unsigned __int64 v22; // [rsp+2008h] [rbp-20h]\n\n  v22 = __readfsqword(0x28u);\n  Rf_checkArityCall(a2, a3, a1);\n  v5 = *(_QWORD *)(a3 + 32);\n  if ( (*(_BYTE *)v5 & 0x1F) != 0x10 || v5 == *(_QWORD *)&R_NilValue )\n    goto LABEL_13;\n  if ( *(char *)v5 < 0 )\n    v6 = ALTREP_LENGTH(*(_QWORD *)(a3 + 32));\n  else\n    v6 = *(_QWORD *)(v5 + 32);\n  if ( v6 > 0x7FFFFFFF )\n    R_BadLongVector(v5, \"Rdynload.c\", 960LL);\n  if ( (_DWORD)v6 != 1 )\n  {\nLABEL_13:\n    v11 = (unsigned int)dcgettext(0LL, \"character argument expected\", 5);\n    Rf_error(v11, (unsigned int)\"character argument expected\", v12, v13, v14, v15);\n  }\n  v7 = *(_QWORD *)(a3 + 32);\n  if ( *(char *)v7 < 0 )\n    v8 = ALTSTRING_ELT(v7, 0LL);\n  else\n    v8 = *(_QWORD *)(v7 + 48);\n  v9 = Rf_translateChar(v8);\n  (*((void (__fastcall **)(__int64, char *, __int64))off_512010 + 7))(a1, v21, v9);\n  if ( !(unsigned int)sub_6D7D0(v21) )\n  {\n    v16 = (unsigned int)dcgettext(0LL, \"shared object '%s' was not loaded\", 5);\n    Rf_error(v16, (unsigned int)v21, v17, v18, v19, v20);\n  }\n  return *(_QWORD *)&R_NilValue;\n}\n",
    "function_name": "do_dynunload",
    "decompiled_code": "__int64 __fastcall do_dynunload(\n        char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        int a5,\n        int a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        double a11,\n        double a12,\n        __m128 a13,\n        __m128 a14)\n{\n  __int64 v17; // rsi\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n  __m128 v21; // xmm4\n  __m128 v22; // xmm5\n  __int64 v23; // rbp\n  __int64 v24; // rdx\n  __int64 v25; // rax\n  __int64 v26; // rdi\n  __int64 v27; // rdi\n  void *v28; // rax\n  unsigned int v30; // eax\n  __int64 v31; // rdx\n  __int64 v32; // rcx\n  __int64 v33; // r8\n  __int64 v34; // r9\n  __m128 v35; // xmm4\n  __m128 v36; // xmm5\n  unsigned int v37; // eax\n  __int64 v38; // rdx\n  __int64 v39; // rcx\n  __int64 v40; // r8\n  __int64 v41; // r9\n  __m128 v42; // xmm4\n  __m128 v43; // xmm5\n  char v44[8200]; // [rsp+0h] [rbp-2028h] BYREF\n  unsigned __int64 v45; // [rsp+2008h] [rbp-20h]\n\n  v17 = a3;\n  v45 = __readfsqword(0x28u);\n  Rf_checkArityCall(a2, a3, a1, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);\n  v23 = *(_QWORD *)(a3 + 32);\n  v24 = *(_BYTE *)v23 & 0x1F;\n  if ( (_BYTE)v24 != 16 || v23 == *(_QWORD *)&R_NilValue )\n    goto LABEL_13;\n  if ( *(char *)v23 < 0 )\n    v25 = ALTREP_LENGTH(*(_QWORD *)(a3 + 32));\n  else\n    v25 = *(_QWORD *)(v23 + 32);\n  if ( v25 > 0x7FFFFFFF )\n    R_BadLongVector(\n      a7,\n      a8,\n      a9,\n      a10,\n      *(double *)v21.m128_u64,\n      *(double *)v22.m128_u64,\n      a13,\n      a14,\n      v23,\n      (__int64)\"Rdynload.c\",\n      0x3C0u);\n  if ( (_DWORD)v25 != 1 )\n  {\nLABEL_13:\n    v30 = (unsigned int)dcgettext(0LL, \"character argument expected\", 5);\n    Rf_error(v30, (__int64)\"character argument expected\", v31, v32, v33, v34, a7, a8, a9, a10, v35, v36, a13, a14);\n  }\n  v26 = *(_QWORD *)(a3 + 32);\n  if ( *(char *)v26 < 0 )\n  {\n    v17 = 0LL;\n    v27 = ALTSTRING_ELT(v26, 0, v24, v18, v19, v20);\n  }\n  else\n  {\n    v27 = *(_QWORD *)(v26 + 48);\n  }\n  v28 = Rf_translateChar(v27, a7, a8, a9, a10, v21, v22, a13, a14, v17, v24, v18, v19, v20);\n  (*((void (__fastcall **)(char *, char *, void *))R_osDynSymbol + 7))(a1, v44, v28);\n  if ( !(unsigned int)DeleteDLL(v44) )\n  {\n    v37 = (unsigned int)dcgettext(0LL, \"shared object '%s' was not loaded\", 5);\n    Rf_error(v37, (__int64)v44, v38, v39, v40, v41, a7, a8, a9, a10, v42, v43, a13, a14);\n  }\n  return *(_QWORD *)&R_NilValue;\n}\n",
    "source_code": "\nSEXP attribute_hidden do_dynunload(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    char buf[2 * PATH_MAX];\n\n    checkArity(op,args);\n    if (!isString(CAR(args)) || LENGTH(CAR(args)) != 1)\n\terror(_(\"character argument expected\"));\n    GetFullDLLPath(call, buf, translateChar(STRING_ELT(CAR(args), 0)));\n    if(!DeleteDLL(buf))\n\terror(_(\"shared object '%s\\' was not loaded\"), buf);\n    return R_NilValue;\n}",
    "comment": "Unloads a shared object from memory by verifying the argument and deleting its associated DLL using the full path derived from the input.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Sets the error message in R to a specified character string , ensuring it is a single string argument .\n",
    "cpbcs_sum": "Sets the error message domain for a specified R environment using the provided arguments, ensuring it is a single string argument.\n",
    "misum_sum": "Reads environment variables from a specified file and returns a logical value indicating successful reading or failure.\n",
    "decom_sum": "Loads a named shared object in R, validating a single string argument and raising errors if missing or loading fails.",
    "cfg_sum": "Loads a shared object by name, ensuring the argument is a single character string, and reports localized errors if validation or loading fails.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains two claims: that the function returns the filled buf or null if a character does not have a name, and that it looks up the name of a Unicode character in uppercase ASCII. Neither claim is supported by the source code, which actually checks for a single string argument, constructs a DLL path, attempts to delete it, and returns R_NilValue. No accurate claims about the code are present, so the proportion of accurate statements is zero.",
                "The summary's claims about returning a filled buffer or null, and looking up a Unicode character name in uppercase ASCII, are entirely unrelated to the actual source code, which unloads a dynamically loaded shared object based on a given path string and returns R_NilValue. The primary purpose is missed, and none of the critical semantic units from the source are captured.",
                "The summary's claims are entirely inaccurate. It states that the function returns a filled buffer or null based on a character name and retrieves a Unicode character name in uppercase ASCII, which contradicts the source code. The actual implementation checks argument type and length, constructs a DLL path, deletes the DLL, and returns R_NilValue, with no relation to Unicode character lookup or uppercase conversion. This represents a FATAL error affecting the primary purpose and core I/O of the function."
            ]
        },
        "bint5": {
            "summary": "Sets the error message in R to a specified character string , ensuring it is a single string argument .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function sets an error message in R to a specified character string, which does not align with the source code. The code checks that the argument is a single string, resolves its DLL path, and attempts to unload it, producing specific error messages only if conditions fail. The main purpose is DLL unloading, not setting arbitrary error messages. This makes the core claim inaccurate, with only the part about ensuring a single string argument being accurate.",
                "The summary incorrectly describes the function as setting an error message in R, which contradicts the source code's actual primary purpose of unloading a DLL by path after validating a single string argument. While it notes the single string argument requirement, it omits the critical DLL path resolution, deletion, and related error handling. The inaccurate primary purpose and lack of coverage on secondary details result in low alignment.",
                "The summary claims the function sets an error message in R to a specified character string, which does not match the actual code\u2019s primary purpose. The function validates that the argument is a single string, constructs the DLL path, attempts to unload it, and raises errors only if validation fails or the DLL is not loaded. The mismatch directly contradicts the core functionality (unloading a DLL), making this a FATAL error regarding the primary purpose."
            ]
        },
        "cpbcs": {
            "summary": "Sets the error message domain for a specified R environment using the provided arguments, ensuring it is a single string argument.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes setting an error message domain in an R environment, which is unrelated to the source code. The source implements dynamic unloading of a DLL, validating that the argument is a single string and handling errors if the DLL is not loaded. None of the claims in the summary accurately reflect the actual implementation, resulting in 0% accuracy.",
                "The summary is inaccurate because it claims the function sets the error message domain, which is not in the source code. The actual primary purpose is to unload a dynamically loaded DLL in R after validating that the argument is a single string and handling error cases. The summary misses this core purpose and all secondary details such as DLL path resolution, deletion, and specific error handling, resulting in no coverage of the implementation.",
                "The summary incorrectly describes the function's purpose as setting an error message domain, which does not match the source code. The implementation actually checks that the argument is a single string, resolves its full DLL path, attempts to unload it, and returns R_NilValue, raising errors if checks fail. This mismatch is a FATAL error regarding the primary purpose, leading to unreliable understanding."
            ]
        },
        "misum": {
            "summary": "Reads environment variables from a specified file and returns a logical value indicating successful reading or failure.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function reads environment variables from a file and returns a logical success indicator, but the source code shows it loads a DLL path from a string argument, attempts to unload it, and returns R_NilValue. None of the described behavior in the summary matches the actual implementation, resulting in no accurate claims.",
                "The summary claims the function reads environment variables from a file and returns a logical value. This is entirely inaccurate given the source code, which unloads a dynamically loaded shared object (DLL), validates its argument, constructs its file path, deletes it, and returns R_NilValue. The primary purpose and all secondary details from the source are missed, and the described behavior is unrelated to the implementation.",
                "The summary claims the function reads environment variables from a file and returns a logical success/failure, but the source code shows it checks argument type, constructs a DLL path, attempts to unload a DLL, and returns R_NilValue. This is a direct contradiction to the primary purpose and output, making it a FATAL error with high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579563904,
    "strip_function_name": "sub_FFFFFFFF810AF780",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810AF780(__int64 a1)\n{\n  _QWORD *v2; // rbx\n  __int64 v3; // r13\n  int v4; // ebx\n  __int64 v5; // rax\n  int v6; // [rsp-2Ch] [rbp-2Ch] BYREF\n  _UNKNOWN **v7; // [rsp-28h] [rbp-28h]\n\n  if ( !dword_FFFFFFFF81E66B68 )\n    return 0LL;\n  v7 = (_UNKNOWN **)off_FFFFFFFF81C365F0;\n  v2 = off_FFFFFFFF81C365F0;\n  if ( off_FFFFFFFF81C365F0 == (_UNKNOWN *)&off_FFFFFFFF81C365F0 )\n  {\nLABEL_11:\n    v3 = 0LL;\n    v4 = 1;\n  }\n  else\n  {\n    while ( !(unsigned int)sub_FFFFFFFF810AD5F0(a1, v2 + 4, 0LL, 0LL, &v6, 1LL) )\n    {\n      v7 = (_UNKNOWN **)*v2;\n      v2 = v7;\n      if ( v7 == &off_FFFFFFFF81C365F0 )\n        goto LABEL_11;\n    }\n    v3 = 0LL;\n    if ( v6 == 2 )\n      v3 = sub_FFFFFFFF81100020(v2[39], 32LL);\n    v4 = v6;\n    if ( !v6 )\n      return 0LL;\n  }\n  v5 = sub_FFFFFFFF8112CA50(qword_FFFFFFFF81E8C750, 32976LL, 864LL);\n  if ( v5 )\n  {\n    *(_DWORD *)(v5 + 8) = v4;\n    *(_QWORD *)(v5 + 600) = v3;\n    *(_QWORD *)(v5 + 80) = -(__int64)(v4 == 2);\n    *(_QWORD *)(v5 + 760) = v5 + 760;\n    *(_QWORD *)(v5 + 768) = v5 + 760;\n    *(_QWORD *)(v5 + 584) = v5 + 584;\n    *(_QWORD *)(v5 + 592) = v5 + 584;\n    *(_QWORD *)(a1 + 1464) = v5;\n    _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a1 + 8) + 16LL), 0x80u);\n    return 0LL;\n  }\n  sub_FFFFFFFF8112DCD0(v3);\n  sub_FFFFFFFF810A8A10((int)\"out of memory in audit_alloc\", 32976LL);\n  return 4294967284LL;\n}\n",
    "function_name": "audit_alloc",
    "decompiled_code": "__int64 __fastcall audit_alloc(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  _QWORD *v10; // rbx\n  unsigned __int64 v11; // r13\n  int v12; // ebx\n  __int64 v13; // rax\n  __int64 *v14; // rdx\n  __int64 v15; // rcx\n  int v16; // r8d\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  int v22; // [rsp-2Ch] [rbp-2Ch] BYREF\n  _UNKNOWN **v23; // [rsp-28h] [rbp-28h]\n\n  if ( !audit_ever_enabled )\n    return 0LL;\n  v23 = (_UNKNOWN **)off_FFFFFFFF81C365F0;\n  v10 = off_FFFFFFFF81C365F0;\n  if ( off_FFFFFFFF81C365F0 == (_UNKNOWN *)&off_FFFFFFFF81C365F0 )\n  {\nLABEL_11:\n    v11 = 0LL;\n    v12 = 1;\n  }\n  else\n  {\n    while ( !(unsigned int)audit_filter_rules(a1, v10 + 4, 0LL, 0LL, &v22, 1LL) )\n    {\n      v23 = (_UNKNOWN **)*v10;\n      v10 = v23;\n      if ( v23 == &off_FFFFFFFF81C365F0 )\n        goto LABEL_11;\n    }\n    v11 = 0LL;\n    if ( v22 == 2 )\n      v11 = kstrdup(v10[39], 0x20u);\n    v12 = v22;\n    if ( !v22 )\n      return 0LL;\n  }\n  v13 = kmem_cache_alloc_trace((_QWORD *)qword_FFFFFFFF81E8C750, 0x80D0u, 864LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( v13 )\n  {\n    *(_DWORD *)(v13 + 8) = v12;\n    *(_QWORD *)(v13 + 600) = v11;\n    *(_QWORD *)(v13 + 80) = -(__int64)(v12 == 2);\n    *(_QWORD *)(v13 + 760) = v13 + 760;\n    *(_QWORD *)(v13 + 768) = v13 + 760;\n    *(_QWORD *)(v13 + 584) = v13 + 584;\n    *(_QWORD *)(v13 + 592) = v13 + 584;\n    *(_QWORD *)(a1 + 1464) = v13;\n    _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a1 + 8) + 16LL), 0x80u);\n    return 0LL;\n  }\n  kfree(v11, a2, a3, a4, a5, v18, v19, a8, a9, 32976LL, v14, v15, v16, v17);\n  audit_log_lost((__int64)\"out of memory in audit_alloc\", a2, a3, a4, a5, v20, v21, a8, a9);\n  return 4294967284LL;\n}\n",
    "source_code": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED)\n\t\treturn 0;\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "comment": "Allocates an audit context for a given task if auditing is enabled and filters the task based on its audit state.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Checks if a specified audit filter exists by comparing it against a list of valid audit filters .\n",
    "cpbcs_sum": "Initiates a system core dump for userspace registered devices by verifying their memory against the provided limit and updating flags accordingly.\n",
    "misum_sum": "Reserves memory for a memory type if the address space is not already set, updating the mapping list and mapping accordingly.\n",
    "decom_sum": "Allocates and initializes an audit record for the given context, linking it to a global list and handling memory allocation failures.",
    "cfg_sum": "Allocates and initializes an audit data structure from a linked list entry, storing parameters and handling memory allocation failures with error reporting.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains only a vague phrase that does not relate to or accurately describe the source code\u2019s semantics. It fails to capture specific fact-based details from the function, such as audit initialization, context allocation, and error handling. As it does not match or safely generalize the implementation, the proportion of accurate claims is effectively zero.",
                "The summary is vague and does not convey the primary purpose of the function, which is to allocate and initialize an audit context for a given task if auditing is enabled. It fails to mention key secondary details such as the conditions checked before allocation, handling of the AUDIT_DISABLED state, error handling for memory allocation, and setting of the syscall audit flag. The claim 'push a pointer type' does not match any specific semantics of the source code, making it inaccurate and providing no coverage.",
                "The summary 'push a pointer type.' is vague, unrelated to the source code\u2019s primary purpose, and contains no specific or accurate claims about the audit_alloc function. It does not describe any of the main I/O, control flow, or side effects, resulting in pure NOISE with no useful insight. There are no accurate claims to yield positive gain."
            ]
        },
        "bint5": {
            "summary": "Checks if a specified audit filter exists by comparing it against a list of valid audit filters .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function checks for the existence of a specified audit filter against a list of valid audit filters, but the source code shows it allocates an audit context for a task, checks if auditing is enabled, applies an audit filter to determine state, and sets relevant task flags. There is no explicit comparison against a list of valid filters, making the summary's claim inaccurate and unrelated to the actual semantics.",
                "The summary incorrectly describes the function as checking for the existence of an audit filter against a list of valid filters, which is not reflected in the source code. The actual implementation allocates and sets an audit context for a given task, with checks for whether auditing is enabled, handling of an audit filter state, and out-of-memory error logging. The primary purpose is missed entirely, and none of the key behavior or secondary details are covered.",
                "The summary asserts that the function checks for a specified audit filter against a list of valid audit filters, which is inaccurate. The source code shows it allocates an audit context, verifies auditing is enabled, and applies a task-based filter\u2014no list comparison is implemented. This is a FATAL error as it misstates the primary purpose and core logic of the function, offering no accurate claims and misleading about key I/O behavior."
            ]
        },
        "cpbcs": {
            "summary": "Initiates a system core dump for userspace registered devices by verifying their memory against the provided limit and updating flags accordingly.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary\u2019s claim about initiating a system core dump for userspace registered devices and verifying memory limits does not match the source code, which allocates and sets up an audit context for a task, checks auditing state, and updates a thread flag. None of the atomic claims align with the actual function behavior, resulting in no accurate matches.",
                "The summary is completely inaccurate as it describes initiating a system core dump for userspace devices with memory verification, which is unrelated to the source code. The source function allocates and initializes an audit context for a task, handles cases when auditing is disabled, performs filtering, manages memory allocation failures, sets a filter key, updates the task's audit context, and sets a thread flag. The summary misses the primary purpose and all secondary details of the code.",
                "The summary's claim that the function initiates a system core dump for userspace registered devices and verifies memory is entirely unrelated to the source code, which manages audit context allocation, task auditing state, and flags. This is a FATAL error targeting the primary purpose incorrectly, making the description wholly inaccurate and misleading."
            ]
        },
        "misum": {
            "summary": "Reserves memory for a memory type if the address space is not already set, updating the mapping list and mapping accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claim about reserving memory based on address space and updating mapping lists does not match the source code, which deals with allocating an audit context for a task and setting audit flags. None of the claims in the summary are accurate to the actual audit-related logic present, resulting in no alignment with the source implementation.",
                "The summary describes reserving memory for a memory type and updating mappings, which does not align with the source code. The function in the source code allocates and initializes an audit context for a task if auditing is enabled, handles the audit state, error conditions, and sets a thread flag. The summary completely misses the primary purpose and all secondary details of the actual implementation.",
                "The summary's claim about reserving memory for a type, updating mapping lists, and adjusting mappings does not align with the source code, which handles auditing state for a task, allocates an audit context, sets audit-related flags, and logs errors if memory allocation fails. This is a completely different functionality, creating a FATAL error regarding the primary purpose. No accurate claims are present, resulting in high negative impact and zero positive gain."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4306256,
    "strip_function_name": "sub_41B550",
    "strip_decompiled_code": "__int64 __fastcall sub_41B550(__int64 a1, const char *a2, int a3, int *a4, __int64 a5, __int64 *a6, char a7)\n{\n  __int64 v7; // rbx\n  unsigned int v8; // ebp\n  int v9; // eax\n  __int64 v10; // rdx\n  int v11; // eax\n  __int64 v12; // rdx\n  char *v14; // rax\n  __int64 v15; // rdx\n  const char *v16; // rbx\n  int v17; // eax\n\n  v7 = *a4;\n  v8 = a7 & 1;\n  if ( (a7 & 1) != 0 )\n  {\n    *a4 = v7 + 1;\n    v9 = strlen(a2) + 1;\n    v10 = v9;\n    v11 = v9 & 7;\n    v12 = *a6 + v10 + 8;\n    if ( v11 )\n      v12 = v12 + 8 - v11;\n    *a6 = v12;\n    return v8;\n  }\n  if ( a3 <= (int)v7 )\n  {\n    v16 = (const char *)(a1 + 176644);\n    sprintf((char *)(a1 + 176644), \"Number of matching files changed unexpectedly (> %d)\", a3);\n    if ( (a7 & 2) != 0 )\n    {\n      sub_4118F0((_DWORD *)a1, 0, v16, 0, \"FATAL\", 0);\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      sub_4118F0((_DWORD *)a1, 0, v16, 0, \"WARNING\", 0);\n      return a7 & 2;\n    }\n  }\n  else\n  {\n    v14 = strdup(a2);\n    v15 = *a4;\n    *(_QWORD *)(a5 + 8 * v7) = v14;\n    if ( !*(_QWORD *)(a5 + 8 * v15) )\n    {\n      v8 = -1;\n      v17 = strlen(a2);\n      sub_41B3D0(a1, v17 + 1);\n      return v8;\n    }\n    *a4 = v15 + 1;\n    return 1LL;\n  }\n}\n",
    "function_name": "Xorriso_register_matched_adr",
    "decompiled_code": "__int64 __fastcall Xorriso_register_matched_adr(\n        XorrisO *a1,\n        char *adr,\n        int count_limit,\n        int *filec,\n        char **filev,\n        off_t *mem,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        char flag)\n{\n  __int64 v11; // rbx\n  unsigned int v12; // ebp\n  int v13; // eax\n  __int64 v14; // rdx\n  int v15; // eax\n  off_t v16; // rdx\n  char *v18; // rax\n  __int64 v19; // rdx\n  char *info_text; // rbx\n  size_t v21; // rax\n\n  v11 = *filec;\n  v12 = flag & 1;\n  if ( (flag & 1) != 0 )\n  {\n    *filec = v11 + 1;\n    v13 = strlen(adr) + 1;\n    v14 = v13;\n    v15 = v13 & 7;\n    v16 = *mem + v14 + 8;\n    if ( v15 )\n      v16 = v16 + 8 - v15;\n    *mem = v16;\n    return v12;\n  }\n  if ( count_limit <= (int)v11 )\n  {\n    info_text = a1->info_text;\n    sprintf(a1->info_text, \"Number of matching files changed unexpectedly (> %d)\", count_limit);\n    if ( (flag & 2) != 0 )\n    {\n      Xorriso_msgs_submit(a1, 0, info_text, 0, dword_5000F4, 0);\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      Xorriso_msgs_submit(a1, 0, info_text, 0, &s[445], 0);\n      return flag & 2;\n    }\n  }\n  else\n  {\n    v18 = strdup(adr);\n    v19 = *filec;\n    filev[v11] = v18;\n    if ( !filev[v19] )\n    {\n      v12 = -1;\n      v21 = strlen(adr);\n      Xorriso_no_pattern_memory(a1, v21 + 1, 0, a7, a8, a9, a10);\n      return v12;\n    }\n    *filec = v19 + 1;\n    return 1LL;\n  }\n}\n",
    "source_code": "int Xorriso_register_matched_adr(struct XorrisO *xorriso,\n                                char *adr, int count_limit,\n                                int *filec, char **filev, off_t *mem, int flag)\n{\n int l;\n\n if(flag&1) {\n   (*filec)++;\n   l= strlen(adr)+1;\n   (*mem)+= sizeof(char *)+l;\n   if(l % sizeof(char *))\n     (*mem)+= sizeof(char *)-(l % sizeof(char *));\n } else {\n   if(*filec >= count_limit) {\n     sprintf(xorriso->info_text,\n         \"Number of matching files changed unexpectedly (> %d)\",\n         count_limit);\n     Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0,\n                         (flag&2 ? \"FATAL\" : \"WARNING\"), 0);\n     return(flag&2 ? -1 : 0);\n   }\n   filev[*filec]= strdup(adr);\n   if(filev[*filec]==NULL) {\n     Xorriso_no_pattern_memory(xorriso, (off_t) (strlen(adr)+1), 0);\n     return(-1);\n   }\n   (*filec)++;\n }\n return(1);\n}",
    "comment": "Registers a matched address by updating file count, allocating memory for the address, and handling errors based on a specified flag.",
    "hext5_sum": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
    "bint5_sum": "Formats a given string with appropriate quoting based on the specified flags , updating the position and size of the buffer accordingly .\n",
    "cpbcs_sum": "Retrieves the path of a specified path in an ISO image, populating the buffer with its length based on the provided results.\n",
    "misum_sum": "Processes command-line arguments to extract operations, copying the result into a buffer, and handles memory allocation and updating the accordingly.\n",
    "decom_sum": "Manages adding a matching file name to a list, adjusting storage offsets, and reporting warnings or errors if limits are exceeded.",
    "cfg_sum": "Manages a list of matching file names by duplicating entries, updating counters and memory offsets, and logging warnings or fatal errors when limits are exceeded.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of columns needed to represent the multibyte character string pointed to by string of length nbytes. if a returned. non-printable character occurs, and mbsw_reject_unprintable is",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes functionality about calculating the number of columns for a multibyte character string and handling non-printable characters, which is unrelated to the provided source code. The source code deals with registering matched addresses in `Xorriso_register_matched_adr`, modifying counters, memory usage, and handling errors. None of the summary's claims match or safely generalize the code's behavior, resulting in 0% accurate claims.",
                "The summary describes behavior related to representing multibyte character strings and rejecting unprintable characters, which is completely unrelated to the source code. The source function manages matched addresses, counts, memory usage, and error handling for file names, none of which is reflected in the summary. The primary purpose is missed entirely and no accurate claims are present.",
                "The summary\u2019s claims describe calculating display columns for a multibyte string and rejecting unprintable characters, which are entirely unrelated to the actual source implementation that manages matched addresses, memory size calculations, and error reporting. This is pure NOISE with no accurate alignment to code semantics, resulting in zero useful insight."
            ]
        },
        "bint5": {
            "summary": "Formats a given string with appropriate quoting based on the specified flags , updating the position and size of the buffer accordingly .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function formats a string with quoting based on flags and updates buffer position/size, which does not align with the source code. The actual function registers matched addresses, manipulates counters and memory sizes, handles over-limit cases, duplicates strings, and submits messages. No accurate fact-based claims related to the code implementation are present, making all claims inaccurate.",
                "The summary is entirely inaccurate; it describes formatting a string with quoting based on flags, which does not match the source code's actual behavior. The code registers a matched address string into a list or updates counters/memory usage depending on flags, enforces count limits, handles memory allocation failures, and issues messages. The summary misses the primary purpose and all secondary details such as count_limit checks, message submission on errors, and actual pointer/memory adjustments.",
                "The summary's claim about formatting a string with quoting and updating buffer position/size is completely inaccurate with respect to the source code. The function actually manages matching addresses, increments counters, updates memory usage, checks limits, and handles errors, with no string quoting logic. This is a FATAL error targeting the primary purpose and key side effects, resulting in major negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the path of a specified path in an ISO image, populating the buffer with its length based on the provided results.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes retrieving a path from an ISO image and populating a buffer with its length, which does not match the source code. The function in the source registers matched addresses, updates counters and memory usage, enforces a count limit, and handles memory allocation and error reporting. None of the factual claims in the summary align with this behavior, resulting in no accurate claims.",
                "The summary describes retrieving a path from an ISO image and populating a buffer, which does not align with the source code. The function in the source increments file counters, manages memory size, checks against a count limit, handles fatal/warning messages, duplicates strings, and manages out-of-memory conditions. The summary misses the primary purpose entirely and introduces unrelated behavior, making it inaccurate and providing no verifiable coverage of CSU_LIST.",
                "The summary makes a specific claim about retrieving a path from an ISO image and populating a buffer, which is not represented in the source code. The function instead handles counting and storing matched addresses, memory accounting, and error reporting. This discrepancy directly contradicts the actual primary purpose and key I/O semantics, making it a FATAL error. There are no accurate claims to offset the negative impact."
            ]
        },
        "misum": {
            "summary": "Processes command-line arguments to extract operations, copying the result into a buffer, and handles memory allocation and updating the accordingly.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes command-line arguments to extract operations, which is not evident in the source code. The source deals with matching addresses, managing file counts, storing strings, and updating memory size. While it correctly notes memory allocation and updating, the rest misrepresents the function\u2019s purpose, resulting in most claims being inaccurate.",
                "The summary is inaccurate because it describes processing command-line arguments and copying results into a buffer, which is not reflected in the source code. The actual function registers matched addresses based on a flag, updates counters and memory usage, manages dynamic string duplication, and handles error conditions for exceeding count limits or memory allocation failure. The summary misses the primary purpose entirely and contains unrelated concepts.",
                "The summary claims the function processes command-line arguments to extract operations and copy results into a buffer, which contradicts the actual source code. The code operates on a file list, increments counters, calculates memory requirements, checks against a count limit, duplicates strings, and handles allocation failures. These mismatches are FATAL because they describe an entirely different primary purpose, leading to high negative impact and making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582889680,
    "strip_function_name": "sub_FFFFFFFF813DB6D0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813DB6D0(\n        __int64 a1,\n        unsigned __int16 *a2,\n        int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  unsigned int v11; // r13d\n  int v12; // r12d\n  _BYTE *v13; // r14\n  unsigned int v14; // r15d\n  unsigned int v15; // r12d\n  __int64 result; // rax\n  unsigned int v17; // eax\n  _BYTE *v18; // rdx\n  _BYTE *v19; // [rsp+8h] [rbp-38h]\n  int v20; // [rsp+10h] [rbp-30h]\n  unsigned int v21; // [rsp+14h] [rbp-2Ch]\n\n  v20 = a3 | 0x42000001;\n  v19 = (_BYTE *)*((_QWORD *)a2 + 1);\n  v21 = a2[2];\n  do\n  {\n    v11 = 256;\n    v12 = *(_DWORD *)(a1 + 4624);\n    if ( v21 <= 0x100 )\n      v11 = v21;\n    sub_FFFFFFFF8138EC40((__int64 *)a1, v12 + 20740, v20 | (2 * *a2) | (v11 << 16), a4, a5, a6, a7, a8, a9, a10, a11);\n    if ( v11 )\n    {\n      v13 = v19;\n      v14 = v11;\n      v15 = v12 + 20748;\nLABEL_6:\n      result = sub_FFFFFFFF813DB590((__int64 *)a1, 2048, 1u, a4, a5, a6, a7, a8, a9, a10, a11);\n      if ( (_DWORD)result )\n        return result;\n      v17 = sub_FFFFFFFF8138E6A0(a1, v15);\n      v18 = v13 + 4;\n      while ( 1 )\n      {\n        *v13++ = v17;\n        v17 >>= 8;\n        if ( !--v14 )\n          break;\n        if ( v13 == v18 )\n          goto LABEL_6;\n      }\n    }\n    v19 += v11;\n    v21 -= v11;\n  }\n  while ( v21 );\n  return 0LL;\n}\n",
    "function_name": "gmbus_xfer_read",
    "decompiled_code": "__int64 __fastcall gmbus_xfer_read(\n        __int64 a1,\n        unsigned __int16 *a2,\n        int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  unsigned int v11; // r13d\n  int v12; // r12d\n  _BYTE *v13; // r14\n  unsigned int v14; // r15d\n  unsigned int v15; // r12d\n  __int64 result; // rax\n  unsigned int v17; // eax\n  _BYTE *v18; // rdx\n  _BYTE *v19; // [rsp+8h] [rbp-38h]\n  int v20; // [rsp+10h] [rbp-30h]\n  unsigned int v21; // [rsp+14h] [rbp-2Ch]\n\n  v20 = a3 | 0x42000001;\n  v19 = (_BYTE *)*((_QWORD *)a2 + 1);\n  v21 = a2[2];\n  do\n  {\n    v11 = 256;\n    v12 = *(_DWORD *)(a1 + 4624);\n    if ( v21 <= 0x100 )\n      v11 = v21;\n    i915_write32(\n      (volatile signed __int16 *)a1,\n      v12 + 20740,\n      v20 | (2 * *a2) | (v11 << 16),\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      a11);\n    if ( v11 )\n    {\n      v13 = v19;\n      v14 = v11;\n      v15 = v12 + 20748;\nLABEL_6:\n      result = gmbus_wait_hw_status((__int64 *)a1, 2048, 1u, a4, a5, a6, a7, a8, a9, a10, a11);\n      if ( (_DWORD)result )\n        return result;\n      v17 = i915_read32(a1, v15);\n      v18 = v13 + 4;\n      while ( 1 )\n      {\n        *v13++ = v17;\n        v17 >>= 8;\n        if ( !--v14 )\n          break;\n        if ( v13 == v18 )\n          goto LABEL_6;\n      }\n    }\n    v19 += v11;\n    v21 -= v11;\n  }\n  while ( v21 );\n  return 0LL;\n}\n",
    "source_code": "\nstatic int\ngmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,\n\t\tu32 gmbus1_index)\n{\n\tint reg_offset = dev_priv->gpio_mmio_base;\n\tu16 len = msg->len;\n\tu8 *buf = msg->buf;\n\n\tI915_WRITE(GMBUS1 + reg_offset,\n\t\t   gmbus1_index |\n\t\t   GMBUS_CYCLE_WAIT |\n\t\t   (len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t   GMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\t\tu32 val, loop = 0;\n\n\t\tret = gmbus_wait_hw_status(dev_priv, GMBUS_HW_RDY,\n\t\t\t\t\t   GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = I915_READ(GMBUS3 + reg_offset);\n\t\tdo {\n\t\t\t*buf++ = val & 0xff;\n\t\t\tval >>= 8;\n\t\t} while (--len && ++loop < 4);\n\t}\n\n\treturn 0;\n}",
    "comment": "Reads data from a GMBUS device into a buffer, handling timing and status checks during the transfer process.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Transfers I2C messages by addressing the device , reading or writing bytes , and handling errors during the process .\n",
    "cpbcs_sum": "Writes a Display Information Packet (DIP) to a specified register and updates the control register based on the provided EDID structure.\n",
    "misum_sum": "Writes a DisplayPort infoframe value to the specified hardware register for the Intel graphics device, including I2C bus and channel counts.\n",
    "decom_sum": "Transfers data from a buffer to a hardware device in 256-byte chunks, issuing configuration commands and reading status between write operations.",
    "cfg_sum": "Processes chunks of data from a buffer, writes them to a device register, and iteratively transfers bytes while invoking supporting control and status routines.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer, conversion based on a printf formatting character, and conditional use of hex output based on num_bytes are completely unrelated to the function in the source code. The source performs an I2C read via GMBUS registers without any printf formatting or static buffer logic. All claims are inaccurate, resulting in 0% accurate content.",
                "The summary describes functionality involving formatted value conversion, static buffers, printf formatting characters, and hex display logic, none of which are present in the source code. The actual function performs a GMBUS I2C read operation, writing to hardware registers, waiting for readiness, and reading bytes into a provided buffer. The summary is entirely inaccurate and fails to capture the primary purpose or any secondary implementation details of the source.",
                "The summary makes multiple factual claims about returning a pointer to a static buffer, using printf formatting with a `fmtch` parameter, and conditional hex formatting based on `num_bytes`. None of these concepts, parameters, or behaviors appear in the source code, which deals with reading data via GMBUS registers into a provided buffer. These are all [INACCURATE] NOISE claims unrelated to the actual implementation. Since the majority of claims are noise and there are no accurate insights, the net benefit is zero."
            ]
        },
        "bint5": {
            "summary": "Transfers I2C messages by addressing the device , reading or writing bytes , and handling errors during the process .\n",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function transfers I2C messages, addresses the device, reads/writes bytes, and handles errors. In the source, the function performs a read from an I2C device (via GMBUS), addressing the slave, reading bytes into a buffer, and returning errors from hardware status waits. However, the summary incorrectly includes 'writing bytes,' which is not present in the code, making some claims inaccurate. Most claims are accurate, but the inclusion of an incorrect write operation reduces overall precision.",
                "The summary captures the primary purpose of transferring I2C messages and mentions addressing the device and handling errors, aligning broadly with the function\u2019s role. However, it inaccurately includes 'writing bytes', which is not present in the source code, as the function is read-only. It also omits secondary details such as configuring GMBUS registers, byte count handling, and reading multiple bytes from hardware via loops, which are critical behaviors in the implementation.",
                "The summary claims the function transfers I2C messages, addresses the device, reads or writes bytes, and handles errors. In the source code, the function specifically performs an I2C read transfer via GMBUS, reads bytes into a buffer, and returns errors from hardware status checks. The mention of 'writing bytes' is inaccurate because the implementation only reads data. This is a FATAL error affecting a key I/O description (primary purpose). The rest of the claims are broad and low-detail, offering little positive gain."
            ]
        },
        "cpbcs": {
            "summary": "Writes a Display Information Packet (DIP) to a specified register and updates the control register based on the provided EDID structure.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function writes a Display Information Packet to a register and updates the control register using an EDID structure, but the source code instead performs an I2C read operation via GMBUS, reading bytes from a slave device into a buffer. None of the claims match the code\u2019s semantics, resulting in no accurate statements.",
                "The summary incorrectly states that the function writes a Display Information Packet and updates the control register based on an EDID structure. In reality, the source code reads data from a GMBUS/I2C device into a buffer, using specific register writes and hardware-ready checks. This misidentification misses the primary purpose and all key secondary details of the code, making the claims inaccurate and unrelated to the actual implementation.",
                "The summary contains a FATAL error: it describes writing a Display Information Packet to a register and updating a control register based on an EDID structure, which is unrelated to the source code. The actual implementation reads data from a GMBUS slave device via I2C, not handling DIP or EDID. This contradicts the primary purpose and key I/O of the function, making the description severely misleading."
            ]
        },
        "misum": {
            "summary": "Writes a DisplayPort infoframe value to the specified hardware register for the Intel graphics device, including I2C bus and channel counts.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function writes a DisplayPort infoframe value, which is inaccurate because the source code actually performs an I2C read transfer via the GMBUS interface for an Intel graphics device. There is no handling of DisplayPort infoframes or channel counts; instead, the code uses message length, address, and buffer to read data from hardware registers. None of the claims align with the actual implementation, resulting in no accurate matches.",
                "The summary incorrectly states that the function writes a DisplayPort infoframe value, which contradicts the source code's actual purpose of performing an I2C read transfer via the GMBUS interface. It fails to mention reading data into a buffer, the use of gmbus_wait_hw_status, or handling byte counts and hardware ready flags, missing both the primary purpose and all secondary details.",
                "The summary describes writing a DisplayPort infoframe value, which is unrelated to the source code\u2019s actual function. The code performs an I2C read transfer via GMBUS for an Intel graphics device, reading bytes from hardware and storing them in a buffer. This constitutes a FATAL inaccuracy about the primary purpose, as the claimed operation and data type do not match the implementation at all."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586514432,
    "strip_function_name": "sub_FFFFFFFF81750600",
    "strip_decompiled_code": "_QWORD *__fastcall sub_FFFFFFFF81750600(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // ebx\n  __int64 *i; // r12\n  __int64 *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  _QWORD *result; // rax\n  __int64 v16; // r14\n  __int64 *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v9 = 0;\n  for ( i = *(__int64 **)(a1 + 3280); (__int64 *)(a1 + 3280) != i; i = (__int64 *)*i )\n  {\n    if ( *((_DWORD *)i + 538) == 3 )\n    {\n      v11 = sub_FFFFFFFF815CD4F0((__int64)(i + 187));\n      if ( v11 )\n        sub_FFFFFFFF817319E0((_QWORD *)a1, (volatile signed __int32 *)v11, a2, a3, a4, a5, v12, v13, a8, a9);\n      v9 += *((_DWORD *)i + 378);\n    }\n  }\n  v14 = *(_QWORD **)(a1 + 600);\n  for ( result = (_QWORD *)(a1 + 600); v14 != (_QWORD *)(a1 + 600); v14 = (_QWORD *)*v14 )\n  {\n    v16 = (__int64)(v14 + 33);\n    while ( 1 )\n    {\n      v17 = sub_FFFFFFFF815CD4F0(v16);\n      v9 += *(_DWORD *)(v16 + 16);\n      if ( v17 )\n        break;\n      v16 -= 24LL;\n      if ( v14 + 21 == (_QWORD *)v16 )\n        goto LABEL_12;\n    }\n    sub_FFFFFFFF817319E0((_QWORD *)a1, (volatile signed __int32 *)v17, a2, a3, a4, a5, v18, v19, a8, a9);\nLABEL_12:\n    result = (_QWORD *)*v14;\n  }\n  *(_DWORD *)(a1 + 4032) = v9;\n  return result;\n}\n",
    "function_name": "purge_old_ps_buffers",
    "decompiled_code": "_QWORD *__fastcall purge_old_ps_buffers(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // ebx\n  __int64 *i; // r12\n  __int64 *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  _QWORD *result; // rax\n  __int64 v16; // r14\n  __int64 *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v9 = 0;\n  for ( i = *(__int64 **)(a1 + 3280); (__int64 *)(a1 + 3280) != i; i = (__int64 *)*i )\n  {\n    if ( *((_DWORD *)i + 538) == 3 )\n    {\n      v11 = skb_dequeue((__int64)(i + 187));\n      if ( v11 )\n        ieee80211_free_txskb(\n          (volatile signed __int16 *)a1,\n          (volatile signed __int32 *)v11,\n          a2,\n          a3,\n          a4,\n          a5,\n          v12,\n          v13,\n          a8,\n          a9);\n      v9 += *((_DWORD *)i + 378);\n    }\n  }\n  v14 = *(_QWORD **)(a1 + 600);\n  for ( result = (_QWORD *)(a1 + 600); v14 != (_QWORD *)(a1 + 600); v14 = (_QWORD *)*v14 )\n  {\n    v16 = (__int64)(v14 + 33);\n    while ( 1 )\n    {\n      v17 = skb_dequeue(v16);\n      v9 += *(_DWORD *)(v16 + 16);\n      if ( v17 )\n        break;\n      v16 -= 24LL;\n      if ( v14 + 21 == (_QWORD *)v16 )\n        goto LABEL_12;\n    }\n    ieee80211_free_txskb(\n      (volatile signed __int16 *)a1,\n      (volatile signed __int32 *)v17,\n      a2,\n      a3,\n      a4,\n      a5,\n      v18,\n      v19,\n      a8,\n      a9);\nLABEL_12:\n    result = (_QWORD *)*v14;\n  }\n  *(_DWORD *)(a1 + 4032) = v9;\n  return result;\n}\n",
    "source_code": "static void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}",
    "comment": "Purges old Power Save buffers from access points and stations, freeing memory and updating the total buffered frame count.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Updates the transmission queue for each active sub-interface after a scan completion event in the IEEE 802.11 local structure .\n",
    "cpbcs_sum": "Processes and submits IEEE 802.11 packets for each completed manager associated with a specified duration, managing state and list cleanup.\n",
    "misum_sum": "Cleans up and releases pending bitmap for active network devices, notifying network devices while managing interface state and list states.\n",
    "decom_sum": "Traverses two linked lists of objects, processes those matching criteria, accumulates a specific integer field, and stores the total at offset 4032.",
    "cfg_sum": "Iterates through two linked lists, processes specific entries via helper functions, accumulates a total count, updates a state variable, and returns the final list position.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes generating LEB128 value fragments with sign handling, which is unrelated to the source code\u2019s logic for purging old power-save buffers in a wireless networking context. None of the claims match the source code semantics, resulting in no accurate matches.",
                "The summary describes generating fragments to emit a LEB128 value with sign distinction, which is unrelated to the source code's function. The source code handles purging old power-save buffers in a Wi-Fi driver, iterating over interfaces and stations and freeing queued SKBs. The summary misses the primary purpose and all secondary details, and contains no accurate claims about the implementation.",
                "The summary describes generating fragments to emit a LEB128 value with a sign flag, which is unrelated to the source code's function of purging old power-save buffers in a Wi-Fi context. This is pure NOISE with no accurate alignment to the implementation, providing no insight and high irrelevance."
            ]
        },
        "bint5": {
            "summary": "Updates the transmission queue for each active sub-interface after a scan completion event in the IEEE 802.11 local structure .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function updates the transmission queue for each active sub-interface after a scan completion event, which contradicts the source code. The code actually purges old power-save buffers for AP and mesh interfaces and stations, unrelated to scan completion events or general transmission queue updates. All fact-based claims are inaccurate, resulting in no alignment with the source semantics.",
                "The summary incorrectly describes updating transmission queues after a scan completion, which does not align with the source code's actual purpose of purging old power-save buffers for AP and mesh interfaces and dropping frames from each station's lowest-priority AC buffer. It fails to capture the primary function behavior entirely and introduces unrelated context, making the claim inaccurate.",
                "The summary claims the function updates the transmission queue for each active sub-interface after a scan completion event, which is inaccurate. The source code shows the function purges old power-save buffers across AP and mesh interfaces and for each station, not tied to scan completion. This is a FATAL error affecting the primary purpose description, as it misrepresents the core behavior."
            ]
        },
        "cpbcs": {
            "summary": "Processes and submits IEEE 802.11 packets for each completed manager associated with a specified duration, managing state and list cleanup.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes and submits IEEE 802.11 packets for each completed manager with a specified duration, managing state and list cleanup. These statements do not match the source code, which actually purges old power-save buffers by dequeuing and freeing frames from specific queues for AP and mesh interfaces and from stations, updating counts, and logging. None of the claims in the summary are accurate to the code semantics, resulting in a complete mismatch.",
                "The summary is inaccurate as it describes processing and submitting IEEE 802.11 packets for managers with a duration, which is unrelated to the actual function. The source code's primary purpose is to purge old power-save buffers from AP and mesh interfaces and from stations, update the total buffered count, and log the purge, none of which are mentioned. The summary misses both the main functionality and all secondary details, making it non-aligned.",
                "The summary's main claims about processing and submitting IEEE 802.11 packets for managers over a specified duration are inaccurate; the source code instead purges old power-save buffers for AP and mesh interfaces, removing queued frames from broadcast buffers and per-station queues. These errors target the primary purpose and core I/O semantics, making them fatal. There are no accurate, specific details that match the implementation, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Cleans up and releases pending bitmap for active network devices, notifying network devices while managing interface state and list states.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about cleaning up and releasing a pending bitmap, notifying network devices, and managing interface state are inaccurate relative to the source code. The function actually purges old power-save buffers for AP and mesh interfaces and station lists, freeing sk_buffs and updating totals. No bitmap operations or notification mechanisms are present, and interface state management is not shown. None of the claims align factually with the code.",
                "The summary inaccurately describes the function's behavior, referencing 'pending bitmap' and 'notifying network devices' which do not appear in the source code. It omits the primary purpose of purging old power-save buffers for AP and mesh interfaces and stations, and does not mention key secondary details such as handling different interface types, deallocating sk_buffs, updating total buffer count, or logging purged frame count. No accurate claims map to the actual CSU_LIST, resulting in no coverage.",
                "The summary makes broad, inaccurate claims unrelated to the source code semantics. It describes 'pending bitmap' cleanup, notifying network devices, and managing interface/list states, none of which are in the implementation. The function actually purges buffered power-save frames from AP/mesh interfaces and per-station queues, updates a total count, and logs purged frames. These mismatches are FATAL to the primary purpose, leading to high negative impact and unreliable understanding."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585594224,
    "strip_function_name": "sub_FFFFFFFF8166FB70",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8166FB70(\n        __int64 a1,\n        __int64 a2,\n        __int16 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v14; // eax\n  bool v15; // cc\n  __int64 v16; // r13\n  int v17; // edi\n  volatile signed __int32 *v18; // rsi\n  int v19; // eax\n  char *v20; // rax\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  unsigned __int64 v27; // r15\n  signed int v28; // ebx\n\n  v14 = *(_DWORD *)(a1 + 3208);\n  v15 = *(_WORD *)(a2 + 24) <= 0x1Fu;\n  v16 = *(_QWORD *)(a1 + 16);\n  v17 = 52;\n  v18 = (volatile signed __int32 *)&qword_20;\n  v19 = 8 * v14 + 92;\n  if ( v15 )\n    v17 = v19;\n  v20 = (char *)sub_FFFFFFFF815CF830(v17, 0x20u, 0, 0xFFFFFFFF, a4, a5, a6, a7, a8, a9, a10, a11);\n  v27 = (unsigned __int64)v20;\n  if ( !v20 )\n  {\n    v28 = -105;\n    goto LABEL_5;\n  }\n  v18 = (volatile signed __int32 *)v20;\n  v28 = sub_FFFFFFFF8166FA00(a1, v20, 0, 0, (_DWORD *)a2, a3, 0);\n  if ( v28 < 0 )\n  {\nLABEL_5:\n    sub_FFFFFFFF815CFEE0(v27, v18, v21, v22, v23, v24, a4, a5, a6, a7, v25, v26, a10, a11);\n    return sub_FFFFFFFF815EA860(v16, 6u, v28);\n  }\n  return sub_FFFFFFFF815EA820(v27, v16, 0LL, 6LL, 0LL);\n}\n",
    "function_name": "mroute_netlink_event",
    "decompiled_code": "__int64 __fastcall mroute_netlink_event(\n        __int64 a1,\n        __int64 a2,\n        __int16 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  int v14; // eax\n  bool v15; // cc\n  __int64 v16; // r13\n  int v17; // edi\n  volatile signed __int32 *v18; // rsi\n  int v19; // eax\n  char *v20; // rax\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  volatile signed __int32 *v27; // r15\n  int v28; // ebx\n\n  v14 = *(_DWORD *)(a1 + 3208);\n  v15 = *(_WORD *)(a2 + 24) <= 0x1Fu;\n  v16 = *(_QWORD *)(a1 + 16);\n  v17 = 52;\n  v18 = (volatile signed __int32 *)&qword_20;\n  v19 = 8 * v14 + 92;\n  if ( v15 )\n    v17 = v19;\n  v20 = (char *)_alloc_skb(v17, 0x20u, 0, -1, a4, a5, a6, a7, a8, a9, a10, a11);\n  v27 = (volatile signed __int32 *)v20;\n  if ( !v20 )\n  {\n    v28 = -105;\n    goto LABEL_5;\n  }\n  v18 = (volatile signed __int32 *)v20;\n  v28 = ipmr_fill_mroute(a1, v20, 0, 0, (_DWORD *)a2, a3, a4, a5, a6, a7, v25, v26, a10, a11, 0);\n  if ( v28 < 0 )\n  {\nLABEL_5:\n    kfree_skb(v27, v18, v21, v22, v23, v24, a4, a5, a6, a7, v25, v26, a10, a11);\n    return rtnl_set_sk_err(v16, 6, v28);\n  }\n  return rtnl_notify((unsigned __int64)v27, v16, 0, 6LL, 0LL, 0x20u, a4, a5, a6, a7, v25, v26, a10, a11);\n}\n",
    "source_code": "\nstatic void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,\n\t\t\t\t int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mroute_msgsize(mfc->mfc_parent >= MAXVIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = ipmr_fill_mroute(mrt, skb, 0, 0, mfc, cmd);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE, err);\n}",
    "comment": "Notifies the kernel about multicast route changes by creating and sending a netlink message based on the provided mfc_cache and command.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Processes a netlink message for a routing table lookup and sends the result back to the originating socket .\n",
    "cpbcs_sum": "Sends a netlink message to a specified socket buffer after locking and sending a netlink message to the appropriate network device.\n",
    "misum_sum": "Sends a netlink message to a specified socket buffer using netlink message parameters.\n",
    "decom_sum": "Allocates a parameterized data buffer, initializes it with provided values, and either processes it successfully or frees it and reports an error.",
    "cfg_sum": "Allocates and initializes a data structure with given parameters, processes it using input descriptors, and returns a status code indicating success or failure.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only mathematical notation unrelated to the source code's functionality. It does not reference any facts about the mroute_netlink_event function, its parameters, or operations. All claims are noise relative to the source, resulting in no accurate matches.",
                "The summary contains only a mathematical expression unrelated to the function's purpose or behavior in the source code. It does not identify the primary purpose of handling multicast routing netlink events, nor mention any secondary details such as skb allocation, error handling, or notification mechanisms. As it does not target the code semantics at all, it provides no coverage.",
                "The summary contains only a mathematical expression unrelated to the source code\u2019s multicast routing netlink event handling. There are no fact-based claims about functions, variables, or control flow in the provided code, making all extracted claims NOISE. The worst failure mode is excessive NOISE, with zero alignment to the source\u2019s primary purpose or key side effects."
            ]
        },
        "bint5": {
            "summary": "Processes a netlink message for a routing table lookup and sends the result back to the originating socket .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function processes a netlink message for a routing table lookup and returns the result to the originating socket. In reality, the source code handles multicast routing events by creating and filling a netlink message, notifying listeners via rtnl_notify, and setting socket errors if needed. There is no explicit routing table lookup or direct return to an originating socket, making the main claim inaccurate and unrelated to core code intent. Therefore, the proportion of accurate claims is near zero.",
                "The summary inaccurately describes the function as performing a routing table lookup and returning the result to the originating socket, which contradicts the source code. The actual implementation prepares and sends a multicast routing event via netlink, not a lookup, and includes error handling for buffer allocation and message filling. The summary misses the primary purpose and all secondary details, leading to no coverage of critical semantic units.",
                "The summary incorrectly describes the function as performing a routing table lookup and sending the result to the originating socket, which contradicts the source code. In reality, the code prepares and sends a multicast routing netlink notification, possibly reporting an error via rtnl_set_sk_err, rather than performing a lookup or returning results to an originating socket. This is a FATAL error affecting the primary purpose, leading to high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Sends a netlink message to a specified socket buffer after locking and sending a netlink message to the appropriate network device.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes locking and sending to a specific socket buffer and network device, which are not present in the source code. The actual function allocates a new netlink message buffer, fills it, notifies through rtnl_notify, and handles errors, but no locking or targeting a specific network device occurs. The majority of claims are inaccurate, resulting in low alignment.",
                "The summary incorrectly states that the function locks and sends a netlink message to a specific network device, which is not reflected in the source code. The code creates a netlink message skb, fills it with multicast routing info, notifies listeners via rtnl_notify, and handles errors, but there is no locking behavior and no explicit targeting of a particular network device. This means the primary purpose is misrepresented and several secondary details such as error handling and message size calculation are missed.",
                "The summary contains an inaccurate claim about locking and sending to a specific network device, which is not present in the source code. The actual function allocates a socket buffer, populates it with multicast routing information, and sends it via rtnl_notify with error handling, but no locking or targeting of a particular network device is implemented. This is a FATAL error as it misrepresents the primary purpose and key operations of the function, leading to unreliable understanding. There are no substantial accurate details provided, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Sends a netlink message to a specified socket buffer using netlink message parameters.\n",
            "score": [
                0.1,
                0.3,
                0.2
            ],
            "reason": [
                "The summary makes a single claim about sending a netlink message to a specified socket buffer using netlink message parameters, but the source code describes constructing a netlink message (via nlmsg_new and ipmr_fill_mroute) and notifying via rtnl_notify to multicast routing group subscribers, not to a specific socket buffer. The claim inaccurately describes the target recipient and omits key behaviors, meaning it does not align with the actual semantics. With this single claim being inaccurate, the proportion of accurate claims is 0%.",
                "The summary vaguely describes sending a netlink message but omits key aspects of the code\u2019s primary purpose and behavior. It fails to mention that the function constructs the message using mroute-specific data, checks for allocation errors, fills the message via ipmr_fill_mroute, notifies listeners via rtnl_notify, and handles cleanup and error reporting through kfree_skb and rtnl_set_sk_err. The claim is overly generic and misses critical secondary details, providing minimal coverage of the CSU_LIST.",
                "The summary is inaccurate because it incorrectly describes sending a netlink message to a specified socket buffer, which is not the primary purpose of the function. The source code shows that the function allocates a netlink message, fills it with multicast routing data, and notifies listeners via rtnl_notify, handling errors if allocation or filling fails. The claim is both overly vague and semantically incorrect about key I/O, constituting a FATAL error."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585332144,
    "strip_function_name": "sub_FFFFFFFF8162FBB0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8162FBB0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 result; // rax\n  unsigned __int64 v10; // r13\n  __int64 v11; // r12\n  unsigned int v12; // ebx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // r14d\n  __int64 v16; // rsi\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // [rsp+0h] [rbp-30h]\n\n  result = a1 - 16;\n  v10 = __readgsqword(0xA760u);\n  v22 = a1 - 16;\n  if ( *(_DWORD *)(a1 - 4) )\n  {\n    v11 = a1 - 368;\n    do\n    {\n      v12 = 0;\n      sub_FFFFFFFF81792930(v22);\n      do\n      {\n        while ( 1 )\n        {\n          v15 = 1 << v12;\n          if ( ((1 << v12) & *(_DWORD *)(a1 - 4)) != 0 )\n            break;\n          if ( ++v12 == 8 )\n            goto LABEL_10;\n        }\n        while ( 1 )\n        {\n          v16 = v12;\n          if ( !(unsigned int)sub_FFFFFFFF8162FA30(v11, v12, a2, a3, a4, a5, v13, v14, a8, a9) )\n            break;\n          while ( (*(_QWORD *)(v10 - 8136) & 8) != 0 )\n          {\n            sub_FFFFFFFF81792870(v22);\n            sub_FFFFFFFF81790B80(v22, v16, v17, v18, v19);\n            sub_FFFFFFFF81792930(v22);\n            v16 = v12;\n            if ( !(unsigned int)sub_FFFFFFFF8162FA30(v11, v12, a2, a3, a4, a5, v20, v21, a8, a9) )\n              goto LABEL_9;\n          }\n        }\nLABEL_9:\n        ++v12;\n        *(_DWORD *)(a1 - 4) &= ~v15;\n      }\n      while ( v12 != 8 );\nLABEL_10:\n      sub_FFFFFFFF81792870(v22);\n      result = *(unsigned int *)(a1 - 4);\n    }\n    while ( (_DWORD)result );\n  }\n  return result;\n}\n",
    "function_name": "inet_twdr_twkill_work",
    "decompiled_code": "__int64 __fastcall inet_twdr_twkill_work(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10)\n{\n  __int64 result; // rax\n  unsigned __int64 v11; // r13\n  __int64 v12; // r12\n  unsigned int v13; // ebx\n  __int64 v14; // rdx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rcx\n  int v20; // r14d\n  __int64 v21; // rdx\n  __int64 v22; // rcx\n  __int64 v23; // r8\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  volatile signed __int16 *v26; // [rsp+0h] [rbp-30h]\n\n  result = a1 - 16;\n  v11 = __readgsqword(0xA760u);\n  v26 = (volatile signed __int16 *)(a1 - 16);\n  if ( *(_DWORD *)(a1 - 4) )\n  {\n    v12 = a1 - 368;\n    do\n    {\n      v13 = 0;\n      raw_spin_lock_bh(v26);\n      do\n      {\n        while ( 1 )\n        {\n          v19 = v13;\n          v20 = 1 << v13;\n          if ( ((1 << v13) & *(_DWORD *)(a1 - 4)) != 0 )\n            break;\n          if ( ++v13 == 8 )\n            goto LABEL_10;\n        }\n        while ( 1 )\n        {\n          a10 = v13;\n          if ( !(unsigned int)inet_twdr_do_twkill_work(v12, v13, a2, a3, a4, a5, v17, v18, a8, a9) )\n            break;\n          while ( (*(_QWORD *)(v11 - 8136) & 8) != 0 )\n          {\n            raw_spin_unlock_bh(v26, a10, v14, v19, v15, v16);\n            a2 = schedule(v26, a10, v21, v22, v23);\n            raw_spin_lock_bh(v26);\n            a10 = v13;\n            if ( !(unsigned int)inet_twdr_do_twkill_work(v12, v13, a2, a3, a4, a5, v24, v25, a8, a9) )\n              goto LABEL_9;\n          }\n        }\nLABEL_9:\n        ++v13;\n        *(_DWORD *)(a1 - 4) &= ~v20;\n      }\n      while ( v13 != 8 );\nLABEL_10:\n      raw_spin_unlock_bh(v26, a10, v14, v19, v15, v16);\n      result = *(unsigned int *)(a1 - 4);\n    }\n    while ( (_DWORD)result );\n  }\n  return result;\n}\n",
    "source_code": "\nvoid inet_twdr_twkill_work(struct work_struct *work)\n{\n\tstruct inet_timewait_death_row *twdr =\n\t\tcontainer_of(work, struct inet_timewait_death_row, twkill_work);\n\tint i;\n\n\tBUILD_BUG_ON((INET_TWDR_TWKILL_SLOTS - 1) >\n\t\t\t(sizeof(twdr->thread_slots) * 8));\n\n\twhile (twdr->thread_slots) {\n\t\tspin_lock_bh(&twdr->death_lock);\n\t\tfor (i = 0; i < INET_TWDR_TWKILL_SLOTS; i++) {\n\t\t\tif (!(twdr->thread_slots & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\twhile (inet_twdr_do_twkill_work(twdr, i) != 0) {\n\t\t\t\tif (need_resched()) {\n\t\t\t\t\tspin_unlock_bh(&twdr->death_lock);\n\t\t\t\t\tschedule();\n\t\t\t\t\tspin_lock_bh(&twdr->death_lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttwdr->thread_slots &= ~(1 << i);\n\t\t}\n\t\tspin_unlock_bh(&twdr->death_lock);\n\t}\n}",
    "comment": "Processes and removes active threads from the timewait death row while managing concurrency using spin locks and checking for rescheduling needs.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "The function waits for a socket to finish closing , handling interruptions and timeouts , while ensuring proper synchronization and memory management .\n",
    "cpbcs_sum": "Cleans up and unregisters IPv6 flow control tables for IPv6 addresses, including their IPv4 and IPv4 device information.\n",
    "misum_sum": "Processes socket events by locking and handling Duplicate Address Detection until the callback is received.\n",
    "decom_sum": "Processes active flag bits by invoking handler routines for each set bit until all bits are cleared, coordinating with hardware status and repeated checks.",
    "cfg_sum": "Processes flagged entries in a data structure, invoking computations and I/O routines until all flags are cleared, then returns the final status code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only a vague phrase 'push a pointer type' which does not clearly map to any specific, verifiable action in the source code. It fails to extract atomic fact-based claims relevant to the code\u2019s functionality and provides no accurate representation of the source logic, resulting in no identifiable ACCURATE claims.",
                "The summary makes a vague and unrelated statement about pushing a pointer type, which does not align with the source code\u2019s primary purpose of processing time-wait socket termination work in specific thread slots with locking, scheduling, and clearing operations. It misses the primary purpose entirely and provides no accurate claims tied to the implementation.",
                "The summary 'push a pointer type.' is unrelated to the source code, which implements a work function to process and clear time-wait death row thread slots with locking and scheduling logic. This is pure NOISE with no accurate claims, offering no insight or alignment with the code semantics. The worst failure mode is overwhelming NOISE and zero factual value."
            ]
        },
        "bint5": {
            "summary": "The function waits for a socket to finish closing , handling interruptions and timeouts , while ensuring proper synchronization and memory management .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function waits for a socket to finish closing, manages interruptions, timeouts, and memory, but the source code shows it iterates over timewait slots, performs killing work on sockets, reschedules if needed, and handles synchronization via spin locks. There is no explicit waiting for closure, timeout handling, or memory management, making most claims inaccurate. Only the mention of synchronization matches the code.",
                "The summary is inaccurate because it describes waiting for a socket to close with interruptions and timeouts, which is not reflected in the source code's semantics. The function actually iterates through thread slots, performing time-wait socket cleanup work using locks, scheduling when necessary, and clearing slots \u2014 not generic socket closure waiting or memory management. The primary purpose and key details from the source are missed entirely.",
                "The summary claims the function waits for a socket to finish closing, handles interruptions and timeouts, and manages memory. These are INACCURATE because the source code actually iterates over thread slots to perform time-wait socket cleanup work via inet_twdr_do_twkill_work, with spinlock synchronization and scheduling when needed. It does not explicitly wait for socket closure, handle timeouts, or perform memory management. The inaccuracies target the primary purpose and semantics of the function, constituting FATAL errors and severely misleading the reader."
            ]
        },
        "cpbcs": {
            "summary": "Cleans up and unregisters IPv6 flow control tables for IPv6 addresses, including their IPv4 and IPv4 device information.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims relate to cleaning up and unregistering IPv6 flow control tables and handling IPv4 details, which are entirely unrelated to the source code that manages killing timewait sockets via a workqueue and bitmask-based slot handling. None of the claims match the source implementation, resulting in 0% accurate claims.",
                "The summary claims the function cleans up and unregisters IPv6 flow control tables, referencing IPv6 and IPv4 address management. The source code does not involve IPv6 or IPv4 flow control or table unregistration; instead, it processes time-wait sockets in a death row structure, iterating over thread slots and performing cleanup work. The primary purpose and all secondary details in the source are misrepresented, yielding no accurate claim coverage.",
                "The summary's claim that the function cleans up and unregisters IPv6 flow control tables, along with IPv4 information, is completely unrelated to the source code. The actual code handles time-wait socket cleanup in a death row structure, iterating through thread slots and killing work items. This is a FATAL inaccuracy targeting the primary purpose and semantic meaning of the function, making the description misleading and unusable for understanding the real implementation."
            ]
        },
        "misum": {
            "summary": "Processes socket events by locking and handling Duplicate Address Detection until the callback is received.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about processing socket events and handling Duplicate Address Detection until a callback is received do not match the source code. The source implements time-wait socket cleanup via slot-based iteration, locking, and scheduling, with no reference to Duplicate Address Detection or callbacks. All claims are inaccurate, resulting in no alignment with the source semantics.",
                "The summary is inaccurate as it describes processing socket events related to Duplicate Address Detection and callbacks, which do not align with the source code. The function actually iterates over time-wait slots in a death row structure, performing cleanup work with locking, rescheduling, and bitmask updates. The primary purpose and key secondary details from the source are completely missed, resulting in no factual coverage.",
                "The summary claims the function processes socket events related to Duplicate Address Detection until a callback is received, which is entirely inaccurate. The source code shows it iterates through timewait slots to run cleanup work via inet_twdr_do_twkill_work under locking, with no mention of Duplicate Address Detection or callbacks. This is a FATAL error about the primary purpose, as the summary misidentifies the core functionality."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585723248,
    "strip_function_name": "sub_FFFFFFFF8168F370",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8168F370(\n        __int64 a1,\n        __int64 a2,\n        _DWORD *a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned __int64 v14; // rbx\n  volatile signed __int32 *v15; // r12\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rsi\n  unsigned __int64 v23; // rdx\n  signed __int32 v24; // et0\n  unsigned int v25; // r12d\n  __int64 v27; // rax\n\n  v14 = *(_QWORD *)(a1 + 32);\n  if ( a4 )\n  {\n    v27 = sub_FFFFFFFF8168D550(*(_QWORD *)(a1 + 32));\n    v14 = v27;\n    if ( !v27 )\n      return (unsigned int)-107;\n    v15 = (volatile signed __int32 *)(v27 + 76);\n  }\n  else\n  {\n    v15 = (volatile signed __int32 *)(v14 + 76);\n    _InterlockedIncrement((volatile signed __int32 *)(v14 + 76));\n  }\n  sub_FFFFFFFF81792900(v14 + 728);\n  v22 = *(_QWORD *)(v14 + 632);\n  if ( v22 )\n  {\n    v23 = *(int *)(v22 + 4);\n    v22 += 12LL;\n    *a3 = v23;\n    sub_FFFFFFFF812B9E70(a2, (__int64 *)v22, v23);\n  }\n  else\n  {\n    *(_BYTE *)(a2 + 2) = 0;\n    *(_WORD *)a2 = 1;\n    *a3 = 2;\n  }\n  ++*(_BYTE *)(v14 + 728);\n  v24 = _InterlockedDecrement(v15);\n  v25 = 0;\n  if ( !v24 )\n    sub_FFFFFFFF815CA7D0(v14, (volatile signed __int32 *)v22, v16, v17, v18, v19, a5, a6, a7, a8, v20, v21, a11, a12);\n  return v25;\n}\n",
    "function_name": "unix_getname",
    "decompiled_code": "__int64 __fastcall unix_getname(\n        __int64 a1,\n        __int64 a2,\n        _DWORD *a3,\n        int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  __int64 v14; // rbx\n  volatile signed __int32 *v15; // r12\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rsi\n  unsigned __int64 v23; // rdx\n  signed __int32 v24; // et0\n  unsigned int v25; // r12d\n  __int64 v27; // rax\n\n  v14 = *(_QWORD *)(a1 + 32);\n  if ( a4 )\n  {\n    v27 = unix_peer_get(*(_QWORD *)(a1 + 32));\n    v14 = v27;\n    if ( !v27 )\n      return (unsigned int)-107;\n    v15 = (volatile signed __int32 *)(v27 + 76);\n  }\n  else\n  {\n    v15 = (volatile signed __int32 *)(v14 + 76);\n    _InterlockedIncrement((volatile signed __int32 *)(v14 + 76));\n  }\n  raw_spin_lock((volatile signed __int16 *)(v14 + 728));\n  v22 = *(_QWORD *)(v14 + 632);\n  if ( v22 )\n  {\n    v23 = *(int *)(v22 + 4);\n    v22 += 12LL;\n    *a3 = v23;\n    memcpy(a2, (__int64 *)v22, v23);\n  }\n  else\n  {\n    *(_BYTE *)(a2 + 2) = 0;\n    *(_WORD *)a2 = 1;\n    *a3 = 2;\n  }\n  ++*(_BYTE *)(v14 + 728);\n  v24 = _InterlockedDecrement(v15);\n  v25 = 0;\n  if ( !v24 )\n    sk_free(\n      v14,\n      (void (__fastcall *)(__int64, __int64, __int64 *, __int64, int, int, double, double, double, double, double, double, double, double))v22,\n      v16,\n      v17,\n      v18,\n      v19,\n      a5,\n      a6,\n      a7,\n      a8,\n      v20,\n      v21,\n      a11,\n      a12);\n  return v25;\n}\n",
    "source_code": "\n\nstatic int unix_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u;\n\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, uaddr);\n\tint err = 0;\n\n\tif (peer) {\n\t\tsk = unix_peer_get(sk);\n\n\t\terr = -ENOTCONN;\n\t\tif (!sk)\n\t\t\tgoto out;\n\t\terr = 0;\n\t} else {\n\t\tsock_hold(sk);\n\t}\n\n\tu = unix_sk(sk);\n\tunix_state_lock(sk);\n\tif (!u->addr) {\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tsunaddr->sun_path[0] = 0;\n\t\t*uaddr_len = sizeof(short);\n\t} else {\n\t\tstruct unix_address *addr = u->addr;\n\n\t\t*uaddr_len = addr->len;\n\t\tmemcpy(sunaddr, addr->name, *uaddr_len);\n\t}\n\tunix_state_unlock(sk);\n\tsock_put(sk);\nout:\n\treturn err;\n}",
    "comment": "Retrieves the Unix socket's address or initializes it as empty if not connected, handling peer connections appropriately.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Retrieves an xfrm_state for a given xfrm_usersa_id and sends an associated asynchronous event message through a netlink socket .\n",
    "cpbcs_sum": "Reads a string from the user, copies it to the user buffer, and updates the buffer if the buffer is successful.\n",
    "misum_sum": "Retrieves a message from a socket's socket, populating it with its associated state and notifies the user, and address.\n",
    "decom_sum": "Initializes or updates a device context, retrieves and copies its configuration into `a2`, and manages reference counting with cleanup when no users remain.",
    "cfg_sum": "Manages a shared resource with atomic reference counting, retrieves or initializes related data, triggers processing routines, and returns success or error status.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains only a mathematical expression unrelated to the source code's functionality, offering no fact-based claims about the socket handling or address retrieval implemented. All extracted claims are noise, resulting in no accurate alignment with the source.",
                "The summary consists of a mathematical expression unrelated to the source code, which describes a function for retrieving a UNIX socket address. It does not capture the primary purpose, inputs, outputs, or any secondary implementation details of the function. The claim is entirely off-topic and fails to align with the required evaluation steps.",
                "The summary contains only unrelated mathematical notation and makes no fact-based claims about the source code\u2019s structure, purpose, or behavior. All claims are NOISE, overwhelming the output with zero relevant insight. There are no ACCURATE claims, and the worst failure mode is excessive NOISE."
            ]
        },
        "bint5": {
            "summary": "Retrieves an xfrm_state for a given xfrm_usersa_id and sends an associated asynchronous event message through a netlink socket .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes retrieving an xfrm_state and sending an asynchronous event via netlink, which is unrelated to the source code. The source function handles retrieving a UNIX socket address, managing locking, and filling a sockaddr structure. None of the claims in the summary match the implementation, making all claims inaccurate.",
                "The summary describes retrieving an xfrm_state and sending an asynchronous netlink event, which is unrelated to the actual function. The source code implements unix_getname, which obtains a UNIX socket address, handles peer lookup, locks state, sets address fields, and returns errors for unconnected sockets. The summary misses the primary purpose entirely and contains only inaccurate claims.",
                "The summary claims the function retrieves an xfrm_state for a given xfrm_usersa_id and sends an asynchronous event via netlink, which is entirely unrelated to the provided source code. The source implements unix_getname for UNIX sockets, handling peer connections, address retrieval, and copying sockaddr_un data. This is a FATAL error targeting the primary purpose, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Reads a string from the user, copies it to the user buffer, and updates the buffer if the buffer is successful.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function reads a string from the user, copies it to the user buffer, and updates it upon success. In reality, the source code retrieves a Unix socket address (possibly from a peer), locks the state, checks for the presence of an address, and copies relevant address data into a provided sockaddr structure. The summarized description focuses on generic user string reading and buffering, which is unrelated to the actual socket address handling, making all claims inaccurate.",
                "The summary is inaccurate because it describes reading a string from the user and updating a buffer, which does not match the source code's actual purpose of retrieving a UNIX socket address (either peer or local), handling null addresses, locking/unlocking state, and managing socket references. It entirely misses the PRIMARY PURPOSE and all key secondary details present in the implementation.",
                "The summary's claims describe reading a string from the user and copying it to the user buffer, which is unrelated to the source code's purpose of retrieving a UNIX socket's address (local or peer) into a sockaddr_un structure and setting its length. All claims are NOISE as they don't target actual code semantics, resulting in no accurate insight and high irrelevance."
            ]
        },
        "misum": {
            "summary": "Retrieves a message from a socket's socket, populating it with its associated state and notifies the user, and address.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim that the function retrieves a message from a socket and notifies the user is inaccurate, as the source code shows it retrieves the socket's address information and populates the sockaddr structure, not messages. The mention of 'associated state' and 'address' partially aligns with the code, but the majority of the description misrepresents the core semantics, resulting in less than half of the claims being accurate.",
                "The summary inaccurately describes the function\u2019s behavior, claiming it retrieves a message and notifies the user, which is not reflected in the source. The source function retrieves a UNIX socket's address (local or peer), handles connection checks, sets address fields accordingly, and returns an error code if not connected. It entirely misses the primary purpose and key details such as handling of peer parameter, locking, address structure population, and error handling.",
                "The summary's main claim about retrieving a message and notifying the user is inaccurate, as the source code does not handle messages or user notifications\u2014it retrieves and populates a sockaddr structure with address details from a UNIX socket. This is a FATAL error affecting the primary purpose, which is address retrieval. There are no accurate claims matching the source implementation, leading to high negative impact and zero net benefit."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 303360,
    "strip_function_name": "sub_4A100",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_4A100(__int64 *a1, __int64 *a2)\n{\n  __int64 v3; // rbp\n  __int64 v4; // rax\n  __int64 v5; // rdi\n  __int64 v7; // r13\n  __int64 v8; // rsi\n  const void *v9; // rsi\n  __int64 v10; // rdx\n  __int64 v11; // rax\n  __m128i *v12; // rax\n  _QWORD *v13; // rsi\n  __int64 v15; // [rsp+0h] [rbp-78h] BYREF\n  _BYTE *v16; // [rsp+8h] [rbp-70h]\n  __int128 v17; // [rsp+10h] [rbp-68h]\n  __int128 v18; // [rsp+20h] [rbp-58h]\n  __int128 v19; // [rsp+30h] [rbp-48h]\n  __int64 v20; // [rsp+40h] [rbp-38h]\n  unsigned __int64 v21; // [rsp+48h] [rbp-30h]\n\n  v3 = *a1;\n  v21 = __readfsqword(0x28u);\n  v4 = a1[64];\n  v5 = *a2;\n  if ( v4 )\n  {\n    v7 = *(_QWORD *)(v4 + 8) + 32LL * *(__int16 *)(v4 + 66) - 32;\n    if ( (unsigned int)sub_27C40(v5, *(_BYTE *)(v3 + 169) + 4, 0) )\n    {\n      v8 = *(_QWORD *)(v7 + 8);\n      if ( v8 )\n        sub_2FF20(v3, v8);\n      v9 = (const void *)a2[1];\n      v10 = a2[2];\n      v20 = 0LL;\n      v15 = 161LL;\n      v17 = 0LL;\n      v18 = 0LL;\n      v19 = 0LL;\n      v16 = sub_220B0(v3, v9, (int)v10 - (int)v9);\n      v11 = *a2;\n      HIDWORD(v15) = 4096;\n      *(_QWORD *)&v17 = v11;\n      v12 = sub_2F030(v3, (__int64)&v15, 1u, 0LL);\n      v13 = v16;\n      *(_QWORD *)(v7 + 8) = v12;\n      sub_21060(v3, v13);\n      v5 = *a2;\n    }\n    else\n    {\n      sub_46EC0((__int64)a1, \"default value of column [%s] is not constant\", *(const char **)v7);\n      v5 = *a2;\n    }\n  }\n  if ( v5 )\n    sub_2FF20(v3, v5);\n  return __readfsqword(0x28u) ^ v21;\n}\n",
    "function_name": "sqlite3AddDefaultValue",
    "decompiled_code": "void __fastcall sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan)\n{\n  sqlite3 *db; // rbp\n  Table *pNewTable; // rax\n  Expr *pExpr; // rdi\n  __int64 v7; // r13\n  Expr *v8; // rsi\n  const char *zStart; // rsi\n  const char *zEnd; // rdx\n  Expr *v11; // rax\n  Expr *v12; // rax\n  char *zToken; // rsi\n  Expr x; // [rsp+0h] [rbp-78h] BYREF\n  unsigned __int64 v15; // [rsp+48h] [rbp-30h]\n\n  db = pParse->db;\n  v15 = __readfsqword(0x28u);\n  pNewTable = pParse->pNewTable;\n  pExpr = pSpan->pExpr;\n  if ( pNewTable )\n  {\n    v7 = (__int64)&pNewTable->aCol[pNewTable->nCol - 1];\n    if ( exprIsConst(pExpr, db->init.busy + 4, 0) )\n    {\n      v8 = *(Expr **)(v7 + 8);\n      if ( v8 )\n        sqlite3ExprDeleteNN(db, v8);\n      zStart = pSpan->zStart;\n      zEnd = pSpan->zEnd;\n      *(_QWORD *)&x.op = 161LL;\n      memset(&x.pLeft, 0, 56);\n      x.u.zToken = sqlite3DbStrNDup(db, zStart, (int)zEnd - (int)zStart);\n      v11 = pSpan->pExpr;\n      x.flags = 4096;\n      x.pLeft = v11;\n      v12 = exprDup(db, &x, 1, 0LL);\n      zToken = x.u.zToken;\n      *(_QWORD *)(v7 + 8) = v12;\n      sqlite3DbFree(db, zToken);\n      pExpr = pSpan->pExpr;\n    }\n    else\n    {\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\", *(const char **)v7);\n      pExpr = pSpan->pExpr;\n    }\n  }\n  if ( pExpr )\n    sqlite3ExprDeleteNN(db, pExpr);\n}\n",
    "source_code": "void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory. The 'span' of the expression\n      ** is required by pragma table_info.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                    (int)(pSpan->zEnd - pSpan->zStart));\n      x.pLeft = pSpan->pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  sqlite3ExprDelete(db, pSpan->pExpr);\n}",
    "comment": "Validates and sets a default value for the last column of a new table, ensuring it is a constant expression before storing it.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Parses a mangled D language identifier , extracting specific names and properties based on symbol kind , length , and predefined patterns .\n",
    "cpbcs_sum": "Finalizes SQLite statements by retrieving their values, checking for active connections and creating a new object for statement use.\n",
    "misum_sum": "Finalizes the logarithm of a CREATE VIRTUAL TABLE by calculating the corresponding register and symbol table size.\n",
    "decom_sum": "Initializes or replaces a database column\u2019s constant default value, validating it and updating related memory structures before final cleanup.",
    "cfg_sum": "Validates a column\u2019s default value as constant, replaces it with computed data if valid, otherwise reports an error, ensuring stack integrity throughout.",
    "work_score": {
        "hext5": {
            "summary": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes generating and shuffling random wipe passes, which is unrelated to the source code's function of adding a default value to a table column in SQLite. None of the claims in the summary match or reflect the source code's semantics, resulting in 0% accurate claims.",
                "The summary describes generating a random wiping pass pattern with selection and shuffling, which is entirely unrelated to the source code's purpose of adding a default column value to a new table in SQLite with constant checks and memory handling. It misses the primary purpose and all secondary details, making all claims inaccurate.",
                "The summary describes generating a random wiping pass pattern with a selection and shuffle stage, which is entirely unrelated to the source code that handles adding a default value to a column in an SQLite table. All claims are NOISE and contradictory to the actual primary purpose of the code, indicating zero alignment with key I/O or side effects. The worst failure mode is overwhelming NOISE, leading to no useful insight."
            ]
        },
        "bint5": {
            "summary": "Parses a mangled D language identifier , extracting specific names and properties based on symbol kind , length , and predefined patterns .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes parsing a mangled D language identifier, which is entirely unrelated to the source code. The source code handles adding a default value to a column in an SQLite table, including validation for constant expressions and copying expression spans. None of the claims in the summary align with the actual implementation logic, resulting in no accurate fact-based claims.",
                "The summary describes parsing a D language identifier with symbol kind and pattern extraction, which is entirely unrelated to the source code's actual purpose of adding a default value to the most recently added column in a new SQLite table definition, validating that it's a constant or function, and handling memory management. It misses the primary purpose and all secondary implementation details, making it inaccurate and providing no relevant coverage.",
                "The summary claims the function parses a mangled D language identifier, which is completely unrelated to the source code. The actual code handles adding a default value to the last column of a new SQLite table, validating it as a constant, and duplicating its expression span. This mismatch is a FATAL error targeting the primary purpose, severely reducing reliability."
            ]
        },
        "cpbcs": {
            "summary": "Finalizes SQLite statements by retrieving their values, checking for active connections and creating a new object for statement use.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about finalizing SQLite statements, retrieving values, checking for active connections, and creating a new object for statement use are not reflected in the source code. The code actually adds a default value to the last column of a new table, validates that it's constant or a function, and duplicates the expression. None of the summary's claims are accurate, resulting in 0% alignment.",
                "The summary is entirely inaccurate: it describes finalizing SQLite statements, retrieving values, checking connections, and creating new statement objects, none of which match the source code's primary purpose or behavior. The actual function adds a default value to the last column of a new table, validates that it is constant or a function, handles errors for invalid defaults, and duplicates the expression. The primary purpose is missed, and no secondary details are covered.",
                "The summary claims the function finalizes SQLite statements, retrieves values, checks for active connections, and creates a new object for statement use. None of these actions align with the source code, which actually sets a default column value with validation and memory handling in a table definition. These are all inaccurate and constitute NOISE that overwhelms any accurate content, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Finalizes the logarithm of a CREATE VIRTUAL TABLE by calculating the corresponding register and symbol table size.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function finalizes the logarithm of a CREATE VIRTUAL TABLE and calculates register and symbol table size, which is entirely unrelated to the source code. The actual function adds a default value to the last column of a newly created table, with checks for constant expressions and memory handling. All claims in the summary are inaccurate, resulting in no alignment with the source semantics.",
                "The summary incorrectly describes the function as finalizing the logarithm of a CREATE VIRTUAL TABLE, which is unrelated to the actual implementation. The source code shows the function adds a default value to the most recently added column in a new table, with checks for constant expressions and appropriate memory management. The summary misses the primary purpose and all key secondary details, and its claims are entirely inaccurate.",
                "The summary claims the function finalizes the creation of a virtual table by calculating register and symbol table size, which is entirely unrelated to the source code. The source code instead adds a default value to the most recently added column in a new table, performing validation and memory handling. This is a FATAL error affecting the primary purpose, resulting in high negative impact and no accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585524640,
    "strip_function_name": "sub_FFFFFFFF8165EBA0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8165EBA0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  int v10; // eax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  char v14; // al\n  __int64 v15; // r13\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  v9 = *(_QWORD *)a1;\n  if ( !*(_BYTE *)(a1 + 149) )\n  {\n    *(_BYTE *)(a1 + 149) = 1;\n    v15 = *(_QWORD *)v9;\n    if ( !(unsigned int)sub_FFFFFFFF81656380(*(_DWORD *)(a1 + 8), v18, *(_QWORD *)v9, 0) )\n      sub_FFFFFFFF815E3EF0(v15, v18, a2, a3, a4, a5, v16, v17, a8, a9);\n  }\n  if ( *(_DWORD *)(a1 + 8) != 16777440 && !*(_DWORD *)(v9 + 12) )\n  {\n    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 1000LL) + 552LL) + 72LL);\n    if ( v10 == 1\n      || (v11 = *(_DWORD *)(v9 + 320), v11 == 1)\n      || (v12 = *(_QWORD *)(v9 + 48)) != 0 && qword_FFFFFFFF81CC2000 - v12 < 0\n      || v11 == 2\n      || v10 == 2\n      || (v13 = *(_QWORD *)(v9 + 56)) != 0 && qword_FFFFFFFF81CC2000 - v13 < 0 )\n    {\n      sub_FFFFFFFF81792930(a1 + 144);\n      sub_FFFFFFFF8165E890(a1, 1u);\n      sub_FFFFFFFF81792870(a1 + 144);\n    }\n    else\n    {\n      v14 = *(_BYTE *)(v9 + 72);\n      if ( !v14 )\n        v14 = 2;\n      *(_BYTE *)(a1 + 151) = v14;\n      sub_FFFFFFFF8165E920(v9);\n    }\n  }\n}\n",
    "function_name": "igmp_group_added",
    "decompiled_code": "void __fastcall igmp_group_added(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  int v10; // eax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 v13; // rax\n  char v14; // al\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  __int64 v19; // r13\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  v9 = *(_QWORD *)a1;\n  if ( !*(_BYTE *)(a1 + 149) )\n  {\n    *(_BYTE *)(a1 + 149) = 1;\n    v19 = *(_QWORD *)v9;\n    if ( !(unsigned int)arp_mc_map(*(_DWORD *)(a1 + 8), v22, *(_QWORD *)v9, 0) )\n      dev_mc_add(v19, v22, a2, a3, a4, a5, v20, v21, a8, a9);\n  }\n  if ( *(_DWORD *)(a1 + 8) != 16777440 && !*(_DWORD *)(v9 + 12) )\n  {\n    v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 1000LL) + 552LL) + 72LL);\n    if ( v10 == 1\n      || (v11 = *(_DWORD *)(v9 + 320), v11 == 1)\n      || (v12 = *(_QWORD *)(v9 + 48)) != 0 && _vvar_beginning_hack - v12 < 0\n      || v11 == 2\n      || v10 == 2\n      || (v13 = *(_QWORD *)(v9 + 56)) != 0 && _vvar_beginning_hack - v13 < 0 )\n    {\n      raw_spin_lock_bh((volatile signed __int16 *)(a1 + 144));\n      igmp_start_timer(a1, 1u);\n      raw_spin_unlock_bh((_BYTE *)(a1 + 144), 1LL, v15, v16, v17, v18);\n    }\n    else\n    {\n      v14 = *(_BYTE *)(v9 + 72);\n      if ( !v14 )\n        v14 = 2;\n      *(_BYTE *)(a1 + 151) = v14;\n      igmp_ifc_event(v9);\n    }\n  }\n}\n",
    "source_code": "\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}",
    "comment": "The function processes the addition of an IGMP multicast group, initializing it and managing timers based on the interface's multicast version and state.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sends an IGMP report message to the multicast group and handles potential IGMP errors or cleanup based on the message type .\n",
    "cpbcs_sum": "Handles the removal of a multicast group, updating the interface state and sending an IGMP leave message if applicable.\n",
    "misum_sum": "Handles the expiration of a multicast group, updating the interface state and sending an IGMP leave message if necessary.\n",
    "decom_sum": "Initializes an object if not already done, then updates its state or triggers related handlers based on specific status flags and timing conditions.",
    "cfg_sum": "Initializes an object if not already done, then updates or triggers handlers based on specific state flags and time-based validity checks.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary 'push a pointer type' is vague and unrelated to the source code\u2019s actual logic involving IGMP group addition, filter updates, timer setup, and multicast event handling. It does not accurately describe any specific operation from the implementation, resulting in no ACCURATE claims.",
                "The summary 'push a pointer type' is vague, does not describe the primary purpose or behavior of the function, and fails to address any critical semantic units from the source code such as IGMP group addition, conditional checks, or timer initialization. It does not align with the implementation details in the source code.",
                "The summary 'push a pointer type.' is vague, unrelated to the source code, and does not describe any actual behavior or semantics of the function. This is pure NOISE with no accurate claims, offering zero insight. The worst failure mode is NOISE, as it overwhelms content with a meaningless statement."
            ]
        },
        "bint5": {
            "summary": "Sends an IGMP report message to the multicast group and handles potential IGMP errors or cleanup based on the message type .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function sends an IGMP report message and handles potential IGMP errors or cleanup based on the message type. The source code does start an IGMP timer for report sending, which loosely relates to sending a report, but there is no actual sending logic or explicit error/cleanup handling as described. The main operations involve setting a loaded flag, adding a multicast filter, returning early for certain conditions, and triggering events, not handling IGMP errors or performing cleanup. As a result, most claims are inaccurate.",
                "The summary incorrectly states that the function sends an IGMP report message and handles errors or cleanup, which contradicts the source code. The source code conditionally starts an IGMP report timer for certain IGMP versions, adds group filters, and avoids action for specific addresses or dead interfaces, but does not explicitly send a report or perform error cleanup. This misses the primary purpose and secondary details of the function.",
                "The summary claims the function sends an IGMP report message and handles potential IGMP errors or cleanup based on message type. The source code does not explicitly send a report; it starts a timer for IGMP versions 1/2 and triggers iface events for v3, which may lead to report sending later but is not direct. Also, there is no handling of IGMP errors or cleanup operations in the code. These are FATAL inaccuracies about the primary purpose, which is managing multicast group join state and initiating IGMP timers. No accurate, high-value claims are present, resulting in high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Handles the removal of a multicast group, updating the interface state and sending an IGMP leave message if applicable.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function handles the removal of a multicast group and sends an IGMP leave message, but the source code actually deals with adding a multicast group, updating the state when 'im->loaded' is zero, and starting IGMP report timers depending on protocol version. None of the claims in the summary match the source's semantics, resulting in all claims being inaccurate.",
                "The summary incorrectly describes the function as handling the removal of a multicast group and sending an IGMP leave message, whereas the source code shows it adds a multicast group, updates `loaded`, modifies the multicast filter, and potentially starts IGMP timers and events. This is a direct contradiction of the primary purpose and behavior, resulting in no accurate claims and zero coverage of critical semantic units.",
                "The summary claims the function handles removal of a multicast group and sends an IGMP leave message, which directly contradicts the source code. The implementation clearly handles adding a multicast group, marking it as loaded, updating the filter, and initiating IGMP report timers. This is a FATAL inaccuracy affecting the primary purpose, leaving no accurate claims to provide benefit."
            ]
        },
        "misum": {
            "summary": "Handles the expiration of a multicast group, updating the interface state and sending an IGMP leave message if necessary.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function handles multicast group expiration, updates interface state, and sends an IGMP leave message if necessary. However, the source code shows logic for adding a multicast group, initializing filters, and triggering IGMP reports, with no expiration handling or leave message sending. All claims contradict the actual code behavior, resulting in no accurate matches.",
                "The summary incorrectly describes the function as handling the expiration of a multicast group and sending a leave message, which contradicts the source code. The actual code processes the addition of a multicast group, updates the loaded flag, applies a filter, and initiates IGMP report timers/events based on conditions. This misses the primary purpose entirely and introduces inaccurate behavior not present in the source.",
                "The summary claims the function handles expiration of a multicast group and sends an IGMP leave message, which directly contradicts the source code. The code instead adds a multicast group, updates flags, and starts IGMP report timers, with no expiration or leave message logic. This is a FATAL inaccuracy concerning the primary purpose and core behavior, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580470048,
    "strip_function_name": "sub_FFFFFFFF8118CB20",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8118CB20(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // r12d\n  _UNKNOWN **v5; // rbx\n  _QWORD *v6; // rax\n  __int64 v7; // rdx\n  _QWORD *v8; // rax\n  _QWORD *v9; // rdx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rdx\n\n  if ( (unsigned int)*(_QWORD *)(a2 + 8) )\n  {\n    v4 = *(_QWORD *)(a2 + 8);\n    sub_FFFFFFFF81792900(&byte_FFFFFFFF81C04540);\n    v5 = off_FFFFFFFF81C40D78[0];\n    do\n    {\n      if ( v5 == &off_FFFFFFFF81C40D70 )\n        break;\n      v6 = *(v5 - 3);\n      if ( v6 )\n      {\n        v7 = (__int64)*(v5 - 4);\n        *v6 = v7;\n        if ( v7 )\n          *(_QWORD *)(v7 + 8) = v6;\n        *(v5 - 4) = 0LL;\n        *(v5 - 3) = 0LL;\n      }\n      v8 = *v5;\n      if ( v5 != (_UNKNOWN **)*v5 )\n      {\n        v9 = v5[1];\n        v8[1] = v9;\n        *v9 = v8;\n        *v5 = v5;\n        v10 = (unsigned int)dword_FFFFFFFF81CB8B04;\n        v5[1] = v5;\n        sub_FFFFFFFF812C76B0(&unk_FFFFFFFF81E93670, -1LL, v10);\n      }\n      sub_FFFFFFFF812C76B0(&unk_FFFFFFFF81E93648, -1LL, (unsigned int)dword_FFFFFFFF81CB8B04);\n      v11 = *(v5 - 1);\n      v12 = (__int64)*(v5 - 2);\n      *(_QWORD *)(v12 + 8) = v11;\n      *v11 = v12;\n      *(v5 - 2) = (_UNKNOWN *)0xDEAD000000000100LL;\n      *(v5 - 1) = (_UNKNOWN *)0xDEAD000000000200LL;\n      (*(void (__fastcall **)(_UNKNOWN **))(*((_QWORD *)v5[13] + 7) + 16LL))(v5 - 4);\n      --v4;\n      v5 = off_FFFFFFFF81C40D78[0];\n    }\n    while ( v4 );\n    ++byte_FFFFFFFF81C04540;\n  }\n  v2 = qword_FFFFFFFF81E93678;\n  if ( qword_FFFFFFFF81E93678 < 0 )\n    v2 = 0;\n  return v2 / 0x64 * dword_FFFFFFFF81CB88E0;\n}\n",
    "function_name": "shrink_dqcache_memory",
    "decompiled_code": "__int64 __fastcall shrink_dqcache_memory(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // r12d\n  _UNKNOWN **v5; // rbx\n  _QWORD *v6; // rax\n  __int64 v7; // rdx\n  _QWORD *v8; // rax\n  _QWORD *v9; // rdx\n  _QWORD *v10; // rax\n  __int64 v11; // rdx\n\n  if ( (unsigned int)*(_QWORD *)(a2 + 8) )\n  {\n    v4 = *(_QWORD *)(a2 + 8);\n    raw_spin_lock((volatile signed __int16 *)&dq_list_lock);\n    v5 = off_FFFFFFFF81C40D78[0];\n    do\n    {\n      if ( v5 == &free_dquots )\n        break;\n      v6 = *(v5 - 3);\n      if ( v6 )\n      {\n        v7 = (__int64)*(v5 - 4);\n        *v6 = v7;\n        if ( v7 )\n          *(_QWORD *)(v7 + 8) = v6;\n        *(v5 - 4) = 0LL;\n        *(v5 - 3) = 0LL;\n      }\n      v8 = *v5;\n      if ( v5 != (_UNKNOWN **)*v5 )\n      {\n        v9 = v5[1];\n        v8[1] = v9;\n        *v9 = v8;\n        *v5 = v5;\n        LODWORD(v9) = percpu_counter_batch;\n        v5[1] = v5;\n        _percpu_counter_add((__int64)&unk_FFFFFFFF81E93670, -1LL, (int)v9);\n      }\n      _percpu_counter_add((__int64)&unk_FFFFFFFF81E93648, -1LL, percpu_counter_batch);\n      v10 = *(v5 - 1);\n      v11 = (__int64)*(v5 - 2);\n      *(_QWORD *)(v11 + 8) = v10;\n      *v10 = v11;\n      *(v5 - 2) = (_UNKNOWN *)0xDEAD000000000100LL;\n      *(v5 - 1) = (_UNKNOWN *)0xDEAD000000000200LL;\n      (*(void (__fastcall **)(_UNKNOWN **))(*((_QWORD *)v5[13] + 7) + 16LL))(v5 - 4);\n      --v4;\n      v5 = off_FFFFFFFF81C40D78[0];\n    }\n    while ( v4 );\n    ++dq_list_lock;\n  }\n  v2 = qword_FFFFFFFF81E93678;\n  if ( qword_FFFFFFFF81E93678 < 0 )\n    v2 = 0;\n  return v2 / 0x64 * sysctl_vfs_cache_pressure;\n}\n",
    "source_code": "static int shrink_dqcache_memory(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tint nr = sc->nr_to_scan;\n\n\tif (nr) {\n\t\tspin_lock(&dq_list_lock);\n\t\tprune_dqcache(nr);\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\treturn ((unsigned)\n\t\tpercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS])\n\t\t/100) * sysctl_vfs_cache_pressure;\n}",
    "comment": "Releases disk quota cache memory by pruning unused entries based on the specified number of entries to scan and adjusts the cache pressure accordingly.",
    "hext5_sum": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
    "bint5_sum": "Transfers disk quotas from the current inode 's user and group to new user and group IDs specified in the inode 's attributes .\n",
    "cpbcs_sum": "Removes a dentry from the hash table if it is not empty, ensuring thread safety with mutexes and RCU synchronization.\n",
    "misum_sum": "The function removes a virtual memory area from a hash table and frees the associated memory management structure if available.\n",
    "decom_sum": "Clears and unlinks all active objects from a global list, invokes their cleanup callbacks, then returns a scaled value from qword_FFFFFFFF81E93678.",
    "cfg_sum": "Processes and removes entries from a global linked list, updates related counters and flags, then returns a scaled metric based on a global value.",
    "work_score": {
        "hext5": {
            "summary": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about relocations, ELF linking, and constructor/destructor table building are unrelated to the provided source code, which implements a function to shrink a dqcache and return a calculated value. None of the claims match the source code's functionality, making them inaccurate and irrelevant.",
                "The summary describes linker behavior and relocation handling for ELF files, which is completely unrelated to the source code\u2019s actual purpose of shrinking a dqcache by pruning entries and returning a calculated value based on free dquots and cache pressure. It misses the primary purpose and all secondary details from the function, making all claims inaccurate.",
                "The summary is entirely unrelated to the source code, which implements a memory shrinker for dquot cache. All claims in the summary describe ELF linking and relocations, which contradict the source's purpose, I/O, and side effects. This constitutes a FATAL error impacting the primary purpose, making the content unreliable."
            ]
        },
        "bint5": {
            "summary": "Transfers disk quotas from the current inode 's user and group to new user and group IDs specified in the inode 's attributes .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function transfers disk quotas between users and groups based on inode attributes, which is not reflected in the source code. The actual implementation deals with shrinking a disk quota cache by pruning entries and returning a computed value based on free quotas and cache pressure. None of the claims in the summary match the semantics or behavior of the code, resulting in no accurate claims.",
                "The summary describes transferring disk quotas between user and group IDs, which is unrelated to the source code\u2019s actual behavior. The function in the source manages shrinking the disk quota cache by pruning entries and returning a computed value based on free quota counts and cache pressure. The summary misses the primary purpose and all secondary details, making it a completely inaccurate representation.",
                "The summary claims the function transfers disk quotas between users/groups based on inode attributes, which directly contradicts the source code. The actual implementation locks a quota list, prunes cached disk quota structures, and returns a calculated value based on free quotas and cache pressure. This is a FATAL error affecting the primary purpose, making the summary highly unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Removes a dentry from the hash table if it is not empty, ensuring thread safety with mutexes and RCU synchronization.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function removes a dentry from a hash table with mutexes and RCU synchronization, but the source code actually prunes a dqcache using a spinlock for thread safety and returns a computed value based on counters and sysctl settings. None of the summary's details match the code's operations, making all claims inaccurate.",
                "The summary is inaccurate as it describes removing a dentry from a hash table with mutexes and RCU, which does not appear in the source code at all. The actual function prunes the dqcache when nr_to_scan is nonzero using a spinlock, not a mutex or RCU, and returns a value based on a percpu counter and sysctl parameter. It misses the primary purpose and all secondary details from the source.",
                "The summary claims the function removes a dentry from a hash table, uses mutexes, and RCU synchronization, none of which match the source code. The actual code prunes the dqcache under a spin lock and returns a value based on counters and cache pressure. These are FATAL inaccuracies about the primary purpose and key logic, causing severe misrepresentation."
            ]
        },
        "misum": {
            "summary": "The function removes a virtual memory area from a hash table and frees the associated memory management structure if available.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim about removing a virtual memory area from a hash table and freeing a memory management structure is entirely unrelated to the source code, which deals with pruning a quota cache under a spinlock and returning a calculated value. None of the summary's claims accurately reflect the code, resulting in 0% accurate claims.",
                "The summary\u2019s claim about removing a virtual memory area from a hash table and freeing a memory management structure is unrelated to the actual code, which prunes a dqcache under a lock and returns a calculated value based on free dquots. It misses the primary purpose entirely and provides information that contradicts the source implementation.",
                "The summary contains a FATAL error by describing an unrelated operation about removing a virtual memory area and freeing memory structures, which does not match the source code\u2019s purpose. The function in the source code prunes a quota cache under a lock and returns a computed value based on a counter and a system parameter. This fundamental mismatch targets primary purpose/key I/O, drastically reducing reliability."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 590960,
    "strip_function_name": "BN_CTX_end",
    "strip_decompiled_code": "__int64 __fastcall BN_CTX_end(__int64 a1)\n{\n  int v1; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  unsigned int v4; // ecx\n  __int64 result; // rax\n  int v6; // esi\n  int i; // edx\n\n  v1 = *(_DWORD *)(a1 + 52);\n  if ( v1 )\n  {\n    result = (unsigned int)(v1 - 1);\n    *(_DWORD *)(a1 + 52) = result;\n  }\n  else\n  {\n    v2 = *(_QWORD *)(a1 + 32);\n    v3 = (unsigned int)(*(_DWORD *)(a1 + 40) - 1);\n    *(_DWORD *)(a1 + 40) = v3;\n    v4 = *(_DWORD *)(v2 + 4 * v3);\n    result = *(unsigned int *)(a1 + 48);\n    if ( (unsigned int)result > v4 )\n    {\n      v6 = *(_DWORD *)(a1 + 24);\n      LODWORD(result) = result - v4;\n      *(_DWORD *)(a1 + 24) = v6 - result;\n      for ( i = ((_BYTE)v6 - 1) & 0xF; ; --i )\n      {\n        result = (unsigned int)(result - 1);\n        if ( (_DWORD)result == -1 )\n          break;\n        while ( !i )\n        {\n          result = (unsigned int)(result - 1);\n          *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 384LL);\n          i = 15;\n          if ( (_DWORD)result == -1 )\n            goto LABEL_7;\n        }\n      }\n    }\nLABEL_7:\n    *(_DWORD *)(a1 + 48) = v4;\n    *(_DWORD *)(a1 + 56) = 0;\n  }\n  return result;\n}\n",
    "function_name": "BN_CTX_end",
    "decompiled_code": "__int64 __fastcall BN_CTX_end(__int64 a1)\n{\n  int v1; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  unsigned int v4; // ecx\n  __int64 result; // rax\n  int v6; // esi\n  int i; // edx\n\n  v1 = *(_DWORD *)(a1 + 52);\n  if ( v1 )\n  {\n    result = (unsigned int)(v1 - 1);\n    *(_DWORD *)(a1 + 52) = result;\n  }\n  else\n  {\n    v2 = *(_QWORD *)(a1 + 32);\n    v3 = (unsigned int)(*(_DWORD *)(a1 + 40) - 1);\n    *(_DWORD *)(a1 + 40) = v3;\n    v4 = *(_DWORD *)(v2 + 4 * v3);\n    result = *(unsigned int *)(a1 + 48);\n    if ( (unsigned int)result > v4 )\n    {\n      v6 = *(_DWORD *)(a1 + 24);\n      LODWORD(result) = result - v4;\n      *(_DWORD *)(a1 + 24) = v6 - result;\n      for ( i = ((_BYTE)v6 - 1) & 0xF; ; --i )\n      {\n        result = (unsigned int)(result - 1);\n        if ( (_DWORD)result == -1 )\n          break;\n        while ( !i )\n        {\n          result = (unsigned int)(result - 1);\n          *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 384LL);\n          i = 15;\n          if ( (_DWORD)result == -1 )\n            goto LABEL_7;\n        }\n      }\n    }\nLABEL_7:\n    *(_DWORD *)(a1 + 48) = v4;\n    *(_DWORD *)(a1 + 56) = 0;\n  }\n  return result;\n}\n",
    "source_code": "\nvoid BN_CTX_end(BN_CTX *ctx)\n\t{\n\tCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\n\tif(ctx->err_stack)\n\t\tctx->err_stack--;\n\telse\n\t\t{\n\t\tunsigned int fp = BN_STACK_pop(&ctx->stack);\n\t\t/* Does this stack frame have anything to release? */\n\t\tif(fp < ctx->used)\n\t\t\tBN_POOL_release(&ctx->pool, ctx->used - fp);\n\t\tctx->used = fp;\n\t\t/* Unjam \"too_many\" in case \"get\" had failed */\n\t\tctx->too_many = 0;\n\t\t}\n\tCTXDBG_EXIT(ctx);\n\t}",
    "comment": "Releases resources associated with the BN_CTX structure, updating the used stack frame and resetting the too_many flag if necessary.",
    "hext5_sum": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
    "bint5_sum": "Decrements the reference count of a BIGNUM_CTX structure and frees associated memory if the count reaches zero , ensuring proper context management .\n",
    "cpbcs_sum": "Decrements the reference count of a BIGNUM structure, frees it if the count reaches zero.\n",
    "misum_sum": "Multiplies a BIGNUM by adjusting its length, storing the result in the solver if the context is less than zero.\n",
    "decom_sum": "Restores the previous allocation state in a big number context stack, updating internal indices and freeing any temporary big number entries.",
    "cfg_sum": "Finalizes a BN_CTX context frame by updating stack and allocation counters, restoring state, and resetting flags before returning control.",
    "work_score": {
        "hext5": {
            "summary": "generate a random wiping pass pattern with num passes. this is a two-stage process. first, the passes to include are chosen, and then they are shuffled into the desired order.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes a process for generating a random wiping pass pattern, which does not relate to or accurately reflect any part of the source code. The source code handles ending a BN_CTX context, managing an error stack, releasing memory pools, and resetting state flags, with no mention of random patterns, passes, or shuffling. All claims in the summary are unrelated and thus inaccurate.",
                "The summary describes generating a random wiping pass pattern, which is unrelated to the BN_CTX_end function\u2019s purpose of managing a stack frame within a bignum context, handling error stack decrement, releasing pooled resources, resetting state, and debugging entry/exit. It misses the primary purpose entirely and contains only inaccurate, non-code-related details.",
                "The summary describes generating a random wiping pass pattern with a two-stage selection and shuffling process, which is completely unrelated to the source code's functionality of ending a BN_CTX context, handling an error stack, releasing pool resources, and resetting internal state variables. All claims are NOISE, with no accurate detail about the implementation, resulting in overwhelming irrelevance."
            ]
        },
        "bint5": {
            "summary": "Decrements the reference count of a BIGNUM_CTX structure and frees associated memory if the count reaches zero , ensuring proper context management .\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function decrements a reference count and frees associated memory when the count reaches zero. In the source code, there is no reference count mechanism; instead, it decrements an `err_stack` counter or restores a stack frame and releases memory from a pool based on usage, regardless of a zero threshold. This makes the central claim contradictory to the actual semantics, resulting in no accurate claims extracted.",
                "The summary incorrectly describes the function as decrementing a reference count and freeing memory when the count reaches zero, which does not align with the source code. The implementation handles an error stack counter, pops a frame pointer from a stack, releases elements from a pool if needed, updates usage tracking, and resets a 'too_many' flag\u2014none of which are reference counting or a classic memory-free-on-zero operation. Although it mentions context management broadly, it misses the primary purpose and specifics of the function, making the claim largely inaccurate.",
                "The summary claims the function decrements a reference count and frees memory when it reaches zero. This is inaccurate because the source code does not implement reference counting; instead, it manages an error stack, pops a stack frame, and conditionally releases part of a memory pool. The mismatch targets the primary purpose and key side effects, making it a FATAL error that significantly misrepresents the function\u2019s behavior."
            ]
        },
        "cpbcs": {
            "summary": "Decrements the reference count of a BIGNUM structure, frees it if the count reaches zero.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function decrements a BIGNUM's reference count and frees it when zero, which contradicts the source code. The actual function manages an internal BN_CTX stack frame, releases pool resources, and resets state; there is no reference count logic or freeing of a BIGNUM as described. Since the claim targets code semantics but is completely inaccurate, none of the claims are accurate.",
                "The summary incorrectly describes reference count management for a BIGNUM structure, which is not present in the source. The function instead manages the internal BN_CTX stack, handling err_stack decrement, pool release, and resetting flags. The primary purpose and all secondary details from the code are missed, making the claim inaccurate and unrelated to the actual implementation.",
                "The summary claims the function decrements a BIGNUM reference count and frees it when zero, which directly contradicts the source code. The actual implementation manages a BN_CTX context, adjusting an error stack counter or releasing pool elements based on a stack frame pointer, and resetting a flag. This is a FATAL error about the primary purpose, leading to high negative impact and making the summary unreliable."
            ]
        },
        "misum": {
            "summary": "Multiplies a BIGNUM by adjusting its length, storing the result in the solver if the context is less than zero.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function multiplies a BIGNUM and adjusts its length, which is unrelated to the actual BN_CTX_end implementation that manages stack frames, releases pool memory, and resets state variables. None of the claims correspond to the source code's semantics, making them inaccurate.",
                "The summary incorrectly describes multiplication of a BIGNUM and adjustment of its length, which does not align with the source code. The function in the source ends a BN_CTX context, manipulates error stack, releases memory from a pool, adjusts 'used' and 'too_many' fields, and pops from a stack. The summary misses the primary purpose and all secondary details, and provides unrelated, contradictory behavior.",
                "The summary claims the function multiplies a BIGNUM and stores a result based on a context check, which directly contradicts the source code. The actual implementation manages a BN_CTX stack frame, releases pooled BIGNUMs if needed, updates counters, and resets a flag \u2014 it performs no multiplication. This is a FATAL error affecting the primary purpose of the function, resulting in high negative impact and no accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584132624,
    "strip_function_name": "sub_FFFFFFFF8150AE10",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8150AE10(\n        __int64 a1,\n        _BYTE *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v14; // rcx\n  __int64 v15; // rax\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( !memcmp(a2, \"default\", 7uLL) )\n  {\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v14 + 120))(a1, 0LL, 0LL);\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = *(_QWORD *)(a1 + 248);\n    }\n    v18[0] = v15;\n    *(_DWORD *)(a1 + 256) = 0;\n  }\n  else\n  {\n    if ( (int)sub_FFFFFFFF81509C60(a2, v18) < 0 )\n      return -22LL;\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v17 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v14 + 120))(a1, 0LL, 0LL);\n      v15 = v18[0];\n      if ( v17 < v18[0] )\n        return -7LL;\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = v18[0];\n    }\n    *(_DWORD *)(a1 + 256) = 1;\n  }\n  *(_QWORD *)(a1 + 248) = v15;\n  if ( v14 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 80LL) = v15;\n    sub_FFFFFFFF8116B620(*(_QWORD *)(a1 + 72), a4, a5, a6, a7, a8, a9, a10, a11);\n  }\n  return a3;\n}\n",
    "function_name": "array_size_store",
    "decompiled_code": "__int64 __fastcall array_size_store(\n        __int64 a1,\n        _BYTE *a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v14; // rcx\n  __int64 v15; // rax\n  unsigned __int64 v17; // rdx\n  unsigned __int64 v18[3]; // [rsp+0h] [rbp-18h] BYREF\n\n  if ( !memcmp(a2, \"default\", 7uLL) )\n  {\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, double, double, double, double, double, double, double, double))(v14 + 120))(\n              a1,\n              0LL,\n              0LL,\n              a4,\n              a5,\n              a6,\n              a7,\n              a8,\n              a9,\n              a10,\n              a11);\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = *(_QWORD *)(a1 + 248);\n    }\n    v18[0] = v15;\n    *(_DWORD *)(a1 + 256) = 0;\n  }\n  else\n  {\n    if ( (int)strict_blocks_to_sectors(a2, v18) < 0 )\n      return -22LL;\n    v14 = *(_QWORD *)(a1 + 8);\n    if ( v14 )\n    {\n      v17 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, double, double, double, double, double, double, double, double))(v14 + 120))(\n              a1,\n              0LL,\n              0LL,\n              a4,\n              a5,\n              a6,\n              a7,\n              a8,\n              a9,\n              a10,\n              a11);\n      v15 = v18[0];\n      if ( v17 < v18[0] )\n        return -7LL;\n      v14 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v15 = v18[0];\n    }\n    *(_DWORD *)(a1 + 256) = 1;\n  }\n  *(_QWORD *)(a1 + 248) = v15;\n  if ( v14 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 80LL) = v15;\n    revalidate_disk(*(_QWORD *)(a1 + 72), a4, a5, a6, a7, a8, a9, a10, a11);\n  }\n  return a3;\n}\n",
    "source_code": "\nstatic ssize_t\narray_size_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tsector_t sectors;\n\n\tif (strncmp(buf, \"default\", 7) == 0) {\n\t\tif (mddev->pers)\n\t\t\tsectors = mddev->pers->size(mddev, 0, 0);\n\t\telse\n\t\t\tsectors = mddev->array_sectors;\n\n\t\tmddev->external_size = 0;\n\t} else {\n\t\tif (strict_blocks_to_sectors(buf, &sectors) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->pers && mddev->pers->size(mddev, 0, 0) < sectors)\n\t\t\treturn -E2BIG;\n\n\t\tmddev->external_size = 1;\n\t}\n\n\tmddev->array_sectors = sectors;\n\tif (mddev->pers) {\n\t\tset_capacity(mddev->gendisk, mddev->array_sectors);\n\t\trevalidate_disk(mddev->gendisk);\n\t}\n\treturn len;\n}",
    "comment": "Sets the array size for a storage device based on input, updating capacity and validating the disk if a specific size is provided.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Retrieves the current temperature from a thermal zone device or falls back to the thermal zone 's temperature if the name is `` default '' .\n",
    "cpbcs_sum": "Transfers data from a memory-mapped offset to a file after validating the offset and managing synchronization and ensuring thread safety.\n",
    "misum_sum": "Sets the maximum synchronization flag for a device, validating input and invoking a callback function to appropriate callbacks based on the old.\n",
    "decom_sum": "Updates a device\u2019s active configuration value to either \u201cdefault\u201d or a validated custom setting, then applies associated calibration parameters and operational state.",
    "cfg_sum": "Sets or validates a configuration value, updates internal state, and applies related parameters through a linked resource, returning a provided status code.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior involving a static buffer, printf formatting, and hexadecimal conversion based on num_bytes, none of which appear in the provided source code. The function in the source adjusts array sizes, handles default or parsed sector values, validates input, and updates disk capacity. All claims in the summary are unrelated to the source's semantics, making them inaccurate.",
                "The summary describes behavior involving a static buffer, printf formatting, and hexadecimal conversion, which is entirely unrelated to the source code\u2019s primary purpose of updating the RAID array size based on input, handling 'default' keyword, parsing sectors, validating limits, and updating device capacity. None of the summary\u2019s claims match or safely generalize the source semantics, so they are inaccurate and provide zero coverage of primary or secondary details.",
                "All claims in the summary describe behavior involving static buffers, printf formatting, and hex conversion, which are entirely unrelated to the source code\u2019s actual functionality of setting array size in a RAID device structure and adjusting disk capacity. This is pure NOISE with no accurate match to the code, resulting in zero alignment and no informational value."
            ]
        },
        "bint5": {
            "summary": "Retrieves the current temperature from a thermal zone device or falls back to the thermal zone 's temperature if the name is `` default '' .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about retrieving temperature from a thermal zone device is entirely unrelated to the source code, which handles setting array size sectors in an mddev structure based on input, not temperature. All claims are inaccurate and do not match the implementation, resulting in no accurate matches.",
                "The summary is entirely inaccurate, describing temperature retrieval from a thermal zone device, which is unrelated to the source code. The source code handles setting the array size for an md device based on the input buffer, with conditions for 'default', parsing sectors, and updating capacity/revalidating the disk. The primary purpose and all secondary details from the code are missed, and none of the claims map to the actual semantics.",
                "The summary's sole claim describes retrieving temperature from a thermal zone device with a 'default' fallback, which is completely unrelated to the source code's actual functionality of setting array size in an md device based on input or 'default'. This is a NOISE error targeting the wrong domain, with no accurate claims, making the output entirely unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Transfers data from a memory-mapped offset to a file after validating the offset and managing synchronization and ensuring thread safety.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about transferring data from a memory-mapped offset to a file, offset validation, synchronization, and thread safety do not align with the source code, which handles parsing a buffer to set an array size, validates sector values, and updates device capacity. None of the claims accurately reflect the code's functionality, resulting in no accurate matches.",
                "The summary describes transferring data from a memory-mapped offset to a file with validation and thread safety, which is unrelated to the source code's actual purpose of updating the array size for a RAID device, handling 'default' input, validating sector values, managing error codes, and updating disk capacity. The claim is inaccurate and covers none of the primary or secondary semantic units in the source.",
                "The summary describes transferring data from a memory-mapped offset to a file with validation and thread safety, which is completely unrelated to the actual code that sets RAID array size based on input, parses sectors, and updates disk capacity. All claims are NOISE, heavily misrepresenting the primary purpose, leading to zero alignment and negative utility."
            ]
        },
        "misum": {
            "summary": "Sets the maximum synchronization flag for a device, validating input and invoking a callback function to appropriate callbacks based on the old.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function sets a maximum synchronization flag and invokes callbacks based on prior state, but the source code shows it sets array size, processes 'default' or parsed sector values, validates inputs, and updates capacity after optional validation. The stated flag and callback logic are unsupported, making all claims inaccurate per evaluation steps.",
                "The summary incorrectly describes the function as setting a maximum synchronization flag and invoking callbacks, which is not reflected in the source code. The actual code parses the input buffer to set the array size, handles special 'default' input, validates sector values, updates internal fields, adjusts capacity, and revalidates the disk. The summary misses the primary purpose entirely and introduces unrelated behavior, making it inaccurate.",
                "The summary claims that the function sets a maximum synchronization flag, validates input, and invokes a callback based on an 'old' value. None of these accurately reflect the source code's actual purpose, which is to set the array size for a RAID device, parse the input, adjust internal fields, and update disk capacity. The mismatched description is a FATAL error regarding the primary purpose of the function, leading to a high negative impact with no gain from accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579235968,
    "strip_function_name": "sub_FFFFFFFF8105F680",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8105F680(__int64 a1)\n{\n  __int64 *v1; // rbx\n  __int64 v2; // rdx\n  _QWORD *v3; // rax\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  int v7; // r9d\n  __int64 v8; // r13\n  __int64 v9; // rax\n  bool v10; // zf\n  __int64 (__fastcall **v11)(); // rax\n  __int64 (__fastcall *v12)(); // rax\n\n  v1 = *(__int64 **)(a1 + 120);\n  if ( (__int64 *)(a1 + 120) != v1 )\n  {\n    while ( 1 )\n    {\n      v8 = sub_FFFFFFFF817928D0(v1 + 4);\n      v9 = *((int *)v1 + 9);\n      if ( (int)v9 < 0 )\n      {\n        v11 = off_FFFFFFFF81C316C0;\n        if ( (*((_DWORD *)v1 + 9) & 7) == 3 )\n          v11 = off_FFFFFFFF81C33E80;\n      }\n      else if ( (int)v9 > 15\n             || (v4 = 80 * v9,\n                 v10 = qword_FFFFFFFF81E3EEE0[10 * v9] == 0,\n                 v11 = (__int64 (__fastcall **)())&qword_FFFFFFFF81E3EEE0[10 * v9],\n                 v10) )\n      {\nLABEL_3:\n        if ( !byte_FFFFFFFF81CAC55D )\n        {\n          sub_FFFFFFFF8103BB80((__int64)\"kernel/posix-timers.c\", 929, v4, v5, v6, v7);\n          byte_FFFFFFFF81CAC55D = 1;\n        }\n        goto LABEL_5;\n      }\n      v12 = v11[8];\n      if ( !v12 )\n        goto LABEL_3;\n      if ( ((unsigned int (__fastcall *)(__int64 *))v12)(v1) == 1 )\n      {\n        sub_FFFFFFFF81792660(v1 + 4, v8);\n      }\n      else\n      {\nLABEL_5:\n        v2 = *v1;\n        v3 = (_QWORD *)v1[1];\n        *(_QWORD *)(v2 + 8) = v3;\n        *v3 = v2;\n        *v1 = 0xDEAD000000000100LL;\n        v1[8] = 0LL;\n        v1[1] = 0xDEAD000000000200LL;\n        sub_FFFFFFFF81792660(v1 + 4, v8);\n        sub_FFFFFFFF8105EA70(v1, 1);\n        v1 = *(__int64 **)(a1 + 120);\n        if ( v1 == (__int64 *)(a1 + 120) )\n          return;\n      }\n    }\n  }\n}\n",
    "function_name": "exit_itimers",
    "decompiled_code": "void __fastcall exit_itimers(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  volatile signed __int16 *v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rax\n  bool v17; // zf\n  __int64 (__fastcall **v18)(); // rax\n  __int64 (__fastcall *v19)(); // rax\n\n  v9 = *(volatile signed __int16 **)(a1 + 120);\n  if ( (volatile signed __int16 *)(a1 + 120) != v9 )\n  {\n    while ( 1 )\n    {\n      raw_spin_lock_irqsave(v9 + 16);\n      v16 = *((int *)v9 + 9);\n      if ( (int)v16 < 0 )\n      {\n        v18 = clock_posix_cpu;\n        if ( (*((_DWORD *)v9 + 9) & 7) == 3 )\n          v18 = clock_posix_dynamic;\n      }\n      else if ( (int)v16 > 15\n             || (v17 = posix_clocks[10 * v16] == 0, v18 = (__int64 (__fastcall **)())&posix_clocks[10 * v16], v17) )\n      {\nLABEL_3:\n        if ( !_warned_28687 )\n        {\n          warn_slowpath_null(\"kernel/posix-timers.c\", 0x3A1u, a2, a3, a4, a5, v14, v15, a8, a9);\n          _warned_28687 = 1;\n        }\n        goto LABEL_5;\n      }\n      v19 = v18[8];\n      if ( !v19 )\n        goto LABEL_3;\n      if ( ((unsigned int (__fastcall *)(volatile signed __int16 *))v19)(v9) == 1 )\n      {\n        raw_spin_unlock_irqrestore((_BYTE *)v9 + 32);\n      }\n      else\n      {\nLABEL_5:\n        v10 = *(_QWORD *)v9;\n        v11 = (_QWORD *)*((_QWORD *)v9 + 1);\n        *(_QWORD *)(v10 + 8) = v11;\n        *v11 = v10;\n        *(_QWORD *)v9 = 0xDEAD000000000100LL;\n        *((_QWORD *)v9 + 8) = 0LL;\n        *((_QWORD *)v9 + 1) = 0xDEAD000000000200LL;\n        raw_spin_unlock_irqrestore((_BYTE *)v9 + 32);\n        release_posix_timer(v9, 1, a2, a3, a4, a5, v12, v13, a8, a9);\n        v9 = *(volatile signed __int16 **)(a1 + 120);\n        if ( v9 == (volatile signed __int16 *)(a1 + 120) )\n          return;\n      }\n    }\n  }\n}\n",
    "source_code": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "comment": "Deletes all posix timers associated with the given signal structure by iterating through and removing each timer from the list.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Frees all PID lists associated with the given PID namespace and then deallocates the namespace structure itself .\n",
    "cpbcs_sum": "Processes a worker pool, executing associated operations while managing RCU callbacks and handling memory operations for safe concurrent access.\n",
    "misum_sum": "Executes a usermode helper process, managing its state and registry if necessary.\n",
    "decom_sum": "Iterates through pending POSIX timers, invoking their handlers if valid, otherwise deleting and cleaning up invalid or expired timer entries.",
    "cfg_sum": "Iterates through a linked list of timer objects, validates their type, executes associated callbacks, and removes or cleans entries that fail validation.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display do not match the source code, which focuses on deleting POSIX timers from a signal_struct. None of the claims accurately reflect the code's behavior, resulting in no alignment with the source implementation.",
                "The summary describes string manipulation involving control characters, escape sequences, static buffers, and Unicode display, which is entirely unrelated to the source code's actual purpose of iterating over and deleting POSIX timers in a signal_struct. None of the described behaviors match the source implementation, so there is no coverage of the primary purpose or any secondary details.",
                "All claims in the summary are unrelated to the source code, which is about deleting POSIX timers from a signal structure. The summary discusses string manipulation, control character escaping, static buffers, and Unicode handling\u2014none of which are present in the implementation. This is pure NOISE with no accurate alignment, resulting in low reliability and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Frees all PID lists associated with the given PID namespace and then deallocates the namespace structure itself .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes freeing PID lists and deallocating a PID namespace, which is unrelated to the source code. The source code iterates through a signal_struct's posix_timers list and deletes timers; there is no mention of PID lists or PID namespace deallocation. All claims are inaccurate.",
                "The summary's claim about freeing PID lists and deallocating a PID namespace does not match the source code, which iterates over and deletes POSIX timers for a given signal_struct. This is a semantic mismatch that misses the primary purpose of the function and includes no accurate coverage of its actual behavior.",
                "The summary claims that the function frees PID lists and deallocates a PID namespace, which directly contradicts the source code. The code actually iterates through and deletes POSIX timers from a signal_struct, not PID lists or namespaces. This is a FATAL error affecting the primary purpose, leading to a high negative impact and making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Processes a worker pool, executing associated operations while managing RCU callbacks and handling memory operations for safe concurrent access.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary contains claims about processing a worker pool, executing operations, managing RCU callbacks, and handling memory for concurrent access, none of which correspond to the source code. The source code deals exclusively with deleting POSIX timers from a signal structure until the list is empty. All claims are inaccurate and unrelated to the actual implementation, resulting in no accurate matches.",
                "The summary claims the function processes a worker pool, executes operations, and manages RCU callbacks with memory safety, which does not match the source code. The code\u2019s primary purpose is to iterate through and delete all POSIX timers from a signal_struct, with no worker pools, RCU callbacks, or memory operations beyond timer deletion. This misses the primary purpose entirely and contains only inaccurate claims.",
                "The summary contains only INACCURATE claims that do not match the source code semantics. The source code deletes POSIX timers from a signal_struct by repeatedly invoking itimer_delete, and has no worker pool processing, RCU callbacks, or concurrent memory handling. This is pure NOISE, with no accurate or relevant details, resulting in high negative impact and no gain."
            ]
        },
        "misum": {
            "summary": "Executes a usermode helper process, managing its state and registry if necessary.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes executing a usermode helper process and managing its state/registry, which is unrelated to the source code. The source code iterates over a list of POSIX timers in a signal structure and deletes them, so all claims in the summary are inaccurate.",
                "The summary claims the function executes a usermode helper process and manages its state and registry, which directly contradicts the code. The source code clearly shows the function iterates through and deletes all POSIX timers in a signal_struct, with no involvement in usermode helpers or registry management. This misses the primary purpose entirely and contains inaccurate semantic mapping.",
                "The summary's claim that the function executes a usermode helper process and manages its state and registry is entirely unrelated to the source code, which loops through and deletes POSIX timers from a signal_struct. This is a FATAL inaccuracy about the PRIMARY PURPOSE, as it misrepresents the function\u2019s core operation. No accurate claims are present, resulting in high negative impact and zero positive gain."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584527008,
    "strip_function_name": "sub_FFFFFFFF8156B2A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8156B2A0(\n        _QWORD *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // r12\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  unsigned __int64 v19; // rdi\n  unsigned int v20; // ebx\n  _QWORD *v22; // rax\n  __int64 *v23; // rdx\n\n  sub_FFFFFFFF8178FDC0(qword_FFFFFFFF81C80920);\n  v11 = a1 + 46;\n  sub_FFFFFFFF817926F0(&dword_FFFFFFFF81C80940);\n  if ( (_QWORD *)a1[50] == a1 + 46 )\n  {\n    v20 = -114;\n  }\n  else\n  {\n    v17 = (_QWORD *)a1[45];\n    v18 = a1[44];\n    *(_QWORD *)(v18 + 8) = v17;\n    *v17 = v18;\n    a1[44] = 0xDEAD000000000100LL;\n    a1[45] = 0xDEAD000000000200LL;\n    --*(_DWORD *)(a1[50] + 24LL);\n    v19 = a1[50];\n    if ( *(_DWORD *)(v19 + 24) == 1 )\n    {\n      v22 = *(_QWORD **)(v19 + 8);\n      v23 = (__int64 *)(v19 + 8);\n      if ( v22 != (_QWORD *)(v19 + 8) )\n      {\n        v22[4] = v22;\n        v22[3] = v22;\n        v22[6] = v22 + 2;\n        v23 = v22 + 3;\n        *v22 = v22 + 3;\n        v22[1] = v22 + 3;\n        v19 = a1[50];\n      }\n      sub_FFFFFFFF8112DCD0(v19, a3, a4, a5, a6, v15, v16, a9, a10, a2, v23, v12, v13, v14);\n    }\n    a1[50] = v11;\n    a1[48] = a1 + 44;\n    a1[44] = a1 + 47;\n    a1[45] = a1 + 47;\n    a1[47] = a1 + 44;\n    v20 = 0;\n  }\n  _InterlockedAdd(&dword_FFFFFFFF81C80940, 0x100000u);\n  _enable();\n  sub_FFFFFFFF810644C0(qword_FFFFFFFF81C80920);\n  return v20;\n}\n",
    "function_name": "snd_pcm_unlink",
    "decompiled_code": "__int64 __fastcall snd_pcm_unlink(\n        _QWORD *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // r12\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rdi\n  unsigned int v17; // ebx\n  _QWORD *v19; // rax\n  __int64 *v20; // rdx\n\n  down_write(snd_pcm_link_rwsem);\n  v11 = a1 + 46;\n  raw_write_lock_irq(&snd_pcm_link_rwlock);\n  if ( (_QWORD *)a1[50] == a1 + 46 )\n  {\n    v17 = -114;\n  }\n  else\n  {\n    v14 = (_QWORD *)a1[45];\n    v15 = a1[44];\n    *(_QWORD *)(v15 + 8) = v14;\n    *v14 = v15;\n    a1[44] = 0xDEAD000000000100LL;\n    a1[45] = 0xDEAD000000000200LL;\n    --*(_DWORD *)(a1[50] + 24LL);\n    v16 = a1[50];\n    if ( *(_DWORD *)(v16 + 24) == 1 )\n    {\n      v19 = *(_QWORD **)(v16 + 8);\n      v20 = (__int64 *)(v16 + 8);\n      if ( v19 != (_QWORD *)(v16 + 8) )\n      {\n        v19[4] = v19;\n        v19[3] = v19;\n        v19[6] = v19 + 2;\n        v20 = v19 + 3;\n        *v19 = v19 + 3;\n        v19[1] = v19 + 3;\n        v16 = a1[50];\n      }\n      kfree((__int64 *)v16, a3, a4, a5, a6, v12, v13, a9, a10, a2, v20);\n    }\n    a1[50] = v11;\n    a1[48] = a1 + 44;\n    a1[44] = a1 + 47;\n    a1[45] = a1 + 47;\n    a1[47] = a1 + 44;\n    v17 = 0;\n  }\n  _InterlockedAdd(&snd_pcm_link_rwlock, 0x100000u);\n  _enable();\n  up_write(snd_pcm_link_rwsem, a2);\n  return v17;\n}\n",
    "source_code": "\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_substream *s;\n\tint res = 0;\n\n\tdown_write(&snd_pcm_link_rwsem);\n\twrite_lock_irq(&snd_pcm_link_rwlock);\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\tlist_del(&substream->link_list);\n\tsubstream->group->count--;\n\tif (substream->group->count == 1) {\t/* detach the last stream, too */\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\trelink_to_local(s);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(substream->group);\n\t}\n\trelink_to_local(substream);\n       _end:\n\twrite_unlock_irq(&snd_pcm_link_rwlock);\n\tup_write(&snd_pcm_link_rwsem);\n\treturn res;\n}",
    "comment": "Unlinks a PCM substream from its group and releases resources if it was the last linked stream in the group.",
    "hext5_sum": "p^1_{-1/2 + i lambda}",
    "bint5_sum": "Unregisters a PCM substream , cleans up associated resources , and notifies subscribers about the substream 's unregistration .\n",
    "cpbcs_sum": "Registers an HDA codec by initializing its list and adding it to the list if it is not empty, while managing concurrency with a spin lock.\n",
    "misum_sum": "Unregisters a PCM device by removing it from the list and updating its card count and notifying the device's bus list.\n",
    "decom_sum": "Resets and reinitializes linked list entries in a1, updates counters, and triggers further processing when the list\u2019s reference count reaches one.",
    "cfg_sum": "Updates linked list nodes and counters, resets related pointers, and performs synchronized cleanup when a specific element count condition is met.",
    "work_score": {
        "hext5": {
            "summary": "p^1_{-1/2 + i lambda}",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only an isolated mathematical expression and no fact-based claims related to the source code. It does not describe or target any aspects of snd_pcm_unlink\u2019s implementation, making all potential claims irrelevant. As a result, there are no accurate claims to evaluate against the source, leading to a complete mismatch with the evaluation steps.",
                "The summary provides a mathematical expression unrelated to the source code, failing to capture the primary purpose of snd_pcm_unlink or any observable behavior, inputs, outputs, or secondary details. No accurate claims about the function\u2019s logic or semantics are present, resulting in no coverage.",
                "The summary contains no fact-based claims about the source code, instead presenting unrelated mathematical notation. This is pure NOISE with no connection to the code\u2019s semantics or implementation details, resulting in no informative or accurate content for evaluation."
            ]
        },
        "bint5": {
            "summary": "Unregisters a PCM substream , cleans up associated resources , and notifies subscribers about the substream 's unregistration .\n",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function notifies subscribers about the substream's unregistration, but the source code contains no notification mechanism. While it correctly notes that the function unregisters a PCM substream and cleans up associated resources (via list deletion, group decrement, and memory free), the inclusion of the inaccurate notification claim reduces accuracy, leaving only about two-thirds of the claims aligned with the implementation.",
                "The summary correctly implies that the function removes a PCM substream and cleans up resources, aligning with the code's unlinking process and freeing memory when appropriate. However, it inaccurately states that subscribers are notified, which is not supported by the source code, and omits important secondary details such as the EALREADY error handling, synchronization via locks, and the specific relinking logic. This results in partial coverage of the primary purpose but misses several key secondary behaviors.",
                "The summary claims that the function notifies subscribers about the substream's unregistration, but the source code shows no notification mechanism, making this a FATAL inaccuracy related to side effects. While it is accurate that the code unlinks a substream and frees associated resources when appropriate, the incorrect subscriber notification detail directly contradicts the implementation's observable behavior."
            ]
        },
        "cpbcs": {
            "summary": "Registers an HDA codec by initializing its list and adding it to the list if it is not empty, while managing concurrency with a spin lock.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes registering an HDA codec, initializing and adding it to a list with a spin lock, which is unrelated to the actual source code that unlinks an ALSA PCM substream, manipulates group counts, and uses read/write locks. All claims are inaccurate because they do not match the function's semantics or context.",
                "The summary is entirely inaccurate because it describes registering an HDA codec and managing a list with a spin lock, which is unrelated to the source code's actual purpose of unlinking an ALSA PCM substream from a linked group, handling concurrency with read/write locks, updating the group's count, relinking streams to local, and freeing memory when appropriate. It misses the primary purpose and all key implementation details from the source.",
                "The summary is entirely inaccurate regarding the source code's functionality. The source code focuses on unlinking an ALSA PCM substream from a group, handling resource cleanup and concurrency with read/write locks, while the summary incorrectly describes registering an HDA codec, list initialization, and spin lock usage that do not exist in the implementation. This is a FATAL error affecting the primary purpose, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Unregisters a PCM device by removing it from the list and updating its card count and notifying the device's bus list.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function unregisters a PCM device, updates its card count, and notifies its device's bus list. The source code actually unlinks a PCM substream from a linked group, updates the group's count, relinks streams locally, and frees the group if needed. There is no operation on a PCM device object, card count, or bus list, making most claims inaccurate. Only the removal from a list aligns partially, resulting in less than half of the claims being accurate.",
                "The summary incorrectly describes the function as unregistering a PCM device and updating its card count and bus list, which does not match the source code. The source code unlinks a PCM substream from its group, updates the group's count, handles the special case where it is the last linked stream, relinks streams locally, frees the group structure, and uses locking mechanisms. The claims in the summary are inaccurate, miss the primary purpose, and introduce unrelated concepts like a card count and bus list.",
                "The summary's claim about unregistering a PCM device and interacting with a card count and bus list is inaccurate. The source code actually unlinks a PCM substream from its group, updates the group's count, potentially detaches the last stream, and frees the group memory. There is no device unregistration, card count manipulation, or bus list notification in the implementation. This mismatch targets the core function purpose, making it a FATAL error with high negative impact and no accurate claims to provide useful insight."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 435248,
    "strip_function_name": "sub_6A430",
    "strip_decompiled_code": "__int64 __fastcall sub_6A430(__int64 a1)\n{\n  unsigned __int64 v1; // rax\n  _QWORD *v3; // rax\n  void *v4; // rax\n\n  v1 = *(_QWORD *)(a1 + 592);\n  if ( v1 == 204 || v1 == 304 || v1 <= 0xC7 || *(_QWORD *)(a1 + 1072) != a1 || *(_QWORD *)(a1 + 920) == 4LL )\n    return qword_2D6490();\n  if ( *(_QWORD *)(a1 + 856) != -1LL )\n  {\n    if ( (*(_BYTE *)(a1 + 1249) & 0x10) == 0\n      || *(_QWORD *)(a1 + 928) <= 0x3E8uLL\n      || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * ngx_http_core_module) + 520LL) )\n    {\n      return qword_2D6490();\n    }\nLABEL_13:\n    v3 = *(_QWORD **)(a1 + 632);\n    *(_QWORD *)(a1 + 856) = -1LL;\n    if ( v3 )\n    {\n      *v3 = 0LL;\n      *(_QWORD *)(a1 + 632) = 0LL;\n    }\n    goto LABEL_15;\n  }\n  if ( *(_QWORD *)(a1 + 928) <= 0x3E8uLL\n    || !*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * ngx_http_core_module) + 520LL) )\n  {\n    *(_BYTE *)(a1 + 1249) &= ~0x20u;\n    return qword_2D6490();\n  }\n  if ( (*(_BYTE *)(a1 + 1249) & 0x10) != 0 )\n    goto LABEL_13;\nLABEL_15:\n  *(_BYTE *)(a1 + 1249) |= 4u;\n  v4 = ngx_pcalloc(*(_QWORD **)(a1 + 88), 0x10uLL);\n  if ( v4 )\n  {\n    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * ngx_http_chunked_filter_module) = v4;\n    return qword_2D6490();\n  }\n  return -1LL;\n}\n",
    "function_name": "ngx_http_chunked_header_filter",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n  ngx_uint_t status; // rax\n  ngx_table_elt_t *content_length; // rax\n  void *v4; // rax\n\n  status = r->headers_out.status;\n  if ( status == 204 || status == 304 || status <= 0xC7 || r->main != r || r->method == 4 )\n    return ngx_http_next_header_filter(r);\n  if ( r->headers_out.content_length_n == -1 )\n  {\n    if ( r->http_version <= 0x3E8 || !*((_QWORD *)r->loc_conf[ngx_http_core_module.ctx_index] + 65) )\n    {\n      *((_BYTE *)r + 1249) &= ~0x20u;\n      return ngx_http_next_header_filter(r);\n    }\n    if ( (*((_BYTE *)r + 1249) & 0x10) == 0 )\n      goto LABEL_16;\n  }\n  else if ( (*((_BYTE *)r + 1249) & 0x10) == 0\n         || r->http_version <= 0x3E8\n         || !*((_QWORD *)r->loc_conf[ngx_http_core_module.ctx_index] + 65) )\n  {\n    return ngx_http_next_header_filter(r);\n  }\n  content_length = r->headers_out.content_length;\n  r->headers_out.content_length_n = -1LL;\n  if ( content_length )\n  {\n    content_length->hash = 0LL;\n    r->headers_out.content_length = 0LL;\n  }\nLABEL_16:\n  *((_BYTE *)r + 1249) |= 4u;\n  v4 = ngx_pcalloc(r->pool, 0x10uLL);\n  if ( v4 )\n  {\n    r->ctx[ngx_http_chunked_filter_module.ctx_index] = v4;\n    return ngx_http_next_header_filter(r);\n  }\n  return -1LL;\n}\n",
    "source_code": "\n\nstatic ngx_int_t\nngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n    ngx_http_core_loc_conf_t       *clcf;\n    ngx_http_chunked_filter_ctx_t  *ctx;\n\n    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_out.content_length_n == -1\n        || r->expect_trailers)\n    {\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n\n        } else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }\n    }\n\n    return ngx_http_next_header_filter(r);\n}",
    "comment": "The function processes HTTP responses to enable chunked transfer encoding when conditions regarding content length and HTTP version are met.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Processes the HTTP response status , handling errors , retries , redirections , and managing memory for the response buffer .\n",
    "cpbcs_sum": "Processes HTTP requests by determining the request body counts, linking them to the output if certain conditions are met.\n",
    "misum_sum": "Processes and sends HTTP response data for an HTTP request, ensuring proper handling of checksum and headers before executing the core phase handler.\n",
    "decom_sum": "Initializes the HTTP chunked filter module for a request if specific state and timeout conditions are met, otherwise terminates processing early.",
    "cfg_sum": "Checks HTTP request state and conditions, resets or updates related pointers, and allocates chunked filter context before returning a status code.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes generating LEB128 fragments with sign control for sleb or uleb, which is unrelated to the provided source code that handles HTTP chunked transfer encoding in the Nginx header filter. None of the claims in the summary match or safely align with the code's logic, resulting in no accurate claims.",
                "The summary describes generating LEB128 value fragments with a sign flag, which is completely unrelated to the source code's purpose of handling HTTP chunked transfer encoding in the Nginx header filter. It misses the primary purpose and any secondary details from the source, making the claims inaccurate noise.",
                "The summary describes generating LEB128 fragments with sign-based encoding, which is unrelated to the source code's behavior. The source implements an HTTP header filter for chunked transfer encoding in Nginx, with logic around content length, HTTP version, and trailers. This mismatch means all claims are NOISE, providing no accurate or relevant insight into the code."
            ]
        },
        "bint5": {
            "summary": "Processes the HTTP response status , handling errors , retries , redirections , and managing memory for the response buffer .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims handling of errors, retries, redirections, and managing memory for the response buffer, which are not present in the source code. The source function deals with HTTP response status checks, chunked transfer encoding setup, clearing content length under certain conditions, and keepalive adjustments, but does not implement retries or redirection logic. Most claims target code semantics inaccurately, with only a general mention of processing response status aligning loosely. Overall accuracy is very low.",
                "The summary is inaccurate because it describes handling errors, retries, redirections, and memory for a response buffer, none of which are observed in the source code. The actual function determines whether to apply chunked transfer encoding based on response status, HTTP version, content length, and expectation of trailers, and sets up context accordingly. The primary purpose and key conditions in the code are entirely missed, resulting in no accurate coverage of the function's semantics.",
                "The summary claims handling of errors, retries, and redirections, as well as memory management for a response buffer, none of which match the source code behavior. The function actually processes HTTP headers to apply chunked transfer encoding in specific status and content length scenarios. The mismatched claims are high-impact (FATAL) because they misstate the primary purpose and key logic of the function, leading to a fundamentally incorrect understanding."
            ]
        },
        "cpbcs": {
            "summary": "Processes HTTP requests by determining the request body counts, linking them to the output if certain conditions are met.\n",
            "score": [
                0.1,
                0.2,
                0.4
            ],
            "reason": [
                "The summary is overly vague and does not reflect the specific conditions and logic in the source code, such as handling different HTTP statuses, methods, content length checks, chunked transfer encoding, and trailer expectations. It introduces an unrelated concept of 'request body counts' and 'linking to the output', which is not present in the implementation, making the claim inaccurate overall.",
                "The summary fails to capture the primary purpose of determining and setting up chunked transfer encoding based on HTTP version, content length, and trailers. It also omits key conditions involving status codes, HEAD requests, and keepalive handling. The vague mention of 'request body counts' and 'linking to output' is inaccurate and does not reflect the actual logic in the source code.",
                "The summary contains a single vague claim about 'determining the request body counts and linking them to the output if certain conditions are met,' which does not match the source code\u2019s specific logic for setting chunked transfer encoding based on status codes, HTTP version, and content length. This is effectively NOISE, as it misses key semantics and provides no useful detail. With no accurate or high-gain claims, the content offers low net benefit."
            ]
        },
        "misum": {
            "summary": "Processes and sends HTTP response data for an HTTP request, ensuring proper handling of checksum and headers before executing the core phase handler.\n",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary describes sending HTTP response data with checksum handling, which is not reflected in the source code. The code specifically sets chunked transfer encoding based on certain conditions and manipulates headers accordingly, but does not handle checksums or execute a 'core phase handler'. These mismatches mean the fact-based claims in the summary are largely inaccurate, with minimal alignment to actual code behavior.",
                "The summary is inaccurate because it mentions checksum handling and sending HTTP response data, neither of which are present in the source code. The source code\u2019s primary purpose is to modify HTTP header handling for certain conditions, adding chunked transfer encoding when appropriate before passing control to the next header filter. The summary fails to capture this primary purpose and omits key secondary details such as conditions on status codes, HTTP version checks, handling of content length, and expect_trailers logic.",
                "The summary claims that the function processes and sends HTTP response data, handles checksums, and prepares headers before a core phase handler. The source code shows header filtering logic for chunked transfer encoding without any checksum handling, which makes the checksum claim inaccurate and unrelated (NOISE). While the mention of handling headers is broadly accurate (SAFE), the summary omits critical specifics such as conditions for chunked encoding, absence of content length, and support for HTTP trailers, resulting in low informational value. The worst failure mode is NOISE, as inaccurate claims outweigh accurate ones."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 4997088,
    "strip_function_name": "sub_4C3FE0",
    "strip_decompiled_code": "__int64 __fastcall sub_4C3FE0(__int64 a1, const char *a2, _DWORD *a3, char a4)\n{\n  int v5; // ecx\n  unsigned int v6; // ebp\n  int v7; // ebx\n  __int64 v8; // rsi\n  signed __int64 v9; // rax\n  bool v10; // zf\n  __off_t v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // [rsp+8h] [rbp-C0h] BYREF\n  struct stat stat_buf; // [rsp+10h] [rbp-B8h] BYREF\n\n  v5 = a4 & 1;\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = sub_4AE520(*(_QWORD *)(a1 + 8), a2, &v14, &stat_buf, 0);\n    if ( v7 >= 0 )\n    {\n      v8 = v14;\n      v9 = stat_buf.st_dev + 4094;\n      if ( (signed __int64)(stat_buf.st_dev + 2047) >= 0 )\n        v9 = stat_buf.st_dev + 2047;\n      *a3 = v9 >> 11;\n      v7 = sub_4AF430(a1, v8);\n      sub_4AE4A0((void **)&v14);\n      v10 = v7 == 0;\n      if ( v7 >= 0 )\n      {\n        v7 = 2;\n        if ( v10 )\n          return v6;\n      }\n    }\n    return (unsigned int)v7;\n  }\n  *a3 = 0;\n  if ( __xstat(1, a2, &stat_buf) == -1 || (stat_buf.st_mode & 0xF000) != 0x8000 )\n    return (unsigned int)-399442290;\n  v12 = stat_buf.st_size + 4094;\n  if ( stat_buf.st_size + 2047 >= 0 )\n    v12 = stat_buf.st_size + 2047;\n  v13 = v12 >> 11;\n  if ( v13 > 0x3FFFFFFF || !v13 )\n    return (unsigned int)-399442290;\n  *a3 = v13;\n  return 1LL;\n}\n",
    "function_name": "compute_partition_size",
    "decompiled_code": "__int64 __fastcall compute_partition_size(Ecma119Image *a1, char *disk_path, _DWORD *a3, char flag)\n{\n  int v5; // ecx\n  unsigned int v6; // ebp\n  int v7; // ebx\n  iso_interval_reader *v8; // rsi\n  off_t v9; // rax\n  bool v10; // zf\n  __int64 v12; // rax\n  __int64 v13; // rax\n  iso_interval_reader *ivr; // [rsp+8h] [rbp-C0h] BYREF\n  off_t byte_count[3]; // [rsp+10h] [rbp-B8h] BYREF\n  int v16; // [rsp+28h] [rbp-A0h]\n  __int64 v17; // [rsp+40h] [rbp-88h]\n\n  v5 = flag & 1;\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = iso_interval_reader_new(a1->image, disk_path, &ivr, byte_count, 0);\n    if ( v7 >= 0 )\n    {\n      v8 = ivr;\n      v9 = byte_count[0] + 4094;\n      if ( byte_count[0] + 2047 >= 0 )\n        v9 = byte_count[0] + 2047;\n      *a3 = v9 >> 11;\n      v7 = iso_interval_reader_keep(a1, v8, 0);\n      iso_interval_reader_destroy(&ivr, 0);\n      v10 = v7 == 0;\n      if ( v7 >= 0 )\n      {\n        v7 = 2;\n        if ( v10 )\n          return v6;\n      }\n    }\n    return (unsigned int)v7;\n  }\n  *a3 = 0;\n  if ( __xstat(1, disk_path, (struct stat *)byte_count) == -1 || (v16 & 0xF000) != 0x8000 )\n    return (unsigned int)-399442290;\n  v12 = v17 + 4094;\n  if ( v17 + 2047 >= 0 )\n    v12 = v17 + 2047;\n  v13 = v12 >> 11;\n  if ( v13 > 0x3FFFFFFF || !v13 )\n    return (unsigned int)-399442290;\n  *a3 = v13;\n  return 1LL;\n}\n",
    "source_code": "static int compute_partition_size(Ecma119Image *t, char *disk_path,\n                                  uint32_t *size, int flag)\n{\n    int ret, keep;\n    off_t num;\n    struct stat stbuf;\n    struct iso_interval_reader *ivr;\n    off_t byte_count;\n\n    if (flag & 1) {\n        ret = iso_interval_reader_new(t->image, disk_path,\n                                      &ivr, &byte_count, 0);\n        if (ret < 0)\n            return ret;\n        *size = (byte_count + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        keep = iso_interval_reader_keep(t, ivr, 0);\n        iso_interval_reader_destroy(&ivr, 0);\n        if (keep < 0)\n            return keep;\n        return ISO_SUCCESS + (keep > 0);\n    }\n\n    *size = 0;\n    ret = stat(disk_path, &stbuf);\n    if (ret == -1)\n        return ISO_BAD_PARTITION_FILE;\n    if (! S_ISREG(stbuf.st_mode))\n        return ISO_BAD_PARTITION_FILE;\n    num = ((stbuf.st_size + 2047) / 2048);\n    if (num > 0x3fffffff || num == 0)\n        return ISO_BAD_PARTITION_FILE;\n    *size = num;\n    return ISO_SUCCESS;\n}",
    "comment": "Calculates the partition size from a disk path or an image based on a specified flag, ensuring valid file attributes and conditions.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the size of a file or directory from an ISO image , adjusting for potential overflows based on specified flags .\n",
    "cpbcs_sum": "Writes a null-terminated string to a binary file, checks for write errors, and retrieves the buffer length if successful.\n",
    "misum_sum": "Retrieves file status information, populates a buffer, and returns success or failure based on the provided flag code.\n",
    "decom_sum": "Determines file size in 2KB blocks, verifying regular file type or using an alternate lookup path when a specific mode flag is set.",
    "cfg_sum": "Determines file size in 2KB blocks for regular files or using directory lookup when flagged, returning computed blocks or specific error codes.",
    "work_score": {
        "hext5": {
            "summary": "| a this function build the following tree, from regular expression a*:",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's single claim about building a tree from a regular expression 'a*' is unrelated to the source code, which computes partition sizes from a disk path and handles file statistics. This is a semantic mismatch, yielding 0 accurate claims.",
                "The summary is entirely unrelated to the source code's purpose. The function computes a partition size based on either reading intervals or stat'ing a file, with validation and error returns, but the summary describes building a tree from a regular expression, which is not present in the code. This misses the primary purpose and all secondary details, and contains inaccurate claims not grounded in the source implementation.",
                "The summary's only claim about building a tree from the regular expression 'a*' is entirely unrelated to the source code, which deals with computing a partition size based on a disk path and optional interval reader logic. This is pure NOISE with no accurate alignment to the code's primary purpose or implementation, providing zero useful insight. The worst failure mode is overwhelming NOISE, leading to no gain in understanding."
            ]
        },
        "bint5": {
            "summary": "Retrieves the size of a file or directory from an ISO image , adjusting for potential overflows based on specified flags .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves the size of a file or directory from an ISO image. The source code actually computes a partition size from either reading via iso_interval_reader or from a file's stat, and it explicitly rejects non-regular files, meaning directories are not handled. Additionally, the overflow handling is only partial and involves block size calculation and bounds checking, not general adjustment based on flags. This introduces inaccuracies in both the type of objects handled and the overflow description, with less than half of the claims matching the code.",
                "The summary incorrectly describes the function as retrieving the size of a file or directory from an ISO image, whereas the source code specifically computes a partition size either from an interval reader or from a regular file on disk, with validation checks. It fails to capture the primary purpose accurately and omits all secondary details such as error handling, block size adjustments, and flag-specific behavior. The mention of 'directory' and 'ISO image' is misleading because the code only handles regular files and does not enumerate directories.",
                "The summary claims the function retrieves the size of a file or directory from an ISO image and adjusts for potential overflows based on flags. In reality, the source code does not handle directories, only files or intervals from an ISO image when a flag is set, and it validates against certain limits rather than adjusting for overflows. This mismatch is a semantic contradiction with the core I/O purpose (FATAL error). There are no accurate, detailed claims to provide benefit."
            ]
        },
        "cpbcs": {
            "summary": "Writes a null-terminated string to a binary file, checks for write errors, and retrieves the buffer length if successful.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes writing a null-terminated string to a binary file, checking for write errors, and retrieving buffer length, which is entirely unrelated to the actual function in the source code. The source handles computing partition size with optional interval reading and file stat checks. None of the claims in the summary align with the code, resulting in 0% accurate claims.",
                "The summary describes writing a string to a binary file and handling write errors, which is entirely unrelated to the source code's actual purpose of computing a partition size from either an interval reader or file metadata, with validation checks for file type and size limits. None of the summary's claims match any critical semantic units from the function, meaning the primary purpose and all secondary details are missed.",
                "The summary is entirely inaccurate, describing string writing to a binary file with error checks and buffer length retrieval, which is unrelated to the actual function that computes partition size from either an interval reader or file stats. This is pure NOISE with no accurate claims, so it provides no useful insight into the code's purpose."
            ]
        },
        "misum": {
            "summary": "Retrieves file status information, populates a buffer, and returns success or failure based on the provided flag code.\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary contains one broad claim that the function retrieves file status information, which is partially accurate for the branch where flag is not set, but omits other behaviors like using iso_interval_reader for the flag set case. The mention of populating a buffer is vague and does not clearly align with actual variable assignments in the code, and the final description of returning success or failure based on the flag is oversimplified and misses specific return conditions. Overall, the majority of the functional details are missing or inaccurately generalized.",
                "The summary vaguely mentions retrieving file status information and returning success or failure based on a flag but fails to capture the primary purpose: computing the partition size from either an interval reader or file stats depending on the flag. It omits critical details such as use of iso_interval_reader functions, size calculations using BLOCK_SIZE or 2048-byte units, validation conditions for file type and size limits, and specific return codes for different error cases. Coverage is minimal and misses both primary purpose and key secondary details.",
                "The summary contains mostly broad, low-information SAFE claims. It mentions retrieving file status information, which corresponds to the `stat` call in the code, and returning success or failure based on a flag, which loosely matches the branch on `flag & 1`. However, it omits key specifics such as how `size` is computed in both branches, the use of `iso_interval_reader` in the flag branch, and detailed error conditions. There are no clear FATAL inaccuracies, but the description is too vague to provide substantive insight, resulting in low gain."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 239376,
    "strip_function_name": "dtls1_get_timeout",
    "strip_decompiled_code": "_QWORD *__fastcall dtls1_get_timeout(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rax\n  __int64 v4; // rax\n  __time_t tv_sec; // rcx\n  __suseconds_t tv_usec; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __time_t v9; // rdx\n  __int64 v10; // rax\n  _QWORD *result; // rax\n  __time_t v12; // rdx\n  struct timeval v13; // [rsp+0h] [rbp-28h] BYREF\n\n  v2 = *(_QWORD *)(a1 + 136);\n  if ( !*(_QWORD *)(v2 + 840) && !*(_QWORD *)(v2 + 848) )\n    return 0LL;\n  gettimeofday(&v13, 0LL);\n  v4 = *(_QWORD *)(a1 + 136);\n  tv_sec = v13.tv_sec;\n  if ( *(_QWORD *)(v4 + 840) < v13.tv_sec )\n    goto LABEL_10;\n  tv_usec = v13.tv_usec;\n  if ( *(_QWORD *)(v4 + 840) == v13.tv_sec && *(_QWORD *)(v4 + 848) <= v13.tv_usec )\n    goto LABEL_10;\n  v7 = *(_QWORD *)(v4 + 840);\n  *a2 = v7;\n  v8 = *(_QWORD *)(v4 + 848);\n  v9 = v7 - tv_sec;\n  *a2 = v9;\n  v10 = v8 - tv_usec;\n  a2[1] = v10;\n  if ( v10 < 0 )\n  {\n    v12 = v9 - 1;\n    a2[1] = v10 + 1000000;\n    *a2 = v12;\n    result = a2;\n    if ( v12 )\n      return result;\n  }\n  else\n  {\n    result = a2;\n    if ( v9 )\n      return result;\n  }\n  if ( (__int64)a2[1] <= 14999 )\n  {\nLABEL_10:\n    *a2 = 0LL;\n    a2[1] = 0LL;\n    return a2;\n  }\n  return result;\n}\n",
    "function_name": "dtls1_get_timeout",
    "decompiled_code": "_QWORD *__fastcall dtls1_get_timeout(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rax\n  __int64 v4; // rax\n  __time_t tv_sec; // rcx\n  __suseconds_t tv_usec; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __time_t v9; // rdx\n  __int64 v10; // rax\n  _QWORD *result; // rax\n  __time_t v12; // rdx\n  struct timeval v13; // [rsp+0h] [rbp-28h] BYREF\n\n  v2 = *(_QWORD *)(a1 + 136);\n  if ( !*(_QWORD *)(v2 + 840) && !*(_QWORD *)(v2 + 848) )\n    return 0LL;\n  gettimeofday(&v13, 0LL);\n  v4 = *(_QWORD *)(a1 + 136);\n  tv_sec = v13.tv_sec;\n  if ( *(_QWORD *)(v4 + 840) < v13.tv_sec )\n    goto LABEL_10;\n  tv_usec = v13.tv_usec;\n  if ( *(_QWORD *)(v4 + 840) == v13.tv_sec && *(_QWORD *)(v4 + 848) <= v13.tv_usec )\n    goto LABEL_10;\n  v7 = *(_QWORD *)(v4 + 840);\n  *a2 = v7;\n  v8 = *(_QWORD *)(v4 + 848);\n  v9 = v7 - tv_sec;\n  *a2 = v9;\n  v10 = v8 - tv_usec;\n  a2[1] = v10;\n  if ( v10 < 0 )\n  {\n    v12 = v9 - 1;\n    a2[1] = v10 + 1000000;\n    *a2 = v12;\n    result = a2;\n    if ( v12 )\n      return result;\n  }\n  else\n  {\n    result = a2;\n    if ( v9 )\n      return result;\n  }\n  if ( (__int64)a2[1] <= 14999 )\n  {\nLABEL_10:\n    *a2 = 0LL;\n    a2[1] = 0LL;\n    return a2;\n  }\n  return result;\n}\n",
    "source_code": "\nstruct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)\n\t{\n\tstruct timeval timenow;\n\n\t/* If no timeout is set, just return NULL */\n\tif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)\n\t\t{\n\t\treturn NULL;\n\t\t}\n\n\t/* Get current time */\n\tget_current_time(&timenow);\n\n\t/* If timer already expired, set remaining time to 0 */\n\tif (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\n\t\t(s->d1->next_timeout.tv_sec == timenow.tv_sec &&\n\t\t s->d1->next_timeout.tv_usec <= timenow.tv_usec))\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\treturn timeleft;\n\t\t}\n\n\t/* Calculate time left until timer expires */\n\tmemcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n\ttimeleft->tv_sec -= timenow.tv_sec;\n\ttimeleft->tv_usec -= timenow.tv_usec;\n\tif (timeleft->tv_usec < 0)\n\t\t{\n\t\ttimeleft->tv_sec--;\n\t\ttimeleft->tv_usec += 1000000;\n\t\t}\n\n\t/* If remaining time is less than 15 ms, set it to 0\n\t * to prevent issues because of small devergences with\n\t * socket timeouts.\n\t */\n\tif (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\t}\n\t\n\n\treturn timeleft;\n\t}",
    "comment": "Calculates the remaining timeout for a DTLS connection and returns a struct timeval with the time left until expiration.",
    "hext5_sum": "p series representation.",
    "bint5_sum": "Calculates and returns the timeout in milliseconds for DTLS connections , considering various connection states and timeouts .\n",
    "cpbcs_sum": "Retrieves the current time from a DTLS timeout duration or adjusts it if no progress is needed for future writing if necessary.\n",
    "misum_sum": "Initializes and retrieves a DTLS timeout duration for a task, adjusting timeout time based on current time and handling overflow conditions.\n",
    "decom_sum": "Calculates remaining time until a stored DTLS timeout expires and returns zero if the deadline has passed or is within 15 milliseconds.",
    "cfg_sum": "Calculates the remaining time until a scheduled DTLS event and resets the timeout to zero if the event is due or expired.",
    "work_score": {
        "hext5": {
            "summary": "p series representation.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary 'p series representation.' does not contain any fact-based claims about the source code's behavior or implementation. It fails to reference any specific function, logic, or condition from the code, making it entirely unrelated to the source. Since none of the claims (there are effectively zero) are accurate or relevant, the alignment is nonexistent.",
                "The summary provided is vague and unrelated to the function\u2019s actual purpose or behavior in the source code. It does not mention that the function calculates and returns the remaining time until a DTLS timeout, handles expired timers, adjusts for negative microseconds, or applies a minimum 15 ms cutoff. Since the primary purpose and all key secondary details are missed, there is no alignment with the evaluation steps.",
                "The summary is vague and does not contain any fact-based claims about the source code\u2019s purpose, inputs, outputs, or logic. It is pure NOISE with no alignment to the implementation, offering no useful or accurate insights for the reader."
            ]
        },
        "bint5": {
            "summary": "Calculates and returns the timeout in milliseconds for DTLS connections , considering various connection states and timeouts .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates and returns the timeout in milliseconds for DTLS connections, but the source code operates with struct timeval to compute time differences in seconds and microseconds, not explicitly in milliseconds. It does not mention 'various connection states' \u2014 it only handles specific timer expiration and small deviation adjustments. This introduces significant inaccuracies, making the majority of claims misaligned with the source implementation.",
                "The summary incorrectly states that the function returns a timeout in milliseconds for DTLS connections and considers various connection states. The source code operates with struct timeval to compute remaining time until expiry, potentially returning NULL or zeroed time, and it does not convert to milliseconds or explicitly consider multiple connection states beyond timeout checks. It misses key secondary details such as handling expired timers, adjustments for microseconds, and the special case for time less than 15 ms, and the primary purpose is misstated.",
                "The summary incorrectly states that the function returns the timeout in milliseconds, while the source code returns a struct timeval (seconds and microseconds). This is a FATAL error affecting a key aspect of the primary purpose and output type. There are no accurate, high-value specifics to offset this, making the overall description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the current time from a DTLS timeout duration or adjusts it if no progress is needed for future writing if necessary.\n",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary's claim that the function retrieves current time from a DTLS timeout duration is loosely related, but the source code shows it calculates remaining time until a timeout, not directly retrieving from a duration. The mention of 'adjusts it if no progress is needed for future writing' is inaccurate and does not reflect any code logic about writing progress; instead, the code sets timeleft to zero under specific timeout or remaining time conditions. Overall, less than half of the claims align with the actual implementation.",
                "The summary vaguely suggests retrieving current time from a DTLS timeout, but it fails to accurately capture the function\u2019s primary purpose of calculating the remaining time until the next timeout or returning NULL if none is set. It omits key details such as handling expired timers, adjusting for negative microseconds, and the specific 15 ms threshold optimization. The phrasing about 'no progress' and 'future writing' is inaccurate and not grounded in the source code semantics.",
                "The summary contains vague and inaccurate phrasing that does not align with the source code's actual behavior. It omits key details such as checking if no timeout is set, computing remaining time until expiry, handling expired timers, and adjusting small time differences for socket timeouts. The phrase 'retrieves the current time from a DTLS timeout duration' is misleading, as the function calculates remaining time rather than retrieving the current time from a stored duration. The 'no progress is needed for future writing' part is unrelated to the code logic, constituting NOISE. The worst failure mode is excessive NOISE, with almost no accurate, specific claims, leading to low informational value."
            ]
        },
        "misum": {
            "summary": "Initializes and retrieves a DTLS timeout duration for a task, adjusting timeout time based on current time and handling overflow conditions.\n",
            "score": [
                0.2,
                0.5,
                0.5
            ],
            "reason": [
                "The summary claims that the function initializes and retrieves a DTLS timeout duration and handles overflow conditions. The source code does retrieve the remaining DTLS timeout based on the current time, but it does not perform any initialization\u2014it only returns NULL if no timeout is set\u2014and it does not handle overflow conditions. Instead, it handles small time differences and expiration cases. Thus, less than half of the claims are accurate.",
                "The summary captures the primary purpose of retrieving and adjusting a DTLS timeout based on the current time, which is consistent with the source code. However, it misses key secondary details such as returning NULL if no timeout is set, zeroing time if expired, handling small remaining times under 15 ms, and the specific time calculation adjustments when microseconds are negative. The mention of 'overflow conditions' is vague and not clearly tied to the actual logic, reducing completeness.",
                "The summary captures that the function retrieves a DTLS timeout and adjusts it based on the current time, which is accurate. However, it inaccurately mentions handling overflow conditions, which is not evident in the source code\u2014the code handles negative microseconds by adjusting seconds and microseconds, but no true overflow scenario. The accurate portion is broad and lacks detailed specifics such as the conditions for returning NULL, setting timeleft to zero, or the 15 ms adjustment behavior. Overall, low gain and minor inaccuracy make it a safe but low-value summary, with the worst issue being low informational detail rather than a fatal error."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5123408,
    "strip_function_name": "sub_4E2D50",
    "strip_decompiled_code": "__int64 __fastcall sub_4E2D50(__int64 a1, _QWORD *a2, int *a3, char a4)\n{\n  _QWORD *v5; // rax\n  _QWORD *v6; // rbp\n  unsigned int v7; // r15d\n  _DWORD *v8; // rax\n  _DWORD *v9; // rbx\n  int v10; // eax\n  unsigned __int8 *v12; // r12\n  int v13; // eax\n  void *v14; // rax\n\n  *a2 = 0LL;\n  v5 = sub_4E19C0(0x11008uLL, 1uLL);\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = -1;\n    v8 = sub_4E19C0(0xC8uLL, 1uLL);\n    v9 = v8;\n    if ( v8 )\n    {\n      sub_4F3790(v8, &unk_7716D8, 10LL);\n      v10 = *a3;\n      v9[40] = 1;\n      *((_QWORD *)v9 + 21) = v6;\n      v7 = 0;\n      v9[6] = v10;\n      *((_BYTE *)v9 + 7) = BYTE1(v10);\n      *((_BYTE *)v9 + 8) = v10;\n      v6[8704] = 0LL;\n      v9[5] = 1;\n      (*(void (__fastcall **)(__int64, _DWORD *))(a1 + 2072))(a1, v9);\n      if ( !v9[39] )\n      {\n        v12 = (unsigned __int8 *)*((_QWORD *)v9 + 21);\n        v13 = v12[1] + (*v12 << 8);\n        *a3 = v13 + 2;\n        if ( (a4 & 1) != 0 || v13 + 2 <= 21 )\n        {\n          v7 = 1;\n        }\n        else\n        {\n          v7 = -1;\n          v14 = sub_4E19C0(1uLL, v13 - 2);\n          *a2 = v14;\n          if ( v14 )\n          {\n            v7 = 1;\n            memcpy(v14, v12 + 4, *a3 - 4);\n          }\n        }\n      }\n      free(v9);\n    }\n    free(v6);\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n  return v7;\n}\n",
    "function_name": "mmc_get_leadin_text_al",
    "decompiled_code": "__int64 __fastcall mmc_get_leadin_text_al(__int64 a1, _QWORD *a2, int *a3, char flag)\n{\n  buffer *v5; // rax\n  buffer *v6; // rbp\n  unsigned int v7; // r15d\n  command *v8; // rax\n  command *v9; // rbx\n  int v10; // eax\n  buffer *page; // r12\n  int v13; // eax\n  void *v14; // rax\n\n  *a2 = 0LL;\n  v5 = (buffer *)burn_alloc_mem(0x11008uLL, 1uLL, 0);\n  if ( v5 )\n  {\n    v6 = v5;\n    v7 = -1;\n    v8 = (command *)burn_alloc_mem(0xC8uLL, 1uLL, 0);\n    v9 = v8;\n    if ( v8 )\n    {\n      scsi_init_command(v8, MMC_GET_LEADTEXT, 10);\n      v10 = *a3;\n      v9->retry = 1;\n      v9->page = v6;\n      v7 = 0;\n      v9->dxfer_len = v10;\n      v9->opcode[7] = BYTE1(v10);\n      v9->opcode[8] = v10;\n      *(_QWORD *)&v6->sectors = 0LL;\n      v9->dir = 1;\n      (*(void (__fastcall **)(__int64, command *))(a1 + 2072))(a1, v9);\n      if ( !v9->error )\n      {\n        page = v9->page;\n        v13 = page->data[1] + (page->data[0] << 8);\n        *a3 = v13 + 2;\n        if ( (flag & 1) != 0 || v13 + 2 <= 21 )\n        {\n          v7 = 1;\n        }\n        else\n        {\n          v7 = -1;\n          v14 = burn_alloc_mem(1uLL, v13 - 2, 0);\n          *a2 = v14;\n          if ( v14 )\n          {\n            v7 = 1;\n            memcpy(v14, &page->data[4], *a3 - 4);\n          }\n        }\n      }\n      free(v9);\n    }\n    free(v6);\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n  return v7;\n}\n",
    "source_code": "static int mmc_get_leadin_text_al(struct burn_drive *d,\n                                  unsigned char **text_packs, int *alloc_len,\n                                  int flag)\n{\n\tstruct buffer *buf = NULL;\n\tstruct command *c = NULL;\n\tunsigned char *data;\n\tint ret, data_length;\n\n\t*text_packs = NULL;\n\n\tBURN_ALLOC_MEM(buf, struct buffer, 1);\n\tBURN_ALLOC_MEM(c, struct command, 1);\n\n\tscsi_init_command(c, MMC_GET_LEADTEXT, sizeof(MMC_GET_LEADTEXT));\n\tc->dxfer_len = *alloc_len;\n\tc->opcode[7]= (c->dxfer_len >> 8) & 0xff;\n\tc->opcode[8]= c->dxfer_len & 0xff;\n\tc->retry = 1;\n\tc->page = buf;\n\tc->page->bytes = 0;\n\tc->page->sectors = 0;\n\n\tc->dir = FROM_DRIVE;\n\td->issue_command(d, c);\n\tif (c->error)\n\t\t{ret = 0; goto ex;}\n\n\tdata = c->page->data;\t\n\tdata_length = (data[0] << 8) + data[1];\n\t*alloc_len = data_length + 2;\n\tif (*alloc_len >= 22 && !(flag & 1)) {\n\t\tBURN_ALLOC_MEM(*text_packs, unsigned char, *alloc_len - 4);\n\t\tmemcpy(*text_packs, data + 4, *alloc_len - 4);\n\t}\n\tret = 1;\t\nex:;\n\tBURN_FREE_MEM(c);\n\tBURN_FREE_MEM(buf);\n\treturn ret;\n}",
    "comment": "Retrieves lead-in text from a drive and allocates memory for the text if the conditions are met, returning success or failure.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Reads a CD-TEXT pack from a burn drive , allocating memory for text packs and returning the pack size or an error code .\n",
    "cpbcs_sum": "Writes the track to a burn drive, initializes an object if necessary, and handles exclusive read errors.\n",
    "misum_sum": "Reads the contents of a burn drive, initializes a drive, and registers a media capacity if it's a local type.\n",
    "decom_sum": "Allocates buffers, sends a prepared command structure to a device, retrieves its response, and optionally copies payload data into the provided output buffer.",
    "cfg_sum": "Allocates and links memory structures, invokes a handler to populate them, processes retrieved data based on flags, and copies payload into output buffer when valid.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' is vague and does not accurately reflect the function's behavior in the source code, which involves issuing a SCSI command, processing data, and allocating memory for text packs. The claim does not target any actual code semantics, making it irrelevant to the implementation.",
                "The summary only states 'push a pointer type,' which is vague and does not describe the primary purpose or behavior of the function. It fails to capture that the function issues a SCSI command to retrieve lead-in text from a drive, processes the returned data, allocates memory for text packs, and handles errors. No specific details match the source code, and critical semantic units are entirely missed.",
                "The summary's single claim 'push a pointer type' is highly vague and does not correspond directly to the code's semantics, which involve preparing and issuing a SCSI command, handling data transfer, and allocating memory for lead-in text. This constitutes NOISE with no specific alignment to any meaningful aspect of the source. There are no factual, detailed matches, resulting in low gain and overwhelming irrelevance."
            ]
        },
        "bint5": {
            "summary": "Reads a CD-TEXT pack from a burn drive , allocating memory for text packs and returning the pack size or an error code .\n",
            "score": [
                0.8,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function reads a CD-TEXT pack from a burn drive and allocates memory for text packs, which matches the source code that issues a MMC_GET_LEADTEXT command, processes returned data, and conditionally allocates memory for text packs. However, the claim that it returns the pack size is inaccurate; the function returns 1 on success or 0 on error, while updating alloc_len separately for size information. Most claims are accurate except the return value detail, so overall accuracy is above 80%.",
                "The summary captures the primary purpose\u2014reading CD-TEXT data from a burn drive\u2014but inaccurately states that the function returns the pack size; the source code returns a success/failure flag (1 or 0). It also omits key secondary details such as initializing and issuing a MMC_GET_LEADTEXT SCSI command, setting dxfer_len and opcodes, specific memory allocation conditions based on alloc_len and flag, and error handling when c->error is set. These omissions reduce completeness despite partially covering the main intent.",
                "The summary claims the function reads a CD-TEXT pack, allocates memory, and returns the pack size or error code. In the source, the function initializes a SCSI command to get lead-in text, allocates memory conditionally, and returns 1 or 0 (success/error), not the pack size. The misunderstanding of the return value is a FATAL error impacting key I/O semantics, while the allocation part is accurate but broad."
            ]
        },
        "cpbcs": {
            "summary": "Writes the track to a burn drive, initializes an object if necessary, and handles exclusive read errors.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes writing a track, object initialization, and handling exclusive read errors, none of which match the source code. The function actually prepares and sends a MMC_GET_LEADTEXT command to a burn drive, allocates buffers, parses returned data length, and copies text packs when appropriate. All claims in the summary are inaccurate and unrelated to the function\u2019s true behavior.",
                "The summary's claims are inaccurate: it describes writing a track, object initialization, and handling exclusive read errors, none of which match the source code. The function in the source code retrieves lead-in text data from a burn drive via a SCSI command, manages memory buffers, processes returned data length, and copies text packs conditionally. The PRIMARY PURPOSE is missed entirely, and no accurate claims correspond to the CSU_LIST, resulting in no coverage of actual behavior.",
                "The summary contains multiple inaccurate claims. It describes writing a track to a burn drive and handling exclusive read errors, which contradicts the source code\u2019s actual purpose of issuing a MMC_GET_LEADTEXT command to read lead-in text from the drive. There is no track writing, and no mention of exclusive read errors; initialization in the code refers to buffer and command structures, not a generic object. These are FATAL inaccuracies touching primary purpose and key I/O, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Reads the contents of a burn drive, initializes a drive, and registers a media capacity if it's a local type.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains claims about reading a burn drive, initializing a drive, and registering media capacity for a local type, none of which match the source code. The source code issues a specific MMC_GET_LEADTEXT SCSI command to retrieve lead-in text, allocates memory for buffers, processes returned data, and copies text packs if conditions are met. The described actions in the summary are unrelated, making all claims inaccurate.",
                "The summary is inaccurate because it does not reflect the primary purpose of the function, which is to issue a MMC_GET_LEADTEXT SCSI command to retrieve lead-in text data from the burn drive. Instead, it incorrectly describes initializing a drive and registering media capacity, which are unrelated to the source code's semantics. No claims in the summary match the actual observable behavior or secondary details present in the source code.",
                "The summary contains multiple [INACCURATE] claims about the function's purpose: it does not initialize a drive nor register media capacity, and it does not broadly read general contents of a burn drive; instead, it issues a specific SCSI 'GET LEADTEXT' command to retrieve text data from the lead-in area. These inaccuracies target the primary purpose and I/O behavior of the code, making them FATAL errors. No accurate or high-gain details are provided to counterbalance this."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580241712,
    "strip_function_name": "sub_FFFFFFFF81154F30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81154F30(\n        __int64 a1,\n        __int64 a2,\n        int a3,\n        int a4,\n        int a5,\n        int a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  _DWORD *v14; // r12\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n  int v19; // edx\n  int v20; // ecx\n  int v21; // r8d\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  __int64 result; // rax\n  _DWORD *v26; // rax\n  __int64 *v27; // [rsp+0h] [rbp-28h] BYREF\n  _DWORD *v28; // [rsp+8h] [rbp-20h]\n\n  v14 = *(_DWORD **)(__readgsqword(0xA7C0u) + 1328);\n  if ( !(unsigned __int8)sub_FFFFFFFF81047700(*(_QWORD *)(a2 + 32), 0x15u, a3, a4, a5, a6)\n    || !(unsigned __int8)sub_FFFFFFFF81047B40(0x12u, 21LL, v15, v16, v17, v18)\n    || !(unsigned __int8)sub_FFFFFFFF81047B40(0x15u, 21LL, v19, v20, v21, v22) )\n  {\n    return 0xFFFFFFFFLL;\n  }\n  result = 4294967274LL;\n  if ( *v14 == 1 )\n  {\n    _InterlockedIncrement((volatile signed __int32 *)a2);\n    sub_FFFFFFFF81154B30(*(_QWORD *)(a1 + 24), a7, a8, a9, a10, v23, v24, a13, a14);\n    *(_QWORD *)(a1 + 24) = a2;\n    v26 = *(_DWORD **)(*(_QWORD *)(a2 + 8) + 32LL);\n    v27 = (__int64 *)(*(_QWORD *)(a2 + 8) + 32LL);\n    v28 = v26;\n    sub_FFFFFFFF8113F300(&v27);\n    while ( (*v28 & 0x10000) != 0 && (unsigned int)sub_FFFFFFFF8113E1B0(&v27) )\n      ;\n    sub_FFFFFFFF81162700(v14, &v27);\n    sub_FFFFFFFF81162690(v14, &v27);\n    sub_FFFFFFFF8113E0F0(&v27);\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "mntns_install",
    "decompiled_code": "__int64 __fastcall mntns_install(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _DWORD *v10; // r12\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 result; // rax\n  _DWORD *v18; // rax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // [rsp+0h] [rbp-28h] BYREF\n  _DWORD *v24; // [rsp+8h] [rbp-20h]\n\n  v10 = *(_DWORD **)(__readgsqword(0xA7C0u) + 1328);\n  if ( !(unsigned __int8)ns_capable(*(_QWORD *)(a2 + 32), 0x15u, a3, a4, a5, a6, a7, a8, a9, a10)\n    || !(unsigned __int8)nsown_capable(0x12u, a3, a4, a5, a6, v11, v12, a9, a10)\n    || !(unsigned __int8)nsown_capable(0x15u, a3, a4, a5, a6, v13, v14, a9, a10) )\n  {\n    return 0xFFFFFFFFLL;\n  }\n  result = 4294967274LL;\n  if ( *v10 == 1 )\n  {\n    _InterlockedIncrement((volatile signed __int32 *)a2);\n    put_mnt_ns(*(_QWORD *)(a1 + 24), a3, a4, a5, a6, v15, v16, a9, a10);\n    *(_QWORD *)(a1 + 24) = a2;\n    v18 = *(_DWORD **)(*(_QWORD *)(a2 + 8) + 32LL);\n    v23 = (__int64 *)(*(_QWORD *)(a2 + 8) + 32LL);\n    v24 = v18;\n    path_get((__int64 *)&v23);\n    while ( (*v24 & 0x10000) != 0\n         && (unsigned int)follow_down_one(\n                            &v23,\n                            (volatile signed __int32 *)((char *)&qword_10 + 5),\n                            a3,\n                            a4,\n                            a5,\n                            a6,\n                            v19,\n                            v20,\n                            a9,\n                            a10) )\n      ;\n    set_fs_pwd((__int64)v10, (__int64 *)&v23);\n    set_fs_root((__int64)v10, (__int64 *)&v23);\n    path_put((__int64 *)&v23, (volatile signed __int32 *)&v23, a3, a4, a5, a6, v21, v22, a9, a10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int mntns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = ns;\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !nsown_capable(CAP_SYS_CHROOT) ||\n\t    !nsown_capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}",
    "comment": "Validates permissions, checks filesystem usage, updates the mount namespace in the nsproxy, and sets the current process's root and working directory.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Creates a new file in the specified directory with given flags , ensuring security checks and notifying the filesystem of the creation event .\n",
    "cpbcs_sum": "Converts a process to a file descriptor in a directory, ensuring only processes if the namespace is valid.\n",
    "misum_sum": "Adds a new mount to a process if the current time is in the user namespace and the user has a valid mount context.\n",
    "decom_sum": "Validates multiple conditions on input parameters, then updates linked data structures and processes queued items when the system state flag equals one.",
    "cfg_sum": "Validates multiple input parameters, updates linked data structures, performs synchronized processing steps, and returns specific error codes or success based on validation and processing outcomes.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes returning a buffer or null based on a Unicode character name lookup in uppercase ASCII, which is entirely unrelated to the source code that handles mounting a namespace, capability checks, and setting process filesystem root and pwd. All claims are inaccurate as they do not target the code's semantics.",
                "The summary describes functionality related to looking up Unicode character names, which is completely unrelated to the source code\u2019s actual purpose of installing a mount namespace, handling permissions, and updating filesystem root and working directory. The claims do not target the source code semantics and thus provide no accurate coverage of primary or secondary details.",
                "The summary's claims refer to looking up a Unicode character's name in uppercase ASCII and returning a buffer or null, which is entirely unrelated to the source code. The source function installs a mount namespace with capability checks and updates the process's root and working directories, not character name lookup. All claims are NOISE, overwhelming the content, providing no relevant or accurate insight."
            ]
        },
        "bint5": {
            "summary": "Creates a new file in the specified directory with given flags , ensuring security checks and notifying the filesystem of the creation event .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function creates a new file with specified flags, performs security checks, and notifies the filesystem of the creation. The source code actually changes the mount namespace for a process after performing capability checks, without any file creation or filesystem notification. Since the main claims directly contradict the implementation, none are accurate.",
                "The summary describes creating a file with flags, performing security checks, and notifying the filesystem, which directly contradicts the actual source code. The source code installs a mount namespace into a process\u2019s nsproxy after capability checks and updates the process's root and working directory \u2014 it does not create files or handle filesystem notifications. The primary purpose and key secondary details from the code are entirely missed, and the summary contains unrelated functionality.",
                "The summary claims the function creates a new file with given flags and notifies the filesystem of creation, which is completely unrelated to the source code. The actual code changes the mount namespace of a process after performing capability and reference count checks, and updates the root and working directory paths. This is a FATAL error targeting the primary purpose, leading to a high negative impact with no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Converts a process to a file descriptor in a directory, ensuring only processes if the namespace is valid.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's main claim about converting a process to a file descriptor in a directory is inaccurate, as the source function installs a mount namespace into a process, updating its root and working directory, not converting it to a file descriptor. The mention of ensuring the namespace is valid is loosely related to permission checks but lacks specificity and introduces unrelated semantics. Overall, the majority of claims contradict the code's actual behavior.",
                "The summary does not capture the primary purpose or observable behavior from the source code. The function installs a mount namespace into a process's namespace proxy after checking specific capabilities, user count constraints, and updating root and working directory paths. The summary incorrectly describes converting a process to a file descriptor in a directory, which is unrelated to the actual semantics, and omits all key secondary details such as permission checks and updating fs_struct paths.",
                "The summary's main claim that the function converts a process to a file descriptor in a directory is inaccurate, as the source code performs a mount namespace installation, sets root and working directories, and enforces capability checks, but has no logic related to creating file descriptors from processes. This is a FATAL error about the primary purpose. There are no accurate claims present, leading to high negative impact and zero net benefit."
            ]
        },
        "misum": {
            "summary": "Adds a new mount to a process if the current time is in the user namespace and the user has a valid mount context.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary introduces concepts such as 'current time in the user namespace' and 'valid mount context' which are not present in the source code. The implementation focuses on capability checks (CAP_SYS_ADMIN, CAP_SYS_CHROOT), ensuring fs->users equals 1, and updating the mount namespace and process root/pwd, with no reference to time-based conditions. None of the claims align accurately with the source logic, resulting in entirely inaccurate interpretation.",
                "The summary\u2019s claim about adding a new mount based on current time is inaccurate and not grounded in the source code semantics. The function mntns_install checks user capabilities, verifies fs->users count, updates the nsproxy\u2019s mount namespace, adjusts root and working directory paths, but has no logic related to current time. It also omits critical details such as capability checks (CAP_SYS_ADMIN, CAP_SYS_CHROOT), reference counting of mount namespaces, and path adjustments, thus missing the primary purpose entirely.",
                "The summary introduces incorrect conditions: it mentions the current time and user namespace, which are not present in the source code. The actual code checks for specific capabilities (CAP_SYS_ADMIN, CAP_SYS_CHROOT) in the mount and owning namespaces, and verifies fs->users == 1 before replacing the process's mount namespace and updating root/pwd. The mismatch is a FATAL error on the primary purpose and key I/O, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582904640,
    "strip_function_name": "sub_FFFFFFFF813DF140",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813DF140(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // r13\n  __int64 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned __int64 v17; // kr00_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v10 = __readgsqword(0xA760u);\n  v11 = *(__int64 **)(*(_QWORD *)(a1 + 24) + 840LL);\n  sub_FFFFFFFF8138EC40(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10001, a3, a4, a5, a6, a7, a8, a9, a10);\n  sub_FFFFFFFF8138F4E0(v11, (unsigned int)&unk_12198, 0LL, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = sub_FFFFFFFF81042910(50) + qword_FFFFFFFF81CC2000 + 1;\n  while ( (sub_FFFFFFFF8138E6A0((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n  {\n    if ( v14 - qword_FFFFFFFF81CC2000 < 0 )\n    {\n      if ( (sub_FFFFFFFF8138E6A0((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n        sub_FFFFFFFF81379A60(\n          (int)\"gen6_bsd_ring_write_tail\",\n          (__int64)\"timed out waiting for the BSD ring to wake up\\n\",\n          a3,\n          a4,\n          a5,\n          a6,\n          v15,\n          v16,\n          a9,\n          a10);\n      break;\n    }\n    if ( (*(_DWORD *)(v10 - 8124) & 0xEFFFFFFF) != 0 || (v17 = __readeflags(), (v17 & 0x200) == 0) )\n      _mm_pause();\n    else\n      sub_FFFFFFFF8104BD50(1);\n  }\n  sub_FFFFFFFF8138EC40(v11, *(_DWORD *)(a1 + 12) + 48, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n  return sub_FFFFFFFF8138EC40(\n           v11,\n           (unsigned int)&unk_12050,\n           (unsigned int)&unk_10000,\n           a3,\n           a4,\n           a5,\n           a6,\n           v18,\n           v19,\n           a9,\n           a10);\n}\n",
    "function_name": "gen6_bsd_ring_write_tail",
    "decompiled_code": "void __fastcall gen6_bsd_ring_write_tail(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // r13\n  volatile signed __int16 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // r12\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  unsigned __int64 v17; // kr00_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  v10 = __readgsqword(0xA760u);\n  v11 = *(volatile signed __int16 **)(*(_QWORD *)(a1 + 24) + 840LL);\n  i915_write32(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10001, a3, a4, a5, a6, a7, a8, a9, a10);\n  i915_write64(v11, (unsigned int)&unk_12198, 0LL, a3, a4, a5, a6, v12, v13, a9, a10);\n  v14 = msecs_to_jiffies(50) + _vvar_beginning_hack + 1;\n  while ( (i915_read32((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n  {\n    if ( v14 - _vvar_beginning_hack < 0 )\n    {\n      if ( (i915_read32((__int64)v11, (unsigned int)&unk_12050) & 8) != 0 )\n        drm_err(\n          (__int64)\"gen6_bsd_ring_write_tail\",\n          (__int64)\"timed out waiting for the BSD ring to wake up\\n\",\n          a3,\n          a4,\n          a5,\n          a6,\n          v15,\n          v16,\n          a9,\n          a10);\n      break;\n    }\n    if ( (*(_DWORD *)(v10 - 8124) & 0xEFFFFFFF) != 0 || (v17 = __readeflags(), (v17 & 0x200) == 0) )\n      _mm_pause();\n    else\n      msleep(1, (__int64)&unk_12050, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  i915_write32(v11, *(_DWORD *)(a1 + 12) + 48, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n  i915_write32(v11, (unsigned int)&unk_12050, (unsigned int)&unk_10000, a3, a4, a5, a6, v18, v19, a9, a10);\n}\n",
    "source_code": "\n\nstatic void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,\n\t\t\t\t     u32 value)\n{\n\tdrm_i915_private_t *dev_priv = ring->dev->dev_private;\n\n       /* Every tail move must follow the sequence below */\n\n\t/* Disable notification that the ring is IDLE. The GT\n\t * will then assume that it is busy and bring it out of rc6.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n\n\t/* Clear the context id. Here be magic! */\n\tI915_WRITE64(GEN6_BSD_RNCID, 0x0);\n\n\t/* Wait for the ring not to be idle, i.e. for it to wake up. */\n\tif (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &\n\t\t      GEN6_BSD_SLEEP_INDICATOR) == 0,\n\t\t     50))\n\t\tDRM_ERROR(\"timed out waiting for the BSD ring to wake up\\n\");\n\n\t/* Now that the ring is fully powered up, update the tail */\n\tI915_WRITE_TAIL(ring, value);\n\tPOSTING_READ(RING_TAIL(ring->mmio_base));\n\n\t/* Let the ring send IDLE messages to the GT again,\n\t * and so let it sleep to conserve power when idle.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n}",
    "comment": "Updates the tail of the BSD ring buffer after ensuring the ring is active and managing power-saving notifications.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Disables vertical blanking interrupts for a specified display pipe by clearing the interrupt enable bit in the hardware register .\n",
    "cpbcs_sum": "Displays the current graphics context ID of the Intel graphics device and schedules a response to the associated with the DRM device.\n",
    "misum_sum": "The function disables GPU cache invalidation by checking for changes in the pipeline's display interfaces, handling destination-specific devices and ensuring proper synchronization.\n",
    "decom_sum": "Writes commands to the Gen6 BSD hardware ring and waits for it to become ready, aborting with a timeout if it stays inactive.",
    "cfg_sum": "Writes commands to a hardware processing ring, waits for it to become ready with timeout handling, then issues subsequent configuration and execution commands.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary makes claims about replacing control characters, using a static buffer, and handling Unicode conversion when enabled. None of these behaviors are present in the provided source code, which deals with updating a BSD ring tail and power management in GPU hardware. All claims are unrelated to the code\u2019s semantics, making them inaccurate.",
                "The summary describes string processing with control character escaping, static buffers, and Unicode handling, which is entirely unrelated to the actual source function that manages GPU BSD ring tail updates, power state control, and wake-up sequencing. None of the summary\u2019s claims match the primary purpose or secondary details of the source code, making all claims inaccurate and resulting in no coverage.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display are entirely unrelated to the source code, which manages power states and tail pointer updates for a BSD ring buffer in a GPU. All extracted claims are NOISE, overwhelming any accurate content, resulting in no alignment with the source implementation."
            ]
        },
        "bint5": {
            "summary": "Disables vertical blanking interrupts for a specified display pipe by clearing the interrupt enable bit in the hardware register .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes disabling vertical blanking interrupts for a display pipe, which is unrelated to the source code. The source implements `gen6_bsd_ring_write_tail`, handling BSD ring wake-up, tail updates, and power state transitions, without any logic about vertical blanking or display pipe interrupts. All claims in the summary are inaccurate with respect to the actual code.",
                "The summary is entirely inaccurate: it describes disabling vertical blanking interrupts for a display pipe, which is unrelated to the actual function. The source code handles BSD ring tail writes, modifies power management control bits, clears context IDs, waits for the ring to wake, updates the tail register, and restores idle notifications. The primary purpose and all secondary details are missed, with no correct claim matching the implementation.",
                "The summary claims the function disables vertical blanking interrupts for a display pipe, which is unrelated to the source code's actual behavior. The source code handles BSD ring tail updates, involving power state manipulation and register writes for ring wake-up, not vertical blanking interrupts. This is a direct semantic contradiction to the primary purpose, making it a FATAL error that misrepresents the core functionality."
            ]
        },
        "cpbcs": {
            "summary": "Displays the current graphics context ID of the Intel graphics device and schedules a response to the associated with the DRM device.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims are inaccurate compared to the source code. The function does not display the current graphics context ID; instead, it explicitly clears it to 0. It also does not schedule a response related to the DRM device, but rather manages the BSD ring's tail position and related power state transitions. None of the claims match the actual source implementation, resulting in no accurate matches.",
                "The summary claims the function displays the current graphics context ID and schedules a response, which does not match the source code. The source code sequence disables idle notifications, clears the context ID, waits for the ring to wake, writes the ring tail, and re-enables idle notifications. The primary purpose of updating the BSD ring tail and handling power state transitions is entirely missed, and the described behavior is inaccurate.",
                "The summary claims the function displays the current graphics context ID and schedules a response for the DRM device. In reality, the code clears the context ID, powers up the BSD ring, writes the tail pointer, and restores sleep notifications. These are specific operational steps unrelated to displaying the context ID or scheduling a DRM device response. This introduces FATAL inaccuracies regarding the primary purpose and key I/O behavior of the function."
            ]
        },
        "misum": {
            "summary": "The function disables GPU cache invalidation by checking for changes in the pipeline's display interfaces, handling destination-specific devices and ensuring proper synchronization.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about GPU cache invalidation, pipeline display interfaces, and destination-specific devices do not match the source code. The source function manipulates BSD ring power management registers, clears context IDs, waits for wake-up, updates the ring tail, and restores idle message behavior. None of the described actions in the summary are present, resulting in all claims being inaccurate.",
                "The summary's claims about disabling GPU cache invalidation, checking pipeline display interfaces, and handling destination-specific devices do not match the source code's actual behavior. The code focuses on managing the BSD ring tail write sequence, including disabling idle messages, clearing context ID, waiting for ring wake-up, updating tail, and re-enabling idle messages. None of these CSU points are accurately represented, and the PRIMARY PURPOSE is missed entirely.",
                "The summary's claims are inaccurate and do not reflect the source code. The function actually manages BSD ring tail updates by controlling power state and idle notifications, not GPU cache invalidation or display interface changes. All mentioned behaviors in the summary are unrelated to the implementation, making these NOISE errors that target code semantics incorrectly. Given the complete mismatch, there is high negative impact with no accurate details provided."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583186688,
    "strip_function_name": "sub_FFFFFFFF81423F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81423F00(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        int a14)\n{\n  __int64 v14; // rcx\n  unsigned int v15; // r15d\n  unsigned int v16; // r12d\n  __int64 result; // rax\n  __int64 v20; // rax\n  __int64 v21; // rdx\n\n  v14 = *(unsigned int *)(a1 + 7264);\n  v15 = a2 ^ *(_DWORD *)(a1 + 7264);\n  if ( (v15 & (unsigned int)a2) != 0 )\n  {\n    sub_FFFFFFFF814226D0(\n      a1,\n      (int)&unk_FFFFFFFF8198743C,\n      (__int64)\"illegal qc_active transition (%08x->%08x)\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      v14,\n      (unsigned int)a2);\n    return 4294967274LL;\n  }\n  else\n  {\n    v16 = 0;\n    result = 0LL;\n    if ( v15 )\n    {\n      do\n      {\n        while ( 1 )\n        {\n          _RBX = v15;\n          __asm { tzcnt   rbx, rbx }\n          if ( (unsigned int)_RBX <= 0x1F )\n          {\n            v20 = 216LL * (unsigned int)_RBX;\n            if ( a1 + v20 != -344 )\n            {\n              v21 = *(_QWORD *)(a1 + 8);\n              if ( !*(_QWORD *)(v21 + 176) || (*(_QWORD *)(a1 + v20 + 416) & 0x10001LL) == 1 )\n                break;\n            }\n          }\n          v14 = (unsigned int)_RBX;\n          v15 &= ~(1 << _RBX);\n          if ( !v15 )\n            return v16;\n        }\n        sub_FFFFFFFF81423CF0(a1 + v20 + 344, a2, v21, v14, a13, a14);\n        v14 = (unsigned int)_RBX;\n        ++v16;\n        v15 &= ~(1 << _RBX);\n      }\n      while ( v15 );\n      return v16;\n    }\n  }\n  return result;\n}\n",
    "function_name": "ata_qc_complete_multiple",
    "decompiled_code": "__int64 __fastcall ata_qc_complete_multiple(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned int v10; // r15d\n  unsigned int v11; // r12d\n  __int64 result; // rax\n  __int64 v15; // rax\n\n  v10 = a2 ^ *(_DWORD *)(a1 + 7264);\n  if ( (v10 & (unsigned int)a2) != 0 )\n  {\n    ata_port_printk(\n      a1,\n      (__int64)&unk_FFFFFFFF8198743C,\n      (__int64)\"illegal qc_active transition (%08x->%08x)\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9,\n      a10,\n      *(unsigned int *)(a1 + 7264),\n      (unsigned int)a2);\n    return 4294967274LL;\n  }\n  else\n  {\n    v11 = 0;\n    result = 0LL;\n    if ( v10 )\n    {\n      do\n      {\n        while ( 1 )\n        {\n          _RBX = v10;\n          __asm { tzcnt   rbx, rbx }\n          if ( (unsigned int)_RBX <= 0x1F )\n          {\n            v15 = 216LL * (unsigned int)_RBX;\n            if ( a1 + v15 != -344\n              && (!*(_QWORD *)(*(_QWORD *)(a1 + 8) + 176LL) || (*(_QWORD *)(a1 + v15 + 416) & 0x10001LL) == 1) )\n            {\n              break;\n            }\n          }\n          v10 &= ~(1 << _RBX);\n          if ( !v10 )\n            return v11;\n        }\n        ata_qc_complete(a1 + v15 + 344, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n        ++v11;\n        v10 &= ~(1 << _RBX);\n      }\n      while ( v10 );\n      return v11;\n    }\n  }\n  return result;\n}\n",
    "source_code": "int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active)\n{\n\tint nr_done = 0;\n\tu32 done_mask;\n\n\tdone_mask = ap->qc_active ^ qc_active;\n\n\tif (unlikely(done_mask & qc_active)) {\n\t\tata_port_err(ap, \"illegal qc_active transition (%08x->%08x)\\n\",\n\t\t\t     ap->qc_active, qc_active);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_done++;\n\t\t}\n\t\tdone_mask &= ~(1 << tag);\n\t}\n\n\treturn nr_done;\n}",
    "comment": "Processes and completes multiple ATA queued commands based on the active command status while checking for illegal state transitions.",
    "hext5_sum": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
    "bint5_sum": "Validates and sets the active DMA transition for a SCSI disk based on the provided transition values , logging an error for invalid transitions .\n",
    "cpbcs_sum": "Disables a specified USB host endpoint, ensuring that do not exceed maximum queue depth and handling potential errors during the process.\n",
    "misum_sum": "Disables specified ATA port. clears its disable port if not exceptional or deactivates it is currently running.\n",
    "decom_sum": "Validates and processes changes in `qc_active` bitmask, logging illegal transitions and invoking handlers for each newly activated bit.",
    "cfg_sum": "Validates and processes qc_active state bit transitions, logging illegal changes and invoking handlers for each newly activated bit, returning processed transition count or an error code.",
    "work_score": {
        "hext5": {
            "summary": "compute the covariance matrix cov = inv (j^t j) by qrp^t decomposition of j",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes computing a covariance matrix using a QRP^T decomposition, which is entirely unrelated to the source code\u2019s purpose of completing queued ATA commands and handling illegal transitions. None of the claims in the summary align with the source implementation, resulting in zero accurate claims.",
                "The summary describes calculating a covariance matrix using QRP decomposition, which is entirely unrelated to the source code. The source function processes ATA queued commands, checks for illegal `qc_active` transitions, completes commands, and returns a count or error. The summary fails to capture the primary purpose or any secondary details from the code, making all claims inaccurate.",
                "The summary describes a mathematical operation involving covariance matrix computation and QRP decomposition, which is entirely unrelated to the actual source code\u2019s logic of completing queued ATA commands and error handling transitions. This is pure NOISE with no accurate claims about the code, resulting in zero alignment with the evaluation steps."
            ]
        },
        "bint5": {
            "summary": "Validates and sets the active DMA transition for a SCSI disk based on the provided transition values , logging an error for invalid transitions .\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains a single claim describing validation and setting of an active DMA transition for a SCSI disk, which is inaccurate. The source code instead processes ATA queued commands, checks for illegal qc_active transitions, and completes commands\u2014it does not involve DMA or SCSI-specific behavior. As the claim targets code semantics but contradicts the actual implementation, none of the claims are accurate.",
                "The summary is inaccurate: it describes handling of \"active DMA transition for a SCSI disk,\" which is not reflected in the source. The code works with ATA queued commands in an ATA port, checking for illegal qc_active transitions, logging errors, and completing commands. The primary purpose and context are misidentified, and no accurate coverage of actual secondary details like iteration through done_mask or invocation of ata_qc_complete is provided.",
                "The summary contains a FATAL inaccuracy: it claims the function deals with active DMA transitions for a SCSI disk, whereas the source code actually processes ATA queued command completions and validates qc_active transitions for an ATA port, not specific to SCSI or DMA. This misrepresentation affects the primary purpose and key I/O of the function. There are no accurate, high-gain details to offset the error."
            ]
        },
        "cpbcs": {
            "summary": "Disables a specified USB host endpoint, ensuring that do not exceed maximum queue depth and handling potential errors during the process.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes disabling a USB host endpoint with queue depth checks, which is unrelated to the actual source code that processes ATA queued commands by calculating a done mask, handling illegal transitions, and completing commands. None of the claims match the source implementation, making all claims inaccurate.",
                "The summary is entirely inaccurate. The source code implements completion of multiple ATA queued commands, checking for illegal transitions in qc_active and returning an error if detected, while counting completed commands. The summary incorrectly describes disabling a USB host endpoint and queue depth management, which is unrelated to the actual function's purpose or details. No accurate claims match the source code, and the primary purpose is missed.",
                "The summary's claim about disabling a USB host endpoint is entirely unrelated to the source code, which manages ATA queued commands completion using a bitmask and handles illegal transitions to return errors. This is pure NOISE with no accurate alignment to the primary purpose or key side effects, offering zero useful insight."
            ]
        },
        "misum": {
            "summary": "Disables specified ATA port. clears its disable port if not exceptional or deactivates it is currently running.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about disabling an ATA port and clearing/deactivating it are not reflected in the source code, which actually processes completed ATA queued commands, checks for illegal transitions, and counts completed commands. None of the summary's claims accurately describe the code's semantics, resulting in no alignment with the source.",
                "The summary claims the function disables an ATA port or clears a disable flag, which does not match the source code's actual purpose of completing multiple queued ATA commands and handling illegal transitions. It misses the primary purpose entirely and contains inaccurate details not reflected in the implementation, offering no coverage of key secondary behaviors like error handling and command completion loops.",
                "The summary contains only inaccurate claims about disabling an ATA port, clearing a disable flag, or deactivating it if running. The source code instead completes multiple queued ATA commands, checks for illegal transitions in qc_active, and returns the count of completed commands. These mismatches are fatal because they misrepresent the primary purpose and key I/O of the function, offering no accurate or helpful insight."
            ]
        }
    }
}
{
    "project_name": "gawk",
    "function_addr": 4677088,
    "strip_function_name": "sub_475DE0",
    "strip_decompiled_code": "char *__fastcall sub_475DE0(__int64 a1, __int64 *a2, __m128i *a3, __int64 a4, int a5, int *a6)\n{\n  __int64 v9; // rbx\n  char *v10; // rax\n  char *v11; // r15\n  char *v12; // rcx\n  __int64 v15; // [rsp+18h] [rbp-70h]\n  __int64 v16; // [rsp+20h] [rbp-68h]\n  __m128i v17; // [rsp+30h] [rbp-58h] BYREF\n  unsigned __int64 v18; // [rsp+48h] [rbp-40h]\n\n  v9 = *a2;\n  v18 = __readfsqword(0x28u);\n  v16 = *(_QWORD *)(v9 + 152);\n  v10 = sub_475C40((__int64 *)a1, a2, a3, a4, a5, a6);\n  v11 = v10;\n  if ( *a6 && !v10 )\n    return 0LL;\n  while ( a3->m128i_i8[8] == 10 )\n  {\n    *(_DWORD *)(a1 + 56) += sub_46FB40((unsigned __int8 *)a3, (__int64 *)a1, a4 | 0x800000);\n    if ( (a3->m128i_i8[8] & 0xF7) == 2 || a3->m128i_i8[8] == 9 && a5 )\n    {\n      v12 = 0LL;\n    }\n    else\n    {\n      v15 = *(_QWORD *)(v9 + 152);\n      *(_QWORD *)(v9 + 152) = v16;\n      v12 = sub_475C40((__int64 *)a1, a2, a3, a4, a5, a6);\n      if ( *a6 && !v12 )\n      {\n        if ( v11 )\n          sub_469F50(v11, (__int64 (__fastcall *)(__int64, _QWORD *))sub_46AE80, 0LL);\n        return 0LL;\n      }\n      *(_QWORD *)(v9 + 152) |= v15;\n    }\n    v17 = 0LL;\n    v17.m128i_i8[8] = 10;\n    v11 = sub_46BD40((_QWORD *)(v9 + 112), (int *)(v9 + 128), v11, v12, &v17);\n    if ( !v11 )\n    {\n      *a6 = 12;\n      return v11;\n    }\n  }\n  return v11;\n}\n",
    "function_name": "parse_reg_exp",
    "decompiled_code": "bin_tree_t *__fastcall parse_reg_exp(\n        re_string_t *regexp,\n        regex_t *preg,\n        re_token_t *token,\n        reg_syntax_t syntax,\n        Idx nest,\n        reg_errcode_t *err)\n{\n  re_dfa_t *buffer; // rbx\n  bin_tree_t *v10; // rax\n  bin_tree_t *v11; // r15\n  bin_tree_t *v12; // rcx\n  bitset_word_t v15; // [rsp+A0h] [rbp+18h]\n  bitset_word_t completed_bkref_map; // [rsp+A8h] [rbp+20h]\n  __m128i v17; // [rsp+B8h] [rbp+30h] BYREF\n  unsigned __int64 v18; // [rsp+D0h] [rbp+48h]\n\n  buffer = preg->buffer;\n  v18 = __readfsqword(0x28u);\n  completed_bkref_map = buffer->completed_bkref_map;\n  v10 = parse_branch(regexp, preg, token, syntax, nest, err);\n  v11 = v10;\n  if ( *err && !v10 )\n    return 0LL;\n  while ( *((_BYTE *)token + 8) == 10 )\n  {\n    regexp->cur_idx += peek_token(token, regexp, syntax | 0x800000);\n    if ( (*((_BYTE *)token + 8) & 0xF7) == 2 || *((_BYTE *)token + 8) == 9 && nest )\n    {\n      v12 = 0LL;\n    }\n    else\n    {\n      v15 = buffer->completed_bkref_map;\n      buffer->completed_bkref_map = completed_bkref_map;\n      v12 = parse_branch(regexp, preg, token, syntax, nest, err);\n      if ( *err && !v12 )\n      {\n        if ( v11 )\n          postorder(v11, free_tree, 0LL);\n        return 0LL;\n      }\n      buffer->completed_bkref_map |= v15;\n    }\n    v17 = 0LL;\n    v17.m128i_i8[8] = 10;\n    v11 = create_token_tree(\n            (re_dfa_t *)&buffer->str_tree_storage,\n            (bin_tree_t *)&buffer->str_tree_storage_idx,\n            v11,\n            (const re_token_t *)v12,\n            &v17);\n    if ( !v11 )\n    {\n      *err = _REG_ESPACE;\n      return v11;\n    }\n  }\n  return v11;\n}\n",
    "source_code": "\nstatic bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (__glibc_unlikely (*err != REG_NOERROR && branch == NULL))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
    "comment": "Parses a regular expression into a binary tree structure while managing alternative branches and backreference mapping.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Parses a regular expression into a binary tree structure , handling concatenation and error management through recursive expression evaluations .\n",
    "cpbcs_sum": "Parses a regular expression into a binary tree structure, handling alternations and backreference mappings while managing error states.\n",
    "misum_sum": "Parses a regular expression into an ASN.1 structure, handling scope and error management during the parsing process.\n",
    "decom_sum": "Processes input records with type code 10, performing iterative merging and state restoration while handling errors according to the provided status flag.",
    "cfg_sum": "Processes structured input data, conditionally updates object state, chains results through helper calls, and aborts with error on validation failure or stack corruption detection.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior involving a static buffer, printf formatting, and hexadecimal conversion based on num_bytes, which is unrelated to the regex parsing logic in the source code. None of the claims in the summary match the implementation's semantics, resulting in no accurate claims.",
                "The summary describes a function that returns a pointer to a static buffer and performs formatting based on printf rules, which is entirely unrelated to the actual source code. The source code parses a regular expression into a binary tree, manages alternation operators, backreference maps, and error handling. None of the summary\u2019s claims match the primary purpose or any secondary details of the source, making the content inaccurate and missing all critical semantic units.",
                "The summary's claims about returning a pointer to a static buffer, using printf formatting, handling num_bytes, and hex formatting are entirely unrelated to the source code, which parses regular expressions and constructs a syntax tree. All claims are NOISE, overwhelming any accurate content, resulting in zero alignment with the actual implementation."
            ]
        },
        "bint5": {
            "summary": "Parses a regular expression into a binary tree structure , handling concatenation and error management through recursive expression evaluations .\n",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function parses a regular expression into a binary tree and manages errors, both of which align with the source implementation. However, it inaccurately claims handling of concatenation, which is not reflected in the code; the code specifically handles alternation via OP_ALT. This introduces a semantic mismatch, so the accuracy rate is reduced due to one of the few claims being incorrect.",
                "The summary correctly states the primary purpose of parsing a regular expression into a binary tree, which matches the source code's functionality. However, it inaccurately mentions 'handling concatenation', which is not evident in the provided code that focuses on handling alternation (OP_ALT) and specific error conditions. It also omits key secondary details such as back-reference map management, conditions for stopping, memory allocation failure handling, and the specific logic when encountering different token types. Overall, it captures the primary purpose but misses multiple important secondary details and contains one inaccurate detail.",
                "The summary claims the function handles concatenation, which is inaccurate because the source code handles alternation (OP_ALT) rather than concatenation; this is a FATAL error affecting the primary purpose. While it correctly notes parsing into a binary tree and error management, the incorrect operation target undermines reliability and reduces net benefit."
            ]
        },
        "cpbcs": {
            "summary": "Parses a regular expression into a binary tree structure, handling alternations and backreference mappings while managing error states.\n",
            "score": [
                1.0,
                0.7,
                0.6
            ],
            "reason": [
                "The summary makes three fact-based claims: parsing a regular expression into a binary tree, handling alternations, and managing backreference mappings with error states. All match the source: the function builds a binary tree via parse_branch/create_tree, processes OP_ALT tokens for alternations, and manages completed_bkref_map for backreferences while checking for and returning on error conditions. No contradictions or extraneous details are present, yielding high precision.",
                "The summary accurately captures the primary purpose by stating that the function parses a regular expression into a binary tree and handles alternations, consistent with the \u2018parse_branch\u2019 and \u2018create_tree\u2019 logic in the code. It also correctly mentions backreference mappings and managing error states, reflecting the handling of \u2018dfa->completed_bkref_map\u2019 and the various error checks. However, it omits secondary details such as specific branching conditions (e.g., token type checks against OP_ALT, END_OF_RE, OP_CLOSE_SUBEXP), the reset and union of backreference maps, and memory cleanup via \u2018postorder\u2019. These omissions limit completeness despite an accurate core description.",
                "The summary's claims are mostly accurate: it identifies the function's purpose as parsing a regular expression into a binary tree, handling alternations, managing backreference mappings, and dealing with error states, all of which are reflected in the source code. The information is correct but broad, lacking detailed specifics such as the use of `parse_branch`, the resetting and merging of `completed_bkref_map`, or the conditions for halting alternation processing. No claims are inaccurate or contradictory, but the gain is low due to the generic nature of the description."
            ]
        },
        "misum": {
            "summary": "Parses a regular expression into an ASN.1 structure, handling scope and error management during the parsing process.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function parses a regular expression into an ASN.1 structure, but the source code parses it into a binary tree structure, not ASN.1. While it does handle scope and error management as noted, the primary claim about the target data structure is incorrect, resulting in less than half of the claims being accurate.",
                "The summary incorrectly states that the function parses a regular expression into an ASN.1 structure, which contradicts the source code that builds a binary tree representation of the regex for a DFA. While it mentions handling scope and error management, which is partially true, the PRIMARY PURPOSE is misidentified. This fundamental inaccuracy means the core semantics are missed, and secondary details like alternation handling, bkref map adjustments, and tree creation are not covered.",
                "The summary contains a critical inaccuracy: it claims the function parses a regular expression into an ASN.1 structure, which contradicts the source code that clearly builds a binary parse tree for regex via parse_branch and create_tree. This is a FATAL error about the primary purpose of the function, negating any potential gain from accurate claims. While it mentions handling scope and error management, these are too generic and overshadowed by the incorrect core description."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584303216,
    "strip_function_name": "sub_FFFFFFFF81534870",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81534870(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r14\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  int v13; // r9d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  unsigned __int64 v16; // rax\n  unsigned __int64 v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  int v20; // r9d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  int v23; // r14d\n  __int64 *v24; // rdx\n  __int64 v25; // rcx\n  int v26; // r8d\n  int v27; // r9d\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n  double v30; // xmm4_8\n  double v31; // xmm5_8\n\n  v9 = sub_FFFFFFFF812CA1F0((_WORD *)a1);\n  v16 = sub_FFFFFFFF8112CF10((int)v9 + 38, 0xD0u, v10, v11, v12, v13, a2, a3, a4, a5, v14, v15, a8, a9);\n  if ( !v16 )\n    return 1LL;\n  v17 = v16;\n  sub_FFFFFFFF812CA260(v16, (_WORD *)a1, (int)v9 + 38);\n  *(_BYTE *)(v17 + v9) = 45;\n  sub_FFFFFFFF812B84F0(v17 + v9 + 1, (__int64)\"%pUl\", a2, a3, a4, a5, v18, v19, a8, a9, a1 + 1024);\n  *(_QWORD *)(a1 + 2136) = qword_FFFFFFFF81EA8120;\n  v23 = sub_FFFFFFFF812AFED0(\n          (unsigned __int64 *)(a1 + 2104),\n          (__int64)off_FFFFFFFF81C7BA60,\n          0LL,\n          (__int64)byte_FFFFFFFF819CBB7A,\n          v17,\n          v20,\n          a2,\n          a3,\n          a4,\n          a5,\n          v21,\n          v22,\n          a8,\n          a9);\n  sub_FFFFFFFF8112DCD0(v17, a2, a3, a4, a5, v28, v29, a8, a9, (__int64)off_FFFFFFFF81C7BA60, v24, v25, v26, v27);\n  if ( v23 )\n    return 1LL;\n  sub_FFFFFFFF812B0B70(a1 + 2104, 0, a2, a3, a4, a5, v30, v31, a8, a9);\n  sub_FFFFFFFF81532AA0(a1, (__int64 *)&off_FFFFFFFF81C7BB80);\n  return 0LL;\n}\n",
    "function_name": "efivar_create_sysfs_entry",
    "decompiled_code": "__int64 __fastcall efivar_create_sysfs_entry(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r14\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  __int64 *v12; // rax\n  __int64 *v13; // rbx\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // r14d\n  __int64 *v19; // rdx\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v9 = ucs2_utf8size((_WORD *)a1);\n  v12 = _kmalloc((int)v9 + 38, 208LL, a2, a3, a4, a5, v10, v11, a8, a9);\n  if ( !v12 )\n    return 1LL;\n  v13 = v12;\n  ucs2_as_utf8((__int64)v12, (_WORD *)a1, (int)v9 + 38);\n  *((_BYTE *)v13 + v9) = 45;\n  sprintf((__int64)v13 + v9 + 1, (__int64)\"%pUl\", a2, a3, a4, a5, v14, v15, a8, a9, a1 + 1024);\n  *(_QWORD *)(a1 + 2136) = efivars_kset;\n  v18 = kobject_init_and_add(\n          (__int64 **)(a1 + 2104),\n          (__int64)efivar_ktype,\n          0LL,\n          (__int64)byte_FFFFFFFF819CBB7A,\n          a2,\n          a3,\n          a4,\n          a5,\n          v16,\n          v17,\n          a8,\n          a9,\n          v13);\n  kfree(v13, a2, a3, a4, a5, v20, v21, a8, a9, (__int64)efivar_ktype, v19);\n  if ( v18 )\n    return 1LL;\n  kobject_uevent(a1 + 2104, 0, a2, a3, a4, a5, v22, v23, a8, a9);\n  efivar_entry_add(a1, (__int64 *)&efivar_sysfs_list);\n  return 0LL;\n}\n",
    "source_code": "static int\nefivar_create_sysfs_entry(struct efivar_entry *new_var)\n{\n\tint i, short_name_size;\n\tchar *short_name;\n\tunsigned long variable_name_size;\n\tefi_char16_t *variable_name;\n\n\tvariable_name = new_var->var.VariableName;\n\tvariable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);\n\n\t/*\n\t * Length of the variable bytes in ASCII, plus the '-' separator,\n\t * plus the GUID, plus trailing NUL\n\t */\n\tshort_name_size = variable_name_size / sizeof(efi_char16_t)\n\t\t\t\t+ 1 + EFI_VARIABLE_GUID_LEN + 1;\n\n\tshort_name = kzalloc(short_name_size, GFP_KERNEL);\n\n\tif (!short_name)\n\t\treturn 1;\n\n\t/* Convert Unicode to normal chars (assume top bits are 0),\n\t   ala UTF-8 */\n\tfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\n\t\tshort_name[i] = variable_name[i] & 0xFF;\n\t}\n\t/* This is ugly, but necessary to separate one vendor's\n\t   private variables from another's.         */\n\n\t*(short_name + strlen(short_name)) = '-';\n\tefi_guid_unparse(&new_var->var.VendorGuid,\n\t\t\t short_name + strlen(short_name));\n\n\tnew_var->kobj.kset = efivars_kset;\n\n\ti = kobject_init_and_add(&new_var->kobj, &efivar_ktype,\n\t\t\t\t   NULL, \"%s\", short_name);\n\tkfree(short_name);\n\tif (i)\n\t\treturn 1;\n\n\tkobject_uevent(&new_var->kobj, KOBJ_ADD);\n\tefivar_entry_add(new_var, &efivar_sysfs_list);\n\n\treturn 0;\n}",
    "comment": "Creates a sysfs entry for a new EFI variable by converting its Unicode name to ASCII and adding it to the kernel's object hierarchy.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes a new EFI variable entry and its corresponding sysfs entry if the variable content is valid and the user has appropriate permissions .\n",
    "cpbcs_sum": "Allocates and initializes a PCI bus for a PCI device based on the retrieved EDID name, setting up input parameters.\n",
    "misum_sum": "Allocates memory for a new PCM device and appends it to the uevent environment if the device does not already exist.\n",
    "decom_sum": "Formats and sends a UID string to a device buffer, updates related state, and finalizes communication with the associated handler structure.",
    "cfg_sum": "Allocates and formats a buffer, updates device state with formatted data, verifies the update, restores context, and returns success or failure status.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a vague and generic statement that does not address any specific fact-based details from the source code implementation. It fails to mention relevant functions, logic, or data structures, making it entirely inaccurate with respect to the source semantics.",
                "The summary 'push a pointer type' is vague, does not describe the primary purpose of the function, and fails to capture any concrete behavior from the source code such as creating a sysfs entry for an EFI variable, converting its name, handling memory allocation errors, or adding it to a list. It targets no atomic claim about the implementation, making it inaccurate and missing all critical semantic units.",
                "The summary 'push a pointer type' does not accurately reflect any part of the source code logic, which is about creating a sysfs entry for an EFI variable. It is noise with no factual alignment and provides no useful insight into the primary purpose, I/O, or side effects of the function. The worst failure mode is NOISE, resulting in low informational value."
            ]
        },
        "bint5": {
            "summary": "Initializes a new EFI variable entry and its corresponding sysfs entry if the variable content is valid and the user has appropriate permissions .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function checks the validity of the variable content and enforces user permissions, but the source code does not perform these checks. The implementation focuses on constructing a short name, initializing the kobject, triggering a uevent, and adding the entry to a list. There is accurate mention of initializing a new EFI variable entry and creating its sysfs entry, but most of the claim content about validity and permissions contradicts or is unsupported by the code, resulting in less than half of the claims being accurate.",
                "The summary incorrectly states conditions about variable content validity and user permissions, which are not present in the source code. While it vaguely references initializing an EFI variable entry and sysfs entry, it omits key implementation details like constructing the short name from the Unicode variable name with a GUID appended, memory allocation and conversion, error handling upon allocation and initialization failures, triggering uevents, and adding the entry to a list. Overall, it misrepresents the function\u2019s actual behavior and lacks coverage of critical secondary details.",
                "The summary introduces claims about validating variable content and checking user permissions, which are not present in the source code and thus are inaccurate. This constitutes FATAL errors because they misstate the primary purpose and key I/O of the function, which instead simply builds a sysfs entry for an EFI variable without such checks. There are no accurate, specific claims to offset this inaccuracy, leading to high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Allocates and initializes a PCI bus for a PCI device based on the retrieved EDID name, setting up input parameters.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about allocating and initializing a PCI bus for a PCI device based on an EDID name is entirely unrelated to the source code, which deals with creating a sysfs entry for an EFI variable by constructing a short name and setting up a kobject. None of the summary's content matches the actual implementation, so no claims are accurate.",
                "The summary describes initializing a PCI bus using an EDID name, which is completely unrelated to the source code's actual purpose of creating and registering a sysfs entry for an EFI variable, including allocating memory, converting the variable name, appending a GUID, and initializing kernel objects. The primary purpose and all secondary details are missed, and the claims are inaccurate with respect to the source semantics.",
                "The summary\u2019s claim that the function allocates and initializes a PCI bus for a PCI device using an EDID name is completely unrelated to the source code, which creates a sysfs entry for an EFI variable. This is a FATAL error targeting the primary purpose, as it misstates the function\u2019s core operation and key I/O. No accurate claims are present, resulting in high negative impact and zero positive gain."
            ]
        },
        "misum": {
            "summary": "Allocates memory for a new PCM device and appends it to the uevent environment if the device does not already exist.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims memory allocation for a PCM device and appending it to a uevent environment, which is unrelated to the source code. The source code instead creates a sysfs entry for an EFI variable, allocates memory for its short name, formats it with a GUID, initializes a kobject, sends a uevent, and adds the entry to a list. None of the summary's claims match the code's semantics, so all claims are inaccurate.",
                "The summary claims the function allocates memory for a PCM device and appends it to a uevent environment if it does not already exist, which is entirely unrelated to the actual source code. The source implements creation of a sysfs entry for an EFI variable, including Unicode to ASCII conversion, GUID appending, kobject initialization, and uevent emission. The summary misses the primary purpose and all key secondary details, making its claims inaccurate.",
                "The summary introduces unrelated concepts like a PCM device and uevent environment, which are not present in the source code that focuses on creating a sysfs entry for an EFI variable. This is a FATAL error impacting the primary purpose by misidentifying the core functionality, making the description unreliable and misleading."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586732474,
    "strip_function_name": "sub_FFFFFFFF817859BA",
    "strip_decompiled_code": "void __fastcall __noreturn sub_FFFFFFFF817859BA(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        int a10)\n{\n  unsigned int v10; // ebx\n  void (__fastcall *v11)(int *); // rax\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // r8d\n  int v15; // r9d\n  void (*v16)(void); // rax\n  double v17; // xmm0_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v20; // rdx\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  unsigned int v24; // edi\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 v27; // rdx\n\n  sub_FFFFFFFF817822C3();\n  off_FFFFFFFF81CAB688();\n  v10 = __readgsdword(0xA030u);\n  v11 = (void (__fastcall *)(int *))off_FFFFFFFF81CB6AB8[33];\n  if ( v11 && v10 )\n    v11(&dword_FFFFFFFF81DD29D8);\n  v12 = ((unsigned int (__fastcall *)(__int64))off_FFFFFFFF81CB6AB8[36])(32LL);\n  v13 = ((__int64 (__fastcall *)(__int64))off_FFFFFFFF81CB6AB8[22])(v12);\n  if ( _bittest((const signed __int32 *)&qword_FFFFFFFF81DCE750, v10) )\n    sub_FFFFFFFF8178A51B(\n      (unsigned int)\"%s: phys CPU#%d, CPU#%d already present??\\n\",\n      (unsigned int)\"smp_callin\",\n      v13,\n      v10,\n      v14,\n      v15);\n  while ( !_bittest((const signed __int32 *)&qword_FFFFFFFF81DCE758, v10) )\n    _mm_pause();\n  v16 = (void (*)(void))off_FFFFFFFF81CB6AB8[34];\n  if ( v16 )\n    v16();\n  sub_FFFFFFFF81786852();\n  sub_FFFFFFFF81786AD6();\n  LODWORD(v12) = __readgsdword(0xA030u);\n  v17 = sub_FFFFFFFF81006060(v12);\n  sub_FFFFFFFF8178554D(v10, v17, a2, a3, a4, v18, v19, a7, a8);\n  sub_FFFFFFFF8177FEF2(v10, a10, v20, v21, v22, v23);\n  v24 = __readgsdword(0xA030u);\n  *(_QWORD *)&byte_10E00[qword_FFFFFFFF81CB6720[v10] + 160] = off_FFFFFFFF81C10020;\n  sub_FFFFFFFF81785588(v24, v17, a2, a3, a4, v25, v26, a7, a8);\n  _mm_sfence();\n  sub_FFFFFFFF817876B3(v10);\n  sub_FFFFFFFF8178A0B1(v10, &qword_FFFFFFFF81DCE750, v27);\n  dword_FFFFFFFF81DD29DC = 0;\n  sub_FFFFFFFF817864C4();\n  sub_FFFFFFFF81007390();\n  sub_FFFFFFFF81027050();\n  sub_FFFFFFFF8103F840(__readgsdword(0xA030u), 1);\n  sub_FFFFFFFF81027070();\n  *(_DWORD *)(qword_FFFFFFFF81CB6720[__readgsdword(0xA030u)] + 48128) = 2;\n  off_FFFFFFFF81C11DA8();\n  _enable();\n  off_FFFFFFFF81CAB680();\n  _mm_sfence();\n  sub_FFFFFFFF81082C80(1LL);\n}\n",
    "function_name": "start_secondary",
    "decompiled_code": "void __fastcall __noreturn start_secondary(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        int a10)\n{\n  unsigned int v10; // ebx\n  void (__fastcall *v11)(int *); // rax\n  __int64 v12; // rdi\n  unsigned int v13; // eax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  void (*v16)(void); // rax\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n  signed int v25; // edi\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n  double v30; // xmm4_8\n  double v31; // xmm5_8\n\n  cpu_init(a1, a2, a3, a4, a5, a6, a7, a8);\n  off_FFFFFFFF81CAB688();\n  v10 = __readgsdword(0xA030u);\n  v11 = (void (__fastcall *)(int *))*((_QWORD *)apic + 33);\n  if ( v11 && v10 )\n    v11(&init_deasserted);\n  v12 = (*((unsigned int (__fastcall **)(__int64))apic + 36))(32LL);\n  v13 = (*((__int64 (__fastcall **)(__int64))apic + 22))(v12);\n  if ( _bittest((const signed __int32 *)&cpu_callin_mask, v10) )\n    panic(\n      (__int64)\"%s: phys CPU#%d, CPU#%d already present??\\n\",\n      a1,\n      a2,\n      a3,\n      a4,\n      v14,\n      v15,\n      a7,\n      a8,\n      \"smp_callin\",\n      v13,\n      v10);\n  while ( !_bittest((const signed __int32 *)&cpu_callout_mask, v10) )\n    _mm_pause();\n  v16 = (void (*)(void))*((_QWORD *)apic + 34);\n  if ( v16 )\n    v16();\n  setup_local_APIC();\n  end_local_APIC_setup(v12, a10, v17, v18, v19, v20);\n  setup_vector_irq(__readgsdword(0xA030u));\n  smp_store_cpu_info(v10, a1, a2, a3, a4, v21, v22, a7, a8);\n  calibrate_delay(a1, a2, a3, a4, v23, v24, a7, a8);\n  v25 = __readgsdword(0xA030u);\n  *(_QWORD *)&cpu_info[_per_cpu_offset[v10] + 160] = loops_per_jiffy;\n  set_cpu_sibling_map(v25, a1, a2, a3, a4, v26, v27, a7, a8);\n  _mm_sfence();\n  notify_cpu_starting(v10);\n  cpumask_set_cpu_1(v10, (volatile signed __int32 *)&cpu_callin_mask);\n  enable_start_cpu0 = 0;\n  check_tsc_sync_target(a1, a2, a3, a4, v28, v29, a7, a8, v10, (__int64)&cpu_callin_mask);\n  init_espfix_ap();\n  lock_vector_lock();\n  set_cpu_online(__readgsdword(0xA030u), 1);\n  unlock_vector_lock();\n  *(_DWORD *)(_per_cpu_offset[__readgsdword(0xA030u)] + 48128) = 2;\n  off_FFFFFFFF81C11DA8();\n  _enable();\n  x86_cpuinit();\n  _mm_sfence();\n  cpu_startup_entry((_BYTE *)&_per_cpu_start + 1, 1LL, a1, a2, a3, a4, v30, v31, a7, a8);\n}\n",
    "source_code": "\nvoid __cpuinit start_secondary(void)\n{\n\tunsigned int cpu;\n\tunsigned long thread_ptr;\n\n\t/*  Calculate thread_info pointer from stack pointer  */\n\t__asm__ __volatile__(\n\t\t\"%0 = SP;\\n\"\n\t\t: \"=r\" (thread_ptr)\n\t);\n\n\tthread_ptr = thread_ptr & ~(THREAD_SIZE-1);\n\n\t__asm__ __volatile__(\n\t\tQUOTED_THREADINFO_REG \" = %0;\\n\"\n\t\t:\n\t\t: \"r\" (thread_ptr)\n\t);\n\n\t/*  Set the memory struct  */\n\tatomic_inc(&init_mm.mm_count);\n\tcurrent->active_mm = &init_mm;\n\n\tcpu = smp_processor_id();\n\n\tsetup_irq(BASE_IPI_IRQ + cpu, &ipi_intdesc);\n\n\t/*  Register the clock_event dummy  */\n\tsetup_percpu_clockdev();\n\n\tprintk(KERN_INFO \"%s cpu %d\\n\", __func__, current_thread_info()->cpu);\n\n\tnotify_cpu_starting(cpu);\n\n\tset_cpu_online(cpu, true);\n\n\tlocal_irq_enable();\n\n\tcpu_startup_entry(CPUHP_ONLINE);\n}",
    "comment": "Initializes the secondary CPU by configuring memory management, enabling interrupts, and signaling readiness for operation within a multiprocessor environment.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Initializes the kernel by setting up memory , CPU access , opening the console , checking for early init commands , and loading default modules .\n",
    "cpbcs_sum": "Handles CPU state by invoking the error handler, managing CPU states, and invoking hotplug CPUs if available.\n",
    "misum_sum": "Handles CPU state changes by preparing it the CPU online CPU, and managing CPU state changes during CPU startup and online CPUs.\n",
    "decom_sum": "Initializes and synchronizes a CPU during SMP startup, performing readiness checks, memory fencing, and enabling interrupts before entering operational state.",
    "cfg_sum": "Initializes a CPU during system startup by validating its state, handling duplicate detection, executing setup routines, synchronizing memory, and enabling interrupts.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes functionality related to generating LEB128 values with sign handling, which is unrelated to the source code\u2019s CPU initialization sequence. None of the claims reference or accurately match the code\u2019s behavior, resulting in no fact-based alignment.",
                "The summary describes generating LEB128 fragments based on sign, which is unrelated to the source code\u2019s purpose of initializing a secondary CPU, setting up memory structures, interrupts, and bringing the CPU online. No elements of the PRIMARY PURPOSE or secondary details from the source are captured, making the content completely inaccurate.",
                "The summary makes a claim about generating LEB128 values with sign flags for sleb/uleb, which is entirely unrelated to the source code that initializes a secondary CPU, sets up IRQs, and enables interrupts. This is pure NOISE with no alignment to the code\u2019s primary purpose, key I/O, or side effects, and provides no actionable insight."
            ]
        },
        "bint5": {
            "summary": "Initializes the kernel by setting up memory , CPU access , opening the console , checking for early init commands , and loading default modules .\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary makes several claims such as initializing the kernel, opening the console, checking early init commands, and loading default modules. None of these are reflected in the source code, which focuses specifically on CPU startup tasks like setting memory structures, registering interrupts, enabling local IRQs, and setting the CPU online. The summary is therefore largely inaccurate with respect to the source implementation, containing no accurate claims about the actual operations shown.",
                "The summary claims the function initializes the kernel with actions like opening the console, checking early init commands, and loading default modules, but none of these are present in the source code. The actual code computes the thread_info pointer, sets up memory structures, configures IRQs for the CPU, registers a clock device, logs CPU info, marks the CPU as online, enables interrupts, and enters the CPU startup entry logic. While 'setting up memory' and 'CPU access' vaguely align, the summary misses the primary purpose of bringing a secondary CPU online and misstates several key operations, indicating poor alignment.",
                "The summary contains multiple INACCURATE claims compared to the source code. It describes opening the console, checking for early init commands, and loading default modules, none of which appear in the implementation. The actual function initializes per-CPU structures, sets the active memory context, configures IRQs, registers a clock device, logs a message, marks the CPU online, enables local interrupts, and enters the CPU startup loop. These mismatches target the primary purpose and key side effects, making them FATAL errors that directly contradict the code\u2019s semantics."
            ]
        },
        "cpbcs": {
            "summary": "Handles CPU state by invoking the error handler, managing CPU states, and invoking hotplug CPUs if available.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains claims about invoking an error handler and managing hotplug CPUs, which are not supported by the source code. The source code handles CPU startup by setting thread info, initializing memory structures, setting up IRQs and clock devices, notifying CPU start, and enabling interrupts, but it does not involve error handling or conditional hotplug CPU invocation. All claims are inaccurate, leading to no alignment.",
                "The summary incorrectly describes the function as invoking an error handler and managing hotplug CPUs, which are not present in the source. The actual code initializes secondary CPU state: sets thread pointer from stack, sets active_mm, configures IRQ and clock devices, prints status, notifies CPU starting, marks CPU online, enables local IRQs, and enters the CPU startup loop. The summary misses the primary purpose and key observable behaviors, and introduces inaccurate claims unrelated to the implementation.",
                "The summary claims the function invokes an error handler and manages hotplug CPUs, which are not present in the source code. The actual implementation sets up CPU state by configuring thread info, IRQs, clock devices, and enabling it \u2014 no error handling or conditional hotplug invocation is shown. These are FATAL inaccuracies on the primary purpose, making the description unreliable despite touching on CPU state."
            ]
        },
        "misum": {
            "summary": "Handles CPU state changes by preparing it the CPU online CPU, and managing CPU state changes during CPU startup and online CPUs.\n",
            "score": [
                0.3,
                0.5,
                0.5
            ],
            "reason": [
                "The summary is vague and only broadly mentions CPU state changes and making the CPU online, which loosely aligns with the source code steps such as setting the CPU online and enabling interrupts. However, it omits critical specifics like initializing memory structures, setting up IRQs, registering the clock device, and calling startup functions. Its broad language reduces precision, and several aspects relevant to the source implementation are missing, resulting in low accuracy proportion.",
                "The summary broadly states that the function handles CPU state changes and prepares the CPU to go online, which loosely matches the primary purpose of the source code (bringing a secondary CPU online). However, it lacks accuracy in details\u2014there is no mention of specific actions in the code like setting thread_info from the stack pointer, incrementing mm_count, configuring IRQs, registering clock devices, enabling interrupts, or calling cpu_startup_entry. The vague phrasing omits key secondary details and does not clearly follow the source semantics, leading to low completeness.",
                "The summary contains broad, generic claims about managing CPU state changes and preparing CPUs to go online, which are SAFE but low-information. It omits key specifics from the source, such as calculating the thread_info pointer, setting active_mm, registering clock events, and enabling local IRQ. There are no factual contradictions (no FATAL), but the claims provide minimal insight into actual implementation details, resulting in low gain and low net benefit."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582001184,
    "strip_function_name": "sub_FFFFFFFF81302820",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81302820(\n        int *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 (__fastcall *v10)(int *, _QWORD); // rax\n  int v11; // eax\n  bool v12; // zf\n  __int64 result; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  int i; // r14d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned __int64 v20[11]; // [rsp+0h] [rbp-58h] BYREF\n\n  v10 = *(__int64 (__fastcall **)(int *, _QWORD))(a2 + 8);\n  if ( !v10 )\n    goto LABEL_6;\n  v11 = v10(a1, *(_QWORD *)(a2 + 16));\n  v12 = v11 == 0;\n  if ( v11 < 0 )\n  {\n    *(_DWORD *)(a2 + 28) = v11;\n    return 16387LL;\n  }\n  result = 0LL;\n  if ( v12 )\n  {\nLABEL_6:\n    memset(v20, 0, 0x38uLL);\n    if ( (unsigned __int8)sub_FFFFFFFF81302020(a1, v20) || (unsigned __int8)sub_FFFFFFFF81302220((__int64)a1, v20) )\n      return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n    v16 = *a1;\n    if ( (unsigned int)(*a1 - 11) <= 2 )\n    {\n      if ( (unsigned __int8)sub_FFFFFFFF81302410((__int64)a1, v20) )\n        return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      v16 = *a1;\n    }\n    if ( v16 != 14 || !(unsigned __int8)sub_FFFFFFFF81302320((__int64)a1, v20) )\n    {\n      for ( i = 0; (unsigned __int8)sub_FFFFFFFF81302680((__int64)a1, i, v20); ++i )\n      {\n        result = sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v18, v19, a9, a10);\n        if ( (_DWORD)result )\n          return result;\n      }\n      return 0LL;\n    }\n    return sub_FFFFFFFF81302180(v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n  }\n  return result;\n}\n",
    "function_name": "acpi_dev_process_resource",
    "decompiled_code": "__int64 __fastcall acpi_dev_process_resource(\n        int *a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 (__fastcall *v10)(int *, _QWORD, double, double, double, double, double, double, double, double); // rax\n  int v11; // eax\n  bool v12; // zf\n  __int64 result; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  int v16; // eax\n  int i; // r14d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned __int64 v20[11]; // [rsp+0h] [rbp-58h] BYREF\n\n  v10 = *(__int64 (__fastcall **)(int *, _QWORD, double, double, double, double, double, double, double, double))(a2 + 8);\n  if ( !v10 )\n    goto LABEL_6;\n  v11 = v10(a1, *(_QWORD *)(a2 + 16), a3, a4, a5, a6, a7, a8, a9, a10);\n  v12 = v11 == 0;\n  if ( v11 < 0 )\n  {\n    *(_DWORD *)(a2 + 28) = v11;\n    return 16387LL;\n  }\n  result = 0LL;\n  if ( v12 )\n  {\nLABEL_6:\n    memset(v20, 0, 0x38uLL);\n    if ( (unsigned __int8)acpi_dev_resource_memory(a1, v20) || (unsigned __int8)acpi_dev_resource_io((__int64)a1, v20) )\n      return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n    v16 = *a1;\n    if ( (unsigned int)(*a1 - 11) <= 2 )\n    {\n      if ( (unsigned __int8)acpi_dev_resource_address_space_part_2(a1, v20) )\n        return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      v16 = *a1;\n    }\n    if ( v16 != 14 || !(unsigned __int8)acpi_dev_resource_ext_address_space_part_1((__int64)a1, v20) )\n    {\n      for ( i = 0; (unsigned __int8)acpi_dev_resource_interrupt((__int64)a1, i, v20, a3, a4, a5, a6, v14, v15, a9, a10); ++i )\n      {\n        result = acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v18, v19, a9, a10);\n        if ( (_DWORD)result )\n          return result;\n      }\n      return 0LL;\n    }\n    return acpi_dev_new_resource_entry((__int64 *)v20, (_DWORD *)a2, a3, a4, a5, a6, v14, v15, a9, a10);\n  }\n  return result;\n}\n",
    "source_code": "\nstatic acpi_status acpi_dev_process_resource(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct res_proc_context *c = context;\n\tstruct resource r;\n\tint i;\n\n\tif (c->preproc) {\n\t\tint ret;\n\n\t\tret = c->preproc(ares, c->preproc_data);\n\t\tif (ret < 0) {\n\t\t\tc->error = ret;\n\t\t\treturn AE_CTRL_TERMINATE;\n\t\t} else if (ret > 0) {\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tmemset(&r, 0, sizeof(r));\n\n\tif (acpi_dev_resource_memory(ares, &r)\n\t    || acpi_dev_resource_io(ares, &r)\n\t    || acpi_dev_resource_address_space(ares, &r)\n\t    || acpi_dev_resource_ext_address_space(ares, &r))\n\t\treturn acpi_dev_new_resource_entry(&r, c);\n\n\tfor (i = 0; acpi_dev_resource_interrupt(ares, i, &r); i++) {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_dev_new_resource_entry(&r, c);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t}\n\n\treturn AE_OK;\n}",
    "comment": "Processes ACPI resources by calling preprocessing functions, handling memory, I/O, and address space resources, and creating new resource entries as needed.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes ACPI devices by executing their _INI methods and counting the number of devices , while managing mutex locks for thread safety .\n",
    "cpbcs_sum": "Sets the rendering sequence variable for an Intel DVO device by validating access and calling the appropriate operation handler if needed.\n",
    "misum_sum": "Handles opening a specified request associated with a device by converting and invoking the appropriate event hook method.\n",
    "decom_sum": "Processes structured input data through multiple parsing routines and dispatches it to a handler, returning error codes for invalid or unsupported formats.",
    "cfg_sum": "Validates and processes structured input data through multiple checks and handlers, updating status on failure and returning appropriate success or error codes.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer, printf formatting, hex conversion, and num_bytes behavior do not align with the source code. The function in the source handles ACPI resources, processes them via callbacks, and returns ACPI status codes, not converted values or formatted strings. All claims are inaccurate, resulting in no alignment with the source.",
                "The summary describes behavior involving a static buffer, printf formatting, and byte display rules, none of which correspond to the source code\u2019s actual purpose of processing ACPI resource structures, running a preprocessor callback, and creating resource entries. This is a clear contradiction to the source semantics and fails to capture the primary purpose or any secondary details from the code.",
                "All claims in the summary are unrelated to the source code, describing string conversion and formatting behavior with fmtch and num_bytes, whereas the provided function processes ACPI resource structures and does not perform any such conversion or return a static buffer. This constitutes pure NOISE with no accurate statements, offering no relevant insight into the code."
            ]
        },
        "bint5": {
            "summary": "Initializes ACPI devices by executing their _INI methods and counting the number of devices , while managing mutex locks for thread safety .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function initializes ACPI devices by executing their _INI methods, counts devices, and manages mutex locks for thread safety. None of these actions are present in the source code, which instead processes ACPI resources, runs an optional pre-processing step, and creates new resource entries. The claims target code semantics but are entirely contradictory, resulting in no accurate alignment.",
                "The summary describes initializing ACPI devices via _INI methods and handling mutex locks, which does not align with the source code's actual purpose of processing ACPI resources, invoking a preprocessor callback, handling different resource types, and creating new resource entries. The summary misses the primary purpose entirely and introduces unrelated concepts, so no claims are accurate.",
                "The summary claims the function initializes ACPI devices, executes their _INI methods, counts devices, and manages mutex locks, none of which are supported by the source code. The implementation instead processes an ACPI resource, optionally invokes a preprocessor callback, populates a resource structure, and registers memory, I/O, address space, or interrupt resources. These are [INACCURATE] claims targeting the primary purpose of the function, resulting in a FATAL error and making the summary misleading."
            ]
        },
        "cpbcs": {
            "summary": "Sets the rendering sequence variable for an Intel DVO device by validating access and calling the appropriate operation handler if needed.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes setting a rendering sequence variable for an Intel DVO device, which is unrelated to the source code. The source code processes ACPI resources, invoking preprocessing, handling various resource types, and managing interrupts. None of the claims in the summary match the code\u2019s functionality, making all of them inaccurate.",
                "The summary is entirely inaccurate: it describes setting a rendering sequence variable for an Intel DVO device, which is unrelated to the actual source code. The source code processes ACPI resources by optionally invoking a preprocessor, handling various resource types, creating resource entries, and managing interrupts. No claims in the summary match any critical semantic units from the source code, and the primary purpose is missed.",
                "The summary is completely unrelated to the source code, which processes ACPI resources, handles preprocessing callbacks, initializes resource structures, and creates new resource entries from various resource types. The described action of setting a rendering sequence for an Intel DVO device does not match any semantics from the source, constituting pure NOISE with no accurate claims. This results in high negative impact from irrelevant content and zero useful gain."
            ]
        },
        "misum": {
            "summary": "Handles opening a specified request associated with a device by converting and invoking the appropriate event hook method.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function opens a specified request for a device and invokes an event hook, which bears no relation to the source code's actual behavior. The source processes ACPI resource descriptors, optionally calling a preprocessor, populating a resource structure, and adding entries based on resource types. None of these actions involve opening requests or event hooks. All extracted claims are unrelated to the code, resulting in no accurate matches.",
                "The summary describes handling a device request by converting and invoking an event hook, which is not aligned with the source code. The function in the source processes ACPI resource structures, calls optional preprocessing, handles memory, I/O, and interrupt resources, and creates new resource entries. The summary misses the primary purpose entirely and introduces unrelated concepts, making it inaccurate.",
                "The summary describes opening a request, converting it, and invoking an event hook, which does not match the source code's actual behavior of processing ACPI resources through pre-processing, memory/IO/address space handling, and interrupt resource entry creation. This is a FATAL inaccuracy concerning the primary purpose, leading to high negative impact and no useful alignment with code semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578993552,
    "strip_function_name": "sub_FFFFFFFF81024390",
    "strip_decompiled_code": "__int64 sub_FFFFFFFF81024390()\n{\n  __int64 result; // rax\n  unsigned int v6; // r12d\n  unsigned int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  int v10; // esi\n  const void *v11; // rbx\n  __int64 i; // rcx\n  __int64 v13; // [rsp+0h] [rbp-18h]\n\n  sub_FFFFFFFF81024340();\n  if ( (__readgsqword((unsigned int)&qword_10E24) & 8) != 0\n    && (__readgsqword((unsigned int)&qword_10E14) & 0x80000) != 0\n    && (int)__readgsdword((unsigned int)&dword_10E10) > 4 )\n  {\n    _RAX = 5LL;\n    __asm { cpuid }\n    v6 = 0;\n    if ( (_RCX & 1) != 0 )\n    {\n      v7 = (unsigned int)_RDX >> 4;\n      if ( (unsigned int)_RDX >> 4 )\n      {\n        v8 = 0;\n        v9 = 0;\n        v10 = 0;\n        do\n        {\n          if ( (v7 & 0xF) != 0 )\n          {\n            v9 = v10;\n            v8 = v7 & 0xF;\n          }\n          ++v10;\n          v7 >>= 4;\n        }\n        while ( v10 != 7 && v7 );\n        v6 = (v8 - 1) | (16 * v9);\n      }\n      else\n      {\n        v6 = -1;\n      }\n    }\n    v11 = (const void *)(__readgsqword(0xA760u) - 8136);\n    __wbinvd();\n    for ( i = 0LL; ; i = v13 )\n    {\n      do\n      {\n        do\n        {\n          _mm_clflush(v11);\n          _mm_monitor(v11, i, i);\n          _mm_mfence();\n          _mm_mwait(i, v6);\n        }\n        while ( __readgsdword(0xA030u) );\n      }\n      while ( !dword_FFFFFFFF81DD29DC );\n      v13 = i;\n      sub_FFFFFFFF810002A0();\n    }\n  }\n  result = sub_FFFFFFFF8152F750();\n  if ( (_DWORD)result )\n  {\n    if ( __readgsbyte((unsigned int)byte_10E00) > 3u )\n      __wbinvd();\n    __halt();\n  }\n  return result;\n}\n",
    "function_name": "native_play_dead",
    "decompiled_code": "__int64 native_play_dead()\n{\n  __int64 result; // rax\n  unsigned int v6; // r12d\n  unsigned int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  int v10; // esi\n  const void *v11; // rbx\n  __int64 i; // rcx\n  __int64 v13; // [rsp+0h] [rbp-18h]\n\n  play_dead_common();\n  if ( (__readgsqword((unsigned int)&qword_10E24) & 8) != 0\n    && (__readgsqword((unsigned int)&qword_10E14) & 0x80000) != 0\n    && (int)__readgsdword((unsigned int)&dword_10E10) > 4 )\n  {\n    _RAX = 5LL;\n    __asm { cpuid }\n    v6 = 0;\n    if ( (_RCX & 1) != 0 )\n    {\n      v7 = (unsigned int)_RDX >> 4;\n      if ( (unsigned int)_RDX >> 4 )\n      {\n        v8 = 0;\n        v9 = 0;\n        v10 = 0;\n        do\n        {\n          if ( (v7 & 0xF) != 0 )\n          {\n            v9 = v10;\n            v8 = v7 & 0xF;\n          }\n          ++v10;\n          v7 >>= 4;\n        }\n        while ( v10 != 7 && v7 );\n        v6 = (v8 - 1) | (16 * v9);\n      }\n      else\n      {\n        v6 = -1;\n      }\n    }\n    v11 = (const void *)(__readgsqword(0xA760u) - 8136);\n    __wbinvd();\n    for ( i = 0LL; ; i = v13 )\n    {\n      do\n      {\n        do\n        {\n          _mm_clflush(v11);\n          _mm_monitor(v11, i, i);\n          _mm_mfence();\n          _mm_mwait(i, v6);\n        }\n        while ( __readgsdword(0xA030u) );\n      }\n      while ( !enable_start_cpu0 );\n      v13 = i;\n      start_cpu0();\n    }\n  }\n  result = cpuidle_play_dead();\n  if ( (_DWORD)result )\n  {\n    if ( __readgsbyte((unsigned int)cpu_info) > 3u )\n      __wbinvd();\n    __halt();\n  }\n  return result;\n}\n",
    "source_code": "\nvoid native_play_dead(void)\n{\n\tplay_dead_common();\n\ttboot_shutdown(TB_SHUTDOWN_WFS);\n\n\tmwait_play_dead();\t/* Only returns on failure */\n\tif (cpuidle_play_dead())\n\t\thlt_play_dead();\n}",
    "comment": "Initiates a shutdown sequence and enters a low-power state, managing transitions based on CPU idle status and system power states.",
    "hext5_sum": " a choice for the \"order\" of the method, using the deuflhard criteria.",
    "bint5_sum": "Restores the local APIC state and re-enables IRQ remapping for various CPUs after a system suspend .\n",
    "cpbcs_sum": "Restores the local APIC state and registers the calling thread for the current CPU.\n",
    "misum_sum": "Calculates the number of CPU masks by iterating through the TSC thread based on the current task's cache state.\n",
    "decom_sum": "Enters a CPU idle loop using MONITOR/MWAIT after checking system state, flushing caches, and handling wake events, otherwise halts on critical condition.",
    "cfg_sum": "Monitors CPU state and cache status, enters a wait loop on specific hardware conditions, or halts the system on detected critical faults.",
    "work_score": {
        "hext5": {
            "summary": " a choice for the \"order\" of the method, using the deuflhard criteria.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary does not contain any fact-based claims about the source code\u2019s logic, functions, or execution order. Instead, it introduces unrelated terms ('order' and 'deuflhard criteria') that do not correspond to anything in the provided function. As a result, none of the claims align with the source code, yielding no accurate matches.",
                "The summary is vague and unrelated to the source code's functionality. It does not identify the primary purpose of the function, which is to execute a sequence of shutdown and processor halt operations via calls to specific low-level routines. No accurate claims are made about inputs, outputs, or behavior, so there is no coverage of critical semantic units.",
                "The summary contains a vague statement about 'order' and 'deuflhard criteria' that does not reference or match any details of the source code. There are no accurate claims about the actual function's sequence of calls, parameters, or behavior. All content is NOISE, with no clear tie-in to the code's semantics, producing no useful insight for understanding implementation."
            ]
        },
        "bint5": {
            "summary": "Restores the local APIC state and re-enables IRQ remapping for various CPUs after a system suspend .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claim about restoring local APIC state and re-enabling IRQ remapping after suspend is not reflected in the source code, which instead invokes functions for playing dead and shutting down. None of the claims from the summary align with the actual implementation, resulting in no accurate matches.",
                "The summary describes restoring APIC state and IRQ remapping after suspend, which is unrelated to the source code. The actual function performs a sequence of shutdown and CPU idle operations to put the system into a 'play dead' state, with conditional fallbacks. The summary misses the primary purpose entirely and introduces inaccurate behavior, resulting in no alignment with the implementation.",
                "The summary makes a highly specific claim about restoring local APIC state and re-enabling IRQ remapping after suspend, but none of these actions appear in the provided source code, which only calls functions to shut down and play dead. This is a FATAL inaccuracy targeting the primary purpose of the function, making the description misleading about core behavior."
            ]
        },
        "cpbcs": {
            "summary": "Restores the local APIC state and registers the calling thread for the current CPU.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function restores the local APIC state and registers the calling thread for the current CPU, but the source code only calls functions related to shutting down and putting the CPU into a dead state. There is no indication of restoring APIC state or registering any thread, making the claim entirely inaccurate and unrelated to the implementation.",
                "The summary inaccurately describes behavior unrelated to the source code, claiming restoration of APIC state and thread registration, while the function in the source code invokes shutdown routines and CPU idle/dead states. It completely misses the primary purpose and all secondary details, leading to no alignment with actual implementation.",
                "The summary claims that the function restores the local APIC state and registers the calling thread for the current CPU, but the source code only calls functions related to shutting down or entering a 'play dead' power state. There is no evidence of any APIC state restoration or thread registration in the implementation, making this a contradictory (FATAL) error regarding the primary purpose and side effects of the function."
            ]
        },
        "misum": {
            "summary": "Calculates the number of CPU masks by iterating through the TSC thread based on the current task's cache state.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes calculating CPU masks by iterating through a TSC thread based on cache state, which is unrelated to the source code. The provided function instead calls several shutdown and 'play_dead' routines without any CPU mask calculation or TSC thread logic. All claims are inaccurate as they do not match the source implementation.",
                "The summary describes calculating CPU masks via TSC threads and cache state, which is unrelated to the source code's actual purpose of executing a sequence of functions to initiate and manage a CPU 'play dead' shutdown process. It misses the primary purpose and all secondary details such as calls to play_dead_common, tboot_shutdown, mwait_play_dead, cpuidle_play_dead, and hlt_play_dead.",
                "The summary's claim about calculating CPU masks through TSC threads and cache state is entirely unrelated to the source code, which handles CPU shutdown sequences via play_dead_common, tboot_shutdown, mwait_play_dead, cpuidle_play_dead, and hlt_play_dead. This is a NOISE failure, with no accurate claims present, making the content misleading and offering no insight into the actual code."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583981312,
    "strip_function_name": "sub_FFFFFFFF814E5F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814E5F00(__int64 *a1, unsigned int a2, unsigned __int16 *a3)\n{\n  __int64 v6; // r13\n  int v7; // edi\n  __int64 v8; // r15\n  int v9; // edi\n  __int64 result; // rax\n  __int64 v11; // r13\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // esi\n  __int64 v16; // [rsp+0h] [rbp-30h]\n\n  v6 = *a1;\n  v7 = *a3;\n  v8 = qword_FFFFFFFF81CC2000;\n  if ( (_WORD)v7 && (v16 = a1[3], v8 - v16 - sub_FFFFFFFF81042910(v7) < 0) )\n  {\n    v13 = sub_FFFFFFFF810427C0((int)v8 - *((_DWORD *)a1 + 6));\n    LOWORD(v14) = 0x7FFF;\n    v15 = *a3;\n    if ( a3[1] <= 0x7FFFu )\n      LOWORD(v14) = a3[1];\n    v14 = (unsigned __int16)v14;\n  }\n  else\n  {\n    v9 = a3[2];\n    if ( !(_WORD)v9 )\n      return a2;\n    if ( !*(_WORD *)(v6 + 10) )\n      return a2;\n    v11 = a1[4];\n    if ( v11 - sub_FFFFFFFF81042910(v9) - v8 >= 0 )\n      return a2;\n    v12 = a1[4];\n    if ( v8 - v12 >= 0 )\n      return a2;\n    v13 = sub_FFFFFFFF810427C0((int)v12 - (int)v8);\n    LOWORD(v14) = 0x7FFF;\n    v15 = a3[2];\n    if ( a3[3] <= 0x7FFFu )\n      LOWORD(v14) = a3[3];\n    v14 = (unsigned __int16)v14;\n  }\n  result = (unsigned int)(v14 + (int)((abs32(a2) - v14) * v13) / v15);\n  if ( (a2 & 0x80000000) != 0 )\n    return (unsigned int)-(int)result;\n  return result;\n}\n",
    "function_name": "apply_envelope",
    "decompiled_code": "__int64 __fastcall apply_envelope(__int64 *a1, unsigned int a2, unsigned __int16 *a3)\n{\n  __int64 v6; // r13\n  int v7; // edi\n  __int64 v8; // r15\n  int v9; // edi\n  __int64 result; // rax\n  __int64 v11; // r13\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // esi\n  __int64 v16; // [rsp+0h] [rbp-30h]\n\n  v6 = *a1;\n  v7 = *a3;\n  v8 = _vvar_beginning_hack;\n  if ( (_WORD)v7 && (v16 = a1[3], v8 - v16 - msecs_to_jiffies(v7) < 0) )\n  {\n    v13 = jiffies_to_msecs((int)v8 - *((_DWORD *)a1 + 6));\n    LOWORD(v14) = 0x7FFF;\n    v15 = *a3;\n    if ( a3[1] <= 0x7FFFu )\n      LOWORD(v14) = a3[1];\n    v14 = (unsigned __int16)v14;\n  }\n  else\n  {\n    v9 = a3[2];\n    if ( !(_WORD)v9 )\n      return a2;\n    if ( !*(_WORD *)(v6 + 10) )\n      return a2;\n    v11 = a1[4];\n    if ( v11 - msecs_to_jiffies(v9) - v8 >= 0 )\n      return a2;\n    v12 = a1[4];\n    if ( v8 - v12 >= 0 )\n      return a2;\n    v13 = jiffies_to_msecs((int)v12 - (int)v8);\n    LOWORD(v14) = 0x7FFF;\n    v15 = a3[2];\n    if ( a3[3] <= 0x7FFFu )\n      LOWORD(v14) = a3[3];\n    v14 = (unsigned __int16)v14;\n  }\n  result = (unsigned int)(v14 + (int)((abs32(a2) - v14) * v13) / v15);\n  if ( (a2 & 0x80000000) != 0 )\n    return (unsigned int)-(int)result;\n  return result;\n}\n",
    "source_code": "static int apply_envelope(struct ml_effect_state *state, int value,\n\t\t\t  struct ff_envelope *envelope)\n{\n\tstruct ff_effect *effect = state->effect;\n\tunsigned long now = jiffies;\n\tint time_from_level;\n\tint time_of_envelope;\n\tint envelope_level;\n\tint difference;\n\n\tif (envelope->attack_length &&\n\t    time_before(now,\n\t\t\tstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\n\t\tpr_debug(\"value = 0x%x, attack_level = 0x%x\\n\",\n\t\t\t value, envelope->attack_level);\n\t\ttime_from_level = jiffies_to_msecs(now - state->play_at);\n\t\ttime_of_envelope = envelope->attack_length;\n\t\tenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\n\n\t} else if (envelope->fade_length && effect->replay.length &&\n\t\t   time_after(now,\n\t\t\t      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\n\t\t   time_before(now, state->stop_at)) {\n\t\ttime_from_level = jiffies_to_msecs(state->stop_at - now);\n\t\ttime_of_envelope = envelope->fade_length;\n\t\tenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\n\t} else\n\t\treturn value;\n\n\tdifference = abs(value) - envelope_level;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\tpr_debug(\"time_from_level = 0x%x\\n\", time_from_level);\n\tpr_debug(\"time_of_envelope = 0x%x\\n\", time_of_envelope);\n\n\tdifference = difference * time_from_level / time_of_envelope;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\n\treturn value < 0 ?\n\t\t-(difference + envelope_level) : (difference + envelope_level);\n}",
    "comment": "Adjusts the input value based on an attack or fade envelope, modifying the output according to the elapsed time and specified envelope levels.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Processes input events , updates mouse device state , and manages timer interrupt based on current time and previous state changes .\n",
    "cpbcs_sum": "Processes USB request blocks by checking their status and time constraints, then moves them to a timer for further handling.\n",
    "misum_sum": "Processes mouse input events by a value to a specified value, retrying on an effect reply and waking up to a multiple times if found.\n",
    "decom_sum": "Adjusts the input value toward a target limit based on buffer capacity and thresholds, applying scaling when resource constraints are detected.",
    "cfg_sum": "Adjusts the input value based on memory availability and constraints, using scaled division of its magnitude with specified limits and sign preservation.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a filled buffer or null based on a Unicode character's name, and performing an uppercase ASCII lookup, are entirely unrelated to the source code. The source code implements an envelope function for force feedback effects with parameters for attack and fade durations, and does not involve character names or Unicode processing. All extracted claims are inaccurate, resulting in no alignment with the implementation.",
                "The summary is entirely inaccurate, describing a function that looks up a Unicode character\u2019s name and returns a buffer or null, which is unrelated to the source code. The actual code applies an attack or fade envelope to an effect\u2019s value based on timing and envelope parameters. It misses the primary purpose and all secondary details, providing no coverage of the function\u2019s semantics.",
                "The summary's claims about returning a filled buffer or null and looking up a Unicode character name are entirely unrelated to the source code, which applies an envelope to a force-feedback effect's value based on attack and fade timing. All claims are NOISE, targeting a different functionality, leading to severe mismatch and zero usable information."
            ]
        },
        "bint5": {
            "summary": "Processes input events , updates mouse device state , and manages timer interrupt based on current time and previous state changes .\n",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary's claims about processing input events, updating mouse device state, and managing timer interrupts do not align with the source code, which handles applying an envelope to an effect's value based on attack and fade timings. None of the claims accurately reflect the semantics or operations in the provided code, resulting in no ACCURATE matches.",
                "The summary describes processing input events, updating mouse device state, and managing timer interrupts, which is unrelated to the source code. The function in the source applies an attack/fade envelope to an effect's value based on timing conditions and envelope parameters. The summary misses the primary purpose entirely and provides no accurate claims about the actual behavior, inputs, or outputs of the function.",
                "The summary claims the function processes input events, updates mouse device state, and manages timer interrupts, but the source code is actually applying an envelope (attack/fade) to a force feedback effect value. The claims do not target the actual code semantics and are unrelated, making them NOISE. There are no accurate statements, and the overwhelming NOISE means the description provides no useful insight."
            ]
        },
        "cpbcs": {
            "summary": "Processes USB request blocks by checking their status and time constraints, then moves them to a timer for further handling.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function processes USB request blocks, checks status and time constraints, and moves them to a timer for further handling, but the source code deals with applying an attack/fade envelope to a force feedback effect's value based on timing. The claims do not match the code's purpose or semantics, resulting in no accurate alignment.",
                "The summary inaccurately describes the function as processing USB request blocks with timers, which is unrelated to the actual source code. The source implements an envelope application over an effect value, adjusting it based on attack and fade times and levels. This means the primary purpose is missed entirely, and none of the key secondary details are correctly captured.",
                "The summary is entirely inaccurate (NOISE) because it describes processing USB request blocks with timers, which is unrelated to the source code. The source actually applies an envelope function to an effect state based on attack and fade times, adjusting the value accordingly. There are no matching claims, and the description misrepresents the primary purpose, leading to no useful or accurate insights."
            ]
        },
        "misum": {
            "summary": "Processes mouse input events by a value to a specified value, retrying on an effect reply and waking up to a multiple times if found.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims do not align with the source code. The function in the source applies an envelope to an effect based on attack or fade parameters, using timing calculations and modifying the input value accordingly. The summary incorrectly describes processing mouse input events, retrying on an effect reply, and waking multiple times, none of which are present in the code. All claims are inaccurate, resulting in no accurate matches.",
                "The summary is inaccurate: it describes processing mouse input events and retry behavior, which are not present in the source code. The function actually applies an attack or fade envelope to an effect's value based on timing and envelope parameters, adjusting output accordingly. The primary purpose and all secondary details are missed, as the claims do not align with the implementation.",
                "The summary contains mostly inaccurate claims: it describes processing mouse input events, retries, and waking multiple times, none of which are present in the source code. The actual code applies an envelope to an effect's value based on attack or fade parameters, using timing and level calculations. These mismatches target core functionality (PRIMARY PURPOSE), making them fatal errors. There are no accurate claims to provide any positive gain."
            ]
        }
    }
}
{
    "project_name": "squashfs",
    "function_addr": 55264,
    "strip_function_name": "sub_D7E0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_D7E0(char *path, int a2)\n{\n  char *v4; // rax\n  void **v5; // r13\n  unsigned int v6; // ebp\n  char *v7; // rbx\n  int v8; // edi\n  int v9; // esi\n  unsigned int v10; // [rsp+4h] [rbp-34h] BYREF\n  unsigned __int64 v11; // [rsp+8h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  if ( dword_293988 || a2 == -1 || *((_QWORD *)&xmmword_293A30 + 1) == -1LL )\n    return __readfsqword(0x28u) ^ v11;\n  v4 = sub_D460(a2, &v10, 1);\n  v5 = (void **)v4;\n  if ( !v4 )\n  {\n    sub_3A90();\n    return __readfsqword(0x28u) ^ v11;\n  }\n  v6 = 0;\n  v7 = v4 + 8;\n  if ( v10 )\n  {\n    while ( 1 )\n    {\n      if ( dword_213694 )\n      {\n        if ( !v7[24] )\n          goto LABEL_9;\n      }\n      else\n      {\n        if ( dword_313B28 || !v7[24] )\n        {\nLABEL_9:\n          if ( lsetxattr(path, *(const char **)v7, *((const void **)v7 + 2), *((int *)v7 + 3), 0) == -1 )\n          {\n            v8 = *__errno_location();\n            if ( v8 == 95 )\n            {\n              sub_3A90();\n              sub_3A90();\n              sub_3A90();\n              dword_293988 = 1;\n            }\n            else if ( (v8 == 28 || v8 == 122) && dword_293984 <= 9 )\n            {\n              sub_3A90();\n              if ( ++dword_293984 == 10 )\n                sub_3A90();\n            }\n            else\n            {\n              strerror(v8);\n              sub_3A90();\n            }\n          }\n          goto LABEL_10;\n        }\n        if ( !dword_293980 )\n        {\n          sub_3A90();\n          sub_3A90();\n          sub_3A90();\n          dword_293980 = 1;\n        }\n      }\nLABEL_10:\n      v9 = v10;\n      ++v6;\n      v7 += 64;\n      if ( v6 >= v10 )\n        goto LABEL_21;\n    }\n  }\n  v9 = 0;\nLABEL_21:\n  sub_D420(v5, v9);\n  return __readfsqword(0x28u) ^ v11;\n}\n",
    "function_name": "write_xattr",
    "decompiled_code": "unsigned __int64 __fastcall write_xattr(char *path, int a2)\n{\n  char *xattr; // rax\n  void **v5; // r13\n  unsigned int v6; // ebp\n  char *v7; // rbx\n  int v8; // edi\n  int v9; // esi\n  unsigned int v10; // [rsp+4h] [rbp-34h] BYREF\n  unsigned __int64 v11; // [rsp+8h] [rbp-30h]\n\n  v11 = __readfsqword(0x28u);\n  if ( ignore_xattrs_10143 || a2 == -1 || *((_QWORD *)&xmmword_293A30 + 1) == -1LL )\n    return __readfsqword(0x28u) ^ v11;\n  xattr = get_xattr(a2, &v10, 1);\n  v5 = (void **)xattr;\n  if ( !xattr )\n  {\n    progressbar_error();\n    return __readfsqword(0x28u) ^ v11;\n  }\n  v6 = 0;\n  v7 = xattr + 8;\n  if ( v10 )\n  {\n    while ( 1 )\n    {\n      if ( user_xattrs )\n      {\n        if ( !v7[24] )\n          goto LABEL_9;\n      }\n      else\n      {\n        if ( root_process || !v7[24] )\n        {\nLABEL_9:\n          if ( lsetxattr(path, *(const char **)v7, *((const void **)v7 + 2), *((int *)v7 + 3), 0) == -1 )\n          {\n            v8 = *__errno_location();\n            if ( v8 == 95 )\n            {\n              progressbar_error();\n              progressbar_error();\n              progressbar_error();\n              ignore_xattrs_10143 = 1;\n            }\n            else if ( (v8 == 28 || v8 == 122) && nospace_error_10144 <= 9 )\n            {\n              progressbar_error();\n              if ( ++nospace_error_10144 == 10 )\n                progressbar_error();\n            }\n            else\n            {\n              strerror(v8);\n              progressbar_error();\n            }\n          }\n          goto LABEL_10;\n        }\n        if ( !nonsuper_error_10142 )\n        {\n          progressbar_error();\n          progressbar_error();\n          progressbar_error();\n          nonsuper_error_10142 = 1;\n        }\n      }\nLABEL_10:\n      v9 = v10;\n      ++v6;\n      v7 += 64;\n      if ( v6 >= v10 )\n        goto LABEL_21;\n    }\n  }\n  v9 = 0;\nLABEL_21:\n  free_xattr(v5, v9);\n  return __readfsqword(0x28u) ^ v11;\n}\n",
    "source_code": "\nvoid write_xattr(char *pathname, unsigned int xattr)\n{\n\tunsigned int count;\n\tstruct xattr_list *xattr_list;\n\tint i;\n\tstatic int nonsuper_error = FALSE;\n\tstatic int ignore_xattrs = FALSE;\n\tstatic int nospace_error = 0;\n\n\tif(ignore_xattrs || xattr == SQUASHFS_INVALID_XATTR ||\n\t\t\tsBlk.s.xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn;\n\n\txattr_list = get_xattr(xattr, &count, 1);\n\tif(xattr_list == NULL) {\n\t\tERROR(\"Failed to read xattrs for file %s\\n\", pathname);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < count; i++) {\n\t\tint prefix = xattr_list[i].type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif(user_xattrs && prefix != SQUASHFS_XATTR_USER)\n\t\t\tcontinue;\n\n\t\tif(root_process || prefix == SQUASHFS_XATTR_USER) {\n\t\t\tint res = lsetxattr(pathname, xattr_list[i].full_name,\n\t\t\t\txattr_list[i].value, xattr_list[i].vsize, 0);\n\n\t\t\tif(res == -1) {\n\t\t\t\tif(errno == ENOTSUP) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the destination filesystem cannot\n\t\t\t\t\t * suppport xattrs, print error, and\n\t\t\t\t\t * disable xattr output as this error is\n\t\t\t\t\t * unlikely to go away, and printing\n\t\t\t\t\t * screenfulls of the same error message\n\t\t\t\t\t * is rather annoying\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"extended attributes are not \"\n\t\t\t\t\t\t\"supported by the destination \"\n\t\t\t\t\t\t\"filesystem\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tERROR(\"Ignoring xattrs in \"\n\t\t\t\t\t\t\t\t\"filesystem\\n\");\n\t\t\t\t\tERROR(\"To avoid this error message, \"\n\t\t\t\t\t\t\"specify -no-xattrs\\n\");\n\t\t\t\t\tignore_xattrs = TRUE;\n\t\t\t\t} else if((errno == ENOSPC || errno == EDQUOT)\n\t\t\t\t\t\t&& nospace_error < NOSPACE_MAX) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Many filesystems like ext2/3/4 have\n\t\t\t\t\t * limits on the amount of xattr\n\t\t\t\t\t * data that can be stored per file\n\t\t\t\t\t * (typically one block or 4K), so\n\t\t\t\t\t * we shouldn't disable xattr ouput,\n\t\t\t\t\t * as the error may be restriced to one\n\t\t\t\t\t * file only.  If we get a lot of these\n\t\t\t\t\t * then suppress the error messsage\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"no extended attribute space \"\n\t\t\t\t\t\t\"remaining (per file or \"\n\t\t\t\t\t\t\"filesystem limit)\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tif(++ nospace_error == NOSPACE_MAX)\n\t\t\t\t\t\tERROR(\"%d of these errors \"\n\t\t\t\t\t\t\t\"printed, further error \"\n\t\t\t\t\t\t\t\"messages of this type \"\n\t\t\t\t\t\t\t\"are suppressed!\\n\",\n\t\t\t\t\t\t\tNOSPACE_MAX);\n\t\t\t\t} else\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \"\n\t\t\t\t\t\t\"%s\\n\", xattr_list[i].full_name,\n\t\t\t\t\t\tpathname, strerror(errno));\n\t\t\t}\n\t\t} else if(nonsuper_error == FALSE) {\n\t\t\t/*\n\t\t\t * if extract user xattrs only then\n\t\t\t * error message is suppressed, if not\n\t\t\t * print error, and then suppress further error\n\t\t\t * messages to avoid possible screenfulls of the\n\t\t\t * same error message!\n\t\t\t */\n\t\t\tERROR(\"write_xattr: could not write xattr %s \"\n\t\t\t\t\t\"for file %s because you're not \"\n\t\t\t\t\t\"superuser!\\n\",\n\t\t\t\t\txattr_list[i].full_name, pathname);\n\t\t\tERROR(\"write_xattr: to avoid this error message, either\"\n\t\t\t\t\" specify -user-xattrs, -no-xattrs, or run as \"\n\t\t\t\t\"superuser!\\n\");\n\t\t\tERROR(\"Further error messages of this type are \"\n\t\t\t\t\"suppressed!\\n\");\n\t\t\tnonsuper_error = TRUE;\n\t\t}\n\t}\n\n\tfree_xattr(xattr_list, count);\n}",
    "comment": "Writes extended attributes to a specified file while handling errors for unsupported filesystems, space limitations, and non-superuser access.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a backup file to a specified disk path if it exists and is not a directory , returning success status .\n",
    "cpbcs_sum": "Retrieves the target file path for a specified directory or user directory path based on the provided filename and directory name.\n",
    "misum_sum": "Searches for a matching process based on the given name and type, checking the validity and directory validity against predefined criteria.\n",
    "decom_sum": "Sets multiple extended file attributes on the specified path, handling specific errno cases and updating global error state flags.",
    "cfg_sum": "Updates extended file attributes for a given path based on security flags, handling specific error codes and limiting repeated failures.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague statement unrelated to the function's logic or specifics in the source code. It does not convey any accurate, fact-based claim about the implementation, resulting in no alignment with the evaluation steps.",
                "The summary 'push a pointer type' is vague, does not reflect the primary purpose of the function, and fails to capture any critical semantic units such as writing extended attributes, handling errors, or conditional logic. It is unrelated to the source code's actual behavior, making it inaccurate and providing no coverage.",
                "The summary contains a vague and unrelated statement that does not describe the function's behavior, inputs, outputs, or any structural detail from the source code. It is pure NOISE and provides no accurate or useful insight into how `write_xattr` operates. The absence of any accurate claims results in zero net benefit."
            ]
        },
        "bint5": {
            "summary": "Adds a backup file to a specified disk path if it exists and is not a directory , returning success status .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function adds a backup file to a specified disk path if it exists and is not a directory, but the source code actually writes extended attributes to a file, handling various error cases. None of the summary's assertions align with the implementation details, resulting in no accurate claims.",
                "The summary describes adding a backup file to a disk path with conditions about existence and directory status, which is entirely unrelated to the source code. The function in the source writes extended attributes to a file, handles specific error cases, and manages attribute lists. The summary misses the primary purpose and all secondary details from the implementation, making it completely inaccurate.",
                "The summary claims the function adds a backup file to a specified disk path and returns a success status, which is entirely unrelated to the source code. The source function writes extended attributes (xattrs) to a file, with multiple checks for validity, permissions, and error handling. This mismatch is a FATAL error affecting the primary purpose of the code, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the target file path for a specified directory or user directory path based on the provided filename and directory name.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves a target file path based on a filename and directory name, which is entirely inaccurate. The source code instead handles writing extended attributes to a given file path, including error handling for unsupported attributes, space limits, and permissions. None of the described behavior in the summary matches the actual code, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate, describing behavior related to retrieving a file path from a filename and directory name, which is unrelated to the source code. The function in the source writes extended file attributes (xattrs) to a file, with checks for invalid inputs, user permissions, filesystem support, and error handling. The summary misses the primary purpose and all secondary details, making no accurate claims.",
                "The summary claims the function retrieves a target file path based on a filename and directory name, which is entirely unrelated to the actual code. The source function writes extended attributes (xattrs) to a file, handles various error conditions, and may suppress repeated error messages. This is a FATAL error impacting the primary purpose since the summary misidentifies the fundamental operation and omits all relevant behavior."
            ]
        },
        "misum": {
            "summary": "Searches for a matching process based on the given name and type, checking the validity and directory validity against predefined criteria.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the code searches for a matching process by name and type and checks validity against criteria, which is unrelated to the actual source code. The source implements writing extended attributes to a file, handling errors for unsupported xattrs, insufficient space, and permission issues. None of the summary's claims align with the source code, resulting in no accurate statements.",
                "The summary describes searching for a process by name and type, with validity checks, which is completely unrelated to the source code's function. The source code writes extended attributes to a file, performs conditional checks for certain prefixes, handles multiple error scenarios, and frees resources. None of these primary or secondary details are addressed, indicating no alignment.",
                "The summary makes claims about searching for a process by name and type with directory validity checks, which is entirely unrelated to the source code's primary purpose of writing extended attributes to files and handling related errors. This is a complete mismatch (NOISE) with no accurate overlap, providing no useful insight into the code's semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579258624,
    "strip_function_name": "sub_FFFFFFFF81064F00",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81064F00(\n        __int64 a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // rax\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  _QWORD v20[2]; // [rsp+0h] [rbp-48h] BYREF\n  int v21; // [rsp+10h] [rbp-38h] BYREF\n  _BYTE v22[48]; // [rsp+18h] [rbp-30h] BYREF\n\n  sub_FFFFFFFF81790F30(a1);\n  v21 = 0;\n  sub_FFFFFFFF81060710((__int64)v22);\n  v20[0] = 0LL;\n  v20[1] = sub_FFFFFFFF81064B80;\n  sub_FFFFFFFF81792630(a1 + 16);\n  if ( *(_BYTE *)(a1 + 18) )\n  {\n    **(_QWORD **)(a1 + 32) = v20;\n    *(_QWORD *)(a1 + 32) = v20;\n    ++*(_BYTE *)(a1 + 16);\n    _enable();\n    return sub_FFFFFFFF81790F70(&v21);\n  }\n  v11 = *(_QWORD **)(a1 + 48);\n  *(_BYTE *)(a1 + 18) = 1;\n  *v11 = v20;\n  *(_QWORD *)(a1 + 48) = v20;\n  ++*(_BYTE *)(a1 + 16);\n  _enable();\n  sub_FFFFFFFF81064D70(a1, a2);\n  v17 = *(_QWORD **)(a1 + 80);\n  v18 = a1 + 72;\n  if ( v17 == (_QWORD *)(a1 + 72) )\n  {\n    sub_FFFFFFFF81064E60(a1, a3, a4, a5, a6, v15, v16, a9, a10, a2, v18, v12, v13, v14);\n    return sub_FFFFFFFF81790F70(&v21);\n  }\n  if ( *(_QWORD **)(a1 + 72) != v20 )\n    BUG();\n  v19 = v20[0];\n  *(_QWORD *)(a1 + 72) = v20[0];\n  if ( v17 == v20 )\n  {\n    *(_QWORD *)(a1 + 72) = 0LL;\n    *(_QWORD *)(a1 + 80) = v18;\n  }\n  return sub_FFFFFFFF81064E60(a1, a3, a4, a5, a6, v15, v16, a9, a10, a2, v18, v19, v13, v14);\n}\n",
    "function_name": "__synchronize_srcu",
    "decompiled_code": "__int64 __fastcall _synchronize_srcu(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned int v10; // r13d\n  __int64 v11; // rsi\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v15; // rax\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  _QWORD *v18; // rax\n  _QWORD v19[2]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned int v20; // [rsp+10h] [rbp-38h] BYREF\n  _BYTE v21[48]; // [rsp+18h] [rbp-30h] BYREF\n\n  v10 = a2;\n  cond_resched(a1, a2);\n  v11 = (__int64)\"&x->wait\";\n  v20 = 0;\n  _init_waitqueue_head((__int64)v21);\n  v19[0] = 0LL;\n  v19[1] = wakeme_after_rcu_0;\n  raw_spin_lock_irq((volatile signed __int16 *)(a1 + 16));\n  if ( *(_BYTE *)(a1 + 18) )\n  {\n    **(_QWORD **)(a1 + 32) = v19;\n    *(_QWORD *)(a1 + 32) = v19;\n    ++*(_BYTE *)(a1 + 16);\n    _enable();\n    return wait_for_completion(&v20, v11, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  v15 = *(_QWORD **)(a1 + 48);\n  *(_BYTE *)(a1 + 18) = 1;\n  *v15 = v19;\n  *(_QWORD *)(a1 + 48) = v19;\n  ++*(_BYTE *)(a1 + 16);\n  _enable();\n  v11 = v10;\n  srcu_advance_batches(a1, v10);\n  v18 = *(_QWORD **)(a1 + 80);\n  if ( v18 == (_QWORD *)(a1 + 72) )\n  {\n    srcu_reschedule(a1, a3, a4, a5, a6, v16, v17, a9, a10);\n    return wait_for_completion(&v20, v11, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  if ( *(_QWORD **)(a1 + 72) != v19 )\n    BUG();\n  *(_QWORD *)(a1 + 72) = v19[0];\n  if ( v18 == v19 )\n  {\n    *(_QWORD *)(a1 + 72) = 0LL;\n    *(_QWORD *)(a1 + 80) = a1 + 72;\n  }\n  return srcu_reschedule(a1, a3, a4, a5, a6, v16, v17, a9, a10);\n}\n",
    "source_code": "static void __synchronize_srcu(struct srcu_struct *sp, int trycount)\n{\n\tstruct rcu_synchronize rcu;\n\tstruct rcu_head *head = &rcu.head;\n\tbool done = false;\n\n\trcu_lockdep_assert(!lock_is_held(&sp->dep_map) &&\n\t\t\t   !lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"Illegal synchronize_srcu() in same-type SRCU (or RCU) read-side critical section\");\n\n\tmight_sleep();\n\tinit_completion(&rcu.completion);\n\n\thead->next = NULL;\n\thead->func = wakeme_after_rcu;\n\tspin_lock_irq(&sp->queue_lock);\n\tif (!sp->running) {\n\t\t/* steal the processing owner */\n\t\tsp->running = true;\n\t\trcu_batch_queue(&sp->batch_check0, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\n\t\tsrcu_advance_batches(sp, trycount);\n\t\tif (!rcu_batch_empty(&sp->batch_done)) {\n\t\t\tBUG_ON(sp->batch_done.head != head);\n\t\t\trcu_batch_dequeue(&sp->batch_done);\n\t\t\tdone = true;\n\t\t}\n\t\t/* give the processing owner to work_struct */\n\t\tsrcu_reschedule(sp);\n\t} else {\n\t\trcu_batch_queue(&sp->batch_queue, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\t}\n\n\tif (!done)\n\t\twait_for_completion(&rcu.completion);\n}",
    "comment": "Synchronizes SRCU processing by queuing a completion task and waiting for it to finish if not already done by the processing owner.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Cleans up and frees resources associated with a task structure , ensuring it is not in use before releasing its memory .\n",
    "cpbcs_sum": "Handles the cancellation of a scheduled timer by executing a callback and managing its states in a cgroup, manner.\n",
    "misum_sum": "Flushes a workqueue by executing its control function, updating its state, managing its states and ensuring thread safety with a mutex lock.\n",
    "decom_sum": "Initializes internal queue pointers, enables interrupts, and dispatches a floating\u2011point parameter packet to a handler based on current queue state.",
    "cfg_sum": "Initializes and links queue structures, updates control flags, invokes processing routines, and re-enables interrupts to synchronize and continue hardware data handling.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' is vague, low-information, and fails to capture any specific behavior or semantics from the source code. It does not reflect the function's actual operations, such as queueing RCU callbacks, synchronization steps, or locking mechanisms. This makes it irrelevant to the code, resulting in no accurate claims.",
                "The summary 'push a pointer type.' is vague, does not accurately represent the function's primary purpose of synchronizing SRCU by queuing and processing RCU callbacks, and misses all critical semantic details such as lock assertions, completion handling, and batch operations. It targets neither the actual semantics nor observable behavior from the source code, providing no valid coverage.",
                "The summary 'push a pointer type.' is vague, low-information, and does not align with the source code's actual functionality, which involves synchronizing SRCU, queuing RCU batches, and handling completions. It introduces NOISE rather than accurate insight, with no specific or correct claim about primary purpose or I/O. The worst failure mode is overwhelming NOISE and zero useful detail."
            ]
        },
        "bint5": {
            "summary": "Cleans up and frees resources associated with a task structure , ensuring it is not in use before releasing its memory .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes cleanup and memory release for a task structure, which does not match the source code that implements SRCU synchronization by queuing work, advancing batches, and waiting for completion. None of the claims in the summary are accurate with respect to the actual SRCU synchronization logic, resulting in no alignment with the source semantics.",
                "The summary incorrectly describes cleaning up and freeing a task structure, which is unrelated to the source code. The source code manages SRCU synchronization, queuing and processing batches, and potentially waiting for completion, with specific lock and sleep checks. The summary misses the primary purpose entirely and introduces unrelated semantics, leading to no coverage of critical details.",
                "The summary claims the function cleans up and frees resources for a task structure, ensuring it is not in use before releasing memory. This is completely inaccurate as the source code implements SRCU synchronization logic, queuing batches, advancing, dequeuing, and waiting for completion. There is no memory deallocation or task structure handling, making the claim a FATAL error about the primary purpose. This causes high negative impact and unreliability."
            ]
        },
        "cpbcs": {
            "summary": "Handles the cancellation of a scheduled timer by executing a callback and managing its states in a cgroup, manner.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function cancels a scheduled timer, executes a callback, and manages its states within a cgroup. The source code instead implements SRCU synchronization, involving lock assertions, queue management, batch processing, and waiting for completion. None of the claims align with the actual purpose or operations in the code, making all claims inaccurate.",
                "The summary describes cancellation of a scheduled timer and cgroup state management, which is entirely unrelated to the source code. The function in the source handles synchronizing SRCU by queuing work, advancing batches, asserting lock conditions, and waiting for completion. The summary fails to capture the primary purpose or any secondary details of the actual implementation, and its claims are inaccurate and non-verifiable against the source.",
                "The summary's claim that the function handles cancellation of a scheduled timer within a cgroup by executing a callback and managing states is entirely unrelated to the source code, which implements SRCU synchronization with batch queuing, completion handling, and lock assertions. All claims are NOISE, targeting an unrelated domain, resulting in high negative impact and no accurate insight for understanding the actual synchronization mechanism."
            ]
        },
        "misum": {
            "summary": "Flushes a workqueue by executing its control function, updating its state, managing its states and ensuring thread safety with a mutex lock.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about flushing a workqueue, executing a control function, managing states, and ensuring thread safety with a mutex lock do not align with the source code, which manages SRCU synchronization using completions, spin locks, and batch queues. None of the summary's elements accurately reflect the actual functions, mechanisms, or synchronization primitives in the implementation.",
                "The summary incorrectly describes the function as flushing a workqueue and using a mutex lock, which contradicts the source code. The source handles SRCU synchronization, asserts no locks are held from specific RCU maps, uses spin locks for queue management, and waits for completion. It neither flushes a generic workqueue nor uses a mutex, so the primary purpose and key behaviors are missed entirely.",
                "The summary's claims about flushing a workqueue, executing a control function, updating states, and ensuring thread safety via a mutex lock do not match the source code, which deals with SRCU synchronization, RCU batch queuing, and completion handling without any workqueue or mutex usage. These are semantic contradictions about the primary purpose and key operations, representing a FATAL failure mode with high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579041760,
    "strip_function_name": "sub_FFFFFFFF8102FFE0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8102FFE0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 *v6; // r14\n  unsigned __int64 v7; // rbx\n  unsigned __int64 v8; // rsi\n  __int64 result; // rax\n  __int64 v10; // rax\n  unsigned __int64 v11; // rdx\n  __int64 v12; // rdx\n  unsigned __int64 v13; // [rsp+0h] [rbp-38h]\n  unsigned __int64 v14; // [rsp+0h] [rbp-38h]\n  __int64 v15; // [rsp+8h] [rbp-30h]\n\n  v15 = *(_BYTE *)(a1 + 24) != 0 ? 0x110 : 0;\n  if ( a3 < a4 )\n  {\n    do\n    {\n      v6 = (unsigned __int64 *)(a2 + 8 * (v15 + ((a3 >> 39) & 0x1FF)));\n      v7 = (a3 & 0xFFFFFF8000000000LL) + 0x8000000000LL;\n      v8 = *v6;\n      if ( a4 <= v7 )\n        v7 = a4;\n      if ( (v8 & 1) != 0 )\n      {\n        result = sub_FFFFFFFF8102FCE0(a1, (v8 & 0x3FFFFFFFF000LL) - 0x780000000000LL, a3, v7);\n        if ( (_DWORD)result )\n          return result;\n      }\n      else\n      {\n        v13 = a3;\n        v10 = (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));\n        if ( !v10 )\n          return 4294967284LL;\n        v11 = v13;\n        v14 = v10;\n        result = sub_FFFFFFFF8102FCE0(a1, v10, v11, v7);\n        if ( (_DWORD)result )\n          return result;\n        v12 = 0x77FF80000000LL;\n        if ( v14 >= 0xFFFFFFFF80000000LL )\n          v12 = qword_FFFFFFFF81C10010;\n        *v6 = (v12 + v14 + 0x80000000) | 0x63;\n      }\n      a3 = v7;\n    }\n    while ( v7 < a4 );\n  }\n  return 0LL;\n}\n",
    "function_name": "kernel_ident_mapping_init",
    "decompiled_code": "__int64 __fastcall kernel_ident_mapping_init(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 *v6; // r14\n  unsigned __int64 v7; // rbx\n  unsigned __int64 v8; // rsi\n  __int64 result; // rax\n  __int64 v10; // rax\n  unsigned __int64 v11; // rdx\n  __int64 v12; // rdx\n  unsigned __int64 v13; // [rsp+0h] [rbp-38h]\n  unsigned __int64 v14; // [rsp+0h] [rbp-38h]\n  __int64 v15; // [rsp+8h] [rbp-30h]\n\n  v15 = *(_BYTE *)(a1 + 24) != 0 ? 0x110 : 0;\n  if ( a3 < a4 )\n  {\n    do\n    {\n      v6 = (unsigned __int64 *)(a2 + 8 * (v15 + ((a3 >> 39) & 0x1FF)));\n      v7 = (a3 & 0xFFFFFF8000000000LL) + 0x8000000000LL;\n      v8 = *v6;\n      if ( a4 <= v7 )\n        v7 = a4;\n      if ( (v8 & 1) != 0 )\n      {\n        result = ident_pud_init(a1, (v8 & 0x3FFFFFFFF000LL) - 0x780000000000LL, a3, v7);\n        if ( (_DWORD)result )\n          return result;\n      }\n      else\n      {\n        v13 = a3;\n        v10 = (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));\n        if ( !v10 )\n          return 4294967284LL;\n        v11 = v13;\n        v14 = v10;\n        result = ident_pud_init(a1, v10, v11, v7);\n        if ( (_DWORD)result )\n          return result;\n        v12 = 0x77FF80000000LL;\n        if ( v14 >= 0xFFFFFFFF80000000LL )\n          v12 = phys_base;\n        *v6 = (v12 + v14 + 0x80000000) | 0x63;\n      }\n      a3 = v7;\n    }\n    while ( v7 < a4 );\n  }\n  return 0LL;\n}\n",
    "source_code": "\nint kernel_ident_mapping_init(struct x86_mapping_info *info, pgd_t *pgd_page,\n\t\t\t      unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\tint result;\n\tint off = info->kernel_mapping ? pgd_index(__PAGE_OFFSET) : 0;\n\n\tfor (; addr < end; addr = next) {\n\t\tpgd_t *pgd = pgd_page + pgd_index(addr) + off;\n\t\tpud_t *pud;\n\n\t\tnext = (addr & PGDIR_MASK) + PGDIR_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (pgd_present(*pgd)) {\n\t\t\tpud = pud_offset(pgd, 0);\n\t\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpud = (pud_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pud)\n\t\t\treturn -ENOMEM;\n\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\t\tset_pgd(pgd, __pgd(__pa(pud) | _KERNPG_TABLE));\n\t}\n\n\treturn 0;\n}",
    "comment": "Initializes kernel identity mapping by setting up page entries in the page global directory for the specified address range, allocating pages as needed.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Maps a range of IOVA addresses to physical addresses in a device 's address space , handling page table entries and flushing the IOMMU as needed .\n",
    "cpbcs_sum": "Maps a range of memory pages for a device, handling page table entries and flushing the page cache if necessary.\n",
    "misum_sum": "Maps a page to a DMA domain, handling page allocation and page table entries in a specified address space.\n",
    "decom_sum": "Allocates and maps memory page table entries for a virtual address range, creating new tables when absent and linking them with proper flags.",
    "cfg_sum": "Processes a virtual memory range by mapping missing pages, invoking allocation and mapping routines, and returning status codes for successes or failures.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving control character replacement, escape sequences, static buffers, and Unicode handling, which is unrelated to the source code provided. The source implements kernel page table initialization logic for identity mapping in x86, with no mention of string processing or Unicode. All claims are inaccurate and do not match the code\u2019s semantics.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode are entirely unrelated to the source code, which initializes kernel identity mapping for x86 by traversing PGD entries, allocating PUD pages, handling page table setup, and returning error codes as needed. None of the summary's statements align with the primary purpose or secondary details of the actual implementation.",
                "The summary's claims about replacing control characters with escape sequences, using a static buffer, and handling Unicode display are entirely unrelated to the actual source code, which implements a kernel page table mapping initialization routine. All extracted claims are NOISE, overwhelming any accurate content, resulting in no alignment with the code\u2019s semantics."
            ]
        },
        "bint5": {
            "summary": "Maps a range of IOVA addresses to physical addresses in a device 's address space , handling page table entries and flushing the IOMMU as needed .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims mapping of IOVA addresses to physical addresses within a device's address space and mentions handling page table entries with IOMMU flushing. The source code instead deals with kernel identity mapping of virtual addresses in the x86 page table without any reference to IOVA or IOMMU flushing. None of the claims match the source implementation, making all claims inaccurate.",
                "The summary misidentifies the function's domain and purpose. The source code shows it initializes kernel identity mappings in x86 page tables, calculating pgd offsets, allocating pud pages, and setting entries, without any mention of IOVA, device address spaces, or IOMMU flushing. This makes the claim inaccurate with no coverage of the actual primary purpose or key secondary details.",
                "The summary claims the function maps IOVA addresses to physical addresses in a device\u2019s address space and flushes the IOMMU, which contradicts the source code semantics. The source code handles kernel identity mapping between virtual addresses and page tables, with no mention of IOVA, device-specific address space, or IOMMU flushing. This is a FATAL inaccuracy regarding the primary purpose and key I/O, causing high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Maps a range of memory pages for a device, handling page table entries and flushing the page cache if necessary.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function maps memory pages for a device and flushes the page cache if necessary. The source code shows it sets up identity mappings for kernel memory by iterating over addresses, allocating page tables, and initializing PUDs, with no device-specific handling or page cache flushing. Both claims are inaccurate and not grounded in the actual code, resulting in no accurate matches.",
                "The summary claims the function maps memory pages for a device and mentions flushing the page cache, which is not reflected in the source code. The source implements kernel identity mapping for a given address range, iterating over PGD entries, allocating PUD tables if absent, and initializing them via ident_pud_init. There is no device-specific logic or page cache flushing, making the claims inaccurate and missing the primary purpose and details of the code.",
                "The summary claims the function maps memory pages for a device and flushes the page cache, but the source code shows it initializes identity mappings for kernel address ranges, configuring PGD/PUD entries, without any device-specific logic or page cache flushing. These are inaccurate semantic claims about the primary purpose, making them FATAL errors. There are no accurate details to offset this negative impact."
            ]
        },
        "misum": {
            "summary": "Maps a page to a DMA domain, handling page allocation and page table entries in a specified address space.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about mapping to a DMA domain are inaccurate because the source code deals with kernel identity mapping in the x86 page table, not DMA domains. While it does handle page allocation and page table entries, the context of a specified address space for DMA is misleading and not supported by the implementation. Only part of the summary aligns with the actual code, resulting in low accuracy.",
                "The summary incorrectly states the function maps a page to a DMA domain. The source code shows the function initializes kernel identity mappings between given start and end addresses, working with PGD/PUD entries and allocating page tables if needed. It does not reference DMA domains at all, making the primary purpose misrepresented. While page allocation and page table entry manipulation are mentioned, these appear in a completely different context. This misses both the true primary purpose and key details such as the loop over address ranges, offset calculation, and error handling for allocation failures.",
                "The summary contains a single claim stating the function maps a page to a DMA domain, which is inaccurate because the source code does not mention DMA domains at all; instead it initializes kernel identity mappings and page table entries. This is a FATAL error affecting the primary purpose. Although it mentions page allocation and page table entries, which matches the code, the central function role is mischaracterized, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "sed",
    "function_addr": 4273792,
    "strip_function_name": "sub_413680",
    "strip_decompiled_code": "__int64 __fastcall sub_413680(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  void *v6; // rax\n  __int64 v7; // rbx\n  __int64 v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rsi\n\n  v4 = a2[2];\n  *a2 = a3;\n  a2[5] = 0LL;\n  a2[4] = v4;\n  v6 = malloc(8 * v4);\n  a2[6] = v6;\n  if ( !v6 )\n    return 12LL;\n  if ( v4 > 0 )\n  {\n    v7 = 0LL;\n    while ( (*(_BYTE *)(*a1 + 16LL * *(_QWORD *)(a2[3] + 8 * v7) + 8) & 8) != 0\n         || (unsigned __int8)sub_4134E0(a2 + 4, *(_QWORD *)(a2[3] + 8 * v7)) )\n    {\n      if ( a2[2] <= ++v7 )\n        goto LABEL_8;\n    }\n    return 12LL;\n  }\nLABEL_8:\n  v9 = a1[8] + 24 * (a1[17] & a3);\n  v10 = *(_QWORD *)v9;\n  v11 = *(_QWORD **)(v9 + 16);\n  v12 = *(_QWORD *)v9 + 1LL;\n  if ( *(_QWORD *)(v9 + 8) <= *(_QWORD *)v9 )\n  {\n    v11 = realloc(*(void **)(v9 + 16), 16 * v12);\n    if ( v11 )\n    {\n      v10 = *(_QWORD *)v9;\n      *(_QWORD *)(v9 + 16) = v11;\n      *(_QWORD *)(v9 + 8) = 2 * v12;\n      v12 = v10 + 1;\n      goto LABEL_9;\n    }\n    return 12LL;\n  }\nLABEL_9:\n  *(_QWORD *)v9 = v12;\n  v11[v10] = a2;\n  return 0LL;\n}\n",
    "function_name": "register_state",
    "decompiled_code": "__int64 __fastcall register_state(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  void *v6; // rax\n  __int64 v7; // rbx\n  __int64 v9; // rbx\n  __int64 v10; // rdx\n  _QWORD *v11; // rax\n  __int64 v12; // rsi\n\n  v4 = a2[2];\n  *a2 = a3;\n  a2[5] = 0LL;\n  a2[4] = v4;\n  v6 = malloc(8 * v4);\n  a2[6] = v6;\n  if ( !v6 )\n    return 12LL;\n  if ( v4 > 0 )\n  {\n    v7 = 0LL;\n    while ( (*(_BYTE *)(*a1 + 16LL * *(_QWORD *)(a2[3] + 8 * v7) + 8) & 8) != 0\n         || (unsigned __int8)re_node_set_insert_last(a2 + 4, *(_QWORD *)(a2[3] + 8 * v7)) )\n    {\n      if ( a2[2] <= ++v7 )\n        goto LABEL_8;\n    }\n    return 12LL;\n  }\nLABEL_8:\n  v9 = a1[8] + 24 * (a1[17] & a3);\n  v10 = *(_QWORD *)v9;\n  v11 = *(_QWORD **)(v9 + 16);\n  v12 = *(_QWORD *)v9 + 1LL;\n  if ( *(_QWORD *)(v9 + 8) <= *(_QWORD *)v9 )\n  {\n    v11 = realloc(*(void **)(v9 + 16), 16 * v12);\n    if ( v11 )\n    {\n      v10 = *(_QWORD *)v9;\n      *(_QWORD *)(v9 + 16) = v11;\n      *(_QWORD *)(v9 + 8) = 2 * v12;\n      v12 = v10 + 1;\n      goto LABEL_9;\n    }\n    return 12LL;\n  }\nLABEL_9:\n  *(_QWORD *)v9 = v12;\n  v11[v10] = a2;\n  return 0LL;\n}\n",
    "source_code": "\nstatic reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
    "comment": "Registers a new DFA state in the state table, allocating memory as needed and populating non-epsilon nodes.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Initializes a hash table structure by allocating memory for buckets and rehashing existing buckets based on their hash values .\n",
    "cpbcs_sum": "Inserts a new entry into a hash table, handling duplicates and maintaining the table with the key and name indices for efficient regex matching entries.\n",
    "misum_sum": "Retrieves a dynamically loaded symbol from a cached file, allocating memory and updating the target array if not found.\n",
    "decom_sum": "Initializes and validates an entry structure, allocates its associated array, and appends it to a dynamically managed list in the container object.",
    "cfg_sum": "Initializes a data structure with provided parameters, allocates and validates its elements, and inserts it into a dynamically managed indexed collection.",
    "work_score": {
        "hext5": {
            "summary": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains claims unrelated to the source code, mentioning indexes, item selection, analyzers, and jtable usage, which do not appear in or match the actual implementation. None of the claims align with the function's real behavior of allocating non-epsilon nodes and adding the new state to the state table. This results in no accurate claims.",
                "The summary is completely unrelated to the source code. The source code implements a function that registers a DFA state, initializes its non-epsilon node set, manages memory allocation for the state table, and handles allocation failures, returning specific error codes. The summary instead describes selecting an item from a list, calling unrelated functions, and processing table data for an analyzer, none of which aligns with the actual function\u2019s purpose or observable behavior. It misses the primary purpose and all secondary details.",
                "The summary contains NOISE and appears completely unrelated to the source code. It talks about selecting an item from a list, calling 'dbegetfunclist', and generating tabular data for an analyzer, none of which are present in the function implementation. The source code registers a DFA state, allocates non-epsilon nodes, and manages a state table, so there is no alignment. This is a worst-case mismatch due to irrelevance, with no accurate claims or useful insights."
            ]
        },
        "bint5": {
            "summary": "Initializes a hash table structure by allocating memory for buckets and rehashing existing buckets based on their hash values .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes a hash table and rehashes existing buckets, but the source code specifically registers a new DFA state, allocates memory for its non-epsilon nodes, and possibly resizes an array in the state table. There is no logic for global hash table initialization or rehashing of existing buckets, making the statement inaccurate with respect to the code.",
                "The summary incorrectly describes the function as initializing a hash table with bucket allocation and rehashing, which is not supported by the source code. The source function registers a DFA state: sets its hash, allocates and populates non-epsilon nodes, potentially reallocates the state table's array if full, and inserts the state. There is no evidence of creating buckets or rehashing existing ones. The description is targeted at code semantics but contradictory, missing the primary purpose entirely.",
                "The summary claims the function initializes a hash table by allocating buckets and rehashing, which is inaccurate. The source code shows it registers a DFA state, allocates memory for non-epsilon nodes, inserts them, and possibly resizes the state table array, but does not perform bucket initialization or rehashing. This is a FATAL error targeting the primary purpose and key operations, severely misleading understanding."
            ]
        },
        "cpbcs": {
            "summary": "Inserts a new entry into a hash table, handling duplicates and maintaining the table with the key and name indices for efficient regex matching entries.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function inserts a new entry into a hash table while handling duplicates and maintaining key and name indices for efficient regex matching. The source code does insert a new state into a hash-based state table for a DFA, but there is no logic for handling duplicates or managing key/name indices. Instead, it allocates memory for non-epsilon nodes and ensures capacity in the state table. The majority of the claims are inaccurate or unsupported by the source code.",
                "The summary claims handling of duplicates, usage of key and name indices, and regex matching entries, none of which are present in the source code. The actual function assigns a hash and builds a set of non-epsilon nodes, reallocates the state table array if needed, and appends the new state, returning appropriate error codes. The primary purpose of registering a DFA state and memory allocation handling is missed, and most claims are inaccurate.",
                "The summary claims the function inserts a new entry into a hash table and handles duplicates with key and name indices for efficient regex matching. The source code shows insertion into a state table based on a hash, but there is no handling of duplicates or any concept of key and name indices; instead, it deals with regex DFA states and non-epsilon nodes. These inaccuracies directly misrepresent key implementation details, making them FATAL errors about the primary purpose."
            ]
        },
        "misum": {
            "summary": "Retrieves a dynamically loaded symbol from a cached file, allocating memory and updating the target array if not found.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes retrieving a dynamically loaded symbol from a cached file, which does not match the source code's functionality of registering a DFA state, allocating space for non-epsilon nodes, and managing the state table. All claims in the summary are unrelated to the actual code semantics, resulting in no accurate alignment.",
                "The summary describes retrieving a dynamic symbol from a cached file, which is unrelated to the actual function in the source code. The code registers a DFA state by setting its hash, populating non-epsilon nodes, reallocating memory in a state table if necessary, and updating the entry. The primary purpose and all secondary details in the source are missed, and the summary contains entirely inaccurate semantics.",
                "The summary's claim that the function retrieves a dynamically loaded symbol from a cached file is entirely inaccurate; the source code actually registers a DFA state, allocates space for non-epsilon nodes, and updates a state table entry. This is a FATAL error targeting the primary purpose and key operations, leading to high negative impact. No accurate claims are present to add value."
            ]
        }
    }
}
{
    "project_name": "apr",
    "function_addr": 115376,
    "strip_function_name": "apr_unix_mode2perms",
    "strip_decompiled_code": "__int64 __fastcall apr_unix_mode2perms(__int16 a1)\n{\n  __int64 result; // rax\n  unsigned int v2; // edx\n  unsigned int v3; // edx\n  unsigned int v4; // edx\n  unsigned int v5; // edx\n  unsigned int v6; // edx\n\n  result = (unsigned __int8)((a1 & 0x800) != 0) << 15;\n  v2 = ((a1 & 0x800) != 0) << 15;\n  BYTE1(v2) |= 4u;\n  if ( (a1 & 0x100) != 0 )\n    result = v2;\n  v3 = result;\n  if ( (a1 & 0x80u) != 0 )\n  {\n    BYTE1(v3) = BYTE1(result) | 2;\n    result = v3;\n  }\n  v4 = result;\n  if ( (a1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(result) | 1;\n    result = v4;\n  }\n  v5 = result;\n  if ( (a1 & 0x400) != 0 )\n  {\n    BYTE1(v5) = BYTE1(result) | 0x40;\n    result = v5;\n  }\n  if ( (a1 & 0x20) != 0 )\n    result = (unsigned int)result | 0x40;\n  if ( (a1 & 0x10) != 0 )\n    result = (unsigned int)result | 0x20;\n  if ( (a1 & 8) != 0 )\n    result = (unsigned int)result | 0x10;\n  v6 = result;\n  if ( (a1 & 0x200) != 0 )\n  {\n    BYTE1(v6) = BYTE1(result) | 0x20;\n    result = v6;\n  }\n  if ( (a1 & 4) != 0 )\n    result = (unsigned int)result | 4;\n  if ( (a1 & 2) != 0 )\n    result = (unsigned int)result | 2;\n  if ( (a1 & 1) != 0 )\n    return (unsigned int)result | 1;\n  return result;\n}\n",
    "function_name": "apr_unix_mode2perms",
    "decompiled_code": "__int64 __fastcall apr_unix_mode2perms(__int16 a1)\n{\n  __int64 result; // rax\n  unsigned int v2; // edx\n  unsigned int v3; // edx\n  unsigned int v4; // edx\n  unsigned int v5; // edx\n  unsigned int v6; // edx\n\n  result = (unsigned __int8)((a1 & 0x800) != 0) << 15;\n  v2 = ((a1 & 0x800) != 0) << 15;\n  BYTE1(v2) |= 4u;\n  if ( (a1 & 0x100) != 0 )\n    result = v2;\n  v3 = result;\n  if ( (a1 & 0x80u) != 0 )\n  {\n    BYTE1(v3) = BYTE1(result) | 2;\n    result = v3;\n  }\n  v4 = result;\n  if ( (a1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(result) | 1;\n    result = v4;\n  }\n  v5 = result;\n  if ( (a1 & 0x400) != 0 )\n  {\n    BYTE1(v5) = BYTE1(result) | 0x40;\n    result = v5;\n  }\n  if ( (a1 & 0x20) != 0 )\n    result = (unsigned int)result | 0x40;\n  if ( (a1 & 0x10) != 0 )\n    result = (unsigned int)result | 0x20;\n  if ( (a1 & 8) != 0 )\n    result = (unsigned int)result | 0x10;\n  v6 = result;\n  if ( (a1 & 0x200) != 0 )\n  {\n    BYTE1(v6) = BYTE1(result) | 0x20;\n    result = v6;\n  }\n  if ( (a1 & 4) != 0 )\n    result = (unsigned int)result | 4;\n  if ( (a1 & 2) != 0 )\n    result = (unsigned int)result | 2;\n  if ( (a1 & 1) != 0 )\n    return (unsigned int)result | 1;\n  return result;\n}\n",
    "source_code": "\napr_fileperms_t apr_unix_mode2perms(mode_t mode)\n{\n    apr_fileperms_t perms = 0;\n\n    if (mode & S_ISUID)\n        perms |= APR_USETID;\n    if (mode & S_IRUSR)\n        perms |= APR_UREAD;\n    if (mode & S_IWUSR)\n        perms |= APR_UWRITE;\n    if (mode & S_IXUSR)\n        perms |= APR_UEXECUTE;\n\n    if (mode & S_ISGID)\n        perms |= APR_GSETID;\n    if (mode & S_IRGRP)\n        perms |= APR_GREAD;\n    if (mode & S_IWGRP)\n        perms |= APR_GWRITE;\n    if (mode & S_IXGRP)\n        perms |= APR_GEXECUTE;\n\n#ifdef S_ISVTX\n    if (mode & S_ISVTX)\n        perms |= APR_WSTICKY;\n#endif\n    if (mode & S_IROTH)\n        perms |= APR_WREAD;\n    if (mode & S_IWOTH)\n        perms |= APR_WWRITE;\n    if (mode & S_IXOTH)\n        perms |= APR_WEXECUTE;\n\n    return perms;\n}",
    "comment": "Converts a Unix file mode into an APR file permissions representation by checking user, group, and others' read, write, and execute bits.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Converts UNIX file permissions into APR file permission constants by setting corresponding permissions bits .\n",
    "cpbcs_sum": "Generates polling events for POSIX polling events based on file mode and polling event flags for user, group, and permissions.\n",
    "misum_sum": "Converts POSIX polling events to APR polling event constants by checking specific event flags in the input parameter.\n",
    "decom_sum": "Converts a UNIX file mode bitmask into an APR-style permission bitfield, mapping read, write, execute, and special mode flags to internal representation.",
    "cfg_sum": "Converts a Unix file mode bitmask into a corresponding permission flag set encoded in a numerical status value.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving control character replacement, escape sequences, static buffers, and Unicode handling, none of which are present in the source code, which instead maps Unix file mode bits to APR file permission flags. All claims are unrelated to the actual implementation, resulting in no accurate matches.",
                "The summary is entirely inaccurate as it describes processing control characters, escape sequences, static buffers, and Unicode handling, none of which are present in the source code. The actual function converts UNIX mode bits into APR file permission flags. The primary purpose is missed completely, and no secondary details from the source are covered.",
                "The summary's claims are entirely unrelated to the source code. The source implements a function converting Unix mode_t bits into APR file permission flags, but the summary describes control character escaping, static buffer usage, and Unicode handling. These are all [INACCURATE] and constitute NOISE, overwhelming with no accurate claims, resulting in zero net benefit."
            ]
        },
        "bint5": {
            "summary": "Converts UNIX file permissions into APR file permission constants by setting corresponding permissions bits .\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function converts UNIX file permissions into APR file permission constants by setting corresponding bits, which matches the source code's logic for mapping mode flags to APR constants. While it is broad and lacks specifics on individual permission mappings, it is accurate overall and does not contradict the implementation.",
                "The summary accurately captures the primary purpose of the function\u2014translating UNIX file permission flags into APR-specific constants\u2014but it omits secondary details such as handling of special flags (setuid, setgid, sticky bit), and the mapping for user, group, and world read/write/execute permissions. There is no mention of the conditional compilation around the sticky bit check or the specific constants used, which reduces completeness.",
                "The summary accurately captures the primary purpose of the function, which is converting UNIX file permissions into APR file permission constants by setting related bits. This matches the source code's implementation, which checks each UNIX mode flag and sets the corresponding APR constant. However, the claim is broad and lacks specific details such as the exact flags or constants used, resulting in low informational gain despite being accurate. There are no inaccurate or contradictory claims, so there is no negative impact, but the gain is low."
            ]
        },
        "cpbcs": {
            "summary": "Generates polling events for POSIX polling events based on file mode and polling event flags for user, group, and permissions.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as generating POSIX polling events, whereas the source code converts a POSIX mode_t file mode into APR file permission flags for user, group, and others. The claim about handling permissions is loosely aligned, but the core focus on polling events is inaccurate and unrelated to the actual implementation. This results in most claims being inaccurate.",
                "The summary is inaccurate because it describes generating POSIX polling events, while the source code actually translates file mode flags (user, group, other permissions and special bits) into apr_fileperms_t permission bits. It misses the primary purpose entirely and does not cover any secondary details such as handling of S_ISUID, S_ISGID, S_ISVTX, or specific read/write/execute mappings.",
                "The summary is highly inaccurate: it claims the function generates POSIX polling events, which contradicts the source code\u2019s actual purpose of converting a mode_t bitmask into an apr_fileperms_t permission set. This is a FATAL error about the primary purpose. No accurate claims are present, resulting in zero net benefit."
            ]
        },
        "misum": {
            "summary": "Converts POSIX polling events to APR polling event constants by checking specific event flags in the input parameter.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes converting POSIX polling events to APR polling event constants, which is unrelated to the actual code. The source function translates POSIX file permission bits to APR file permission constants, not polling events. This is a semantic mismatch, meaning 0% of the claims are accurate.",
                "The summary incorrectly describes the function as converting POSIX polling events, while the source code actually converts POSIX file permission bits to APR permission constants by checking specific mode flags. This contradicts the primary purpose and misses all secondary details such as handling user, group, others permissions, and special mode bits like setuid, setgid, and sticky. No accurate claims are present.",
                "The summary incorrectly states that the function converts POSIX polling events to APR polling event constants, whereas the source code clearly converts POSIX file mode bits to APR file permission constants. This is a FATAL error targeting the primary purpose, undermining reliability. No accurate claims are present to provide meaningful gain."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 1056384,
    "strip_function_name": "sub_101E80",
    "strip_decompiled_code": "__int64 __fastcall sub_101E80(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // eax\n  int i; // ebp\n  __int64 v4; // rax\n\n  if ( *(_QWORD *)(a1 + 224) )\n    return 1LL;\n  v2 = X509_policy_check(\n         a1 + 168,\n         a1 + 176,\n         *(_QWORD *)(a1 + 160),\n         *(_QWORD *)(*(_QWORD *)(a1 + 40) + 48LL),\n         *(unsigned int *)(*(_QWORD *)(a1 + 40) + 24LL));\n  if ( v2 )\n  {\n    if ( v2 == -1 )\n    {\n      for ( i = 1; i < (int)sk_num(*(unsigned int **)(a1 + 160)); ++i )\n      {\n        v4 = sk_value(*(_QWORD *)(a1 + 160), i);\n        if ( (*(_BYTE *)(v4 + 73) & 8) != 0 )\n        {\n          *(_QWORD *)(a1 + 192) = v4;\n          *(_DWORD *)(a1 + 184) = 42;\n          result = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n          if ( !(_DWORD)result )\n            return result;\n        }\n      }\n      return 1LL;\n    }\n    if ( v2 == -2 )\n    {\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 43;\n      return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n    }\n    else\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 25LL) & 8) == 0 )\n        return 1LL;\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 0;\n      return (*(unsigned int (__fastcall **)(__int64, __int64))(a1 + 64))(2LL, a1) != 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(0xBu, 145, 65, (__int64)\"x509_vfy.c\", 1499);\n    return 0LL;\n  }\n}\n",
    "function_name": "check_policy",
    "decompiled_code": "__int64 __fastcall check_policy(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // eax\n  int i; // ebp\n  __int64 v4; // rax\n\n  if ( *(_QWORD *)(a1 + 224) )\n    return 1LL;\n  v2 = X509_policy_check(\n         (__int64 **)(a1 + 168),\n         (_DWORD *)(a1 + 176),\n         *(unsigned int **)(a1 + 160),\n         *(unsigned int **)(*(_QWORD *)(a1 + 40) + 48LL),\n         *(_DWORD *)(*(_QWORD *)(a1 + 40) + 24LL));\n  if ( v2 )\n  {\n    if ( v2 == -1 )\n    {\n      for ( i = 1; i < (int)sk_num(*(unsigned int **)(a1 + 160)); ++i )\n      {\n        v4 = sk_value(*(_QWORD *)(a1 + 160), i);\n        if ( (*(_BYTE *)(v4 + 73) & 8) != 0 )\n        {\n          *(_QWORD *)(a1 + 192) = v4;\n          *(_DWORD *)(a1 + 184) = 42;\n          result = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n          if ( !(_DWORD)result )\n            return result;\n        }\n      }\n      return 1LL;\n    }\n    if ( v2 == -2 )\n    {\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 43;\n      return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 64))(0LL, a1);\n    }\n    else\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 25LL) & 8) == 0 )\n        return 1LL;\n      *(_QWORD *)(a1 + 192) = 0LL;\n      *(_DWORD *)(a1 + 184) = 0;\n      return (*(unsigned int (__fastcall **)(__int64, __int64))(a1 + 64))(2LL, a1) != 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(0xBu, 145, 65, (__int64)\"x509_vfy.c\", 1499);\n    return 0LL;\n  }\n}\n",
    "source_code": "\nstatic int check_policy(X509_STORE_CTX *ctx)\n\t{\n\tint ret;\n\tif (ctx->parent)\n\t\treturn 1;\n\tret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n\t\t\t\tctx->param->policies, ctx->param->flags);\n\tif (ret == 0)\n\t\t{\n\t\tX509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\t/* Invalid or inconsistent extensions */\n\tif (ret == -1)\n\t\t{\n\t\t/* Locate certificates with bad extensions and notify\n\t\t * callback.\n\t\t */\n\t\tX509 *x;\n\t\tint i;\n\t\tfor (i = 1; i < sk_X509_num(ctx->chain); i++)\n\t\t\t{\n\t\t\tx = sk_X509_value(ctx->chain, i);\n\t\t\tif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n\t\t\t\tcontinue;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n\t\t\tif(!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\treturn 1;\n\t\t}\n\tif (ret == -2)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n\t\treturn ctx->verify_cb(0, ctx);\n\t\t}\n\n\tif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_OK;\n\t\tif (!ctx->verify_cb(2, ctx))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}",
    "comment": "Validates X509 certificate policies, checks for invalid extensions, and invokes a callback for policy notifications or errors during the verification process.",
    "hext5_sum": " the index of a human readable format.",
    "bint5_sum": "Validates the policies of an X509 certificate based on its auxiliary trust and constraints , returning success or failure status .\n",
    "cpbcs_sum": "Validates a certificate revocation by checking its status, handling both binary and soft characters, and manages memory for the certificate structure.\n",
    "misum_sum": "Validates an X.509 certificate by checking its validity and handling certificate verification based on the validation context and callback.\n",
    "decom_sum": "Validates an X.509 certificate chain\u2019s policy using `X509_policy_check` and triggers appropriate error handling callbacks based on the verification result.",
    "cfg_sum": "Validates X509 certificate policies, handles specific error codes and conditions, and triggers callbacks for success or detailed policy verification failures.",
    "work_score": {
        "hext5": {
            "summary": " the index of a human readable format.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary only mentions 'the index of a human readable format', which does not correspond to any specific behavior, variable, or logic in the source code. This is a non-targeted, vague statement that fails to capture the semantics of the code, resulting in no accurate claims.",
                "The summary does not reference any aspect of the source code's primary purpose or secondary details, such as policy checking, error handling, or callback invocation. It is unrelated and fails to capture observable behavior or constants from the implementation.",
                "The summary contains a vague and unrelated phrase that does not correspond to any functionality in the source code. It fails to mention the primary purpose, key input/output, or side effects of the function, making it entirely NOISE. No accurate claims are present, so there is zero net benefit to understanding the code."
            ]
        },
        "bint5": {
            "summary": "Validates the policies of an X509 certificate based on its auxiliary trust and constraints , returning success or failure status .\n",
            "score": [
                0.2,
                0.5,
                0.5
            ],
            "reason": [
                "The summary claims that the function validates policies of an X509 certificate based on auxiliary trust and constraints, but the source code shows policy checks using X509_policy_check, explicit policy, and flags, with specific handling for invalid policy extensions and notification flags. No mention of auxiliary trust is present in the code, making the claim inaccurate. The return of success or failure is broadly correct, but the main policy basis described is incorrect, resulting in less than half of the claims being accurate.",
                "The summary correctly conveys that the function validates X509 certificate policies and returns a status, capturing the primary purpose. However, it inaccurately mentions 'auxiliary trust and constraints,' which is not present in the code, and omits important secondary details such as early return when a parent exists, multiple specific return codes (-1, -2), handling of invalid policy extensions, use of error codes, and callbacks triggered under different conditions. This limits completeness and precision.",
                "The summary provides a broad, generic description of validating policies for an X509 certificate and returning success or failure, but it fails to mention specific implementation details from the source code such as handling ret values from X509_policy_check, special cases like parent contexts, invalid policy extensions, explicit policy errors, or notification flags. While not contradictory, the claim is low-info and omits the key branching logic and error handling, resulting in minimal positive gain. The worst failure mode here is NOISE due to oversimplification."
            ]
        },
        "cpbcs": {
            "summary": "Validates a certificate revocation by checking its status, handling both binary and soft characters, and manages memory for the certificate structure.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims are almost entirely inaccurate with respect to the source code. The function does not perform certificate revocation checks, nor does it handle binary or soft characters. It focuses on policy validation, error handling for policy extension issues, and notifying the verification callback. There is no mention or evidence of memory management for the certificate structure in this context.",
                "The summary claims focus on certificate revocation status checks, binary and soft character handling, and memory management, none of which match the source code's actual purpose of checking certificate policy compliance. The primary purpose is missed entirely, and no accurate coverage of key branches, errors, or policy conditions is present.",
                "The summary introduces multiple inaccurate claims about the code's purpose: it mentions certificate revocation, status checks, binary/soft character handling, and memory management for the certificate structure, none of which are present in the source. The source function checks certificate policy constraints and invokes callbacks for policy errors, without revocation logic or character handling. These contradictions target the primary purpose and key I/O, making them FATAL errors with high negative impact and no accurate insights."
            ]
        },
        "misum": {
            "summary": "Validates an X.509 certificate by checking its validity and handling certificate verification based on the validation context and callback.\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary states that the function validates an X.509 certificate and handles verification based on context and a callback. While the source function does perform policy checks and uses a callback mechanism, it specifically handles policy-related checks rather than general certificate validity. The summary omits these specifics and generalizes the behavior, making it broadly accurate but lacking detail. Given the generalization, most of the claim is SAFE.",
                "The summary captures the general purpose of certificate validation within a contextual and callback-based process, which aligns with the primary function goal. However, it omits critical secondary details present in the source code, such as handling specific return values from X509_policy_check, distinct error conditions (malloc failure, invalid policy extension, no explicit policy), iteration over certificate chain to locate problematic extensions, and conditional notification behavior based on flags. These omissions reduce completeness despite the primary purpose being correct.",
                "The summary makes a broad claim that the function validates an X.509 certificate and handles verification via context and callback. While generally SAFE, it is low-info and omits key specifics such as policy checking, detailed error handling for invalid extensions, explicit policy failures, and notify policy logic. There are no FATAL inaccuracies, but the lack of detailed, accurate claims limits its usefulness and constitutes low gain."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 35551,
    "strip_function_name": "sub_8ADF",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_8ADF(int *a1, int *a2, __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 v4; // rax\n  _BOOL4 v8; // [rsp+2Ch] [rbp-44h]\n  int v9[4]; // [rsp+30h] [rbp-40h] BYREF\n  int v10[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v11[24]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *(int *)(a3 + 4) < 0;\n  if ( (~a4 & (*(int *)(a3 + 4) < 0)) != 0 )\n    sub_B8A(\"mpz_rootrem: Negative argument, with even root.\");\n  if ( !a4 )\n    sub_B8A(\"mpz_rootrem: Zeroth root.\");\n  if ( (int)sub_57EB(a3, 1uLL) > 0 )\n  {\n    sub_4834((__int64)v10);\n    sub_4834((__int64)v9);\n    v4 = sub_B382(a3, 2LL);\n    sub_A1EB(v9, v4 / a4 + 1);\n    if ( a4 == 2 )\n    {\n      do\n      {\n        sub_591D(v10, v9);\n        sub_6952(v9, a3, (__int64)v10);\n        sub_5D36(v9, (__int64)v9, (__int64)v10);\n        sub_6F9A(v9, (__int64)v9, 1uLL);\n      }\n      while ( (int)sub_5861((__int64)v9, (__int64)v10) < 0 );\n    }\n    else\n    {\n      sub_4834((__int64)v11);\n      if ( v8 )\n        sub_58E5(v9, (__int64)v9);\n      do\n      {\n        sub_591D(v10, v9);\n        sub_84D8(v9, (__int64)v10, a4 - 1);\n        sub_6952(v9, a3, (__int64)v9);\n        sub_5EA7((__int64)v11, (__int64)v10, a4 - 1);\n        sub_5D36(v9, (__int64)v9, (__int64)v11);\n        sub_737D(v9, (__int64)v9, a4);\n      }\n      while ( (int)sub_5861((__int64)v9, (__int64)v10) < 0 );\n      sub_48C3((__int64)v11);\n    }\n    if ( a2 )\n    {\n      sub_84D8(v9, (__int64)v10, a4);\n      sub_5DBB(a2, a3, (__int64)v9);\n    }\n    if ( a1 )\n      sub_591D(a1, v10);\n    sub_48C3((__int64)v10);\n    sub_48C3((__int64)v9);\n  }\n  else\n  {\n    if ( a1 )\n      sub_4A75(a1, a3);\n    if ( a2 )\n      a2[1] = 0;\n  }\n  return __readfsqword(0x28u) ^ v12;\n}\n",
    "function_name": "mpz_rootrem",
    "decompiled_code": "unsigned __int64 __fastcall mpz_rootrem(int *a1, int *a2, __int64 a3, unsigned __int64 a4)\n{\n  unsigned __int64 v4; // rax\n  _BOOL4 v8; // [rsp+2Ch] [rbp-44h]\n  int v9[4]; // [rsp+30h] [rbp-40h] BYREF\n  int v10[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v11[24]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *(int *)(a3 + 4) < 0;\n  if ( (~a4 & (*(int *)(a3 + 4) < 0)) != 0 )\n    gmp_die(\"mpz_rootrem: Negative argument, with even root.\");\n  if ( !a4 )\n    gmp_die(\"mpz_rootrem: Zeroth root.\");\n  if ( (int)mpz_cmpabs_ui(a3, 1uLL) > 0 )\n  {\n    mpz_init((__int64)v10);\n    mpz_init((__int64)v9);\n    v4 = mpz_sizeinbase(a3, 2LL);\n    mpz_setbit(v9, v4 / a4 + 1);\n    if ( a4 == 2 )\n    {\n      do\n      {\n        mpz_swap(v10, v9);\n        mpz_tdiv_q(v9, a3, (__int64)v10);\n        mpz_add(v9, (__int64)v9, (__int64)v10);\n        mpz_tdiv_q_2exp(v9, (__int64)v9, 1uLL);\n      }\n      while ( (int)mpz_cmpabs((__int64)v9, (__int64)v10) < 0 );\n    }\n    else\n    {\n      mpz_init((__int64)v11);\n      if ( v8 )\n        mpz_neg(v9, (__int64)v9);\n      do\n      {\n        mpz_swap(v10, v9);\n        mpz_pow_ui(v9, (__int64)v10, a4 - 1);\n        mpz_tdiv_q(v9, a3, (__int64)v9);\n        mpz_mul_ui((__int64)v11, (__int64)v10, a4 - 1);\n        mpz_add(v9, (__int64)v9, (__int64)v11);\n        mpz_tdiv_q_ui(v9, (__int64)v9, a4);\n      }\n      while ( (int)mpz_cmpabs((__int64)v9, (__int64)v10) < 0 );\n      mpz_clear((__int64)v11);\n    }\n    if ( a2 )\n    {\n      mpz_pow_ui(v9, (__int64)v10, a4);\n      mpz_sub(a2, a3, (__int64)v9);\n    }\n    if ( a1 )\n      mpz_swap(a1, v10);\n    mpz_clear((__int64)v10);\n    mpz_clear((__int64)v9);\n  }\n  else\n  {\n    if ( a1 )\n      mpz_set(a1, a3);\n    if ( a2 )\n      a2[1] = 0;\n  }\n  return __readfsqword(0x28u) ^ v12;\n}\n",
    "source_code": "void\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);\n\n  if (z == 2) /* simplify sqrt loop: z-1 == 1 */\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_tdiv_q (t, y, u);\t\t/* t = y/x */\n      mpz_add (t, t, u);\t\t/* t = y/x + x */\n      mpz_tdiv_q_2exp (t, t, 1);\t/* x'= (y/x + x)/2 */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n  else /* z != 2 */ {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_pow_ui (t, u, z - 1);\t\t/* t = x^(z-1) */\n      mpz_tdiv_q (t, y, t);\t\t/* t = y/x^(z-1) */\n      mpz_mul_ui (v, u, z - 1);\t\t/* v = x*(z-1) */\n      mpz_add (t, t, v);\t\t/* t = y/x^(z-1) + x*(z-1) */\n      mpz_tdiv_q_ui (t, t, z);\t\t/* x'=(y/x^(z-1) + x*(z-1))/z */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}",
    "comment": "Computes the nth root and remainder of a multi-precision integer, handling special cases for negative and zero values.",
    "hext5_sum": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
    "bint5_sum": "Removes a specified integer from a multi-precision integer , handling potential negation and ensuring no carry occurs during the operation .\n",
    "cpbcs_sum": "Calculates the modular inverse of an unsigned long integer `a` modulo `2^n` and stores the result in `r`.\n",
    "misum_sum": "Calculates the modular inverse of a multi-precision integer and stores the result in a specified base variable.\n",
    "decom_sum": "Computes the integer n\u2011th root of a large number and optionally returns the remainder, handling special cases for zero, negatives, and even roots.",
    "cfg_sum": "Computes the integer nth root and remainder of a large number, handling special cases for invalid inputs and supporting both square and general roots.",
    "work_score": {
        "hext5": {
            "summary": "returns the number of destinations if successful, -1 on internal error. group all nodes belonging to state into several destinations. then for all destinations, set the nodes belonging to the destination to dests_node[i] and set the characters accepted by the destination",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes functionality related to grouping nodes into destinations, returning counts, and handling characters, which is entirely unrelated to the source code for mpz_rootrem that computes integer roots and remainders using GMP functions. None of the claims match the code's semantics, resulting in no accurate fact-based claims.",
                "The summary describes returning a count of destinations, handling internal errors, grouping nodes by state, and assigning characters to destinations, none of which align with the source code's actual function of computing integer roots and remainders with specific error checks for negative arguments with even roots and zeroth roots, iterative calculation for z=2 and general z, and remainder calculation. The primary purpose and secondary details in the code are entirely missed, and the summary is unrelated to the source semantics.",
                "The summary's claims about returning the number of destinations, grouping nodes by state, and setting characters for destinations do not match the source code at all. The source code implements an integer root and remainder calculation using GMP functions, with error checks for invalid roots, and no concept of destinations, nodes, or characters. These are wholly unrelated to the primary purpose, constituting a FATAL mismatch on key I/O and semantics, making the content unreliable."
            ]
        },
        "bint5": {
            "summary": "Removes a specified integer from a multi-precision integer , handling potential negation and ensuring no carry occurs during the operation .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function removes a specified integer from a multi-precision integer without carry, which is inaccurate as the source code implements integer root and remainder calculation (mpz_rootrem) with checks for negative arguments and special cases. None of the claims match the function's semantics, resulting in 0% accurate statements.",
                "The summary incorrectly describes the function as removing an integer from a multi-precision integer, which does not match the source code implementation. The actual code computes the integer z-th root of y and the remainder, with checks for invalid inputs such as negative arguments with even roots and zeroth root. No claim in the summary accurately captures the primary purpose or secondary details, making it completely misaligned with the source behavior.",
                "The summary's single claim that the function removes a specified integer from a multi-precision integer is entirely inaccurate. The source code actually computes the integer z-th root of a given multi-precision integer y, stores it in x, and sets r to the remainder. It also includes checks for negative arguments with even roots and for zero roots. The summary does not reflect the function's primary purpose, key I/O, or side effects, making this a FATAL error affecting the core semantics."
            ]
        },
        "cpbcs": {
            "summary": "Calculates the modular inverse of an unsigned long integer `a` modulo `2^n` and stores the result in `r`.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function computes the modular inverse of an unsigned long integer modulo 2^n, which is entirely unrelated to the actual source code. The source function computes the integer z-th root of a large integer y and optionally the remainder, not a modular inverse. This is a direct semantic contradiction, making the claim inaccurate with no accurate elements.",
                "The summary incorrectly states that the function calculates the modular inverse of an unsigned long integer, which does not match the source code. The code actually computes the integer z-th root of y, returning both the root and the remainder, with specific error handling for negative even roots and zeroth roots. The primary purpose is entirely missed, and no accurate claims are made.",
                "The summary claims the function calculates a modular inverse of an unsigned long integer modulo 2^n, which directly contradicts the source code. The actual function computes the integer z-th root of y and the remainder, with error handling for invalid inputs. This is a FATAL error affecting the primary purpose and key I/O, leaving no accurate claims to salvage."
            ]
        },
        "misum": {
            "summary": "Calculates the modular inverse of a multi-precision integer and stores the result in a specified base variable.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function calculates the modular inverse, which contradicts the source code. The source implements an integer root and remainder calculation with error handling for negative arguments and zeroth roots, unrelated to modular inversion. This is a targeted semantic claim that is entirely inaccurate, so none of the claims are accurate.",
                "The summary is entirely inaccurate, claiming the function calculates a modular inverse, which does not align with the source code. The actual function computes the integer z-th root of y and the remainder, with specific error checks for invalid inputs, and implements different iterative methods depending on whether z equals 2. None of these details are captured, and the primary purpose is missed.",
                "The summary incorrectly describes the function as calculating a modular inverse, while the source code actually computes the integer z-th root of a multi-precision number and the remainder. This is a FATAL error about the primary purpose and key I/O, leading to a complete mismatch with the implementation and making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 230936,
    "strip_function_name": "mutil_parse_field_map",
    "strip_decompiled_code": "__int64 __fastcall mutil_parse_field_map(__int64 a1, _QWORD *a2, _DWORD *a3)\n{\n  int v3; // ebx\n  int v4; // eax\n  int v5; // r8d\n  int v6; // r9d\n  char *v8; // rax\n  char v9; // [rsp+0h] [rbp-180h]\n  unsigned int v11; // [rsp+28h] [rbp-158h]\n  int i; // [rsp+2Ch] [rbp-154h]\n  __int64 v13; // [rsp+30h] [rbp-150h] BYREF\n  char *s; // [rsp+38h] [rbp-148h]\n  char *v15; // [rsp+40h] [rbp-140h]\n  char *v16; // [rsp+48h] [rbp-138h]\n  _QWORD v17[38]; // [rsp+50h] [rbp-130h] BYREF\n\n  v17[35] = __readfsqword(0x28u);\n  v13 = 0LL;\n  v17[7] = \":\";\n  if ( (unsigned int)mu_wordsplit(a1, v17, 33574468LL) )\n  {\n    v3 = mu_wordsplit_strerror(v17);\n    v4 = (unsigned int)dgettext(\"mailutils\", \"cannot split line `%s': %s\");\n    mu_error(v4, a1, v3, v4, v5, v6, v9);\n    return (unsigned int)*__errno_location();\n  }\n  else\n  {\n    for ( i = 0; (unsigned __int64)i < v17[0]; ++i )\n    {\n      s = *(char **)(8LL * i + v17[1]);\n      v15 = strchr(s, 61);\n      if ( !v15 )\n      {\n        v11 = 22;\n        break;\n      }\n      if ( !v13 )\n      {\n        v11 = mu_assoc_create(&v13, 0LL);\n        if ( v11 )\n          break;\n        mu_assoc_set_destroy_item(v13, mu_list_free_item);\n        *a2 = v13;\n      }\n      v8 = v15++;\n      *v8 = 0;\n      v16 = strdup(v15);\n      if ( !v16 )\n      {\n        v11 = *__errno_location();\n        break;\n      }\n      v11 = mu_assoc_install(v13, s, v16);\n      if ( v11 )\n      {\n        free(v15);\n        break;\n      }\n    }\n    mu_wordsplit_free(v17);\n    if ( v11 )\n    {\n      if ( a3 )\n        *a3 = i;\n    }\n    return v11;\n  }\n}\n",
    "function_name": "mutil_parse_field_map",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nint __cdecl mutil_parse_field_map(const char *map, mu_assoc_t *passoc_tab, int *perr)\n{\n  __int64 v3; // rbx\n  char *v4; // rax\n  char *v6; // rax\n  int rc; // [rsp+28h] [rbp-158h]\n  int i; // [rsp+2Ch] [rbp-154h]\n  mu_assoc_t assoc_tab; // [rsp+30h] [rbp-150h] BYREF\n  char *tok; // [rsp+38h] [rbp-148h]\n  char *p; // [rsp+40h] [rbp-140h]\n  char *pptr; // [rsp+48h] [rbp-138h]\n  mu_wordsplit ws; // [rsp+50h] [rbp-130h] BYREF\n  unsigned __int64 v15; // [rsp+168h] [rbp-18h]\n\n  v15 = __readfsqword(0x28u);\n  assoc_tab = 0LL;\n  ws.ws_delim = \":\";\n  if ( (unsigned int)((__int64 (__fastcall *)(const char *, char ***, __int64))mu_wordsplit)(\n                       map,\n                       &ws.ws_wordv,\n                       33574468LL) )\n  {\n    v3 = ((__int64 (__fastcall *)(mu_wordsplit *))mu_wordsplit_strerror)(&ws);\n    v4 = dgettext(\"mailutils\", \"cannot split line `%s': %s\");\n    ((void (__fastcall *)(char *, const char *, __int64))mu_error)(v4, map, v3);\n    return *__errno_location();\n  }\n  else\n  {\n    for ( i = 0; i < ws.ws_wordc; ++i )\n    {\n      tok = ws.ws_wordv[i];\n      p = strchr(tok, 61);\n      if ( !p )\n      {\n        rc = 22;\n        break;\n      }\n      if ( !assoc_tab )\n      {\n        rc = ((__int64 (__fastcall *)(mu_assoc_t *, _QWORD))mu_assoc_create)(&assoc_tab, 0LL);\n        if ( rc )\n          break;\n        ((void (__fastcall *)(mu_assoc_t, void (__cdecl *)(void *)))mu_assoc_set_destroy_item)(\n          assoc_tab,\n          mu_list_free_item);\n        *passoc_tab = assoc_tab;\n      }\n      v6 = p++;\n      *v6 = 0;\n      pptr = strdup(p);\n      if ( !pptr )\n      {\n        rc = *__errno_location();\n        break;\n      }\n      rc = ((__int64 (__fastcall *)(mu_assoc_t, char *, char *))mu_assoc_install)(assoc_tab, tok, pptr);\n      if ( rc )\n      {\n        free(p);\n        break;\n      }\n    }\n    ((void (__fastcall *)(mu_wordsplit *))mu_wordsplit_free)(&ws);\n    if ( rc )\n    {\n      if ( perr )\n        *perr = i;\n    }\n    return rc;\n  }\n}\n",
    "source_code": "\nint\nmutil_parse_field_map (const char *map, mu_assoc_t *passoc_tab, int *perr)\n{\n  int rc;\n  int i;\n  struct mu_wordsplit ws;\n  mu_assoc_t assoc_tab = NULL;\n\n  ws.ws_delim = \":\";\n  if (mu_wordsplit (map, &ws, MU_WRDSF_DEFFLAGS|MU_WRDSF_DELIM))\n    {\n      mu_error (_(\"cannot split line `%s': %s\"), map,\n\t\tmu_wordsplit_strerror (&ws));\n      return errno;\n    }\n\n  for (i = 0; i < ws.ws_wordc; i++)\n    {\n      char *tok = ws.ws_wordv[i];\n      char *p = strchr (tok, '=');\n      char *pptr;\n      \n      if (!p)\n\t{\n\t  rc = EINVAL;\n\t  break;\n\t}\n      if (!assoc_tab)\n\t{\n\t  rc = mu_assoc_create (&assoc_tab, 0);\n\t  if (rc)\n\t    break;\n\t  mu_assoc_set_destroy_item (assoc_tab, mu_list_free_item);\n\t  *passoc_tab = assoc_tab;\n\t}\n      *p++ = 0;\n      pptr = strdup (p);\n      if (!pptr)\n\t{\n\t  rc = errno;\n\t  break;\n\t}\n      rc = mu_assoc_install (assoc_tab, tok, pptr);\n      if (rc)\n\t{\n\t  free (p);\n\t  break;\n\t}\n    }\n\n  mu_wordsplit_free (&ws);\n  if (rc && perr)\n    *perr = i;\n  return rc;\n}",
    "comment": "Parses a colon-delimited string into a key-value association table, handling errors for malformed entries and memory allocation failures.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Parses a field mapping from the input stream , populating an array with names and values while handling errors and whitespace .\n",
    "cpbcs_sum": "Parses a configuration file for a given name, returning an error code on failure.\n",
    "misum_sum": "Constructs a dynamic module by appending filename to a given sockaddr and appending it to a specified filename if successful.\n",
    "decom_sum": "Parses a colon-delimited line into key-value pairs, stores them in an associative map, and reports errors with the offending field index.",
    "cfg_sum": "Parses a colon-separated input string into a key-value association map, handling errors, memory allocation, and recording the index of any failed entry.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes behavior involving a static buffer, printf formatting, and byte display limits, none of which are present in the source code. The source code parses a colon-delimited map, creates an association table, and installs key-value pairs. All claims in the summary target different semantics and are therefore inaccurate, resulting in 0% accurate claims.",
                "The summary describes behavior involving a static buffer, printf formatting, byte limits, and hex output, which is entirely unrelated to the source code. The source function parses a colon-delimited map of key-value pairs into an association table with error handling and memory allocation, not any form of value conversion or formatting. As none of the claims match the code\u2019s primary purpose or observable behavior, all claims are inaccurate and completeness is nonexistent.",
                "The summary's claims about returning a pointer to a static buffer, printf formatting character usage, and byte-size behavior are entirely unrelated to the actual source code, which parses a colon-delimited string into key-value associations using mu_wordsplit and mu_assoc functions. All claims are NOISE, with no accurate alignment to the code logic, leading to overwhelming mismatch and no insight into the true implementation."
            ]
        },
        "bint5": {
            "summary": "Parses a field mapping from the input stream , populating an array with names and values while handling errors and whitespace .\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function parses a field mapping from an input stream and populates an array with names and values. The source code instead parses a colon-delimited string, splits it, and stores key-value pairs into an association table, not from a stream and not into a simple array. Although it does handle errors, the mention of whitespace handling is inaccurate as it uses specified delimiters. Less than half of the claims match the actual code behavior.",
                "The summary captures the general idea of parsing and populating a data structure with name-value pairs, which aligns loosely with the function\u2019s purpose of splitting the input string and storing key-value mappings in an association table with error handling. However, it inaccurately describes the source: the function processes a string with colon-delimited tokens rather than reading from an input stream, does not mention the specific use of '=' to split keys/values, the initialization of the association table, memory duplication, or how errors are recorded (perr index). Whitespace handling is not explicit in the code. Several key secondary details are missed, so coverage of the actual implementation is incomplete.",
                "The summary is partially inaccurate: it states the function parses a mapping from an 'input stream', but the code clearly receives a string parameter 'map' rather than reading from a stream. It also claims to populate an array with names and values, whereas the implementation builds an associative table via mu_assoc_install, not an array. While it correctly mentions parsing mappings and handling errors, these inaccuracies about primary I/O and data structure type represent FATAL errors, lowering reliability."
            ]
        },
        "cpbcs": {
            "summary": "Parses a configuration file for a given name, returning an error code on failure.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as parsing a configuration file for a given name, whereas the source code clearly shows it parses a string 'map' containing colon-delimited key=value pairs using mu_wordsplit, not a file. It omits key details such as delimiter handling, association table creation, and value installation, and the claim is not aligned with the actual code semantics. Therefore, the claim is inaccurate and does not reflect the source implementation.",
                "The summary inaccurately describes the primary purpose: the function parses a colon-delimited mapping string into an association table, not a configuration file for a given name. It misses key secondary details such as token parsing, handling of '=' separators, creation and population of the assoc_tab, error handling specifics, and freeing resources. The only partially correct aspect is that it returns an error code on failure, but the rest misrepresents the semantics.",
                "The summary claims the function parses a configuration file for a given name, which is inaccurate. The source code shows it parses a colon-delimited string with key=value pairs, not a file, and there is no parameter for a 'given name'. This is a FATAL error targeting the primary purpose. The only accurate part is that it returns an error code on failure, but the core functional description is wrong, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Constructs a dynamic module by appending filename to a given sockaddr and appending it to a specified filename if successful.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about constructing a dynamic module, appending a filename to a sockaddr, and appending it to another filename are unrelated to the source code, which parses a colon-delimited key=value map into an association table. All claims target semantics not present in the implementation, resulting in no accurate matches.",
                "The summary is entirely inaccurate\u2014it describes constructing a dynamic module by appending a filename to a sockaddr, which has no relation to the source code. The source code parses a colon-separated map of key=value pairs into an association table, handling errors and memory allocation, none of which is reflected in the summary. Primary purpose and all secondary details are missed.",
                "The summary is entirely inaccurate; it describes constructing a dynamic module and working with filenames and sockaddr, which have no relation to the source code. The function in the source code parses a colon-delimited field map string into key-value pairs and installs them into an association table, handling memory allocation and errors accordingly. This mismatch represents a complete FATAL error on the primary purpose and key I/O, resulting in high negative impact."
            ]
        }
    }
}
{
    "project_name": "libxml2",
    "function_addr": 988464,
    "strip_function_name": "sub_F1530",
    "strip_decompiled_code": "__int64 __fastcall sub_F1530(char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v10; // rax\n  __int64 v11; // r12\n  __int64 v12; // rdi\n  __int64 (__fastcall *v14)(int, int, int, int, int, int, char); // rbp\n  _QWORD *v15; // rax\n  __int64 (__fastcall *v16)(int, int, int, int, int, int, char); // rbp\n  _QWORD *v17; // rax\n\n  if ( !qword_3605B0 || !a1 )\n    return 0xFFFFFFFFLL;\n  if ( xmlHashLookup(qword_3605B0, (unsigned __int8 *)a1) )\n  {\n    v16 = *_xmlGenericError();\n    v17 = _xmlGenericErrorContext();\n    ((void (*)(_QWORD, const char *, ...))v16)(*v17, \"Relax-NG types library '%s' already registered\\n\", a1);\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    v10 = xmlMalloc(0x38uLL);\n    v11 = (__int64)v10;\n    if ( v10 )\n    {\n      v10[6] = 0LL;\n      *(_OWORD *)v10 = 0LL;\n      *((_OWORD *)v10 + 1) = 0LL;\n      *((_OWORD *)v10 + 2) = 0LL;\n      *v10 = xmlStrdup(a1);\n      v12 = qword_3605B0;\n      *(_QWORD *)(v11 + 8) = 0LL;\n      *(_QWORD *)(v11 + 16) = a2;\n      *(_QWORD *)(v11 + 32) = a4;\n      *(_QWORD *)(v11 + 24) = a3;\n      *(_QWORD *)(v11 + 40) = a5;\n      *(_QWORD *)(v11 + 48) = a6;\n      if ( (int)xmlHashAddEntry(v12, (unsigned __int8 *)a1, v11) < 0 )\n      {\n        v14 = *_xmlGenericError();\n        v15 = _xmlGenericErrorContext();\n        ((void (*)(_QWORD, const char *, ...))v14)(*v15, \"Relax-NG types library failed to register '%s'\\n\", a1);\n        if ( *(_QWORD *)v11 )\n          xmlFree(*(void **)v11);\n        xmlFree((void *)v11);\n        return 0xFFFFFFFFLL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      sub_E9D50(0LL, (__int64)\"adding types library\\n\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n}\n",
    "function_name": "xmlRelaxNGRegisterTypeLibrary",
    "decompiled_code": "__int64 __fastcall xmlRelaxNGRegisterTypeLibrary(\n        const xmlChar *a1,\n        xmlChar *data,\n        xmlChar *have,\n        xmlChar *check,\n        xmlChar *comp,\n        xmlChar *facet)\n{\n  xmlChar **v10; // rax\n  xmlChar **v11; // r12\n  xmlHashTable *v12; // rdi\n  xmlGenericErrorFunc v14; // rbp\n  void **v15; // rax\n  xmlGenericErrorFunc v16; // rbp\n  void **v17; // rax\n\n  if ( !xmlRelaxNGRegisteredTypes || !a1 )\n    return 0xFFFFFFFFLL;\n  if ( xmlHashLookup__internal_alias(xmlRelaxNGRegisteredTypes, a1) )\n  {\n    v16 = *_xmlGenericError__internal_alias();\n    v17 = _xmlGenericErrorContext__internal_alias();\n    v16(*v17, \"Relax-NG types library '%s' already registered\\n\", (const char *)a1);\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    v10 = (xmlChar **)xmlMalloc(0x38uLL);\n    v11 = v10;\n    if ( v10 )\n    {\n      v10[6] = 0LL;\n      *(_OWORD *)v10 = 0LL;\n      *((_OWORD *)v10 + 1) = 0LL;\n      *((_OWORD *)v10 + 2) = 0LL;\n      *v10 = xmlStrdup__internal_alias(a1);\n      v12 = xmlRelaxNGRegisteredTypes;\n      v11[1] = 0LL;\n      v11[2] = data;\n      v11[4] = check;\n      v11[3] = have;\n      v11[5] = comp;\n      v11[6] = facet;\n      if ( xmlHashAddEntry__internal_alias(v12, a1, v11) < 0 )\n      {\n        v14 = *_xmlGenericError__internal_alias();\n        v15 = _xmlGenericErrorContext__internal_alias();\n        v14(*v15, \"Relax-NG types library failed to register '%s'\\n\", (const char *)a1);\n        if ( *v11 )\n          xmlFree(*v11);\n        xmlFree(v11);\n        return 0xFFFFFFFFLL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      xmlRngVErrMemory(0LL, \"adding types library\\n\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n}\n",
    "source_code": "static int\nxmlRelaxNGRegisterTypeLibrary(const xmlChar * namespace, void *data,\n                              xmlRelaxNGTypeHave have,\n                              xmlRelaxNGTypeCheck check,\n                              xmlRelaxNGTypeCompare comp,\n                              xmlRelaxNGFacetCheck facet,\n                              xmlRelaxNGTypeFree freef)\n{\n    xmlRelaxNGTypeLibraryPtr lib;\n    int ret;\n\n    if ((xmlRelaxNGRegisteredTypes == NULL) || (namespace == NULL) ||\n        (check == NULL) || (comp == NULL))\n        return (-1);\n    if (xmlHashLookup(xmlRelaxNGRegisteredTypes, namespace) != NULL) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library '%s' already registered\\n\",\n                        namespace);\n        return (-1);\n    }\n    lib =\n        (xmlRelaxNGTypeLibraryPtr)\n        xmlMalloc(sizeof(xmlRelaxNGTypeLibrary));\n    if (lib == NULL) {\n        xmlRngVErrMemory(NULL, \"adding types library\\n\");\n        return (-1);\n    }\n    memset(lib, 0, sizeof(xmlRelaxNGTypeLibrary));\n    lib->namespace = xmlStrdup(namespace);\n    lib->data = data;\n    lib->have = have;\n    lib->comp = comp;\n    lib->check = check;\n    lib->facet = facet;\n    lib->freef = freef;\n    ret = xmlHashAddEntry(xmlRelaxNGRegisteredTypes, namespace, lib);\n    if (ret < 0) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library failed to register '%s'\\n\",\n                        namespace);\n        xmlRelaxNGFreeTypeLibrary(lib, namespace);\n        return (-1);\n    }\n    return (0);\n}",
    "comment": "Registers a new Relax-NG types library with a given namespace and associated functions in the xmlRelaxNGRegisteredTypes hash table.",
    "hext5_sum": "push a pointer to the corresponding user data structures.",
    "bint5_sum": "Registers a new RelaxNG grammar type if it does not already exist in the context or the global list , returning success or failure status .\n",
    "cpbcs_sum": "Creates a new XML schema context with specified attributes and context, initializing necessary resources and handling memory allocation errors.\n",
    "misum_sum": "Logs an error message with context and line information, including source and line number, type, while reporting the error message.\n",
    "decom_sum": "Registers a new Relax-NG types library in an XML hash table, reporting errors if the library is already registered or allocation fails.",
    "cfg_sum": "Registers a new Relax-NG types library by name into a global hash, handling duplicates, allocation failures, and reporting errors.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer to the corresponding user data structures.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary's claim about pushing a pointer to user data structures is vague and does not accurately reflect the function's actual behavior in the source code, which involves allocating and populating a type library structure and registering it in a hash table. The summary neither captures key actions such as memory allocation, field assignments, nor the registration process, making the single claim inaccurate and non-representative of the code.",
                "The summary makes a vague reference to pushing a pointer to user data structures, which does not align with the primary purpose of the function\u2014registering a Relax-NG type library with associated callbacks and namespace into a hash table. It omits critical details such as input validation, error handling, memory allocation, and hash table updates. The claim is low-info and inaccurate relative to the code\u2019s semantics, missing both the primary purpose and secondary behaviors.",
                "The summary makes a vague claim about pushing a pointer to user data structures, which does not specifically align with the code's actual function of registering a Relax-NG type library with multiple callbacks and namespace handling. This is NOISE targeting neither the core purpose nor the detailed semantics of the source. The claim is overly broad, lacks detail, and provides no force-multiplying insight for understanding the implementation."
            ]
        },
        "bint5": {
            "summary": "Registers a new RelaxNG grammar type if it does not already exist in the context or the global list , returning success or failure status .\n",
            "score": [
                0.9,
                0.5,
                0.2
            ],
            "reason": [
                "The summary accurately states that the function registers a new RelaxNG type if it is not already registered and returns a status indicating success or failure, which matches the source code logic. The source code checks both for null required arguments and for existing registration before proceeding, and returns 0 or -1 accordingly. The mention of 'context or the global list' is slightly vague, but does not contradict the implementation. Overall, the claim is aligned with the code with no clear inaccuracies.",
                "The summary captures the primary purpose of registering a new RelaxNG type library and returning success or failure, which aligns with the function's core behavior. However, it omits key secondary details such as the specific validation checks for null parameters, the allocation and initialization of the library structure, the handling of duplicate namespaces with error messages, and cleanup on failure. It also inaccurately mentions 'grammar type' and 'context/global list', which do not directly reflect the actual implementation's use of a global hash table for registered types.",
                "The summary\u2019s main claim is that the function registers a new RelaxNG grammar type if not already present, returning a status code. While this broadly matches the source code\u2019s behavior, it inaccurately refers to a 'context or the global list' \u2014 the implementation only checks the global registry (xmlRelaxNGRegisteredTypes), not any separate context. This mismatch targets key semantics of the primary purpose, making it a FATAL error that undermines reliability. The rest of the description is generic and offers low informational gain."
            ]
        },
        "cpbcs": {
            "summary": "Creates a new XML schema context with specified attributes and context, initializing necessary resources and handling memory allocation errors.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims creation of an XML schema context with specified attributes, which does not match the source code that registers a Relax-NG type library in an existing registry. While it mentions memory allocation error handling, which is accurate, most of the semantics are incorrect or unrelated to the actual function. Less than half of the claims align with the source implementation.",
                "The summary incorrectly states that the function creates a new XML schema context, which contradicts the source code's actual purpose of registering a Relax-NG type library with specified callbacks and namespace. It also omits critical details such as parameter requirements, duplicate registration checks, hash entry addition, and specific error handling paths. Since the primary purpose is misstated, none of the CSU_LIST elements are accurately covered.",
                "The summary is inaccurate because it describes creating a new XML schema context, which contradicts the source code's actual purpose of registering a Relax-NG type library. This is a FATAL error affecting the primary function purpose, as it misrepresents the key I/O and side effects. No accurate claims remain to provide useful insight."
            ]
        },
        "misum": {
            "summary": "Logs an error message with context and line information, including source and line number, type, while reporting the error message.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function logs an error with context, line information, source, and type, but the source code only shows calls to xmlGenericError with error messages and namespace details\u2014no line numbers, source, or type data are logged. This is a semantic mismatch, and none of the claims align accurately with the implementation.",
                "The summary describes logging an error with context, line information, and type, but the source code does not include line numbers or type details. Instead, the code registers a Relax-NG type library, performs null checks, handles duplicate registration, allocates memory, and logs error messages without line-number or type metadata. This shows the summary is inaccurate and fails to capture the primary purpose or any key secondary details.",
                "The summary claims that the function logs an error with context, line information, source, and type while reporting the error message. In reality, the code logs generic error messages without line number or type parameters, and the primary purpose is registering a Relax-NG type library with various checks, not general error reporting. This is a FATAL inaccuracy about the primary purpose and key side effect, leading to strong misrepresentation."
            ]
        }
    }
}
{
    "project_name": "libevent",
    "function_addr": 96816,
    "strip_function_name": "sub_17A30",
    "strip_decompiled_code": "__int64 __fastcall sub_17A30(__int64 a1, __int64 a2)\n{\n  __int64 input; // rax\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int (__fastcall *v6)(__int64, _QWORD); // rax\n  int v7; // eax\n  int v8; // edx\n  __int64 v9; // rsi\n\n  input = bufferevent_get_input();\n  result = evhttp_parse_headers_(a2, input);\n  if ( (result & 0xFFFFFFFD) == 0xFFFFFFFD )\n  {\n    if ( event_debug_logging_mask_ )\n      event_debugx_();\n    goto LABEL_4;\n  }\n  if ( (_DWORD)result )\n  {\n    v6 = *(int (__fastcall **)(__int64, _QWORD))(a2 + 184);\n    if ( v6 )\n    {\n      v5 = 1LL;\n      if ( v6(a2, *(_QWORD *)(a2 + 168)) < 0 )\n        return evhttp_connection_fail_(a1, v5);\n    }\n    v7 = *(_DWORD *)(a2 + 72);\n    if ( !v7 )\n    {\n      if ( !event_debug_logging_mask_ )\n        return sub_176F0(a1, a2);\n      goto LABEL_17;\n    }\n    if ( v7 != 1 )\n    {\n      event_warnx();\nLABEL_4:\n      v5 = 2LL;\n      return evhttp_connection_fail_(a1, v5);\n    }\n    v8 = *(_DWORD *)(a2 + 116);\n    if ( v8 == 100 )\n    {\n      bufferevent_get_output();\n      v9 = *(_QWORD *)(a2 + 152);\n      evbuffer_add_buffer();\n      return evhttp_start_write_(a1, v9);\n    }\n    else\n    {\n      if ( v8 != 204 && v8 != 304 && (unsigned int)(v8 - 100) > 0x63 && *(_DWORD *)(a2 + 76) != 4 )\n      {\n        if ( !event_debug_logging_mask_ )\n          return sub_176F0(a1, a2);\nLABEL_17:\n        event_debugx_();\n        return sub_176F0(a1, a2);\n      }\n      if ( event_debug_logging_mask_ )\n        event_debugx_();\n      return sub_16800(a1);\n    }\n  }\n  return result;\n}\n",
    "function_name": "evhttp_read_header",
    "decompiled_code": "__int64 __fastcall evhttp_read_header(__int64 a1, __int64 a2)\n{\n  __int64 input; // rax\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int (__fastcall *v6)(__int64, _QWORD); // rax\n  int v7; // eax\n  int v8; // edx\n  __int64 v9; // rsi\n\n  input = bufferevent_get_input();\n  result = evhttp_parse_headers_(a2, input);\n  if ( (result & 0xFFFFFFFD) == 0xFFFFFFFD )\n  {\n    if ( event_debug_logging_mask_ )\n      event_debugx_();\n    goto LABEL_4;\n  }\n  if ( (_DWORD)result )\n  {\n    v6 = *(int (__fastcall **)(__int64, _QWORD))(a2 + 184);\n    if ( v6 )\n    {\n      v5 = 1LL;\n      if ( v6(a2, *(_QWORD *)(a2 + 168)) < 0 )\n        return evhttp_connection_fail_(a1, v5);\n    }\n    v7 = *(_DWORD *)(a2 + 72);\n    if ( !v7 )\n    {\n      if ( !event_debug_logging_mask_ )\n        return evhttp_get_body(a1, a2);\n      goto LABEL_17;\n    }\n    if ( v7 != 1 )\n    {\n      event_warnx();\nLABEL_4:\n      v5 = 2LL;\n      return evhttp_connection_fail_(a1, v5);\n    }\n    v8 = *(_DWORD *)(a2 + 116);\n    if ( v8 == 100 )\n    {\n      bufferevent_get_output();\n      v9 = *(_QWORD *)(a2 + 152);\n      evbuffer_add_buffer();\n      return evhttp_start_write_(a1, v9);\n    }\n    else\n    {\n      if ( v8 != 204 && v8 != 304 && (unsigned int)(v8 - 100) > 0x63 && *(_DWORD *)(a2 + 76) != 4 )\n      {\n        if ( !event_debug_logging_mask_ )\n          return evhttp_get_body(a1, a2);\nLABEL_17:\n        event_debugx_();\n        return evhttp_get_body(a1, a2);\n      }\n      if ( event_debug_logging_mask_ )\n        event_debugx_();\n      return evhttp_connection_done(a1);\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void\nevhttp_read_header(struct evhttp_connection *evcon,\n\t\t   struct evhttp_request *req)\n{\n\tenum message_read_status res;\n\tevutil_socket_t fd = evcon->fd;\n\n\tres = evhttp_parse_headers_(req, bufferevent_get_input(evcon->bufev));\n\tif (res == DATA_CORRUPTED || res == DATA_TOO_LONG) {\n\t\t/* Error while reading, terminate */\n\t\tevent_debug((\"%s: bad header lines on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\treturn;\n\t} else if (res == MORE_DATA_EXPECTED) {\n\t\t/* Need more header lines */\n\t\treturn;\n\t}\n\n\t/* Callback can shut down connection with negative return value */\n\tif (req->header_cb != NULL) {\n\t\tif ((*req->header_cb)(req, req->cb_arg) < 0) {\n\t\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_EOF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Done reading headers, do the real work */\n\tswitch (req->kind) {\n\tcase EVHTTP_REQUEST:\n\t\tevent_debug((\"%s: checking for post data on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_get_body(evcon, req);\n\t\t/* note the request may have been freed in evhttp_get_body */\n\t\tbreak;\n\n\tcase EVHTTP_RESPONSE:\n\t\t/* Start over if we got a 100 Continue response. */\n\t\tif (req->response_code == 100) {\n\t\t\tstruct evbuffer *output = bufferevent_get_output(evcon->bufev);\n\t\t\tevbuffer_add_buffer(output, req->output_buffer);\n\t\t\tevhttp_start_write_(evcon);\n\t\t\treturn;\n\t\t}\n\t\tif (!evhttp_response_needs_body(req)) {\n\t\t\tevent_debug((\"%s: skipping body for code %d\\n\",\n\t\t\t\t\t__func__, req->response_code));\n\t\t\tevhttp_connection_done(evcon);\n\t\t} else {\n\t\t\tevent_debug((\"%s: start of read body for %s on \"\n\t\t\t\tEV_SOCK_FMT\"\\n\",\n\t\t\t\t__func__, req->remote_host, EV_SOCK_ARG(fd)));\n\t\t\tevhttp_get_body(evcon, req);\n\t\t\t/* note the request may have been freed in\n\t\t\t * evhttp_get_body */\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tevent_warnx(\"%s: bad header on \"EV_SOCK_FMT, __func__,\n\t\t    EV_SOCK_ARG(fd));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\tbreak;\n\t}\n\t/* request may have been freed above */\n}",
    "comment": "Processes incoming HTTP headers, validates them, invokes a callback if present, and handles the request or response body based on the type and status.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes HTTP trailer data , handling header parsing and managing connection state , timeouts , and error statuses accordingly .\n",
    "cpbcs_sum": "Handles the result of a DNS HTTP write event, managing timeouts and dispatching write events based on the new state.\n",
    "misum_sum": "Handles the HTTP response by parsing the data, parsing the data, and setting a timeout code or triggering a timeout callback.\n",
    "decom_sum": "Parses HTTP headers from a buffered event, handles status-specific responses, and triggers connection failure or appropriate processing based on header and status codes.",
    "cfg_sum": "Parses HTTP headers from the input buffer, validates connection and response status, handles special HTTP codes, and triggers appropriate logging or connection failure actions.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' does not reflect any behavior or logic from the provided source code. It is unrelated to the header parsing, error handling, or body processing implemented, making it an inaccurate, non-code-targeting claim.",
                "The summary 'push a pointer type.' is unrelated to the source code's functionality, which involves parsing HTTP headers, handling errors, invoking callbacks, and processing request/response bodies. It fails to capture the primary purpose or any secondary details of the function, making it entirely inaccurate and providing no coverage of critical semantic units.",
                "The summary contains a single vague statement that does not relate to the source code semantics, functions, or logic. It fails to describe the header parsing, error handling, or request/response processing in the implementation. This is pure NOISE with no accurate, code-related claims, yielding no insight for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Processes HTTP trailer data , handling header parsing and managing connection state , timeouts , and error statuses accordingly .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately states that the function processes HTTP trailer data, which is not present in the source code. While it correctly mentions header parsing and managing connection states and error statuses, it adds unrelated elements like timeouts. These inaccuracies mean that less than half of the claims align with the actual implementation.",
                "The summary incorrectly states that the function processes HTTP trailer data, which is not present in the source code. The code focuses on parsing HTTP headers, checking for errors such as corrupted or overly long headers, handling callbacks, managing connection states for requests and responses, and conditional body handling. It does not mention timeouts, and the reference to trailer data is inaccurate, missing the primary purpose of header parsing. Thus, the summary fails to capture both the primary purpose and the key secondary details found in the code.",
                "The summary contains mainly inaccurate information: it states processing of HTTP trailer data, which does not occur in the source code\u2014the function handles header parsing, not trailers. While it correctly notes header parsing and some connection/error management, it incorrectly adds timeouts (not present here) and misrepresents scope. This is a FATAL error affecting the primary purpose of the function, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Handles the result of a DNS HTTP write event, managing timeouts and dispatching write events based on the new state.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary states that the function handles a DNS HTTP write event with timeouts and dispatches write events, but the source code shows it reads and parses HTTP headers, handles error states, invokes a header callback, and proceeds based on request type; there is no DNS handling or write event dispatch as described. All claims are inaccurate and contradict the actual code logic.",
                "The summary is entirely inaccurate, describing DNS HTTP write event handling, timeouts, and state-based dispatch, none of which are present in the source code. The actual function processes HTTP headers, handles parsing errors, invokes a header callback, and manages body reading or special response codes. It misses the primary purpose and all secondary details, providing unrelated functionality.",
                "The summary contains a single claim that is inaccurate: it describes handling a DNS HTTP write event, managing timeouts, and dispatching write events. The source code actually reads and parses HTTP headers, handles errors, invokes header callbacks, processes request or response bodies, and manages connection state. The mismatch targets the primary purpose of the function, which is reading headers, so this is a FATAL error affecting key I/O semantics. No accurate claims are present, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Handles the HTTP response by parsing the data, parsing the data, and setting a timeout code or triggering a timeout callback.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains vague and partially incorrect claims. It repeats 'parsing the data' redundantly and omits critical details about header handling, error conditions, and body processing logic present in the source. The mention of 'setting a timeout code or triggering a timeout callback' does not align with the actual code, which fails connections or processes bodies rather than triggering timeouts. Most claims either lack specificity or are inaccurate with respect to the source implementation, resulting in a low proportion of accurate statements.",
                "The summary is inaccurate because it describes handling an HTTP response with parsing and setting a timeout, which contradicts the source code. The function actually parses HTTP headers for both requests and responses, handles specific error cases, invokes a header callback, and processes the body depending on request type or response code. No timeout setting or callback logic is present in the source, and the summary misses the primary purpose entirely.",
                "The summary contains mostly inaccurate information: it redundantly states 'parsing the data' without specifying headers and omits key branching logic for request vs response. It falsely claims the function sets a timeout code or triggers a timeout callback, which is not present in the source; instead, it handles header parsing errors, invokes a header callback, and processes body reading or connection completion. This mismatch targets the primary purpose and key side effects, making it a FATAL error with high negative impact and no useful accurate claim."
            ]
        }
    }
}
{
    "project_name": "cflow",
    "function_addr": 30848,
    "strip_function_name": "sub_7880",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_7880(const char *a1)\n{\n  __int64 v1; // rbx\n  char v2; // al\n  const char *i; // rbx\n  char *v4; // rax\n  void *v5; // rax\n  char *v6; // rax\n  char *v8; // rax\n  char *v9; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v10; // [rsp+8h] [rbp-20h]\n\n  v10 = __readfsqword(0x28u);\n  v1 = strtol(a1, &v9, 0);\n  if ( *v9 || v1 <= 0 )\n  {\n    v2 = *a1;\n    for ( i = a1; *i != 61; v2 = *i )\n    {\n      while ( v2 )\n      {\n        v2 = *++i;\n        if ( *i == 61 )\n          goto LABEL_8;\n      }\n      v4 = dcgettext(0LL, \"level-indent syntax\", 5);\n      ++i;\n      error(3, 0, v4);\n    }\nLABEL_8:\n    switch ( (unsigned int)sub_7480((const void **)&off_224080, a1, (int)i - (int)a1) )\n    {\n      case 1u:\n        sub_75C0((char *)i + 1, &off_224160);\n        break;\n      case 2u:\n        sub_75C0((char *)i + 1, (char **)&qword_224E30);\n        break;\n      case 3u:\n        sub_75C0((char *)i + 1, (char **)&qword_224E38);\n        break;\n      case 4u:\n        sub_75C0((char *)i + 1, (char **)&off_224170);\n        break;\n      case 5u:\n        sub_75C0((char *)i + 1, (char **)&off_224178);\n        break;\n      default:\n        v8 = dcgettext(0LL, \"unknown level indent option: %s\", 5);\n        error(3, 0, v8, a1);\n        break;\n    }\n  }\n  else\n  {\n    v5 = (void *)sub_18E60(v1 + 1);\n    v6 = (char *)memset(v5, 32, v1 - 1);\n    v6[v1 - 1] = 0;\n    qword_224E38 = (__int64)v6;\n    qword_224E30 = (__int64)v6;\n  }\n  return __readfsqword(0x28u) ^ v10;\n}\n",
    "function_name": "set_level_indent",
    "decompiled_code": "void __fastcall set_level_indent(const char *str)\n{\n  __int64 v1; // rbx\n  char v2; // al\n  const char *i; // rbx\n  char *v4; // rax\n  void *v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  char *retaddr; // [rsp+28h] [rbp+0h] BYREF\n\n  v1 = strtol(str, &retaddr, 0);\n  if ( *retaddr || v1 <= 0 )\n  {\n    v2 = *str;\n    for ( i = str; *i != 61; v2 = *i )\n    {\n      while ( v2 )\n      {\n        v2 = *++i;\n        if ( *i == 61 )\n          goto LABEL_8;\n      }\n      v4 = dcgettext(0LL, \"level-indent syntax\", 5);\n      ++i;\n      error(3, 0, v4);\n    }\nLABEL_8:\n    switch ( find_option_type(level_indent_optype, str, (_DWORD)i - (_DWORD)str) )\n    {\n      case 1:\n        parse_level_string(i + 1, &level_begin);\n        break;\n      case 2:\n        parse_level_string(i + 1, level_indent);\n        break;\n      case 3:\n        parse_level_string(i + 1, (char **)&qword_224E38);\n        break;\n      case 4:\n        parse_level_string(i + 1, level_end);\n        break;\n      case 5:\n        parse_level_string(i + 1, (char **)&off_224178);\n        break;\n      default:\n        v7 = dcgettext(0LL, \"unknown level indent option: %s\", 5);\n        error(3, 0, v7, str);\n        break;\n    }\n  }\n  else\n  {\n    v5 = xmalloc(v1 + 1);\n    v6 = (char *)memset(v5, 32, v1 - 1);\n    v6[v1 - 1] = 0;\n    qword_224E38 = (__int64)v6;\n    level_indent[0] = v6;\n  }\n}\n",
    "source_code": "\nstatic void\nset_level_indent(const char *str)\n{\n     long n;\n     const char *p;\n     char *q;\n     \n     n = strtol(str, &q, 0);\n     if (*q == 0 && n > 0) {\n\t  char *s = xmalloc(n+1);\n\t  memset(s, ' ', n-1);\n\t  s[n-1] = 0;\n\t  level_indent[0] = level_indent[1] = s;\n\t  return;\n     }\n     \n     p = str;\n     while (*p != '=') {\n\t  if (*p == 0)\n\t       error(EX_USAGE, 0, _(\"level-indent syntax\"));\n\t  p++;\n     }\n     ++p;\n    \n     switch (find_option_type(level_indent_optype, str, p - str - 1)) {\n     case LEVEL_BEGIN:\n\t  parse_level_string(p, &level_begin);\n\t  break;\n     case LEVEL_INDENT0:\n\t  parse_level_string(p, &level_indent[0]);\n\t  break;\n     case LEVEL_INDENT1:\n\t  parse_level_string(p, &level_indent[1]);\n\t  break;\n     case LEVEL_END0:\n\t  parse_level_string(p, &level_end[0]);\n\t  break;\n     case LEVEL_END1:\n\t  parse_level_string(p, &level_end[1]);\n\t  break;\n     default:\n\t  error(EX_USAGE, 0, _(\"unknown level indent option: %s\"), str);\n     }\n}",
    "comment": "Sets the level indentation based on a string input, allocating space for indentation or parsing specific level configuration options.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Parses a level-indent syntax string into a linked list of levels , validating the input and managing memory for each level .\n",
    "cpbcs_sum": "Validates and processes an XML name string by checking its type, ensuring it contains only ASCII characters before setting the type character.\n",
    "misum_sum": "Validates and sets a variable's numeric option string by checking its characters and converting it to an unsigned long integer.\n",
    "decom_sum": "Parses and applies a level\u2011indent configuration, either setting predefined indent styles or creating a custom space\u2011filled string of specified length.",
    "cfg_sum": "Parses a numeric or key=value level-indent option, updates corresponding global indent settings, or reports an error for invalid or unknown options.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains a single vague statement that does not accurately describe or align with the source code's functionality. The source code processes a string to set indentation rules, allocate memory, and handle multiple level indent options, whereas the summary merely refers to pushing a pointer type without context or matching semantics. This makes the claim unrelated and inaccurate, resulting in no accurate claims.",
                "The summary 'push a pointer type' does not reflect the source code's actual primary purpose, which is to parse a string and set level indentation options, handling both numeric and key=value formats with error checks. It misses all critical semantic units including parsing logic, memory allocation, option type handling, and error conditions, and instead provides unrelated terminology.",
                "The summary 'push a pointer type.' is vague, generic, and does not accurately reflect the source code's semantics. It fails to capture the function's purpose, key operations, or input/output behavior, making it [INACCURATE] as NOISE. There are no specific or detailed claims that align with the implementation, resulting in low informational value and no force multipliers."
            ]
        },
        "bint5": {
            "summary": "Parses a level-indent syntax string into a linked list of levels , validating the input and managing memory for each level .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function parses a level-indent syntax string into a linked list of levels and manages memory for each level. The source code does parse a level-indent string and validates the input, but there is no linked list structure\u2014only pointers and arrays of strings are used. Memory allocation occurs for a single string when n > 0, not for each level. The majority of the claims are inaccurate, making the overall alignment low.",
                "The summary incorrectly describes parsing into a linked list, which is not present in the source code. The function primarily interprets a level-indent string to set specific indentation styles or related constants, allocates and initializes memory for indentation based on numeric input, and handles various case branches for different level options with validation and error handling. The summary omits these specific behaviors and constants, contains a fatal semantic error about linked lists, and does not mention edge cases or branching logic.",
                "The summary contains a major inaccuracy: it claims the function parses into a linked list of levels, which is not reflected in the source code. The code allocates a single string of spaces when a numeric indent is provided, or parses specific substrings into different level-related variables, but no linked list is used. While it correctly notes input validation and memory management, this FATAL error misrepresents the primary purpose of the function."
            ]
        },
        "cpbcs": {
            "summary": "Validates and processes an XML name string by checking its type, ensuring it contains only ASCII characters before setting the type character.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes validating and processing an XML name string, checking for ASCII characters, and setting a type character, which is entirely unrelated to the source code. The source code processes indentation levels from a string, parses options, allocates memory, and sets related variables. None of the summary's claims match or safely generalize the code's logic, making all claims inaccurate.",
                "The summary is entirely inaccurate: it describes validation and processing of an XML name string with ASCII checks, which is unrelated to the source code's behavior. The function actually parses a string to set indentation levels, allocates memory, handles specific option types, and reports usage errors. The primary purpose and all secondary details from the source are completely missed.",
                "The summary is entirely inaccurate because it describes XML name validation with ASCII checks, which is unrelated to the source code. The function in the source parses a string to configure indentation options, allocate memory for spaces, and set level indentations. This divergence is a FATAL error on the primary purpose, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Validates and sets a variable's numeric option string by checking its characters and converting it to an unsigned long integer.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as converting to an unsigned long and validating a numeric option string, while the source code uses strtol to parse a signed long and includes logic for both numeric and non-numeric option formats. It omits details about handling '=' in the string, selecting option types via a switch, and calling parse_level_string for different cases, making the claim both overly narrow and partially incorrect. Few accurate elements are present, mainly that it converts string input to a number.",
                "The summary is inaccurate because it states the function validates and sets a variable's numeric option string by converting it to an unsigned long integer, which contradicts the source code. The source uses strtol to parse as a signed long, sets indentation strings, and also handles non-numeric options via parsing and switch cases. It completely misses the primary purpose related to setting level indentation and omits all secondary details such as memory allocation, error handling, and option-specific parsing.",
                "The summary makes a single claim that the function validates and sets a numeric option string by checking characters and converting it to an unsigned long integer. This is inaccurate because the code uses strtol to convert to a signed long, processes positive numeric values by setting indentation strings, and otherwise parses key\u2013value syntax and option types. The claim misses most of the function\u2019s logic and incorrectly specifies the conversion type, representing a FATAL error about the core purpose."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 368656,
    "strip_function_name": "ngx_http_map_find",
    "strip_decompiled_code": "__int64 __fastcall ngx_http_map_find(\n        __int64 a1,\n        _QWORD *a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  unsigned __int64 v11; // rbp\n  unsigned __int64 v13; // rax\n  _BYTE *v14; // r14\n  unsigned __int64 v15; // rax\n  __int64 result; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rbp\n  unsigned __int64 v20; // r14\n  __int64 v21; // rax\n  unsigned __int64 v22; // rax\n\n  v11 = *(_QWORD *)a3;\n  if ( !*(_QWORD *)a3 )\n  {\n    v22 = ngx_hash_strlow(0LL, *(_QWORD *)(a3 + 8), 0LL);\n    return ngx_hash_find_combined(a2, v22, 0LL, 0LL);\n  }\n  v13 = ngx_pnalloc(*(_QWORD **)(a1 + 88), *(_QWORD *)a3);\n  v14 = (_BYTE *)v13;\n  if ( !v13 )\n    return 0LL;\n  v15 = ngx_hash_strlow(v13, *(_QWORD *)(a3 + 8), v11);\n  result = ngx_hash_find_combined(a2, v15, v14, v11);\n  if ( result )\n    return result;\n  if ( !a2[5] )\n    return 0LL;\n  v19 = a2[4];\n  v20 = 0LL;\n  while ( 1 )\n  {\n    v21 = ngx_http_regex_exec(a1, *(_QWORD **)v19, a3, a4, a5, a6, a7, v17, v18, a10, a11);\n    if ( !v21 )\n      break;\n    if ( v21 == -5 )\n    {\n      ++v20;\n      v19 += 16LL;\n      if ( a2[5] > v20 )\n        continue;\n    }\n    return 0LL;\n  }\n  return *(_QWORD *)(v19 + 8);\n}\n",
    "function_name": "ngx_http_map_find",
    "decompiled_code": "void *__fastcall ngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)\n{\n  size_t len; // rbp\n  u_char *v5; // rax\n  u_char *v6; // r14\n  ngx_uint_t v7; // rax\n  void *result; // rax\n  ngx_http_map_regex_t *regex; // rbp\n  ngx_uint_t v10; // r14\n  ngx_int_t v11; // rax\n  ngx_uint_t v12; // rax\n\n  len = match->len;\n  if ( !match->len )\n  {\n    v12 = ngx_hash_strlow(0LL, match->data, 0LL);\n    return ngx_hash_find_combined(&map->hash, v12, 0LL, 0LL);\n  }\n  v5 = (u_char *)ngx_pnalloc(r->pool, match->len);\n  v6 = v5;\n  if ( !v5 )\n    return 0LL;\n  v7 = ngx_hash_strlow(v5, match->data, len);\n  result = ngx_hash_find_combined(&map->hash, v7, v6, len);\n  if ( result )\n    return result;\n  if ( !map->nregex )\n    return 0LL;\n  regex = map->regex;\n  v10 = 0LL;\n  while ( 1 )\n  {\n    v11 = ngx_http_regex_exec(r, regex->regex, match);\n    if ( !v11 )\n      break;\n    if ( v11 == -5 )\n    {\n      ++v10;\n      ++regex;\n      if ( map->nregex > v10 )\n        continue;\n    }\n    return 0LL;\n  }\n  return regex->value;\n}\n",
    "source_code": "\n\nvoid *\nngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)\n{\n    void        *value;\n    u_char      *low;\n    size_t       len;\n    ngx_uint_t   key;\n\n    len = match->len;\n\n    if (len) {\n        low = ngx_pnalloc(r->pool, len);\n        if (low == NULL) {\n            return NULL;\n        }\n\n    } else {\n        low = NULL;\n    }\n\n    key = ngx_hash_strlow(low, match->data, len);\n\n    value = ngx_hash_find_combined(&map->hash, key, low, len);\n    if (value) {\n        return value;\n    }\n\n#if (NGX_PCRE)\n\n    if (len && map->nregex) {\n        ngx_int_t              n;\n        ngx_uint_t             i;\n        ngx_http_map_regex_t  *reg;\n\n        reg = map->regex;\n\n        for (i = 0; i < map->nregex; i++) {\n\n            n = ngx_http_regex_exec(r, reg[i].regex, match);\n\n            if (n == NGX_OK) {\n                return reg[i].value;\n            }\n\n            if (n == NGX_DECLINED) {\n                continue;\n            }\n\n            /* NGX_ERROR */\n\n            return NULL;\n        }\n    }\n\n#endif\n\n    return NULL;\n}",
    "comment": "Finds a corresponding value in a hash map or regex patterns for a given string in an HTTP request.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Finds a key-value pair in a hash table using a combined key and returns the corresponding entry from the combined hash table .\n",
    "cpbcs_sum": "Merges an HTTP URI with a specified name and type, or retrieves its index from the shared memory block.\n",
    "misum_sum": "Generates a unique temporary filename based on an HTTP location and name, handling case sensitivity and errors.\n",
    "decom_sum": "Finds an HTTP map entry by lowercase hashing a key and, if not found, matches it against stored regular expressions.",
    "cfg_sum": "Searches for a mapping entry by exact or lowercased key, falling back to regex matching, and returns the associated value if found.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains only a vague phrase, 'push a pointer type,' which does not accurately reflect the specific logic or functionality of the source code. It neither matches the detailed map lookup and regex matching behavior nor provides safe, general context. This is essentially noise and fails to convey relevant semantics from the function.",
                "The summary 'push a pointer type' is vague, does not reference or align with the PRIMARY PURPOSE of the function, which is to find a mapped value in an Nginx HTTP map given a request and match string, using hash lookup and optional regex matching. It misses all secondary details such as memory allocation, case normalization, hash calculation, regex iteration, and error handling. The claim is unrelated to the function's observable behavior or implementation specifics.",
                "The summary contains a vague and low-information statement that does not describe the actual function behavior or semantics in the source code. It fails to mention the key purpose of the function\u2014finding a mapping in a hash or regex set for an HTTP request\u2014and instead provides unrelated NOISE. There are no accurate claims, and the overwhelming NOISE offers no value to understanding the implementation."
            ]
        },
        "bint5": {
            "summary": "Finds a key-value pair in a hash table using a combined key and returns the corresponding entry from the combined hash table .\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately captures that the function searches for and returns a value from a combined hash table based on a key, which aligns with the code\u2019s use of ngx_hash_find_combined. However, it omits mention of regex-based matching used as a fallback and does not note conditions for returning NULL, leading to incomplete coverage of the function's logic. Most claims are correct but lack full detail.",
                "The summary captures the primary purpose of locating a value in a combined hash table based on a key, which aligns with the function\u2019s main behavior. However, it omits secondary details such as allocating and lowering case for the key string, handling regex-based matches when hash lookup fails, conditions for NULL returns, and error handling. These omissions reduce coverage completeness.",
                "The summary correctly indicates that the function looks up a value in a combined hash table and returns it if found, which matches part of the source code logic. However, it omits important details, such as handling of case normalization, allocation of a lowercase buffer, and the regex-based lookup fallback when hash lookup fails. These omissions make the claim low-information. There are no contradictory (FATAL) claims, but the lack of broader coverage means the gain is minimal, falling into the safe but low-value category."
            ]
        },
        "cpbcs": {
            "summary": "Merges an HTTP URI with a specified name and type, or retrieves its index from the shared memory block.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function merges an HTTP URI with a specified name and type or retrieves its index from shared memory, which does not match the source code. The actual implementation searches for a matching value in a map using a hash or regex, without any URI merging or shared memory index retrieval. All claims are inaccurate, resulting in no alignment with the source code.",
                "The summary claims the function merges an HTTP URI with a name and type or retrieves its index from shared memory, which is entirely inaccurate. The source code shows it searches for a value in a map using a lowercase hash of the match string and optionally regex matching. It does not merge URIs, use types, or access shared memory indexes. The primary purpose is missed entirely, and the claims are unrelated to the actual implementation.",
                "The summary claims the function merges an HTTP URI with a specified name and type or retrieves its index from shared memory, which is entirely inaccurate compared to the source code. The actual implementation searches for a value in a map using a hash and optionally regex matching; there is no merging, no URI-specific handling, and no shared memory index retrieval. This is a FATAL error affecting the primary purpose of the function, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Generates a unique temporary filename based on an HTTP location and name, handling case sensitivity and errors.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about generating a unique temporary filename based on HTTP location and name is entirely unrelated to the source code, which implements map lookups and optional regex matching in Nginx. None of the extracted claims match the source code semantics, resulting in no accurate claims.",
                "The summary is entirely inaccurate. The source function searches a hash and optionally regex patterns to find a mapped value from a match string in an HTTP request, handling memory allocation and null returns. The summary instead describes generating a temporary filename, which does not match the primary purpose or any secondary details in the code. No fact-based claims from the summary align with the source's semantics.",
                "The summary\u2019s main claim about generating a unique temporary filename based on HTTP location and name is entirely inaccurate given the source code, which instead finds a value in a map using normalized string keys and optional regex matching. This is a FATAL error impacting the primary purpose of the function, as it misidentifies both the key I/O and intended logic. No accurate claims are present, yielding zero net benefit."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 357584,
    "strip_function_name": "ngx_http_request_body_save_filter",
    "strip_decompiled_code": "__int64 __fastcall ngx_http_request_body_save_filter(\n        __int64 a1,\n        _QWORD *a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  __int64 *v10; // r12\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rax\n  __int64 *free_buf; // rax\n  __int64 v16; // rdx\n  __int64 v17; // rsi\n\n  v10 = *(__int64 **)(a1 + 888);\n  if ( ngx_chain_add_copy(*(_QWORD **)(a1 + 88), v10 + 1, a2) )\n    return 500LL;\n  if ( (*(_BYTE *)(a1 + 1247) & 4) != 0 )\n    return 0LL;\n  if ( v10[3] > 0 )\n  {\n    v13 = v10[2];\n    if ( v13 && *(_QWORD *)(v13 + 8) == *(_QWORD *)(v13 + 40) && sub_56600(a1, a3, a4, a5, a6, v11, v12, a9, a10) )\n      return 500LL;\n    return 0LL;\n  }\n  if ( !*v10 && (*(_BYTE *)(a1 + 1246) & 8) == 0 )\n    return 0LL;\n  if ( !sub_56600(a1, a3, a4, a5, a6, v11, v12, a9, a10) )\n  {\n    if ( !*(_QWORD *)(*v10 + 168) )\n      return 0LL;\n    free_buf = ngx_chain_get_free_buf(*(_QWORD **)(a1 + 88), v10 + 5);\n    if ( free_buf )\n    {\n      v16 = *free_buf;\n      *(_OWORD *)(v16 + 64) = 0LL;\n      *(_BYTE *)(v16 + 72) |= 0x10u;\n      *(_OWORD *)(v16 + 16) = 0LL;\n      *(_OWORD *)(v16 + 48) = 0LL;\n      *(_OWORD *)v16 = 0LL;\n      *(_OWORD *)(v16 + 32) = 0LL;\n      v17 = *(_QWORD *)(*v10 + 168);\n      *(_QWORD *)(v16 + 56) = *v10;\n      *(_QWORD *)(v16 + 24) = v17;\n      v10[1] = (__int64)free_buf;\n      return 0LL;\n    }\n  }\n  return 500LL;\n}\n",
    "function_name": "ngx_http_request_body_save_filter",
    "decompiled_code": "ngx_int_t __fastcall ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n{\n  ngx_http_request_body_t *request_body; // r12\n  ngx_buf_t *buf; // rax\n  ngx_chain_t *free_buf; // rax\n  ngx_buf_t *v6; // rdx\n  off_t offset; // rsi\n\n  request_body = r->request_body;\n  if ( ngx_chain_add_copy(r->pool, &request_body->bufs, in) )\n    return 500LL;\n  if ( (*((_BYTE *)r + 1247) & 4) != 0 )\n    return 0LL;\n  if ( request_body->rest > 0 )\n  {\n    buf = request_body->buf;\n    if ( buf && buf->last == buf->end && ngx_http_write_request_body(r) )\n      return 500LL;\n    return 0LL;\n  }\n  if ( !request_body->temp_file && (*((_BYTE *)r + 1246) & 8) == 0 )\n    return 0LL;\n  if ( !ngx_http_write_request_body(r) )\n  {\n    if ( !request_body->temp_file->file.offset )\n      return 0LL;\n    free_buf = ngx_chain_get_free_buf(r->pool, &request_body->free);\n    if ( free_buf )\n    {\n      v6 = free_buf->buf;\n      *(_OWORD *)&v6->shadow = 0LL;\n      *((_BYTE *)v6 + 72) |= 0x10u;\n      *(_OWORD *)&v6->file_pos = 0LL;\n      *(_OWORD *)&v6->tag = 0LL;\n      *(_OWORD *)&v6->pos = 0LL;\n      *(_OWORD *)&v6->start = 0LL;\n      offset = request_body->temp_file->file.offset;\n      v6->file = &request_body->temp_file->file;\n      v6->file_last = offset;\n      request_body->bufs = free_buf;\n      return 0LL;\n    }\n  }\n  return 500LL;\n}\n",
    "source_code": "\n\nngx_int_t\nngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n{\n    ngx_buf_t                 *b;\n    ngx_chain_t               *cl;\n    ngx_http_request_body_t   *rb;\n\n    rb = r->request_body;\n\n#if (NGX_DEBUG)\n\n#if 0\n    for (cl = rb->bufs; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body old buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n#endif\n\n    for (cl = in; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body new buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n\n#endif\n\n    /* TODO: coalesce neighbouring buffers */\n\n    if (ngx_chain_add_copy(r->pool, &rb->bufs, in) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (r->request_body_no_buffering) {\n        return NGX_OK;\n    }\n\n    if (rb->rest > 0) {\n\n        if (rb->buf && rb->buf->last == rb->buf->end\n            && ngx_http_write_request_body(r) != NGX_OK)\n        {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        return NGX_OK;\n    }\n\n    /* rb->rest == 0 */\n\n    if (rb->temp_file || r->request_body_in_file_only) {\n\n        if (ngx_http_write_request_body(r) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (rb->temp_file->file.offset != 0) {\n\n            cl = ngx_chain_get_free_buf(r->pool, &rb->free);\n            if (cl == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            b = cl->buf;\n\n            ngx_memzero(b, sizeof(ngx_buf_t));\n\n            b->in_file = 1;\n            b->file_last = rb->temp_file->file.offset;\n            b->file = &rb->temp_file->file;\n\n            rb->bufs = cl;\n        }\n    }\n\n    return NGX_OK;\n}",
    "comment": "Saves the request body data by copying buffers and managing temporary files for further processing in an NGINX HTTP request.",
    "hext5_sum": "add a routine to set the demangling style to be sure it is valid and allow for any demangler initialization that maybe necessary.",
    "bint5_sum": "Processes the HTTP request body 's buffer , saves it , and manages memory while handling potential errors and end-of-stream conditions .\n",
    "cpbcs_sum": "Processes the end of a DNS request, handling both standard and asynchronous formats while managing memory and request parameters.\n",
    "misum_sum": "Reads data from an HTTP request, handling end-of-file and buffering, while invoking a post-handler if available, while logging errors and managing read errors.\n",
    "decom_sum": "Adds incoming request body buffers to a save chain, flushes them when appropriate, and allocates a free buffer for remaining body data if needed.",
    "cfg_sum": "Adds request body buffers to a processing chain, validates completion, and initializes a free buffer if needed, returning HTTP status codes.",
    "work_score": {
        "hext5": {
            "summary": "add a routine to set the demangling style to be sure it is valid and allow for any demangler initialization that maybe necessary.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary discusses adding a routine to set the demangling style and handle demangler initialization, which is unrelated to the provided source code that manages HTTP request body buffers in Nginx. None of the claims in the summary match or are supported by the code, resulting in no accurate claims.",
                "The summary discusses setting a demangling style and initializing a demangler, which is unrelated to the source code's logic for saving HTTP request body buffers, handling buffering conditions, writing request bodies to files, and returning appropriate status codes. It misses the primary purpose entirely and makes no accurate claims about the actual implementation.",
                "The summary describes adding a routine to set a demangling style with potential demangler initialization, which is completely unrelated to the provided source code that handles saving and writing HTTP request body data in NGINX. This is pure NOISE with no accurate claims about the code's functionality, resulting in no alignment or useful insight."
            ]
        },
        "bint5": {
            "summary": "Processes the HTTP request body 's buffer , saves it , and manages memory while handling potential errors and end-of-stream conditions .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary broadly states that the function processes the HTTP request body buffer, saves it, manages memory, and handles potential errors and end-of-stream conditions. These claims are generally accurate given the source code: the function adds incoming buffers to the request body, allocates and resets buffers when needed, writes to temporary files, and checks request state to return appropriate status codes. However, the summary is vague and omits specific conditions and file handling logic, but it does not introduce contradictions. The general alignment is high despite low detail.",
                "The summary accurately captures the general purpose of the function \u2014 processing and saving the HTTP request body buffer, managing memory, and handling errors/end-of-stream \u2014 matching the primary purpose in the source code. However, it omits key secondary details such as conditional handling for no buffering mode, writing to a temporary file, coalescing buffers, specific buffer allocation and initialization logic, and distinct error return codes. This limits completeness despite correctly identifying the core behavior.",
                "The summary broadly states that the function processes the HTTP request body buffer, saves it, manages memory, and handles errors/end-of-stream. These are SAFE, low-info claims that generally align with the code\u2019s behavior: the function copies buffers, potentially writes to a file, checks rest length, and returns error codes in failure cases. There are no contradictory (FATAL) claims, but the description lacks specifics such as temporary file handling, conditional writes, or buffer coalescing. The worst failure mode is low gain due to generic phrasing, providing minimal actionable insight for an engineer."
            ]
        },
        "cpbcs": {
            "summary": "Processes the end of a DNS request, handling both standard and asynchronous formats while managing memory and request parameters.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function processes the end of a DNS request, handles standard and asynchronous formats, and manages memory and request parameters. This directly contradicts the source code, which processes HTTP request body buffers in Nginx and does not involve DNS handling or asynchronous formats. None of the claims align with the code semantics, resulting in zero accurate claims.",
                "The summary is entirely inaccurate as it describes processing a DNS request with asynchronous formats, which is unrelated to the source code. The code handles saving and managing HTTP request body buffers in Nginx, including writing to temporary files and managing memory buffers. It misses the primary purpose and all key secondary details from the source implementation, and introduces unrelated concepts that do not appear in the code.",
                "The summary is entirely inaccurate, describing DNS request processing with asynchronous formats, which does not match the source code\u2019s actual function of handling HTTP request body buffers in Nginx. This is a FATAL error impacting the primary purpose, as it misrepresents the key I/O and semantics of the code. No accurate or relevant claims are present, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Reads data from an HTTP request, handling end-of-file and buffering, while invoking a post-handler if available, while logging errors and managing read errors.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function reads data from an HTTP request and handles end-of-file, buffering, invokes a post-handler, logs errors, and manages read errors. While the source code does process HTTP request body buffers and perform conditional writes, it does not invoke any post-handler, nor explicitly handle end-of-file semantics beyond checking rb->rest, nor include any specific error logging. The logging present is debug-level buffer state logging, not error logging. Several claims are inaccurate or unsupported, resulting in less than half being correct.",
                "The summary incorrectly describes the function as reading data from an HTTP request and invoking a post-handler, which are not present in the source code. The code actually appends incoming buffers to the request body buffer list, handles different buffering conditions, writes data to temporary files if needed, and returns appropriate status codes on errors. The summary fails to capture the primary purpose and omits key secondary details such as conditional writes and temporary file handling, while introducing inaccurate elements.",
                "The summary contains several inaccuracies, the most severe being a FATAL error about invoking a post-handler, which is not present in the source code. It also claims handling of end-of-file logic inaccurately and mentions logging errors, whereas the code only logs buffer details for debugging. There is little specific accurate information about the function\u2019s actual behavior (saving/adding request body buffers, conditional write operations, and temp file handling). The worst failure mode is FATAL as it misstates the primary purpose by introducing nonexistent post-handler usage."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592359958,
    "strip_function_name": "sub_FFFFFFFF81CE3816",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81CE3816(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned int v8; // ebx\n  double v9; // xmm0_8\n  double v10; // xmm4_8\n  double v11; // xmm5_8\n  __int64 v12; // rsi\n  __int64 v13; // rcx\n  __int64 *v14; // rdi\n  int v15; // edx\n  int v16; // ecx\n  int v17; // r8d\n  int v18; // r9d\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  int v22; // r9d\n  double v23; // xmm4_8\n  double v24; // xmm5_8\n\n  v8 = dword_FFFFFFFF81DF2A14;\n  if ( dword_FFFFFFFF81DF2A14 )\n  {\n    v8 = -1;\n    sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF81987710, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  else if ( (qword_FFFFFFFF81CB4E94 & 0x200) != 0 )\n  {\n    v9 = sub_FFFFFFFF81CE5315();\n    sub_FFFFFFFF81CE3394(v9, a2, a3, a4, v10, v11, a7, a8);\n    sub_FFFFFFFF81CE37FB();\n    v12 = ((unsigned int (__fastcall *)(_QWORD))off_FFFFFFFF81CB6AB8[23])((unsigned int)dword_FFFFFFFF81C1B57C);\n    ((void (__fastcall *)(__int64, __int64))off_FFFFFFFF81CB6AB8[37])(32LL, v12);\n    v13 = 1024LL;\n    v14 = qword_FFFFFFFF81DF2A40;\n    while ( v13 )\n    {\n      *(_DWORD *)v14 = v8;\n      v14 = (__int64 *)((char *)v14 + 4);\n      --v13;\n    }\n    _interlockedbittestandset((volatile signed __int32 *)qword_FFFFFFFF81DF2A40, dword_FFFFFFFF81C1B57C);\n    sub_FFFFFFFF81786852();\n    if ( !dword_FFFFFFFF81DF3AE4 && dword_FFFFFFFF81DF5B44 )\n      sub_FFFFFFFF81CE496B(v14);\n    sub_FFFFFFFF81786AD6((__int64)v14, v12, v15, v16, v17, v18);\n    if ( dword_FFFFFFFF81DF2A04 && !dword_FFFFFFFF81DF3AE4 && dword_FFFFFFFF81DF5B44 )\n      sub_FFFFFFFF81CE4A59();\n    else\n      dword_FFFFFFFF81DF5B44 = 0;\n    off_FFFFFFFF81D78B88(v9, a2, a3, a4, v23, v24, a7, a8, (__int64)v14, v12, v19, v20, v21, v22);\n  }\n  else\n  {\n    dword_FFFFFFFF81DF2A14 = 1;\n    v8 = -1;\n    sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF81987721, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  return v8;\n}\n",
    "function_name": "APIC_init_uniprocessor",
    "decompiled_code": "__int64 __fastcall APIC_init_uniprocessor(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  unsigned int v8; // ebx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  __int64 v11; // rsi\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 v14; // rcx\n  __int64 *v15; // rdi\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 v18; // rdx\n  __int64 v19; // rcx\n  __int64 v20; // r8\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  v8 = disable_apic;\n  if ( disable_apic )\n  {\n    v8 = -1;\n    printk((__int64)&unk_FFFFFFFF81987710, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  else if ( (qword_FFFFFFFF81CB4E94 & 0x200) != 0 )\n  {\n    default_setup_apic_routing(a1, a2, a3, a4, a5, a6, a7, a8);\n    verify_local_APIC(a1, a2, a3, a4, v9, v10, a7, a8);\n    connect_bsp_APIC();\n    v11 = (*((unsigned int (__fastcall **)(_QWORD))apic + 23))((unsigned int)boot_cpu_physical_apicid);\n    (*((void (__fastcall **)(__int64, __int64))apic + 37))(32LL, v11);\n    v14 = 1024LL;\n    v15 = phys_cpu_present_map;\n    while ( v14 )\n    {\n      *(_DWORD *)v15 = v8;\n      v15 = (__int64 *)((char *)v15 + 4);\n      --v14;\n    }\n    _interlockedbittestandset((volatile signed __int32 *)phys_cpu_present_map, boot_cpu_physical_apicid);\n    setup_local_APIC(a1, a2, a3, a4, v12, v13, a7, a8);\n    if ( !skip_ioapic_setup && nr_ioapics )\n      enable_IO_APIC(a1, a2, a3, a4, v16, v17, a7, a8);\n    end_local_APIC_setup(a1, a2, a3, a4, v16, v17, a7, a8);\n    if ( smp_found_config && !skip_ioapic_setup && nr_ioapics )\n      setup_IO_APIC(a1, a2, a3, a4, v22, v23, a7, a8);\n    else\n      nr_ioapics = 0;\n    off_FFFFFFFF81D78B88(a1, a2, a3, a4, v22, v23, a7, a8, (__int64)v15, v11, v18, v19, v20, v21);\n  }\n  else\n  {\n    disable_apic = 1;\n    v8 = -1;\n    printk((__int64)&unk_FFFFFFFF81987721, a1, a2, a3, a4, a5, a6, a7, a8);\n  }\n  return v8;\n}\n",
    "source_code": "\nint __init APIC_init_uniprocessor(void)\n{\n\tif (disable_apic) {\n\t\tpr_info(\"Apic disabled\\n\");\n\t\treturn -1;\n\t}\n#ifdef CONFIG_X86_64\n\tif (!cpu_has_apic) {\n\t\tdisable_apic = 1;\n\t\tpr_info(\"Apic disabled by BIOS\\n\");\n\t\treturn -1;\n\t}\n#else\n\tif (!smp_found_config && !cpu_has_apic)\n\t\treturn -1;\n\n\t/*\n\t * Complain if the BIOS pretends there is one.\n\t */\n\tif (!cpu_has_apic &&\n\t    APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {\n\t\tpr_err(\"BIOS bug, local APIC 0x%x not detected!...\\n\",\n\t\t\tboot_cpu_physical_apicid);\n\t\treturn -1;\n\t}\n#endif\n\n\tdefault_setup_apic_routing();\n\n\tverify_local_APIC();\n\tconnect_bsp_APIC();\n\n#ifdef CONFIG_X86_64\n\tapic_write(APIC_ID, SET_APIC_ID(boot_cpu_physical_apicid));\n#else\n\t/*\n\t * Hack: In case of kdump, after a crash, kernel might be booting\n\t * on a cpu with non-zero lapic id. But boot_cpu_physical_apicid\n\t * might be zero if read from MP tables. Get it from LAPIC.\n\t */\n# ifdef CONFIG_CRASH_DUMP\n\tboot_cpu_physical_apicid = read_apic_id();\n# endif\n#endif\n\tphysid_set_mask_of_physid(boot_cpu_physical_apicid, &phys_cpu_present_map);\n\tsetup_local_APIC();\n\n#ifdef CONFIG_X86_IO_APIC\n\t/*\n\t * Now enable IO-APICs, actually call clear_IO_APIC\n\t * We need clear_IO_APIC before enabling error vector\n\t */\n\tif (!skip_ioapic_setup && nr_ioapics)\n\t\tenable_IO_APIC();\n#endif\n\n\tbsp_end_local_APIC_setup();\n\n#ifdef CONFIG_X86_IO_APIC\n\tif (smp_found_config && !skip_ioapic_setup && nr_ioapics)\n\t\tsetup_IO_APIC();\n\telse {\n\t\tnr_ioapics = 0;\n\t}\n#endif\n\n\tx86_init.timers.setup_percpu_clockev();\n\treturn 0;\n}",
    "comment": "Initializes the local APIC for uniprocessor systems, verifying configuration and enabling IO-APICs as necessary for proper operation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the HPET ( High Precision Event Timer ) if enabled , configures MSI capabilities , reserves platform timers , and notifies CPUs of their online status .\n",
    "cpbcs_sum": "Initializes the boot processor by checking for Intel MADT handling PCI architecture, and checking for BIOS completion or initialization status.\n",
    "misum_sum": "Initializes the Intel IOMMU by checking CPU capabilities, enabling machine check exceptions and configuring error checking for various conditions.\n",
    "decom_sum": "Initializes a hardware buffer, triggers device-specific operations, updates status flags, and invokes callbacks based on configuration and control register conditions.",
    "cfg_sum": "Handles system state transitions by checking flags, initializing memory, invoking hardware-related operations, performing optional cleanup, and returning a status code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only a vague phrase unrelated to any specific logic or behavior in the source code. It does not reference APIC initialization, conditional checks, or function calls from the implementation, making it entirely inaccurate under the evaluation steps.",
                "The summary 'push a pointer type.' does not reference the source code's purpose or behavior. The function initializes the local and IO APIC for a uniprocessor system with various hardware checks and configurations, but the summary is unrelated and lacks any accurate, fact-based claim about this. It misses the primary purpose and all secondary details.",
                "The summary contains only the vague statement 'push a pointer type,' which does not address any of the actual logic, conditions, side effects, or purpose of the APIC_init_uniprocessor function in the source code. This is pure NOISE with no factual alignment to the implementation, providing no useful insight and failing to capture primary purpose or I/O behavior."
            ]
        },
        "bint5": {
            "summary": "Initializes the HPET ( High Precision Event Timer ) if enabled , configures MSI capabilities , reserves platform timers , and notifies CPUs of their online status .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "All claims in the summary describe initialization of HPET, MSI configuration, platform timer reservation, and CPU status notification, none of which are present in the source code. The source code focuses on local APIC and IO-APIC setup, APIC routing, and related hardware configuration. This means 0% of the claims match the actual implementation.",
                "The summary does not capture the primary purpose of the source code, which is initializing the local APIC in a uniprocessor system, including checks for APIC availability and BIOS settings, and setting up IO-APICs and timers. Instead, it describes HPET initialization, MSI configuration, and platform timer reservation, none of which are present in the implementation. All claims are inaccurate and unrelated to the actual behavior, resulting in no coverage of critical semantic units.",
                "All claims in the summary are inaccurate and constitute NOISE, as the source code is focused on initializing the local APIC and IO-APIC, not HPET, MSI, platform timers, or CPU online notifications. None of the described actions match the key I/O or side effects in the implementation, leading to a complete mismatch with the actual function purpose."
            ]
        },
        "cpbcs": {
            "summary": "Initializes the boot processor by checking for Intel MADT handling PCI architecture, and checking for BIOS completion or initialization status.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims checks for Intel MADT handling PCI architecture and BIOS completion/initialization status, but the source code does not mention MADT, PCI architecture, or BIOS completion status in those terms. The actual code checks for APIC disable flags, CPU APIC presence, BIOS behavior regarding APIC, and then performs APIC setup steps. None of the claims match the implementation, resulting in no accurate claims.",
                "The summary incorrectly describes the function as handling Intel MADT and PCI architecture, which are not present in the source code, making it inaccurate. It fails to capture the actual primary purpose\u2014initializing the local APIC for a uniprocessor\u2014along with checks for APIC availability, BIOS-related conditions, and subsequent setup steps. No accurate claim matches the code\u2019s semantics, so no CSU coverage is achieved.",
                "The summary makes claims about Intel MADT handling and PCI architecture, as well as BIOS completion status, none of which are present in the source code. The source function deals with APIC initialization, checking conditions like disable_apic, cpu_has_apic, BIOS bugs related to APIC detection, and setting up local and IO APICs. These mismatched details are FATAL inaccuracies concerning the primary purpose of the function, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Initializes the Intel IOMMU by checking CPU capabilities, enabling machine check exceptions and configuring error checking for various conditions.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes the Intel IOMMU, checks CPU capabilities, enables machine check exceptions, and configures error checking, none of which are present in the source code. The source code actually initializes the local APIC in a uniprocessor system, manages APIC/IO-APIC setup, and handles APIC-related conditions. All claims in the summary are inaccurate relative to the code, resulting in no accurate claims.",
                "The summary is inaccurate because it describes initializing the Intel IOMMU, enabling machine check exceptions, and configuring error checking, none of which are present in the source code. The actual function initializes the local APIC for a uniprocessor, with checks for CPU APIC capabilities, BIOS settings, and configuration of IO-APIC and timers. It misses the primary purpose entirely and contains unrelated details, resulting in no accurate claim coverage.",
                "The summary is entirely inaccurate: it describes initialization of the Intel IOMMU and enabling machine check exceptions, none of which are present in the source. The actual function initializes the local APIC in a uniprocessor configuration, checking APIC capabilities and setting up IO-APICs. This is a FATAL error affecting the primary purpose, making the summary misleading and unusable."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 981824,
    "strip_function_name": "sub_EFB40",
    "strip_decompiled_code": "__int64 __fastcall sub_EFB40(__int64 *a1, char **a2, __int64 a3, __int64 *a4, char a5, _BYTE *a6)\n{\n  __int64 v6; // rax\n  int v9; // eax\n  char *v10; // r15\n  int v11; // edx\n  __int64 result; // rax\n  char *v13; // rax\n  __int64 v14; // r15\n  char v15; // [rsp+Eh] [rbp-4Ah] BYREF\n  char v16; // [rsp+Fh] [rbp-49h] BYREF\n  __int64 v17; // [rsp+10h] [rbp-48h] BYREF\n  char *v18[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( !a1 )\n    return 0LL;\n  v6 = *a4;\n  v18[0] = *a2;\n  if ( (v6 & 0x10) == 0 )\n    return sub_EF7C0(a1, a2, a3, a4, a5, a6);\n  v9 = sub_EDE30(&v17, 0LL, 0LL, &v15, &v16, (__int64 *)v18, a3, a4[1], (unsigned __int8)v6 & 0xC0, a5, (__int64)a6);\n  v10 = v18[0];\n  v11 = v9;\n  if ( !v9 )\n  {\n    ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 563);\n    return 0LL;\n  }\n  result = 0xFFFFFFFFLL;\n  if ( v11 != -1 )\n  {\n    if ( !v16 )\n    {\n      ERR_put_error(0xDu, 132, 120, (__int64)\"tasn_dec.c\", 571);\n      return 0LL;\n    }\n    if ( (unsigned int)sub_EF7C0(a1, v18, v17, a4, 0, a6) )\n    {\n      v13 = v18[0];\n      v14 = v17 + v10 - v18[0];\n      v17 = v14;\n      if ( v15 )\n      {\n        if ( v14 > 1 && !*v18[0] && !v18[0][1] )\n        {\n          v13 = v18[0] + 2;\nLABEL_18:\n          *a2 = v13;\n          return 1LL;\n        }\n        ERR_put_error(0xDu, 132, 137, (__int64)\"tasn_dec.c\", 590);\n      }\n      else\n      {\n        if ( !v14 )\n          goto LABEL_18;\n        ERR_put_error(0xDu, 132, 119, (__int64)\"tasn_dec.c\", 601);\n      }\n      ASN1_template_free((void **)a1, a4);\n      return 0LL;\n    }\n    else\n    {\n      ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 579);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "function_name": "asn1_template_ex_d2i",
    "decompiled_code": "__int64 __fastcall asn1_template_ex_d2i(__int64 *a1, char **a2, char *a3, __int64 *a4, char a5, _BYTE *a6)\n{\n  __int64 v6; // rax\n  int v9; // eax\n  unsigned __int8 *v10; // r15\n  int v11; // edx\n  __int64 result; // rax\n  unsigned __int8 *v13; // rax\n  char *v14; // r15\n  char v15; // [rsp+Eh] [rbp-4Ah] BYREF\n  char v16; // [rsp+Fh] [rbp-49h] BYREF\n  char *v17; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int8 *v18[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( !a1 )\n    return 0LL;\n  v6 = *a4;\n  v18[0] = (unsigned __int8 *)*a2;\n  if ( (v6 & 0x10) == 0 )\n    return asn1_template_noexp_d2i(a1, a2, a3, a4, a5, a6);\n  v9 = asn1_check_tlen(&v17, 0LL, 0LL, &v15, &v16, v18, (__int64)a3, a4[1], (unsigned __int8)v6 & 0xC0, a5, (__int64)a6);\n  v10 = v18[0];\n  v11 = v9;\n  if ( !v9 )\n  {\n    ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 563);\n    return 0LL;\n  }\n  result = 0xFFFFFFFFLL;\n  if ( v11 != -1 )\n  {\n    if ( !v16 )\n    {\n      ERR_put_error(0xDu, 132, 120, (__int64)\"tasn_dec.c\", 571);\n      return 0LL;\n    }\n    if ( (unsigned int)asn1_template_noexp_d2i(a1, (char **)v18, v17, a4, 0, a6) )\n    {\n      v13 = v18[0];\n      v14 = &v17[v10 - v18[0]];\n      v17 = v14;\n      if ( v15 )\n      {\n        if ( (__int64)v14 > 1 && !*v18[0] && !v18[0][1] )\n        {\n          v13 = v18[0] + 2;\nLABEL_18:\n          *a2 = (char *)v13;\n          return 1LL;\n        }\n        ERR_put_error(0xDu, 132, 137, (__int64)\"tasn_dec.c\", 590);\n      }\n      else\n      {\n        if ( !v14 )\n          goto LABEL_18;\n        ERR_put_error(0xDu, 132, 119, (__int64)\"tasn_dec.c\", 601);\n      }\n      ASN1_template_free((unsigned int **)a1, a4);\n      return 0LL;\n    }\n    else\n    {\n      ERR_put_error(0xDu, 132, 58, (__int64)\"tasn_dec.c\", 579);\n      return 0LL;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int asn1_template_ex_d2i(ASN1_VALUE **val,\n\t\t\t\tconst unsigned char **in, long inlen,\n\t\t\t\tconst ASN1_TEMPLATE *tt, char opt,\n\t\t\t\t\t\t\tASN1_TLC *ctx)\n\t{\n\tint flags, aclass;\n\tint ret;\n\tlong len;\n\tconst unsigned char *p, *q;\n\tchar exp_eoc;\n\tif (!val)\n\t\treturn 0;\n\tflags = tt->flags;\n\taclass = flags & ASN1_TFLG_TAG_CLASS;\n\n\tp = *in;\n\n\t/* Check if EXPLICIT tag expected */\n\tif (flags & ASN1_TFLG_EXPTAG)\n\t\t{\n\t\tchar cst;\n\t\t/* Need to work out amount of data available to the inner\n\t\t * content and where it starts: so read in EXPLICIT header to\n\t\t * get the info.\n\t\t */\n\t\tret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,\n\t\t\t\t\t&p, inlen, tt->tag, aclass, opt, ctx);\n\t\tq = p;\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\telse if (ret == -1)\n\t\t\treturn -1;\n\t\tif (!cst)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We've found the field so it can't be OPTIONAL now */\n\t\tret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We read the field in OK so update length */\n\t\tlen -= p - q;\n\t\tif (exp_eoc)\n\t\t\t{\n\t\t\t/* If NDEF we must have an EOC here */\n\t\t\tif (!asn1_check_eoc(&p, len))\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\t\tASN1_R_MISSING_EOC);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* Otherwise we must hit the EXPLICIT tag end or its\n\t\t\t * an error */\n\t\t\tif (len)\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_LENGTH_MISMATCH);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\treturn asn1_template_noexp_d2i(val, in, inlen,\n\t\t\t\t\t\t\t\ttt, opt, ctx);\n\n\t*in = p;\n\treturn 1;\n\n\terr:\n\tASN1_template_free(val, tt);\n\treturn 0;\n\t}",
    "comment": "Parses an ASN.1 encoded structure, handling explicit tags and validating length, while managing errors and memory for the decoded value.",
    "hext5_sum": "set the endianness of the symbol table attached to fp.",
    "bint5_sum": "Validates an XML attribute against a RelaxNG definition , checking attributes and namespace constraints , and returning a status code .\n",
    "cpbcs_sum": "Validates ASN.1 encoded data by checking the ASN.1 encoded truncate data, length, and flags, returning the length of the encoded string.\n",
    "misum_sum": "Processes ASN.1 encoded data, decoding it into a buffer while handling implicit characters and error conditions.\n",
    "decom_sum": "Parses and validates ASN.1 data using a template, handling optional elements, advancing input on success, and reporting specific decoding errors.",
    "cfg_sum": "Parses and decodes ASN.1 data from input with optional special handling, performing validation, error reporting, and resource cleanup before returning success or failure.",
    "work_score": {
        "hext5": {
            "summary": "set the endianness of the symbol table attached to fp.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function sets the endianness of a symbol table attached to a file pointer, which is entirely unrelated to the actual implementation. The source code deals with ASN.1 decoding, explicit tag handling, and error checking, with no reference to symbol tables, file pointers, or endianness. This is a direct semantic mismatch, making the claim inaccurate.",
                "The summary claim about setting the endianness of a symbol table attached to a file pointer is unrelated to the source code, which handles ASN.1 template parsing, including explicit tag handling, error checks, and decoding functions. It misses the primary purpose entirely and does not match any semantic unit from the implementation.",
                "The summary claim that the function sets the endianness of a symbol table attached to fp is completely unrelated to the source code, which implements ASN.1 template decoding with explicit/implicit tag handling. This is a NOISE failure, as it targets different semantics entirely, providing no accurate or relevant insight into the code's primary purpose, I/O, or side effects."
            ]
        },
        "bint5": {
            "summary": "Validates an XML attribute against a RelaxNG definition , checking attributes and namespace constraints , and returning a status code .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes validation of an XML attribute against a RelaxNG definition, which is unrelated to the provided source code. The source code processes ASN.1 data structures with explicit tagging and error handling logic, not XML or RelaxNG validation. All claims in the summary are inaccurate and do not reflect the code's functionality.",
                "The summary describes validation of XML attributes against a RelaxNG definition, which is entirely unrelated to the source code. The source code implements ASN.1 template decoding with handling of explicit tags, length checks, and error reporting. None of the summary\u2019s claims align with the function\u2019s primary purpose or secondary details, making them inaccurate and providing no coverage of critical semantic units.",
                "The summary incorrectly describes XML attribute validation against a RelaxNG definition, which is unrelated to the provided C function. The source code processes ASN.1 data structures with explicit and implicit tags, error handling, and decoding logic. This is a FATAL error on the primary purpose, as the summary misidentifies the domain, inputs, and outputs entirely, introducing overwhelming noise with no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Validates ASN.1 encoded data by checking the ASN.1 encoded truncate data, length, and flags, returning the length of the encoded string.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains inaccuracies and lacks alignment with the source code. While it mentions checking length and flags, it incorrectly states that the function returns the length of the encoded string; in reality, it returns 1 for success, 0 for failure, or -1 for optional conditions. It also omits important details such as handling explicit tags, constructed types, and error conditions, making less than half of its claims accurate.",
                "The summary inaccurately describes the function, claiming it returns the length of the encoded string, whereas the source code returns success/failure indicators or -1 for specific cases. It also omits the primary purpose of parsing ASN.1 data according to template flags, handling explicit tags, error conditions, and EOC checks. Critical semantic units like branching between explicit and no-explicit parsing, error reporting, and freeing resources on failure are missed entirely.",
                "The summary makes a broad claim about validating ASN.1 encoded data and returning the length, but the source code\u2019s primary purpose is to decode ASN.1 templates with optional explicit tagging, handle nested content, and error conditions; it does not return the length of the encoded string. This is a FATAL inaccuracy regarding the function\u2019s key output and purpose, and the rest of the claim is too generic to provide meaningful insight."
            ]
        },
        "misum": {
            "summary": "Processes ASN.1 encoded data, decoding it into a buffer while handling implicit characters and error conditions.\n",
            "score": [
                0.5,
                0.5,
                0.5
            ],
            "reason": [
                "The summary claims involve decoding ASN.1 encoded data and handling implicit characters and error conditions. While the source code does indeed parse ASN.1 data and handle multiple error scenarios, there is no evidence in the code of handling 'implicit characters'; instead, it deals with explicit tags, optional fields, and length checks. Thus, only part of the summary aligns accurately, making the claim set partially accurate but with notable misrepresentation.",
                "The summary captures the broad primary purpose of processing and decoding ASN.1 encoded data and mentions error handling, which aligns with the function\u2019s main role and some secondary behavior. However, it omits key implementation specifics from the source, such as handling explicit versus non-explicit tags, constructed data checks, length/eoc validations, and the branching between `asn1_template_noexp_d2i` and explicit handling logic. The mention of 'implicit characters' is inaccurate and not supported by the code, which focuses on tag classes and explicit tags, reducing accuracy.",
                "The summary makes a broad claim about processing ASN.1 encoded data and handling errors, which is generally accurate in describing the function\u2019s overall purpose. However, it introduces an inaccurate element by mentioning 'implicit characters,' which is not reflected in the source code\u2019s logic. The function specifically handles explicit tags and invokes lower-level decoders, without any character-specific processing. This inaccuracy is noise rather than a fatal error, causing low informational value overall."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584049712,
    "strip_function_name": "sub_FFFFFFFF814F6A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF814F6A30(__int64 *a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  int v3; // ecx\n  __int64 result; // rax\n  int v5; // eax\n  int v6; // edx\n  unsigned __int8 v7; // dl\n  int v8; // ecx\n  _BOOL4 v9; // eax\n  int v10; // eax\n\n  v1 = *a1;\n  v2 = *((unsigned __int8 *)a1 + 265);\n  v3 = *(_DWORD *)(*a1 + 4);\n  if ( v2 < v3 )\n  {\n    v5 = v2 - 1;\n    v6 = v5;\n    if ( v5 < 0 || v3 < v5 )\n    {\n      return 0LL;\n    }\n    else\n    {\n      result = 1LL;\n      if ( !v6 )\n      {\n        v7 = *((_BYTE *)a1 + 256);\n        if ( (v7 & 0xFC) != 0 )\n        {\n          v8 = *(_DWORD *)(v1 + 8);\n          if ( (v8 & 0xF) != 0 )\n          {\n            result = 0LL;\n            if ( (v7 & 8) == 0 )\n            {\n              if ( v7 >> 6 == 1 || (a1[32] & 0x20) != 0 )\n              {\n                v10 = 5;\n                if ( (v8 & 4) != 0 )\n                  v10 = 4;\n              }\n              else\n              {\n                v9 = v7 >> 6 == 2;\n                if ( (v8 & 4) != 0 )\n                  v10 = 3 * v9 + 4;\n                else\n                  v10 = 3 * v9 + 5;\n              }\n              *(_DWORD *)(v1 + 4) = v10;\n              return 1LL;\n            }\n          }\n        }\n        else\n        {\n          sub_FFFFFFFF814F66A0(a1);\n          return 2LL;\n        }\n      }\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF814F66A0(a1);\n    return 2LL;\n  }\n  return result;\n}\n",
    "function_name": "cypress_protocol_handler",
    "decompiled_code": "__int64 __fastcall cypress_protocol_handler(\n        unsigned __int8 *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rsi\n  int v10; // eax\n  int v11; // ecx\n  __int64 result; // rax\n  int v13; // eax\n  int v14; // edx\n  unsigned __int8 v15; // dl\n  int v16; // ecx\n  _BOOL4 v17; // eax\n  int v18; // eax\n\n  v9 = *(_QWORD *)a1;\n  v10 = a1[265];\n  v11 = *(_DWORD *)(*(_QWORD *)a1 + 4LL);\n  if ( v10 < v11 )\n  {\n    v13 = v10 - 1;\n    v14 = v13;\n    if ( v13 < 0 || v11 < v13 )\n    {\n      return 0LL;\n    }\n    else\n    {\n      result = 1LL;\n      if ( !v14 )\n      {\n        v15 = a1[256];\n        if ( (v15 & 0xFC) != 0 )\n        {\n          v16 = *(_DWORD *)(v9 + 8);\n          if ( (v16 & 0xF) != 0 )\n          {\n            result = 0LL;\n            if ( (v15 & 8) == 0 )\n            {\n              if ( v15 >> 6 == 1 || (a1[256] & 0x20) != 0 )\n              {\n                v18 = 5;\n                if ( (v16 & 4) != 0 )\n                  v18 = 4;\n              }\n              else\n              {\n                v17 = v15 >> 6 == 2;\n                if ( (v16 & 4) != 0 )\n                  v18 = 3 * v17 + 4;\n                else\n                  v18 = 3 * v17 + 5;\n              }\n              *(_DWORD *)(v9 + 4) = v18;\n              return 1LL;\n            }\n          }\n        }\n        else\n        {\n          cypress_process_packet((__int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);\n          return 2LL;\n        }\n      }\n    }\n  }\n  else\n  {\n    cypress_process_packet((__int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    return 2LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic psmouse_ret_t cypress_protocol_handler(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (psmouse->pktcnt >= cytp->pkt_size) {\n\t\tcypress_process_packet(psmouse, 0);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn cypress_validate_byte(psmouse);\n}",
    "comment": "Handles packet processing for a Cypress device, validating bytes and triggering full packet processing when the expected packet size is reached.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Validates if the mouse is within valid bounds and has valid coordinates , returning 1 for valid coordinates and 0 for invalid coordinates .\n",
    "cpbcs_sum": "Processes a PS/2 mouse to extract state and protocol version information, handling specific error conditions for invalid input data.\n",
    "misum_sum": "Classifies a specific keyboard structure into interrupt format, handling special cases for invalid input and escape sequences.\n",
    "decom_sum": "Validates index bounds and conditionally updates a control field based on status flags, otherwise triggers a fallback handler and returns a status code.",
    "cfg_sum": "Checks index and status flags, updates a control field accordingly, or triggers a reset routine, returning a status code based on hardware state.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary 'push a pointer type' does not reflect any factual claim about the source code's logic, parameters, or return values. It is unrelated to the cypress_protocol_handler implementation and thus constitutes noise. None of the extracted claims are accurate against the source code.",
                "The summary 'push a pointer type' does not accurately or meaningfully describe the source code's purpose or behavior. It misses the primary purpose of handling Cypress protocol packets, including the conditions for processing a full packet and validating bytes. The claim is vague, low-information, and unrelated to the function's actual semantics.",
                "The summary's single claim 'push a pointer type' does not align with the source code, which processes packets based on pktcnt and pkt_size, and returns specific psmouse_ret_t values. The claim is vague, unrelated to the code logic, and constitutes NOISE. With no accurate or useful insight and overwhelming irrelevance, this yields very low net benefit."
            ]
        },
        "bint5": {
            "summary": "Validates if the mouse is within valid bounds and has valid coordinates , returning 1 for valid coordinates and 0 for invalid coordinates .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function checks mouse bounds and coordinates, returning 1 or 0 based on validity, but the source code shows it processes a packet if the packet count meets the expected size and otherwise calls a validation function. There is no explicit bounds or coordinate checking, nor 1/0 return semantics. All claims are inaccurate relative to the source code, resulting in no alignment with the evaluation criteria.",
                "The summary describes coordinate validation and returning 1 or 0 based on validity, which does not match the source code's actual behavior of checking packet count, processing the packet if full, and returning a specific enum value or invoking a validation function. This misses the primary purpose entirely and introduces unrelated details, making the claims inaccurate.",
                "The summary makes a specific claim about validating mouse bounds and coordinates with return values 1 or 0, which directly contradicts the source code. The source function checks packet count against packet size, processes packets, returns PSMOUSE_FULL_PACKET, or validates a byte \u2014 it does not deal with coordinate bounds or return 1/0. This is a FATAL error affecting the primary purpose and key output semantics, with no accurate claims to offset the impact."
            ]
        },
        "cpbcs": {
            "summary": "Processes a PS/2 mouse to extract state and protocol version information, handling specific error conditions for invalid input data.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function processes a PS/2 mouse to extract state and protocol version information and handles specific error conditions for invalid input data. The source code shows it checks packet count against expected size, processes the packet, and returns either a full packet indicator or result of byte validation. There is no evidence of protocol version extraction or explicit error condition handling for invalid data in the code. Most claims are inaccurate because they introduce functionality not present in the source.",
                "The summary is inaccurate because it describes extracting state and protocol version information along with handling specific error conditions, none of which are evident in the source code. The actual function checks if a full packet has been accumulated and either processes it or validates the next byte, with no explicit protocol version handling or detailed error condition logic. The primary purpose of packet processing is missed, and the described behavior contradicts the implementation.",
                "The summary claims that the function extracts state and protocol version information and handles specific error conditions for invalid input. The source code shows the function only checks if enough bytes have been collected, processes the packet, and either returns a constant or validates a byte. There is no evidence of protocol version handling or specific error conditions mentioned; these are inaccurate and relate to the primary purpose, making them FATAL errors. There are no accurate claims to balance the inaccuracies, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Classifies a specific keyboard structure into interrupt format, handling special cases for invalid input and escape sequences.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about classifying a keyboard structure, handling invalid input, and escape sequences do not align with the source code, which processes mouse protocol packets and validates bytes. None of the claims accurately reflect the code's semantics, resulting in no accurate matches.",
                "The summary is inaccurate because it describes classifying a keyboard structure into an interrupt format with handling for invalid input and escape sequences, which does not match the source code. The actual function processes mouse protocol packets, checks packet size, calls a processing function, and returns either a full packet indicator or validation result. The summary misses the primary purpose entirely and introduces unrelated concepts such as keyboard structures and escape sequences.",
                "The summary makes claims about classifying a keyboard structure into an interrupt format and handling invalid input and escape sequences, which do not align with the source code's implementation of a Cypress touchpad protocol handler that processes packets and validates bytes. These are inaccurate and unrelated to the actual primary purpose and I/O behavior, representing a FATAL error about the core functionality."
            ]
        }
    }
}
{
    "project_name": "texinfo",
    "function_addr": 144448,
    "strip_function_name": "sub_23440",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_23440(unsigned int sig)\n{\n  struct sigaction *v1; // rdx\n  struct sigaction *v3; // r12\n  __pid_t v4; // eax\n  sigset_t v5; // [rsp+0h] [rbp-138h] BYREF\n  sigset_t set; // [rsp+80h] [rbp-B8h] BYREF\n  unsigned __int64 v7; // [rsp+108h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  if ( sig <= 0x1C )\n  {\n    if ( ((1LL << sig) & 0x70800C) != 0 )\n    {\n      v3 = &oact;\n      if ( sig != 20 )\n      {\n        v3 = &stru_24BAC0;\n        if ( sig != 22 )\n        {\n          if ( sig == 21 )\n          {\n            v3 = &stru_24BA20;\n          }\n          else\n          {\n            v3 = &stru_24B700;\n            if ( sig != 3 )\n            {\n              v3 = &stru_24B8E0;\n              if ( sig != 2 )\n              {\n                v3 = 0LL;\n                if ( sig == 15 )\n                  v3 = &stru_24B840;\n              }\n            }\n          }\n        }\n      }\n      sub_24440(0, dword_24C140 - 1);\n      sub_24640();\n      fflush(stdout);\n      sub_25670();\n      sigaction(sig, v3, 0LL);\n      sigemptyset(&set);\n      sigemptyset(&v5);\n      sigaddset(&v5, sig);\n      sigprocmask(1, &v5, &set);\n      v4 = getpid();\n      kill(v4, sig);\n      sub_25480();\n      sigaction(sig, &act, v3);\n      sub_23400();\n    }\n    else if ( ((1LL << sig) & 0x10000400) != 0 )\n    {\n      v1 = &stru_24B980;\n      if ( sig != 28 )\n      {\n        v1 = &stru_24B7A0;\n        if ( sig != 10 )\n          v1 = (struct sigaction *)((1LL << sig) & 0x70800C);\n      }\n      sigaction(sig, &act, v1);\n      if ( dword_24B6E0 )\n        abort();\n      dword_24B6E0 = 1;\n      sub_23400();\n      --dword_24B6E0;\n      sigemptyset(&set);\n      sigemptyset(&v5);\n      sigaddset(&v5, sig);\n      sigprocmask(1, &v5, &set);\n    }\n  }\n  return __readfsqword(0x28u) ^ v7;\n}\n",
    "function_name": "info_signal_proc",
    "decompiled_code": "void __fastcall info_signal_proc(int sig)\n{\n  struct sigaction *v1; // rdx\n  signal_info *v2; // r12\n  __pid_t v3; // eax\n  _UNKNOWN *retaddr; // [rsp+138h] [rbp+0h] BYREF\n  sigset_t v5; // [rsp+1B8h] [rbp+80h] BYREF\n  unsigned __int64 v6; // [rsp+240h] [rbp+108h]\n\n  v6 = __readfsqword(0x28u);\n  if ( (unsigned int)sig <= 0x1C )\n  {\n    if ( ((1LL << sig) & 0x70800C) != 0 )\n    {\n      v2 = &old_TSTP;\n      if ( sig != 20 )\n      {\n        v2 = &old_TTOU;\n        if ( sig != 22 )\n        {\n          if ( sig == 21 )\n          {\n            v2 = &old_TTIN;\n          }\n          else\n          {\n            v2 = &old_QUIT;\n            if ( sig != 3 )\n            {\n              v2 = &old_INT;\n              if ( sig != 2 )\n              {\n                v2 = 0LL;\n                if ( sig == 15 )\n                  v2 = &old_TERM;\n              }\n            }\n          }\n        }\n      }\n      terminal_goto_xy(0, screenheight - 1);\n      terminal_clear_to_eol();\n      fflush((FILE *)stdout);\n      terminal_unprep_terminal();\n      sigaction(sig, v2, 0LL);\n      sigemptyset(&v5);\n      sigemptyset((sigset_t *)&retaddr);\n      sigaddset((sigset_t *)&retaddr, sig);\n      sigprocmask(1, (const sigset_t *)&retaddr, &v5);\n      v3 = getpid();\n      kill(v3, sig);\n      terminal_prep_terminal();\n      sigaction(sig, &info_signal_handler, v2);\n      reset_info_window_sizes();\n    }\n    else if ( ((1LL << sig) & 0x10000400) != 0 )\n    {\n      v1 = &old_WINCH;\n      if ( sig != 28 )\n      {\n        v1 = &old_USR1;\n        if ( sig != 10 )\n          v1 = (struct sigaction *)((1LL << sig) & 0x70800C);\n      }\n      sigaction(sig, &info_signal_handler, v1);\n      if ( sigwinch_block_count )\n        abort();\n      sigwinch_block_count = 1;\n      reset_info_window_sizes();\n      --sigwinch_block_count;\n      sigemptyset(&v5);\n      sigemptyset((sigset_t *)&retaddr);\n      sigaddset((sigset_t *)&retaddr, sig);\n      sigprocmask(1, (const sigset_t *)&retaddr, &v5);\n    }\n  }\n}\n",
    "source_code": "\nstatic void\ninfo_signal_proc (int sig)\n{\n  signal_info *old_signal_handler = NULL;\n\n#if !defined (HAVE_SIGACTION)\n  /* best effort: first increment this counter and later block signals */\n  if (term_conf_busy)\n    return;\n  term_conf_busy++;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_BLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n  switch (sig)\n    {\n#if defined (SIGTSTP)\n    case SIGTSTP:\n    case SIGTTOU:\n    case SIGTTIN:\n#endif\n#if defined (SIGQUIT)\n    case SIGQUIT:\n#endif\n#if defined (SIGINT)\n    case SIGINT:\n#endif\n#if defined (SIGTERM)\n    case SIGTERM:\n#endif\n      {\n#if defined (SIGTSTP)\n        if (sig == SIGTSTP)\n          old_signal_handler = &old_TSTP;\n        if (sig == SIGTTOU)\n          old_signal_handler = &old_TTOU;\n        if (sig == SIGTTIN)\n          old_signal_handler = &old_TTIN;\n#endif /* SIGTSTP */\n#if defined (SIGQUIT)\n        if (sig == SIGQUIT)\n          old_signal_handler = &old_QUIT;\n#endif /* SIGQUIT */\n#if defined (SIGINT)\n        if (sig == SIGINT)\n          old_signal_handler = &old_INT;\n#endif /* SIGINT */\n#if defined (SIGTERM)\n        if (sig == SIGTERM)\n          old_signal_handler = &old_TERM;\n#endif /* SIGTERM */\n\n        /* For stop signals, restore the terminal IO, leave the cursor\n           at the bottom of the window, and stop us. */\n        terminal_goto_xy (0, screenheight - 1);\n        terminal_clear_to_eol ();\n        fflush (stdout);\n        terminal_unprep_terminal ();\n\trestore_termsig (sig, old_signal_handler);\n\tUNBLOCK_SIGNAL (sig);\n\tkill (getpid (), sig);\n\n        /* The program is returning now.  Restore our signal handler,\n           turn on terminal handling, redraw the screen, and place the\n           cursor where it belongs. */\n        terminal_prep_terminal ();\n\tset_termsig (sig, old_signal_handler);\n\t/* window size might be changed while sleeping */\n\treset_info_window_sizes ();\n      }\n      break;\n\n#if defined (SIGWINCH) || defined (SIGUSR1)\n#ifdef SIGWINCH\n    case SIGWINCH:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n      {\n\t/* Turn off terminal IO, tell our parent that the window has changed,\n\t   then reinitialize the terminal and rebuild our windows. */\n#ifdef SIGWINCH\n\tif (sig == SIGWINCH)\n\t  old_signal_handler = &old_WINCH;\n#endif\n#ifdef SIGUSR1\n\tif (sig == SIGUSR1)\n\t  old_signal_handler = &old_USR1;\n#endif\n\n        /* This seems risky: what if we receive a (real) signal before\n           the next line is reached? */\n#if 0\n\trestore_termsig (sig, old_signal_handler);\n\tkill (getpid (), sig);\n#endif\n\n\t/* After our old signal handler returns... */\n\tset_termsig (sig, old_signal_handler); /* needless? */\n\n        if (sigwinch_block_count != 0)\n          abort ();\n\n        /* Avoid any of the code unblocking the signal too early.  This\n           should set the variable to 1 because we shouldn't be here if\n           sigwinch_block_count > 0. */\n        sigwinch_block_count++;\n\n\treset_info_window_sizes ();\n\n        sigwinch_block_count--;\n        /* Don't unblock the signal until after we've finished. */\n\tUNBLOCK_SIGNAL (sig);\n      }\n      break;\n#endif /* SIGWINCH || SIGUSR1 */\n    }\n#if !defined (HAVE_SIGACTION)\n  /* at this time it is safer to perform unblock after decrement */\n  term_conf_busy--;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_UNBLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n}",
    "comment": "Handles various signals by restoring terminal settings, blocking signals during critical sections, and managing terminal window size changes.",
    "hext5_sum": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
    "bint5_sum": "Handles various signals by managing actions like SIGINT , SIGTSTP , SIGTTIN , and SIGTTOU while ensuring proper cleanup of previous signals .\n",
    "cpbcs_sum": "Handles SIGINT or SIGTERM signal delivery by managing terminal settings and suspending the actions based on the exit status.\n",
    "misum_sum": "Handles various signals, updates signal actions and manages signal traps for various signals, and manages child trap states accordingly.\n",
    "decom_sum": "Handles specific signals by temporarily altering handlers, triggering related cleanup routines, delivering the signal to itself, then restoring original signal actions.",
    "cfg_sum": "Handles specific signals by installing appropriate handlers, adjusting signal masks, triggering the signal to self, and ensuring stack integrity or aborting on failure.",
    "work_score": {
        "hext5": {
            "summary": "note: a response of 425 is not mentioned as a possible response to the pasv command in rfc959. however, it has been blessed as a legitimate response by jon postel in a telephone conversation with rick adams on 25 jan 89.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary discusses FTP PASV command responses, RFC959, and historical commentary from Jon Postel, which are entirely unrelated to the signal processing logic, terminal handling, and conditional compilation in the provided source code. None of the claims target or align with the code semantics, resulting in no accurate matches.",
                "The summary consists entirely of historical information about FTP PASV command responses, which is unrelated to the source code. It contains no claims about the implementation, purpose, or behavior of the function, so none of the Critical Semantic Units are addressed.",
                "The summary contains information entirely unrelated to the given source code, focusing on FTP PASV command responses and historical anecdotes rather than the signal handling logic implemented in the code. All claims are NOISE, overwhelming the content with no accurate alignment to the source, providing zero insight into the actual functionality."
            ]
        },
        "bint5": {
            "summary": "Handles various signals by managing actions like SIGINT , SIGTSTP , SIGTTIN , and SIGTTOU while ensuring proper cleanup of previous signals .\n",
            "score": [
                0.6,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function handles signals such as SIGINT, SIGTSTP, SIGTTIN, and SIGTTOU, which matches the source code. However, it inaccurately describes the behavior as 'ensuring proper cleanup of previous signals,' which is vague and partially misleading since the code restores specific old handlers and performs terminal I/O cleanup, not a generalized cleanup of previous signals. The claim about handling signals is accurate, but the cleanup description reduces precision.",
                "The summary captures the primary purpose broadly, mentioning handling of several signals and cleanup of previous signal handlers, which aligns with the source code's main intent. However, it misses many secondary details, such as specific handling for SIGQUIT, SIGTERM, SIGWINCH, SIGUSR1, terminal state changes, window size resets, signal blocking/unblocking logic, and the conditions under HAVE_SIGACTION or HAVE_SIGPROCMASK. The coverage is incomplete due to omission of these behaviors and edge cases.",
                "The summary accurately identifies that the function handles SIGINT, SIGTSTP, SIGTTIN, and SIGTTOU, which matches the source code. However, the stated purpose of 'ensuring proper cleanup of previous signals' is vague and low-info, not specifying the detailed terminal and signal state restoration logic present in the code. There are no contradictory claims (no FATAL), but the gain is low as the summary omits handling of other signals, conditional compilation aspects, and specific sequence of terminal operations, yielding minimal insight."
            ]
        },
        "cpbcs": {
            "summary": "Handles SIGINT or SIGTERM signal delivery by managing terminal settings and suspending the actions based on the exit status.\n",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary states that SIGINT or SIGTERM handling involves managing terminal settings and suspending actions based on exit status. While the source code does show adjustments to terminal settings when handling SIGINT and SIGTERM, there is no indication of suspension based on exit status; instead, the code restores and resets terminal state, reassigns signal handlers, and may stop or terminate the process. The claim about exit status is inaccurate, reducing overall accuracy.",
                "The summary correctly notes that the function handles SIGINT and SIGTERM and adjusts terminal settings, which aligns with the code's restoration and preparation of the terminal around signal handling. However, it omits other handled signals (SIGTSTP, SIGTTOU, SIGTTIN, SIGQUIT, SIGWINCH, SIGUSR1) and does not mention key secondary behaviors like blocking/unblocking signals, resetting window sizes, or the actual process kill and restoration steps. The claim about suspending actions based on exit status is unsupported and inaccurate, reducing coverage and accuracy.",
                "The summary makes a specific claim about handling SIGINT or SIGTERM and suspending actions based on exit status, but the source code does not reference exit status at all. The signal handling is focused on restoring and reinitializing terminal settings, managing blocking/unblocking signals, and redrawing the screen. The mention of exit status is inaccurate and targets key behavior incorrectly, making it a FATAL error. This significantly reduces reliability despite correctly noting SIGINT and SIGTERM handling."
            ]
        },
        "misum": {
            "summary": "Handles various signals, updates signal actions and manages signal traps for various signals, and manages child trap states accordingly.\n",
            "score": [
                0.3,
                0.5,
                0.5
            ],
            "reason": [
                "The summary broadly states that the function handles various signals and manages signal actions, which aligns with the source. However, it inaccurately mentions 'manages child trap states accordingly,' which is not supported by the code \u2014 there is no handling of child processes or traps for them. This introduces noise and reduces precision. While the first parts of the summary are safe, this false claim drops overall accuracy below majority correctness.",
                "The summary broadly states that the function handles various signals and updates actions, but it is vague and omits key secondary details present in the source code, such as specific behaviors for SIGTSTP, SIGINT, SIGTERM, SIGWINCH, and SIGUSR1, restoring and re-prepping the terminal, blocking/unblocking signals, and managing window size changes. There is no mention of conditions involving HAVE_SIGACTION or HAVE_SIGPROCMASK, nor the step-by-step handling logic. While the primary purpose of signal handling is captured, the coverage of critical semantics is minimal and lacks precision.",
                "The summary makes broad, generic claims about handling signals and updating traps, which are loosely accurate but lack specific details found in the source, such as distinct handling for SIGTSTP, SIGWINCH, and terminal state restoration. There are no outright contradictions (no FATAL errors), but the mention of 'manages child trap states' is unsupported and likely NOISE. The worst failure mode is NOISE, and the gain from accurate claims is low due to their generic nature."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 785280,
    "strip_function_name": "ENGINE_add",
    "strip_decompiled_code": "__int64 __fastcall ENGINE_add(const char **a1)\n{\n  const char **v1; // rbx\n  const char *v2; // rbp\n  int v3; // eax\n  bool v4; // al\n  __int64 v5; // rax\n  __int64 v6; // r8\n  unsigned int v7; // ebx\n\n  if ( a1 )\n  {\n    if ( !*a1 || !a1[1] )\n      ERR_put_error(38LL, 105LL, 108LL, \"eng_list.c\", 282LL);\n    CRYPTO_lock(9u, 30, (__int64)\"eng_list.c\", 0x11Cu);\n    v1 = (const char **)qword_3C0870;\n    if ( qword_3C0870 )\n    {\n      v2 = *a1;\n      do\n      {\n        v3 = strcmp(*v1, v2);\n        v1 = (const char **)v1[26];\n        v4 = v3 == 0;\n      }\n      while ( (unsigned __int8)v4 < (unsigned __int8)(v1 != 0LL) );\n      if ( v4 )\n      {\n        ERR_put_error(38LL, 120LL, 103LL, \"eng_list.c\", 116LL);\n        goto LABEL_12;\n      }\n      v5 = qword_3C0868;\n      if ( !qword_3C0868 || *(_QWORD *)(qword_3C0868 + 208) )\n      {\n        v6 = 141LL;\nLABEL_11:\n        ERR_put_error(38LL, 120LL, 110LL, \"eng_list.c\", v6);\nLABEL_12:\n        v7 = 0;\n        ERR_put_error(38LL, 105LL, 110LL, \"eng_list.c\", 288LL);\nLABEL_13:\n        CRYPTO_lock(0xAu, 30, (__int64)\"eng_list.c\", 0x123u);\n        return v7;\n      }\n      *(_QWORD *)(qword_3C0868 + 208) = a1;\n      a1[25] = (const char *)v5;\n    }\n    else\n    {\n      v6 = 125LL;\n      if ( qword_3C0868 )\n        goto LABEL_11;\n      a1[25] = 0LL;\n      qword_3C0870 = a1;\n      engine_cleanup_add_last((__int64)sub_BFED0);\n    }\n    ++*((_DWORD *)a1 + 43);\n    qword_3C0868 = (__int64)a1;\n    v7 = 1;\n    a1[26] = 0LL;\n    goto LABEL_13;\n  }\n  ERR_put_error(38LL, 105LL, 67LL, \"eng_list.c\", 276LL);\n  return 0LL;\n}\n",
    "function_name": "ENGINE_add",
    "decompiled_code": "__int64 __fastcall ENGINE_add(const char **a1)\n{\n  const char **v1; // rbx\n  const char *v2; // rbp\n  int v3; // eax\n  bool v4; // al\n  const char *v5; // rax\n  int v6; // r8d\n  unsigned int v7; // ebx\n\n  if ( a1 )\n  {\n    if ( !*a1 || !a1[1] )\n      ERR_put_error(0x26u, 105, 108, (__int64)\"eng_list.c\", 282);\n    CRYPTO_lock(9u, 30, (__int64)\"eng_list.c\", 0x11Cu);\n    v1 = (const char **)engine_list_head;\n    if ( engine_list_head )\n    {\n      v2 = *a1;\n      do\n      {\n        v3 = strcmp(*v1, v2);\n        v1 = (const char **)v1[26];\n        v4 = v3 == 0;\n      }\n      while ( (unsigned __int8)v4 < (unsigned __int8)(v1 != 0LL) );\n      if ( v4 )\n      {\n        ERR_put_error(0x26u, 120, 103, (__int64)\"eng_list.c\", 116);\n        goto LABEL_12;\n      }\n      v5 = (const char *)engine_list_tail;\n      if ( !engine_list_tail || *(_QWORD *)(engine_list_tail + 208) )\n      {\n        v6 = 141;\nLABEL_11:\n        ERR_put_error(0x26u, 120, 110, (__int64)\"eng_list.c\", v6);\nLABEL_12:\n        v7 = 0;\n        ERR_put_error(0x26u, 105, 110, (__int64)\"eng_list.c\", 288);\nLABEL_13:\n        CRYPTO_lock(0xAu, 30, (__int64)\"eng_list.c\", 0x123u);\n        return v7;\n      }\n      *(_QWORD *)(engine_list_tail + 208) = a1;\n      a1[25] = v5;\n    }\n    else\n    {\n      v6 = 125;\n      if ( engine_list_tail )\n        goto LABEL_11;\n      a1[25] = 0LL;\n      engine_list_head = a1;\n      engine_cleanup_add_last((__int64)engine_list_cleanup);\n    }\n    ++*((_DWORD *)a1 + 43);\n    engine_list_tail = (__int64)a1;\n    v7 = 1;\n    a1[26] = 0LL;\n    goto LABEL_13;\n  }\n  ERR_put_error(0x26u, 105, 67, (__int64)\"eng_list.c\", 276);\n  return 0LL;\n}\n",
    "source_code": "int ENGINE_add(ENGINE *e)\n\t{\n\tint to_return = 1;\n\tif(e == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\tif((e->id == NULL) || (e->name == NULL))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_ID_OR_NAME_MISSING);\n\t\t}\n\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\tif(!engine_list_add(e))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_INTERNAL_LIST_ERROR);\n\t\tto_return = 0;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\treturn to_return;\n\t}",
    "comment": "Adds an ENGINE structure to a list after validating its parameters and managing thread safety with locks.",
    "hext5_sum": "add arg to the end of the list of arguments 'cmd_argv' to pass to the command. len is the length of arg, including the terminating null. if this brings the list up to its maximum size, execute the command.",
    "bint5_sum": "Adds an ENGINE to a linked list , ensuring no duplicates and handling thread safety with locking mechanisms .\n",
    "cpbcs_sum": "Adds an XRECORD with a warnings in the context and associates it with the appropriate DSO validation context.\n",
    "misum_sum": "Adds a new `X509_VERIFY_PARAM` to the appropriate chain of an ENGINE structure, ensuring the list is valid and the mutex is properly locked.\n",
    "decom_sum": "Registers a new ENGINE structure into the global linked list with duplicate checks, error reporting, and thread-safe locking.",
    "cfg_sum": "Adds a new engine to the global engine list with validation, duplicate checks, lock protection, and error reporting on failure.",
    "work_score": {
        "hext5": {
            "summary": "add arg to the end of the list of arguments 'cmd_argv' to pass to the command. len is the length of arg, including the terminating null. if this brings the list up to its maximum size, execute the command.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes adding an argument to a command argument list and executing the command on reaching maximum size, which is unrelated to the source code. The source code handles adding an ENGINE object to an internal list, with checks for null parameters, missing IDs/names, locking, and error handling. None of the summary's claims match the source implementation, resulting in no accurate claims.",
                "The summary describes adding an argument to a list for a command execution, which is unrelated to the source code's function. The source code defines ENGINE_add, which adds an ENGINE to an internal list and includes null checks, missing ID/name handling, locking, and error reporting. The summary misses the primary purpose entirely and introduces noise about unrelated command arguments, so no claim aligns accurately with the actual implementation.",
                "The summary describes adding an argument to a 'cmd_argv' list and executing a command when full, which is entirely unrelated to the source code. The source code handles adding an ENGINE to an internal list with null checks, error handling, and locking. All claims in the summary are NOISE, with no accurate alignment to the source implementation, resulting in overwhelming irrelevance."
            ]
        },
        "bint5": {
            "summary": "Adds an ENGINE to a linked list , ensuring no duplicates and handling thread safety with locking mechanisms .\n",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims that the function ensures no duplicates, which is not supported by the source code; the code simply calls engine_list_add without explicit duplicate checks visible. The mention of thread safety with locking mechanisms matches the CRYPTO_w_lock/CRYPTO_w_unlock in the source, but the linked list reference is only implied by engine_list_add and not guaranteed. As a result, only part of the claims match the source, leading to mixed accuracy below 50%.",
                "The summary captures thread safety via locking, which aligns with CRYPTO_w_lock/unlock usage, and partially matches the primary purpose of adding an ENGINE to a list. However, it inaccurately claims duplicate prevention, which is not evident in the source code, and omits key secondary details such as null parameter checks, missing id/name validation, and error reporting. This results in an incomplete and partially incorrect representation of the code\u2019s behavior.",
                "The summary claims that the function ensures no duplicates, but the source code does not contain any explicit duplicate check, making this a FATAL inaccuracy about a key side effect. It correctly mentions locking for thread safety, which matches the CRYPTO_w_lock/CRYPTO_w_unlock calls, but this is a generic SAFE observation. The worst failure mode is FATAL because the inaccurate claim directly misrepresents the primary purpose and behavior of the code."
            ]
        },
        "cpbcs": {
            "summary": "Adds an XRECORD with a warnings in the context and associates it with the appropriate DSO validation context.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about adding an XRECORD and associating it with a DSO validation context do not match the source code, which deals with adding an ENGINE object, checking for null parameters or missing ID/name, and handling errors accordingly. None of the claims in the summary are accurate or relevant to the actual code semantics.",
                "The summary describes adding an XRECORD with a warning and associating it with a DSO validation context, which is entirely unrelated to the source code. The source code implements ENGINE_add, which adds an ENGINE object to an internal list with checks for null parameters, missing IDs or names, and internal list errors. The summary does not capture the primary purpose or any secondary details of the source code, making its claims inaccurate and irrelevant.",
                "The summary claims that the function adds an XRECORD with warnings and associates it with a DSO validation context, which is entirely unrelated to the source code. The source implements ENGINE_add, checks for null parameters and missing fields, locks a resource, adds the engine to a list, handles errors, and returns a status. The summary contains no accurate claims about this logic, making all claims NOISE with no factual alignment. The worst failure mode is overwhelming NOISE, leading to no positive gain."
            ]
        },
        "misum": {
            "summary": "Adds a new `X509_VERIFY_PARAM` to the appropriate chain of an ENGINE structure, ensuring the list is valid and the mutex is properly locked.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes adding an `X509_VERIFY_PARAM` to an ENGINE chain, which is not reflected in the source code. The actual function adds an ENGINE to a global list, performs null checks on its id and name, handles errors, and uses locking/unlocking. None of the specific claims in the summary match the implementation, resulting in all claims being inaccurate.",
                "The summary incorrectly claims that the function adds an `X509_VERIFY_PARAM` to an ENGINE, which contradicts the source code. The actual purpose is to add an ENGINE to a global list, handle null checks, missing ID/name, lock/unlock a mutex, and report errors. The summary misses the primary purpose and all secondary details, making it inaccurate.",
                "The summary makes a highly specific claim about adding an `X509_VERIFY_PARAM` to an ENGINE, which contradicts the source code\u2019s actual behavior of adding an ENGINE to a global list after checking for null and missing ID/name, and locking/unlocking around the list operation. This is a FATAL error affecting the primary purpose and key functionality, resulting in severe misrepresentation with no accurate claims to balance the impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585776048,
    "strip_function_name": "sub_FFFFFFFF8169C1B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8169C1B0(\n        __int64 a1,\n        __int64 a2,\n        _OWORD *a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int v12; // ebx\n  __int64 v15; // rax\n  __int64 *v16; // r15\n  __int64 *v17; // r13\n  __int64 *v18; // rax\n  __int64 v19; // rbx\n  __int64 *v20; // rax\n  __int64 v21; // rdi\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n\n  v12 = -22;\n  if ( a4 <= 0x80 )\n  {\n    v15 = sub_FFFFFFFF815D82F0(a1, a2);\n    if ( v15 )\n    {\n      v16 = *(__int64 **)(v15 + 600);\n      if ( v16 )\n      {\n        v17 = v16 + 1;\n        sub_FFFFFFFF817927D0(v16 + 29);\n        v18 = (__int64 *)v16[1];\n        v19 = (__int64)(v18 - 28);\n        if ( v16 + 1 == v18 )\n        {\nLABEL_12:\n          v12 = -99;\n          sub_FFFFFFFF81792890(v16 + 29);\n        }\n        else\n        {\n          while ( a4 != *(_DWORD *)(v19 + 16) || *(_OWORD *)v19 - *a3 != 0LL )\n          {\n            v20 = *(__int64 **)(v19 + 224);\n            v19 = (__int64)(v20 - 28);\n            if ( v17 == v20 )\n              goto LABEL_12;\n          }\n          _InterlockedIncrement((volatile signed __int32 *)(v19 + 28));\n          sub_FFFFFFFF81792890(v16 + 29);\n          v21 = v19;\n          v12 = 0;\n          sub_FFFFFFFF8169BCB0(v21, a2, a5, a6, a7, a8, v22, v23, a11, a12);\n          if ( (__int64 *)v16[1] == v17 )\n            sub_FFFFFFFF8169B590(*v16, 1, a5, a6, a7, a8, v24, v25, a11, a12);\n        }\n      }\n      else\n      {\n        return (unsigned int)-6;\n      }\n    }\n    else\n    {\n      return (unsigned int)-19;\n    }\n  }\n  return v12;\n}\n",
    "function_name": "inet6_addr_del",
    "decompiled_code": "__int64 __fastcall inet6_addr_del(\n        __int64 a1,\n        __int64 a2,\n        _OWORD *a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned int v12; // ebx\n  __int64 v15; // rax\n  __int64 v16; // r15\n  __int64 v17; // r13\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  int v20; // r9d\n  __int64 v21; // rax\n  volatile signed __int32 *v22; // rdx\n  __int64 v23; // rbx\n  __int64 v24; // rax\n  __int64 v25; // rdi\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n  double v28; // xmm4_8\n  double v29; // xmm5_8\n\n  v12 = -22;\n  if ( a4 <= 0x80 )\n  {\n    v15 = _dev_get_by_index(a1, a2);\n    if ( v15 )\n    {\n      v16 = *(_QWORD *)(v15 + 600);\n      if ( v16 )\n      {\n        v17 = v16 + 8;\n        raw_read_lock_bh((volatile signed __int32 *)(v16 + 232));\n        v21 = *(_QWORD *)(v16 + 8);\n        v22 = (volatile signed __int32 *)(v16 + 232);\n        v23 = v21 - 224;\n        if ( v16 + 8 == v21 )\n        {\nLABEL_12:\n          v12 = -99;\n          raw_read_unlock_bh((volatile signed __int32 *)(v16 + 232), a2, (__int64)v22, v18, v19, v20);\n        }\n        else\n        {\n          while ( 1 )\n          {\n            if ( a4 == *(_DWORD *)(v23 + 16) )\n            {\n              v18 = *(_QWORD *)(v23 + 8) ^ *((_QWORD *)a3 + 1) | *(_QWORD *)v23 ^ *(_QWORD *)a3;\n              if ( *(_OWORD *)v23 - *a3 == 0LL )\n                break;\n            }\n            v24 = *(_QWORD *)(v23 + 224);\n            v23 = v24 - 224;\n            if ( v17 == v24 )\n              goto LABEL_12;\n          }\n          _InterlockedIncrement((volatile signed __int32 *)(v23 + 28));\n          raw_read_unlock_bh(v22, a2, (__int64)v22, v18, v19, v20);\n          v25 = v23;\n          v12 = 0;\n          ipv6_del_addr(v25, a2, a5, a6, a7, a8, v26, v27, a11, a12);\n          if ( *(_QWORD *)(v16 + 8) == v17 )\n            addrconf_ifdown(*(_QWORD *)v16, 1u, a5, a6, a7, a8, v28, v29, a11, a12);\n        }\n      }\n      else\n      {\n        return (unsigned int)-6;\n      }\n    }\n    else\n    {\n      return (unsigned int)-19;\n    }\n  }\n  return v12;\n}\n",
    "source_code": "\nstatic int inet6_addr_del(struct net *net, int ifindex, const struct in6_addr *pfx,\n\t\t\t  unsigned int plen)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\n\tif (plen > 128)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif ((idev = __in6_dev_get(dev)) == NULL)\n\t\treturn -ENXIO;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->prefix_len == plen &&\n\t\t    ipv6_addr_equal(pfx, &ifp->addr)) {\n\t\t\tin6_ifa_hold(ifp);\n\t\t\tread_unlock_bh(&idev->lock);\n\n\t\t\tipv6_del_addr(ifp);\n\n\t\t\t/* If the last address is deleted administratively,\n\t\t\t   disable IPv6 on this interface.\n\t\t\t */\n\t\t\tif (list_empty(&idev->addr_list))\n\t\t\t\taddrconf_ifdown(idev->dev, 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock_bh(&idev->lock);\n\treturn -EADDRNOTAVAIL;\n}",
    "comment": "Removes an IPv6 address from a network interface and disables IPv6 if it becomes the last address.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Retrieves and displays IPv6 address label information based on the provided socket buffer and interface index from the specified network device .\n",
    "cpbcs_sum": "Removes specified multicast addresses from the multicast routing table if it matches the specified network interface index and address.\n",
    "misum_sum": "Removes specified IPv6 address from the routing table if it is not currently registered and membership devices from the network stack.\n",
    "decom_sum": "Searches a linked structure for an entry matching a given key and 128-bit value, then updates counters and triggers parameterized processing callbacks.",
    "cfg_sum": "Searches for a matching entry by ID and 128\u2011bit key, updates its state, executes processing routines with provided parameters, and returns a status code.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only a mathematical expression unrelated to the source code's IPv6 address removal logic. None of its content matches or describes the implementation in the provided C function, making all claims inaccurate.",
                "The summary contains mathematical notation unrelated to the source code's functionality. It does not mention the primary purpose of deleting an IPv6 address from an interface, nor any secondary details such as input validation, error codes, or the disabling of IPv6 when the last address is removed. All claims are inaccurate and provide no coverage of the code's semantics.",
                "The summary contains only a mathematical expression unrelated to the source code\u2019s function, which concerns IPv6 address deletion logic. All extracted claims are NOISE, with no accurate or aligned information about the code\u2019s purpose, inputs, or outputs. This results in zero net benefit and high irrelevance."
            ]
        },
        "bint5": {
            "summary": "Retrieves and displays IPv6 address label information based on the provided socket buffer and interface index from the specified network device .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves and displays IPv6 address label information from a socket buffer and interface index, but the source code shows it deletes a specified IPv6 address from an interface, handling errors for invalid prefix length, missing device, or address not found. None of the key actions in the summary align with the actual code, so all claims are inaccurate.",
                "The summary claims the function retrieves and displays IPv6 address label information based on a socket buffer and interface index, but the source code instead deletes a specific IPv6 address from a network interface given a prefix and length, handling errors for invalid prefix length, missing device, or missing IPv6 device, and possibly disabling IPv6 if no addresses remain. The summary\u2019s description is entirely unrelated to the actual primary purpose, missing all critical semantic units and introducing incorrect context and inputs.",
                "The summary contains a single claim suggesting the function retrieves and displays IPv6 address label information from a socket buffer and interface index. This is inaccurate because the source code instead deletes an IPv6 address from a network interface based on a prefix and length, without handling display or label information; it operates on existing device structures, not socket buffers. This is a FATAL error targeting the primary purpose, resulting in high negative impact and no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Removes specified multicast addresses from the multicast routing table if it matches the specified network interface index and address.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function removes specified multicast addresses from the multicast routing table, but the source code shows it deletes IPv6 addresses from an interface's address list, not specifically multicast addresses or a multicast routing table. This is a direct semantic contradiction, meaning the claim is inaccurate relative to the code.",
                "The summary is inaccurate because the function actually deletes a specified IPv6 address (based on prefix length and match) from a network interface, handling several error conditions, and may disable IPv6 if the last address is removed. The mentioned removal of multicast addresses from a multicast routing table does not align with the source code's semantics, missing the primary purpose entirely.",
                "The summary claims the function removes specified multicast addresses from the multicast routing table, which is inaccurate. The source code actually deletes IPv6 interface addresses matching a given prefix length and address on a specific interface, and conditionally disables IPv6. The claim targets core semantics (primary purpose) but misstates address type and affected data structures, making it a FATAL error. There are no accurate claims providing useful specifics, resulting in high negative impact."
            ]
        },
        "misum": {
            "summary": "Removes specified IPv6 address from the routing table if it is not currently registered and membership devices from the network stack.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as removing an IPv6 address from the routing table if it is not registered, whereas in the source code the function searches for a matching registered IPv6 address on a specific interface and removes it only if found, returning errors otherwise. The claim about removing 'membership devices from the network stack' does not align with the code, which instead may disable IPv6 on the interface if no addresses remain. Most of the claims are inaccurate and do not reflect the actual implementation, resulting in low alignment.",
                "The summary incorrectly describes the function as removing an IPv6 address from the routing table and involving membership devices, which is not reflected in the source code. The actual purpose is to remove a matching IPv6 address from a network interface\u2019s address list, with specific error handling for invalid prefix lengths, missing devices, and missing addresses. The primary purpose is misrepresented and key secondary behaviors such as disabling IPv6 when the last address is removed are completely missed.",
                "The summary incorrectly states that the function removes an IPv6 address from the routing table and does so if it is not registered, which contradicts the source. The source clearly removes an address from an interface only if it matches and is currently present, and manages interface-level IPv6 state, not routing tables or 'membership devices'. These are FATAL inaccuracies targeting the primary function purpose. No accurate, high-gain details are provided, leading to high negative impact."
            ]
        }
    }
}
{
    "project_name": "a2ps",
    "function_addr": 4225184,
    "strip_function_name": "sub_4078A0",
    "strip_decompiled_code": "const char *__fastcall sub_4078A0(const char *src)\n{\n  size_t v1; // rax\n  size_t v2; // rdx\n  unsigned __int64 v3; // rax\n  void *v4; // rsp\n  void *v5; // rsp\n  void *v6; // r13\n  char *v7; // rbx\n  const char **v8; // rax\n  char *i; // r12\n  const char **v10; // rax\n  char *v11; // rax\n  char *v12; // rbx\n  const char *v13; // rax\n  const char *v14; // rbx\n  const char **v15; // r12\n  char *v16; // rax\n  const char *v17; // rdi\n  char v19[15]; // [rsp+0h] [rbp-20h] BYREF\n\n  v1 = strlen(src);\n  v2 = v1 + 1;\n  v3 = (v1 + 31) & 0xFFFFFFFFFFFFFFF0LL;\n  v4 = alloca(v3);\n  v5 = alloca(v3);\n  memcpy(v19, src, v2);\n  v6 = (void *)sub_4343F0(\"Ancestors\", 2LL, 1LL, 2LL, j__fputs, 0LL);\n  v7 = strtok(v19, \",;+\");\n  sub_434A00(v6, v7);\n  v8 = (const char **)sub_406920(v7);\n  for ( i = stpcpy(v19, *v8); ; i = stpcpy(i + 1, *v10) )\n  {\n    v11 = strtok(0LL, \",;+\");\n    v12 = v11;\n    if ( !v11 )\n      break;\n    sub_434A00(v6, v11);\n    v10 = (const char **)sub_406920(v12);\n    *i = 44;\n  }\n  *i = 0;\n  v13 = (const char *)sub_438B00(v19);\n  v14 = v13;\n  if ( (dword_6584C8 & 4) != 0 )\n    fprintf(stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", v13);\n  v15 = (const char **)sub_4065D0((__int64)v14);\n  v16 = strdup(v14);\n  v17 = v15[8];\n  *v15 = v16;\n  sub_434B70(v17, v6);\n  sub_4344C0(v6);\n  sub_4069F0(v15);\n  return v14;\n}\n",
    "function_name": "style_sheet_mixed_new",
    "decompiled_code": "char *__fastcall style_sheet_mixed_new(\n        const char *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        char a7)\n{\n  da_growth v7; // r13d\n  void (*v8)(const void *, FILE *); // r15\n  size_t v9; // rax\n  size_t v10; // rdx\n  unsigned __int64 v11; // rax\n  void *v12; // rsp\n  void *v13; // rsp\n  darray *v14; // r13\n  char *v15; // rbx\n  style_sheet *style_sheet; // rax\n  char *i; // r12\n  style_sheet *v18; // rax\n  char *v19; // rax\n  char *v20; // rbx\n  char *v21; // rax\n  char *v22; // rbx\n  style_sheet *v23; // r12\n  _UNKNOWN *retaddr; // [rsp+28h] [rbp+8h] BYREF\n\n  v9 = strlen(a1);\n  v10 = v9 + 1;\n  v11 = (v9 + 31) & 0xFFFFFFFFFFFFFFF0LL;\n  v12 = alloca(v11);\n  v13 = alloca(v11);\n  memcpy(&a7, a1, v10);\n  v14 = da_new(a1, (size_t)&a7, v7, (size_t)&retaddr, v8, 0LL);\n  v15 = strtok(&a7, &byte_43B750[7918]);\n  da_append((darray *)v15, v15);\n  style_sheet = get_style_sheet(v15);\n  for ( i = stpcpy(&a7, style_sheet->key); ; i = stpcpy(i + 1, v18->key) )\n  {\n    v19 = strtok(0LL, &byte_43B750[7918]);\n    v20 = v19;\n    if ( !v19 )\n      break;\n    da_append((darray *)v19, v19);\n    v18 = get_style_sheet(v20);\n    *i = 44;\n  }\n  *i = 0;\n  v21 = xstrdup(0LL);\n  v22 = v21;\n  if ( (msg_verbosity & 4) != 0 )\n    fprintf((FILE *)stderr, &byte_43B750[9696], v21);\n  v23 = new_style_sheet((size_t)v22);\n  v23->key = strdup(v22);\n  da_concat((darray *)v22, (darray *)&retaddr);\n  da_erase(v14);\n  style_sheet_finalize(v23);\n  return v22;\n}\n",
    "source_code": "\nstatic char *\nstyle_sheet_mixed_new (const uchar * ancestors)\n{\n  struct style_sheet *sheet, *ancestor;\n  char *ancestor_key, *key, *cp;\n  char *ancestors_keys;\n  struct darray *ancestors_array;\n\n  /* It cannot be longer than ancestors_keys. */\n  key = ALLOCA (char, ustrlen (ancestors) + 1);\n  astrcpy (ancestors_keys, ancestors);\n\n  /* Create the darray of ancestors keys, and build the final key. */\n  ancestors_array = ancestors_new ();\n  ancestor_key = strtok (ancestors_keys, MIXED_SHEET_SEP);\n  da_append (ancestors_array, ancestor_key);\n  ancestor = get_style_sheet (ancestor_key);\n  cp = stpcpy (key, ancestor->key);\n\n  while ((ancestor_key = strtok (NULL, MIXED_SHEET_SEP)))\n    {\n      da_append (ancestors_array, ancestor_key);\n      ancestor = get_style_sheet (ancestor_key);\n      *cp++ =',';\n      cp = stpcpy (cp, ancestor->key);\n    }\n  *cp = '\\0';\n  key = xstrdup (key);\n\n  /* Create the style sheet. */\n  message (msg_sheet,\n\t   (stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", key));\n  /* Its name is its key. */\n  sheet = new_style_sheet ((uchar *) key);\n  sheet->key = strdup (key);\n  da_concat (sheet->ancestors, ancestors_array);\n  da_erase (ancestors_array);\n  style_sheet_finalize (sheet);\n\n  return key;\n}",
    "comment": "Creates a new style sheet by concatenating keys from ancestor style sheets, storing them in a darray, and finalizing the new sheet.",
    "hext5_sum": "set up the sizes and contents of the elf dynamic sections.",
    "bint5_sum": "Constructs a relative path from a given file path by traversing up its directory hierarchy until a different file system is detected .\n",
    "cpbcs_sum": "Constructs a mangled filename by concatenating a template string in /proc/irq and appending a dot suffix to a specified file.\n",
    "misum_sum": "Generates a shell message for a given message by concatenating a suffix, then returns the resulting digest string.\n",
    "decom_sum": "Parses a comma/semicolon/plus-separated list of style sheet names, registers them as \u201cAncestors,\u201d merges them, and creates a mixed style sheet entry.",
    "cfg_sum": "Parses a comma- or symbol-separated list of style sheet names, builds a combined style sheet object, logs creation if enabled, and returns its name.",
    "work_score": {
        "hext5": {
            "summary": "set up the sizes and contents of the elf dynamic sections.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes setting up sizes and contents of ELF dynamic sections, which is unrelated to the source code that creates a mixed style sheet by concatenating ancestor keys and initializing a style sheet structure. This is a clear semantic mismatch, making the claim inaccurate.",
                "The summary describes configuring ELF dynamic sections, which is unrelated to the source code's actual functionality of creating a mixed style sheet by combining ancestor style sheet keys and building a new sheet object. This is a clear semantic mismatch and misses the primary purpose entirely.",
                "The summary claims the function configures ELF dynamic sections, which is unrelated to the actual code. The source code constructs a mixed style sheet key from ancestor style sheets, manages dynamic arrays, and finalizes a style sheet object. This mismatch is a FATAL error affecting the primary purpose of the function, with no accurate claims to provide value."
            ]
        },
        "bint5": {
            "summary": "Constructs a relative path from a given file path by traversing up its directory hierarchy until a different file system is detected .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes constructing a relative path by traversing a directory hierarchy and detecting a different file system, which is entirely unrelated to the source code. The source function builds a mixed style sheet key from ancestor style sheets, manipulating strings and arrays; no file path, directory traversal, or file system detection occurs. All claims in the summary are inaccurate, resulting in 0% accuracy.",
                "The summary describes building a relative path by traversing directories until a different file system is detected, which is completely unrelated to the source code's purpose of creating a mixed style sheet key from ancestor style sheets and initializing a new style sheet object. It misses the primary purpose and all secondary details, and the claim is inaccurate in targeting unrelated functionality.",
                "The summary describes constructing a relative path by traversing directories until a different file system is detected, which is entirely unrelated to the source code. The source code creates a mixed style sheet key from ancestor style sheets, handling string manipulation and data arrays. This mismatch is a complete semantic contradiction about the primary purpose (FATAL), resulting in high negative impact and no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Constructs a mangled filename by concatenating a template string in /proc/irq and appending a dot suffix to a specified file.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function constructs a filename using a template string in /proc/irq and appends a suffix, which is entirely unrelated to the source code. The provided source code builds a 'mixed style sheet' key from ancestor sheets, with no reference to filenames, /proc/irq, or suffix operations. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary incorrectly describes creating a mangled filename in /proc/irq with a dot suffix, which does not align with the source code. The function constructs a combined style sheet key from ancestor sheet keys and creates a new mixed style sheet object, with no relation to filenames, /proc/irq, or dot suffixes. This misses the primary purpose and all critical semantic details of the source code.",
                "The summary's claims about constructing a mangled filename in /proc/irq with a dot suffix are entirely unrelated to the source code, which builds a mixed style sheet key from ancestor style sheets. This is pure NOISE targeting incorrect semantics, with no accurate claims about the function's actual purpose, key I/O, or side effects. The worst failure mode is FATAL because it misidentifies the primary purpose."
            ]
        },
        "misum": {
            "summary": "Generates a shell message for a given message by concatenating a suffix, then returns the resulting digest string.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function generates a shell message by concatenating a suffix and returns a digest string, which is inaccurate. The source code actually constructs a mixed style sheet key from ancestor keys, logs a creation message, creates and finalizes a style sheet, and returns the key. None of the described behavior in the summary matches the source code\u2019s purpose or implementation, resulting in 0% accurate claims.",
                "The summary is entirely inaccurate. It describes generating a shell message by concatenating a suffix and returning a digest string, which does not align with the source code\u2019s primary purpose of creating a mixed style sheet key from ancestor style sheets, logging its creation, and returning the key. No details from the SOURCE_CODE are correctly reflected, missing both the primary purpose and all secondary behaviors such as ancestor key parsing, sheet creation, and array manipulation.",
                "The summary is entirely inaccurate: it describes generating a shell message by concatenating a suffix and returning a digest string, which is unrelated to the actual function. The source code creates a mixed style sheet key from ancestor keys, logs a creation message, builds a style_sheet structure, and returns the key. This is a FATAL error affecting the primary purpose and I/O, resulting in zero alignment with the source implementation."
            ]
        }
    }
}
{
    "project_name": "libredwg",
    "function_addr": 7274112,
    "strip_function_name": "dwg_find_tablehandle",
    "strip_decompiled_code": "__int64 __fastcall dwg_find_tablehandle(_QWORD *a1, const char *a2, const char *a3)\n{\n  __int64 v4; // r14\n  __int64 result; // rax\n  __int64 v6; // rax\n\n  if ( a3 == 0LL || a2 == 0LL || !a1 )\n    return 0LL;\n  v4 = dwg_ctrl_table(a1, a3);\n  if ( strcmp(a3, \"LTYPE\") )\n    goto LABEL_11;\n  if ( strcmp(a2, \"BYLAYER\") && strcmp(a2, \"ByLayer\") )\n  {\n    if ( !strcmp(a2, \"BYBLOCK\") || !strcmp(a2, \"ByBlock\") )\n    {\n      result = a1[315];\n      if ( result )\n        return result;\n    }\n    else if ( !strcmp(a2, \"CONTINUOUS\") || !strcmp(a2, \"Continuous\") )\n    {\n      result = a1[316];\n      if ( result )\n        return result;\n    }\nLABEL_11:\n    if ( v4 )\n      goto LABEL_12;\nLABEL_18:\n    if ( (unsigned int)dword_1110710 <= 2 )\n      return 0LL;\nLABEL_19:\n    __fprintf_chk();\n    return 0LL;\n  }\n  result = a1[314];\n  if ( result )\n    return result;\n  if ( !v4 )\n    goto LABEL_18;\nLABEL_12:\n  v6 = dwg_resolve_handle((__int64)a1, *(_QWORD *)(v4 + 32));\n  if ( !v6 )\n  {\n    if ( (unsigned int)dword_1110710 <= 2 )\n      return 0LL;\n    goto LABEL_19;\n  }\n  if ( *(_DWORD *)(v6 + 16) == 42 )\n    return dwg_find_dicthandle_objname((__int64)a1, v4, a2);\n  if ( (unsigned int)dwg_obj_is_control(v6) )\n  {\n    dwg_dynapi_entity_value();\n    return 0LL;\n  }\n  if ( !dword_1110710 )\n    return 0LL;\n  fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n  if ( dword_1110710 )\n    __fprintf_chk();\n  fputc(10, stderr);\n  return 0LL;\n}\n",
    "function_name": "dwg_find_tablehandle",
    "decompiled_code": "BITCODE_H __fastcall dwg_find_tablehandle(Dwg_Data_2 *dwg, const char *name, const char *table)\n{\n  BITCODE_H v5; // r14\n  BITCODE_H result; // rax\n  Dwg_Object *v7; // rax\n  Dwg_Object *v8; // r12\n  const char *v9; // rcx\n  const char *v10; // rdx\n  Dwg_Entity_UNUSED *UNUSED; // r13\n  __int64 v12; // rdx\n  unsigned int v13; // r15d\n  __int64 v14; // rax\n  Dwg_Object *v15; // rax\n  Dwg_Object *v16; // r12\n  Dwg_Object_Entity *entity; // rax\n  Dwg_Entity_UNUSED *v18; // rdi\n  char v19; // r14\n  char *v20; // r12\n  int v21; // r14d\n  Dwg_Object *v22; // [rsp+90h] [rbp+18h]\n  __int64 v23; // [rsp+98h] [rbp+20h] BYREF\n  __int64 v24; // [rsp+A0h] [rbp+28h] BYREF\n  char *v25; // [rsp+A8h] [rbp+30h] BYREF\n  unsigned __int64 v26; // [rsp+B0h] [rbp+38h]\n\n  v26 = __readfsqword(0x28u);\n  LODWORD(v23) = 0;\n  v24 = 0LL;\n  if ( table == 0LL || name == 0LL || !dwg )\n    return 0LL;\n  v5 = dwg_ctrl_table(dwg, table);\n  if ( strcmp(table, \"LTYPE\") )\n  {\nLABEL_11:\n    if ( v5 )\n      goto LABEL_12;\nLABEL_18:\n    v9 = table;\n    v10 = \"dwg_find_tablehandle: Empty header_vars table %s\\n\";\n    if ( loglevel_7 <= 2 )\n      return 0LL;\nLABEL_19:\n    ((void (__fastcall *)(struct _IO_FILE *, __int64, const char *, const char *))__fprintf_chk)(stderr, 1LL, v10, v9);\n    return 0LL;\n  }\n  if ( strcmp(name, \"BYLAYER\") && strcmp(name, \"ByLayer\") )\n  {\n    if ( !strcmp(name, \"BYBLOCK\") || !strcmp(name, \"ByBlock\") )\n    {\n      result = dwg->header_vars.LTYPE_BYBLOCK;\n      if ( result )\n        return result;\n    }\n    else if ( !strcmp(name, \"CONTINUOUS\") || !strcmp(name, \"Continuous\") )\n    {\n      result = dwg->header_vars.LTYPE_CONTINUOUS;\n      if ( result )\n        return result;\n    }\n    goto LABEL_11;\n  }\n  result = dwg->header_vars.LTYPE_BYLAYER;\n  if ( result )\n    return result;\n  if ( !v5 )\n    goto LABEL_18;\nLABEL_12:\n  v7 = dwg_resolve_handle(dwg, v5->absolute_ref);\n  v8 = v7;\n  if ( !v7 )\n  {\n    if ( loglevel_7 <= 2 )\n      return 0LL;\n    v9 = table;\n    v10 = \"dwg_find_tablehandle: Could not resolve table %s\\n\";\n    goto LABEL_19;\n  }\n  if ( v7->type == 42 )\n    return dwg_find_dicthandle_objname(dwg, v5, name);\n  if ( !dwg_obj_is_control(v7) )\n  {\n    if ( loglevel_7 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( loglevel_7 )\n        ((void (*)(struct _IO_FILE *, __int64, const char *, ...))__fprintf_chk)(\n          stderr,\n          1LL,\n          \"dwg_find_tablehandle: Could not resolve CONTROL object %s for table %s\",\n          v8->name,\n          table);\n      fputc(10, stderr);\n      return 0LL;\n    }\n    return 0LL;\n  }\n  UNUSED = v8->tio.entity->tio.UNUSED;\n  ((void (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, __int64 *, _QWORD))dwg_dynapi_entity_value)(\n    UNUSED,\n    v8->name,\n    \"num_entries\",\n    &v23,\n    0LL);\n  if ( !(_DWORD)v23 )\n    return 0LL;\n  ((void (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, __int64 *, _QWORD))dwg_dynapi_entity_value)(\n    UNUSED,\n    v8->name,\n    \"entries\",\n    &v24,\n    0LL);\n  v12 = v24;\n  if ( !v24 || !(_DWORD)v23 )\n    return 0LL;\n  v22 = v8;\n  v13 = 0;\n  while ( 1 )\n  {\n    HIDWORD(v23) = 0;\n    v14 = *(_QWORD *)(v12 + 8LL * v13);\n    if ( v14 )\n    {\n      v15 = dwg_resolve_handle(dwg, *(_QWORD *)(v14 + 32));\n      v16 = v15;\n      if ( v15 )\n      {\n        entity = v15->tio.entity;\n        if ( entity )\n        {\n          v18 = entity->tio.UNUSED;\n          if ( v18 )\n          {\n            v19 = ((__int64 (__fastcall *)(Dwg_Entity_UNUSED *, char *, char *, char **, char *, _QWORD))dwg_dynapi_entity_utf8text)(\n                    v18,\n                    v16->name,\n                    \"name\",\n                    &v25,\n                    (char *)&v23 + 4,\n                    0LL);\n            if ( loglevel_7 > 3 )\n              ((void (__fastcall *)(struct _IO_FILE *, __int64, const char *, char *, char *, _QWORD))__fprintf_chk)(\n                stderr,\n                1LL,\n                \" %s.%s[%d] => %s.name: %s\\n\",\n                v22->name,\n                \"entries\",\n                v13);\n            if ( v19 )\n            {\n              v20 = v25;\n              if ( v25 )\n                break;\n            }\n          }\n        }\n      }\n    }\nLABEL_44:\n    if ( (unsigned int)v23 <= ++v13 )\n      return 0LL;\n    v12 = v24;\n  }\n  v21 = HIDWORD(v23);\n  if ( strcmp(name, v25) && strcasecmp(name, v20) )\n  {\n    if ( v21 )\n      free(v20);\n    goto LABEL_44;\n  }\n  if ( v21 )\n    free(v20);\n  return *(BITCODE_H *)(v24 + 8LL * v13);\n}\n",
    "source_code": "EXPORT BITCODE_H\ndwg_find_tablehandle (Dwg_Data *restrict dwg, const char *restrict name,\n                      const char *restrict table)\n{\n  BITCODE_BL i, num_entries = 0;\n  BITCODE_H ctrl = NULL, *hdlv = NULL;\n  Dwg_Object *obj;\n  Dwg_Object_APPID_CONTROL *_obj; // just some random generic type\n  Dwg_Header_Variables *vars = &dwg->header_vars;\n\n  if (!dwg || !name || !table)\n    return NULL;\n  // look for the _CONTROL table, and search for name in all entries\n  ctrl = dwg_ctrl_table (dwg, table);\n  if (strEQc (table, \"LTYPE\"))\n    {\n      if (strEQc (name, \"BYLAYER\") || strEQc (name, \"ByLayer\"))\n        {\n          if (vars->LTYPE_BYLAYER)\n            return vars->LTYPE_BYLAYER;\n        }\n      else if (strEQc (name, \"BYBLOCK\") || strEQc (name, \"ByBlock\"))\n        {\n          if (vars->LTYPE_BYBLOCK)\n            return vars->LTYPE_BYBLOCK;\n        }\n      else if (strEQc (name, \"CONTINUOUS\") || strEQc (name, \"Continuous\"))\n        {\n          if (vars->LTYPE_CONTINUOUS)\n            return vars->LTYPE_CONTINUOUS;\n        }\n    }\n  if (!ctrl)\n    { // TODO: silently search table_control. header_vars can be empty\n      LOG_TRACE (\"dwg_find_tablehandle: Empty header_vars table %s\\n\", table);\n      return NULL;\n    }\n  obj = dwg_resolve_handle (dwg, ctrl->absolute_ref);\n  if (!obj)\n    {\n      LOG_TRACE (\"dwg_find_tablehandle: Could not resolve table %s\\n\", table);\n      return NULL;\n    }\n  if (obj->type == DWG_TYPE_DICTIONARY)\n    return dwg_find_dicthandle_objname (dwg, ctrl, name);\n  if (!dwg_obj_is_control (obj))\n    {\n      LOG_ERROR (\"dwg_find_tablehandle: Could not resolve CONTROL object %s \"\n                 \"for table %s\",\n                 obj->name, table);\n      return NULL;\n    }\n  _obj = obj->tio.object->tio.APPID_CONTROL; // just random type\n  dwg_dynapi_entity_value (_obj, obj->name, \"num_entries\", &num_entries, NULL);\n  if (!num_entries)\n    return NULL;\n  dwg_dynapi_entity_value (_obj, obj->name, \"entries\", &hdlv, NULL);\n  if (!hdlv)\n    return NULL;\n  for (i = 0; i < num_entries; i++)\n    {\n      char *hdlname;\n      Dwg_Object *hobj;\n      Dwg_Object_APPID *_o;\n      int isnew = 0;\n      bool ok;\n\n      if (!hdlv[i])\n        continue;\n      hobj = dwg_resolve_handle (dwg, hdlv[i]->absolute_ref);\n      if (!hobj || !hobj->tio.object || !hobj->tio.object->tio.APPID)\n        continue;\n      _o = hobj->tio.object->tio.APPID;\n      ok = dwg_dynapi_entity_utf8text (_o, hobj->name, \"name\", &hdlname, &isnew, NULL);\n      LOG_HANDLE (\" %s.%s[%d] => %s.name: %s\\n\", obj->name, \"entries\", i,\n                  hobj->name, hdlname ? hdlname : \"NULL\");\n      if (ok && hdlname && (strEQ (name, hdlname) || !strcasecmp (name, hdlname)))\n        {\n          if (isnew)\n            free (hdlname);\n          return hdlv[i];\n        }\n      if (ok && isnew && hdlname)\n        free (hdlname);\n    }\n\n  return NULL;\n}",
    "comment": "Retrieves a handle for a specified named entry in a given table from a DWG file's control structure.",
    "hext5_sum": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert the numeric value to a structure, prints the header.",
    "bint5_sum": "Retrieves a handle for a specified table type and name in a DWG data structure based on the provided parameters .\n",
    "cpbcs_sum": "Retrieves UTF-8 encoded values from a DWG entity based on a specified header name and ending from a drawing object.\n",
    "misum_sum": "Processes RSA-related Unicode code to set UTF-8 grapheme based on specific flags and associated name comparisons.\n",
    "decom_sum": "Retrieves a specific DWG table entry handle, prioritizing predefined LTYPE names and resolving or reporting errors when handles are missing or invalid.",
    "cfg_sum": "Retrieves a specific DWG table entry handle by matching table and entry names, with special cases for LTYPE defaults and comprehensive error handling.",
    "work_score": {
        "hext5": {
            "summary": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert the numeric value to a structure, prints the header.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims are unrelated to the source code. The source implements a function to find and return a table handle based on given parameters, with specific logic for 'LTYPE' names and control object resolution. The summary instead references program options, open file pointers, numeric-to-structure conversion, and header printing, none of which appear in the source. All extracted claims are inaccurate with respect to the code, resulting in no alignment.",
                "The summary is entirely inaccurate: it describes program options, file opening, numeric-to-structure conversion, and header printing, none of which appear in the source code. It fails to mention the actual primary purpose of the function, which is to locate and return a specific table handle in a DWG structure based on a given name and table. No claims align with the code\u2019s CSU_LIST, so there is no coverage of primary or secondary details.",
                "The summary's claims about taking `opts` as input, returning a file pointer, converting a numeric value to a structure, and printing the header are entirely unrelated to the actual code, which searches for and returns a handle from a DWG table based on name and table parameters. This is pure NOISE with no accurate claims tied to the source code's primary purpose or I/O, resulting in very low reliability."
            ]
        },
        "bint5": {
            "summary": "Retrieves a handle for a specified table type and name in a DWG data structure based on the provided parameters .\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary broadly states that the function retrieves a handle for a specified table type and name in a DWG data structure using provided parameters. This aligns with the core purpose of the source code, which checks inputs, handles specific 'LTYPE' cases, retrieves a control table, resolves handles, and searches entries by name. Although the summary omits specifics like special case handling and detailed lookup logic, it remains accurate and not contradictory, making it a broadly safe match.",
                "The summary correctly identifies the primary purpose of the function as retrieving a handle for a specified table type and name in a DWG data structure, which aligns with the code's main behavior. However, it omits key secondary details such as null parameter checks, special handling for 'LTYPE' with specific names, resolution of control objects, dictionary type handling, iteration through entries, and various early return conditions. This lack of coverage for important secondary behaviors reduces completeness.",
                "The summary makes a single broad claim that the function retrieves a handle for a specified table type and name in a DWG data structure. This is generally accurate as the code searches for a table control, handles special LTYPE cases, and returns a matching handle when found. However, the claim is very generic, omitting the detailed control object resolution, specific name matching logic, and error handling shown in the source code. There are no inaccurate or contradictory statements, but the gain is low due to lack of specificity."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves UTF-8 encoded values from a DWG entity based on a specified header name and ending from a drawing object.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as retrieving UTF-8 encoded values from a DWG entity based on a header name and ending, which does not match the source code's central logic. The actual implementation searches for a handle in a specified table and compares names, sometimes fetching UTF-8 text for comparison, but it is not primarily retrieving values based on a header name and ending. This mismatch makes the claim targeted but inaccurate.",
                "The summary incorrectly states that the function retrieves UTF-8 encoded values from a DWG entity based on a specified header name and ending, which is misleading. The source code shows the function\u2019s primary purpose is to find and return a table handle for a given table and name within a DWG structure, including specific handling for the 'LTYPE' table and searching through control entries. While UTF-8 text retrieval occurs as part of name matching, this is incidental and not the core purpose. The summary misses the main functionality and omits critical secondary details such as input validation, special-case constants, control object resolution, and iteration over entries.",
                "The summary is inaccurate because it misrepresents the function\u2019s primary purpose. The source code\u2019s main role is to locate and return a table handle in a DWG structure by matching a given name and table type, not to retrieve UTF-8 encoded values based on a header name and ending. This is a FATAL error affecting the primary purpose, as it could mislead an engineer about what the function actually does."
            ]
        },
        "misum": {
            "summary": "Processes RSA-related Unicode code to set UTF-8 grapheme based on specific flags and associated name comparisons.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claim about processing RSA-related Unicode code and setting UTF-8 graphemes based on flags does not match the source code, which deals with finding specific table handles in a DWG structure and comparing names for certain LTYPE values. None of the summary's statements align with the actual operations in the code, resulting in no accurate claims.",
                "The summary is entirely inaccurate and unrelated to the source code. The function in the source handles locating a table handle within DWG data structures based on table type and name, with specific handling for 'LTYPE' constants and iterative searches through entries. The summary incorrectly describes RSA-related Unicode processing and UTF-8 grapheme setting, which does not match any semantics or purpose in the source code, thus missing the primary purpose and all secondary details.",
                "The summary makes a claim about processing RSA-related Unicode code and setting UTF-8 graphemes based on flags and name comparisons, which is entirely unrelated to the source code\u2019s purpose. The source implements a function to locate a specific table handle in DWG structures by matching names within DWG control or dictionary objects. This is a FATAL inaccuracy regarding the primary purpose, as the summary misidentifies the domain and core functionality, providing no accurate insight into the code."
            ]
        }
    }
}
{
    "project_name": "ncurses",
    "function_addr": 69424,
    "strip_function_name": "sub_10F30",
    "strip_decompiled_code": "_BYTE *__fastcall sub_10F30(__int64 a1, __int64 a2)\n{\n  _BYTE *result; // rax\n  _BYTE *v3; // rbp\n  _BYTE *v4; // rdx\n  unsigned int v5; // ebx\n  __int64 v6; // rdx\n  __int16 v7; // ax\n\n  result = *(_BYTE **)(a1 + 104);\n  v3 = result;\n  v4 = &result[*(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 12)];\n  if ( (*(_BYTE *)(a1 + 49) & 8) != 0 )\n  {\n    if ( result < v4 )\n      goto LABEL_17;\nLABEL_8:\n    v5 = (_DWORD)v4 - (_DWORD)v3;\n    if ( (int)v4 - (int)v3 <= 0 )\n      return result;\n    goto LABEL_9;\n  }\n  if ( result >= v4 )\n    goto LABEL_8;\n  if ( *result == 32 )\n  {\n    while ( ++v3 != v4 )\n    {\n      if ( *v3 != 32 )\n        goto LABEL_17;\n    }\n    v3 = *(_BYTE **)(a1 + 104);\n    if ( *(v4 - 1) == 32 )\n      goto LABEL_16;\n    goto LABEL_8;\n  }\nLABEL_17:\n  while ( *(v4 - 1) == 32 )\n  {\nLABEL_16:\n    if ( --v4 <= result )\n      goto LABEL_8;\n  }\n  v5 = (_DWORD)v4 - (_DWORD)v3;\n  if ( (int)v4 - (int)v3 > 0 )\n  {\nLABEL_9:\n    v6 = *(__int16 *)(a1 + 4) - v5;\n    if ( (int)v6 < 0 )\n    {\n      v6 = 0LL;\n    }\n    else\n    {\n      v7 = *(_WORD *)(a1 + 30);\n      if ( v7 == 2 )\n      {\n        v6 = (unsigned int)((int)v6 >> 1);\n      }\n      else if ( v7 != 3 )\n      {\n        v6 = 0LL;\n      }\n    }\n    sub_1FE50(a2, 0LL, v6);\n    return (_BYTE *)sub_1A040(a2, v3, v5);\n  }\n  return result;\n}\n",
    "function_name": "Perform_Justification",
    "decompiled_code": "void __fastcall Perform_Justification(FIELD *field, WINDOW *win)\n{\n  char *buf; // rax\n  char *v3; // rbp\n  char *v4; // rdx\n  int v5; // ebx\n  int v6; // edx\n  __int16 just; // ax\n\n  buf = field->buf;\n  v3 = buf;\n  v4 = &buf[field->dcols * field->drows];\n  if ( (field->opts & 0x800) != 0 )\n  {\n    if ( buf < v4 )\n      goto LABEL_17;\nLABEL_8:\n    v5 = (_DWORD)v4 - (_DWORD)v3;\n    if ( (int)v4 - (int)v3 <= 0 )\n      return;\n    goto LABEL_9;\n  }\n  if ( buf >= v4 )\n    goto LABEL_8;\n  if ( *buf == 32 )\n  {\n    while ( ++v3 != v4 )\n    {\n      if ( *v3 != 32 )\n        goto LABEL_17;\n    }\n    v3 = field->buf;\n    if ( *(v4 - 1) == 32 )\n      goto LABEL_16;\n    goto LABEL_8;\n  }\nLABEL_17:\n  while ( *(v4 - 1) == 32 )\n  {\nLABEL_16:\n    if ( --v4 <= buf )\n      goto LABEL_8;\n  }\n  v5 = (_DWORD)v4 - (_DWORD)v3;\n  if ( (int)v4 - (int)v3 > 0 )\n  {\nLABEL_9:\n    v6 = field->cols - v5;\n    if ( v6 < 0 )\n    {\n      v6 = 0;\n    }\n    else\n    {\n      just = field->just;\n      if ( just == 2 )\n      {\n        v6 >>= 1;\n      }\n      else if ( just != 3 )\n      {\n        v6 = 0;\n      }\n    }\n    wmove(win, 0, v6);\n    waddnstr(win, v3, v5);\n  }\n}\n",
    "source_code": "static void\nPerform_Justification(FIELD *field, WINDOW *win)\n{\n  FIELD_CELL *bp;\n  int len;\n\n  bp = (Field_Has_Option(field, O_NO_LEFT_STRIP)\n\t? field->buf\n\t: Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);\n\n  if (len > 0)\n    {\n      int col = 0;\n\n      assert(win && (field->drows == 1));\n\n      if (field->cols - len >= 0)\n\tswitch (field->just)\n\t  {\n\t  case JUSTIFY_LEFT:\n\t    break;\n\t  case JUSTIFY_CENTER:\n\t    col = (field->cols - len) / 2;\n\t    break;\n\t  case JUSTIFY_RIGHT:\n\t    col = field->cols - len;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n      wmove(win, 0, col);\n      myADDNSTR(win, bp, len);\n    }\n}",
    "comment": "Justifies the contents of a field within a window by aligning text based on specified justification (left, center, right) and current field length.",
    "hext5_sum": "@param[in] path colon separated list of directories @param[in] fname the name we are hunting for @param[in] mode the required file mode @returns an allocated string with the full path, or null local implementation of pathfind.",
    "bint5_sum": "Advances the cursor position in a form to the start of the next non-whitespace word in a given field , handling whitespace appropriately .\n",
    "cpbcs_sum": "Restores the display of a FIELD in a WINDOW by moving the cursor and writing the relevant data buffer contents to the window.\n",
    "misum_sum": "Restores the display of a FIELD in a WINDOW by moving the cursor position to the appropriate timeout based on a valid window.\n",
    "decom_sum": "Trims leading and trailing space characters from a byte buffer, adjusts length based on format, and writes the result to the output stream.",
    "cfg_sum": "Trims leading and trailing spaces from a data buffer, adjusts length based on format type, and writes the processed segment to the target.",
    "work_score": {
        "hext5": {
            "summary": "@param[in] path colon separated list of directories @param[in] fname the name we are hunting for @param[in] mode the required file mode @returns an allocated string with the full path, or null local implementation of pathfind.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes parameters and behavior related to a path-finding function with directory lists, filename hunting, and file mode checks, which has no relation to the provided source code implementing text justification within a window. All extracted claims are unrelated to the source code and therefore inaccurate.",
                "The summary description is entirely unrelated to the provided source code. It describes parameters and behavior for a file path search function, while the actual code performs text justification in a window based on field settings. The primary purpose, inputs, outputs, and logic from the source code are completely missed, indicating no accurate claims or coverage.",
                "The summary describes parameters related to a `pathfind` function (path list, filename, mode) and its return value, which is completely unrelated to the source code that implements text justification within a window for a form field. All claims are NOISE, with no accurate alignment to the code\u2019s primary purpose or I/O, resulting in zero informative gain and severe mismatch."
            ]
        },
        "bint5": {
            "summary": "Advances the cursor position in a form to the start of the next non-whitespace word in a given field , handling whitespace appropriately .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes advancing the cursor to the next non-whitespace word, which does not match the source code's actual behavior of justifying text within a field and positioning the cursor based on justification type. This is a semantic mismatch and all claims are inaccurate relative to the implementation, resulting in no accurate claims.",
                "The summary incorrectly describes the function as advancing the cursor to the next non-whitespace word, which contradicts the source code. The source code performs text justification within a single-row field, calculating alignment based on justification type and then moving the window cursor before printing the text. The claimed behavior targets source code semantics but is entirely unrelated, missing the primary purpose and all secondary details.",
                "The summary claims the function advances the cursor to the start of the next non-whitespace word, which directly contradicts the source code. The actual function calculates text justification (left, center, right) within a single-row field, moves the cursor to an appropriate column based on justification, and writes the text, with no logic for finding next words or skipping whitespace. This is a FATAL error about the primary purpose and cursor movement semantics, resulting in high negative impact and no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Restores the display of a FIELD in a WINDOW by moving the cursor and writing the relevant data buffer contents to the window.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately reflects the main action in the source code: positioning the cursor in the window and writing the buffer contents. It omits specific details such as justification logic, stripping options, and length checks, but does not contradict any code behavior. The single claim is correct but broad, making it [ACCURATE], resulting in a high proportion of accurate claims.",
                "The summary captures the primary purpose of writing the field\u2019s buffer content to the window and moving the cursor, which aligns with the core behavior in the source code. However, it misses secondary details such as handling left-strip options, calculating content length, justification modes (left, center, right), and the preconditions checked (assertions on window and row count). This incompleteness limits alignment with the evaluation steps.",
                "The summary contains a single broad SAFE claim: it says the function restores the display of a FIELD in a WINDOW by moving the cursor and writing data from the buffer. This loosely matches the source code\u2019s behavior of calculating justification, moving the cursor, and writing the relevant buffer segment to the window. However, it omits key specifics like handling justification modes and stripping whitespace. The claim is low\u2011info, lacking detailed GOLD insight, but there are no FATAL inaccuracies. The worst failure mode is low gain due to generic description rather than noise or contradiction."
            ]
        },
        "misum": {
            "summary": "Restores the display of a FIELD in a WINDOW by moving the cursor position to the appropriate timeout based on a valid window.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains a single claim that the function restores a FIELD display by moving the cursor based on a timeout, which is inaccurate. The source code handles text justification within a single-row field by calculating column positions according to justification settings, then moving the cursor and adding the text. There is no concept of a timeout, and the 'restore display' phrasing is misleading. As the only claim is incorrect, none of the extracted claims are accurate.",
                "The summary inaccurately describes the function\u2019s purpose by mentioning a 'timeout' and 'restores display,' which are not part of the source code. The actual implementation calculates text justification within a single-row field, moves the cursor to the appropriate column based on left/center/right alignment, and writes the field\u2019s contents to the window. The summary misses the primary purpose of performing text justification, omits key secondary details such as handling of leading spaces when O_NO_LEFT_STRIP is not set, and incorrectly introduces behavior (timeout) that doesn\u2019t exist in the code.",
                "The summary contains an inaccurate claim about moving the cursor position based on a 'timeout', which is not present in the source code. The actual implementation calculates column offset based on justification settings and text length, without any timeout logic. There is also missing mention of core behavior like text alignment (left, center, right) and conditional stripping of leading spaces. This is a FATAL error as it misstates the primary purpose, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582135843,
    "strip_function_name": "sub_FFFFFFFF81323623",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81323623(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10,\n        __int64 *a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  __int64 i; // rbx\n  __int64 *v15; // rdx\n  __int64 v16; // rcx\n  int v17; // r8d\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 *v21; // rdx\n  __int64 v22; // rcx\n  int v23; // r8d\n  int v24; // r9d\n  double v25; // xmm4_8\n  double v26; // xmm5_8\n  __int64 *v27; // rdx\n  __int64 v28; // rcx\n  int v29; // r8d\n  int v30; // r9d\n  double v31; // xmm4_8\n  double v32; // xmm5_8\n  __int64 *v33; // rdx\n  __int64 v34; // rcx\n  int v35; // r8d\n  int v36; // r9d\n  double v37; // xmm4_8\n  double v38; // xmm5_8\n\n  for ( i = 0LL; i != 24; i += 3LL )\n  {\n    sub_FFFFFFFF812FBA70(qword_FFFFFFFF81E9EAC0[i], a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);\n    qword_FFFFFFFF81E9EAC0[i] = 0LL;\n    qword_FFFFFFFF81E9EAD0[i] = 0LL;\n  }\n  sub_FFFFFFFF812FBA70(qword_FFFFFFFF81E9EA68, a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA80, a10, v15, v16, v17, v18, a1, a2, a3, a4, v19, v20, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA78, a10, v21, v22, v23, v24, a1, a2, a3, a4, v25, v26, a7, a8);\n  sub_FFFFFFFF812FBB60(qword_FFFFFFFF81E9EA70, a10, v27, v28, v29, v30, a1, a2, a3, a4, v31, v32, a7, a8);\n  return sub_FFFFFFFF8132319B((__int64)&unk_FFFFFFFF81E9EA50, a10, v33, v34, v35, v36, a1, a2, a3, a4, v37, v38, a7, a8);\n}\n",
    "function_name": "acpi_ut_mutex_terminate",
    "decompiled_code": "__int64 __fastcall acpi_ut_mutex_terminate(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10,\n        __int64 *a11)\n{\n  __int64 i; // rbx\n  __int64 *v12; // rdx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  __int64 *v15; // rdx\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 *v18; // rdx\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n\n  for ( i = 0LL; i != 24; i += 3LL )\n  {\n    acpi_os_delete_semaphore((__int64 *)acpi_gbl_mutex_info[i], a10, a11, a1, a2, a3, a4, a5, a6, a7, a8);\n    acpi_gbl_mutex_info[i] = 0LL;\n    qword_FFFFFFFF81E9EAD0[i] = 0LL;\n  }\n  acpi_os_delete_semaphore((__int64 *)acpi_gbl_osi_mutex, a10, a11, a1, a2, a3, a4, a5, a6, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_gpe_lock, a10, v12, a1, a2, a3, a4, v13, v14, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_hardware_lock, a10, v15, a1, a2, a3, a4, v16, v17, a7, a8);\n  acpi_os_delete_lock((__int64 *)acpi_gbl_reference_count_lock, a10, v18, a1, a2, a3, a4, v19, v20, a7, a8);\n  return acpi_ut_delete_rw_lock((__int64)acpi_gbl_namespace_rw_lock, a10, v21, a1, a2, a3, a4, v22, v23, a7, a8);\n}\n",
    "source_code": "\nvoid acpi_ut_mutex_terminate(void)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_terminate);\n\n\t/* Delete each predefined mutex object */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tacpi_ut_delete_mutex(i);\n\t}\n\n\tacpi_os_delete_mutex(acpi_gbl_osi_mutex);\n\n\t/* Delete the spinlocks */\n\n\tacpi_os_delete_lock(acpi_gbl_gpe_lock);\n\tacpi_os_delete_lock(acpi_gbl_hardware_lock);\n\tacpi_os_delete_lock(acpi_gbl_reference_count_lock);\n\n\t/* Delete the reader/writer lock */\n\n\tacpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_VOID;\n}",
    "comment": "Terminates and deletes all predefined mutex objects, spinlocks, and a reader/writer lock to clean up synchronization mechanisms.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases resources and deletes all video devices in the ACPI video bus , including their brightness settings , while ensuring thread safety .\n",
    "cpbcs_sum": "Releases resources and unregisters video devices and classes related to the ACPI video module exit.\n",
    "misum_sum": "Unregisters the ACPI video driver by resetting the list and freeing allocated memory for them.\n",
    "decom_sum": "Resets multiple global 64-bit data slots, processes them with transformation routines, and finalizes results using additional computations on remaining global entries.",
    "cfg_sum": "Processes and resets multiple global data entries, applies sequential transformation routines, and finalizes state updates using provided numeric parameters before returning the result.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains a single vague claim unrelated to the actual function's implementation, which is about deleting mutexes, spinlocks, and locks. The provided statement 'push a pointer type' does not match any operation or logic in the source code, making it inaccurate. Since none of the claims are accurate, the alignment is extremely poor.",
                "The summary 'push a pointer type' does not describe the primary purpose of the function, which is to delete various predefined mutexes, spinlocks, and a reader/writer lock during ACPI termination. It contains no accurate claims related to the source code, missing both the primary purpose and all secondary details.",
                "The summary contains a single vague statement about pushing a pointer type, which is unrelated to the source code that deletes mutexes, spinlocks, and locks in ACPI. This is pure NOISE with no factual alignment to the code, providing no useful insight into implementation or purpose."
            ]
        },
        "bint5": {
            "summary": "Releases resources and deletes all video devices in the ACPI video bus , including their brightness settings , while ensuring thread safety .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function deletes video devices in the ACPI video bus, manages brightness settings, and ensures thread safety. None of these details appear in the source code, which strictly deletes various mutexes, locks, and a reader/writer lock without any focus on video devices or brightness. All claims target semantics absent from the code, resulting in no accurate matches.",
                "The summary claims the function deletes video devices and manages brightness settings in the ACPI video bus, which is entirely unrelated to the source code. The source code terminates mutexes, spinlocks, and a reader/writer lock for ACPI, with no mention of video devices or brightness. As a result, the summary misses the primary purpose and all key secondary details.",
                "The summary claims the function deletes all video devices in the ACPI video bus and handles brightness settings, which is entirely unrelated to the source code. The real function releases mutexes, spinlocks, and a reader/writer lock, but there is no mention of video devices or brightness control. This is a FATAL semantic error targeting the primary purpose, making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Releases resources and unregisters video devices and classes related to the ACPI video module exit.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function releases resources and unregisters video devices and classes related to the ACPI video module exit, but the source code shows it only deletes mutexes, locks, and a reader/writer lock with no mention of video devices or classes. All claims are highly specific and contradict the actual implementation, resulting in 0% accuracy.",
                "The summary claims the function releases resources and unregisters video devices/classes tied to the ACPI video module, which is unrelated to the source code's actual behavior. The source code deletes mutexes, spinlocks, and a reader/writer lock for ACPI, with no mention of video devices or classes. This misses the primary purpose entirely and contains inaccurate assertions.",
                "The summary claims the function releases resources and unregisters video devices and classes related to the ACPI video module exit, but the source code only deletes various ACPI mutexes, locks, and a reader/writer lock. This is a direct contradiction about the primary purpose and key side effects, making it a FATAL error that misleads about the function\u2019s actual behavior."
            ]
        },
        "misum": {
            "summary": "Unregisters the ACPI video driver by resetting the list and freeing allocated memory for them.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function unregisters the ACPI video driver and frees allocated memory for it, which is entirely unrelated to the source code. The code instead deletes various mutexes, locks, and a reader/writer lock related to ACPI, with no mention of video driver or list resets. All claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary describes unregistering the ACPI video driver, resetting a list, and freeing memory, which is entirely unrelated to the source code\u2019s actual purpose of terminating mutexes, locks, and cleanup in the ACPI subsystem. This is a direct contradiction to the source semantics, missing the primary purpose and all secondary details.",
                "The summary makes a highly specific claim about unregistering the ACPI video driver, resetting a list, and freeing memory, which directly contradicts the source code. The actual function terminates and deletes various mutexes, spinlocks, and locks within the ACPI subsystem, not anything related to video driver handling or list memory management. This is a FATAL inaccuracy targeting the primary purpose of the function, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "coreutils",
    "function_addr": 4205360,
    "strip_function_name": "sub_402B30",
    "strip_decompiled_code": "__int64 __fastcall sub_402B30(const char *a1, __int64 a2, _BYTE *a3)\n{\n  FILE *v4; // rbx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  unsigned int v7; // r12d\n  const char *v9; // rbp\n  int *v10; // rax\n  __int64 v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  const char *v14; // rbx\n  int *v15; // rax\n  int *v16; // rax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int *v19; // rbx\n  const char *v20; // rax\n\n  *a3 = 0;\n  if ( !strcmp(a1, \"-\") )\n  {\n    v4 = stdin;\n    byte_60D2F0 = 1;\n    sub_4061E0(stdin, 2LL);\n    if ( !(unsigned int)sub_405F50(v4) )\n      return 1;\n  }\n  else\n  {\n    v11 = sub_406210(a1, 4234863LL);\n    v4 = (FILE *)v11;\n    if ( !v11 )\n    {\n      v7 = (unsigned __int8)byte_60D2DA;\n      v16 = __errno_location();\n      v19 = v16;\n      if ( (_BYTE)v7 && *v16 == 2 )\n      {\n        *a3 = 1;\n      }\n      else\n      {\n        v20 = (const char *)sub_407D50(0LL, 3LL, a1, v17, v18);\n        v7 = 0;\n        error(0, *v19, \"%s\", v20);\n      }\n      return v7;\n    }\n    sub_4061E0(v11, 2LL);\n    if ( !(unsigned int)sub_405F50(v4) )\n    {\n      if ( (unsigned int)sub_408730(v4) )\n      {\n        v14 = (const char *)sub_407D50(0LL, 3LL, a1, v12, v13);\n        v7 = 0;\n        v15 = __errno_location();\n        error(0, *v15, \"%s\", v14);\n        return v7;\n      }\n      return 1;\n    }\n  }\n  v9 = (const char *)sub_407D50(0LL, 3LL, a1, v5, v6);\n  v7 = 0;\n  v10 = __errno_location();\n  error(0, *v10, \"%s\", v9);\n  if ( stdin == v4 )\n    return v7;\n  sub_408730(v4);\n  return 0LL;\n}\n",
    "function_name": "digest_file",
    "decompiled_code": "_BOOL8 __fastcall digest_file(FILE *filename, char *binary, unsigned __int8 *bin_result, bool *missing)\n{\n  FILE *v5; // rbx\n  _BOOL4 v6; // r12d\n  char *v8; // rbp\n  int *v9; // rax\n  FILE *v10; // rax\n  char *v11; // rbx\n  int *v12; // rax\n  int *v13; // rax\n  int *v14; // rbx\n  char *v15; // rax\n\n  *bin_result = 0;\n  if ( !strcmp((const char *)filename, prefix) )\n  {\n    v5 = stdin;\n    have_read_stdin = 1;\n    fadvise(stdin, FADVISE_SEQUENTIAL);\n    if ( !(unsigned int)sha256_stream(v5, binary) )\n      return 1;\n  }\n  else\n  {\n    v10 = fopen_safer((const char *)filename, &command_name[165]);\n    v5 = v10;\n    if ( !v10 )\n    {\n      v6 = ignore_missing;\n      v13 = __errno_location();\n      v14 = v13;\n      if ( v6 && *v13 == 2 )\n      {\n        *bin_result = 1;\n      }\n      else\n      {\n        v15 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n        v6 = 0;\n        error(0, *v14, format, v15);\n      }\n      return v6;\n    }\n    fadvise(v10, FADVISE_SEQUENTIAL);\n    if ( !(unsigned int)sha256_stream(v5, binary) )\n    {\n      if ( rpl_fclose(v5) )\n      {\n        v11 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n        v6 = 0;\n        v12 = __errno_location();\n        error(0, *v12, format, v11);\n        return v6;\n      }\n      return 1;\n    }\n  }\n  v8 = quotearg_n_style_colon(0, quoting_style::shell_escape_quoting_style, (const char *)filename);\n  v6 = 0;\n  v9 = __errno_location();\n  error(0, *v9, format, v8);\n  if ( stdin == v5 )\n    return v6;\n  rpl_fclose(v5);\n  return 0LL;\n}\n",
    "source_code": "\nstatic bool\ndigest_file (const char *filename, int *binary, unsigned char *bin_result,\n             bool *missing)\n{\n  FILE *fp;\n  int err;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  *missing = false;\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fp = stdin;\n      if (O_BINARY && *binary)\n        {\n          if (*binary < 0)\n            *binary = ! isatty (STDIN_FILENO);\n          if (*binary)\n            xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n    }\n  else\n    {\n      fp = fopen (filename, (O_BINARY && *binary ? \"rb\" : \"r\"));\n      if (fp == NULL)\n        {\n          if (ignore_missing && errno == ENOENT)\n            {\n              *missing = true;\n              return true;\n            }\n          error (0, errno, \"%s\", quotef (filename));\n          return false;\n        }\n    }\n\n  fadvise (fp, FADVISE_SEQUENTIAL);\n\n#if HASH_ALGO_BLAKE2\n  err = DIGEST_STREAM (fp, bin_result, b2_length / 8);\n#else\n  err = DIGEST_STREAM (fp, bin_result);\n#endif\n  if (err)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      if (fp != stdin)\n        fclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return true;\n}",
    "comment": "Calculates a digest of the specified file or standard input, handling binary mode and error management for file operations.",
    "hext5_sum": "| prints the field provided by field. | '",
    "bint5_sum": "Calculates the CRC checksum of a file or standard input and prints the checksum along with the file size .\n",
    "cpbcs_sum": "Opens a file for reading or writing, handling standard input or output based on the provided command, and manages errors accordingly.\n",
    "misum_sum": "Opens a file for reading, processes the appropriate drive based on 'must_exist', and handles interruptions and drive errors.\n",
    "decom_sum": "Opens the specified file or stdin, performs validation, reports errors using errno, and sets a flag if the file is missing.",
    "cfg_sum": "Opens the specified file or standard input, verifies readability, sets error flags when necessary, and returns a status code indicating success or failure.",
    "work_score": {
        "hext5": {
            "summary": "| prints the field provided by field. | '",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague and nonsensical claim about printing a field, which is not represented in the source code. The source code computes a digest from a file or stdin and handles errors, missing files, and binary mode, with no printing of any field as described. This is a complete mismatch, resulting in no accurate claims.",
                "The summary is vague, nonsensical, and unrelated to the source code. It fails to identify the primary purpose of the function, which is reading a file or stdin to compute a digest while handling binary mode, missing files, errors, and closing resources. No accurate, fact-based claims were made, so there is no coverage of any critical semantic units.",
                "The summary contains only an incoherent and irrelevant fragment that does not address the function's actual behavior in the source code. It fails to mention the primary purpose of computing a digest from a file or stdin, and thus constitutes pure NOISE with zero accurate claims. This yields no useful insight into the code."
            ]
        },
        "bint5": {
            "summary": "Calculates the CRC checksum of a file or standard input and prints the checksum along with the file size .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates a CRC checksum and prints it with the file size. The source code shows a file digest computation using DIGEST_STREAM without any CRC-specific logic and does not output or print anything, nor handle file size printing. These claims target code semantics but contradict implementation, resulting in no accurate matches.",
                "The summary claims the function calculates a CRC checksum and prints it along with file size, which contradicts the source code. The source implements digest_file to read data from a file or stdin, compute a digest via DIGEST_STREAM, set missing flags for ENOENT, handle binary mode, and manage file closing, but does not specifically compute a CRC checksum nor print anything. This misidentifies the primary purpose and omits key details such as error handling and binary mode processing.",
                "The summary incorrectly states that the function calculates a CRC checksum and prints it along with the file size, which contradicts the source code. The function digests a file or stdin to produce a hash (via DIGEST_STREAM), but does not specifically use CRC or output anything; it only returns a boolean and sets results in provided buffers. This is a FATAL error about the primary purpose and output behavior, leading to a high negative impact and making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Opens a file for reading or writing, handling standard input or output based on the provided command, and manages errors accordingly.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function opens a file for reading or writing, handles standard input/output, and manages errors. The source code shows the function opens files only for reading (either 'r' or 'rb'), specifically handles standard input, and manages errors. The mention of writing and standard output is inaccurate, and the handling described is partially correct. Overall, only part of the summary matches the actual code, resulting in less than 50% accuracy.",
                "The summary inaccurately states that the function opens a file for reading or writing and handles standard input or output, but the source code only supports reading and processing file contents to compute a digest, not writing. It also omits key secondary details such as binary mode handling, specific error handling for missing files, use of fadvise for sequential access, digest computation via DIGEST_STREAM, and closing resources. The primary purpose is also misrepresented, so coverage of critical semantics is missing.",
                "The summary inaccurately claims the function opens a file for reading or writing and handles standard output, while the source code shows it only opens files for reading and processes standard input, with no writing or output handling. This is a FATAL error impacting the primary purpose. No accurate, detailed claims are provided to offset the negative impact."
            ]
        },
        "misum": {
            "summary": "Opens a file for reading, processes the appropriate drive based on 'must_exist', and handles interruptions and drive errors.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains only one partially relevant claim about opening a file for reading, which aligns with the source code. However, it incorrectly refers to 'must_exist' and 'drive' handling, neither of which appear in the code. The code handles missing files via 'ignore_missing', processes stdin or a regular file, and manages file errors, not drive-specific or 'must_exist' logic. This results in a majority of claims being inaccurate.",
                "The summary incorrectly describes the function\u2019s behavior, mentioning 'must_exist', 'drive', and 'drive errors', which are not present in the source code. It fails to identify the primary purpose \u2014 computing a digest of a file or stdin \u2014 and omits key secondary details such as handling stdin vs file input, binary mode settings, error handling for missing files, sequential read advice, and closing the file. None of the claims align accurately with the implementation.",
                "The summary contains a major inaccuracy: it mentions processing the 'appropriate drive' and using 'must_exist', neither of which are present in the source code. The function actually opens a file or stdin, handles missing files via 'ignore_missing', and performs digest operations while managing binary mode and error handling. These incorrect references target the key purpose and logic, making this a FATAL error with high negative impact. No accurate claims are present to provide useful insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580813104,
    "strip_function_name": "sub_FFFFFFFF811E0730",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811E0730(__int64 a1, __int64 a2)\n{\n  int v2; // ebx\n  __int64 v3; // r13\n  __int64 result; // rax\n  __int64 v5; // rax\n  int v6; // eax\n  int v7; // [rsp+4h] [rbp-34h]\n  _DWORD v8[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v2 = *(unsigned __int8 *)(a1 + 100);\n  v3 = *(_QWORD *)(a1 + 8);\n  if ( !(_BYTE)v2 )\n    BUG();\n  result = (unsigned int)*(unsigned __int8 *)(v3 + 20) + 1;\n  if ( v2 <= (int)result )\n  {\n    while ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 4LL * v2 + 80) )\n    {\n      if ( ++v2 > (int)result )\n        return result;\n    }\n    v5 = sub_FFFFFFFF811DBE20(a2, v2, v8);\n    if ( !v5 )\n      BUG();\n    v7 = v8[0];\n    v6 = sub_FFFFFFFF812BE6B0(v5 & 0xFFFFFFFFFFFFFFF8LL, (int)(8 * (v5 & 7) + v8[0]), 8 * (unsigned int)(v5 & 7))\n       - 8 * (v5 & 7);\n    if ( v6 > v7 )\n      v6 = v7;\n    if ( v8[0] <= v6 )\n      BUG();\n    ++*(_WORD *)(a1 + 90);\n    *(_DWORD *)(a1 + 60) = 1 << v2;\n    *(_DWORD *)(a1 + 52) = v6 << v2;\n    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 52);\n    sub_FFFFFFFF811E0350(a1, a2);\n    if ( *(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 44) )\n      BUG();\n    result = *(_QWORD *)(v3 + 848);\n    if ( *(_DWORD *)(result + 700) )\n      _InterlockedIncrement((volatile signed __int32 *)(result + 760));\n  }\n  return result;\n}\n",
    "function_name": "ext4_mb_simple_scan_group",
    "decompiled_code": "__int64 __fastcall ext4_mb_simple_scan_group(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  int v10; // ebx\n  __int64 v11; // r13\n  __int64 result; // rax\n  __int64 buddy; // rax\n  int v14; // eax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  int v17; // [rsp+4h] [rbp-34h]\n  _DWORD v18[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v10 = *(unsigned __int8 *)(a1 + 100);\n  v11 = *(_QWORD *)(a1 + 8);\n  if ( !(_BYTE)v10 )\n    BUG();\n  result = (unsigned int)*(unsigned __int8 *)(v11 + 20) + 1;\n  if ( v10 <= (int)result )\n  {\n    while ( !*(_DWORD *)(*(_QWORD *)(a2 + 32) + 4LL * v10 + 80) )\n    {\n      if ( ++v10 > (int)result )\n        return result;\n    }\n    buddy = mb_find_buddy(a2, v10, v18);\n    if ( !buddy )\n      BUG();\n    v17 = v18[0];\n    v14 = find_next_zero_bit(\n            buddy & 0xFFFFFFFFFFFFFFF8LL,\n            (int)(8 * (buddy & 7) + v18[0]),\n            8 * (unsigned int)(buddy & 7))\n        - 8 * (buddy & 7);\n    if ( v14 > v17 )\n      v14 = v17;\n    if ( v18[0] <= v14 )\n      BUG();\n    ++*(_WORD *)(a1 + 90);\n    *(_DWORD *)(a1 + 60) = 1 << v10;\n    *(_DWORD *)(a1 + 52) = v14 << v10;\n    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 52);\n    ext4_mb_use_best_found(a1, a2, a3, a4, a5, a6, v15, v16, a9, a10);\n    if ( *(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 44) )\n      BUG();\n    result = *(_QWORD *)(v11 + 848);\n    if ( *(_DWORD *)(result + 700) )\n      _InterlockedIncrement((volatile signed __int32 *)(result + 760));\n  }\n  return result;\n}\n",
    "source_code": "static noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}",
    "comment": "Scans the buddy system for free blocks, updates allocation context, and records statistics for memory management in an ext4 filesystem.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Adds a new extended file attribute entry to an ext4 filesystem , ensuring it does not already exist and updating its metadata accordingly .\n",
    "cpbcs_sum": "Displays the total transaction ID in an ext4 filesystem by iterating through its bitmap and checking for the associated bitmap and space errors.\n",
    "misum_sum": "Updates the writes revoke values of free blocks in an ext4 filesystem by checking their lengths and ensuring the bitmap is not exceed the limit.\n",
    "decom_sum": "Updates device state by advancing to the next active index, recalculating parameters, validating results, and incrementing associated counters if conditions are met.",
    "cfg_sum": "Validates indexed data from a structure, processes retrieved block values, updates related state fields, and increments counters, halting execution on critical validation failures.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary contains only a vague phrase unrelated to the source code's specific logic, offering no accurate or verifiable fact-based claims about the implementation. This results in 0% accurate claims, as it does not reflect the function's operations or semantics.",
                "The summary 'push a pointer type' is vague and unrelated to the source code's functionality. It does not capture the primary purpose, which is scanning an ext4 block group for a suitable extent using buddy system counters. There are no accurate, fact-based claims, and it misses all critical semantic units, including loop logic, error checks, extent assignment, and stats updates.",
                "The summary 'push a pointer type.' does not describe any aspect of the source code's logic, structure, or purpose. It is vague, unrelated to the actual implementation steps in ext4_mb_simple_scan_group, and provides no accurate or useful insight (NOISE). With no ACCURATE claims present, the content offers zero benefit for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Adds a new extended file attribute entry to an ext4 filesystem , ensuring it does not already exist and updating its metadata accordingly .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes adding a new extended file attribute entry and updating metadata, which is unrelated to the source code. The source code scans ext4 allocation groups to find and select blocks using buddy bitmaps, with no mention of extended attributes or metadata updates. All claims are inaccurate with respect to the code, resulting in no accurate claims.",
                "The summary claims the function adds a new extended file attribute entry and updates metadata to ensure uniqueness, but the source code shows it scans a group for free blocks matching a certain order in ext4 allocation, sets block extent info, and uses the best found block. The described behavior is unrelated to the function\u2019s primary purpose or secondary details, making the claims inaccurate and failing to capture any true semantics.",
                "The summary describes adding an extended file attribute entry and related metadata handling, which is entirely unrelated to the actual source code. The function in the source scans a buddy bitmap for available blocks in an ext4 group, sets allocation context fields, and updates statistics. This is a complete semantic mismatch, making the claim inaccurate and amounting to a FATAL error about the primary purpose."
            ]
        },
        "cpbcs": {
            "summary": "Displays the total transaction ID in an ext4 filesystem by iterating through its bitmap and checking for the associated bitmap and space errors.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about displaying a total transaction ID and checking for bitmap and space errors do not match the source code, which instead scans block groups for free space using buddy bitmaps in the ext4 allocator. None of the claims are accurate, as they target unrelated filesystem operations and ignore the actual scanning and allocation logic present.",
                "The summary is entirely inaccurate as it describes displaying a transaction ID and checking for bitmap and space errors, which do not correspond to the source function's actual behavior. The source code implements a scan through an ext4 block group to locate suitable free extents and update allocation context, with specific checks using BUG_ON and handling buddy structures. It misses the primary purpose and all secondary details of the function, offering unrelated functionality.",
                "The summary's primary claim that the function displays a total transaction ID in an ext4 filesystem is completely inaccurate, as the source code performs a scan of a buddy allocator structure to find suitable block extents. It also mentions iterating through a bitmap for space errors, which does not match the code's actual iteration and validation logic. This is a FATAL error because it misrepresents the primary purpose and key operations of the function, leading to unreliable understanding."
            ]
        },
        "misum": {
            "summary": "Updates the writes revoke values of free blocks in an ext4 filesystem by checking their lengths and ensuring the bitmap is not exceed the limit.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary is inaccurate because it describes updating 'writes revoke values' and checking bitmap limits, which are not reflected in the source code. The function in the source scans block groups for available free blocks using buddy structures, updates allocation context fields based on findings, and ensures constraints with BUG_ON checks. None of the summary's core claims match the actual semantics, so the proportion of accurate claims is 0%.",
                "The summary is inaccurate because it describes updating 'writes revoke values' of free blocks, which is not present in the source code. The function actually scans a block group in an ext4 filesystem for free extents matching specific size (order), sets fields in the allocation context, and uses the best found block. It includes safety checks via BUG_ON, uses buddy bitmaps, and optionally updates statistics. The primary purpose and actual observable behavior are missed entirely, so there is no accurate claim coverage.",
                "The summary contains a single claim that the function updates \"writes revoke values\" of free blocks, which is inaccurate and unrelated to the actual code semantics. The source function scans an ext4 block group to locate suitable free block extents, updates allocation context fields, and calls helper functions to use the best match; it does not manage revoke values or enforce a bitmap limit in the described sense. This is a FATAL error targeting the primary purpose of the code, leading to high negative impact and no accurate details."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 855088,
    "strip_function_name": "gsl_linalg_cholesky_scale_apply",
    "strip_decompiled_code": "__int64 __fastcall gsl_linalg_cholesky_scale_apply(_QWORD *a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // r8\n  unsigned __int64 v3; // rax\n  unsigned __int64 v4; // r10\n  __int64 v5; // r9\n  __int64 v6; // r11\n  __int64 v7; // rbx\n  double v8; // xmm1_8\n  double *v9; // rcx\n  unsigned __int64 v10; // rdx\n  double v11; // xmm0_8\n  __int64 v12; // rsi\n  double *v13; // rax\n\n  if ( *a1 == a1[1] )\n  {\n    v2 = *a2;\n    if ( *a2 == *a1 )\n    {\n      if ( v2 )\n      {\n        v3 = a2[1];\n        v4 = 0LL;\n        v5 = 8 * v3;\n        v6 = 8 * v3 + a2[2];\n        v7 = -8LL * v3;\n        do\n        {\n          v8 = *(double *)(v6 + v7);\n          if ( v2 > v4 )\n          {\n            v9 = (double *)v6;\n            v10 = v4;\n            v11 = *(double *)(v6 + v7);\n            v12 = 8LL * a1[2];\n            v13 = (double *)(a1[3] + v4 * (v12 + 8));\n            while ( 1 )\n            {\n              ++v10;\n              *v13 = v11 * v8 * *v13;\n              v13 = (double *)((char *)v13 + v12);\n              if ( v2 == v10 )\n                break;\n              v11 = *v9;\n              v9 = (double *)((char *)v9 + v5);\n            }\n          }\n          ++v4;\n          v6 += v5;\n        }\n        while ( v2 != v4 );\n      }\n      return 0LL;\n    }\n    else\n    {\n      gsl_error(\"S must have length N\", \"cholesky.c\", 425LL, 19LL);\n      return 19LL;\n    }\n  }\n  else\n  {\n    gsl_error(\"A is not a square matrix\", \"cholesky.c\", 421LL, 20LL);\n    return 20LL;\n  }\n}\n",
    "function_name": "gsl_linalg_cholesky_scale_apply",
    "decompiled_code": "int __fastcall gsl_linalg_cholesky_scale_apply(gsl_matrix *A, const gsl_vector *S)\n{\n  size_t size; // r8\n  size_t stride; // rax\n  size_t v4; // r10\n  __int64 v5; // r9\n  double *v6; // r11\n  __int64 v7; // rbx\n  double v8; // xmm1_8\n  double *v9; // rcx\n  size_t v10; // rdx\n  double v11; // xmm0_8\n  size_t v12; // rsi\n  double *v13; // rax\n\n  if ( A->size1 == A->size2 )\n  {\n    size = S->size;\n    if ( S->size == A->size1 )\n    {\n      if ( size )\n      {\n        stride = S->stride;\n        v4 = 0LL;\n        v5 = 8 * stride;\n        v6 = &S->data[stride];\n        v7 = 0x1FFFFFFFFFFFFFFFLL * stride;\n        do\n        {\n          v8 = v6[v7];\n          if ( size > v4 )\n          {\n            v9 = v6;\n            v10 = v4;\n            v11 = v6[v7];\n            v12 = 8 * A->tda;\n            v13 = (double *)((char *)A->data + v4 * (v12 + 8));\n            while ( 1 )\n            {\n              ++v10;\n              *v13 = v11 * v8 * *v13;\n              v13 = (double *)((char *)v13 + v12);\n              if ( size == v10 )\n                break;\n              v11 = *v9;\n              v9 = (double *)((char *)v9 + v5);\n            }\n          }\n          ++v4;\n          v6 = (double *)((char *)v6 + v5);\n        }\n        while ( size != v4 );\n      }\n      return 0;\n    }\n    else\n    {\n      ((void (__fastcall *)(const char *, char *, __int64, __int64))gsl_error)(\n        \"S must have length N\",\n        \"cholesky.c\",\n        425LL,\n        19LL);\n      return 19;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, char *, __int64, __int64))gsl_error)(\n      \"A is not a square matrix\",\n      \"cholesky.c\",\n      421LL,\n      20LL);\n    return 20;\n  }\n}\n",
    "source_code": "\nint\ngsl_linalg_cholesky_scale_apply(gsl_matrix * A, const gsl_vector * S)\n{\n  const size_t M = A->size1;\n  const size_t N = A->size2;\n\n  if (M != N)\n    {\n      GSL_ERROR(\"A is not a square matrix\", GSL_ENOTSQR);\n    }\n  else if (N != S->size)\n    {\n      GSL_ERROR(\"S must have length N\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i, j;\n\n      /* compute: A <- diag(S) A diag(S) using lower triangle */\n      for (j = 0; j < N; ++j)\n        {\n          double sj = gsl_vector_get(S, j);\n\n          for (i = j; i < N; ++i)\n            {\n              double si = gsl_vector_get(S, i);\n              double *Aij = gsl_matrix_ptr(A, i, j);\n              *Aij *= si * sj;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "comment": "Scales the elements of square matrix A by the elements of vector S using diagonal multiplication in a Cholesky decomposition context.",
    "hext5_sum": "this function computes the 12-th order and 24-th order chebyshev approximations to f(x) on [a,b]",
    "bint5_sum": "Applies a scaling transformation to the Cholesky decomposition of matrix A and stores the result in vector S .\n",
    "cpbcs_sum": "Performs a symmetric matrix-vector multiplication based on vector size and vector x and the vector size while checking for normalization.\n",
    "misum_sum": "Multiplies matrices A and B, storing results in vector S, and optionally performing matrix V via matrix B for normalization.\n",
    "decom_sum": "Validates matrix and vector dimensions, then scales a Cholesky factor matrix elements by products of corresponding scaling vector entries.",
    "cfg_sum": "Scales a Cholesky-decomposed square matrix by a diagonal scaling vector after validating dimension equality, returning errors for mismatched sizes.",
    "work_score": {
        "hext5": {
            "summary": "this function computes the 12-th order and 24-th order chebyshev approximations to f(x) on [a,b]",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function computes 12th and 24th order Chebyshev approximations to f(x) on [a,b], which is completely unrelated to the source code\u2019s actual behavior. The source implements gsl_linalg_cholesky_scale_apply, performing scaling of a square matrix using a vector S, and has no connection to Chebyshev approximations or the interval [a,b]. All extracted claims are inaccurate, resulting in no alignment with the source.",
                "The summary is entirely inaccurate; it describes computing Chebyshev approximations, which is unrelated to the actual source code functionality. The source implements scaling of a symmetric matrix using a diagonal matrix derived from vector S, with square matrix and length checks. The PRIMARY PURPOSE and all secondary details from the source code are missed.",
                "The summary's sole claim about computing 12th and 24th order Chebyshev approximations to f(x) on [a,b] is completely unrelated to the actual function, which scales a square matrix by a diagonal vector using the lower triangle. This is a FATAL error impacting the primary purpose and key computation, leaving no accurate information."
            ]
        },
        "bint5": {
            "summary": "Applies a scaling transformation to the Cholesky decomposition of matrix A and stores the result in vector S .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The claim that the function applies a scaling transformation to the Cholesky decomposition of matrix A and stores the result in vector S is inaccurate. The source code scales the matrix A in place using elements from vector S; it does not perform a Cholesky decomposition nor store results in S. This contradicts the actual semantics, resulting in 0% accurate claims.",
                "The summary incorrectly states that the function applies a scaling transformation to the Cholesky decomposition and stores the result in vector S, which contradicts the code. The source code shows the function scales matrix A in-place using values from vector S, with specific checks for square matrices and matching vector length, and returns GSL_SUCCESS or errors. The primary purpose and secondary details are missed, making the claim inaccurate.",
                "The summary incorrectly states that the result is stored in vector S, whereas the source code uses S as an input vector and modifies matrix A in place. This is a FATAL error affecting the primary purpose of the function (key I/O). There are no accurate or detailed claims present, and the main claim significantly contradicts the source semantics."
            ]
        },
        "cpbcs": {
            "summary": "Performs a symmetric matrix-vector multiplication based on vector size and vector x and the vector size while checking for normalization.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as performing a symmetric matrix-vector multiplication and checking for normalization, which contradicts the source code. The actual code scales a square matrix using a vector S by applying diag(S) * A * diag(S) to its lower triangle after validating matrix and vector dimensions. None of the claims in the summary align with the implementation, resulting in no accurate matches.",
                "The summary incorrectly describes the code as performing a symmetric matrix-vector multiplication and refers to normalization, which is not present in the implementation. The actual function scales a square matrix using the elements of a vector via the operation A <- diag(S) A diag(S), and includes validation checks for matrix squareness and matching vector length. The summary misses the primary purpose and key secondary details such as the scaling process, lower triangle use, and specific error conditions, yielding no accurate coverage of the CSU_LIST.",
                "The summary inaccurately describes the code as performing a symmetric matrix-vector multiplication and checking for normalization, which contradicts the actual implementation that scales a square matrix by a diagonal matrix derived from vector S. This is a FATAL error affecting the primary purpose and key I/O of the function, with no accurate claims provided, resulting in very high negative impact."
            ]
        },
        "misum": {
            "summary": "Multiplies matrices A and B, storing results in vector S, and optionally performing matrix V via matrix B for normalization.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains multiple fact-based claims that do not match the source code. The function operates on matrix A and vector S, scales A using diag(S) on both sides, and checks matrix dimensions, but there is no multiplication of matrices A and B, no storing results in vector S, and no mention of matrix V or normalization. All claims in the summary contradict the actual implementation, resulting in 0% accurate claims.",
                "The summary incorrectly states that the function multiplies matrices A and B and stores results in vector S, with optional normalization, which contradicts the source code. The actual code applies a scaling transformation to square matrix A using elements from vector S, with error checks for matrix shape and vector length. The primary purpose and all secondary details are missed, and the claims are not aligned with the function's implementation.",
                "The summary contains multiple inaccurate claims that contradict the source code\u2019s actual behavior. The source performs a scaling of the square matrix A using the vector S (A <- diag(S) A diag(S) on its lower triangle) with validation checks, but the summary incorrectly states that it multiplies matrices A and B, stores results in vector S, and performs normalization using matrix B \u2014 none of which appear in the implementation. These are FATAL errors targeting the primary purpose and I/O, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581886368,
    "strip_function_name": "sub_FFFFFFFF812E67A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812E67A0(__int64 a1, unsigned __int64 *a2)\n{\n  __int64 v2; // rbx\n  __int64 v3; // r13\n  __int64 (__fastcall *v4)(__int64, unsigned __int64 *); // rax\n  __int64 v5; // rdi\n  unsigned int v6; // ebx\n  unsigned __int64 v8; // r13\n  __int64 v9; // r15\n  unsigned __int64 v10; // rcx\n  unsigned __int64 v11; // rax\n  __int64 v12; // rax\n  bool v13; // cc\n\n  v2 = qword_FFFFFFFF81CB8C60[*(_DWORD *)(*(_QWORD *)(a1 + 32) + 76LL) & 0xFFFFF];\n  if ( *(_QWORD *)(a1 + 168) != v2 )\n    return 4294967277LL;\n  if ( !v2 )\n    return 4294967277LL;\n  v3 = *(_QWORD *)(v2 + 688);\n  if ( !v3 )\n    return 4294967277LL;\n  sub_FFFFFFFF8178F210(v2 + 56);\n  v4 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *))(v3 + 152);\n  if ( v4 )\n  {\n    v5 = v2 + 56;\n    v6 = v4(v2, a2);\n    sub_FFFFFFFF8178F1B0(v5);\n    return v6;\n  }\n  v8 = *(_QWORD *)(v2 + 272);\n  v9 = *(unsigned int *)(v2 + 280);\n  v10 = a2[19];\n  v11 = (v9 + (v8 & 0xFFF) + 4095) >> 12;\n  if ( v11 <= v10 )\n  {\n    if ( *(_DWORD *)(v2 + 192) )\n    {\n      sub_FFFFFFFF8178F1B0(v2 + 56);\n      return 4294967274LL;\n    }\n    a2[19] = v10 - v11;\n    v9 = *(unsigned int *)(v2 + 320);\n    v8 = *(_QWORD *)(v2 + 312);\n  }\n  sub_FFFFFFFF8178F1B0(v2 + 56);\n  v12 = sub_FFFFFFFF811104A0(a2[10]);\n  v13 = (unsigned __int8)dword_FFFFFFFF81CB4E80 <= 3u;\n  a2[9] = v12;\n  if ( !v13 )\n    a2[9] |= 0x10uLL;\n  return sub_FFFFFFFF8110D910(a2, v8, v9);\n}\n",
    "function_name": "fb_mmap",
    "decompiled_code": "__int64 __fastcall fb_mmap(\n        __int64 a1,\n        unsigned __int64 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 v10; // rbx\n  __int64 v11; // r13\n  __int64 (__fastcall *v12)(__int64, unsigned __int64 *); // rax\n  __int64 v13; // rdi\n  unsigned int v14; // ebx\n  unsigned __int64 v16; // r13\n  __int64 v17; // r15\n  unsigned __int64 v18; // rcx\n  unsigned __int64 v19; // rax\n  char *page_prot; // rax\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  bool v23; // cc\n\n  v10 = registered_fb[*(_DWORD *)(*(_QWORD *)(a1 + 32) + 76LL) & 0xFFFFF];\n  if ( *(_QWORD *)(a1 + 168) != v10 )\n    return 4294967277LL;\n  if ( !v10 )\n    return 4294967277LL;\n  v11 = *(_QWORD *)(v10 + 688);\n  if ( !v11 )\n    return 4294967277LL;\n  mutex_lock(v10 + 56);\n  v12 = *(__int64 (__fastcall **)(__int64, unsigned __int64 *))(v11 + 152);\n  if ( v12 )\n  {\n    v13 = v10 + 56;\n    v14 = v12(v10, a2);\n    mutex_unlock(v13);\n    return v14;\n  }\n  v16 = *(_QWORD *)(v10 + 272);\n  v17 = *(unsigned int *)(v10 + 280);\n  v18 = a2[19];\n  v19 = (v17 + (v16 & 0xFFF) + 4095) >> 12;\n  if ( v19 <= v18 )\n  {\n    if ( *(_DWORD *)(v10 + 192) )\n    {\n      mutex_unlock(v10 + 56);\n      return 4294967274LL;\n    }\n    a2[19] = v18 - v19;\n    v17 = *(unsigned int *)(v10 + 320);\n    v16 = *(_QWORD *)(v10 + 312);\n  }\n  mutex_unlock(v10 + 56);\n  page_prot = vm_get_page_prot(a2[10]);\n  v23 = (unsigned __int8)boot_cpu_data <= 3u;\n  a2[9] = (unsigned __int64)page_prot;\n  if ( !v23 )\n    a2[9] |= 0x10uLL;\n  return vm_iomap_memory(a2, v16, v17, a3, a4, a5, a6, v21, v22, a9, a10);\n}\n",
    "source_code": "\nstatic int\nfb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}",
    "comment": "Maps the framebuffer or MMIO memory region into the process's address space based on the provided virtual memory area structure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Reads framebuffer memory from a video device into a user-provided buffer , ensuring proper alignment and handling potential errors .\n",
    "cpbcs_sum": "Updates the framebuffer compression position based on the virtual console size and cursor position while ensuring thread safety with a mutex lock.\n",
    "misum_sum": "Handles framebuffer blanking and rendering power settings for a virtual console if the console is active.\n",
    "decom_sum": "Validates a device context, adjusts memory usage counters, and either calls a device-specific handler or performs a block transfer using stored parameters.",
    "cfg_sum": "Validates an object's state and associated resources, adjusts buffer counters, updates flags, and invokes processing to return a success or specific error code.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary\u2019s claims about replacing control characters with escape sequences, using a static buffer, and handling Unicode conversion when display is enabled do not match the source function `fb_mmap`, which deals with framebuffer memory mapping and related offsets. None of the claims target the actual code behavior, making them inaccurate.",
                "The summary is entirely unrelated to the source code's semantics. The source function handles memory mapping for a framebuffer device, including locking, optional delegation to a device-specific mmap handler, calculating mmio offsets, setting protections, and invoking vm_iomap_memory. The summary discusses replacing control characters, using a static buffer, and Unicode conversion, which do not appear in the source code. This results in no accurate claims and no coverage of the primary purpose.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display are entirely unrelated to the source code, which implements a framebuffer mmap operation. All claims are [INACCURATE] as they do not describe any source code logic, resulting in overwhelming NOISE and zero alignment with the code\u2019s primary purpose or I/O."
            ]
        },
        "bint5": {
            "summary": "Reads framebuffer memory from a video device into a user-provided buffer , ensuring proper alignment and handling potential errors .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function reads framebuffer memory into a user-provided buffer, but the source code implements an mmap operation for mapping framebuffer or mmio memory into user space, not a direct read. The claimed 'ensuring proper alignment' loosely aligns with mmio_pgoff alignment logic, and 'handling potential errors' matches the error checks in code. However, the central read operation claim is inaccurate, meaning less than half of the claims are correct.",
                "The summary incorrectly describes the function as reading framebuffer memory into a user-provided buffer, which is not reflected in the source code. The code actually handles memory mapping of framebuffer or MMIO regions into user space via mmap semantics, checks for device info and ops, manages locks, handles accelerator flags, adjusts offsets, sets page protections, and returns appropriate error codes. The primary purpose and critical details like differentiating framebuffer vs. MMIO mapping and error handling are missed, and the main action is misrepresented, making the claim inaccurate.",
                "The summary contains an inaccurate claim about reading framebuffer memory into a user-provided buffer, which contradicts the actual code that sets up a memory mapping via vm_iomap_memory rather than performing a read operation. This is a FATAL error affecting the primary purpose and I/O semantics. It does mention error handling, which is present in the code, but that alone does not offset the misleading core description."
            ]
        },
        "cpbcs": {
            "summary": "Updates the framebuffer compression position based on the virtual console size and cursor position while ensuring thread safety with a mutex lock.\n",
            "score": [
                0.2,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function updates framebuffer compression position based on console size and cursor position, which is not reflected in the source code. The source deals with mapping framebuffer or MMIO memory in fb_mmap, conditional offsets, and mutex locking, but does not mention compression, console size, or cursor position. The only partially accurate detail is the mention of thread safety via a mutex, but the majority of claims are unrelated or inaccurate.",
                "The summary's claims about updating framebuffer compression based on virtual console size and cursor position do not align with the source code, which handles memory mapping for a framebuffer device, including checks for device availability, optional fb_mmap operation, handling of MMIO vs framebuffer regions, mutex protection, and setting page protections. The summary misses the primary purpose entirely and introduces unrelated concepts not present in the code.",
                "The summary is entirely inaccurate (NOISE) and describes behavior unrelated to the source code. The code does not update framebuffer compression, virtual console size, or cursor position, but instead maps framebuffer or MMIO memory with mutex protection. The mismatch is total, and there are no accurate claims to provide any benefit."
            ]
        },
        "misum": {
            "summary": "Handles framebuffer blanking and rendering power settings for a virtual console if the console is active.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function handles framebuffer blanking and rendering power settings for a virtual console if active, but the source code shows it manages mmap operations for framebuffer memory and MMIO regions, with no logic for blanking, power settings, or console activity checks. This is a direct semantic mismatch and none of the claims align with the implementation.",
                "The summary describes framebuffer blanking and rendering power settings for a virtual console, which is unrelated to the actual code. The source implements memory mapping for a framebuffer device, handling optional fb_mmap callbacks, mmio offset calculations, and error cases. The summary misses the primary purpose entirely and introduces unrelated concepts, making all claims inaccurate.",
                "The summary claims the function handles framebuffer blanking and rendering power settings for a virtual console, which is unrelated to the actual code. The source implements framebuffer mmap behavior, checking device availability, invoking fb_mmap if present, handling memory offsets for framebuffer vs mmio regions, and mapping memory. This is a FATAL inaccuracy targeting the primary purpose and I/O, resulting in zero alignment with actual functionality."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582270352,
    "strip_function_name": "sub_FFFFFFFF81344390",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF81344390(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r13\n  __int64 v11; // rbx\n  unsigned int v12; // r12d\n  __int64 v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 **v16; // rbx\n  __int64 *v17; // r12\n  __int64 *v18; // rdx\n  __int64 v19; // rcx\n  int v20; // r8d\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  _QWORD v24[63]; // [rsp+0h] [rbp-210h]\n  __int64 v25; // [rsp+8h] [rbp-208h] BYREF\n  char v26; // [rsp+1F8h] [rbp-18h] BYREF\n\n  v10 = &unk_FFFFFFFF81E9F5C8;\n  v11 = 1LL;\n  v12 = 1;\n  sub_FFFFFFFF8103C680(a1);\n  do\n  {\n    v13 = *(_QWORD *)(*(_QWORD *)(qword_FFFFFFFF81E9F580 + 128) + v11 * 8);\n    if ( v13 && *(_DWORD *)(v13 + 400) || dword_FFFFFFFF81E9F594 == v12 || *v10 == qword_FFFFFFFF81E9F1F8 )\n    {\n      v24[v11] = 0LL;\n    }\n    else\n    {\n      a1 = v12;\n      v24[v11] = sub_FFFFFFFF81350630(v12);\n    }\n    ++v12;\n    ++v11;\n    v10 += 5;\n  }\n  while ( v12 != 63 );\n  sub_FFFFFFFF8103D500(a1);\n  v16 = (__int64 **)&v25;\n  do\n  {\n    v17 = *v16;\n    if ( *v16 )\n    {\n      sub_FFFFFFFF81341780(*v16, a2, a3, a4, a5, a6, v14, v15, a9, a10);\n      sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a3, a4, a5, a6, v22, v23, a9, a10, a2, v18, v19, v20, v21);\n    }\n    ++v16;\n  }\n  while ( v16 != (__int64 **)&v26 );\n}\n",
    "function_name": "vt_disallocate_all",
    "decompiled_code": "void __fastcall vt_disallocate_all(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r13\n  __int64 v11; // rbx\n  unsigned int v12; // r12d\n  __int64 v13; // rdx\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 **v19; // rbx\n  __int64 *v20; // r12\n  __int64 *v21; // rdx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  _QWORD v24[63]; // [rsp+0h] [rbp-210h] BYREF\n  char v25; // [rsp+1F8h] [rbp-18h] BYREF\n\n  v10 = &unk_FFFFFFFF81E9F5C8;\n  v11 = 1LL;\n  v12 = 1;\n  console_lock(a1, a2);\n  do\n  {\n    v16 = *(_QWORD *)(*(_QWORD *)(console_driver + 128) + v11 * 8);\n    if ( v16 && *(_DWORD *)(v16 + 400) || fg_console == v12 || *v10 == sel_cons )\n      v24[v11] = 0LL;\n    else\n      v24[v11] = vc_deallocate(v12, a2, v13, a3, a4, a5, a6, v14, v15, a9, a10);\n    ++v12;\n    ++v11;\n    v10 += 5;\n  }\n  while ( v12 != 63 );\n  console_unlock(a3, a4, a5, a6, v14, v15, a9, a10);\n  v19 = (__int64 **)&v24[1];\n  do\n  {\n    v20 = *v19;\n    if ( *v19 )\n    {\n      tty_port_destroy(*v19, a2, a3, a4, a5, a6, v17, v18, a9, a10);\n      kfree(v20, a3, a4, a5, a6, v22, v23, a9, a10, a2, v21);\n    }\n    ++v19;\n  }\n  while ( v19 != (__int64 **)&v25 );\n}\n",
    "source_code": "static void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!VT_BUSY(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES) {\n\t\t\ttty_port_destroy(&vc[i]->port);\n\t\t\tkfree(vc[i]);\n\t\t}\n\t}\n}",
    "comment": "Deallocates all virtual consoles that are not busy, destroying associated tty ports and freeing memory for those consoles.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases resources associated with a tty_driver , unregisters devices , and cleans up termios structures when the driver is no longer needed .\n",
    "cpbcs_sum": "Waits for all GPU firmware devices in the ACPI subsystem by reading their status registers and counting them to their respective controls.\n",
    "misum_sum": "Destroys the GPU cache by cleaning up resources, and decrementing the reference count of the framebuffer memory freeing associated resources.\n",
    "decom_sum": "Iterates through 62 indexed objects, conditionally initializes them, then processes each with two computational routines using provided parameters.",
    "cfg_sum": "Processes up to 62 indexed objects, skipping invalid or flagged entries, and applies two sequential update operations with provided parameters before finishing.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague statement about pushing a pointer type, which is not reflected in the source code's behavior. The source function handles deallocating console structures, locking/unlocking, and freeing resources, with no implementation resembling a generic pointer push. This results in no accurate claims aligned with the code.",
                "The summary 'push a pointer type' is vague, unrelated to the source code's semantics, and fails to capture the function's primary purpose of deallocating virtual consoles and freeing associated resources. No fact-based claim aligns with the implementation, resulting in no coverage of secondary details such as console locking, iteration over console indices, or resource cleanup.",
                "The summary 'push a pointer type.' is vague, contains no specific or accurate claims about the source code, and fails to describe its behavior, purpose, inputs, or outputs. This is pure NOISE with no factual alignment, offering zero insight to an engineer."
            ]
        },
        "bint5": {
            "summary": "Releases resources associated with a tty_driver , unregisters devices , and cleans up termios structures when the driver is no longer needed .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes releasing resources for a tty_driver, unregistering devices, and cleaning up termios structures. These details are not reflected in the source code, which specifically deallocates virtual console data, destroys tty ports, and frees memory for vc_data structures without any mention of tty_driver, device unregistration, or termios. All claims in the summary are inaccurate regarding the actual implementation.",
                "The summary describes freeing resources for a tty_driver, unregistering devices, and cleaning up termios structures, none of which appear in the source code. The code instead locks the console, deallocates non-busy virtual consoles, destroys tty ports, and frees their memory. This means the primary purpose and secondary details of the actual implementation are entirely missed and replaced with unrelated claims.",
                "The summary does not match the source code's functionality. The source code disallocates virtual console structures, destroys tty ports, and frees memory, but it does not interact with a tty_driver, unregister devices, or clean up termios structures. These are specific semantic contradictions regarding the primary purpose and key operations, making them fatal inaccuracies."
            ]
        },
        "cpbcs": {
            "summary": "Waits for all GPU firmware devices in the ACPI subsystem by reading their status registers and counting them to their respective controls.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function waits for GPU firmware devices in the ACPI subsystem and interacts with status registers, which is entirely unrelated to the source code. The source code clearly deallocates virtual consoles and associated resources, without mention of GPUs, firmware, ACPI, or status registers. All claims are inaccurate, resulting in no alignment.",
                "The summary describes waiting for GPU firmware devices in the ACPI subsystem, which is entirely unrelated to the source code. The source function deals with deallocating console structures, managing console locks, and freeing associated resources. The summary does not match the primary purpose or any secondary details of the source code, leading to no accurate claim coverage.",
                "The summary's claims about waiting for GPU firmware devices in the ACPI subsystem, reading their status registers, and counting them to controls are completely unrelated to the source code, which deals with deallocating virtual consoles and freeing associated resources. This is pure NOISE with zero accurate claims about the actual implementation, providing no usable insight and misrepresenting the primary purpose."
            ]
        },
        "misum": {
            "summary": "Destroys the GPU cache by cleaning up resources, and decrementing the reference count of the framebuffer memory freeing associated resources.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about destroying GPU cache, cleaning up framebuffer memory, and decrementing reference counts are unrelated to the source code, which deals with deallocating virtual console structures and freeing associated TTY ports. None of the claims accurately reflect the code semantics, resulting in no alignment with the source.",
                "The summary incorrectly describes GPU cache cleanup and framebuffer memory handling, which are unrelated to the source code. The source function disallocates virtual consoles by locking, deallocating unused ones, destroying tty ports, and freeing associated memory. The summary misses the primary purpose entirely and introduces inaccurate details not present in the code.",
                "The summary claims the function destroys the GPU cache, cleans up framebuffer memory, and decrements a reference count\u2014none of which are present in the source. The source clearly deals with deallocating virtual console structures, destroying tty ports, and freeing memory for unused consoles. These are semantics-heavy inaccuracies (FATAL) concerning the primary purpose and key I/O, leaving no accurate claims and creating high negative impact."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6104481,
    "strip_function_name": "sub_5D25A1",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_5D25A1(\n        _BYTE *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  int *v16; // rax\n  const __m128i *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  _QWORD v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = &a15;\n  v21[2] = &v22;\n  v16 = (int *)sub_4B60D0();\n  v17 = (const __m128i *)sub_4BABE0(*v16);\n  return sub_5176F5(\n           a1,\n           v21,\n           v17,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           v18,\n           v19,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "function_name": "bb_herror_msg",
    "decompiled_code": "unsigned __int64 __fastcall bb_herror_msg(\n        const __m128i *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  int *v16; // rax\n  const __m128i *v17; // rax\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = (__int64)&a15;\n  v21[2] = (__int64)&v22;\n  v16 = (int *)_h_errno_location();\n  v17 = (const __m128i *)hstrerror(*v16);\n  return bb_verror_msg(\n           a1,\n           v21,\n           v17,\n           *(double *)a7.m128_u64,\n           *(double *)a8.m128_u64,\n           *(double *)a9.m128_u64,\n           *(double *)a10.m128_u64,\n           v18,\n           v19,\n           *(double *)a13.m128_u64,\n           *(double *)a14.m128_u64);\n}\n",
    "source_code": "\nvoid FAST_FUNC bb_herror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\tbb_verror_msg(s, p, hstrerror(h_errno));\n\tva_end(p);\n}",
    "comment": "Formats and displays an error message using a variable argument list and the current error description from `hstrerror(h_errno)`.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Logs an error message formatted with the provided string and arguments , retrieves the error description using ` hstrerror ` , and terminates the program .\n",
    "cpbcs_sum": "Formats an error message using a variable argument list and arguments, retrieves the error description using `hstrerror`, and terminates the program.\n",
    "misum_sum": "Logs an error message formatted with a variable argument list using a variable argument list and variable arguments.\n",
    "decom_sum": "Prepares structured parameters and SIMD data, retrieves configuration, and invokes a processing routine with multiple double-precision values.",
    "cfg_sum": "Prepares state and vector registers, retrieves configuration data, and passes them to a processing routine to compute and return a result code.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes functionality related to Unicode character name lookup and buffer handling, which has no relation to the actual source code. The source code implements an error message function using variable arguments and system error translation, so all claims are inaccurate and unrelated.",
                "The summary describes behavior related to looking up Unicode character names and returning a buffer or null, which is entirely unrelated to the source code's actual function of formatting and printing an error message using hstrerror and variable arguments. The primary purpose is missed, and no accurate claims match the source implementation, resulting in no coverage of any critical semantic units.",
                "The summary contains only NOISE claims; it describes functionality about returning a buffer, looking up Unicode character names in uppercase ASCII, which is entirely unrelated to the source code that actually formats and prints an error message using hstrerror and variable arguments. There are no ACCURATE claims, and the mismatch is complete, making it unreliable."
            ]
        },
        "bint5": {
            "summary": "Logs an error message formatted with the provided string and arguments , retrieves the error description using ` hstrerror ` , and terminates the program .\n",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that an error message is formatted using the provided string and arguments and that `hstrerror` is used to retrieve an error description, which aligns with the source code. However, it inaccurately claims that the program terminates, which is not supported by the implementation of `bb_herror_msg`. This discrepancy reduces accuracy to a mixed level, as only part of the summary matches the actual behavior.",
                "The summary correctly states that the function formats an error message with the provided string and arguments and retrieves the error description using `hstrerror`, aligning with the source code. However, it inaccurately claims the program terminates, which is not shown in the implementation. It captures the primary purpose of logging an error with h_errno information but misses secondary details such as the use of `va_list` and the exact function called (`bb_verror_msg`).",
                "The summary correctly states that the function formats and logs an error message using the provided string, arguments, and `hstrerror` description, which matches the source code. However, it inaccurately claims that the program terminates, a FATAL error since termination is a key side effect and not present in the code. This high-impact inaccuracy on the primary purpose results in low reliability despite some accurate elements."
            ]
        },
        "cpbcs": {
            "summary": "Formats an error message using a variable argument list and arguments, retrieves the error description using `hstrerror`, and terminates the program.\n",
            "score": [
                0.5,
                0.4,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function formats an error message using a variable argument list and retrieves an error description via `hstrerror`, which matches the source code. However, it inaccurately claims that the function terminates the program, which is not implemented in the source. This introduces a significant incorrect claim, resulting in mixed accuracy with about half of the claims being accurate.",
                "The summary correctly states that the function formats an error message using variable arguments and retrieves the error description via `hstrerror`, aligning with the source code's actual behavior. However, it inaccurately claims that the function terminates the program, which is not evidenced in the source code. While the primary purpose is partially captured, this fatal inaccuracy and lack of mention of key secondary details such as use of `bb_verror_msg` and handling of `va_list` weaken completeness.",
                "The summary contains a FATAL inaccuracy: it claims the function terminates the program, but the source code simply formats and logs an error message via bb_verror_msg without any termination. While the part about using a variable argument list and retrieving the error description via hstrerror is accurate, the termination claim directly contradicts the primary purpose and behavior, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Logs an error message formatted with a variable argument list using a variable argument list and variable arguments.\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary claims that the function logs an error message formatted using a variable argument list, which is broadly accurate as the code uses `va_list` and passes it to `bb_verror_msg`. However, the repetition in 'using a variable argument list and variable arguments' is vague, and the summary omits important specifics such as the use of `hstrerror(h_errno)` to include error details. Overall, the claims are mostly accurate but incomplete and low in specificity.",
                "The summary correctly identifies that the function logs a formatted error message using a variable argument list, which aligns with the primary purpose of the source code. However, it misses important secondary details such as the use of `bb_verror_msg`, the inclusion of `hstrerror(h_errno)` to append a human-readable network error message, and the exact sequence of va_list initialization and cleanup. These omissions reduce completeness.",
                "The single claim in the summary is broad and repetitive, stating that the function logs an error message using a variable argument list. While this is not contradictory to the source, it lacks specifics such as the use of `bb_verror_msg`, `hstrerror`, and `h_errno`, and thus provides low informational value. There are no inaccurate claims, but the gain is low due to the absence of detailed, time-saving insights."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580570544,
    "strip_function_name": "sub_FFFFFFFF811A53B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811A53B0(\n        __int64 a1,\n        __int64 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  volatile signed __int32 *v10; // rax\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 **v17; // rbx\n  __int64 v18; // r14\n  volatile signed __int32 *v19; // r13\n  __int64 *v20; // rsi\n  unsigned int v21; // eax\n  unsigned int v22; // r12d\n  __int64 v24; // r14\n\n  v10 = sub_FFFFFFFF811A37C0(*(_QWORD *)(a1 + 48), 0LL, *a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( v10 )\n  {\n    v17 = (__int64 **)a2[2];\n    v18 = 0LL;\n    v19 = v10;\n    v20 = *v17;\n    if ( *v17 )\n    {\n      while ( 1 )\n      {\n        ++v17;\n        v21 = sub_FFFFFFFF811A2860((__int64)v19, (__int64)v20, 2u, a3, a4, a5, a6, v15, v16, a9, a10);\n        v20 = *v17;\n        v22 = v21;\n        if ( !*v17 )\n          break;\n        if ( v21 )\n          goto LABEL_12;\n        v18 = (int)v18 + 1;\n      }\n      if ( !v21 )\n        goto LABEL_8;\nLABEL_12:\n      if ( (int)v18 >= 0 )\n      {\n        v24 = (__int64)&v17[-v18 - 1];\n        do\n        {\n          --v17;\n          v20 = 0LL;\n          sub_FFFFFFFF811A19E0((__int64)v19, 0LL, **v17, a3, a4, a5, a6, v15, v16, a9, a10);\n        }\n        while ( (__int64 **)v24 != v17 );\n      }\n    }\n    else\n    {\nLABEL_8:\n      v22 = 0;\n    }\n    if ( !_InterlockedDecrement(v19) )\n      sub_FFFFFFFF811A2C80((unsigned __int64)v19, (__int64)v20, v11, v12, v13, v14, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  else\n  {\n    return (unsigned int)-2;\n  }\n  return v22;\n}\n",
    "function_name": "sysfs_merge_group",
    "decompiled_code": "__int64 __fastcall sysfs_merge_group(\n        __int64 a1,\n        unsigned __int8 **a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  volatile signed __int32 *dirent; // rax\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  int v13; // r8d\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 **v17; // rbx\n  __int64 v18; // r14\n  volatile signed __int32 *v19; // r13\n  __int64 *v20; // rsi\n  unsigned int v21; // eax\n  unsigned int v22; // r12d\n  __int64 v24; // r14\n\n  dirent = sysfs_get_dirent(*(_QWORD *)(a1 + 48), 0LL, *a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( dirent )\n  {\n    v17 = (__int64 **)a2[2];\n    v18 = 0LL;\n    v19 = dirent;\n    v20 = *v17;\n    if ( *v17 )\n    {\n      while ( 1 )\n      {\n        ++v17;\n        v21 = sysfs_add_file((__int64)v19, (__int64)v20, 2, a3, a4, a5, a6, v15, v16, a9, a10);\n        v20 = *v17;\n        v22 = v21;\n        if ( !*v17 )\n          break;\n        if ( v21 )\n          goto LABEL_12;\n        v18 = (int)v18 + 1;\n      }\n      if ( !v21 )\n        goto LABEL_8;\nLABEL_12:\n      if ( (int)v18 >= 0 )\n      {\n        v24 = (__int64)&v17[-v18 - 1];\n        do\n        {\n          --v17;\n          v20 = 0LL;\n          sysfs_hash_and_remove((__int64)v19, 0LL, **v17, a3, a4, a5, a6, v15, v16, a9, a10);\n        }\n        while ( (__int64 **)v24 != v17 );\n      }\n    }\n    else\n    {\nLABEL_8:\n      v22 = 0;\n    }\n    if ( !_InterlockedDecrement(v19) )\n      release_sysfs_dirent((__int64)v19, (__int64)v20, v11, v12, v13, v14, a3, a4, a5, a6, v15, v16, a9, a10);\n  }\n  else\n  {\n    return (unsigned int)-2;\n  }\n  return v22;\n}\n",
    "source_code": "int sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct sysfs_dirent *dir_sd;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tdir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);\n\tif (!dir_sd)\n\t\treturn -ENOENT;\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tsysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);\n\t}\n\tsysfs_put(dir_sd);\n\n\treturn error;\n}",
    "comment": "Merges a specified attribute group into a kobject's sysfs directory, adding attributes and handling errors by removing any added attributes on failure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Adds a symbolic link to a specified group in a sysfs directory , linking to a target kobject with the given link name .\n",
    "cpbcs_sum": "Attempts to merge a specified number of pages in the sysfs filesystem, verifying access for any necessary adjustments before returning the result.\n",
    "misum_sum": "Retrieves file attributes for a specified kernel object by copying data to user space, handling memory allocation and error conditions.\n",
    "decom_sum": "Processes a list of targets using a reference-counted resource, performing operations until a match is found, then cleans up and returns the operation status code.",
    "cfg_sum": "Processes a sequence of linked resources, invoking evaluation and cleanup routines as needed, and returns a status code based on conditional handler execution results.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes string processing related to control characters, escape sequences, static buffers, and unicode handling, which is entirely unrelated to the source code. The source code implements merging of sysfs attribute groups for a kobject, involving directory lookups and attribute file additions/removals. None of the claims match the code's semantics, resulting in 0% accurate claims.",
                "The summary's claims describe string processing operations such as replacing control characters, Unicode handling, and use of a static buffer, which are entirely unrelated to the source code. The source code implements merging sysfs attribute groups by adding files to a directory entry, handling errors, and cleaning up on failure. None of the summary's claims match the PRIMARY PURPOSE or any secondary details in the code, indicating a complete mismatch.",
                "The summary describes behavior involving control character replacement, escape sequences, use of a static buffer, and Unicode conversion, none of which align with the source code\u2019s actual functionality of merging attribute groups into a sysfs directory and handling errors during file addition. All claims are unrelated to the source, making them NOISE, with no accurate elements present. The worst failure mode is overwhelming NOISE, leading to zero informational value."
            ]
        },
        "bint5": {
            "summary": "Adds a symbolic link to a specified group in a sysfs directory , linking to a target kobject with the given link name .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a symbolic link to a specified group in a sysfs directory, linking to a target kobject with a given link name. However, the source code shows that the function merges an attribute group into an existing sysfs directory entry, iterating through attributes and adding files, not creating symbolic links to a kobject. This is a direct contradiction of the code\u2019s semantics, making the claim inaccurate with no accurate components.",
                "The summary incorrectly describes the function as adding a symbolic link to a sysfs group and linking to a target kobject, which contradicts the source code. The actual implementation merges a group of attributes into an existing sysfs directory, adds files for each attribute, and handles error cleanup. This mismatch means the primary purpose is not captured and no correct secondary details are provided.",
                "The summary claims that the function adds a symbolic link to a specified group in a sysfs directory, linking to a target kobject with a given link name. This is inaccurate because the source code does not create symbolic links; instead, it locates the directory entry for the group and iteratively adds attribute files, handling errors by removing them. The claim contradicts the primary purpose and semantics of the function, which is a FATAL error impacting key I/O behavior."
            ]
        },
        "cpbcs": {
            "summary": "Attempts to merge a specified number of pages in the sysfs filesystem, verifying access for any necessary adjustments before returning the result.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function merges a specified number of pages in the sysfs filesystem and verifies access before returning, which is inaccurate. The source code shows the function merges an attribute group into an existing kobject's directory, iterating over attributes and adding files, handling errors by removing added files. There is no mention of merging pages or verifying access permissions, making the claims unrelated to actual code semantics. All claims are inaccurate, resulting in very low alignment.",
                "The summary is inaccurate because it describes merging a number of pages and verifying access, which is unrelated to the actual code. The source code merges attributes from an attribute_group into a kobject's sysfs directory, handles errors by removing added files, and returns an error code. The summary misses the primary purpose entirely and introduces incorrect concepts (pages, access verification).",
                "The summary contains a FATAL inaccuracy: it describes merging a specified number of pages in sysfs and verifying access, which is entirely unrelated to the actual function. The source code merges an attribute group into a sysfs kobject directory, adding files for each attribute and rolling back on error. The incorrect focus on 'pages' and 'access verification' misrepresents the primary purpose and key I/O of the function, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Retrieves file attributes for a specified kernel object by copying data to user space, handling memory allocation and error conditions.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function retrieves file attributes for a kernel object by copying data to user space and handling memory allocation. The source code actually adds attribute files to a sysfs directory for a given kobject, handles errors by removing added files, and manages reference counts, but does not copy data to user space or perform explicit memory allocation. All claims are inaccurate as they contradict the code's semantics.",
                "The summary is inaccurate because it describes retrieving file attributes and copying data to user space, which does not match the source code. The function merges an attribute group into a sysfs directory for a kernel object by adding files for each attribute and handling errors through cleanup \u2014 there is no user space data copy or explicit memory allocation. This misses the primary purpose and all key secondary details.",
                "The summary contains a FATAL inaccuracy: it claims the function copies data to user space and handles memory allocation, which contradicts the source code. The implementation operates entirely within kernel space, merging a sysfs attribute group into a kobject's directory, adding files, and removing them on error\u2014no user space interaction or explicit memory allocation is performed. This is a high negative impact because it misrepresents the primary purpose and key I/O semantics."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582377712,
    "strip_function_name": "sub_FFFFFFFF8135E6F0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8135E6F0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 *a4)\n{\n  unsigned __int64 v5; // r13\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // rsi\n  __int64 v8; // rdx\n  unsigned __int64 v9; // rbx\n  void *v10; // r14\n  unsigned __int64 v11; // rcx\n  __int64 result; // rax\n  __int64 v14; // [rsp+8h] [rbp-38h]\n  __int64 v15; // [rsp+10h] [rbp-30h]\n\n  v5 = a3;\n  v6 = *a4;\n  v7 = *a4 + a3;\n  v8 = 0x77FF80000000LL;\n  if ( (unsigned __int64)qword_FFFFFFFF81E8C780 >= 0xFFFFFFFF80000000LL )\n    v8 = qword_FFFFFFFF81C10010;\n  if ( v7 > v8 + qword_FFFFFFFF81E8C780 + 0x80000000LL )\n    return -14LL;\n  if ( v5 )\n  {\n    v14 = 0LL;\n    while ( 1 )\n    {\n      v9 = 4096 - (v6 & 0xFFF);\n      if ( v9 > v5 )\n        v9 = v5;\n      v10 = (void *)sub_FFFFFFFF81031720(v6);\n      if ( !v10 )\n        break;\n      sub_FFFFFFFF81790F30(v6);\n      v15 = sub_FFFFFFFF812B8B10(v10, a2, (unsigned int)v9);\n      sub_FFFFFFFF81031790(v6, (__int64)v10);\n      if ( v15 )\n      {\n        v14 = v9 + v14 - v15;\n        if ( !v14 )\n          return -14LL;\nLABEL_12:\n        v11 = *a4;\n        goto LABEL_13;\n      }\n      a2 += v9;\n      v6 += v9;\n      v14 += v9;\n      v5 -= v9;\n      if ( !v5 )\n        goto LABEL_12;\n    }\n    if ( !v14 )\n      return -14LL;\n    goto LABEL_12;\n  }\n  v11 = *a4;\n  v14 = 0LL;\nLABEL_13:\n  result = v14;\n  *a4 = v14 + v11;\n  return result;\n}\n",
    "function_name": "write_mem",
    "decompiled_code": "__int64 __fastcall write_mem(\n        __int64 a1,\n        __int64 a2,\n        unsigned __int64 a3,\n        unsigned __int64 *a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  unsigned __int64 v13; // r13\n  unsigned __int64 v14; // r12\n  unsigned __int64 v15; // rsi\n  __int64 v16; // rdx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  unsigned __int64 v19; // rbx\n  unsigned __int64 v20; // r14\n  unsigned __int64 v21; // rcx\n  __int64 result; // rax\n  __int64 v24; // [rsp+8h] [rbp-38h]\n  __int64 v25; // [rsp+10h] [rbp-30h]\n\n  v13 = a3;\n  v14 = *a4;\n  v15 = *a4 + a3;\n  v16 = 0x77FF80000000LL;\n  if ( (unsigned __int64)high_memory >= 0xFFFFFFFF80000000LL )\n    v16 = phys_base;\n  if ( v15 > v16 + high_memory + 0x80000000LL )\n    return -14LL;\n  if ( v13 )\n  {\n    v24 = 0LL;\n    while ( 1 )\n    {\n      v19 = 4096 - (v14 & 0xFFF);\n      if ( v19 > v13 )\n        v19 = v13;\n      v20 = xlate_dev_mem_ptr(v14, a5, a6, a7, a8, a9, a10, a11, a12);\n      if ( !v20 )\n        break;\n      cond_resched(v14, v15);\n      v15 = v20;\n      v25 = copy_from_user(v20, a2, (unsigned int)v19);\n      unxlate_dev_mem_ptr(v14, v20, a5, a6, a7, a8, v17, v18, a11, a12);\n      if ( v25 )\n      {\n        v24 = v19 + v24 - v25;\n        if ( !v24 )\n          return -14LL;\nLABEL_12:\n        v21 = *a4;\n        goto LABEL_13;\n      }\n      a2 += v19;\n      v14 += v19;\n      v24 += v19;\n      v13 -= v19;\n      if ( !v13 )\n        goto LABEL_12;\n    }\n    if ( !v24 )\n      return -14LL;\n    goto LABEL_12;\n  }\n  v21 = *a4;\n  v24 = 0LL;\nLABEL_13:\n  result = v24;\n  *a4 = v24 + v21;\n  return result;\n}\n",
    "source_code": "static int __kprobes write_mem(unsigned long val, unsigned long ea, int nb,\n\t\t\t       struct pt_regs *regs)\n{\n\tif (!address_ok(regs, ea, nb))\n\t\treturn -EFAULT;\n\tif ((ea & (nb - 1)) == 0)\n\t\treturn write_mem_aligned(val, ea, nb);\n\treturn write_mem_unaligned(val, ea, nb, regs);\n}",
    "comment": "Writes specified bytes from a buffer to a target object's memory section, logging the operation if enabled.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Reads memory from a specified address , checking alignment and validity before using appropriate aligned or unaligned reading methods .\n",
    "cpbcs_sum": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
    "misum_sum": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
    "decom_sum": "Copies data from a source address to paged destination memory in chunks, updating the offset, with strict alignment and size limit checks.",
    "cfg_sum": "Transfers data from a source buffer to memory in page-aligned chunks, validating addresses and updating the offset, returning an error on invalid conditions.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving returning a pointer to a static buffer, value conversion based on a printf formatting character, and conditional use of hexadecimal output depending on num_bytes. None of these claims align with the source code, which instead checks address validity and calls either aligned or unaligned memory write functions without any formatting or buffer conversion logic. All extracted claims are inaccurate with respect to the provided implementation.",
                "The summary describes behavior related to converting a value to a string with printf formatting, which is unrelated to the source code's logic for writing memory. None of the claims match the primary purpose or secondary details of the function, such as address validation, alignment checks, or calls to write_mem_aligned/unaligned. This results in no coverage and a complete mismatch with the source semantics.",
                "All claims in the summary are unrelated to the source code\u2019s semantics, which deal with writing memory with alignment checks. The summary introduces unrelated behavior about returning a pointer to a static buffer, value conversion, printf formatting, and hex display, none of which are present. This is pure NOISE with no accurate claims, resulting in no informative gain and a high negative impact."
            ]
        },
        "bint5": {
            "summary": "Reads memory from a specified address , checking alignment and validity before using appropriate aligned or unaligned reading methods .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function reads memory, but the source code shows it writes memory via write_mem_aligned or write_mem_unaligned. While it correctly notes that it checks address validity and alignment before invoking the appropriate method, the main operation type is misstated, making a critical claim inaccurate. Only the procedural checks are accurately described, so less than half of the claims are correct.",
                "The summary incorrectly states that the function reads memory, while the source code clearly writes memory to a specified address. Although it mentions alignment and validity checks, the core purpose is misstated, resulting in a failure to capture the primary purpose. Secondary details like the specific error handling via -EFAULT and the distinction between aligned and unaligned write functions are partially mentioned but overshadowed by the fundamental inaccuracy.",
                "The summary incorrectly states that the function reads memory, while the source code shows it writes memory (`write_mem`). This is a FATAL inaccuracy about the primary purpose of the function (key I/O). Although it mentions checking address validity and alignment, the core operation is fundamentally misstated, making the description unreliable despite some accurate details."
            ]
        },
        "cpbcs": {
            "summary": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as reading memory, while the source code implements writing to memory. While it mentions checking validity and alignment and choosing aligned or unaligned access methods, which matches the code logic, the core operation (write vs. read) is misstated. This contradiction means less than half the claims are accurate.",
                "The summary incorrectly states that the function reads memory, whereas the source code\u2019s primary purpose is to write memory. While it mentions checking alignment and validity and using different methods depending on alignment, the core operation is misrepresented. This is a fatal inaccuracy that misses the primary purpose entirely, resulting in no valid coverage of critical semantic units.",
                "The summary inaccurately states that the function reads memory, while the source code clearly writes memory using write_mem_aligned or write_mem_unaligned after validating address and alignment. This is a FATAL error concerning the primary purpose of the function (key I/O). Although it mentions alignment and validity checks, the main operation is misrepresented, making the summary unreliable despite some partially correct details."
            ]
        },
        "misum": {
            "summary": "Reads memory from a specified address, checking alignment and validity before using appropriate aligned or unaligned reading methods.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function reads memory, while the source code implements writing memory via write_mem. Although it correctly mentions checking alignment and validity before choosing the appropriate method, the core operation described is inaccurate. Therefore, only a portion of the claims align with the source, resulting in low overall accuracy.",
                "The summary incorrectly describes the function as reading memory, whereas the source code clearly implements a write operation to memory. While it mentions address validity and alignment checks with appropriate method calls, the primary purpose is misstated, making the core claim inaccurate and disqualifying it from meaningful coverage.",
                "The summary contains a FATAL inaccuracy: it states that the function reads memory, while the source code clearly writes memory using `write_mem`, `write_mem_aligned`, and `write_mem_unaligned`. This misrepresents the primary purpose. Although it mentions alignment and validity checks, the core operation direction (read vs write) is wrong, which is a critical semantic error. This high negative impact overshadows any minor accurate details."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592542067,
    "strip_function_name": "sub_FFFFFFFF81D0FF73",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81D0FF73(\n        int a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // r12d\n  __int64 v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 result; // rax\n  __int64 v15; // rax\n  __int64 v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // edx\n  unsigned __int64 v20; // r12\n\n  v9 = 1;\n  if ( a1 >= 0 )\n    v9 = a1 + 2;\n  v11 = sub_FFFFFFFF8178CF92(a2, a3, a4, a5, a6, a7, a8, a9);\n  result = 4294967284LL;\n  if ( v11 )\n  {\n    v15 = qword_FFFFFFFF81EA6D38;\n    *(_QWORD *)v11 = 16LL * v9 - 2115343008;\n    v16 = v11 + 8;\n    *(_BYTE *)(v11 + 73) = 1;\n    *(_QWORD *)(v11 + 80) = sub_FFFFFFFF814DFE10;\n    *(_QWORD *)(v11 + 104) = sub_FFFFFFFF814DF330;\n    *(_QWORD *)(v11 + 112) = sub_FFFFFFFF814DFA50;\n    *(_QWORD *)(v11 + 672) = &unk_FFFFFFFF81C763A0;\n    *(_QWORD *)(v11 + 216) = v15 + 16;\n    if ( a1 >= 0 )\n    {\n      sub_FFFFFFFF812B8440(v16, 32LL, (__int64)\"i8042 AUX%d port\", a2, a3, a4, a5, v12, v13, a8, a9, (unsigned int)a1);\n      sub_FFFFFFFF812B8440(\n        v11 + 40,\n        32LL,\n        (__int64)\"isa0060/serio%d\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9,\n        (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      sub_FFFFFFFF812B54A0(v16, \"i8042 AUX port\", 0x20uLL);\n      sub_FFFFFFFF812B54A0(v11 + 40, \"isa0060/serio1\", 0x20uLL);\n      *(_QWORD *)(v11 + 96) = sub_FFFFFFFF814E0250;\n    }\n    v19 = dword_FFFFFFFF81EA6E40;\n    v20 = 4LL * v9;\n    result = 0LL;\n    qword_FFFFFFFF81EA6D60[v20 / 2] = v11;\n    byte_FFFFFFFF81EA6D6D[v20 * 4] = a1;\n    dword_FFFFFFFF81EA6D68[v20] = v19;\n  }\n  return result;\n}\n",
    "function_name": "i8042_create_aux_port",
    "decompiled_code": "__int64 __fastcall i8042_create_aux_port(\n        int a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  int v9; // r12d\n  __int64 *v11; // rbx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 result; // rax\n  __int64 v15; // rax\n  __int64 v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // edx\n  unsigned __int64 v20; // r12\n\n  v9 = 1;\n  if ( a1 >= 0 )\n    v9 = a1 + 2;\n  v11 = kzalloc_constprop_8(a2, a3, a4, a5, a6, a7, a8, a9);\n  result = 4294967284LL;\n  if ( v11 )\n  {\n    v15 = i8042_platform_device;\n    *v11 = 16LL * v9 - 2115343008;\n    v16 = (__int64)(v11 + 1);\n    *((_BYTE *)v11 + 73) = 1;\n    v11[10] = (__int64)i8042_aux_write;\n    v11[13] = (__int64)i8042_start;\n    v11[14] = (__int64)i8042_stop;\n    v11[84] = (__int64)&i8042_mutex;\n    v11[27] = v15 + 16;\n    if ( a1 >= 0 )\n    {\n      snprintf(v16, 32LL, (__int64)\"i8042 AUX%d port\", a2, a3, a4, a5, v12, v13, a8, a9, (unsigned int)a1);\n      snprintf(\n        (__int64)(v11 + 5),\n        32LL,\n        (__int64)\"isa0060/serio%d\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9,\n        (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      strlcpy(v16, (__int64 *)\"i8042 AUX port\", 0x20uLL);\n      strlcpy((__int64)(v11 + 5), (__int64 *)\"isa0060/serio1\", 0x20uLL);\n      v11[12] = (__int64)i8042_port_close;\n    }\n    v19 = i8042_aux_irq;\n    v20 = 4LL * v9;\n    result = 0LL;\n    i8042_ports[v20 / 2] = (__int64)v11;\n    byte_FFFFFFFF81EA6D6D[v20 * 4] = a1;\n    dword_FFFFFFFF81EA6D68[v20] = v19;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int __init i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrlcpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}",
    "comment": "Initializes an i8042 auxiliary port, allocating a serio structure and configuring it for communication with the specified input device.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes the loop device by allocating memory , setting up loop devices , and registering the loop device with the block device subsystem .\n",
    "cpbcs_sum": "Initializes a serial 8250 port, configures its parameters and adds it to the device if valid, while setting up a semaphore.\n",
    "misum_sum": "Initializes an input device by allocating memory, setting up its corresponding function and initializing its properties in the system.\n",
    "decom_sum": "Initializes and registers an i8042 auxiliary (mouse) port device, configuring handlers, names, and storing it in global controller structures.",
    "cfg_sum": "Initializes and registers an i8042 AUX port device, setting handlers, naming identifiers, and updating global tables based on the provided port index.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary contains only a vague statement ('push a pointer type') that does not correspond to any specific or accurate behavior in the source code. It lacks fact-based claims tied to the code's semantics, resulting in 0% accurate claims.",
                "The summary 'push a pointer type.' is vague, does not describe the function's primary purpose, and fails to capture any verifiable details from the source code such as the initialization of a serio structure, port setup, or error handling. It does not match any critical semantic units and provides no relevant information aligned with the function's behavior.",
                "The summary contains only a vague phrase unrelated to the source code's actual functionality. It does not capture any specific behavior, inputs, or outputs from the function, resulting in pure NOISE with no accurate claims. There is no informative or actionable content, providing zero net benefit."
            ]
        },
        "bint5": {
            "summary": "Initializes the loop device by allocating memory , setting up loop devices , and registering the loop device with the block device subsystem .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the code initializes a loop device, allocates memory, sets up loop devices, and registers it with the block device subsystem. In reality, the source code allocates and configures a serio structure for an i8042 auxiliary port, sets function pointers, and configures port details\u2014nothing related to loop devices or block device registration. All claims in the summary are inaccurate with respect to the source code.",
                "The summary is entirely inaccurate as it describes operations related to loop devices and block device subsystem, which do not appear in the source code. The source function initializes an AUX port for the i8042 driver by allocating a serio structure, setting callbacks, naming the port based on the index, and configuring port parameters. It completely misses the primary purpose and all secondary details of the actual code, making the claims irrelevant to the implementation.",
                "The summary makes multiple claims about initializing a loop device, involving memory allocation, setup, and registration with the block device subsystem. These are entirely unrelated to the source code, which initializes an i8042 auxiliary port for a serio device with specific properties and handlers. All claims are NOISE, referencing different hardware and subsystems, providing no accurate alignment with the actual code implementation. The worst failure mode is overwhelming NOISE, with no factual match to the code."
            ]
        },
        "cpbcs": {
            "summary": "Initializes a serial 8250 port, configures its parameters and adds it to the device if valid, while setting up a semaphore.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes a serial 8250 port, configures parameters, adds it to a device, and sets up a semaphore, none of which matches the source code. The source code initializes a serio structure for an i8042 AUX port, assigns handlers, names, and device parent, and sets port-related fields without involving serial 8250, semaphores, or adding to a device explicitly. All claims are inaccurate, resulting in no alignment with the source.",
                "The summary incorrectly states that the function initializes a serial 8250 port and sets up a semaphore, which contradicts the source code that creates and configures an i8042 AUX port using a serio structure. It also misses the primary purpose and specific behavior such as handling idx for AUX vs MUX ports, memory allocation, error handling, and setting function pointers. No accurate claims align with the code, resulting in no coverage of the CSU_LIST.",
                "The summary contains a FATAL error: it claims the function initializes a serial 8250 port with semaphore setup, which directly contradicts the source code that creates and configures an i8042 AUX port without any semaphore handling. This misidentifies the primary purpose and key functionality, making the description misleading and unreliable."
            ]
        },
        "misum": {
            "summary": "Initializes an input device by allocating memory, setting up its corresponding function and initializing its properties in the system.\n",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function allocates memory and sets up properties, which matches the code's kzalloc usage and struct initialization. However, it is overly broad and omits critical specifics like assigning function pointers, handling conditional naming, and configuring port and IRQ values. Despite being safe and not contradictory, its lack of detail reduces alignment precision, making it mostly low-information but accurate.",
                "The summary correctly conveys the primary purpose of the function\u2014initializing an input device via memory allocation and property setup\u2014which matches the source code. However, it omits key secondary details such as the use of specific functions (i8042_aux_write, i8042_start, i8042_stop, i8042_port_close), handling of idx for naming and physical description, error handling for memory allocation failure, setting IRQ values, and linking to the platform device. These omissions reduce completeness.",
                "The summary is broadly accurate but very generic, lacking specific details such as conditional naming based on idx, setting of port_data, mux, irq, and specific functions assigned (write, start, stop, close). It matches the overall purpose of initializing an input device with allocated memory and properties, but provides low informational value and no contradictions. The worst failure mode is low gain due to overly broad SAFE claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581326800,
    "strip_function_name": "sub_FFFFFFFF8125DDD0",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8125DDD0(\n        unsigned int a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // rbx\n  unsigned __int64 v11; // r13\n  unsigned __int64 v12; // rsi\n  unsigned __int64 v13; // rax\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  volatile signed __int32 *v20; // rbx\n  volatile signed __int32 *v21; // r12\n  __int64 v22; // rdx\n  __int64 v23; // rcx\n  __int64 v24; // r8\n  int v25; // r9d\n  double v26; // xmm4_8\n  double v27; // xmm5_8\n\n  v10 = sub_FFFFFFFF8125FA30(a2, 0LL, 4LL);\n  v11 = v10;\n  if ( v10 <= 0xFFFFFFFFFFFFF000LL )\n  {\n    v12 = 4LL;\n    v13 = sub_FFFFFFFF8125FA30(a1, 4LL, 0LL);\n    if ( v13 > 0xFFFFFFFFFFFFF000LL )\n    {\n      v11 = v13;\n      v20 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n    }\n    else\n    {\n      v20 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n      v21 = (volatile signed __int32 *)(v13 & 0xFFFFFFFFFFFFFFFELL);\n      v12 = v13 & 0xFFFFFFFFFFFFFFFELL;\n      v11 = (int)sub_FFFFFFFF8125C660((__int64)v20, v13 & 0xFFFFFFFFFFFFFFFELL, a3, a4, a5, a6, v18, v19, a9, a10);\n      sub_FFFFFFFF8125B5F0(v21, a3, a4, a5, a6, v26, v27, a9, a10, v12, v22, v23, v24, v25);\n    }\n    sub_FFFFFFFF8125B5F0(v20, a3, a4, a5, a6, v18, v19, a9, a10, v12, v14, v15, v16, v17);\n  }\n  return v11;\n}\n",
    "function_name": "keyctl_keyring_unlink",
    "decompiled_code": "unsigned __int64 __fastcall keyctl_keyring_unlink(\n        unsigned int a1,\n        unsigned int a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  unsigned __int64 v10; // rbx\n  unsigned __int64 v11; // r13\n  unsigned __int64 v12; // rax\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  volatile signed __int32 *v15; // rbx\n  volatile signed __int32 *v16; // r12\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  v10 = lookup_user_key(a2, 0LL, 4LL);\n  v11 = v10;\n  if ( v10 <= 0xFFFFFFFFFFFFF000LL )\n  {\n    v12 = lookup_user_key(a1, 4LL, 0LL);\n    if ( v12 > 0xFFFFFFFFFFFFF000LL )\n    {\n      v11 = v12;\n      v15 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n    }\n    else\n    {\n      v15 = (volatile signed __int32 *)(v10 & 0xFFFFFFFFFFFFFFFELL);\n      v16 = (volatile signed __int32 *)(v12 & 0xFFFFFFFFFFFFFFFELL);\n      v11 = (int)key_unlink((__int64)v15, v12 & 0xFFFFFFFFFFFFFFFELL, a3, a4, a5, a6, v13, v14, a9, a10);\n      key_put(v16, a3, a4, a5, a6, v17, v18, a9, a10);\n    }\n    key_put(v15, a3, a4, a5, a6, v13, v14, a9, a10);\n  }\n  return v11;\n}\n",
    "source_code": "long keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_unlink(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "comment": "Unlinks a key from a specified keyring after verifying the existence of both the key and the keyring.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Links a key to a specified keyring , creating the keyring if it does not exist , and returns a status code .\n",
    "cpbcs_sum": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
    "misum_sum": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
    "decom_sum": "Processes two resource handles retrieved from IDs, performs paired computations using supplied doubles, and invokes cleanup or update routines on each handle before returning a result.",
    "cfg_sum": "Validates two memory-mapped inputs, applies bitmasking, invokes computation and update routines with provided numeric parameters, and returns a computed status value.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains mathematical notation unrelated to the function or logic shown in the source code. There are no claims about the code\u2019s behavior, implementation, or semantics, meaning all extracted claims are inaccurate or irrelevant per the evaluation steps. This results in 0% accurate claims.",
                "The summary provides a mathematical formula unrelated to the source code, which defines a C function handling keyring unlink operations in the Linux key management subsystem. It fails to mention the function\u2019s purpose, arguments, return value, or error handling logic, thus missing both the primary purpose and all secondary details.",
                "The summary provides a mathematical expression unrelated to the source code\u2019s function, parameters, or behavior. All claims are NOISE, offering no insight into the keyctl_keyring_unlink implementation. Since there are no ACCURATE claims and the content is entirely irrelevant, the net benefit is zero with the worst failure mode being overwhelming NOISE."
            ]
        },
        "bint5": {
            "summary": "Links a key to a specified keyring , creating the keyring if it does not exist , and returns a status code .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function links a key to a specified keyring, creates the keyring if it does not exist, and returns a status code. In the source code, the function instead unlinks a key from a keyring, does not create a keyring, and returns a status code. The core operation described in the summary contradicts the actual unlink behavior, making most claims inaccurate. Only the detail about returning a status code is correct.",
                "The summary incorrectly states that the function links a key and creates the keyring if it does not exist, which contradicts the source code. The actual implementation unlinks a key from a keyring and does not create any keyring. This misses the primary purpose and all secondary details such as error handling and reference management. The sole claim is inaccurate and provides no correct coverage of the code\u2019s semantics.",
                "The summary contains a FATAL inaccuracy: it claims the function links a key and creates the keyring if it does not exist, whereas the source code performs an unlink operation and never creates a keyring. This contradicts the primary purpose and key side effects of the code, making the description unreliable. There are no accurate or high-gain claims present."
            ]
        },
        "cpbcs": {
            "summary": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as linking a key and creating a keyring if missing, which contradicts the source code. The actual implementation unlinks a key from a keyring and does not create any keyring. This is a semantic mismatch, making the claim inaccurate.",
                "The summary is inaccurate: the source code\u2019s primary purpose is to unlink (remove) a key from a specified keyring, not to link or create it. The claim contradicts the implementation\u2019s semantics, missing critical details such as error handling for failed lookups, use of KEY_WRITE and KEY_LOOKUP_FOR_UNLINK, and calls to key_ref_put for cleanup. Because the primary purpose is misidentified, no accurate claims can be mapped to the source code, resulting in no coverage.",
                "The summary is inaccurate because it describes linking a key to a keyring and creating the keyring if it does not exist, while the source code actually unlinks a key from an existing keyring and does not create any keyring. This is a FATAL error targeting the primary purpose of the function, making it misleading for understanding the code. There are no accurate claims to provide positive gain."
            ]
        },
        "misum": {
            "summary": "Links a key to a specified keyring, creating the keyring if it does not exist, and returns a status code.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function links a key to a specified keyring and creates the keyring if it does not exist, which contradicts the source code. The implementation actually unlinks a key from a keyring and does not create keyrings; it only looks them up and returns an error if not found. Since the main claims are inaccurate, none align with the source code logic.",
                "The summary incorrectly states that the function links a key to a keyring and may create it if it does not exist. In reality, the source code unlinks a key from a keyring, performs checks for write permissions, handles potential errors from key lookups, and does not create any keyring. This misidentifies the primary purpose and omits critical secondary details such as error handling and key reference cleanup.",
                "The summary claims the function links a key to a specified keyring and creates the keyring if it does not exist, which contradicts the source code. The actual implementation unlinks a key from a keyring and assumes both already exist, performing lookups and returning an error if not found. This is a FATAL inaccuracy affecting the primary purpose and key I/O, providing no accurate or useful insight."
            ]
        }
    }
}
{
    "project_name": "putty",
    "function_addr": 4336,
    "strip_function_name": "sub_10F0",
    "strip_decompiled_code": "unsigned int *__fastcall sub_10F0(__int64 a1)\n{\n  unsigned int *result; // rax\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  void *v6; // rcx\n  __int64 v7; // [rsp-28h] [rbp-40h]\n  __int64 v8; // [rsp-20h] [rbp-38h]\n  __int64 v9; // [rsp-18h] [rbp-30h]\n  __int64 v10; // [rsp-10h] [rbp-28h]\n  __int64 v11; // [rsp-8h] [rbp-20h]\n\n  while ( 1 )\n  {\n    result = (unsigned int *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 16) + 32LL))(\n                               *(_QWORD *)(a1 + 16),\n                               *(_QWORD *)(a1 + 16),\n                               0LL);\n    if ( !result )\n      break;\n    v5 = *result;\n    if ( (_DWORD)v5 != 2 )\n    {\n      if ( (_DWORD)v5 != 4 )\n      {\n        if ( (_DWORD)v5 != 1 )\n          return 0LL;\n        v6 = &loc_11B1;\n        if ( (unsigned int)((_DWORD)result - 1) <= 0xE )\n        {\n          v5 = (int)result;\n          v6 = (void *)*((_QWORD *)&loc_11BD + (int)result);\n        }\n        return (unsigned int *)sub_11CF(*(_QWORD *)(a1 + 88), sub_11CF, v5, v6, (unsigned int)result);\n      }\n      v11 = 4412LL;\n      v10 = 4420LL;\n      v9 = 4431LL;\n      v8 = 4446LL;\n      v7 = 4458LL;\n    }\n    (*(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))(*(_QWORD *)(a1 + 16) + 32LL))(\n      *(_QWORD *)(a1 + 16),\n      *(_QWORD *)(a1 + 16),\n      1LL,\n      v2,\n      v3,\n      v4,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11);\n  }\n  return result;\n}\n",
    "function_name": "ssh2_common_filter_queue",
    "decompiled_code": "bool __fastcall ssh2_common_filter_queue(PacketProtocolLayer *ppl)\n{\n  PktIn *v1; // rax\n  int type; // edx\n  BinarySource *v3; // rbx\n  const char *v4; // rbx\n  __int64 v5; // rdx\n  int v6; // eax\n  __int64 v7; // rax\n  BinarySource *binarysource; // rbx\n  int uint32; // r12d\n  const char *string; // rbx\n  __int64 v11; // rdx\n  int v12; // r8d\n  const char *v13; // rcx\n\n  while ( 1 )\n  {\n    v1 = ppl->in_pq->after(ppl->in_pq, ppl->in_pq, 0LL);\n    if ( !v1 )\n      break;\n    type = v1->type;\n    if ( v1->type != 2 )\n    {\n      if ( type != 4 )\n      {\n        if ( type == 1 )\n        {\n          binarysource = v1->binarysource_;\n          uint32 = BinarySource_get_uint32(v1->binarysource_);\n          string = (const char *)BinarySource_get_string(binarysource);\n          v12 = string_length_for_printf(v11);\n          v13 = \"unknown\";\n          if ( (unsigned int)(uint32 - 1) <= 0xE )\n            v13 = ssh2_disconnect_reasons_9548[uint32];\n          ssh_remote_error(\n            ppl->ssh,\n            \"Remote side sent disconnect message\\ntype %d (%s):\\n\\\"%.*s\\\"\",\n            uint32,\n            v13,\n            v12,\n            string);\n          LOBYTE(v1) = 1;\n        }\n        else\n        {\n          LOBYTE(v1) = 0;\n        }\n        return (char)v1;\n      }\n      v3 = v1->binarysource_;\n      BinarySource_get_bool(v1->binarysource_);\n      v4 = (const char *)BinarySource_get_string(v3);\n      v6 = string_length_for_printf(v5);\n      v7 = dupprintf(\"Remote debug message: %.*s\", v6, v4);\n      logevent_and_free(ppl->logctx, v7);\n    }\n    ppl->in_pq->after((PacketQueueBase *)ppl->in_pq, (PacketQueueNode *)ppl->in_pq, 1);\n  }\n  return (char)v1;\n}\n",
    "source_code": "\nbool ssh2_common_filter_queue(PacketProtocolLayer *ppl)\n{\n    static const char *const ssh2_disconnect_reasons[] = {\n        NULL,\n        \"host not allowed to connect\",\n        \"protocol error\",\n        \"key exchange failed\",\n        \"host authentication failed\",\n        \"MAC error\",\n        \"compression error\",\n        \"service not available\",\n        \"protocol version not supported\",\n        \"host key not verifiable\",\n        \"connection lost\",\n        \"by application\",\n        \"too many connections\",\n        \"auth cancelled by user\",\n        \"no more auth methods available\",\n        \"illegal user name\",\n    };\n\n    PktIn *pktin;\n    ptrlen msg;\n    int reason;\n\n    while ((pktin = pq_peek(ppl->in_pq)) != NULL) {\n        switch (pktin->type) {\n          case SSH2_MSG_DISCONNECT:\n            reason = get_uint32(pktin);\n            msg = get_string(pktin);\n\n            ssh_remote_error(\n                ppl->ssh, \"Remote side sent disconnect message\\n\"\n                \"type %d (%s):\\n\\\"%.*s\\\"\", reason,\n                ((reason > 0 && reason < lenof(ssh2_disconnect_reasons)) ?\n                 ssh2_disconnect_reasons[reason] : \"unknown\"),\n                PTRLEN_PRINTF(msg));\n            /* don't try to pop the queue, because we've been freed! */\n            return true;               /* indicate that we've been freed */\n\n          case SSH2_MSG_DEBUG:\n            /* XXX maybe we should actually take notice of the return value */\n            get_bool(pktin);\n            msg = get_string(pktin);\n            ppl_logevent(\"Remote debug message: %.*s\", PTRLEN_PRINTF(msg));\n            pq_pop(ppl->in_pq);\n            break;\n\n          case SSH2_MSG_IGNORE:\n            /* Do nothing, because we're ignoring it! Duhh. */\n            pq_pop(ppl->in_pq);\n            break;\n\n          default:\n            return false;\n        }\n    }\n\n    return false;\n}",
    "comment": "Processes incoming SSH2 packets, handling disconnect messages, debug messages, and ignores messages, while managing packet queue operations.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "The function reads data from a transport stream , processes it , and stores it in a buffer until no more data is available .\n",
    "cpbcs_sum": "Executes a Lua function with its name and manages the stack trace in the provided context of the sieve node.\n",
    "misum_sum": "Formats and returns a string representation of a Lua state, including its type and indentation to the output.\n",
    "decom_sum": "Processes messages from an object at a1+16, dispatching type\u2011specific handlers and invoking callbacks for message types 1, 2, and 4.",
    "cfg_sum": "Processes events from a context handle, dispatching actions based on event type, and invokes callbacks or terminates when no further events are available.",
    "work_score": {
        "hext5": {
            "summary": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains only mathematical claims about lognormal distributions, which are entirely unrelated to the SSH2 packet handling logic in the source code. None of the statements target or match the source implementation, resulting in 0% accurate claims.",
                "The summary contains only mathematical formulas and descriptions of the lognormal distribution, which are unrelated to the function\u2019s purpose or behavior in the provided source code. It does not capture the primary purpose of processing SSH2 protocol queue messages or any secondary details such as handling disconnect, debug, or ignore messages. All claims are noise relative to the source, resulting in no coverage.",
                "The summary contains only mathematical details about the lognormal distribution, which is entirely unrelated to the SSH packet-handling logic in the source code. All claims are NOISE, with no accurate or relevant information on the function's purpose, inputs, or outputs. This results in overwhelming irrelevance and zero benefit for understanding the source."
            ]
        },
        "bint5": {
            "summary": "The function reads data from a transport stream , processes it , and stores it in a buffer until no more data is available .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function reads data from a transport stream, processes it, and stores it in a buffer until no more data is available. This is inaccurate: the source code shows it processes queued SSH2 protocol packets, handles specific message types, may log events, and can return early on disconnects, but there is no generic transport stream reading or storing to a buffer. The lone claim about buffer storage is not supported, resulting in no accurate claims.",
                "The summary incorrectly describes the function as reading from a transport stream and storing data in a buffer, which does not match the source code. The actual implementation inspects queued packet messages, processes specific SSH2 message types (DISCONNECT, DEBUG, IGNORE), logs or handles them, and returns accordingly. The PRIMARY PURPOSE of handling queued SSH2 protocol messages is missed, and none of the concrete secondary details are captured.",
                "The summary claims the function reads data from a transport stream, processes it, and stores it in a buffer until no more data is available. This is inaccurate because the source code shows it operates on a packet queue, handling specific SSH message types, logging events, and potentially returning early on disconnect without generic buffering. The claim misrepresents the primary purpose and key I/O, constituting a FATAL error that undermines reliability."
            ]
        },
        "cpbcs": {
            "summary": "Executes a Lua function with its name and manages the stack trace in the provided context of the sieve node.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function executes a Lua function by name and manages a stack trace in a sieve node context, but the source code is clearly C code handling SSH2 protocol packet types such as DISCONNECT, DEBUG, and IGNORE. None of the summary's claims align with the actual implementation, so all are inaccurate.",
                "The summary is entirely inaccurate as it describes executing a Lua function and managing a stack trace in a sieve node context, which is unrelated to the source code. The actual function processes incoming SSH2 protocol packets, handling disconnect, debug, and ignore message types, which is neither mentioned nor implied in the summary. It misses the primary purpose and all secondary details.",
                "The summary makes a claim about executing a Lua function and managing a stack trace within a sieve node, which is completely unrelated to the source code. The source code processes SSH2 protocol packets, handling disconnect, debug, and ignore messages, with no Lua execution or stack trace management. This is pure NOISE with no accurate claims, resulting in zero alignment."
            ]
        },
        "misum": {
            "summary": "Formats and returns a string representation of a Lua state, including its type and indentation to the output.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the code formats and returns a string representation of a Lua state, including type and indentation, which is unrelated to the source code. The source code handles SSH2 packet types, processes disconnect, debug, and ignore messages, and does not deal with Lua states or string formatting. All extracted claims are inaccurate, resulting in no alignment with the source implementation.",
                "The summary is entirely inaccurate: it describes formatting and returning a string representation of a Lua state, which has no relation to the source code's purpose of processing incoming SSH2 protocol packets (disconnect, debug, ignore) and handling them accordingly. It misses the primary purpose and all secondary details from the code.",
                "The summary is entirely inaccurate: it describes formatting and returning a Lua state string with type and indentation, which is unrelated to the source code's actual behavior of processing SSH2 protocol messages (disconnect, debug, ignore) from a packet queue. This is a FATAL error as it misrepresents the primary purpose and key I/O of the function."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585589376,
    "strip_function_name": "sub_FFFFFFFF8166E880",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8166E880(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  unsigned __int64 result; // rax\n  __int64 v10; // r8\n  int v11; // r9d\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  _QWORD *v14; // r12\n  int v15; // eax\n  __int64 v16; // r8\n  int v17; // r9d\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  __int64 v20; // r8\n  int v21; // r9d\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  unsigned int v24; // ebx\n\n  result = sub_FFFFFFFF815F7130((__int64)&unk_FFFFFFFF818CA200, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n  v14 = (_QWORD *)result;\n  if ( result > 0xFFFFFFFFFFFFF000LL )\n    return (unsigned int)result;\n  v15 = sub_FFFFFFFF815F8510(result, 0, 255LL, 0LL, v10, v11, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( v15 < 0\n    || (v15 = sub_FFFFFFFF815F8510((__int64)v14, 32766, 254LL, 0LL, v16, v17, a2, a3, a4, a5, v18, v19, a8, a9), v15 < 0)\n    || (v15 = sub_FFFFFFFF815F8510((__int64)v14, 0x7FFF, 253LL, 0LL, v20, v21, a2, a3, a4, a5, v22, v23, a8, a9), v15 < 0) )\n  {\n    v24 = v15;\n    sub_FFFFFFFF815F7720(v14);\n    return v24;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 568) = v14;\n    *(_BYTE *)(a1 + 576) = 0;\n    return 0LL;\n  }\n}\n",
    "function_name": "fib4_rules_init",
    "decompiled_code": "_QWORD *__fastcall fib4_rules_init(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        int a14)\n{\n  _QWORD *result; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  _QWORD *v17; // r12\n  int v18; // eax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // ebx\n\n  result = (_QWORD *)fib_rules_register(fib4_rules_ops_template, a1, a2, a3, a4, a5, a6, a7, a8, a9, a11, a12, a13, a14);\n  v17 = result;\n  if ( (unsigned __int64)result > 0xFFFFFFFFFFFFF000LL )\n    return (_QWORD *)(unsigned int)result;\n  v18 = fib_default_rule_add((__int64)result, 0, 255, 0, a2, a3, a4, a5, v15, v16, a8, a9);\n  if ( v18 < 0\n    || (v18 = fib_default_rule_add((__int64)v17, 32766, 254, 0, a2, a3, a4, a5, v19, v20, a8, a9), v18 < 0)\n    || (v18 = fib_default_rule_add((__int64)v17, 0x7FFF, 253, 0, a2, a3, a4, a5, v19, v20, a8, a9), v18 < 0) )\n  {\n    v21 = v18;\n    fib_rules_unregister(v17, a2, a3, a4, a5, v19, v20, a8, a9);\n    return (_QWORD *)v21;\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 568) = v17;\n    *(_BYTE *)(a1 + 576) = 0;\n    return 0LL;\n  }\n}\n",
    "source_code": "\nint __net_init fib4_rules_init(struct net *net)\n{\n\tint err;\n\tstruct fib_rules_ops *ops;\n\n\tops = fib_rules_register(&fib4_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rules_init(ops);\n\tif (err < 0)\n\t\tgoto fail;\n\tnet->ipv4.rules_ops = ops;\n\tnet->ipv4.fib_has_custom_rules = false;\n\treturn 0;\n\nfail:\n\t/* also cleans all rules already added */\n\tfib_rules_unregister(ops);\n\treturn err;\n}",
    "comment": "Initializes IPv4 fib rules for a specified network, registering operations and setting default rules, or cleaning up on failure.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the IPv4 Forwarding Information Base ( FIB ) and related networking structures for a specified network namespace , handling errors appropriately .\n",
    "cpbcs_sum": "Registers an IPv6 flow table for a network namespace, initializing it, and setting parameters before invoking the registration.\n",
    "misum_sum": "Initializes IP packet mangling for IP packet mangling in the network namespace, allocating necessary tables and handling errors during registration.\n",
    "decom_sum": "Initializes and configures a data structure with multiple parameterized setup calls, storing it in the target object or cleaning up on error.",
    "cfg_sum": "Initializes a data structure with provided parameters, performs three validation checks, releases resources on failure, and stores the structure reference on success.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior related to converting values to a string with printf formatting, static buffers, and hex display based on num_bytes, which is completely unrelated to the source code that initializes IPv4 FIB rules, registers/unregisters rule operations, and sets network structure fields. None of the claims in the summary match the source code semantics, so there are no accurate claims.",
                "The summary describes functionality unrelated to the actual source code, focusing on pointer returns, static buffers, and printf formatting, whereas the source code initializes IPv4 fib rules in a network namespace, registers ops, handles errors, and sets flags. This is a complete semantic mismatch, missing the primary purpose and all critical details.",
                "The summary is entirely unrelated to the source code, describing a function that returns a pointer to a static buffer and performs value conversion with printf formatting, which does not match the actual network-related initialization and rule registration logic in the code. This is pure NOISE with no accurate claims, providing no insight into the code\u2019s actual purpose or behavior."
            ]
        },
        "bint5": {
            "summary": "Initializes the IPv4 Forwarding Information Base ( FIB ) and related networking structures for a specified network namespace , handling errors appropriately .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary claims that the function initializes the IPv4 FIB and related networking structures for a given network namespace with appropriate error handling. This aligns closely with the source code, which registers IPv4 rules, initializes default rules, sets relevant fields in the network namespace, and handles errors. The claim is broad but accurate, with no contradictory statements, indicating high proportion of accurate content.",
                "The summary correctly conveys the primary purpose of initializing IPv4 FIB rules for a given network namespace and notes error handling. However, it misses secondary details such as the registration of fib4_rules_ops_template, the specific handling of IS_ERR and PTR_ERR cases, default rules initialization, the setting of net->ipv4.rules_ops and fib_has_custom_rules, and the cleanup via fib_rules_unregister on failure. These omissions reduce completeness.",
                "The summary states that the function initializes the IPv4 FIB and related networking structures for a network namespace and handles errors. This is broadly accurate but low\u2011info: the code registers IPv4 fib rules, sets default rules, and updates namespace-specific fields, which fits the general description. There are no contradictory or FATAL claims, but the lack of specifics (e.g., fib_rules_register, fib_default_rules_init, cleanup on failure) means the gain is low. The worst failure mode here is low gain from overly generic SAFE claims."
            ]
        },
        "cpbcs": {
            "summary": "Registers an IPv6 flow table for a network namespace, initializing it, and setting parameters before invoking the registration.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the code registers an IPv6 flow table, initializes it, and sets parameters before registration. The source code instead registers IPv4 routing rules using fib_rules_register with fib4_rules_ops_template, followed by default rules initialization and error handling. None of the claims align with the actual IPv4-specific logic, resulting in 0% accurate claims.",
                "The summary incorrectly describes the function as registering an IPv6 flow table, while the source code clearly registers IPv4 routing rules using fib_rules_register with fib4_rules_ops_template. This contradicts the PRIMARY PURPOSE and does not capture any secondary details such as error handling, cleanup on failure, or initialization of fib_has_custom_rules. The response is fully inaccurate and misses all critical semantic units.",
                "The summary's main claim that the function registers an IPv6 flow table is directly contradictory to the source code, which clearly registers IPv4 rules via fib_rules_register and sets IPv4-specific parameters. This is a FATAL inaccuracy targeting the primary purpose and key I/O of the function. There are no accurate claims to offset the error, resulting in a high negative impact and zero net benefit."
            ]
        },
        "misum": {
            "summary": "Initializes IP packet mangling for IP packet mangling in the network namespace, allocating necessary tables and handling errors during registration.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes IP packet mangling and allocates necessary tables, but the source code shows it registers IPv4 FIB rules, initializes default rules, assigns them to the network namespace, and handles errors. The packet mangling claim is inaccurate, and the 'allocating tables' statement is unsupported. Most claims are incorrect, with minimal alignment to actual code semantics.",
                "The summary\u2019s main claim about initializing IP packet mangling and allocating tables is inaccurate because the source code\u2019s primary purpose is to initialize IPv4 routing rules in a network namespace, register them, set default rules, and handle errors. The summary does not correctly convey the function\u2019s semantics, missing the actual focus on fib_rules registration, default rules setup, assignment to net->ipv4.rules_ops, and cleanup on failure. This means the primary purpose is not captured and no secondary details are covered.",
                "The summary claims the function initializes IP packet mangling and allocates tables, which is inaccurate. The source code actually registers IPv4 FIB rules operations for a network namespace and sets up default rules, not packet mangling. This is a FATAL error affecting the primary purpose and key semantics, as it misrepresents the core functionality. There are no accurate, high-gain details to offset this misinformation."
            ]
        }
    }
}
{
    "project_name": "sqlite",
    "function_addr": 173008,
    "strip_function_name": "sub_2A3D0",
    "strip_decompiled_code": "__int64 __fastcall sub_2A3D0(\n        __int16 a1,\n        __int16 a2,\n        unsigned __int16 a3,\n        unsigned __int16 a4,\n        _QWORD *a5,\n        __int16 a6,\n        __int16 a7,\n        unsigned __int16 a8,\n        unsigned __int16 a9,\n        __int64 *a10)\n{\n  int v11; // edx\n  int v12; // r10d\n  __int64 v13; // rdi\n  __int64 *v14; // rsi\n  __int64 v15; // r8\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rcx\n\n  if ( a3 - a4 >= a8 - a9 || a4 < a9 || a1 >= a6 && (a1 > a6 || a2 > a7) )\n    return 0LL;\n  v11 = a3 - 1;\n  if ( v11 != -1 )\n  {\n    v12 = a8 - 1;\n    v13 = 8LL * v12;\n    v14 = (__int64 *)(*a5 + 8LL * v11);\n    v15 = (__int64)&v14[-v11 - 1];\n    while ( 1 )\n    {\n      v16 = *v14;\n      if ( *v14 )\n      {\n        if ( !a8 )\n          return 0LL;\n        v17 = *a10;\n        if ( v16 != *(_QWORD *)(*a10 + 8LL * v12) )\n          break;\n      }\nLABEL_17:\n      if ( --v14 == (__int64 *)v15 )\n        return 1LL;\n    }\n    v18 = v17 + v13 - 8;\n    v19 = v17 + v13 - 8 - 8LL * (unsigned int)v12;\n    while ( v18 != v19 )\n    {\n      v18 -= 8LL;\n      if ( v16 == *(_QWORD *)(v18 + 8) )\n        goto LABEL_17;\n    }\n    return 0LL;\n  }\n  return 1LL;\n}\n",
    "function_name": "whereLoopCheaperProperSubset",
    "decompiled_code": "__int64 __fastcall whereLoopCheaperProperSubset(\n        const WhereLoop *pX,\n        const WhereLoop *pY,\n        unsigned __int16 a3,\n        unsigned __int16 a4,\n        _QWORD *a5,\n        __int16 a6,\n        __int64 a7,\n        __int64 a8,\n        unsigned __int16 a9,\n        __int64 *a10)\n{\n  int v11; // edx\n  int v12; // r10d\n  __int64 v13; // rdi\n  __int64 *v14; // rsi\n  __int64 v15; // r8\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // rax\n  __int64 v19; // rcx\n\n  if ( a3 - a4 >= (unsigned __int16)a8 - a9\n    || a4 < a9\n    || (__int16)pX >= a6 && ((__int16)pX > a6 || (__int16)pY > (__int16)a7) )\n  {\n    return 0LL;\n  }\n  v11 = a3 - 1;\n  if ( v11 != -1 )\n  {\n    v12 = (unsigned __int16)a8 - 1;\n    v13 = 8LL * v12;\n    v14 = (__int64 *)(*a5 + 8LL * v11);\n    v15 = (__int64)&v14[-v11 - 1];\n    while ( 1 )\n    {\n      v16 = *v14;\n      if ( *v14 )\n      {\n        if ( !(_WORD)a8 )\n          return 0LL;\n        v17 = *a10;\n        if ( v16 != *(_QWORD *)(*a10 + 8LL * v12) )\n          break;\n      }\nLABEL_17:\n      if ( --v14 == (__int64 *)v15 )\n        return 1LL;\n    }\n    v18 = v17 + v13 - 8;\n    v19 = v17 + v13 - 8 - 8LL * (unsigned int)v12;\n    while ( v18 != v19 )\n    {\n      v18 -= 8LL;\n      if ( v16 == *(_QWORD *)(v18 + 8) )\n        goto LABEL_17;\n    }\n    return 0LL;\n  }\n  return 1LL;\n}\n",
    "source_code": "static int whereLoopCheaperProperSubset(\n  const WhereLoop *pX,       /* First WhereLoop to compare */\n  const WhereLoop *pY        /* Compare against this WhereLoop */\n){\n  int i, j;\n  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){\n    return 0; /* X is not a subset of Y */\n  }\n  if( pY->nSkip > pX->nSkip ) return 0;\n  if( pX->rRun >= pY->rRun ){\n    if( pX->rRun > pY->rRun ) return 0;    /* X costs more than Y */\n    if( pX->nOut > pY->nOut ) return 0;    /* X costs more than Y */\n  }\n  for(i=pX->nLTerm-1; i>=0; i--){\n    if( pX->aLTerm[i]==0 ) continue;\n    for(j=pY->nLTerm-1; j>=0; j--){\n      if( pY->aLTerm[j]==pX->aLTerm[i] ) break;\n    }\n    if( j<0 ) return 0;  /* X not a subset of Y since term X[i] not used by Y */\n  }\n  return 1;  /* All conditions meet */\n}",
    "comment": "Determines if WhereLoop `pX` is a proper subset of WhereLoop `pY` based on terms, costs, and skip values.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Adds a new rule to a list if it falls within the specified interval defined by start and end points .\n",
    "cpbcs_sum": "Searches for a specified offset within a multi-precision range of a multi-precision number, using binary search and returns the value of the first operand.\n",
    "misum_sum": "Finds the nearest source node in a given destination buffer for a specified direction and updates the skip range accordingly.\n",
    "decom_sum": "Checks coordinate bounds and verifies matching 64\u2011bit entries between two grids before confirming a valid position intersection.",
    "cfg_sum": "Validates index bounds and iteratively checks pointer-referenced entries for matching values to ensure structured data consistency before returning a success or failure status.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes string processing involving control characters, escape sequences, and Unicode display handling, which is completely unrelated to the source code's logic for comparing WhereLoop structures to determine subset and cost conditions. None of the factual claims in the summary match or align with the source code, resulting in no accurate claims.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display are entirely unrelated to the actual source code, which compares two WhereLoop objects to determine if one is a cheaper proper subset of the other. None of the stated behaviors match the primary purpose or secondary details of the function, resulting in complete misalignment.",
                "All claims in the summary are unrelated to the actual function, which compares two WhereLoop structures for subset and cost criteria. The summary describes string manipulation, control character escaping, and Unicode conversion, none of which exist in the source code. This is pure NOISE with no accurate claims, resulting in zero alignment."
            ]
        },
        "bint5": {
            "summary": "Adds a new rule to a list if it falls within the specified interval defined by start and end points .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function adds a new rule based on a start/end interval, which does not align with the source code. The source code compares two WhereLoop objects to determine if one is a proper cheaper subset of the other, with no logic related to intervals, start/end points, or adding rules. This makes the single claim entirely inaccurate according to the evaluation steps.",
                "The summary claims the function adds a new rule within a specified interval, which does not align with the source code. The source implements a comparison between two WhereLoop structures to determine if one is a cheaper proper subset of the other, with checks on term counts, skip values, run cost, output count, and term inclusion. The provided description misses the primary purpose and all secondary details, making it entirely inaccurate.",
                "The summary claims the function adds a new rule within a specified interval, which is not present in the source code. The source code compares two WhereLoop structures to determine if one is a cheaper proper subset of the other. This is a FATAL inaccuracy targeting the primary purpose and key logic, leading to highly misleading information with no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Searches for a specified offset within a multi-precision range of a multi-precision number, using binary search and returns the value of the first operand.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims describe searching for a specified offset in a multi-precision number using binary search and returning the first operand's value, which is entirely unrelated to the source code's logic for comparing two WhereLoop structures to determine if one is a cheaper proper subset of the other. None of the claims match the source implementation, so there is 0% accuracy.",
                "The summary describes searching for an offset in a multi-precision number using binary search, which is unrelated to the source code. The source code compares two WhereLoop structures to determine if one is a cheaper proper subset of the other, with specific checks on terms, skips, run cost, and output size. The summary misses the primary purpose and all secondary details, and contains entirely inaccurate claims.",
                "The summary's claim about searching for a specified offset in a multi-precision number via binary search does not match the source code\u2019s actual purpose of comparing two WhereLoop structures to determine if one is a cheaper proper subset of the other. This is a clear FATAL error targeting the primary purpose and I/O, leading to unreliable guidance with no accurate insights."
            ]
        },
        "misum": {
            "summary": "Finds the nearest source node in a given destination buffer for a specified direction and updates the skip range accordingly.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes claims about finding the nearest source node in a destination buffer and updating a skip range, which are not related to the actual code\u2019s logic. The source code compares two WhereLoop structures to determine if one is a cheaper proper subset of the other, using conditions on term counts, skip values, run costs, and output size. None of the summary\u2019s claims match or align with the source implementation, resulting in no accurate claims.",
                "The summary describes finding a nearest source node in a destination buffer and updating a skip range, which is unrelated to the actual function logic. The source code compares two WhereLoop objects to determine if the first is a cheaper proper subset of the second using term counts, skip counts, run cost, output count, and matched terms. The summary misses the primary purpose and all key secondary details, making it inaccurate.",
                "The summary claims the function finds the nearest source node in a destination buffer for a specified direction and updates a skip range, which is completely unrelated to the actual implementation. The source code compares two WhereLoop structures to determine if one is a cheaper proper subset of the other based on term counts, skip counts, run cost, output count, and matching terms. This is a FATAL error affecting the primary purpose and key logic, leaving no accurate claims and making the summary misleading."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582135650,
    "strip_function_name": "sub_FFFFFFFF81323562",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81323562(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 *v8; // rbx\n  __int64 result; // rax\n  _WORD *v10; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  _WORD *v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  _WORD *v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n\n  v8 = qword_FFFFFFFF81E9EAC0;\n  while ( 1 )\n  {\n    if ( !*v8 )\n    {\n      result = sub_FFFFFFFF812FBA00(a1, a2, a3, a4, a5, a6, a7, a8, 1LL, 1, v8);\n      v8[2] = 0LL;\n      *((_DWORD *)v8 + 2) = 0;\n      if ( (_DWORD)result )\n        break;\n    }\n    v8 += 3;\n    if ( &byte_FFFFFFFF81E9EB80 == (char *)v8 )\n    {\n      v10 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, a5, a6, a7, a8);\n      if ( !v10 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA80 = (__int64)v10;\n      *v10 = 0;\n      v13 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, v11, v12, a7, a8);\n      if ( !v13 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA78 = (__int64)v13;\n      *v13 = 0;\n      v16 = (_WORD *)sub_FFFFFFFF81323534(a1, a2, a3, a4, v14, v15, a7, a8);\n      if ( !v16 )\n        return 4LL;\n      qword_FFFFFFFF81E9EA70 = (__int64)v16;\n      *v16 = 0;\n      result = sub_FFFFFFFF812FBA00(a1, a2, a3, a4, v17, v18, a7, a8, 1LL, 1, &qword_FFFFFFFF81E9EA68);\n      if ( !(_DWORD)result )\n        return sub_FFFFFFFF81323160((__int64)&unk_FFFFFFFF81E9EA50, a1, a2, a3, a4, v19, v20, a7, a8);\n      return result;\n    }\n  }\n  return result;\n}\n",
    "function_name": "acpi_ut_mutex_initialize",
    "decompiled_code": "__int64 __fastcall acpi_ut_mutex_initialize(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 *v8; // rbx\n  __int64 result; // rax\n  __int64 *constprop_0; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 *v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 *v16; // rax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n\n  v8 = acpi_gbl_mutex_info;\n  while ( 1 )\n  {\n    if ( !*v8 )\n    {\n      result = acpi_os_create_semaphore(a1, a2, a3, a4, a5, a6, a7, a8, 1LL, 1, (__int64 **)v8);\n      v8[2] = 0LL;\n      *((_DWORD *)v8 + 2) = 0;\n      if ( (_DWORD)result )\n        break;\n    }\n    v8 += 3;\n    if ( &acpi_gbl_integer_nybble_width == (char *)v8 )\n    {\n      constprop_0 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, a5, a6, a7, a8);\n      if ( !constprop_0 )\n        return 4LL;\n      acpi_gbl_gpe_lock = (__int64)constprop_0;\n      *(_WORD *)constprop_0 = 0;\n      v13 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, v11, v12, a7, a8);\n      if ( !v13 )\n        return 4LL;\n      acpi_gbl_hardware_lock = (__int64)v13;\n      *(_WORD *)v13 = 0;\n      v16 = acpi_os_allocate_constprop_0(a1, a2, a3, a4, v14, v15, a7, a8);\n      if ( !v16 )\n        return 4LL;\n      acpi_gbl_reference_count_lock = (__int64)v16;\n      *(_WORD *)v16 = 0;\n      result = acpi_os_create_semaphore(a1, a2, a3, a4, v17, v18, a7, a8, 1LL, 1, (__int64 **)&acpi_gbl_osi_mutex);\n      if ( !(_DWORD)result )\n        return acpi_ut_create_rw_lock((__int64)acpi_gbl_namespace_rw_lock, a1, a2, a3, a4, v19, v20, a7, a8);\n      return result;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nacpi_status acpi_ut_mutex_initialize(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_initialize);\n\n\t/* Create each of the predefined mutex objects */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tstatus = acpi_ut_create_mutex(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t/* Create the spinlocks for use at interrupt level or for speed */\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_gpe_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_hardware_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_reference_count_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Mutex for _OSI support */\n\n\tstatus = acpi_os_create_mutex(&acpi_gbl_osi_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Create the reader/writer lock for namespace access */\n\n\tstatus = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_ACPI_STATUS(status);\n}",
    "comment": "Initializes predefined mutexes and locks for synchronization, including mutexes for _OSI support and a reader/writer lock for namespace access.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the ACPI processor routing table , ensuring no duplicate tables for the same module are registered , while ensuring thread safety with mutexes .\n",
    "cpbcs_sum": "Initializes ACPI table management by allocating an array, setting dimensions, and executing callbacks for the global root table list.\n",
    "misum_sum": "Initializes the ACPI table management by allocating memory, registering the device and setting up sysfs, while handling potential memory allocation errors.\n",
    "decom_sum": "Initializes multiple global buffers and performs sequential data setup until successful, then proceeds with additional parameterized processing or returns an error code.",
    "cfg_sum": "Initializes and allocates required data structures, clears status flags, executes setup routines, and runs critical operations, returning appropriate success or failure codes.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes behavior involving returning a pointer to a static buffer, value conversion via printf formatting, and byte limits with hex output, none of which are present in the source code. The actual implementation initializes various mutexes and locks without any conversion or buffer-return logic, making all claims inaccurate.",
                "The summary's claims about returning a pointer to a static buffer, conversion based on printf formatting characters, and byte count rules have no relation to the source code, which initializes mutexes and locks for ACPI. None of the claims match the primary purpose or any secondary details of the source, making the description entirely inaccurate.",
                "The summary's claims about returning a pointer to a static buffer, performing value conversion based on a printf formatting character, and using hex when num_bytes is non-zero are entirely unrelated to the source code, which initializes multiple mutexes and locks without any value conversion or static buffer return. All claims are NOISE, overwhelming accurate content and providing zero insight into the actual function."
            ]
        },
        "bint5": {
            "summary": "Initializes the ACPI processor routing table , ensuring no duplicate tables for the same module are registered , while ensuring thread safety with mutexes .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function initializes the ACPI processor routing table and prevents duplicate table registration, which are not present in the source code. The source code actually initializes various mutexes, spinlocks, and locks related to ACPI, ensuring thread safety but without any reference to processor routing tables or duplicate checks. Only the mention of thread safety with mutexes aligns loosely with the code, making most claims inaccurate.",
                "The summary incorrectly states that the function initializes an ACPI processor routing table and handles duplicate table registration, which is not present in the source. The actual code initializes various ACPI mutexes, spinlocks, and other locks, with error handling at each step. The claim about thread safety via mutexes is broadly accurate, but the PRIMARY PURPOSE is misrepresented, and most secondary details such as specific locks created are missed.",
                "The summary contains a major factual error: it describes initialization of an ACPI processor routing table and duplicate table checks, which are not present in the source code. The actual function initializes various ACPI-related mutexes, spinlocks, and a reader/writer lock, with no mention of routing tables or module registration. While the mention of thread safety via mutexes is broadly accurate, the core purpose is misrepresented, making this a FATAL error on the primary purpose."
            ]
        },
        "cpbcs": {
            "summary": "Initializes ACPI table management by allocating an array, setting dimensions, and executing callbacks for the global root table list.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about initializing ACPI table management, allocating an array, setting dimensions, and executing callbacks for the global root table list do not match the source code, which initializes mutexes, spinlocks, and locks for ACPI synchronization. None of the claims accurately reflect the functions and logic implemented in the provided code, resulting in no accurate alignment with the source.",
                "The summary incorrectly describes ACPI table management involving array allocation, dimension setting, and callbacks, which is unrelated to the source function. The source code's primary purpose is to initialize mutexes and locks for ACPI, with error handling for each creation step. The summary misses the primary purpose and all secondary details, making it inaccurate and non-aligned.",
                "The summary is entirely inaccurate: it describes ACPI table management, array allocation, and callbacks for a global root table list, none of which occurs in the source code. The actual function initializes various mutexes and locks for ACPI, not table structures. This is a FATAL error targeting the primary purpose, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Initializes the ACPI table management by allocating memory, registering the device and setting up sysfs, while handling potential memory allocation errors.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes ACPI table management tasks such as memory allocation, device registration, and sysfs setup, which are not present in the source code. The source code actually initializes various mutexes, spinlocks, and a reader/writer lock. None of the claims in the summary match the implementation, resulting in all claims being inaccurate.",
                "The summary is entirely inaccurate as it describes initializing ACPI table management, memory allocation, device registration, and sysfs setup, whereas the source code initializes ACPI mutexes, spinlocks, and reader/writer locks with error handling. It misses the primary purpose and all critical semantics of the actual function.",
                "The summary's claims focus on ACPI table management, memory allocation, device registration, and sysfs setup, none of which occur in the source code. The actual code initializes mutexes and locks for ACPI, handling errors via status checks. These contradictions represent FATAL inaccuracies on the primary purpose and key actions, resulting in high negative impact with no accurate claims."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071581323728,
    "strip_function_name": "sub_FFFFFFFF8125D1D0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF8125D1D0(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // rbx\n  __int64 v12; // r14\n  unsigned __int64 v13; // rbx\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  __int64 v17; // r8\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 v21; // rax\n  volatile signed __int32 *v22; // rdi\n\n  v11 = *a3;\n  *a3 = 0LL;\n  v12 = *(_QWORD *)(a1 + 152);\n  v13 = v11 & 0xFFFFFFFFFFFFFFFELL;\n  _InterlockedIncrement((volatile signed __int32 *)a2);\n  v14 = sub_FFFFFFFF81083DC0();\n  *(_QWORD *)(a2 + 96) = v14;\n  *(_QWORD *)(a1 + 96) = v14;\n  if ( v13 )\n  {\n    *(_QWORD *)(v13 + 8LL * *(unsigned __int16 *)(v13 + 20) + 24) = a2;\n    *(_QWORD *)(a1 + 152) = v13;\n    if ( v12 )\n      sub_FFFFFFFF810BA6C0((_QWORD *)v12, (__int64)sub_FFFFFFFF8125C4B0, v15, v16, v17, v18);\n  }\n  else\n  {\n    v21 = *(unsigned __int16 *)(v12 + 20);\n    if ( (unsigned __int16)v21 < *(_WORD *)(v12 + 18) )\n    {\n      v22 = *(volatile signed __int32 **)(v12 + 8 * v21 + 24);\n      *(_QWORD *)(v12 + 8LL * *(unsigned __int16 *)(v12 + 20) + 24) = a2;\n      sub_FFFFFFFF8125B5F0(v22, a4, a5, a6, a7, v19, v20, a10, a11, a2, v15, v16, v17, v18);\n    }\n    else\n    {\n      *(_QWORD *)(v12 + 8 * v21 + 24) = a2;\n      ++*(_WORD *)(v12 + 18);\n    }\n  }\n}\n",
    "function_name": "__key_link",
    "decompiled_code": "void __fastcall _key_link(\n        __int64 a1,\n        __int64 a2,\n        __int64 *a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // rbx\n  __int64 v12; // r14\n  unsigned __int64 v13; // rbx\n  __int64 v14; // rax\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  __int64 v17; // rax\n  volatile signed __int32 *v18; // rdi\n\n  v11 = *a3;\n  *a3 = 0LL;\n  v12 = *(_QWORD *)(a1 + 152);\n  v13 = v11 & 0xFFFFFFFFFFFFFFFELL;\n  _InterlockedIncrement((volatile signed __int32 *)a2);\n  v14 = current_kernel_time();\n  *(_QWORD *)(a2 + 96) = v14;\n  *(_QWORD *)(a1 + 96) = v14;\n  if ( v13 )\n  {\n    *(_QWORD *)(v13 + 8LL * *(unsigned __int16 *)(v13 + 20) + 24) = a2;\n    *(_QWORD *)(a1 + 152) = v13;\n    if ( v12 )\n      call_rcu_sched((_QWORD *)v12, (__int64)keyring_unlink_rcu_disposal, a4, a5, a6, a7, v15, v16, a10, a11);\n  }\n  else\n  {\n    v17 = *(unsigned __int16 *)(v12 + 20);\n    if ( (unsigned __int16)v17 < *(_WORD *)(v12 + 18) )\n    {\n      v18 = *(volatile signed __int32 **)(v12 + 8 * v17 + 24);\n      *(_QWORD *)(v12 + 8LL * *(unsigned __int16 *)(v12 + 20) + 24) = a2;\n      key_put(v18, a4, a5, a6, a7, v15, v16, a10, a11);\n    }\n    else\n    {\n      *(_QWORD *)(v12 + 8 * v17 + 24) = a2;\n      ++*(_WORD *)(v12 + 18);\n    }\n  }\n}\n",
    "source_code": "void __key_link(struct key *keyring, struct key *key,\n\t\tunsigned long *_prealloc)\n{\n\tstruct keyring_list *klist, *nklist;\n\tstruct key *discard;\n\n\tnklist = (struct keyring_list *)(*_prealloc & ~KEY_LINK_FIXQUOTA);\n\t*_prealloc = 0;\n\n\tkenter(\"%d,%d,%p\", keyring->serial, key->serial, nklist);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\n\tatomic_inc(&key->usage);\n\tkeyring->last_used_at = key->last_used_at =\n\t\tcurrent_kernel_time().tv_sec;\n\n\t/* there's a matching key we can displace or an empty slot in a newly\n\t * allocated list we can fill */\n\tif (nklist) {\n\t\tkdebug(\"reissue %hu/%hu/%hu\",\n\t\t       nklist->delkey, nklist->nkeys, nklist->maxkeys);\n\n\t\tRCU_INIT_POINTER(nklist->keys[nklist->delkey], key);\n\n\t\trcu_assign_pointer(keyring->payload.subscriptions, nklist);\n\n\t\t/* dispose of the old keyring list and, if there was one, the\n\t\t * displaced key */\n\t\tif (klist) {\n\t\t\tkdebug(\"dispose %hu/%hu/%hu\",\n\t\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\t\t\tcall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\n\t\t}\n\t} else if (klist->delkey < klist->nkeys) {\n\t\tkdebug(\"replace %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tdiscard = rcu_dereference_protected(\n\t\t\tklist->keys[klist->delkey],\n\t\t\trwsem_is_locked(&keyring->sem));\n\t\trcu_assign_pointer(klist->keys[klist->delkey], key);\n\t\t/* The garbage collector will take care of RCU\n\t\t * synchronisation */\n\t\tkey_put(discard);\n\t} else {\n\t\t/* there's sufficient slack space to append directly */\n\t\tkdebug(\"append %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tRCU_INIT_POINTER(klist->keys[klist->delkey], key);\n\t\tsmp_wmb();\n\t\tklist->nkeys++;\n\t}\n}",
    "comment": "Links a key to a keyring, replacing an existing key if necessary, while managing memory and usage references appropriately.",
    "hext5_sum": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
    "bint5_sum": "Removes a key from a keyring by decrementing its reference count , removing it from the keyring list , and freeing the associated memory .\n",
    "cpbcs_sum": "Appends a message to a new keyring structure, updating timestamps, and managing reference counts for the old one or incrementing garbage collection accordingly.\n",
    "misum_sum": "Links a new keyring to a keyring by creating a new keyring and updating the old name and name.\n",
    "decom_sum": "Updates linked data structures with a new object reference, increments its counter, and initializes or chains it into an existing indexed structure.",
    "cfg_sum": "Updates linked object references and counters, initializes shared state, and conditionally processes or queues an entry into a collection based on index limits.",
    "work_score": {
        "hext5": {
            "summary": "generate a reloc when linking an elf file. this is a reloc requested by the linker, and does not come from any input file. this is used to build constructor and destructor tables when linking with -ur.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about ELF file linking, relocations, and constructor/destructor tables are unrelated to the source code, which implements key linking in a kernel keyring structure using RCU operations and atomic counters. None of the claims match the actual semantics of the function, making them inaccurate.",
                "The summary describes relocation handling in ELF file linking, which is unrelated to the provided source code. The source function manages linking a key into a keyring, handling preallocation, replacing or appending keys, and updating metadata, none of which match the relocation or linker behavior described. The summary's claims are therefore inaccurate with respect to the code and do not capture the primary purpose or any secondary details.",
                "The summary's claims about generating relocations when linking ELF files and building constructor/destructor tables with -ur do not align with the provided source code, which pertains to linking keys into a keyring structure in the kernel. All claims are unrelated to the actual code semantics, causing overwhelming NOISE and providing no accurate or relevant insights."
            ]
        },
        "bint5": {
            "summary": "Removes a key from a keyring by decrementing its reference count , removing it from the keyring list , and freeing the associated memory .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function removes a key by decrementing its reference count, removing it from the list, and freeing memory. In contrast, the source code shows it increments the key's usage count, assigns the key into the keyring list in various scenarios, and schedules disposal for displaced keys via RCU, not explicitly freeing memory directly. All claims in the summary contradict the actual semantics, resulting in no accurate matches.",
                "The summary incorrectly states that the function removes a key from a keyring by decrementing its reference count and freeing memory. In reality, the source code increases the key's usage count, updates timestamps, and links or replaces keys in the keyring list while deferring disposal via RCU calls. The stated removal and freeing behavior contradicts the observed implementation, failing to capture the primary purpose of linking/replacing keys and missing all secondary details.",
                "The summary is inaccurate because it describes removing a key from a keyring by decrementing the reference count and freeing memory, while the source code actually links or replaces a key in the keyring list, incrementing its usage count and managing old list disposal via RCU. This contradicts the primary purpose and key side effects, making it a FATAL error."
            ]
        },
        "cpbcs": {
            "summary": "Appends a message to a new keyring structure, updating timestamps, and managing reference counts for the old one or incrementing garbage collection accordingly.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains multiple inaccuracies: it refers to 'appending a message' instead of linking a key object, and describes 'incrementing garbage collection' rather than calling key_put on a displaced key. While it somewhat matches the source in mentioning timestamp updates and reference count management, over half of its claims misrepresent core semantics of the function.",
                "The summary incorrectly describes the function as appending a message to a new keyring, which contradicts the source code's actual purpose of linking a key to a keyring list while managing references, timestamps, and replacement/appending logic. While it vaguely mentions updating timestamps and reference counts, it omits critical branching details (handling nklist, replacement vs append cases, disposal of displaced keys) and misidentifies the primary purpose. This results in missing both primary purpose and key secondary behaviors.",
                "The summary contains several inaccuracies: it describes appending a message, which contradicts the code\u2019s actual function of linking a key into a keyring list; it misrepresents the data structure and operations, omitting details about conditional replacement, appending, and RCU-based disposal. These errors target the primary purpose and core I/O semantics, making them fatal. No accurate, high-info claims are present to offset the misinformation."
            ]
        },
        "misum": {
            "summary": "Links a new keyring to a keyring by creating a new keyring and updating the old name and name.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary states that the function links a new keyring to a keyring by creating a new keyring and updating the old name, which does not align with the source code. The source actually links a key to a keyring, possibly replacing or appending within the keyring list, and updates usage and timestamps, with no operations involving creation of a keyring or modification of names. All claims are inaccurate relative to the function\u2019s semantics.",
                "The summary is inaccurate because it describes linking a new keyring to a keyring and updating names, which contradicts the source code's actual behavior. The function links a key into an existing keyring, handles preallocated keyring lists, replaces or appends keys, updates usage counts and timestamps, and manages displaced keys using RCU disposal. There is no creation of a new keyring or name updates, so the primary purpose is missed and no secondary details are captured.",
                "The summary claims the function links a new keyring to a keyring by creating a new keyring and updating names. This is inaccurate because the source code does not create a new keyring or update any name fields; instead, it links a key to an existing keyring's data structures, managing slots and lists. This is a FATAL error affecting the primary purpose and semantics of the function, providing no accurate or useful information."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 599168,
    "strip_function_name": "sub_92480",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_92480(\n        __int64 a1,\n        char *p_buf,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        double a7,\n        double a8,\n        __m128 a9,\n        __m128 a10)\n{\n  __int64 v10; // rbp\n  __int64 *v11; // rbx\n  __int64 v12; // r12\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  _QWORD *v19; // rax\n  _QWORD *v20; // rdx\n  char buf; // [rsp+7h] [rbp-21h] BYREF\n  unsigned __int64 v23; // [rsp+8h] [rbp-20h]\n\n  v10 = *(_QWORD *)a1;\n  v23 = __readfsqword(0x28u);\n  if ( (*(_BYTE *)(v10 + 226) & 1) != 0\n    || (*(_BYTE *)(*(_QWORD *)(v10 + 8) + 9LL) & 4) != 0\n    || (p_buf = &buf, (unsigned int)recv(*(_DWORD *)(v10 + 24), &buf, 1uLL, 2) != -1)\n    || *__errno_location() != 11\n    || (*(_BYTE *)(a1 + 8) &= ~0x20u, p_buf = 0LL, ngx_handle_read_event(*(_QWORD *)(v10 + 8), 0LL)) )\n  {\n    v11 = *(__int64 **)v10;\n    v12 = **(_QWORD **)v10;\n    ngx_destroy_pool(*(_QWORD **)(v10 + 88));\n    ngx_close_connection(v10, a3, a4, a5, a6, v17, v18, a9, a10, (__int64)p_buf, v13, v14, v15, v16);\n    v19 = (_QWORD *)v11[2];\n    *v19 = v11[1];\n    *(_QWORD *)(v11[1] + 8) = v19;\n    v20 = *(_QWORD **)(v12 + 48);\n    v11[2] = (__int64)v20;\n    *v20 = v11 + 1;\n    v11[1] = v12 + 40;\n    *(_QWORD *)(v12 + 48) = v11 + 1;\n  }\n  return __readfsqword(0x28u) ^ v23;\n}\n",
    "function_name": "ngx_http_upstream_keepalive_close_handler",
    "decompiled_code": "void __fastcall ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)\n{\n  ngx_connection_t *data; // rbp\n  ngx_pool_t *v2; // rbx\n  __int64 v3; // r12\n  ngx_pool_t *next; // rax\n  u_char ***v5; // rdx\n  char buf[1]; // [rsp+7h] [rbp-21h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  data = (ngx_connection_t *)ev->data;\n  v7 = __readfsqword(0x28u);\n  if ( (*((_BYTE *)data + 226) & 1) != 0\n    || (*((_BYTE *)data->read + 9) & 4) != 0\n    || (unsigned int)recv(data->fd, buf, 1uLL, 2) != -1\n    || *__errno_location() != 11\n    || (*((_BYTE *)ev + 8) &= ~0x20u, ngx_handle_read_event(data->read, 0LL)) )\n  {\n    v2 = (ngx_pool_t *)data->data;\n    v3 = *(_QWORD *)data->data;\n    ngx_destroy_pool(data->pool);\n    ngx_close_connection(data);\n    next = v2->d.next;\n    next->d.last = v2->d.end;\n    *((_QWORD *)v2->d.end + 1) = next;\n    v5 = *(u_char ****)(v3 + 48);\n    v2->d.next = (ngx_pool_t *)v5;\n    *v5 = &v2->d.end;\n    v2->d.end = (u_char *)(v3 + 40);\n    *(_QWORD *)(v3 + 48) = &v2->d.end;\n  }\n}\n",
    "source_code": "\n\nstatic void\nngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)\n{\n    ngx_http_upstream_keepalive_srv_conf_t  *conf;\n    ngx_http_upstream_keepalive_cache_t     *item;\n\n    int                n;\n    char               buf[1];\n    ngx_connection_t  *c;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,\n                   \"keepalive close handler\");\n\n    c = ev->data;\n\n    if (c->close || c->read->timedout) {\n        goto close;\n    }\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {\n        ev->ready = 0;\n\n        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n            goto close;\n        }\n\n        return;\n    }\n\nclose:\n\n    item = c->data;\n    conf = item->conf;\n\n    ngx_http_upstream_keepalive_close(c);\n\n    ngx_queue_remove(&item->queue);\n    ngx_queue_insert_head(&conf->free, &item->queue);\n}",
    "comment": "Closes an upstream keepalive connection, handling read timeouts and queue management for connection reuse.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Appends a string to a dynamic buffer , ensuring it is null-terminated and handling potential errors during the write process .\n",
    "cpbcs_sum": "Flushes the file buffer to the archive, destroys it if necessary, and removes the file from the archive, logging the operation.\n",
    "misum_sum": "The function Flushes a file descriptor either using an I/O or IO file descriptor based on the cache's mode.\n",
    "decom_sum": "Handles connection read events by checking socket state, receiving a byte, and closing and cleaning up the connection if specific conditions are met.",
    "cfg_sum": "Handles socket read errors or closure conditions by cleaning up resources, closing the connection, and updating internal linked list pointers.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a single vague claim about pushing a pointer type, which does not match or describe the source code's behavior involving event handling, connection closing, and queue operations. This claim is unrelated to the actual semantics, making it inaccurate and resulting in no accurate claims.",
                "The summary is vague and unrelated to the source code\u2019s actual functionality. It does not capture the primary purpose of handling upstream keepalive connection closure or any secondary details such as reading events, error handling, or queue management. This is pure noise with no factual alignment to the code.",
                "The summary contains a vague and unrelated statement ('push a pointer type') that does not match any specific behavior or semantics in the source code. This is pure NOISE with no accurate claims, offering no insight into the function\u2019s purpose or I/O. The lack of alignment and absence of relevant details yield zero informational value."
            ]
        },
        "bint5": {
            "summary": "Appends a string to a dynamic buffer , ensuring it is null-terminated and handling potential errors during the write process .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes appending a string to a dynamic buffer with null-termination and error handling, which is unrelated to the provided source code. The source code instead handles closing an upstream keepalive connection, checking timeouts, peeking at socket data, and managing queues. All claims in the summary are inaccurate as they do not match any part of the source implementation.",
                "The summary describes appending a string to a dynamic buffer with null-termination and error handling, which does not align at all with the source code. The source implements a keepalive close handler for upstream connections, handling read timeouts, socket peeking, event readiness, and connection cleanup via queue operations. The summary entirely misses the primary purpose and critical details, making it inaccurate and unrelated.",
                "The summary makes a specific claim about appending a string to a dynamic buffer with null-termination and error handling, but the source code is a network connection close handler for upstream keepalive, with no buffer appending or string manipulation logic. This is a FATAL inaccuracy targeting the primary purpose and key I/O of the function, making the content unreliable despite no accurate claims present."
            ]
        },
        "cpbcs": {
            "summary": "Flushes the file buffer to the archive, destroys it if necessary, and removes the file from the archive, logging the operation.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes operations like flushing a file buffer to an archive, destroying it, and removing a file, which do not match the source code's actual logic. The function in the source handles closing an upstream keepalive connection, checking for timeouts or readiness, invoking a close routine, and managing a connection cache queue, none of which involve file buffers or archives. All claims are inaccurate and unrelated to the code.",
                "The summary's claims about flushing a file buffer, destroying it, and removing a file from an archive are completely unrelated to the source code, which handles closing an upstream keepalive connection, managing event readiness, and queue updates. It misses the primary purpose and all secondary implementation details, making all claims inaccurate according to the evaluation steps.",
                "The summary claims the function flushes a file buffer to an archive, destroys it if needed, and removes the file from the archive while logging. None of these match the source code, which manages an upstream keepalive connection: it handles socket events, checks for close/timed out, peeks into the socket buffer, and closes/recycles the connection in a free queue. This is a complete semantic mismatch targeting the primary purpose, making it a FATAL error with high negative impact."
            ]
        },
        "misum": {
            "summary": "The function Flushes a file descriptor either using an I/O or IO file descriptor based on the cache's mode.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function flushes a file descriptor based on the cache's mode, which is not reflected in the source code. The function handles a keepalive close event by checking connection state, potentially reading one byte with MSG_PEEK, and managing queue items. There is no flushing behavior or mode-based logic, making the claim inaccurate and unrelated to actual semantics.",
                "The summary is completely inaccurate, as it describes flushing a file descriptor based on cache mode, which is unrelated to the actual code. The source function handles closing an HTTP upstream keepalive connection by checking event states, peeking at the socket, managing event readiness, and updating internal queues. The summary misses the primary purpose and all key implementation details, providing irrelevant information.",
                "The summary claims the function flushes a file descriptor based on a cache mode, which is not reflected in the source code. The code handles keepalive connection close events, checks for closure or timeouts, peeks at the socket buffer, handles read events, and manages a queue of cached connections. The flush and cache mode concepts are entirely absent, making this a FATAL inaccuracy regarding the primary purpose and key I/O behavior."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4389008,
    "strip_function_name": "sub_42F890",
    "strip_decompiled_code": "int __fastcall sub_42F890(FILE *stream, int a2, int a3)\n{\n  char **v4; // rbx\n  int v5; // edx\n  unsigned int v6; // ebp\n  char *v7; // rax\n  char *v8; // rcx\n  int v9; // r8d\n  char **v10; // rbx\n  const char *v11; // rcx\n  int v12; // r8d\n  int v14[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v4 = &off_4FBB00;\n  v5 = 0;\n  v6 = 0;\n  v7 = asc_7D76E0 + 27;\n  v14[0] = 54;\n  while ( 1 )\n  {\n    if ( !v5 )\n    {\n      v8 = *v4;\n      v9 = *((_DWORD *)v4 + 2);\n      if ( **v4 == 46 )\n      {\n        if ( a2 )\n        {\n          ++v8;\n          --v9;\nLABEL_5:\n          v7 = (char *)sub_42F7E0(stream, v7, v14, v8, v9);\n        }\n      }\n      else if ( !a2 && (!a3 || (*((_BYTE *)&xmmword_4FBB10 + 40 * v6) & 4) != 0) )\n      {\n        goto LABEL_5;\n      }\n    }\n    ++v6;\n    v4 += 5;\n    if ( v6 == 124 )\n      break;\n    v5 = *((_DWORD *)v4 + 8);\n  }\n  if ( a2 )\n  {\n    v10 = &off_4FB780;\n    v11 = \"no87\";\n    v12 = 4;\n    while ( 1 )\n    {\n      v7 = (char *)sub_42F7E0(stream, v7, v14, v11, v12);\n      if ( v10 == &off_4FBB00 )\n        break;\n      v12 = *((_DWORD *)v10 + 2);\n      v11 = *v10;\n      v10 += 4;\n    }\n  }\n  *v7 = 0;\n  return fprintf(stream, \"%s\\n\", asc_7D76E0);\n}\n",
    "function_name": "show_arch",
    "decompiled_code": "void __fastcall show_arch(FILE *a1, int a2, int a3, char *name, int *len, const char *a6)\n{\n  const arch_entry *v7; // rbx\n  unsigned int skip; // edx\n  int v9; // ebp\n  char *v10; // rax\n  const arch_entry *v11; // rbx\n  char *v12; // rcx\n  __int64 v13; // r8\n  int left[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v7 = cpu_arch;\n  skip = 0;\n  v9 = 0;\n  v10 = message_16509 + 27;\n  left[0] = 54;\n  while ( 1 )\n  {\n    if ( !skip )\n    {\n      name = (char *)v7->name;\n      len = (int *)v7->len;\n      if ( *v7->name == 46 )\n      {\n        if ( a2 )\n        {\n          ++name;\n          len = (int *)(unsigned int)((_DWORD)len - 1);\nLABEL_5:\n          v10 = output_message(a1, v10, (char *)left, name, len, a6);\n        }\n      }\n      else if ( !a2 && (!a3 || (*(_BYTE *)&cpu_arch[v9].flags.bitfield & 4) != 0) )\n      {\n        goto LABEL_5;\n      }\n    }\n    ++v9;\n    ++v7;\n    if ( v9 == 124 )\n      break;\n    skip = v7->skip;\n  }\n  if ( a2 )\n  {\n    v11 = (const arch_entry *)(cpu_noarch + 32);\n    v12 = byte_4F8D2F + 415;\n    v13 = 4LL;\n    while ( 1 )\n    {\n      v10 = output_message(a1, v10, (char *)left, v12, (int *)v13, a6);\n      if ( v11 == cpu_arch )\n        break;\n      v13 = v11->len;\n      v12 = (char *)v11->name;\n      v11 = (const arch_entry *)((char *)v11 + 32);\n    }\n  }\n  *v10 = 0;\n  fprintf(a1, &byte_4F2711[47], message_16509, name, len, a6);\n}\n",
    "source_code": "\nstatic void\nshow_arch (FILE *stream, int ext, int check)\n{\n  static char message[] = MESSAGE_TEMPLATE;\n  char *start = message + 27;\n  char *p;\n  int size = sizeof (MESSAGE_TEMPLATE);\n  int left;\n  const char *name;\n  int len;\n  unsigned int j;\n\n  p = start;\n  left = size - (start - message);\n  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)\n    {\n      /* Should it be skipped?  */\n      if (cpu_arch [j].skip)\n\tcontinue;\n\n      name = cpu_arch [j].name;\n      len = cpu_arch [j].len;\n      if (*name == '.')\n\t{\n\t  /* It is an extension.  Skip if we aren't asked to show it.  */\n\t  if (ext)\n\t    {\n\t      name++;\n\t      len--;\n\t    }\n\t  else\n\t    continue;\n\t}\n      else if (ext)\n\t{\n\t  /* It is an processor.  Skip if we show only extension.  */\n\t  continue;\n\t}\n      else if (check && ! cpu_arch[j].flags.bitfield.cpui386)\n\t{\n\t  /* It is an impossible processor - skip.  */\n\t  continue;\n\t}\n\n      p = output_message (stream, p, message, start, &left, name, len);\n    }\n\n  /* Display disabled extensions.  */\n  if (ext)\n    for (j = 0; j < ARRAY_SIZE (cpu_noarch); j++)\n      {\n\tname = cpu_noarch [j].name;\n\tlen = cpu_noarch [j].len;\n\tp = output_message (stream, p, message, start, &left, name,\n\t\t\t    len);\n      }\n\n  *p = '\\0';\n  fprintf (stream, \"%s\\n\", message);\n}",
    "comment": "Outputs architecture information to a specified stream, including enabled processors and disabled extensions, based on provided flags and conditions.",
    "hext5_sum": "| copy input file to output file, while encoding it. | '",
    "bint5_sum": "Formats and prints the symbol names and their associated flags to a specified file , handling dot-separated symbols appropriately .\n",
    "cpbcs_sum": "Processes a list of words for reading or writing lines to a specified file based on the given flags.\n",
    "misum_sum": "Outputs toggle expressions from a string, handling each string in a list, and formatting the output based on specified flags.\n",
    "decom_sum": "Generates a formatted string from predefined token tables based on flags and writes it to the given stream with a newline.",
    "cfg_sum": "Formats and writes structured text entries to the output stream, conditionally including specific items based on input flags and predefined data tables.",
    "work_score": {
        "hext5": {
            "summary": "| copy input file to output file, while encoding it. | '",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function copies an input file to an output file while encoding, which is unrelated to the source code. The source code instead constructs and prints a CPU architecture message based on conditions for extensions and checks. None of the claims match the code behavior, resulting in no accurate content.",
                "The summary claims the function copies and encodes a file, which is entirely unrelated to the source code. The source code instead constructs and outputs a formatted architecture list based on conditions for extensions, processors, and flags. The summary misses the primary purpose and all secondary details, making the claim inaccurate and with no coverage of the actual implementation.",
                "The summary claims the function copies an input file to an output file while encoding it, which is completely unrelated to the source code. The source code displays architecture names and extensions to a stream, with no file copying or encoding. This is a FATAL error targeting the primary purpose, severely misleading any reader. There are no accurate claims to offset this failure, resulting in high negative impact."
            ]
        },
        "bint5": {
            "summary": "Formats and prints the symbol names and their associated flags to a specified file , handling dot-separated symbols appropriately .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function formats and prints symbol names with associated flags and handles dot-separated symbols. While the source code does format and print names, it processes CPU architecture names rather than general symbols, and there is no handling of symbol flags in the implementation. Dot-prefixed names are handled as extensions, which partially aligns with the claim, but most of the described semantics (symbol-related behavior, flags association) are inaccurate. Overall, less than half of the claims align with the source code.",
                "The summary is inaccurate because it claims the function formats and prints symbol names with associated flags, which is not reflected in the source code. The code's primary purpose is to build and print a CPU architecture message list based on filtering conditions (extensions, processor types, and flags), not symbol names or their flags. This misses the actual logic related to handling 'cpu_arch' and 'cpu_noarch' arrays, extension filtering, and output construction.",
                "The summary makes a specific claim about formatting and printing symbol names with associated flags, which contradicts the source code. The function actually formats and prints CPU architecture and extension names based on conditions, not symbol names or flags. This is a FATAL error targeting the primary purpose of the function, severely misrepresenting the I/O semantics. There are no accurate claims present to provide any positive gain."
            ]
        },
        "cpbcs": {
            "summary": "Processes a list of words for reading or writing lines to a specified file based on the given flags.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function processes a list of words for reading or writing lines to a file based on flags, which is inaccurate. The source code shows that the function iterates over CPU architecture and extension data structures to format and print messages to a stream, with flags controlling skipping behavior, not generic word processing or reading/writing lines. None of the claims align with the actual implementation.",
                "The summary does not capture the primary purpose of the function, which is to display architecture or extension names from specific arrays based on flags and conditions, and output them to a stream. Instead, it inaccurately describes processing words for reading or writing lines to a file, which contradicts the code\u2019s semantics. No accurate claims are present, resulting in no coverage of key details like filtering logic, handling of extensions, or use of cpu_arch/cpu_noarch arrays.",
                "The summary's main claim that the function processes a list of words for reading or writing lines to a specified file is inaccurate. In reality, the code iterates over CPU architecture structures and conditionally outputs their names to a stream based on flags, not generic word lists, nor does it perform arbitrary read/write operations. This is a FATAL error affecting the primary purpose and key I/O behavior, leaving no accurate claims to provide positive gain."
            ]
        },
        "misum": {
            "summary": "Outputs toggle expressions from a string, handling each string in a list, and formatting the output based on specified flags.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the code as handling toggle expressions from a list of strings, which is unrelated to the actual implementation. The source code iterates over CPU architecture arrays, conditionally skips entries based on flags, and formats output messages. None of the claims in the summary align with the code's logic, resulting in no accurate matches.",
                "The summary does not capture the primary purpose of the function, which is to display CPU architecture or extensions based on flags, filtering according to conditions like skipping certain entries, handling extensions versus processors, and displaying disabled extensions. Instead, it inaccurately describes operations on strings and lists unrelated to the source code\u2019s semantics, resulting in no accurate claim coverage.",
                "The summary is mostly inaccurate as it describes processing a list of strings with 'toggle expressions', which is not reflected in the source code. The function actually iterates over CPU architecture arrays, selectively skipping or including entries based on flags, and formats them into an output message. There is no concept of toggling expressions or generic string handling from a list, making this a FATAL error about primary purpose. No accurate claims are present, leading to high negative impact."
            ]
        }
    }
}
{
    "project_name": "GraphicsMagick",
    "function_addr": 1297040,
    "strip_function_name": "sub_13CA90",
    "strip_decompiled_code": "__int64 __fastcall sub_13CA90(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  unsigned __int8 *v5; // rbx\n  __int64 v6; // rbp\n  __int64 v7; // r13\n  size_t v8; // r13\n  __int64 *v9; // r15\n  __int64 v10; // rbp\n  _BYTE *v11; // rbx\n  __int64 v12; // [rsp+8h] [rbp-60h]\n  unsigned __int8 v13[12]; // [rsp+1Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h] BYREF\n\n  v14 = __readfsqword(0x28u);\n  v1 = (__int64)(int)sub_13BF80(a1) << 8;\n  v2 = v1 + (int)sub_13BF80(a1);\n  if ( v2 > 16 )\n  {\n    v5 = v13;\n    do\n      *v5++ = sub_13BF80(a1);\n    while ( v5 != (unsigned __int8 *)&v14 );\n    if ( (unsigned int)sub_9AC60(v13, \"ICC_PROFILE\") )\n    {\n      v6 = v2 - 14;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        sub_13BF80(a1);\n      }\n      while ( v6 != v7 );\n    }\n    else\n    {\n      v8 = v2 - 16;\n      sub_13BF80(a1);\n      sub_13BF80(a1);\n      v9 = *(__int64 **)(a1 + 24);\n      v12 = *v9;\n      sub_5BCA0(150, (__int64)\"coders/jpeg.c\");\n      if ( v2 - 16 > 0 )\n      {\n        v10 = (__int64)v9 + v2 + 464;\n        v11 = v9 + 60;\n        do\n          *v11++ = sub_13BF80(a1);\n        while ( v11 != (_BYTE *)v10 );\n      }\n      sub_6E110(v12, \"ICM\", v9 + 60, v8);\n    }\n  }\n  else\n  {\n    v3 = v2 - 3;\n    if ( v3 >= 0 )\n    {\n      do\n      {\n        --v3;\n        sub_13BF80(a1);\n      }\n      while ( v3 != -1 );\n    }\n  }\n  return 1LL;\n}\n",
    "function_name": "ReadICCProfile",
    "decompiled_code": "__int64 __fastcall ReadICCProfile(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  unsigned __int8 *v5; // rbx\n  __int64 v6; // rbp\n  __int64 v7; // r13\n  size_t v8; // r13\n  __int64 *v9; // r15\n  __int64 v10; // rbp\n  _BYTE *v11; // rbx\n  __int64 v12; // [rsp+8h] [rbp-60h]\n  unsigned __int8 v13[12]; // [rsp+1Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h] BYREF\n\n  v14 = __readfsqword(0x28u);\n  v1 = (__int64)(int)GetCharacter(a1) << 8;\n  v2 = v1 + (int)GetCharacter(a1);\n  if ( v2 > 16 )\n  {\n    v5 = v13;\n    do\n      *v5++ = GetCharacter(a1);\n    while ( v5 != (unsigned __int8 *)&v14 );\n    if ( (unsigned int)LocaleCompare(v13, \"ICC_PROFILE\") )\n    {\n      v6 = v2 - 14;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        GetCharacter(a1);\n      }\n      while ( v6 != v7 );\n    }\n    else\n    {\n      v8 = v2 - 16;\n      GetCharacter(a1);\n      GetCharacter(a1);\n      v9 = *(__int64 **)(a1 + 24);\n      v12 = *v9;\n      LogMagickEvent(150, \"coders/jpeg.c\");\n      if ( v2 - 16 > 0 )\n      {\n        v10 = (__int64)v9 + v2 + 464;\n        v11 = v9 + 60;\n        do\n          *v11++ = GetCharacter(a1);\n        while ( v11 != (_BYTE *)v10 );\n      }\n      AppendImageProfile(v12, \"ICM\", v9 + 60, v8);\n    }\n  }\n  else\n  {\n    v3 = v2 - 3;\n    if ( v3 >= 0 )\n    {\n      do\n      {\n        --v3;\n        GetCharacter(a1);\n      }\n      while ( v3 != -1 );\n    }\n  }\n  return 1LL;\n}\n",
    "source_code": "\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  long\n    length;\n\n  register long\n    i;\n\n  unsigned char\n    *profile;\n\n  /*\n    Determine length of color profile.\n  */\n  length=(long) GetCharacter(jpeg_info) << 8;\n  length+=(long) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (--length >= 0)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,\"ICC_PROFILE\") != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < length-12; i++)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n\n  /*\n    Read color profile.\n  */\n  profile=error_manager->buffer;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"ICC profile chunk: %ld bytes\",\n    length);\n\n  for (i=0 ; i < length; i++)\n   profile[i]=GetCharacter(jpeg_info);\n\n  (void) AppendImageProfile(image,\"ICM\",profile,length);\n\n  return(True);\n}",
    "comment": "Reads an ICC color profile from JPEG data, storing it in an image's buffer if the profile is valid.",
    "hext5_sum": "returns a negative integer calculates sign as well as log(|gamma(x)|). x = -n + eps assumes n >= 1",
    "bint5_sum": "Reads a generic JPEG profile , detects EXIF and XMP types , and stores the profile data in an image structure .\n",
    "cpbcs_sum": "Reads the IPTC JPEG file size from a JPEG image and stores it in the provided character buffer.\n",
    "misum_sum": "Reads the contents of a JPEG image and converts it into a 64-bit unsigned integer in little-endian format.\n",
    "decom_sum": "Parses JPEG stream segments to detect an \"ICC_PROFILE\" marker and, if found, reads and stores the embedded ICC color profile data.",
    "cfg_sum": "Parses JPEG segment data, validates ICC profile integrity, and loads valid profiles into memory while discarding non-conforming or corrupted segments.",
    "work_score": {
        "hext5": {
            "summary": "returns a negative integer calculates sign as well as log(|gamma(x)|). x = -n + eps assumes n >= 1",
            "score": [
                0.0,
                0.1,
                0.0
            ],
            "reason": [
                "The summary describes functionality related to mathematical operations on gamma(x), including returning negative integers, calculating sign, and logarithms, which has no relation to the source code. The source handles reading ICC profiles from JPEG data, with no shared semantics or overlapping functionality. All claims are irrelevant to the code.",
                "The summary describes mathematical operations involving gamma functions and negative integers, which are unrelated to the source code\u2019s behavior. The source function reads and processes ICC profiles from JPEG data, handling specific headers, lengths, and appending the profile to an image object. The summary misses the primary purpose entirely and provides no accurate coverage of the code\u2019s actual logic or observable behavior.",
                "The summary makes claims about returning a negative integer, calculating a sign, and computing log(|gamma(x)|) under certain assumptions about x, which are entirely unrelated to the provided source code that reads an ICC color profile from a JPEG. These are pure NOISE with no accurate alignment to the code\u2019s actual purpose of handling image profiles, resulting in zero factual overlap and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Reads a generic JPEG profile , detects EXIF and XMP types , and stores the profile data in an image structure .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function reads a generic JPEG profile, detects EXIF and XMP types, and stores the profile data in an image structure. The source code shows it specifically reads ICC profiles, checks for the 'ICC_PROFILE' marker, and then stores the data in an image after reading it into a buffer. There is no detection of EXIF or XMP types in the source, and the profile type is not generic\u2014it is ICC-specific. Only the storing of data in an image structure matches. This means less than half of the claims are accurate.",
                "The summary is inaccurate because the source code reads only ICC profiles from a JPEG, not generic profiles, and it does not detect EXIF or XMP types. While it does store the ICC profile data in the image structure, the primary purpose and key conditions are misrepresented, so the coverage is minimal and incorrect overall.",
                "The summary makes several inaccurate claims: it states detection of EXIF and XMP profile types, while the source code clearly only checks for 'ICC_PROFILE'. It also describes reading a generic JPEG profile, which contradicts the targeted ICC profile reading shown in the code. These are FATAL errors regarding the primary purpose and key behavior, as the implementation is specifically for ICC profiles, not EXIF/XMP or generic profiles. These inaccuracies outweigh any correct elements, and there is minimal accurate information to provide positive gain."
            ]
        },
        "cpbcs": {
            "summary": "Reads the IPTC JPEG file size from a JPEG image and stores it in the provided character buffer.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function reads the IPTC JPEG file size and stores it in a character buffer, but the source code actually reads an ICC color profile from a JPEG image, checks its header, and appends it to the image profile. The claim targets source semantics but is entirely mismatched, making it inaccurate.",
                "The summary incorrectly describes reading an IPTC JPEG file size, which contradicts the source code. The function actually reads an ICC color profile from a JPEG stream, checks for 'ICC_PROFILE' marker, then stores the profile data in a buffer and attaches it to the image. The stated buffer purpose and IPTC mention are inaccurate, thus missing the primary purpose and all secondary details.",
                "The summary claims the function reads the IPTC JPEG file size and stores it in a character buffer, which directly contradicts the source code. The code reads an ICC profile chunk from a JPEG image, validates its header, logs its size, and appends it to the image profile. This is a FATAL error targeting the primary purpose and I/O of the function, making the summary unreliable."
            ]
        },
        "misum": {
            "summary": "Reads the contents of a JPEG image and converts it into a 64-bit unsigned integer in little-endian format.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function reads a JPEG image and converts it into a 64-bit unsigned integer in little-endian format. The source code shows that it reads an ICC profile from a JPEG file and appends it to the image; there is no conversion to a 64-bit integer. This is a direct contradiction to the actual implementation, making the claim entirely inaccurate.",
                "The summary claims the function reads a JPEG and converts it to a 64-bit unsigned integer in little-endian format, which contradicts the source code. The actual implementation reads an ICC color profile from a JPEG, checks headers, logs events, and appends the profile to the image; no integer conversion occurs. This is a complete semantic mismatch, missing the primary purpose entirely.",
                "The summary presents a FATAL inaccuracy: it claims the function reads a JPEG image and converts it into a 64-bit unsigned integer in little-endian format, whereas the source code clearly reads an ICC color profile chunk from a JPEG and appends it to an image profile. This contradicts the primary purpose and key I/O of the function, resulting in high negative impact and no accurate claims."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1318368,
    "strip_function_name": "gsl_permutation_linear_to_canonical",
    "strip_decompiled_code": "__int64 __fastcall gsl_permutation_linear_to_canonical(__int64 *a1, _QWORD *a2)\n{\n  __int64 v2; // r8\n  __int64 v3; // rsi\n  __int64 v4; // r9\n  unsigned __int64 v5; // rdx\n  __int64 v6; // rdi\n  unsigned __int64 v7; // rax\n  __int64 i; // rcx\n  unsigned __int64 v9; // rax\n  unsigned __int64 *v10; // rcx\n\n  v2 = *a1;\n  if ( *a1 == *a2 )\n  {\n    if ( v2 )\n    {\n      v3 = a2[1];\n      v4 = a1[1];\n      v5 = 0LL;\n      v6 = *a1;\n      do\n      {\n        v7 = *(_QWORD *)(v3 + 8 * v5);\n        for ( i = 1LL; v7 > v5; ++i )\n          v7 = *(_QWORD *)(v3 + 8 * v7);\n        if ( v7 >= v5 )\n        {\n          v6 -= i;\n          *(_QWORD *)(v4 + 8 * v6) = v5;\n          v9 = *(_QWORD *)(v3 + 8 * v5);\n          if ( v9 > v5 )\n          {\n            v10 = (unsigned __int64 *)(v4 + 8 * v6 + 8);\n            do\n            {\n              *v10 = v9;\n              v9 = *(_QWORD *)(v3 + 8 * v9);\n              ++v10;\n            }\n            while ( v9 > v5 );\n          }\n          if ( !v6 )\n            break;\n        }\n        ++v5;\n      }\n      while ( v2 != v5 );\n    }\n    return 0LL;\n  }\n  else\n  {\n    gsl_error(\"size of q does not match size of p\", \"canonical.c\", 42LL, 4LL);\n    return 4LL;\n  }\n}\n",
    "function_name": "gsl_permutation_linear_to_canonical",
    "decompiled_code": "int __fastcall gsl_permutation_linear_to_canonical(gsl_permutation *q, const gsl_permutation *p)\n{\n  size_t size; // r8\n  size_t *data; // rsi\n  size_t *v4; // r9\n  size_t v5; // rdx\n  size_t v6; // rdi\n  size_t v7; // rax\n  __int64 i; // rcx\n  size_t v9; // rax\n  size_t *v10; // rcx\n\n  size = q->size;\n  if ( q->size == p->size )\n  {\n    if ( size )\n    {\n      data = p->data;\n      v4 = q->data;\n      v5 = 0LL;\n      v6 = q->size;\n      do\n      {\n        v7 = data[v5];\n        for ( i = 1LL; v7 > v5; ++i )\n          v7 = data[v7];\n        if ( v7 >= v5 )\n        {\n          v6 -= i;\n          v4[v6] = v5;\n          v9 = data[v5];\n          if ( v9 > v5 )\n          {\n            v10 = &v4[v6 + 1];\n            do\n            {\n              *v10 = v9;\n              v9 = data[v9];\n              ++v10;\n            }\n            while ( v9 > v5 );\n          }\n          if ( !v6 )\n            break;\n        }\n        ++v5;\n      }\n      while ( size != v5 );\n    }\n    return 0;\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64))gsl_error)(\n      \"size of q does not match size of p\",\n      \"canonical.c\",\n      42LL,\n      4LL);\n    return 4;\n  }\n}\n",
    "source_code": "\nint\ngsl_permutation_linear_to_canonical (gsl_permutation * q,\n                                     const gsl_permutation * p)\n{\n  const size_t n = p->size;\n  size_t i, k, s;\n  size_t t = n;\n\n  const size_t *const pp = p->data;\n  size_t *const qq = q->data;\n\n  if (q->size != p->size)\n    {\n      GSL_ERROR (\"size of q does not match size of p\", GSL_EINVAL);\n    }\n\n  for (i = 0; i < n; i++)\n    {\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          k = pp[k];\n          s++;\n        }\n\n      if (k < i)\n        continue;\n\n      /* Now have k == i, i.e the least in its cycle, and s == cycle length */\n\n      t -= s;\n\n      qq[t] = i;\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          qq[t + s] = k;\n          k = pp[k];\n          s++;\n        }\n\n      if (t == 0)\n        break;\n    }\n\n  return GSL_SUCCESS;\n}",
    "comment": "Converts a given permutation `p` into its canonical form and stores the result in `q`.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Converts a linear permutation ` q ` into its canonical representation by rearranging indices based on the values in ` q ` .\n",
    "cpbcs_sum": "Converts a triplet sparse matrix to its corresponding bins representation, storing the result in the provided inverse array.\n",
    "misum_sum": "Converts a 2D point to a linear programming problem, allocating memory for the result array if necessary.\n",
    "decom_sum": "Converts a linear permutation sequence into its canonical cycle form, storing cycles contiguously after verifying both permutations have matching sizes.",
    "cfg_sum": "Converts a linear permutation into canonical form after verifying equal sizes, otherwise reports an error and returns a failure code.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes behavior related to looking up Unicode character names and returning buffers, which has no connection to the actual source code that performs permutation conversion between linear and canonical forms in GSL. All claims are unrelated to the source implementation, resulting in zero accurate matches.",
                "The summary describes functionality involving looking up Unicode character names and returning a buffer or null, which is entirely unrelated to the source code that processes permutations in the GSL library. It misses the primary purpose of converting a linear permutation to its canonical form and does not match any semantic units from the implementation.",
                "The summary's claims about returning a filled buffer or null, and looking up a Unicode character's name in uppercase ASCII, are entirely unrelated to the source code, which deals with converting a permutation from linear to canonical form. These are NOISE claims and overwhelm the response, providing no accurate insight into the function's semantics."
            ]
        },
        "bint5": {
            "summary": "Converts a linear permutation ` q ` into its canonical representation by rearranging indices based on the values in ` q ` .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function converts a linear permutation q into its canonical form based on values in q, but the source code shows it rearranges q based on the mapping in p. This is a semantic contradiction, as q\u2019s transformation is driven by p\u2019s data. The only partially correct element is mentioning a canonical representation, but the core mechanism is inaccurately described.",
                "The summary incorrectly describes the function as converting permutation `q` based on its own values, while the source code clearly transforms `q` into the canonical form using the data from permutation `p`. It misses the primary purpose, which involves processing cycles of `p` to fill `q`, and omits key secondary details like size mismatch error handling, loop structure for cycle traversal, and use of constants/indices. This mismatch makes the claim inaccurate and results in no coverage of the critical semantic units.",
                "The summary inaccurately describes the algorithm: in the source code, `q` is the output permutation written based on the input `p`, but the summary claims it rearranges indices based on `q`, which is incorrect. This is a FATAL error because it misstates the primary purpose and key I/O relationship. No accurate, high\u2011value details are provided, leading to high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Converts a triplet sparse matrix to its corresponding bins representation, storing the result in the provided inverse array.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about converting a triplet sparse matrix to a bins representation does not align with the source code, which processes GSL permutations to transform them from linear to canonical form. None of the claims in the summary match the code\u2019s actual functionality, resulting in 0% accuracy.",
                "The summary is entirely inaccurate, describing conversion of a triplet sparse matrix to bins representation with an inverse array. The source code function actually converts a permutation from linear form to canonical form, working with gsl_permutation structures, checking size consistency, and arranging data based on cycle decomposition. The summary misses the primary purpose and all key semantic details, making it completely unrelated to the implementation.",
                "The summary's sole claim describes converting a triplet sparse matrix to a bins representation, which is entirely unrelated to the source code's actual function of transforming a permutation from linear to canonical form. This is a FATAL inaccuracy affecting the primary purpose of the function, providing zero valid insight and misleading the reader."
            ]
        },
        "misum": {
            "summary": "Converts a 2D point to a linear programming problem, allocating memory for the result array if necessary.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claim about converting a 2D point to a linear programming problem and allocating memory is completely unrelated to the source code, which converts one permutation representation to another and verifies size matches. None of the atomic claims align with the actual function logic, resulting in 0% accurate claims.",
                "The summary is completely inaccurate; it describes converting a 2D point to a linear programming problem and memory allocation, which has no relation to the source code's actual purpose of transforming a permutation from linear to canonical form. The primary purpose and all secondary details are missed, with no correct claims present.",
                "The summary is entirely inaccurate, describing conversion of a 2D point to a linear programming problem with memory allocation, which is unrelated to the source code. The actual function transforms a permutation from linear to canonical form and handles size mismatches without any mention of points or linear programming. This represents a FATAL error targeting the primary purpose, making the description unreliable."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584487984,
    "strip_function_name": "sub_FFFFFFFF81561A30",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81561A30(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  _QWORD *v9; // rax\n  unsigned __int64 v10; // rbx\n  __int64 v11; // rsi\n  __int64 *v12; // rdx\n  __int64 v13; // rcx\n  int v14; // r8d\n  int v15; // r9d\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // eax\n\n  v9 = (_QWORD *)sub_FFFFFFFF8112CA50((_QWORD *)qword_FFFFFFFF81E8C758, 0xD0u, 1224LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = (unsigned __int64)v9;\n  v11 = (__int64)v9;\n  *v9 = *(_QWORD *)(a1 + 80);\n  v9[1] = *(_QWORD *)(a1 + 88);\n  v9[2] = *(_QWORD *)(a1 + 96);\n  v9[3] = *(_QWORD *)(a1 + 104);\n  v9[4] = *(_QWORD *)(a1 + 112);\n  v9[5] = *(_QWORD *)(a1 + 120);\n  v9[6] = *(_QWORD *)(a1 + 128);\n  v9[7] = *(_QWORD *)(a1 + 136);\n  (*(void (__fastcall **)(__int64, _QWORD *))(a1 + 160))(a1 + 64, v9);\n  v18 = *(_DWORD *)(a1 + 28);\n  if ( v18 > 0 )\n  {\n    v12 = *(__int64 **)(v10 + 72);\n    *(_DWORD *)(a1 + 40) = (_DWORD)v12;\n    if ( v18 != 1 )\n      *(_DWORD *)(a1 + 44) = *(_QWORD *)(v10 + 80);\n  }\n  sub_FFFFFFFF8112DCD0(v10, a2, a3, a4, a5, v16, v17, a8, a9, v11, v12, v13, v14, v15);\n  return 0LL;\n}\n",
    "function_name": "slave_update",
    "decompiled_code": "__int64 __fastcall slave_update(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 *v9; // rax\n  __int64 *v10; // rbx\n  __int64 v11; // rsi\n  __int64 *v12; // rdx\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  int v15; // eax\n\n  v9 = kmem_cache_alloc_trace((__int64 *)qword_FFFFFFFF81E8C758, 208LL, 1224LL, a2, a3, a4, a5, a6, a7, a8, a9);\n  if ( !v9 )\n    return 4294967284LL;\n  v10 = v9;\n  v11 = (__int64)v9;\n  *v9 = *(_QWORD *)(a1 + 80);\n  v9[1] = *(_QWORD *)(a1 + 88);\n  v9[2] = *(_QWORD *)(a1 + 96);\n  v9[3] = *(_QWORD *)(a1 + 104);\n  v9[4] = *(_QWORD *)(a1 + 112);\n  v9[5] = *(_QWORD *)(a1 + 120);\n  v9[6] = *(_QWORD *)(a1 + 128);\n  v9[7] = *(_QWORD *)(a1 + 136);\n  (*(void (__fastcall **)(__int64, __int64 *))(a1 + 160))(a1 + 64, v9);\n  v15 = *(_DWORD *)(a1 + 28);\n  if ( v15 > 0 )\n  {\n    v12 = (__int64 *)v10[9];\n    *(_DWORD *)(a1 + 40) = (_DWORD)v12;\n    if ( v15 != 1 )\n      *(_DWORD *)(a1 + 44) = v10[10];\n  }\n  kfree(v10, a2, a3, a4, a5, v13, v14, a8, a9, v11, v12);\n  return 0LL;\n}\n",
    "source_code": "\nstatic int slave_update(struct link_slave *slave)\n{\n\tstruct snd_ctl_elem_value *uctl;\n\tint err, ch;\n\n\tuctl = kmalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (!uctl)\n\t\treturn -ENOMEM;\n\tuctl->id = slave->slave.id;\n\terr = slave->slave.get(&slave->slave, uctl);\n\tfor (ch = 0; ch < slave->info.count; ch++)\n\t\tslave->vals[ch] = uctl->value.integer.value[ch];\n\tkfree(uctl);\n\treturn 0;\n}",
    "comment": "Updates the values of a slave device by retrieving its current control element values and storing them in the slave's array.",
    "hext5_sum": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Initializes a high-resolution timer for a sound device by allocating memory , setting up timers , and registering the timer .\n",
    "cpbcs_sum": "Copies the properties of an EFI variable entry to a HID device and marks it as dirty if the variable is valid.\n",
    "misum_sum": "Initializes a sequencer device by allocating memory, storing it and an existing slave device if no active events remain.\n",
    "decom_sum": "Allocates and initializes a 0xD0-byte structure from source object fields, invokes a callback with it, updates status fields, and processes it further.",
    "cfg_sum": "Allocates and initializes a data block from input structure, updates related fields, processes it through helper routines, and returns an error code if allocation fails.",
    "work_score": {
        "hext5": {
            "summary": "in the intel world, a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary makes claims about the structure of a stack frame in an Intel architecture context, which is unrelated to the provided source code implementing the `slave_update` function for audio control values. None of the claims directly address or match the semantics, data handling, or logic in the source, making them entirely inaccurate for the evaluation context.",
                "The summary discusses stack frame layout in the Intel architecture, which does not relate to or describe any aspect of the provided source code. The source code implements a function `slave_update` that allocates memory, retrieves control element values via a callback, stores them, and frees memory. The summary misses the primary purpose and all secondary details of the function, making all claims irrelevant or inaccurate.",
                "The summary talks about Intel CPU stack frame layout, which is unrelated to the provided source code that handles updating values from a slave structure in the Linux kernel. All claims are NOISE, providing no insight into the function's primary purpose, logic, or I/O. With no accurate and relevant details, the net benefit is zero."
            ]
        },
        "bint5": {
            "summary": "Initializes a high-resolution timer for a sound device by allocating memory , setting up timers , and registering the timer .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim about initializing a high-resolution timer, setting up timers, and registering the timer does not align with the source code, which allocates memory for a control element value, retrieves data via a get callback, updates values from the retrieved structure, and frees the memory. None of the claims in the summary are accurate to the actual code implementation, resulting in no alignment.",
                "The summary is entirely inaccurate \u2014 it describes initializing a high-resolution timer with memory allocation, timer setup, and registration, which does not match the source code. The actual function allocates memory for a control element, retrieves values from a slave device, copies them into an array, frees memory, and returns a status. The PRIMARY PURPOSE and all secondary details from the source are missed.",
                "The summary contains a FATAL inaccuracy: it claims the function initializes a high-resolution timer for a sound device by setting up and registering timers, which is not present in the source code. The actual implementation allocates memory for a control element, retrieves values via a callback, assigns them to an array, and frees the memory. No timer-related operations occur. This fundamental mismatch to the primary purpose drastically reduces reliability."
            ]
        },
        "cpbcs": {
            "summary": "Copies the properties of an EFI variable entry to a HID device and marks it as dirty if the variable is valid.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about copying properties of an EFI variable entry to a HID device and marking it as dirty bear no relation to the source code, which deals with allocating memory for a control element, retrieving values from a slave device, storing them, and freeing memory. None of the claims match the actual semantics, resulting in zero accurate statements.",
                "The summary is entirely inaccurate; it describes operations involving EFI variables and HID devices, which are unrelated to the actual source code. The source function allocates memory, fetches control element values from a slave structure, updates internal arrays, frees memory, and returns status. The primary purpose and all secondary details from the code are missed, indicating no factual alignment.",
                "The summary makes claims about copying EFI variable properties to a HID device and marking it as dirty, which is entirely unrelated to the source code. The source code operates on an audio control element, allocating memory, retrieving values via a slave callback, copying them into an array, and freeing memory. All claims in the summary are inaccurate (NOISE) and provide no relevant or correct insight to the code's primary purpose, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Initializes a sequencer device by allocating memory, storing it and an existing slave device if no active events remain.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims involve initializing a sequencer device, storing it alongside an existing slave device, and a conditional related to active events, none of which are present in the source code. The source code actually allocates memory for a control element value, copies data from the slave using its get method, updates values, and frees the memory. All claims in the summary misrepresent the implementation, resulting in no accurate matches.",
                "The summary is inaccurate, describing initialization of a sequencer device and conditions about active events, which are not present in the source code. The actual code allocates a control element value structure, retrieves data from the slave device, copies values into an array, and frees the allocated memory. The PRIMARY PURPOSE of updating slave values from retrieved data is missed entirely, and no secondary details are correctly described.",
                "The summary contains a FATAL error by misrepresenting the primary purpose of the function. The source code shows that it allocates a control element value structure, retrieves data from a slave device, updates internal values, frees the memory, and returns 0; it does not initialize a sequencer device or depend on active events. This contradiction about the key purpose and I/O behavior severely undermines reliability."
            ]
        }
    }
}
{
    "project_name": "dico",
    "function_addr": 72448,
    "strip_function_name": "sub_11B00",
    "strip_decompiled_code": "__int64 __fastcall sub_11B00(int a1, const __m128i *a2, __int64 a3, __int64 a4)\n{\n  const char *v5; // rsi\n  __int64 v8; // rbx\n  int v9; // r14d\n  _QWORD *v10; // rax\n  __int64 v11; // r13\n  __int64 v12; // rax\n  __int64 v13; // r12\n  __int64 v14; // rbx\n  __int64 v15; // r12\n\n  v5 = \"Unexpected block statement\";\n  if ( a1 != 2 )\n    goto LABEL_4;\n  if ( *(_DWORD *)a4 != 2 )\n  {\n    v5 = \"Not enough arguments for alias\";\nLABEL_4:\n    dcgettext(0LL, v5, 5);\n    grecs_error();\n    return 1LL;\n  }\n  v8 = *(_QWORD *)(a4 + 40);\n  v9 = v8 - 1;\n  v10 = (_QWORD *)sub_2F900((int)v8, 8LL);\n  v11 = (__int64)v10;\n  if ( (int)v8 - 1 > 0 )\n  {\n    v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8LL);\n    if ( *(_DWORD *)v12 )\n    {\nLABEL_13:\n      dcgettext(0LL, \"argument %d has wrong type\", 5);\n      grecs_error();\n      return 1LL;\n    }\n    v13 = (unsigned int)(v8 - 2);\n    v14 = 1LL;\n    v15 = v13 + 1;\n    while ( 1 )\n    {\n      *(_QWORD *)(v11 + 8 * v14 - 8) = sub_2F970(*(void **)(v12 + 40));\n      if ( v14 == v15 )\n        break;\n      ++v14;\n      v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8 * v14);\n      if ( *(_DWORD *)v12 )\n        goto LABEL_13;\n    }\n    v10 = (_QWORD *)(v11 + 8 * v14);\n  }\n  *v10 = 0LL;\n  return sub_ACE0(*(void **)(**(_QWORD **)(a4 + 48) + 40LL), v9, v11, a2);\n}\n",
    "function_name": "alias_cb",
    "decompiled_code": "int __fastcall alias_cb(\n        grecs_callback_command cmd,\n        grecs_locus_t *locus,\n        void *varptr,\n        grecs_value_t *value,\n        void *cb_data)\n{\n  const char *v6; // rsi\n  char *v8; // rax\n  grecs_list_ptr_t list; // rbx\n  int v11; // r14d\n  char **v12; // rax\n  char **v13; // r13\n  grecs_value *v14; // rax\n  __int64 v15; // r12\n  __int64 v16; // rbx\n  __int64 v17; // r12\n  int v18; // ecx\n  unsigned int v19; // ebx\n  char *v20; // rax\n\n  v6 = \"Unexpected block statement\";\n  if ( cmd != grecs_callback_command::grecs_callback_set_value )\n    goto LABEL_4;\n  if ( value->type != 2 )\n  {\n    v6 = \"Not enough arguments for alias\";\nLABEL_4:\n    v8 = dcgettext(0LL, v6, 5);\n    ((void (__fastcall *)(grecs_locus_t *, _QWORD, char *))grecs_error)(locus, 0LL, v8);\n    return 1;\n  }\n  list = value->v.list;\n  v11 = (_DWORD)list - 1;\n  v12 = (char **)xcalloc((int)list, 8uLL);\n  v13 = v12;\n  if ( (int)list - 1 > 0 )\n  {\n    v14 = (grecs_value *)*((_QWORD *)value->v.arg.v + 1);\n    if ( v14->type )\n    {\n      v19 = 1;\n    }\n    else\n    {\n      v15 = (unsigned int)((_DWORD)list - 2);\n      v16 = 1LL;\n      v17 = v15 + 1;\n      do\n      {\n        v13[v16 - 1] = xstrdup(v14->v.string);\n        v18 = v16;\n        if ( v16 == v17 )\n        {\n          v12 = &v13[v16];\n          goto LABEL_12;\n        }\n        v14 = value->v.arg.v[++v16];\n      }\n      while ( !v14->type );\n      v19 = v18 + 1;\n    }\n    v20 = dcgettext(0LL, \"argument %d has wrong type\", 5);\n    ((void (__fastcall *)(grecs_locus_t *, _QWORD, char *, _QWORD))grecs_error)(locus, 0LL, v20, v19);\n    return 1;\n  }\nLABEL_12:\n  *v12 = 0LL;\n  return alias_install((*value->v.arg.v)->v.string, v11, v13, locus);\n}\n",
    "source_code": "\n\f\nint\nalias_cb(enum grecs_callback_command cmd,\n\t grecs_locus_t *locus,\n\t void *varptr,\n\t grecs_value_t *value,\n\t void *cb_data)\n{\n    char **argv;\n    int argc;\n    int i;\n\n    if (cmd != grecs_callback_set_value) {\n\tgrecs_error(locus, 0, _(\"Unexpected block statement\"));\n\treturn 1;\n    }\n    if (value->type != GRECS_TYPE_ARRAY) {\n\tgrecs_error(locus, 0, _(\"Not enough arguments for alias\"));\n\treturn 1;\n    }\n    argc = value->v.arg.c - 1;\n    argv = xcalloc(argc + 1, sizeof(argv[0]));\n    for (i = 0; i < argc; i++) {\n\tif (value->v.arg.v[i+1]->type != GRECS_TYPE_STRING) {\n\t    grecs_error(locus, 0, _(\"argument %d has wrong type\"), i+1);\n\t    return 1;\n\t}\n\targv[i] = xstrdup(value->v.arg.v[i+1]->v.string);\n    }\n    argv[i] = NULL;\n    return alias_install(value->v.arg.v[0]->v.string, argc, argv, locus);\n}",
    "comment": "Processes a callback to set an alias by checking argument types and installing the alias with provided string parameters.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes a callback to set a value by parsing a string , appending the value to a list , and managing memory for the alias .\n",
    "cpbcs_sum": "Processes a command and tag's a list of arguments, handling errors and unexpected tokens in the command list.\n",
    "misum_sum": "Processes a structured Unicode code to set an array of known words based on the string type, converting line arguments.\n",
    "decom_sum": "Validates alias command arguments, converts them to internal objects, and invokes the alias creation routine, reporting errors for wrong types or insufficient arguments.",
    "cfg_sum": "Validates alias command arguments, reports errors for invalid types or insufficient parameters, builds a processed argument list, and executes the alias operation.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.0
            ],
            "reason": [
                "The summary contains a vague and unsupported claim that does not map to any specific semantics or behavior in the source code. The source implements an alias callback function with argument validation and installation logic, not a generic 'push a pointer type' operation. This makes the claim irrelevant and inaccurate, resulting in no accurate matches.",
                "The summary 'push a pointer type' is vague, does not identify the function's primary purpose, and fails to reference any specific behavior, inputs, outputs, or error handling from the source code. It neither captures the callback handling logic nor the argument parsing and validation, so it has no accurate claim coverage of the CSU_LIST.",
                "The summary 'push a pointer type.' is vague and unrelated to the source code's actual functionality. It does not reference the callback command handling, argument type checks, memory allocation, or alias installation logic in the code. This is pure NOISE with no factual alignment, providing zero useful insight and no acceleration of understanding."
            ]
        },
        "bint5": {
            "summary": "Processes a callback to set a value by parsing a string , appending the value to a list , and managing memory for the alias .\n",
            "score": [
                0.3,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the code parses a string, appends the value to a list, and manages memory for the alias. While the function does parse strings and allocate memory for arguments, it does not simply append to a list; instead, it creates a new argv array from the provided arguments and passes it to alias_install. The summary omits key control flow conditions (such as type checking and error handling) and misrepresents the 'append' operation, resulting in less than half of the claims being fully accurate.",
                "The summary inaccurately describes the function. It claims the function parses a string, appends a value to a list, and manages memory for an alias, but the source shows that it handles a specific callback command, validates input types, allocates memory for argv, and calls alias_install. Key behaviors such as error handling for unexpected commands or wrong argument types, and the use of multiple string arguments, are missed. The primary purpose is misrepresented, leading to no accurate coverage of the critical semantic units.",
                "The summary incorrectly describes the function as parsing a string, appending the value to a list, and managing memory for the alias. In reality, the code checks for specific callback and value types, builds an argv array from string arguments, and calls alias_install. The 'append to a list' claim is inaccurate and misrepresents primary I/O behavior, making this a FATAL error affecting the key logic of the function. There are no accurate, high-info claims to offset this."
            ]
        },
        "cpbcs": {
            "summary": "Processes a command and tag's a list of arguments, handling errors and unexpected tokens in the command list.\n",
            "score": [
                0.2,
                0.5,
                0.5
            ],
            "reason": [
                "The summary is broadly descriptive and does not contain contradictory information, but it omits key specific behaviors from the source code such as checking the command type, verifying that the value is an array, validating argument types, allocating and copying arguments, and installing the alias. The vague phrasing 'tag's a list of arguments' does not precisely match the implementation. As a result, only a small portion of the summary can be considered accurate in relation to the source code.",
                "The summary captures a broad notion of processing a command and handling errors, which loosely aligns with the function's primary purpose of validating command structure and arguments before installing an alias. However, it omits critical secondary details from the source code, such as the specific check for 'grecs_callback_set_value', the requirement that 'value->type' be an array, the type checking of each argument as a string, the allocation and duplication of arguments, and the final call to 'alias_install'. It also inaccurately implies 'tagging' arguments, which is not reflected in the implementation.",
                "The summary provides a broad and vague description, mentioning processing a command, tagging arguments, and handling errors, but lacks specific and accurate detail about the actual implementation. It omits key specifics such as the type checks for GRECS_TYPE_ARRAY and GRECS_TYPE_STRING, memory allocation for argv, and use of alias_install. The generic phrasing 'tag's a list of arguments' is unclear and not reflected in the source code, amounting to NOISE without FATAL contradictions. The gain is low due to the absence of precise insights."
            ]
        },
        "misum": {
            "summary": "Processes a structured Unicode code to set an array of known words based on the string type, converting line arguments.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the code as processing 'structured Unicode code' and 'known words', which do not match the function's actual purpose of handling callback commands, validating argument types, and installing aliases. These claims are not grounded in the source implementation, resulting in a lack of accurate fact-based content.",
                "The summary misrepresents the primary purpose of the function. The source code defines a callback that validates its command type, checks for array-type input, verifies that arguments are strings, duplicates them, and installs an alias. The summary incorrectly describes processing a 'structured Unicode code' and 'known words', which are unrelated to the code\u2019s behavior. It omits key details such as error handling for incorrect types, memory allocation, and the final call to install the alias. This results in missing both the primary purpose and secondary details.",
                "The summary's main claim about processing a 'structured Unicode code' to set an array of known words based on string type is inaccurate relative to the source code. The function actually processes callback data to install aliases, validates argument types, and duplicates strings; it does not deal with Unicode specifically nor 'known words' as described. This is a FATAL error affecting the primary purpose and the key input/output of the function, with no accurate or specific claims, resulting in high negative impact and zero net benefit."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5673105,
    "strip_function_name": "sub_569091",
    "strip_decompiled_code": "char __fastcall sub_569091(__int64 a1, int a2)\n{\n  char result; // al\n  _DWORD *v3; // rdx\n  int v4; // ecx\n  int v5; // eax\n  int v6; // edx\n  unsigned int v7; // esi\n  __int64 v8; // rax\n  __int64 v9; // rdi\n\n  result = 0;\n  if ( a2 != -1 )\n  {\n    v3 = off_8970B8;\n    if ( off_8970B8 )\n    {\n      v4 = *((_DWORD *)off_8970B8 + 3);\n      if ( a2 == v4 )\n      {\n        result = 1;\n        if ( v4 > 0 )\n          return result;\n      }\n      while ( 1 )\n      {\n        v3 = *(_DWORD **)v3;\n        if ( !v3 )\n          break;\n        v5 = v3[3];\n        if ( a2 == v5 && v5 > 0 )\n          return 1;\n      }\n    }\n    result = 0;\n    if ( a1 )\n    {\n      v6 = *(_DWORD *)(a1 + 8);\n      v7 = a2 | 0x80000000;\n      if ( v6 > 0 )\n      {\n        result = 1;\n        if ( *(_DWORD *)(a1 + 16) != v7 )\n        {\n          v8 = a1 + 24;\n          v9 = 8LL * (unsigned int)(v6 - 1) + 24 + a1;\n          while ( v8 != v9 )\n          {\n            v8 += 8LL;\n            if ( *(_DWORD *)(v8 - 8) == v7 )\n              return 1;\n          }\n          return 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "is_hidden_fd",
    "decompiled_code": "char __fastcall is_hidden_fd(__int64 a1, int a2)\n{\n  char result; // al\n  _DWORD *v3; // rdx\n  int v4; // ecx\n  int v5; // eax\n  int v6; // edx\n  unsigned int v7; // esi\n  __int64 v8; // rax\n  __int64 v9; // rdi\n\n  result = 0;\n  if ( a2 != -1 )\n  {\n    v3 = g_parsefile;\n    if ( g_parsefile )\n    {\n      v4 = *((_DWORD *)g_parsefile + 3);\n      if ( a2 == v4 )\n      {\n        result = 1;\n        if ( v4 > 0 )\n          return result;\n      }\n      while ( 1 )\n      {\n        v3 = *(_DWORD **)v3;\n        if ( !v3 )\n          break;\n        v5 = v3[3];\n        if ( a2 == v5 && v5 > 0 )\n          return 1;\n      }\n    }\n    result = 0;\n    if ( a1 )\n    {\n      v6 = *(_DWORD *)(a1 + 8);\n      v7 = a2 | 0x80000000;\n      if ( v6 > 0 )\n      {\n        result = 1;\n        if ( *(_DWORD *)(a1 + 16) != v7 )\n        {\n          v8 = a1 + 24;\n          v9 = 8LL * (unsigned int)(v6 - 1) + 24 + a1;\n          while ( v8 != v9 )\n          {\n            v8 += 8LL;\n            if ( *(_DWORD *)(v8 - 8) == v7 )\n              return 1;\n          }\n          return 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "static int\nis_hidden_fd(struct redirtab *rp, int fd)\n{\n\tint i;\n\tstruct parsefile *pf;\n\n\tif (fd == -1)\n\t\treturn 0;\n\t/* Check open scripts' fds */\n\tpf = g_parsefile;\n\twhile (pf) {\n\t\t/* We skip pf_fd == 0 case because of the following case:\n\t\t * $ ash  # running ash interactively\n\t\t * $ . ./script.sh\n\t\t * and in script.sh: \"exec 9>&0\".\n\t\t * Even though top-level pf_fd _is_ 0,\n\t\t * it's still ok to use it: \"read\" builtin uses it,\n\t\t * why should we cripple \"exec\" builtin?\n\t\t */\n\t\tif (pf->pf_fd > 0 && fd == pf->pf_fd) {\n\t\t\treturn 1;\n\t\t}\n\t\tpf = pf->prev;\n\t}\n\n\tif (!rp)\n\t\treturn 0;\n\t/* Check saved fds of redirects */\n\tfd |= COPYFD_RESTORE;\n\tfor (i = 0; i < rp->pair_count; i++) {\n\t\tif (rp->two_fd[i].copy == fd) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "comment": "Checks if a file descriptor is already in use by open scripts or saved redirects in the given redirection table.",
    "hext5_sum": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert a potential utf-8 encoded sequence in in into the \"order\" of the file.",
    "bint5_sum": "Determines if a given file descriptor is included or excluded based on the provided flag and the list of included files .\n",
    "cpbcs_sum": "Retrieves the previous and priority of a specified CPU, returning a pointer to the number of sheets printed.\n",
    "misum_sum": "Retrieves the current file position in a dynamically allocated string based on the provided mode and service index and backup settings.\n",
    "decom_sum": "Checks whether the given integer ID exists in a global linked list or in the specified object's ID array, returning 1 if found.",
    "cfg_sum": "Checks if the given identifier matches a valid positive entry in a global list or an associated array within the specified structure.",
    "work_score": {
        "hext5": {
            "summary": "@param[in] opts the program options structure @returns the open file pointer. it may be null. convert a potential utf-8 encoded sequence in in into the \"order\" of the file.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes parameters and behavior involving a program options structure, returning a file pointer, and UTF-8 sequence conversion \u2014 none of which appear in the source code. The source code actually checks whether a file descriptor is hidden using parsefile and redirtab structures, with no mention of UTF-8 handling or file pointer returns. All claims are unrelated to the source, resulting in 0% accuracy.",
                "The summary's claims focus on parameters named 'opts', returning a file pointer, nullability, and UTF-8 conversion, none of which correspond to the source code semantics. The function in the source checks whether a given file descriptor is considered hidden, involving conditions on fd values, parsing linked structures, and saved redirects. The summary misses the primary purpose entirely and contains irrelevant and inaccurate details, resulting in no accurate claim coverage.",
                "The summary's claims are entirely inaccurate relative to the source code. The source implements a function to check whether a file descriptor is hidden, working with parsefile structures and redirect tables, but the summary describes program options, returning a file pointer, and UTF-8 conversion, none of which match the code. This is a FATAL error affecting the primary purpose and key I/O, making the description unreliable."
            ]
        },
        "bint5": {
            "summary": "Determines if a given file descriptor is included or excluded based on the provided flag and the list of included files .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary is vague and does not accurately reflect the source code\u2019s logic. The source code specifically checks whether a file descriptor matches certain conditions in the parsefile chain or saved redirections, with no mention of a generic \u2018provided flag\u2019 or \u2018list of included files.\u2019 The summary fails to capture these implementation details and introduces misleading terminology, resulting in no accurate claims.",
                "The summary fails to capture the actual semantics of the function. The source code checks whether a file descriptor should be considered 'hidden' based on current open script file descriptors and saved redirect file descriptors, including a special skip case for fd=0 and handling of COPYFD_RESTORE. The summary inaccurately describes inclusion/exclusion based on a 'provided flag' and 'list of included files,' which are not present in the implementation. This misses the primary purpose and all key secondary details, amounting to a misrepresentation.",
                "The summary claims the function determines if a file descriptor is included or excluded based on a provided flag and a list of included files, which contradicts the actual code. The code checks if a file descriptor is hidden by comparing it against open script file descriptors and saved redirect file descriptors, not flags or generic file lists. This is a FATAL error related to the primary purpose, resulting in high negative impact and no accurate informative claims."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the previous and priority of a specified CPU, returning a pointer to the number of sheets printed.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior related to CPU priority and sheet printing, which is entirely unrelated to the source code. The source function checks whether a file descriptor is hidden by examining parsefiles and saved redirects. None of the claims in the summary match the source implementation, making all claims inaccurate.",
                "The summary makes claims about CPU priority and sheets printed, which are unrelated to the source code. The source function checks if a given file descriptor is hidden based on open scripts or saved redirections, returning 1 if hidden or 0 otherwise. None of the claims in the summary accurately reflect the primary purpose or any secondary details in the source code, resulting in no coverage.",
                "The summary's claims are entirely inaccurate and unrelated to the source code. The source implements a function to check if a file descriptor is hidden based on parsefile structures and redirect tables, while the summary describes CPU priorities and sheet printing. This is a complete mismatch, representing a FATAL error affecting the primary purpose, making the description unreliable."
            ]
        },
        "misum": {
            "summary": "Retrieves the current file position in a dynamically allocated string based on the provided mode and service index and backup settings.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about retrieving a file position in a dynamically allocated string, involving mode, service index, and backup settings do not match the source code, which checks whether a file descriptor is hidden based on open scripts and redirect table data. None of the claims in the summary are accurate with respect to the implementation.",
                "The summary is entirely inaccurate: it describes retrieving a file position with modes, service index, and backup settings, which does not match the source code's primary purpose of determining whether a file descriptor is hidden due to open scripts or saved redirects. None of the claims align with the code\u2019s semantics, so the primary purpose and all secondary details are missed.",
                "The summary\u2019s claims describe retrieving a file position in a string with mode, service index, and backup settings, which is entirely unrelated to the source function. The source code checks whether a given file descriptor is hidden based on active parse files and redirect table entries, with no string handling, positions, or service indices. This is a complete semantic mismatch, constituting a FATAL error about the primary purpose of the function."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582823664,
    "strip_function_name": "sub_FFFFFFFF813CB4F0",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF813CB4F0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        __int64 a14)\n{\n  char v14; // bl\n  __int64 v15; // r12\n  __int64 *v16; // r13\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // r8\n  __int64 v23; // r9\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  char v26; // [rsp-20h] [rbp-20h]\n\n  if ( *(_DWORD *)(a1 - 96) == 8 )\n  {\n    v15 = *(_QWORD *)(a1 - 184);\n    v16 = *(__int64 **)(v15 + 840);\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_edp_panel_off\",\n      (__int64)\"Turn eDP power off\\n\",\n      a13,\n      a14,\n      v14);\n    if ( !*(_BYTE *)(a1 + 912) )\n      sub_FFFFFFFF8103BAE0(\n        (__int64)\"drivers/gpu/drm/i915/intel_dp.c\",\n        1148,\n        (__int64)\"Need VDD to turn off panel\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9);\n    v19 = sub_FFFFFFFF813C8A00(a1);\n    sub_FFFFFFFF8138EC40(\n      v16,\n      (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v15 + 840) + 16LL) + 7LL) & 8) == 0 ? 815620 : 1970692,\n      v19 & 0xFFFFFFF0,\n      a2,\n      a3,\n      a4,\n      a5,\n      v20,\n      v21,\n      a8,\n      a9);\n    *(_BYTE *)(a1 + 912) = 0;\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_wait_panel_off\",\n      (__int64)\"Wait for panel power off time\\n\",\n      v22,\n      v23,\n      v26);\n    sub_FFFFFFFF813CA800(a1, 0xB000000F, 0, a2, a3, a4, a5, v24, v25, a8, a9);\n  }\n}\n",
    "function_name": "ironlake_edp_panel_off",
    "decompiled_code": "void __fastcall ironlake_edp_panel_off(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r12\n  volatile signed __int16 *v10; // r13\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int pp_control; // eax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n\n  if ( *(_DWORD *)(a1 - 96) == 8 )\n  {\n    v9 = *(_QWORD *)(a1 - 184);\n    v10 = *(volatile signed __int16 **)(v9 + 840);\n    drm_ut_debug_printk(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_edp_panel_off\",\n      (__int64)\"Turn eDP power off\\n\",\n      a2,\n      a3,\n      a4,\n      a5,\n      a6,\n      a7,\n      a8,\n      a9);\n    if ( !*(_BYTE *)(a1 + 912) )\n      warn_slowpath_fmt(\n        \"drivers/gpu/drm/i915/intel_dp.c\",\n        0x47Cu,\n        (__int64)\"Need VDD to turn off panel\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n    pp_control = ironlake_get_pp_control(a1);\n    i915_write32(\n      v10,\n      (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v9 + 840) + 16LL) + 7LL) & 8) == 0 ? 815620 : 1970692,\n      pp_control & 0xFFFFFFF0,\n      a2,\n      a3,\n      a4,\n      a5,\n      v14,\n      v15,\n      a8,\n      a9);\n    *(_BYTE *)(a1 + 912) = 0;\n    drm_ut_debug_printk(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_wait_panel_off\",\n      (__int64)\"Wait for panel power off time\\n\",\n      a2,\n      a3,\n      a4,\n      a5,\n      v16,\n      v17,\n      a8,\n      a9);\n    ironlake_wait_panel_status(a1, 0xB000000F, 0, a2, a3, a4, a5, v18, v19, a8, a9);\n  }\n}\n",
    "source_code": "\nvoid ironlake_edp_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_device *dev = intel_dp_to_dev(intel_dp);\n\tstruct drm_i915_private *dev_priv = dev->dev_private;\n\tu32 pp;\n\tu32 pp_ctrl_reg;\n\n\tif (!is_edp(intel_dp))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"Turn eDP power off\\n\");\n\n\tWARN(!intel_dp->want_panel_vdd, \"Need VDD to turn off panel\\n\");\n\n\tpp = ironlake_get_pp_control(intel_dp);\n\t/* We need to switch off panel power _and_ force vdd, for otherwise some\n\t * panels get very unhappy and cease to work. */\n\tpp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = IS_VALLEYVIEW(dev) ? PIPEA_PP_CONTROL : PCH_PP_CONTROL;\n\n\tI915_WRITE(pp_ctrl_reg, pp);\n\tPOSTING_READ(pp_ctrl_reg);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tironlake_wait_panel_off(intel_dp);\n}",
    "comment": "Turns off eDP panel power by modifying control registers and ensuring no VDD is supplied, preventing panel damage during shutdown.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Enables DisplayPort functionality by initializing the panel , performing link training , and enabling backlight for the Intel display encoder .\n",
    "cpbcs_sum": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
    "misum_sum": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
    "decom_sum": "Turns off the Ironlake eDP panel, ensuring VDD is active, logs actions, updates power state, and waits for the panel power-down interval.",
    "cfg_sum": "Turns off the Ironlake eDP panel, logs actions, updates power state flags, and waits for the panel power-off timing to complete.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains a vague phrase that does not accurately reflect any part of the source code's semantics or behavior. It neither matches the eDP panel power-off logic nor corresponds to the specific control register operations in the implementation, making it unrelated to the source. As such, 0% of claims are accurate.",
                "The summary 'push a pointer type' is vague, generic, and unrelated to the actual source code semantics. It fails to identify the primary purpose of the function, which is turning off eDP panel power with specific register manipulations and conditions. No accurate claims were made, so there is no coverage of the critical semantic units.",
                "The summary 'push a pointer type.' is vague, non-specific, and does not describe any actual behavior or semantics from the source code. It is pure NOISE, offering no accurate or relevant information about the function's primary purpose (turning off an eDP panel, handling power and VDD). This results in zero positive gain and high irrelevance."
            ]
        },
        "bint5": {
            "summary": "Enables DisplayPort functionality by initializing the panel , performing link training , and enabling backlight for the Intel display encoder .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes enabling DisplayPort functionality, initialization, link training, and backlight activation, which contradicts the source code's actual purpose of turning off the eDP panel and disabling power/VDD. None of the claims align with the implementation, resulting in no accurate matches.",
                "The summary describes enabling and initializing a DisplayPort panel, which contradicts the source code\u2019s actual behavior of turning off eDP panel power, disabling backlight, clearing control flags, and waiting for panel shutdown. It completely misses the primary purpose and observable behavior in the code, making its claims inaccurate and unrelated to the CSU_LIST.",
                "The summary claims the function enables DisplayPort by initializing the panel, performing link training, and enabling backlight, which directly contradicts the source code. The source code is focused on turning off the eDP panel power, clearing control bits, and disabling VDD, not enabling or training the link. This is a FATAL error about the primary purpose, resulting in high negative impact and no accurate claims."
            ]
        },
        "cpbcs": {
            "summary": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
            "score": [
                0.6,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function disables the eDP backlight by modifying control registers and waiting for a delay after turning off the panel. The source code does modify the panel power control registers (clearing POWER_TARGET_ON, EDP_BLC_ENABLE, etc.) and waits for the panel to power off, but the primary action is turning off the entire panel power, not specifically targeting just the backlight. The 'specified delay' aspect is loosely implied by the wait function. While most of the summary is accurate, the focus on backlight reduction is misleading compared to the broader power-off behavior in the code.",
                "The summary captures the general idea of turning off eDP power by modifying control registers but misstates the primary purpose as backlight disable rather than panel power-off, which includes clearing multiple flags beyond backlight. It omits key secondary details such as the prerequisite `is_edp` check, warning about needing VDD, conditional register selection for Valleyview, and explicitly setting `want_panel_vdd` to false before waiting for the panel off. This indicates partial coverage of the primary purpose with notable inaccuracies and missing secondary details.",
                "The summary claims the function disables the eDP backlight and waits for a delay. In the source, the function disables overall panel power, force VDD, reset, and BLC enable bits\u2014not exclusively the backlight. The 'waiting for a specified delay' part is misleading since it calls a wait function without explicit delay logic in the summary context. This is a FATAL error targeting the primary purpose (actual operation is turning off full panel power, not just backlight). There's minimal accurate detail, so the net benefit is low."
            ]
        },
        "misum": {
            "summary": "Disables the eDP backlight by modifying control registers and waiting for a specified delay after turning off the panel.\n",
            "score": [
                0.5,
                0.5,
                0.2
            ],
            "reason": [
                "The summary contains two claims: (1) it disables the eDP backlight by modifying control registers, and (2) waits for a specified delay after turning off the panel. The first claim is inaccurate because the source code disables multiple aspects of panel power, not specifically just the backlight. The second claim matches the use of `ironlake_wait_panel_off(intel_dp)`, which introduces a delay after power-off. With only one of the two claims accurate, the proportion of accurate claims is 50%, indicating mixed reliability.",
                "The summary captures part of the function\u2019s purpose by noting that it disables the eDP backlight, which aligns with modifying power-related control registers. However, it misses the broader primary purpose of turning off the entire eDP panel, including handling FORCE_VDD, panel reset, and switching power off as per hardware requirements. It also omits key secondary details such as the conditional check for eDP type, specific register selection based on platform, warnings about VDD, and the use of POSTING_READ. The mention of 'waiting for a specified delay' is inaccurate, as the code calls a wait function without specifying a delay in the summary\u2019s wording, making coverage incomplete.",
                "The summary inaccurately states that the function disables the eDP backlight, while the source code primarily turns off panel power and VDD, clearing multiple bits including but not limited to backlight control. This is a FATAL error affecting the primary purpose of the function. The claim also introduces a 'specified delay' which is not explicit in the code; the code calls a wait function without any specific delay described. No highly specific and correct details about register selection or exact bits cleared are provided, resulting in low net benefit and high negative impact."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5730506,
    "strip_function_name": "sub_5770CA",
    "strip_decompiled_code": "__int64 __fastcall sub_5770CA(\n        _BYTE *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  __int64 v16; // rdx\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  __int64 v19; // r9\n  __int64 result; // rax\n  _QWORD v21[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v22; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v23; // [rsp+28h] [rbp-B0h]\n  __int64 v24; // [rsp+30h] [rbp-A8h]\n  __int64 v25; // [rsp+38h] [rbp-A0h]\n  __int64 v26; // [rsp+40h] [rbp-98h]\n  __int64 v27; // [rsp+48h] [rbp-90h]\n  __m128 v28; // [rsp+50h] [rbp-88h]\n  __m128 v29; // [rsp+60h] [rbp-78h]\n  __m128 v30; // [rsp+70h] [rbp-68h]\n  __m128 v31; // [rsp+80h] [rbp-58h]\n  __m128 v32; // [rsp+90h] [rbp-48h]\n  __m128 v33; // [rsp+A0h] [rbp-38h]\n  __m128 v34; // [rsp+B0h] [rbp-28h]\n  __m128 v35; // [rsp+C0h] [rbp-18h]\n\n  v23 = a2;\n  v24 = a3;\n  v25 = a4;\n  v26 = a5;\n  v27 = a6;\n  if ( v15 )\n  {\n    v28 = a7;\n    v29 = a8;\n    v30 = a9;\n    v31 = a10;\n    v32 = a11;\n    v33 = a12;\n    v34 = a13;\n    v35 = a14;\n  }\n  v21[0] = 0x3000000008LL;\n  v21[1] = &a15;\n  v21[2] = &v22;\n  sub_5176F5(\n    a1,\n    v21,\n    0LL,\n    *(double *)a7.m128_u64,\n    *(double *)a8.m128_u64,\n    *(double *)a9.m128_u64,\n    *(double *)a10.m128_u64,\n    *(double *)a11.m128_u64,\n    *(double *)a12.m128_u64,\n    *(double *)a13.m128_u64,\n    *(double *)a14.m128_u64);\n  result = *(unsigned int *)qword_89A638;\n  if ( !(_DWORD)result )\n    sub_517B39((__int64)a1, (__int64)v21, v16, v17, v18, v19);\n  return result;\n}\n",
    "function_name": "die_if_script",
    "decompiled_code": "__int64 __fastcall die_if_script(\n        const __m128i *a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        __int64 a6,\n        __m128 a7,\n        __m128 a8,\n        __m128 a9,\n        __m128 a10,\n        __m128 a11,\n        __m128 a12,\n        __m128 a13,\n        __m128 a14,\n        char a15)\n{\n  char v15; // al\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  __int64 result; // rax\n  __int64 v19[3]; // [rsp+8h] [rbp-D0h] BYREF\n  char v20; // [rsp+20h] [rbp-B8h] BYREF\n  __int64 v21; // [rsp+28h] [rbp-B0h]\n  __int64 v22; // [rsp+30h] [rbp-A8h]\n  __int64 v23; // [rsp+38h] [rbp-A0h]\n  __int64 v24; // [rsp+40h] [rbp-98h]\n  __int64 v25; // [rsp+48h] [rbp-90h]\n  __m128 v26; // [rsp+50h] [rbp-88h]\n  __m128 v27; // [rsp+60h] [rbp-78h]\n  __m128 v28; // [rsp+70h] [rbp-68h]\n  __m128 v29; // [rsp+80h] [rbp-58h]\n  __m128 v30; // [rsp+90h] [rbp-48h]\n  __m128 v31; // [rsp+A0h] [rbp-38h]\n  __m128 v32; // [rsp+B0h] [rbp-28h]\n  __m128 v33; // [rsp+C0h] [rbp-18h]\n\n  v21 = a2;\n  v22 = a3;\n  v23 = a4;\n  v24 = a5;\n  v25 = a6;\n  if ( v15 )\n  {\n    v26 = a7;\n    v27 = a8;\n    v28 = a9;\n    v29 = a10;\n    v30 = a11;\n    v31 = a12;\n    v32 = a13;\n    v33 = a14;\n  }\n  v19[0] = 0x3000000008LL;\n  v19[1] = (__int64)&a15;\n  v19[2] = (__int64)&v20;\n  bb_verror_msg(\n    a1,\n    v19,\n    0LL,\n    *(double *)a7.m128_u64,\n    *(double *)a8.m128_u64,\n    *(double *)a9.m128_u64,\n    *(double *)a10.m128_u64,\n    *(double *)a11.m128_u64,\n    *(double *)a12.m128_u64,\n    *(double *)a13.m128_u64,\n    *(double *)a14.m128_u64);\n  result = *(unsigned int *)ptr_to_globals;\n  if ( !(_DWORD)result )\n    xfunc_die(\n      *(double *)a7.m128_u64,\n      *(double *)a8.m128_u64,\n      *(double *)a9.m128_u64,\n      *(double *)a10.m128_u64,\n      v16,\n      v17,\n      *(double *)a13.m128_u64,\n      *(double *)a14.m128_u64);\n  return result;\n}\n",
    "source_code": "\nstatic void die_if_script(unsigned lineno, const char *fmt, ...)\n{\n\tva_list p;\n\n#if HUSH_DEBUG >= 2\n\tbb_error_msg(\"hush.c:%u\", lineno);\n#endif\n\tva_start(p, fmt);\n\tbb_verror_msg(fmt, p, NULL);\n\tva_end(p);\n\tif (!G_interactive_fd)\n\t\txfunc_die();\n}",
    "comment": "Logs an error message with the line number and format specified, then terminates the program if not in interactive mode.",
    "hext5_sum": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
    "bint5_sum": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
    "cpbcs_sum": "Executes an error message using a variable argument list and handles the response if the call fails.\n",
    "misum_sum": "Formats and sends an error message using a variable argument list to the `bb_verror_msg` function.\n",
    "decom_sum": "Packages input parameters into a structured array, processes them to produce double-precision results, and triggers a secondary routine if no result is available.",
    "cfg_sum": "Initializes provided parameters and vector data, executes a processing routine with them, and triggers a secondary routine if a global completion flag is unset.",
    "work_score": {
        "hext5": {
            "summary": "returns the filled buf, or null if the character does not have a name. looks up the name of a unicode character, in uppercase ascii.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims describe functionality about returning a buffer or null based on a Unicode character's name lookup, which is unrelated to the source code. The source code defines a function for error handling, printing debug info, and terminating if not interactive, with no Unicode name lookup. All claims are inaccurate and do not match the implementation.",
                "The summary describes a function that returns a buffer or null based on a unicode character name lookup, which is entirely unrelated to the source code. The source code implements an error-reporting function that prints a message, optionally logs the file and line in debug mode, and terminates the process if not interactive. The summary misses the primary purpose and all secondary details, making its claims inaccurate.",
                "The summary describes behavior about looking up Unicode character names and returning a buffer or null, which is entirely unrelated to the provided source code. The function in the source code handles error messaging and process termination, with no mention of Unicode or buffer return values. This is a clear NOISE case where all claims are inaccurate and irrelevant, leading to high negative impact from misinformation."
            ]
        },
        "bint5": {
            "summary": "Formats and sends an error message using a variable argument list to the ` bb_verror_msg ` function .\n",
            "score": [
                0.8,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately states that the function formats and sends an error message using a variable argument list to `bb_verror_msg`, which matches the implementation where `va_start` is used and `bb_verror_msg(fmt, p, NULL)` is called. However, it omits other significant behavior such as conditional debug logging, ending the variable argument list, and calling `xfunc_die()` when not interactive. This makes the claim accurate but incomplete, with most of its limited scope correctly aligned to the source code.",
                "The summary correctly notes that the function formats and sends an error message using a variable argument list to `bb_verror_msg`, which aligns with the source code's core action. However, it omits key secondary details: the conditional debug logging via `bb_error_msg`, the invocation of `xfunc_die()` when `G_interactive_fd` is false, and the specific use of `va_start`/`va_end` for argument handling. It captures part of the primary purpose but misses multiple important behaviors, making coverage partial rather than comprehensive.",
                "The single claim correctly identifies that the function formats and sends an error message to `bb_verror_msg` using a variable argument list, which matches the source code. However, it omits specific behaviors such as the conditional debug logging (`bb_error_msg`), the check on `G_interactive_fd`, and the possible program termination via `xfunc_die`. The claim is accurate but low in detail, offering little insight beyond a generic description, and there is no evidence of fatal inaccuracies."
            ]
        },
        "cpbcs": {
            "summary": "Executes an error message using a variable argument list and handles the response if the call fails.\n",
            "score": [
                0.5,
                0.4,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function uses a variable argument list to execute an error message, which matches the use of va_list and bb_verror_msg in the source. However, the claim about handling the response if the call fails is unsupported by the code; instead, the code triggers xfunc_die() when not in interactive mode, not based on a failure check. This results in partial accuracy with one precise match and one incorrect implication.",
                "The summary correctly notes use of a variable argument list and displaying an error message, aligning partially with the source code. However, it inaccurately describes 'handling the response if the call fails', which is not present \u2014 the function terminates if not interactive rather than reacting to a failed call. It misses the specific conditions for termination, the debug message for high HUSH_DEBUG levels, and the fact that termination is unconditional based on `G_interactive_fd`, not related to call failure.",
                "The summary makes a broad claim about executing an error message with a variable argument list, which is accurate to the code's use of `va_list` and `bb_verror_msg`. However, the claim that it 'handles the response if the call fails' is inaccurate, as the code handles non-interactive mode by calling `xfunc_die()` rather than responding to a failed call. This is a FATAL error relating to key side effect semantics, significantly reducing reliability."
            ]
        },
        "misum": {
            "summary": "Formats and sends an error message using a variable argument list to the `bb_verror_msg` function.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately describes a core behavior of the function \u2014 it uses a variable argument list and passes it to `bb_verror_msg` to format and send an error message. While the summary omits mention of conditional debugging output and process termination logic, the described claim directly matches the code\u2019s implementation without contradiction, yielding high claim accuracy.",
                "The summary correctly notes that the function formats and sends an error message using a variable argument list to `bb_verror_msg`, which aligns with the core implementation. However, it omits key secondary details from the source, including the conditional debug logging with `bb_error_msg` when `HUSH_DEBUG >= 2` and the termination behavior via `xfunc_die()` when `G_interactive_fd` is false. While the primary purpose is captured, important branching logic and side effects are missed.",
                "The summary contains a single accurate claim: it describes formatting and sending an error message to `bb_verror_msg` using a variable argument list, which matches the function\u2019s implementation. However, it omits key details such as the conditional debug printing, the conditional call to `xfunc_die()`, and the specific purpose tied to script execution errors. This results in low informational value and no fatal inaccuracies, but the description is too generic to strongly aid understanding."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580415600,
    "strip_function_name": "sub_FFFFFFFF8117F670",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8117F670(\n        unsigned int a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // r13\n  __int64 v13; // rax\n  signed __int64 v14; // r14\n  int v15; // r15d\n  int v16; // eax\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  int v19; // r9d\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // rdx\n  __int64 v24; // [rsp+0h] [rbp-40h] BYREF\n  __int64 v25; // [rsp+8h] [rbp-38h]\n  unsigned int v26; // [rsp+10h] [rbp-30h]\n  int v27; // [rsp+14h] [rbp-2Ch]\n\n  v11 = -14LL;\n  if ( !((__PAIR128__(-(__int64)__CFADD__(a3, a2), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n        - ((unsigned __int64)a3\n         + a2)) >> 64) )\n  {\n    v13 = sub_FFFFFFFF8114FAA0(a1, &v24);\n    v14 = v13;\n    v15 = v24;\n    if ( !v13 )\n      return -9LL;\n    v24 = a2;\n    v25 = 0LL;\n    v26 = a3;\n    v27 = 0;\n    v16 = sub_FFFFFFFF81146A70(v13, (__int64)sub_FFFFFFFF8117E4F0, (__int64)&v24);\n    v22 = v25;\n    if ( v16 >= 0 )\n      v16 = v27;\n    if ( v25 )\n    {\n      v17 = *(_QWORD *)(v14 + 72);\n      *(_QWORD *)(v25 + 8) = v17;\n      v11 = (int)(a3 - v26);\n      if ( v15 )\nLABEL_10:\n        sub_FFFFFFFF81136100(v14, a4, a5, a6, a7, v20, v21, a10, a11, (__int64)sub_FFFFFFFF8117E4F0, v22, v17, v18, v19);\n    }\n    else\n    {\n      v11 = v16;\n      if ( v15 )\n        goto LABEL_10;\n    }\n  }\n  return v11;\n}\n",
    "function_name": "compat_sys_getdents64",
    "decompiled_code": "__int64 __fastcall compat_sys_getdents64(\n        unsigned int a1,\n        __int64 a2,\n        unsigned int a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 v11; // r13\n  __int64 v13; // rax\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  signed __int64 v16; // r14\n  int v17; // r15d\n  int v18; // eax\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  __int64 v22; // [rsp+0h] [rbp-40h] BYREF\n  __int64 v23; // [rsp+8h] [rbp-38h]\n  unsigned int v24; // [rsp+10h] [rbp-30h]\n  int v25; // [rsp+14h] [rbp-2Ch]\n\n  v11 = -14LL;\n  if ( !((__PAIR128__(-(__int64)__CFADD__(a3, a2), *(_QWORD *)(__readgsqword(0xA760u) - 8120))\n        - ((unsigned __int64)a3\n         + a2)) >> 64) )\n  {\n    v13 = fget_light(a1, &v22);\n    v16 = v13;\n    v17 = v22;\n    if ( !v13 )\n      return -9LL;\n    v22 = a2;\n    v23 = 0LL;\n    v24 = a3;\n    v25 = 0;\n    v18 = vfs_readdir(v13, (__int64)compat_filldir64, (__int64)&v22, a4, a5, a6, a7, v14, v15, a10, a11);\n    if ( v18 >= 0 )\n      v18 = v25;\n    if ( v23 )\n    {\n      *(_QWORD *)(v23 + 8) = *(_QWORD *)(v16 + 72);\n      v11 = (int)(a3 - v24);\n      if ( v17 )\nLABEL_10:\n        fput(v16, a4, a5, a6, a7, v19, v20, a10, a11);\n    }\n    else\n    {\n      v11 = v18;\n      if ( v17 )\n        goto LABEL_10;\n    }\n  }\n  return v11;\n}\n",
    "source_code": "\nasmlinkage long compat_sys_getdents64(unsigned int fd,\n\t\tstruct linux_dirent64 __user * dirent, unsigned int count)\n{\n\tstruct fd f;\n\tstruct linux_dirent64 __user * lastdirent;\n\tstruct compat_getdents_callback64 buf;\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tbuf.current_dir = dirent;\n\tbuf.previous = NULL;\n\tbuf.count = count;\n\tbuf.error = 0;\n\n\terror = vfs_readdir(f.file, compat_filldir64, &buf);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\ttypeof(lastdirent->d_off) d_off = f.file->f_pos;\n\t\tif (__put_user_unaligned(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "comment": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the results, handling errors and offsets.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information .\n",
    "cpbcs_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
    "misum_sum": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
    "decom_sum": "Initializes a context for processing given parameters, invokes a callback, and performs additional computations when input size constraints and setup succeed.",
    "cfg_sum": "Validates input parameters against system state, initializes and registers a data handler, processes associated payload, and returns status based on execution outcome.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display do not match any behavior in the provided source code, which implements reading directory entries via compat_sys_getdents64. All claims are unrelated to the source function, resulting in no accurate alignment.",
                "The summary describes text processing involving control characters, escape sequences, static buffers, and Unicode conversion, which is entirely unrelated to the source code. The source code implements a system call to read directory entries with error checking and buffer handling, so none of the claims match or capture its primary purpose or secondary details.",
                "The summary's claims about replacing control characters, using a static buffer, and handling Unicode display do not match the source code, which implements compat_sys_getdents64 to read directory entries via vfs_readdir and manage user space buffers. All claims are unrelated to the actual semantics, resulting in overwhelming NOISE and no accurate information about the key I/O or side effects."
            ]
        },
        "bint5": {
            "summary": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary's single claim that the function retrieves directory entries from a file descriptor and populates a user-provided buffer is accurate and matches the source code's logic, which uses vfs_readdir with a callback to fill in user-space structures. There are no contradictory or irrelevant elements, and the claim is broad but safe, resulting in full alignment with the source semantics.",
                "The summary correctly captures the primary purpose of retrieving directory entries from a file descriptor and writing them to a user-provided buffer, aligning with the core behavior in the source code. However, it omits key secondary details such as error handling for invalid pointers and file descriptors, use of vfs_readdir with a specific callback, and updating d_off for the last entry. These omissions reduce completeness despite accurate coverage of the main purpose.",
                "The summary's single claim that the function retrieves directory entries from a file descriptor and populates a user-provided buffer aligns broadly with the source code, which uses vfs_readdir and copies data into the provided dirent pointer. This is a SAFE, generic description with low informational detail, omitting specifics such as access checks, error codes, and handling of d_off. There are no contradictory statements, so no FATAL impact, but the gain is minimal due to its vagueness."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function retrieves directory entries from a file descriptor and fills a user-provided buffer with the directory information, which matches the implementation involving vfs_readdir and writing to the provided dirent buffer. There are no contradictory or irrelevant claims, though the description is broad and lacks low-level specifics such as error handling or structure use, making it safe but not highly specific.",
                "The summary correctly captures the primary purpose of the function: retrieving directory entries from a given file descriptor and placing them into a user-provided buffer. However, it omits secondary details such as validation of user-space memory (access_ok), handling invalid file descriptors (-EBADF), error propagation from vfs_readdir, the adjustment of directory offsets, and finalizing the byte count returned. This limits completeness despite accurate core purpose coverage.",
                "The summary correctly states that the function retrieves directory entries from a file descriptor and populates a user-provided buffer, matching the core purpose and I/O behavior seen in the source code. It is accurate but very broad, offering minimal detail about parameters, error handling, or specific mechanics of population, which limits its value. There are no inaccuracies or contradictions, but the gain is low due to lack of specifics."
            ]
        },
        "misum": {
            "summary": "Retrieves directory entries from a file descriptor and populates a user-provided buffer with the directory information.\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly describes the broad purpose of the function: it reads directory entries from a file descriptor and writes them into a user-provided buffer. This aligns with the source code\u2019s use of `vfs_readdir` and filling `linux_dirent64` structures in user space. While the summary omits specific error handling and compatibility details, it contains no factual inaccuracies and matches the core functionality, making it a highly accurate high-level description.",
                "The summary correctly identifies the primary purpose of the function\u2014retrieving directory entries from a file descriptor and placing them into a user-provided buffer\u2014which matches the main behavior in the code via `vfs_readdir` and buffer population. However, it omits important secondary details, such as the initial `access_ok` write check, handling of invalid file descriptors (`-EBADF`), updating the `d_off` field, and error propagation logic. These omissions reduce completeness despite accurately describing the core purpose.",
                "The summary contains a single broad claim that matches the general purpose of the function: reading directory entries via a file descriptor into a user buffer. This is accurate but very low in detail, omitting key specifics such as error handling, use of access_ok, vfs_readdir, and updating d_off in the last entry. There are no inaccurate or contradictory statements, but the low-information nature results in minimal positive gain."
            ]
        }
    }
}
{
    "project_name": "gsl",
    "function_addr": 1154992,
    "strip_function_name": "gsl_multilarge_nlinear_eval_df",
    "strip_decompiled_code": "__int64 __fastcall gsl_multilarge_nlinear_eval_df(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        _QWORD *a4,\n        __int64 a5,\n        __int64 a6,\n        _QWORD *a7,\n        _QWORD *a8,\n        _QWORD *a9)\n{\n  bool v10; // zf\n  __int64 v11; // r8\n  __int64 v12; // rcx\n  __int64 (__fastcall *v13)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *); // r10\n  __int64 result; // rax\n\n  v10 = a4 == 0LL;\n  v11 = a7[3];\n  v12 = a7[4];\n  if ( v10 )\n  {\n    if ( !a8 )\n      goto LABEL_4;\n    if ( (_DWORD)a1 != 111 )\n    {\n      if ( (_DWORD)a1 != 112 )\n        goto LABEL_4;\nLABEL_23:\n      if ( *a8 == v12 )\n        goto LABEL_4;\n      goto LABEL_24;\n    }\nLABEL_15:\n    if ( *a8 == v11 )\n      goto LABEL_4;\nLABEL_24:\n    gsl_error(\"v vector has wrong size\", \"fdf.c\", 480LL, 19LL);\n    return 19LL;\n  }\n  if ( (_DWORD)a1 == 111 )\n  {\n    if ( *a4 != v12 )\n    {\nLABEL_19:\n      gsl_error(\"u vector has wrong size\", \"fdf.c\", 475LL, 19LL);\n      return 19LL;\n    }\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_15;\n  }\n  if ( (_DWORD)a1 == 112 )\n  {\n    if ( *a4 != v11 )\n      goto LABEL_19;\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_23;\n  }\nLABEL_4:\n  if ( !a9 || *a9 == v12 && a9[1] == v12 )\n  {\n    v13 = (__int64 (__fastcall *)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *))a7[1];\n    if ( v13 )\n    {\n      result = v13(a1, a2, a4, a7[5], a8, a9);\n      if ( a8 )\n        ++a7[7];\n      if ( a9 )\n        ++a7[8];\n    }\n  }\n  else\n  {\n    gsl_error(\"JTJ matrix has wrong size\", \"fdf.c\", 484LL, 19LL);\n    return 19LL;\n  }\n  return result;\n}\n",
    "function_name": "gsl_multilarge_nlinear_eval_df",
    "decompiled_code": "__int64 __fastcall gsl_multilarge_nlinear_eval_df(\n        __int64 TransJ,\n        const gsl_vector *x,\n        const gsl_vector *f,\n        const gsl_vector *u,\n        const gsl_vector *swts,\n        double h,\n        __int64 fdtype,\n        gsl_multilarge_nlinear_fdf *fdf,\n        gsl_vector *v,\n        gsl_matrix *JTJ,\n        gsl_vector *work,\n        gsl_block **a12,\n        gsl_block **a13)\n{\n  bool v14; // zf\n  gsl_block *block; // r8\n  gsl_block *v16; // rcx\n  __int64 (__fastcall *stride)(__int64, const gsl_vector *, const gsl_vector *, size_t, gsl_block **, gsl_block **, double); // r10\n  __int64 result; // rax\n\n  v14 = u == 0LL;\n  block = work->block;\n  v16 = *(gsl_block **)&work->owner;\n  if ( v14 )\n  {\n    if ( !a12 )\n      goto LABEL_4;\n    if ( (_DWORD)TransJ != 111 )\n    {\n      if ( (_DWORD)TransJ != 112 )\n        goto LABEL_4;\nLABEL_23:\n      if ( *a12 == v16 )\n        goto LABEL_4;\n      goto LABEL_24;\n    }\nLABEL_15:\n    if ( *a12 == block )\n      goto LABEL_4;\nLABEL_24:\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n      \"v vector has wrong size\",\n      \"fdf.c\",\n      480LL,\n      19LL,\n      block,\n      fdtype,\n      h);\n    return 19LL;\n  }\n  if ( (_DWORD)TransJ == 111 )\n  {\n    if ( (gsl_block *)u->size != v16 )\n    {\nLABEL_19:\n      ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n        \"u vector has wrong size\",\n        \"fdf.c\",\n        475LL,\n        19LL,\n        block,\n        fdtype,\n        h);\n      return 19LL;\n    }\n    if ( !a12 )\n      goto LABEL_4;\n    goto LABEL_15;\n  }\n  if ( (_DWORD)TransJ == 112 )\n  {\n    if ( (gsl_block *)u->size != block )\n      goto LABEL_19;\n    if ( !a12 )\n      goto LABEL_4;\n    goto LABEL_23;\n  }\nLABEL_4:\n  if ( !a13 || *a13 == v16 && a13[1] == v16 )\n  {\n    stride = (__int64 (__fastcall *)(__int64, const gsl_vector *, const gsl_vector *, size_t, gsl_block **, gsl_block **, double))work->stride;\n    if ( stride )\n    {\n      result = stride(TransJ, x, u, work[1].size, a12, a13, h);\n      if ( a12 )\n        ++work[1].data;\n      if ( a13 )\n        ++work[1].block;\n    }\n  }\n  else\n  {\n    ((void (__fastcall *)(const char *, const char *, __int64, __int64, gsl_block *, __int64, double))gsl_error)(\n      \"JTJ matrix has wrong size\",\n      \"fdf.c\",\n      484LL,\n      19LL,\n      block,\n      fdtype,\n      h);\n    return 19LL;\n  }\n  return result;\n}\n",
    "source_code": "\nint\ngsl_multilarge_nlinear_eval_df(const CBLAS_TRANSPOSE_t TransJ,\n                               const gsl_vector *x,\n                               const gsl_vector *f,\n                               const gsl_vector *u,\n                               const gsl_vector *swts,\n                               const double h,\n                               const gsl_multilarge_nlinear_fdtype fdtype,\n                               gsl_multilarge_nlinear_fdf *fdf,\n                               gsl_vector *v,\n                               gsl_matrix *JTJ,\n                               gsl_vector *work)\n{\n  const size_t n = fdf->n;\n  const size_t p = fdf->p;\n\n  if (u != NULL && ((TransJ == CblasNoTrans && u->size != p) ||\n                    (TransJ == CblasTrans && u->size != n)))\n    {\n      GSL_ERROR(\"u vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (v != NULL && ((TransJ == CblasNoTrans && v->size != n) ||\n                         (TransJ == CblasTrans && v->size != p)))\n    {\n      GSL_ERROR(\"v vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (JTJ != NULL && ((JTJ->size1 != p) || (JTJ->size2 != p)))\n    {\n      GSL_ERROR(\"JTJ matrix has wrong size\", GSL_EBADLEN);\n    }\n  else\n    {\n      int status;\n\n      if (fdf->df)\n        {\n          /* call user-supplied function */\n          status = ((*((fdf)->df)) (TransJ, x, u, fdf->params, v, JTJ));\n\n          if (v)\n            ++(fdf->nevaldfu);\n\n          if (JTJ)\n            ++(fdf->nevaldf2);\n        }\n      else\n        {\n#if 0\n          /* use finite difference Jacobian approximation */\n          status = gsl_multilarge_nlinear_df(h, fdtype, x, swts, fdf, f, df, work);\n#endif\n        }\n\n      return status;\n    }\n}",
    "comment": "Evaluates the Jacobian or its finite difference approximation for a nonlinear optimization problem, checking vector and matrix sizes for validity.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Evaluates the Jacobian matrix of a nonlinear model using either a user-defined function or finite difference approximation based on the provided inputs .\n",
    "cpbcs_sum": "Evaluates the result of a finite automaton based on the specified condition, adjusting the result and weight accordingly.\n",
    "misum_sum": "Evaluates a nonlinear fitting function, applying user-defined and function functions based on given type and function and function arguments, and updates results accordingly.\n",
    "decom_sum": "Validates vector and matrix dimensions for nonlinear large-scale evaluation and invokes the model's derivative function, reporting precise GSL errors on size mismatches.",
    "cfg_sum": "Validates vector and matrix dimensions for specific operation codes, reports size errors, and calls the appropriate evaluation function if inputs are correct.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior involving a static buffer, value conversion using printf formatting, handling of num_bytes, and hex output, none of which are present in the source code. The source function deals with vector/matrix size checks and calling a derivative function, so all claims in the summary are unrelated to the implementation and therefore inaccurate.",
                "The summary describes converting a value to a string in a static buffer using printf formatting or hex display, which is entirely unrelated to the source code. The source function evaluates a Jacobian or related matrix/vector sizes for a nonlinear evaluation, performs size checks, and calls a user-supplied derivative function. None of the summary's claims match the source code's purpose or behavior, so all claims are inaccurate and coverage is nonexistent.",
                "The summary's claims about returning a pointer to a static buffer, printf formatting, and hex conversion are completely unrelated to the source code, which is about evaluating a Jacobian derivative with size checks and error handling. All claims are NOISE and do not target the actual function semantics. The worst failure mode is overwhelming NOISE, providing zero useful insight into the source code."
            ]
        },
        "bint5": {
            "summary": "Evaluates the Jacobian matrix of a nonlinear model using either a user-defined function or finite difference approximation based on the provided inputs .\n",
            "score": [
                0.5,
                0.6,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function evaluates the Jacobian using either a user-defined function or a finite difference approximation, which matches the implementation\u2019s use of fdf->df and the commented-out finite difference call. However, it inaccurately generalizes the behavior: the finite difference path is disabled via #if 0, meaning in the actual code only the user-defined function is used. This makes the claim partially inaccurate, as it implies active finite difference capability not present in current implementation.",
                "The summary captures the primary purpose of evaluating the Jacobian of a nonlinear model using either a user-provided function or finite difference approximation, which aligns with the source code\u2019s core logic. However, it misses important secondary details such as input validation for vector and matrix sizes, specific handling based on TransJ orientation, the conditional absence of finite difference implementation (disabled code block), and updates to evaluation counters when v or JTJ are provided. These omissions reduce completeness.",
                "The summary states that the function evaluates the Jacobian matrix using either a user-defined function or a finite difference approximation. While the first part is accurate\u2014there is a branch calling a user-supplied df function\u2014the finite difference branch is disabled with #if 0, meaning it is not used in the provided code. This is a FATAL inaccuracy since it misrepresents the actual available computation path, which directly addresses the primary purpose of the function. Positive detail beyond that is minimal, so net benefit is low."
            ]
        },
        "cpbcs": {
            "summary": "Evaluates the result of a finite automaton based on the specified condition, adjusting the result and weight accordingly.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the function evaluates a finite automaton and adjusts result and weight, which is inaccurate because the source code evaluates derivatives or the Jacobian in a numerical optimization context, with checks on vector and matrix sizes. None of the claims match the source code\u2019s semantics, resulting in no accurate claims.",
                "The summary is inaccurate because it describes evaluating a finite automaton and adjusting results and weights, which is unrelated to the source code. The function in the source actually validates input vector/matrix sizes, invokes a user-supplied derivative function or a finite difference approximation, and updates evaluation counters. The primary purpose and key details in the code are completely missed.",
                "The summary is entirely inaccurate and constitutes NOISE, as it describes evaluating a finite automaton, which is unrelated to the actual function. The source code evaluates a Jacobian or related matrix/vector in a numerical algorithm, validates input sizes, and optionally calls a user-supplied derivative function. No claims in the summary match the code semantics, so there is no positive gain and full misalignment."
            ]
        },
        "misum": {
            "summary": "Evaluates a nonlinear fitting function, applying user-defined and function functions based on given type and function and function arguments, and updates results accordingly.\n",
            "score": [
                0.2,
                0.4,
                0.5
            ],
            "reason": [
                "The summary contains vague and repetitive statements such as 'function functions' and does not clearly capture specific fact-based claims from the source code. It fails to mention key implementation details like vector/matrix size checks, handling of TransJ flags, or the conditional use of the user-supplied derivative function. Most of the implied claims are either too broad or inaccurate in targeting actual code semantics, resulting in low alignment.",
                "The summary correctly implies using a user-defined function in evaluation, which aligns with the code's call to fdf->df, but it fails to capture the primary purpose precisely: evaluating the derivative/Jacobian in large-scale nonlinear fitting using provided vectors/matrices, with error checks for input sizes. It omits key secondary details such as different size validations for u, v, and JTJ, condition on TransJ, incrementing evaluation counters, and the finite difference alternative. The phrase 'function functions' is unclear, and no mention of derivative evaluation or size error handling weakens alignment.",
                "The summary is vague and contains inaccuracies. It mentions evaluating a nonlinear fitting function with 'user-defined and function functions based on given type and arguments,' which is imprecise and does not clearly match the code's actual behavior. The source actually evaluates the derivative (Jacobian) via a user-supplied function when available, performs detailed size checks on input vectors and matrices, and updates evaluation counters accordingly. The summary omits these specifics and adds unclear, redundant phrasing, resulting in mostly low-information SAFE claims with some NOISE. The worst failure mode is NOISE, as the description does not contradict key semantics but fails to convey them usefully."
            ]
        }
    }
}
{
    "project_name": "poke",
    "function_addr": 794656,
    "strip_function_name": "sub_C2020",
    "strip_decompiled_code": "__int64 __fastcall sub_C2020(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(_QWORD))\n{\n  unsigned __int64 v6; // rax\n  unsigned __int64 v7; // rdx\n  _QWORD *v8; // rbx\n  __int64 result; // rax\n  __int64 v10; // rsi\n  __int64 v11; // rdx\n  _QWORD *v12; // rsi\n  _QWORD *v13; // rax\n  unsigned __int64 v14; // rcx\n  unsigned __int64 v15; // [rsp+8h] [rbp-30h]\n  __int64 (__fastcall *v16)(_QWORD); // [rsp+8h] [rbp-30h]\n\n  v6 = a1[1];\n  if ( v6 >= (3 * *a1) >> 2 )\n  {\n    v16 = a4;\n    sub_17CF7(a1, (__int64)a4);\n    v6 = a1[1];\n    a4 = v16;\n  }\n  a1[1] = v6 + 1;\n  v7 = a4(a2) % *a1;\n  v8 = *(_QWORD **)(a1[2] + 8 * v7);\n  if ( v8 )\n  {\n    result = v8[2];\n  }\n  else\n  {\n    v15 = v7;\n    v13 = (_QWORD *)sub_C3420(24LL);\n    *v13 = 4LL;\n    v13[1] = 0LL;\n    v8 = v13;\n    result = sub_C3420(64LL);\n    v14 = a1[2];\n    v8[2] = result;\n    *(_QWORD *)(v14 + 8 * v15) = v8;\n  }\n  v10 = v8[1];\n  if ( v10 == *v8 )\n  {\n    *v8 = 2 * v10;\n    result = sub_C3470(result);\n    v10 = v8[1];\n    v8[2] = result;\n  }\n  v11 = v10 + 1;\n  v12 = (_QWORD *)(result + 16 * v10);\n  v8[1] = v11;\n  *v12 = a2;\n  v12[1] = a3;\n  return result;\n}\n",
    "function_name": "jitter_hash_table_add",
    "decompiled_code": "void __fastcall jitter_hash_table_add(\n        jitter_hash_table *t,\n        const jitter_word key,\n        const jitter_word value,\n        jitter_hash_function f)\n{\n  size_t binding_no; // rax\n  jitter_uint v7; // rdx\n  jitter_hash_bucket *v8; // rbx\n  jitter_hash_binding *bindings; // rax\n  size_t used_binding_no; // rsi\n  size_t v11; // rdx\n  jitter_word *p_key; // rsi\n  jitter_hash_bucket *v13; // rax\n  jitter_hash_bucket **buckets; // rcx\n  jitter_uint v15; // [rsp+40h] [rbp+8h]\n  jitter_uint (*v16)(const jitter_word); // [rsp+40h] [rbp+8h]\n\n  binding_no = t->binding_no;\n  if ( binding_no >= (3 * t->bucket_no) >> 2 )\n  {\n    v16 = f;\n    jitter_hash_table_enlarge(t, f);\n    binding_no = t->binding_no;\n    f = v16;\n  }\n  t->binding_no = binding_no + 1;\n  v7 = f(key) % t->bucket_no;\n  v8 = t->buckets[v7];\n  if ( v8 )\n  {\n    bindings = v8->bindings;\n  }\n  else\n  {\n    v15 = v7;\n    v13 = (jitter_hash_bucket *)jitter_xmalloc(0x18uLL);\n    v13->allocated_binding_no = 4LL;\n    v13->used_binding_no = 0LL;\n    v8 = v13;\n    bindings = (jitter_hash_binding *)jitter_xmalloc(0x40uLL);\n    buckets = t->buckets;\n    v8->bindings = bindings;\n    buckets[v15] = v8;\n  }\n  used_binding_no = v8->used_binding_no;\n  if ( used_binding_no == v8->allocated_binding_no )\n  {\n    v8->allocated_binding_no = 2 * used_binding_no;\n    bindings = (jitter_hash_binding *)jitter_xrealloc(bindings, 32 * used_binding_no);\n    used_binding_no = v8->used_binding_no;\n    v8->bindings = bindings;\n  }\n  v11 = used_binding_no + 1;\n  p_key = &bindings[used_binding_no].key;\n  v8->used_binding_no = v11;\n  p_key->fixnum = key.fixnum;\n  p_key[1].fixnum = value.fixnum;\n}\n",
    "source_code": "\nvoid\njitter_hash_table_add (struct jitter_hash_table *t,\n                       const union jitter_word key,\n                       const union jitter_word value,\n                       jitter_hash_function f)\n{\n  /* We only enlarge the table (when it's getting too full) on add, and never\n     shrink it. */\n  if (jitter_hash_table_overfull (t))\n    jitter_hash_table_enlarge (t, f);\n\n  t->binding_no ++;\n  jitter_uint bucket_index = f (key) % t->bucket_no;\n\n  /* Find the bucket; make it if needed. */\n  struct jitter_hash_bucket *b = t->buckets [bucket_index];\n  if (b == NULL)\n    {\n      b = jitter_xmalloc (sizeof (struct jitter_hash_bucket));\n      b->allocated_binding_no = INITIAL_BINDING_NO_PER_BUCKET;\n      b->used_binding_no = 0;\n      b->bindings\n        = jitter_xmalloc (sizeof (struct jitter_hash_binding)\n                          * INITIAL_BINDING_NO_PER_BUCKET);\n      t->buckets [bucket_index] = b;\n    }\n\n  /* Find the binding where we need to write within the bucket; make place and\n     reallocate if needed. */\n  if (b->used_binding_no == b->allocated_binding_no)\n    {\n      //printf (\"enlarging the %i-th bucket: %li to %li\\n\", (int)bucket_index, (long)b->allocated_binding_no, (long)(b->allocated_binding_no * 2));\n\n      b->bindings = jitter_xrealloc (b->bindings,\n                                     sizeof (struct jitter_hash_binding)\n                                     * (b->allocated_binding_no *= 2));\n    }\n  struct jitter_hash_binding *bi = b->bindings + (b->used_binding_no ++);\n  bi->key = key;\n  bi->value = value;\n}",
    "comment": "Adds a key-value pair to a jitter hash table, reallocating bucket space if necessary, while ensuring the table size increases when overfull.",
    "hext5_sum": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
    "bint5_sum": "Sorts an array of pointers using the merge sort algorithm , leveraging a temporary array for merging during the sorting process .\n",
    "cpbcs_sum": "Adds a new entry to an array, reallocating memory if necessary, and initializes the entry's data to accommodate the new entry.\n",
    "misum_sum": "Inserts an element into a hash table using a key and an associated key, resizing the array as needed.\n",
    "decom_sum": "Inserts a key\u2013value pair into a hash table, allocating or resizing bucket arrays as needed and handling collisions via per-bucket dynamic arrays.",
    "cfg_sum": "Adds a key-value pair into a hash table, resizing and allocating buckets as needed, and stores associated data in dynamically managed arrays.",
    "work_score": {
        "hext5": {
            "summary": "returns the index of the selected item in the specified list after calling it to set up, the analyzer calls dbegetfunclist return the table most of the data is destined for a jtable master function to generate all tab data for the analyzer",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary\u2019s claims reference returning an index of a selected item, calling an analyzer, and operations involving 'dbegetfunclist' and 'jtable master function', none of which align with the source code\u2019s implementation of adding key-value bindings to a hash table, enlarging buckets when full, and computing bucket indices via a hash function. All claims are unrelated to the actual code semantics, resulting in no accurate matches.",
                "The summary's claims do not match the source code at all. The described behavior about returning an index from a list, calling analyzer functions, and generating table data for a master function is unrelated to the actual function, which adds a key-value binding to a hash table, enlarges the table if overfull, allocates buckets, and resizes bucket bindings as needed. The primary purpose and all secondary details from the source are completely missed, and the claims are inaccurate.",
                "The summary\u2019s claims are unrelated to the source code semantics, focusing on list item indices, analyzer functions, and table generation, none of which are implemented in the provided function. This constitutes overwhelming NOISE, as no fact-based claims match the actual hash table add logic, nor key I/O or side effects in the code. There are no accurate details to provide positive gain."
            ]
        },
        "bint5": {
            "summary": "Sorts an array of pointers using the merge sort algorithm , leveraging a temporary array for merging during the sorting process .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes merge-sorting an array of pointers using a temporary array, which is unrelated to the source code logic. The source implements adding a key-value pair to a hash table with bucket management and dynamic resizing, not sorting. All claims are inaccurate as they do not target or match the source code semantics.",
                "The summary describes sorting an array of pointers with merge sort and a temporary array, which is entirely unrelated to the source code. The source code implements adding a key-value pair to a hash table, handling table growth when full, allocating buckets, and reallocating bindings as necessary. The summary misses the primary purpose and all secondary details, making its claims inaccurate noise.",
                "The summary claims the code sorts an array of pointers using merge sort with a temporary array, which directly contradicts the source code. The actual implementation adds a key-value pair to a hash table, enlarging buckets as needed. This is a FATAL inaccuracy targeting the primary purpose and key functionality, making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Adds a new entry to an array, reallocating memory if necessary, and initializes the entry's data to accommodate the new entry.\n",
            "score": [
                0.6,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly notes adding a new entry and reallocating memory if needed, which matches the code's behavior of adding a binding to a hash bucket and reallocating when full. However, it inaccurately generalizes to 'an array' and omits key specifics such as hash function usage, bucket selection, and initializing key/value for a hash table, reducing precision. Most core operations are represented accurately, but with overly broad phrasing.",
                "The summary captures a generic notion of adding an entry and reallocating memory if needed, which aligns broadly with the code's behavior. However, it misses the PRIMARY PURPOSE of adding a key-value pair to a hash table, omits critical details such as computing the bucket index using the provided hash function, handling bucket allocation, enlarging the table when overfull, and tracking binding counts. These omissions mean it only partially reflects the function's actual contract and does not cover key secondary aspects of the implementation.",
                "The summary contains a broad SAFE claim about adding a new entry and reallocating memory if needed, which aligns partially with the source code's behavior of adding a binding to a hash table bucket and expanding capacity when required. However, it oversimplifies and misrepresents the structure by calling it an array instead of a hash table with buckets and hash functions, omitting important details like bucket allocation, hash computation, and table enlargement logic. This results in low gain due to lack of specificity, but no fatal contradictions regarding primary purpose, key I/O, or side effects."
            ]
        },
        "misum": {
            "summary": "Inserts an element into a hash table using a key and an associated key, resizing the array as needed.\n",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary claims the function inserts an element into a hash table using a key and an associated key, which is inaccurate because the source code clearly shows it uses a key and an associated value. While it correctly notes resizing when needed, the core semantic about the parameters is wrong, making less than half of the claims accurate.",
                "The summary captures the primary purpose of inserting into a hash table with resizing but contains an inaccuracy by stating 'associated key' instead of 'associated value'. It misses key secondary details from the source code such as enlarging the table only when overfull, initializing buckets when null, and doubling bucket capacity when full. The coverage is incomplete and contains a semantic error in the description of the value parameter.",
                "The summary contains a critical inaccuracy: it states 'associated key' instead of the correct 'associated value,' which contradicts the core semantics of the source code\u2019s primary purpose of adding a key-value pair. This is a FATAL error about the key I/O. While it mentions resizing as needed, which is accurate, the primary-purpose misstatement significantly undermines reliability."
            ]
        }
    }
}
{
    "project_name": "squashfs",
    "function_addr": 93040,
    "strip_function_name": "sub_16B70",
    "strip_decompiled_code": "__int64 __fastcall sub_16B70(__int64 a1, unsigned int a2, __int64 *a3)\n{\n  __int64 v4; // rcx\n  __int64 *v5; // rbx\n  __int64 result; // rax\n  __int64 v7; // rdx\n  __int64 v8; // r13\n  __int64 v9; // rcx\n  __int64 v10; // rax\n\n  v4 = a3[1];\n  v5 = *(__int64 **)(a1 + 48);\n  result = qword_829940[(unsigned __int16)v4];\n  if ( result )\n  {\n    v7 = *a3;\n    while ( *(_QWORD *)result != v7 || v4 != *(_QWORD *)(result + 8) )\n    {\n      result = *(_QWORD *)(result + 24);\n      if ( !result )\n        goto LABEL_7;\n    }\n    a2 = *(_DWORD *)(result + 16);\n  }\nLABEL_7:\n  while ( v5 )\n  {\n    v8 = v5[3];\n    if ( !*(_BYTE *)(v8 + 174) )\n    {\n      result = *(_DWORD *)(v8 + 24) & 0xF000;\n      if ( (_DWORD)result == 0x4000 )\n      {\n        result = sub_16B70(v5[4], a2, v5[3]);\n        v5 = (__int64 *)v5[6];\n        continue;\n      }\n      if ( (_DWORD)result == 0x8000 )\n      {\n        sub_72F0(v5);\n        v9 = *(_QWORD *)(v8 + 8);\n        v10 = qword_829940[(unsigned __int16)v9];\n        if ( !v10 )\n        {\nLABEL_21:\n          result = (__int64)sub_16660((__int64)v5, a2);\n          v5 = (__int64 *)v5[6];\n          continue;\n        }\n        while ( *(_QWORD *)v10 != *(_QWORD *)v8 || v9 != *(_QWORD *)(v10 + 8) )\n        {\n          v10 = *(_QWORD *)(v10 + 24);\n          if ( !v10 )\n            goto LABEL_21;\n        }\n        result = (__int64)sub_16660((__int64)v5, *(_DWORD *)(v10 + 16));\n      }\n    }\n    v5 = (__int64 *)v5[6];\n  }\n  return result;\n}\n",
    "function_name": "generate_file_priorities",
    "decompiled_code": "__int64 __fastcall generate_file_priorities(\n        __int64 a1,\n        unsigned int a2,\n        __int64 *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int64 v12; // rcx\n  __int64 v13; // rbx\n  __int64 result; // rax\n  __int64 v15; // rdx\n  __int64 v16; // r13\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  __int64 v19; // rcx\n  __int64 v20; // rax\n\n  v12 = a3[1];\n  v13 = *(_QWORD *)(a1 + 48);\n  result = sort_info_list[(unsigned __int16)v12];\n  if ( result )\n  {\n    v15 = *a3;\n    while ( *(_QWORD *)result != v15 || v12 != *(_QWORD *)(result + 8) )\n    {\n      result = *(_QWORD *)(result + 24);\n      if ( !result )\n        goto LABEL_7;\n    }\n    a2 = *(_DWORD *)(result + 16);\n  }\nLABEL_7:\n  while ( v13 )\n  {\n    v16 = *(_QWORD *)(v13 + 24);\n    if ( !*(_BYTE *)(v16 + 174) )\n    {\n      result = *(_DWORD *)(v16 + 24) & 0xF000;\n      if ( (_DWORD)result == 0x4000 )\n      {\n        result = generate_file_priorities(*(_QWORD *)(v13 + 32), a2, *(__int64 **)(v13 + 24));\n        v13 = *(_QWORD *)(v13 + 48);\n        continue;\n      }\n      if ( (_DWORD)result == 0x8000 )\n      {\n        pathname((__int64 *)v13);\n        v19 = *(_QWORD *)(v16 + 8);\n        v20 = sort_info_list[(unsigned __int16)v19];\n        if ( !v20 )\n        {\nLABEL_21:\n          result = (__int64)add_priority_list(v13, a2, a4, a5, a6, a7, v17, v18, a10, a11);\n          v13 = *(_QWORD *)(v13 + 48);\n          continue;\n        }\n        while ( *(_QWORD *)v20 != *(_QWORD *)v16 || v19 != *(_QWORD *)(v20 + 8) )\n        {\n          v20 = *(_QWORD *)(v20 + 24);\n          if ( !v20 )\n            goto LABEL_21;\n        }\n        result = (__int64)add_priority_list(v13, *(_DWORD *)(v20 + 16), a4, a5, a6, a7, v17, v18, a10, a11);\n      }\n    }\n    v13 = *(_QWORD *)(v13 + 48);\n  }\n  return result;\n}\n",
    "source_code": "\n\nvoid generate_file_priorities(struct dir_info *dir, int priority,\n\tstruct stat *buf)\n{\n\tstruct dir_ent *dir_ent = dir->list;\n\n\tpriority = get_priority(dir->pathname, buf, priority);\n\n\tfor(; dir_ent; dir_ent = dir_ent->next) {\n\t\tstruct stat *buf = &dir_ent->inode->buf;\n\t\tif(dir_ent->inode->root_entry)\n\t\t\tcontinue;\n\n\t\tswitch(buf->st_mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tadd_priority_list(dir_ent,\n\t\t\t\t\tget_priority(pathname(dir_ent), buf,\n\t\t\t\t\tpriority));\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tgenerate_file_priorities(dir_ent->dir,\n\t\t\t\t\tpriority, buf);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "comment": "Recursively assigns priority values to regular files and directories within a specified directory structure based on their pathnames and inode information.",
    "hext5_sum": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
    "bint5_sum": "Finds the next available port for a given PCI device and updates the last port ID accordingly .\n",
    "cpbcs_sum": "Retrieves a specified database from the connection and sends it to the error if the connection is not marked as a local symbol.\n",
    "misum_sum": "The function skips whitespace and sets the next element in a directory structure, handling local and pattern matching as needed.\n",
    "decom_sum": "Traverses a hierarchical structure to match identifier pairs, propagates a code value to children, and triggers processing routines for specific type flags.",
    "cfg_sum": "Traverses and inspects hierarchical linked structures, updating IDs from a lookup table and invoking helper routines based on node type and state flags.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims describe returning a pointer to a static buffer with a formatted section name and behavior similar to print_symbol without multibyte support, which is entirely unrelated to the source code's implementation of generating file priorities based on directory entries and file types. None of the claims match or are supported by the source code, indicating no alignment.",
                "The summary describes functionality related to returning a pointer to a static buffer for section names and character printing, which has no relation to the actual source code that recursively generates file priorities based on directory entries and file types. It completely misses the primary purpose and all secondary details, making the claims irrelevant and inaccurate.",
                "The summary's claims describe returning a pointer to a static buffer with section name formatting and character handling, which does not correspond at all to the source code's functionality of generating file priorities in a directory structure. This constitutes pure NOISE with zero alignment to key I/O or primary purpose. There are no accurate claims, and all content is unrelated to the implementation."
            ]
        },
        "bint5": {
            "summary": "Finds the next available port for a given PCI device and updates the last port ID accordingly .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function finds the next available port for a PCI device and updates the last port ID, which is entirely unrelated to the source code. The source code processes directory entries, sets priorities based on file type, and recursively handles subdirectories. None of the summary's claims match the actual implementation, resulting in 0% accurate claims.",
                "The summary describes functionality related to PCI device port allocation, which is entirely unrelated to the source code. The source code processes directory entries, determines file types, and updates a priority list recursively. This mismatch indicates the summary misses the primary purpose and all secondary details of the source code.",
                "The summary claims the function finds the next available port for a PCI device and updates the last port ID, which is entirely unrelated to the source code. The source function assigns priorities to files and directories recursively based on their mode, with no PCI or port handling. This is a FATAL error affecting the primary purpose of the code, creating high negative impact and making the description unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves a specified database from the connection and sends it to the error if the connection is not marked as a local symbol.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes behavior involving database retrieval, connection handling, and error reporting, which is entirely unrelated to the source code. The source code implements file priority generation through directory traversal and conditional logic on file types, with no references to databases or connections. All claims are inaccurate, resulting in no alignment with the implementation.",
                "The summary describes retrieving a database from a connection and sending it to an error if not marked as a local symbol, which is entirely unrelated to the actual function's primary purpose of generating file priorities by traversing directory entries and handling files/directories. None of the summary's claims match the source code semantics, resulting in no coverage of any critical semantic units.",
                "The summary claims the function retrieves a database from a connection and handles an error based on a local symbol flag, which is entirely unrelated to the actual source code. The code is about traversing directory entries and assigning priorities based on file types. This is a FATAL error regarding the primary purpose, as the described operations and context do not match any aspect of the implementation."
            ]
        },
        "misum": {
            "summary": "The function skips whitespace and sets the next element in a directory structure, handling local and pattern matching as needed.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims that the function skips whitespace and handles local and pattern matching, which are not reflected in the source code. The actual implementation processes directory entries, updates priorities, and recurses into subdirectories, none of which are accurately described in the summary. All claims are unrelated to the code semantics, resulting in no accurate alignment.",
                "The summary describes behavior about skipping whitespace and pattern matching, which does not align with the source code's actual purpose of generating file priorities for directory entries, recursing into subdirectories, and handling regular files. It entirely misses the primary purpose and observable behavior in the code, providing unrelated information.",
                "The summary's claims about skipping whitespace and handling local/pattern matching are unrelated to the source code, which actually processes directory entries recursively, assigns priorities based on file type, and skips root entries. All claims are NOISE, with no accurate or relevant details about the actual implementation, resulting in an overwhelming mismatch and no useful insight."
            ]
        }
    }
}
{
    "project_name": "zstd",
    "function_addr": 67936,
    "strip_function_name": "sub_10960",
    "strip_decompiled_code": "__int64 __fastcall sub_10960(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rbp\n  __int64 v9; // r14\n  __int64 v10; // r12\n  __int64 v11; // r13\n  __int64 v12; // rdx\n  __int64 v13; // rdi\n  unsigned __int64 v14; // r15\n  __int64 result; // rax\n  __int64 v16; // rbp\n  __int64 v17; // rdi\n  __int64 v18; // r8\n  unsigned __int64 v19; // r14\n\n  v7 = a1[19];\n  v8 = a1[3];\n  v9 = a1[5];\n  v10 = a1[6];\n  v11 = a1[7];\n  v12 = a1[20];\n  v13 = *a1;\n  if ( !v7 )\n  {\n    v14 = sub_2AA70(v13, v8, v9, v12, a5, a6, *((_OWORD *)a1 + 7), a1[16], a1[17]);\n    result = sub_F240(v14);\n    if ( !(_DWORD)result )\n    {\n      v16 = v9 + v8;\n      sub_29080(*a1, 0LL, 1LL);\n      v17 = *a1;\n      if ( *((_DWORD *)a1 + 20) )\n        goto LABEL_4;\nLABEL_12:\n      v19 = sub_2A9E0(v17, v10, v11, v16, 0LL);\n      result = sub_F240(v19);\n      if ( (_DWORD)result )\n      {\n        a1[8] = v19;\n        goto LABEL_9;\n      }\n      sub_29320(*a1);\n      v17 = *a1;\n      goto LABEL_4;\n    }\nLABEL_8:\n    a1[8] = v14;\n    goto LABEL_9;\n  }\n  v14 = sub_2B2B0(v13, v7, v12);\n  result = sub_F240(v14);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  v16 = v9 + v8;\n  v17 = *a1;\n  if ( !*((_DWORD *)a1 + 20) )\n    goto LABEL_12;\nLABEL_4:\n  v18 = a1[4];\n  if ( *((_DWORD *)a1 + 21) )\n    result = sub_2AAD0(v17, v10, v11, v16, v18);\n  else\n    result = sub_2A9E0(v17, v10, v11, v16, v18);\n  a1[8] = result;\nLABEL_9:\n  a1[11] = 1LL;\n  return result;\n}\n",
    "function_name": "ZSTDMT_compressChunk",
    "decompiled_code": "__int64 __fastcall ZSTDMT_compressChunk(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rbp\n  __int64 v9; // r14\n  __int64 v10; // r12\n  unsigned __int64 v11; // r13\n  __int64 v12; // rdx\n  __int64 v13; // rdi\n  __int64 v14; // r15\n  __int64 result; // rax\n  char *v16; // rbp\n  _DWORD *v17; // rdi\n  size_t v18; // r8\n  __int64 v19; // r14\n\n  v7 = a1[19];\n  v8 = a1[3];\n  v9 = a1[5];\n  v10 = a1[6];\n  v11 = a1[7];\n  v12 = a1[20];\n  v13 = *a1;\n  if ( !v7 )\n  {\n    v14 = ZSTD_compressBegin_advanced(v13, v8, v9, v12, a5, a6, *((_OWORD *)a1 + 7), *((_OWORD *)a1 + 8), a1[18]);\n    result = ZSTD_isError(v14);\n    if ( !(_DWORD)result )\n    {\n      v16 = (char *)(v9 + v8);\n      ZSTD_setCCtxParameter(*a1, 0, 1);\n      v17 = (_DWORD *)*a1;\n      if ( *((_DWORD *)a1 + 20) )\n        goto LABEL_4;\nLABEL_12:\n      v19 = ZSTD_compressContinue((__int64)v17, v10, v11, v16, 0LL);\n      result = ZSTD_isError(v19);\n      if ( (_DWORD)result )\n      {\n        a1[8] = v19;\n        goto LABEL_9;\n      }\n      ZSTD_invalidateRepCodes(*a1);\n      v17 = (_DWORD *)*a1;\n      goto LABEL_4;\n    }\nLABEL_8:\n    a1[8] = v14;\n    goto LABEL_9;\n  }\n  v14 = ZSTD_compressBegin_usingCDict(v13, v7, v12, a4, a5, a6);\n  result = ZSTD_isError(v14);\n  if ( (_DWORD)result )\n    goto LABEL_8;\n  v16 = (char *)(v9 + v8);\n  v17 = (_DWORD *)*a1;\n  if ( !*((_DWORD *)a1 + 20) )\n    goto LABEL_12;\nLABEL_4:\n  v18 = a1[4];\n  if ( *((_DWORD *)a1 + 21) )\n    result = ZSTD_compressEnd(v17, v10, v11, v16, v18);\n  else\n    result = ZSTD_compressContinue((__int64)v17, v10, v11, v16, v18);\n  a1[8] = result;\nLABEL_9:\n  a1[11] = 1LL;\n  return result;\n}\n",
    "source_code": "void ZSTDMT_compressChunk(void* jobDescription)\n{\n    ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;\n    const void* const src = (const char*)job->srcStart + job->dictSize;\n    buffer_t const dstBuff = job->dstBuff;\n    DEBUGLOG(3, \"job (first:%u) (last:%u) : dictSize %u, srcSize %u\", job->firstChunk, job->lastChunk, (U32)job->dictSize, (U32)job->srcSize);\n    if (job->cdict) {\n        size_t const initError = ZSTD_compressBegin_usingCDict(job->cctx, job->cdict, job->fullFrameSize);\n        if (job->cdict) DEBUGLOG(3, \"using CDict \");\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n    } else {\n        size_t const initError = ZSTD_compressBegin_advanced(job->cctx, job->srcStart, job->dictSize, job->params, job->fullFrameSize);\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n        ZSTD_setCCtxParameter(job->cctx, ZSTD_p_forceWindow, 1);\n    }\n    if (!job->firstChunk) {  /* flush frame header */\n        size_t const hSize = ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, 0);\n        if (ZSTD_isError(hSize)) { job->cSize = hSize; goto _endJob; }\n        ZSTD_invalidateRepCodes(job->cctx);\n    }\n\n    DEBUGLOG(4, \"Compressing : \");\n    DEBUG_PRINTHEX(4, job->srcStart, 12);\n    job->cSize = (job->lastChunk) ?   /* last chunk signal */\n                 ZSTD_compressEnd     (job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize) :\n                 ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize);\n    DEBUGLOG(3, \"compressed %u bytes into %u bytes   (first:%u) (last:%u)\", (unsigned)job->srcSize, (unsigned)job->cSize, job->firstChunk, job->lastChunk);\n\n_endJob:\n    PTHREAD_MUTEX_LOCK(job->jobCompleted_mutex);\n    job->jobCompleted = 1;\n    job->jobScanned = 0;\n    pthread_cond_signal(job->jobCompleted_cond);\n    pthread_mutex_unlock(job->jobCompleted_mutex);\n}",
    "comment": "Compresses data chunks using a context or dictionary, managing the compression state and signaling job completion through condition variables.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Releases allocated memory for a ZSTDv07_DCtx structure and its associated buffers , ensuring no memory leaks occur .\n",
    "cpbcs_sum": "Processes the SSH2 connection status, updates state, and executes a new result to the next request based on the current state.\n",
    "misum_sum": "Compresses SQL data using the specified dictionary and streams while handling potential errors and updating the decompression process.\n",
    "decom_sum": "Initializes or resumes a data stream by opening necessary resources, falling back to alternates on failure, and storing the active handle in the context.",
    "cfg_sum": "Establishes or reuses a data handle based on stored parameters, invokes appropriate processing routines, updates object state, and marks operation completion.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.0
            ],
            "reason": [
                "The summary 'push a pointer type' is vague and does not contain any specific, fact-based claims about the source code. It fails to reference actual operations, parameters, or flow from the provided implementation, making it noise rather than an accurate representation.",
                "The summary 'push a pointer type' is vague, lacks factual alignment with the source code, and does not capture the function's primary purpose of compressing a chunk using ZSTD with specific handling for dictionaries, continuation, and synchronization. It neither matches any critical semantic units from the source nor provides relevant detail.",
                "The summary contains only a vague statement unrelated to the function's actual behavior, which involves multi-threaded chunk compression with initialization, compression continuation or ending, and signaling completion. This represents pure NOISE with no accurate claims, providing no useful insight and misaligning entirely with the code semantics. The worst failure mode is overwhelming NOISE, yielding zero benefit."
            ]
        },
        "bint5": {
            "summary": "Releases allocated memory for a ZSTDv07_DCtx structure and its associated buffers , ensuring no memory leaks occur .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function releases allocated memory for a ZSTDv07_DCtx structure and its buffers, but the source code shows ZSTDMT_compressChunk performing compression operations, handling chunks, and signaling job completion without any memory deallocation logic. This is a direct contradiction to the code's semantics, meaning none of the claims are accurate.",
                "The summary inaccurately describes the function as releasing memory for a ZSTDv07_DCtx structure, which is unrelated to the actual code. The source code performs multi-threaded compression of a chunk using a compression context, handles initialization with or without a dictionary, processes first and last chunk cases, and signals job completion via mutexes and condition variables. No memory deallocation occurs, and the primary purpose is missed entirely.",
                "The summary claims the function releases allocated memory for a ZSTDv07_DCtx structure and its buffers, which is entirely inaccurate. The source code shows that the function performs chunk compression using a job description, logging debug output, handling compression initialization, continuing or ending compression based on chunk position, and signaling job completion via mutex and condition variables. No memory deallocation or ZSTDv07_DCtx structure handling occurs. This is a FATAL error targeting the primary purpose of the code, making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Processes the SSH2 connection status, updates state, and executes a new result to the next request based on the current state.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes handling SSH2 connection status, updating state, and executing a result request, which is entirely unrelated to the source code. The source code processes compression chunks using ZSTD, manages dictionaries, and handles threading synchronization. None of the factual claims in the summary match the implementation, making all claims inaccurate.",
                "The summary describes processing SSH2 connection status and state transitions, which is entirely unrelated to the source code's purpose of compressing a data chunk using ZSTD, handling dictionary initialization, flushing headers, and updating job completion flags. The primary purpose is missed and none of the critical semantic units are covered, making the summary completely inaccurate.",
                "The summary's claim that the function processes SSH2 connection status and updates state for the next request is completely unrelated to the source code, which deals with chunked compression using ZSTD and synchronization via pthread primitives. This is pure NOISE targeting a different domain, with no accurate claims about the actual implementation, making it unreliable for understanding the code."
            ]
        },
        "misum": {
            "summary": "Compresses SQL data using the specified dictionary and streams while handling potential errors and updating the decompression process.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function compresses SQL data, uses a dictionary and streams, and updates the decompression process. The source code shows it compresses arbitrary data in chunks using Zstandard, with optional dictionary usage, error handling, and completion signaling. It does not indicate SQL-specific data, streaming semantics beyond chunk-based compression, or any decompression process updates. Nearly all claims are inaccurate or unrelated to the source code, resulting in a very low accuracy proportion.",
                "The summary is inaccurate because it describes compressing SQL data and updating a decompression process, which is unrelated to the actual source code\u2019s function. The source code performs chunked compression with optional dictionary, handles errors, manages flushing and ending frames, and signals job completion. The summary misses the primary purpose and all secondary details, focusing instead on incorrect domain and behavior.",
                "The summary contains a FATAL inaccuracy: it states the function compresses SQL data, whereas the source code clearly handles ZSTD compression of arbitrary data chunks, not SQL-specific content. It also mentions updating the decompression process, which is unsupported in the source code and contradicts its purely compressive operations. These errors directly misrepresent the primary purpose of the code, outweighing any potential gain from accurate details."
            ]
        }
    }
}
{
    "project_name": "R",
    "function_addr": 1574128,
    "strip_function_name": "sub_1804F0",
    "strip_decompiled_code": "unsigned __int8 *__fastcall sub_1804F0(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int64 v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  char *v17; // rbp\n  unsigned __int8 *v18; // rbx\n  __int64 v19; // rax\n  _BYTE *v20; // rax\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  unsigned int v27; // eax\n  __int64 v28; // rdx\n  __int64 v29; // rcx\n  __int64 v30; // r8\n  __int64 v31; // r9\n  __m128 v32; // xmm4\n  __m128 v33; // xmm5\n\n  Rf_checkArityCall(a2, a3, a1);\n  v11 = R_HomeDir();\n  if ( !v11 )\n  {\n    v27 = (unsigned int)dcgettext(0LL, \"unable to determine R home location\", 5);\n    Rf_error(\n      v27,\n      (__int64)\"unable to determine R home location\",\n      v28,\n      v29,\n      v30,\n      v31,\n      a4,\n      a5,\n      a6,\n      a7,\n      v32,\n      v33,\n      a10,\n      a11);\n  }\n  v17 = (char *)v11;\n  v18 = (unsigned __int8 *)Rf_allocVector3(0x10u, 1LL, 0LL, a4, a5, a6, a7, v15, v16, a10, a11, v12, v13, v14);\n  v19 = R_PPStackTop;\n  if ( R_PPStackTop >= R_PPStackSize )\n    R_signal_protect_error(\n      *(double *)a4.m128_u64,\n      *(double *)a5.m128_u64,\n      *(double *)a6.m128_u64,\n      *(double *)a7.m128_u64);\n  ++R_PPStackTop;\n  *(_QWORD *)(R_PPStack + 8 * v19) = v18;\n  v20 = (_BYTE *)Rf_mkChar(v17, 1);\n  SET_STRING_ELT(v18, 0LL, v20, a4, a5, a6, a7, v24, v25, a10, a11, v21, v22, v23);\n  --R_PPStackTop;\n  return v18;\n}\n",
    "function_name": "do_Rhome",
    "decompiled_code": "unsigned __int8 *__fastcall do_Rhome(\n        char *a1,\n        __int64 a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11,\n        __int64 a12,\n        int a13,\n        int a14)\n{\n  char *v14; // rax\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __m128 v18; // xmm4\n  __m128 v19; // xmm5\n  char *v20; // rbp\n  unsigned __int8 *v21; // rbx\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  __int64 v24; // rax\n  _BYTE *v25; // rax\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n  __m128 v29; // xmm4\n  __m128 v30; // xmm5\n  unsigned int v32; // eax\n  __int64 v33; // rdx\n  __int64 v34; // rcx\n  __int64 v35; // r8\n  __int64 v36; // r9\n  __m128 v37; // xmm4\n  __m128 v38; // xmm5\n\n  Rf_checkArityCall(a2, a3, a1, a12, a13, a14, a4, a5, a6, a7, a8, a9, a10, a11);\n  v14 = R_HomeDir();\n  if ( !v14 )\n  {\n    v32 = (unsigned int)dcgettext(0LL, \"unable to determine R home location\", 5);\n    Rf_error(\n      v32,\n      (__int64)\"unable to determine R home location\",\n      v33,\n      v34,\n      v35,\n      v36,\n      a4,\n      a5,\n      a6,\n      a7,\n      v37,\n      v38,\n      a10,\n      a11);\n  }\n  v20 = v14;\n  v21 = (unsigned __int8 *)Rf_allocVector3(0x10u, 1LL, 0LL, a4, a5, a6, a7, v18, v19, a10, a11, v15, v16, v17);\n  v24 = R_PPStackTop;\n  if ( R_PPStackTop >= R_PPStackSize )\n    R_signal_protect_error(\n      *(double *)a4.m128_u64,\n      *(double *)a5.m128_u64,\n      *(double *)a6.m128_u64,\n      *(double *)a7.m128_u64);\n  ++R_PPStackTop;\n  *(_QWORD *)(R_PPStack + 8 * v24) = v21;\n  v25 = (_BYTE *)Rf_mkChar(v20, 1LL, a4, a5, a6, a7, v22, v23, a10, a11);\n  SET_STRING_ELT(v21, 0LL, v25, a4, a5, a6, a7, v29, v30, a10, a11, v26, v27, v28);\n  --R_PPStackTop;\n  return v21;\n}\n",
    "source_code": "\nSEXP attribute_hidden do_Rhome(SEXP call, SEXP op, SEXP args, SEXP rho)\n{\n    char *path;\n    checkArity(op, args);\n    if (!(path = R_HomeDir()))\n\terror(_(\"unable to determine R home location\"));\n    return mkString(path);\n}",
    "comment": "Returns the R home directory path as a string after verifying the function's arity and checking if the path can be determined.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Lists directories from specified paths , optionally including full names and supporting recursion , while managing memory allocation and counting results .\n",
    "cpbcs_sum": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
    "misum_sum": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
    "decom_sum": "Retrieves the R home directory path and returns it as a protected one-element character vector, raising an error if the location is unavailable.",
    "cfg_sum": "Creates a character vector containing the R home directory path, ensuring argument validity, managing memory, and handling errors during allocation or stack operations.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer, converting values according to a printf formatting character, and handling num_bytes with hex formatting do not match the source code's functionality, which determines the R home location and returns it as a string. All extracted claims are inaccurate, leading to no alignment with the source code.",
                "The summary describes behavior involving a static buffer, value conversion using printf formatting, and hex output rules, none of which are present in the source code. The source function determines the R home directory using R_HomeDir(), checks argument arity, triggers an error if not found, and returns the path as a string. The described metadata is entirely unrelated, missing the primary purpose and all key secondary details from the code.",
                "The summary makes claims about conversion, printf formatting, byte limits, and hex output, none of which are present in the provided function. The source code simply returns the R home directory as a string and has no formatting or conversion logic. All claims are unrelated to the code (NOISE), overwhelming any accuracy and providing no relevant insight. This yields high negative impact from irrelevant noise."
            ]
        },
        "bint5": {
            "summary": "Lists directories from specified paths , optionally including full names and supporting recursion , while managing memory allocation and counting results .\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary's claims about listing directories, recursion support, memory allocation, and counting results do not match the source code, which simply retrieves the R home directory path using R_HomeDir() and returns it as a string. All claims are inaccurate as they target unrelated functionalities not present in the code.",
                "The summary describes functionality related to listing directories with optional recursion and memory management, which is unrelated to the actual source code. The source code's primary purpose is to return the R home directory path as a string, with error handling if it cannot be determined. The summary misses the primary purpose entirely and all secondary details, making the claims inaccurate and irrelevant to the implementation.",
                "The summary's claims about listing directories, handling recursion, memory allocation, and counting results are entirely inaccurate, as the source function simply returns the R home directory path as a string after checking arguments. These are FATAL errors because they misstate the primary purpose, key I/O, and side effects of the function. There are no accurate claims, resulting in zero net benefit and severe misinformation."
            ]
        },
        "cpbcs": {
            "summary": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function returns the string \"Win32\" after validating arguments, but the source code shows it returns the result of mkString(path), where path is set to R_HomeDir() or errors if unavailable. There is no mention of \"Win32\" in the implementation, making the single claim inaccurate.",
                "The summary claims that the function returns a string 'Win32' after argument count validation, which is incorrect. The actual code validates the number of arguments using checkArity, retrieves the R home directory path via R_HomeDir, and returns it as a string; it never returns 'Win32'. The primary purpose is not captured accurately, leading to misrepresentation of behavior, thus failing to cover the core functionality.",
                "The summary contains a critical inaccuracy: it states the function returns the string 'Win32', whereas the source code clearly returns the R home directory path as a string. This directly misrepresents the primary purpose and output of the function, making it a FATAL error. Although it correctly mentions validating the number of arguments, the major incorrect claim about the return value overwhelms any accurate detail."
            ]
        },
        "misum": {
            "summary": "Returns a string \"Win32\" after validating the number of arguments passed to the function.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function returns the string \"Win32\" after validating arguments, but the source shows it returns the value from R_HomeDir() as a string, not a fixed \"Win32\" value. While the argument count validation part is accurate, the return value detail is incorrect, making a significant portion of the claims inaccurate.",
                "The summary incorrectly claims the function returns the string 'Win32', which contradicts the source code where it actually returns the R home directory path from R_HomeDir(). It does capture that the function validates the number of arguments, which aligns with checkArity(op, args), but misses the primary purpose of retrieving and returning the home path string and the error handling logic if R_HomeDir() fails.",
                "The summary claims the function returns the string \"Win32\" after validating arguments, which contradicts the source code. In reality, the function returns the path from R_HomeDir() wrapped in mkString and errors if it cannot determine the path. This is a FATAL error about the primary output of the function, making the description highly misleading."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584693824,
    "strip_function_name": "sub_FFFFFFFF81593E40",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81593E40(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r14\n  unsigned __int64 v11; // rbx\n  __int64 v12; // r10\n  unsigned __int64 v13; // r9\n  __int64 v14; // r13\n  __int64 v15; // r15\n  __int64 v16; // r12\n  unsigned int v17; // eax\n  __int64 v18; // rdx\n  unsigned int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // [rsp+10h] [rbp-30h]\n\n  v10 = (_QWORD *)(a2 + 72);\n  v11 = *(_QWORD *)(a1 + 120);\n  v12 = *(_QWORD *)(a1 + 128);\n  v13 = v11 >> 16;\n  v14 = (v11 >> 18) & 1;\n  v15 = (v11 >> 19) & 0xF;\n  v16 = (v11 >> 23) & 0x3F;\n  if ( (v11 & 0x10000) != 0 )\n  {\n    v10 = (_QWORD *)(a2 + 80);\n    v22 = *(_QWORD *)(a1 + 128);\n    v20 = sub_FFFFFFFF81593DC0(v12, v11, 0, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v13 = v11 >> 16;\n    v12 = v22;\n    v21 = v20 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v20 )\n      v21 = 0LL;\n    *(_QWORD *)(a2 + 72) = v21;\n  }\n  if ( (v13 & 2) != 0 )\n  {\n    v17 = sub_FFFFFFFF81593DC0(v12, v11, 1, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v18 = v17 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v17 )\n      v18 = 0LL;\n    *v10 = v18;\n  }\n  return 0LL;\n}\n",
    "function_name": "snd_hda_mixer_amp_volume_get",
    "decompiled_code": "__int64 __fastcall snd_hda_mixer_amp_volume_get(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  _QWORD *v10; // r14\n  unsigned __int64 v11; // rbx\n  __int64 v12; // r10\n  unsigned __int64 v13; // r9\n  __int64 v14; // r13\n  __int64 v15; // r15\n  __int64 v16; // r12\n  unsigned int v17; // eax\n  __int64 v18; // rdx\n  unsigned int v20; // eax\n  __int64 v21; // rdx\n  __int64 v22; // [rsp+10h] [rbp-30h]\n\n  v10 = (_QWORD *)(a2 + 72);\n  v11 = *(_QWORD *)(a1 + 120);\n  v12 = *(_QWORD *)(a1 + 128);\n  v13 = v11 >> 16;\n  v14 = (v11 >> 18) & 1;\n  v15 = (v11 >> 19) & 0xF;\n  v16 = (v11 >> 23) & 0x3F;\n  if ( (v11 & 0x10000) != 0 )\n  {\n    v10 = (_QWORD *)(a2 + 80);\n    v22 = *(_QWORD *)(a1 + 128);\n    v20 = snd_hda_codec_amp_read(v12, v11, 0, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v13 = v11 >> 16;\n    v12 = v22;\n    v21 = v20 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v20 )\n      v21 = 0LL;\n    *(_QWORD *)(a2 + 72) = v21;\n  }\n  if ( (v13 & 2) != 0 )\n  {\n    v17 = snd_hda_codec_amp_read(v12, v11, 1, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10) & 0x7F;\n    v18 = v17 - (unsigned int)v16;\n    if ( (unsigned int)v16 > v17 )\n      v18 = 0LL;\n    *v10 = v18;\n  }\n  return 0LL;\n}\n",
    "source_code": "int snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\tif (chs & 1)\n\t\t*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\n\tif (chs & 2)\n\t\t*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\n\treturn 0;\n}",
    "comment": "Retrieves and stores the volume values for specified audio channels from a sound codec's amplifier settings into the provided control element structure.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly .\n",
    "cpbcs_sum": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
    "misum_sum": "Retrieves the mute status of audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
    "decom_sum": "Computes adjusted 7\u2011bit values from hardware status fields and stores them into two offsets of the target structure based on specific flag bits.",
    "cfg_sum": "Computes adjusted values based on specific bitfields from input data using auxiliary calculations, then stores results into designated memory offsets.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims describe processing of control characters, escape sequences, unicode handling, and use of a static buffer \u2014 none of which are implemented in the provided source. The source function retrieves and returns amplifier volume values from hardware via read_amp_value calls, making all claims in the summary irrelevant or contradictory to the code. This results in 0% accurate claims.",
                "The summary describes string processing involving control characters, escape sequences, static buffers, and Unicode handling, none of which are present in the source code. The actual function retrieves amplifier volume levels for one or both channels via read_amp_value and returns 0. The summary misses the primary purpose and all secondary details, making all claims inaccurate.",
                "All claims in the summary are unrelated to the actual function, which retrieves amplifier volume values from a codec via helper functions and populates them into a control structure. The summary talks about replacing control characters, using a static buffer, and handling Unicode\u2014none of which appear in the source. This is pure NOISE unrelated to the code, providing no useful insight and overwhelming the content with inaccuracies."
            ]
        },
        "bint5": {
            "summary": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's purpose: the source code retrieves amplifier volume levels (via read_amp_value) rather than mute status. This directly contradicts the actual implementation, meaning the single claim is incorrect, resulting in no accurate claims.",
                "The summary incorrectly states that the function retrieves the mute status, while the source code shows it reads and returns the volume levels from the amplifier channels. This contradicts the code\u2019s primary purpose. As a result, the main function\u2019s behavior is misrepresented, and no accurate claims map to critical semantic units, leading to no coverage.",
                "The summary incorrectly states that the function retrieves mute status, while the source code clearly retrieves volume values via read_amp_value for specified channels. This is a FATAL inaccuracy as it misidentifies the primary purpose of the function. No accurate claims are present, leading to high negative impact and zero net benefit."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the mute status for audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function retrieves mute status, while the source code clearly retrieves volume values using read_amp_value for one or two channels. This is a semantic mismatch with the implementation. Since the lone claim is inaccurate, there is 0% accuracy.",
                "The summary incorrectly describes the function as retrieving mute status, whereas the source code clearly reads amplifier volume values via read_amp_value and writes them into ucontrol->value for the left and/or right channels based on chs bitmask. This misidentifies the primary purpose, resulting in a major semantic error. Although it notes that data is retrieved from a codec and updates the control element accordingly, the core functionality is misstated, leading to poor alignment.",
                "The summary inaccurately describes the function as retrieving mute status, while the source code clearly retrieves volume levels via read_amp_value and does not involve mute states. This is a FATAL error affecting the primary purpose of the function, leading to a high negative impact. There are no accurate or high-gain claims to offset the inaccuracy."
            ]
        },
        "misum": {
            "summary": "Retrieves the mute status of audio amplifier channels from a specified codec and updates the control element value accordingly.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as retrieving mute status, whereas the source code clearly retrieves volume levels via read_amp_value for specified channels. This is a semantic contradiction, making the central claim inaccurate. Since the only substantive claim is wrong, none of the claims are accurate.",
                "The summary incorrectly describes the function as retrieving mute status, while the source code clearly retrieves amplifier volume values for each channel. Although it mentions updating the control element, it fails to capture the primary purpose (volume retrieval) and omits key details such as channel bitmask handling, directional parameters, and offsets. This contradiction with the core functionality makes the claim inaccurate and results in no coverage of the actual CSU_LIST.",
                "The summary incorrectly claims the function retrieves mute status, while the source code clearly retrieves volume values using read_amp_value. This is a FATAL error targeting the primary purpose of the function, which is to get amplifier volume levels, not mute state. There are no accurate claims to offset this, resulting in high negative impact and zero net benefit."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4881168,
    "strip_function_name": "sub_4A7B10",
    "strip_decompiled_code": "__int64 __fastcall sub_4A7B10(__int64 a1, int a2, __int64 a3, __int64 a4)\n{\n  int v4; // r8d\n  __int64 result; // rax\n\n  switch ( a2 )\n  {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 11:\n    case 33:\n    case 43:\n    case 45:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n    case 58:\n    case 60:\n    case 61:\n    case 63:\n    case 75:\n    case 77:\n      if ( !a3 )\n        goto LABEL_7;\n      goto LABEL_6;\n    case 9:\n    case 10:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n    case 16:\n    case 17:\n    case 18:\n    case 19:\n    case 20:\n    case 21:\n    case 22:\n    case 23:\n    case 34:\n    case 35:\n    case 36:\n    case 37:\n    case 38:\n    case 40:\n    case 51:\n    case 52:\n    case 53:\n    case 59:\n    case 62:\n    case 66:\n    case 67:\n    case 68:\n    case 72:\n    case 73:\n    case 74:\n      if ( a3 )\n        goto LABEL_3;\n      goto LABEL_7;\n    case 25:\n    case 26:\n    case 27:\n    case 28:\n    case 29:\n    case 30:\n    case 31:\n    case 32:\n    case 41:\n    case 46:\n    case 47:\n    case 76:\n    case 78:\n    case 79:\n      goto LABEL_3;\n    case 42:\n    case 48:\nLABEL_6:\n      if ( !a4 )\n        goto LABEL_7;\nLABEL_3:\n      v4 = *(_DWORD *)(a1 + 40);\n      if ( v4 >= *(_DWORD *)(a1 + 44) )\n        goto LABEL_7;\n      result = *(_QWORD *)(a1 + 32) + 24LL * v4;\n      *(_DWORD *)(result + 4) = 0;\n      *(_DWORD *)(a1 + 40) = v4 + 1;\n      *(_DWORD *)result = a2;\n      *(_QWORD *)(result + 8) = a3;\n      *(_QWORD *)(result + 16) = a4;\n      break;\n    default:\nLABEL_7:\n      result = 0LL;\n      break;\n  }\n  return result;\n}\n",
    "function_name": "d_make_comp",
    "decompiled_code": "demangle_component *__fastcall d_make_comp(\n        d_info *di_0,\n        demangle_component_type type,\n        demangle_component *left,\n        demangle_component *right)\n{\n  int next_comp; // r8d\n  demangle_component *result; // rax\n\n  switch ( type )\n  {\n    case demangle_component_type::DEMANGLE_COMPONENT_QUAL_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_LOCAL_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPED_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TEMPLATE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case demangle_component_type::DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_UNARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_BINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_BINARY_ARGS:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case demangle_component_type::DEMANGLE_COMPONENT_LITERAL:\n    case demangle_component_type::DEMANGLE_COMPONENT_LITERAL_NEG:\n    case demangle_component_type::DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TAGGED_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_CLONE:\n      if ( !left )\n        goto LABEL_7;\n      goto LABEL_6;\n    case demangle_component_type::DEMANGLE_COMPONENT_VTABLE:\n    case demangle_component_type::DEMANGLE_COMPONENT_VTT:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case demangle_component_type::DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case demangle_component_type::DEMANGLE_COMPONENT_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case demangle_component_type::DEMANGLE_COMPONENT_JAVA_CLASS:\n    case demangle_component_type::DEMANGLE_COMPONENT_GUARD:\n    case demangle_component_type::DEMANGLE_COMPONENT_TLS_INIT:\n    case demangle_component_type::DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFTEMP:\n    case demangle_component_type::DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case demangle_component_type::DEMANGLE_COMPONENT_POINTER:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFERENCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_COMPLEX:\n    case demangle_component_type::DEMANGLE_COMPONENT_IMAGINARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CAST:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONVERSION:\n    case demangle_component_type::DEMANGLE_COMPONENT_NULLARY:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRINARY_ARG2:\n    case demangle_component_type::DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case demangle_component_type::DEMANGLE_COMPONENT_DECLTYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case demangle_component_type::DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case demangle_component_type::DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case demangle_component_type::DEMANGLE_COMPONENT_PACK_EXPANSION:\n      if ( left )\n        goto LABEL_3;\n      goto LABEL_7;\n    case demangle_component_type::DEMANGLE_COMPONENT_RESTRICT:\n    case demangle_component_type::DEMANGLE_COMPONENT_VOLATILE:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONST:\n    case demangle_component_type::DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_CONST_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case demangle_component_type::DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_ARGLIST:\n    case demangle_component_type::DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    case demangle_component_type::DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case demangle_component_type::DEMANGLE_COMPONENT_NOEXCEPT:\n    case demangle_component_type::DEMANGLE_COMPONENT_THROW_SPEC:\n      goto LABEL_3;\n    case demangle_component_type::DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case demangle_component_type::DEMANGLE_COMPONENT_INITIALIZER_LIST:\nLABEL_6:\n      if ( !right )\n        goto LABEL_7;\nLABEL_3:\n      next_comp = di_0->next_comp;\n      if ( next_comp >= di_0->num_comps )\n        goto LABEL_7;\n      result = &di_0->comps[next_comp];\n      result->d_printing = 0;\n      di_0->next_comp = next_comp + 1;\n      result->type = type;\n      result->u.s_number.number = (__int64)left;\n      result->u.s_extended_operator.name = right;\n      break;\n    default:\nLABEL_7:\n      result = 0LL;\n      break;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic struct demangle_component *\nd_make_comp (struct d_info *di, enum demangle_component_type type,\n             struct demangle_component *left,\n             struct demangle_component *right)\n{\n  struct demangle_component *p;\n\n  /* We check for errors here.  A typical error would be a NULL return\n     from a subroutine.  We catch those here, and return NULL\n     upward.  */\n  switch (type)\n    {\n      /* These types require two parameters.  */\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_CLONE:\n      if (left == NULL || right == NULL)\n\treturn NULL;\n      break;\n\n      /* These types only require one parameter.  */\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      if (left == NULL)\n\treturn NULL;\n      break;\n\n      /* This needs a right parameter, but the left parameter can be\n\t empty.  */\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      if (right == NULL)\n\treturn NULL;\n      break;\n\n      /* These are allowed to have no parameters--in some cases they\n\t will be filled in later.  */\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    FNQUAL_COMPONENT_CASE:\n      break;\n\n      /* Other types should not be seen here.  */\n    default:\n      return NULL;\n    }\n\n  p = d_make_empty (di);\n  if (p != NULL)\n    {\n      p->type = type;\n      p->u.s_binary.left = left;\n      p->u.s_binary.right = right;\n    }\n  return p;\n}",
    "comment": "Constructs a demangle component by validating parameters based on type and initializing its properties, returning NULL for errors or invalid types.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Demangles various C++ type components , including pointers , references , arrays , and member functions , into structured debug types .\n",
    "cpbcs_sum": "Inserts a new item into a sorted list based on the specified item type, updating the list and returning the inserted item.\n",
    "misum_sum": "Creates and initializes a new instance with specified parameters and size, linking it to a dynamic array if the type is not found.\n",
    "decom_sum": "Appends a validated command with its parameters into a bounded queue at `a1` based on specific opcode cases and nonzero argument conditions.",
    "cfg_sum": "Processes specific event codes with parameter checks, logs them into a bounded event buffer, and returns zero if inputs fail validation or capacity is exceeded.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.0,
                0.2
            ],
            "reason": [
                "The summary contains only a vague statement unrelated to the detailed parameter requirements and control flow in the source code. It does not accurately represent the function's logic, such as error checks for NULL parameters based on type categories or the assignment of left/right pointers. This makes the claim non-specific and disconnected from core implementation semantics.",
                "The summary 'push a pointer type' is too vague and does not capture the primary purpose of the function, which is to create and initialize a demangle_component based on type and validate its left/right parameters according to the type's requirements, returning NULL on error. It omits all essential details such as error handling logic, parameter requirements per type, and the construction of the component structure, resulting in no alignment with the source code semantics.",
                "The summary contains a single vague claim implying that the function pushes a pointer type, which is inaccurate regarding the actual code. The source implements creation of various demangle_component structures, with specific parameter validation based on the type, not simply 'pushing' a pointer type. This is a FATAL error as it misrepresents the primary purpose and core behavior of the function."
            ]
        },
        "bint5": {
            "summary": "Demangles various C++ type components , including pointers , references , arrays , and member functions , into structured debug types .\n",
            "score": [
                0.5,
                0.2,
                0.5
            ],
            "reason": [
                "The summary claims the function 'demangles various C++ type components, including pointers, references, arrays, and member functions, into structured debug types.' While the source code does handle multiple demangle component types such as pointers, references, arrays, and function types, the summary's mention of 'member functions' and 'structured debug types' is unsupported by the code, which simply creates and returns demangle_component structures without any explicit debugging or member function semantics. This leads to partial accuracy, with some claims matching the implementation and others being extraneous or inaccurate.",
                "The summary captures only a vague idea of demangling C++ type components but misses the primary purpose of the function, which is constructing a 'demangle_component' with appropriate error checks based on the component type. It omits critical details such as parameter requirements for different component types, handling of NULL values, and creation via 'd_make_empty'. The listed types like pointers, references, arrays, and member functions are only partially accurate and lack specificity about the branching logic in the code.",
                "The summary claims the function demangles various C++ type components into structured debug types, listing examples like pointers, references, arrays, and member functions. While the source does handle many component types including pointers, references, and arrays, it does not specifically perform a full demangling process or target 'member functions' in the way implied; rather, it constructs demangle_component structs with error checks. The claim is broadly related but mostly generic and omits key implementation details such as parameter validation and struct construction. There are no direct fatal inaccuracies, but the gain is low due to lack of specificity and partial mismatch in terminology."
            ]
        },
        "cpbcs": {
            "summary": "Inserts a new item into a sorted list based on the specified item type, updating the list and returning the inserted item.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes inserting a new item into a sorted list based on type, but the source code actually constructs a demangle_component with type-specific parameter validation and returns it. There is no sorting or list insertion in the implementation, making the claim entirely inaccurate and unrelated to the code semantics.",
                "The summary incorrectly describes the function as inserting into a sorted list, which is not present in the source code. The actual code creates a new demangle_component based on type and validates its parameters, returning NULL on errors. The description misses the primary purpose and all secondary details such as parameter requirements and error handling. This is a direct contradiction of the source semantics.",
                "The summary is entirely inaccurate: the source code does not insert into a sorted list nor deal with list order at all. Instead, it constructs a demangle_component based on type and null-checks its parameters. This is a FATAL error about the primary purpose, as the described I/O semantics differ completely from the actual function."
            ]
        },
        "misum": {
            "summary": "Creates and initializes a new instance with specified parameters and size, linking it to a dynamic array if the type is not found.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function creates and initializes a new instance with specified parameters and size, and links it to a dynamic array if the type is not found. While the source does show creation and initialization of a component with provided parameters, there is no mention of 'size', 'dynamic array', or handling a case where the type is not found in this manner. These inaccuracies mean less than half of the claims align with the source code.",
                "The summary is inaccurate because it claims the function creates an instance with a specified size and links it to a dynamic array if the type is not found, which is not reflected in the source code. The actual function constructs a `demangle_component` based on type, validates `left` and `right` parameters depending on the type, and returns NULL for invalid inputs or unknown types. The PRIMARY PURPOSE and parameter validation logic are missed entirely.",
                "The summary contains a key FATAL error: it describes creating an instance with a size and linking to a dynamic array if the type is not found, which is not reflected in the source code. The function instead validates parameters based on the component type, creates an empty demangle_component, and assigns its type and left/right pointers. No dynamic array linking or size specification exists. This severe mismatch affects the primary purpose and I/O semantics."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 397774,
    "strip_function_name": "sub_611CE",
    "strip_decompiled_code": "__int64 __fastcall sub_611CE(__int64 a1, unsigned int a2, unsigned __int8 **a3)\n{\n  unsigned __int8 *v4; // rax\n  char *v5; // rax\n  unsigned __int8 v6; // dl\n  __int64 v7; // rax\n  __int64 v8; // rax\n  unsigned __int8 v10; // [rsp+2Bh] [rbp-35h]\n  char v11; // [rsp+2Bh] [rbp-35h]\n  int v12; // [rsp+2Ch] [rbp-34h]\n  unsigned __int64 i; // [rsp+30h] [rbp-30h]\n  unsigned __int64 v14; // [rsp+38h] [rbp-28h]\n  unsigned __int8 *v15; // [rsp+40h] [rbp-20h]\n  unsigned __int64 v16; // [rsp+48h] [rbp-18h]\n  unsigned __int8 *v17; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+58h] [rbp-8h]\n\n  if ( a2 <= 1 )\n    return 0LL;\n  v15 = *a3;\n  v16 = (unsigned __int64)a3[1];\n  v17 = a3[2];\n  v18 = (unsigned __int64)a3[3];\n  v14 = 0LL;\n  for ( i = 0LL; i < v16 && v14 < v18; ++i )\n  {\n    v4 = v15++;\n    v10 = *v4;\n    if ( *v4 == 92 )\n    {\n      if ( v16 == i + 1 )\n        break;\n      v5 = (char *)v15++;\n      v11 = *v5;\n      ++i;\n      v12 = mu_wordsplit_c_unquote_char((unsigned __int8)*v5);\n      if ( v12 == -1 )\n        v6 = v11;\n      else\n        v6 = v12;\n      v7 = v14++;\n      v17[v7] = v6;\n    }\n    else\n    {\n      v8 = v14++;\n      v17[v8] = v10;\n    }\n  }\n  a3[1] = (unsigned __int8 *)i;\n  a3[3] = (unsigned __int8 *)v14;\n  return 0LL;\n}\n",
    "function_name": "_c_escape_decoder",
    "decompiled_code": "mu_filter_result __cdecl c_escape_decoder(void *xd, mu_filter_command cmd, mu_filter_io *iobuf)\n{\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  char v6; // dl\n  size_t v7; // rax\n  size_t v8; // rax\n  unsigned __int8 c; // [rsp+2Bh] [rbp-35h]\n  unsigned __int8 ca; // [rsp+2Bh] [rbp-35h]\n  int x; // [rsp+2Ch] [rbp-34h]\n  size_t i; // [rsp+30h] [rbp-30h]\n  size_t j; // [rsp+38h] [rbp-28h]\n  const unsigned __int8 *iptr; // [rsp+40h] [rbp-20h]\n  size_t isize; // [rsp+48h] [rbp-18h]\n  char *optr; // [rsp+50h] [rbp-10h]\n  size_t osize; // [rsp+58h] [rbp-8h]\n\n  if ( (unsigned int)cmd <= mu_filter_command::mu_filter_done )\n    return 0;\n  iptr = (const unsigned __int8 *)iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n  j = 0LL;\n  for ( i = 0LL; i < isize && j < osize; ++i )\n  {\n    v4 = (unsigned __int8 *)iptr++;\n    c = *v4;\n    if ( *v4 == 92 )\n    {\n      if ( isize == i + 1 )\n        break;\n      v5 = (unsigned __int8 *)iptr++;\n      ca = *v5;\n      ++i;\n      x = ((__int64 (__fastcall *)(_QWORD))mu_wordsplit_c_unquote_char)(*v5);\n      if ( x == -1 )\n        v6 = ca;\n      else\n        v6 = x;\n      v7 = j++;\n      optr[v7] = v6;\n    }\n    else\n    {\n      v8 = j++;\n      optr[v8] = c;\n    }\n  }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return 0;\n}\n",
    "source_code": "static enum mu_filter_result\n_c_escape_decoder (void *xd MU_ARG_UNUSED,\n\t\t   enum mu_filter_command cmd,\n\t\t   struct mu_filter_io *iobuf)\n{\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n  \n  switch (cmd)\n    {\n    case mu_filter_init:\n    case mu_filter_done:\n      return mu_filter_ok;\n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n      if (c == '\\\\')\n\t{\n\t  int x;\n\t  if (i + 1 == isize)\n\t    break;\n\t  c = *iptr++;\n\t  i++;\n\t  x = mu_wordsplit_c_unquote_char (c);\n\t  optr[j++] = (x == -1) ? c : x;\n\t}\n      else\n\toptr[j++] = c;\n    }\n\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "comment": "Decodes escape sequences in the input buffer by replacing backslash-prefixed characters with their unquoted equivalents, storing results in the output buffer.",
    "hext5_sum": "returns a pointer to its greatest-valued item. returns |null| if |table| contains no nodes. initializes |trav| for |table|",
    "bint5_sum": "Encodes control characters in the input buffer by escaping them with a backslash and writes the result to the output buffer .\n",
    "cpbcs_sum": "Processes input bytes with specific state transitions, filtering out dots at the beginning of line read or end of data with EOF.\n",
    "misum_sum": "Processes input data through a buffer, handling whitespace, and whitespace, and writes the result to a temporary buffer while managing state and position.\n",
    "decom_sum": "Parses an input byte stream, handling backslash escape sequences via `mu_wordsplit_c_unquote_char`, and writes the unescaped bytes into an output buffer.",
    "cfg_sum": "Parses an input byte stream, processes escape sequences into unquoted characters, and writes results to an output buffer while updating position counters.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to its greatest-valued item. returns |null| if |table| contains no nodes. initializes |trav| for |table|",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a pointer to the greatest-valued item, returning null if the table has no nodes, and initializing a traversal object have no correspondence to the provided source code, which implements a C escape decoder function with no table or traversal logic. All extracted claims are inaccurate, resulting in no alignment with the code's behavior.",
                "The summary's claims about returning the greatest-valued item, returning null if there are no nodes, and initializing a traversal are entirely unrelated to the source code, which implements a C escape sequence decoder for a filter interface. The source code does not operate on tables, nodes, or traversal objects. None of the claims match the primary purpose or secondary details, making all claims inaccurate and missing the core behavior.",
                "All extracted claims are [INACCURATE] as they describe behavior unrelated to the provided source code. The summary mentions returning the greatest-valued item and initializing a traversal for a table, while the actual code processes escape sequences in a filter decoder function and never performs any table traversal or greatest-value comparisons. This is a clear NOISE failure mode with no alignment to primary purpose or I/O, leading to zero useful information."
            ]
        },
        "bint5": {
            "summary": "Encodes control characters in the input buffer by escaping them with a backslash and writes the result to the output buffer .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function encodes control characters by escaping them with a backslash, but the source code shows it performs the reverse: it decodes backslash-escaped sequences into characters, calling mu_wordsplit_c_unquote_char and writing the unescaped value to the output buffer. This contradicts the implementation, making the claim inaccurate.",
                "The summary is inaccurate because the function actually decodes backslash-escaped characters in the input buffer into their unescaped form, rather than encoding control characters. This misidentifies the primary purpose, which is to process and remove escape sequences, so it fails at the most critical step of evaluation.",
                "The summary incorrectly states that the function encodes control characters by escaping them, while the source code in fact decodes backslash-escaped characters using `mu_wordsplit_c_unquote_char` and writes the unescaped result to the output buffer. This is a FATAL error about the primary purpose and I/O behavior, making the summary unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Processes input bytes with specific state transitions, filtering out dots at the beginning of line read or end of data with EOF.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function filters out dots at the beginning of a line or end of data with EOF, which is not reflected in the source code. The code processes input bytes by handling backslashes and unquoting characters, with no logic related to dots or EOF detection. All extracted claims are inaccurate, resulting in complete misalignment with the source implementation.",
                "The summary describes filtering dots at the beginning of a line or at EOF, which is unrelated to the actual code. The source code processes escape sequences by replacing backslash-prefixed characters using a helper function and handles specific filter commands. The primary purpose and key behaviors from the code are missed entirely, making the claims inaccurate and non-representative of the implementation.",
                "The summary claims the function filters out dots at the beginning of a line or end of data with EOF, which is incorrect. The source code instead checks for backslashes and decodes escaped characters using mu_wordsplit_c_unquote_char. This is a FATAL error affecting the primary purpose and I/O behavior, making the description unreliable. There are no accurate claims to provide positive gain."
            ]
        },
        "misum": {
            "summary": "Processes input data through a buffer, handling whitespace, and whitespace, and writes the result to a temporary buffer while managing state and position.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the code\u2019s behavior, incorrectly claiming whitespace handling and state management, none of which are present in the implementation. The source code processes characters from an input buffer, specifically handling backslash escapes via `mu_wordsplit_c_unquote_char`, and writes to an output buffer. Since the claims do not match the actual code semantics, the proportion of accurate claims is 0%, resulting in very low alignment.",
                "The summary claims the function handles whitespace and writes to a temporary buffer while managing state, but the source code actually processes C escape sequences, converting backslash escapes via mu_wordsplit_c_unquote_char. There is no whitespace-specific processing described in the code, and 'temporary buffer' is misleading since it writes directly to the provided output buffer. The PRIMARY PURPOSE of decoding escape sequences is missed entirely, making the summary inaccurate and providing no correct coverage of secondary details.",
                "The summary claims the function handles whitespace twice, which is inaccurate because the source code specifically processes backslash escape sequences using `mu_wordsplit_c_unquote_char` and does not include explicit whitespace handling logic. This is a FATAL error since it misrepresents the core data transformation behavior. Additionally, there are no accurate, high-information details that match the code\u2019s implementation, resulting in zero positive gain."
            ]
        }
    }
}
{
    "project_name": "libevent",
    "function_addr": 137856,
    "strip_function_name": "evutil_read_file_",
    "strip_decompiled_code": "__int64 __fastcall evutil_read_file_(char *a1, __int64 *a2, unsigned __int64 *a3)\n{\n  int v4; // eax\n  int v5; // ebp\n  __int64 v6; // r12\n  __off_t st_size; // rdx\n  unsigned __int64 v8; // r15\n  _BYTE *v9; // rbx\n  int v10; // eax\n  unsigned int v12; // [rsp+8h] [rbp-E0h]\n  int v13; // [rsp+Ch] [rbp-DCh]\n  stat stat_buf; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v15; // [rsp+A8h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  if ( !a2 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  if ( !a3 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  *a2 = 0LL;\n  *a3 = 0LL;\n  v4 = evutil_open_closeonexec_(a1, 0);\n  v5 = v4;\n  if ( v4 < 0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v12 = __fxstat(1, v4, &stat_buf);\n    if ( v12 || stat_buf.st_size > 0x7FFFFFFFFFFFFFFEuLL || (v6 = event_mm_malloc_(stat_buf.st_size + 1)) == 0 )\n    {\n      close(v5);\n      return (unsigned int)-2;\n    }\n    else\n    {\n      st_size = stat_buf.st_size;\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v9 = (_BYTE *)(v6 + v8);\n        v10 = read(v5, (void *)(v6 + v8), st_size - v8);\n        if ( v10 <= 0 )\n          break;\n        st_size = stat_buf.st_size;\n        v8 += v10;\n        if ( stat_buf.st_size <= v8 )\n        {\n          v9 = (_BYTE *)(v6 + v8);\n          close(v5);\n          goto LABEL_11;\n        }\n      }\n      v13 = v10;\n      close(v5);\n      if ( !v13 )\n      {\nLABEL_11:\n        *v9 = 0;\n        *a3 = v8;\n        *a2 = v6;\n        return v12;\n      }\n      event_mm_free_(v6);\n      return (unsigned int)-2;\n    }\n  }\n}\n",
    "function_name": "evutil_read_file_",
    "decompiled_code": "__int64 __fastcall evutil_read_file_(char *a1, __int64 *a2, unsigned __int64 *a3)\n{\n  int v4; // eax\n  int v5; // ebp\n  __int64 v6; // r12\n  __off_t st_size; // rdx\n  unsigned __int64 v8; // r15\n  _BYTE *v9; // rbx\n  int v10; // eax\n  unsigned int v12; // [rsp+8h] [rbp-E0h]\n  int v13; // [rsp+Ch] [rbp-DCh]\n  stat stat_buf; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v15; // [rsp+A8h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  if ( !a2 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  if ( !a3 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  *a2 = 0LL;\n  *a3 = 0LL;\n  v4 = evutil_open_closeonexec_(a1, 0);\n  v5 = v4;\n  if ( v4 < 0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v12 = __fxstat(1, v4, &stat_buf);\n    if ( v12 || stat_buf.st_size > 0x7FFFFFFFFFFFFFFEuLL || (v6 = event_mm_malloc_(stat_buf.st_size + 1)) == 0 )\n    {\n      close(v5);\n      return (unsigned int)-2;\n    }\n    else\n    {\n      st_size = stat_buf.st_size;\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v9 = (_BYTE *)(v6 + v8);\n        v10 = read(v5, (void *)(v6 + v8), st_size - v8);\n        if ( v10 <= 0 )\n          break;\n        st_size = stat_buf.st_size;\n        v8 += v10;\n        if ( stat_buf.st_size <= v8 )\n        {\n          v9 = (_BYTE *)(v6 + v8);\n          close(v5);\n          goto LABEL_11;\n        }\n      }\n      v13 = v10;\n      close(v5);\n      if ( !v13 )\n      {\nLABEL_11:\n        *v9 = 0;\n        *a3 = v8;\n        *a2 = v6;\n        return v12;\n      }\n      event_mm_free_(v6);\n      return (unsigned int)-2;\n    }\n  }\n}\n",
    "source_code": "int\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}",
    "comment": "Reads the contents of a specified file into a dynamically allocated buffer, returning the length and handling binary mode if specified.",
    "hext5_sum": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
    "bint5_sum": "Reads a file into an evutil_file structure , reading its contents into provided pointers while handling errors for invalid file paths .\n",
    "cpbcs_sum": "Reads a specified file into a buffer, ensuring it is valid and handling line endings appropriately.\n",
    "misum_sum": "Reads data from a file descriptor, using either a fast file or standard iovec up to the specified count.\n",
    "decom_sum": "Reads the entire contents of a file into a newly allocated buffer, null\u2011terminates it, and returns its size and pointer.",
    "cfg_sum": "Reads the specified file into a newly allocated null\u2011terminated buffer, returning its size, and handles errors or invalid parameters with appropriate cleanup.",
    "work_score": {
        "hext5": {
            "summary": "generate the appropriate fragments for a given expression to emit a leb128 value. sign is 1 for sleb, 0 for uleb.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary discusses generating LEB128 encoding fragments with a sign indicator for sleb/uleb, which is entirely unrelated to the provided source code that reads a file into memory with proper size checks and error handling. None of the fact-based claims from the summary match or safely generalize the implementation, making all claims inaccurate.",
                "The summary's claims about generating LEB128 values and handling signed/unsigned encoding are unrelated to the source code, which reads a file into memory, manages binary mode, performs size checks, allocates buffers, reads content, and returns error codes. The primary purpose and key secondary details of the function are entirely missed, and no accurate claims from the summary map to the source implementation.",
                "The summary claims the function generates fragments for an expression to emit a LEB128 value with a sign parameter, which is unrelated to the provided C function. The source code clearly reads a file into memory, not encoding values in LEB128. This is a FATAL inaccuracy targeting the primary purpose, making the description entirely misleading and harmful for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Reads a file into an evutil_file structure , reading its contents into provided pointers while handling errors for invalid file paths .\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function reads into an 'evutil_file' structure, which does not exist in the source; the code reads into a memory buffer via provided pointers. While it correctly mentions reading file contents and handling errors for invalid paths, this structural misrepresentation is a significant inaccuracy. This results in less than half of the claims being accurate.",
                "The summary captures the general purpose of reading a file into provided pointers and mentions error handling for invalid paths, which aligns with the function\u2019s primary purpose. However, it inaccurately states that the file is read into an \u2018evutil_file\u2019 structure, which does not exist in the source code, and omits critical secondary details like how binary mode is handled, the specific error codes returned (-1, -2), memory allocation, and read loop logic. This makes coverage incomplete despite identifying the main functionality.",
                "The summary contains an inaccurate claim by stating the function reads into an 'evutil_file structure', which does not exist in the source; the code reads directly into a char* buffer via provided pointers. This is a FATAL error about the function's primary purpose and I/O. While it correctly mentions reading file contents and handling errors for invalid paths, the core misunderstanding of the output type severely undermines reliability."
            ]
        },
        "cpbcs": {
            "summary": "Reads a specified file into a buffer, ensuring it is valid and handling line endings appropriately.\n",
            "score": [
                0.3,
                0.5,
                0.2
            ],
            "reason": [
                "The summary correctly states that the function reads a specified file into a buffer, which matches the code's core functionality. However, the mention of 'handling line endings appropriately' is inaccurate, as the source code does not process or normalize line endings; it only reads raw file data. This results in only about half of the claims being accurate.",
                "The summary correctly captures the primary purpose of reading a specified file into a buffer, which aligns with the source code. However, it inaccurately mentions handling line endings, which is not present in the implementation, and omits key secondary details such as binary mode handling, size validation, error codes, and memory allocation specifics. These omissions reduce completeness despite the correct primary purpose.",
                "The summary contains one accurate claim \u2014 that the function reads the specified file into a buffer, which matches the code\u2019s primary purpose. However, it inaccurately claims that the function handles line endings, which is not implemented in the source. This is a FATAL error because it misrepresents a key behavior that could mislead about I/O handling. Consequently, despite one correct high-level claim, the negative impact from the false detailed claim about line endings leads to a low score."
            ]
        },
        "misum": {
            "summary": "Reads data from a file descriptor, using either a fast file or standard iovec up to the specified count.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function reads data from a file descriptor using either a fast file or standard iovec up to a specified count, which is not reflected in the source code. The source implements reading a file by opening it, checking size constraints, allocating memory, reading with a loop, and returning the contents\u2014not using fast file or iovec. This is a semantic mismatch, so none of the claims are accurate.",
                "The summary is inaccurate because the source function reads data from a file given its filename, not from an existing file descriptor, and does not involve a fast file or iovec mechanism. It omits the primary purpose of allocating memory, handling binary mode, managing file size checks, and correctly setting outputs, while introducing irrelevant concepts. Therefore, it fails to capture the core semantics.",
                "The summary claims the function reads from a file descriptor using fast file or iovec, which contradicts the source code. The source opens a file by name, allocates memory, and reads its contents via a loop using `read`, with no reference to fast file or iovec mechanisms. This is a FATAL inaccuracy affecting the primary purpose of the function, and there are no accurate claims to offset it."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071584245680,
    "strip_function_name": "sub_FFFFFFFF815267B0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815267B0(\n        _QWORD **a1,\n        int a2,\n        __int64 a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  _QWORD *v14; // r13\n  unsigned int v15; // ebx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  char *v20; // rcx\n  __int64 v21; // r9\n\n  v14 = a1[2];\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return 0;\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v15 = sub_FFFFFFFF812B8480(\n            a3,\n            a4,\n            (__int64)\"%s %u %s %u \",\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11,\n            a12,\n            **a1,\n            3 - (unsigned int)(*((_DWORD *)v14 + 19) == 0),\n            v14[17] + 12LL,\n            *((_DWORD *)v14 + 5));\n    v19 = *((_DWORD *)v14 + 19);\n    if ( !v19 || a4 <= v15 )\n      return v15;\n    v20 = \"no\";\n    if ( v19 != 1 )\n      v20 = (char *)&unk_FFFFFFFF81999F6F;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3 + (int)v15,\n                           a4 - v15,\n                           (__int64)\"%ssync \",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           v17,\n                           v18,\n                           a11,\n                           a12,\n                           v20)\n         + v15;\n  }\n  else\n  {\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v21 = 70LL;\n    if ( !*((_DWORD *)v14 + 33) )\n      v21 = *((_DWORD *)v14 + 32) == 0 ? 65 : 68;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3,\n                           a4,\n                           (__int64)\"3 %s %s %c\",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           a9,\n                           a10,\n                           a11,\n                           a12,\n                           **a1,\n                           v14[17] + 12LL,\n                           v21);\n  }\n}\n",
    "function_name": "disk_status",
    "decompiled_code": "__int64 __fastcall disk_status(\n        _QWORD **a1,\n        int a2,\n        __int64 a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  _QWORD *v14; // r13\n  unsigned int v15; // ebx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  char *v20; // rcx\n  __int64 v21; // r9\n\n  v14 = a1[2];\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return 0;\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v15 = scnprintf(\n            a3,\n            a4,\n            (__int64)\"%s %u %s %u \",\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11,\n            a12,\n            **a1,\n            3 - (unsigned int)(*((_DWORD *)v14 + 19) == 0),\n            v14[17] + 12LL,\n            *((_DWORD *)v14 + 5));\n    v19 = *((_DWORD *)v14 + 19);\n    if ( !v19 || a4 <= v15 )\n      return v15;\n    v20 = \"no\";\n    if ( v19 != 1 )\n      v20 = (char *)&unk_FFFFFFFF81999F6F;\n    return (unsigned int)scnprintf(a3 + (int)v15, a4 - v15, (__int64)\"%ssync \", a5, a6, a7, a8, v17, v18, a11, a12, v20)\n         + v15;\n  }\n  else\n  {\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v21 = 70LL;\n    if ( !*((_DWORD *)v14 + 33) )\n      v21 = *((_DWORD *)v14 + 32) == 0 ? 65 : 68;\n    return (unsigned int)scnprintf(\n                           a3,\n                           a4,\n                           (__int64)\"3 %s %s %c\",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           a9,\n                           a10,\n                           a11,\n                           a12,\n                           **a1,\n                           v14[17] + 12LL,\n                           v21);\n  }\n}\n",
    "source_code": "\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch(status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"3 %s %s %c\", log->type->name, lc->log_dev->name,\n\t\t       lc->log_dev_flush_failed ? 'F' :\n\t\t       lc->log_dev_failed ? 'D' :\n\t\t       'A');\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %s %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\n\t\t       lc->region_size);\n\t\tDMEMIT_SYNC;\n\t}\n\n\treturn sz;\n}",
    "comment": "Generates and emits status information for a dirty log based on the provided status type, including device name and synchronization details.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Outputs the status of a dirty log , providing information or table details based on the specified status type .\n",
    "cpbcs_sum": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
    "misum_sum": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
    "decom_sum": "Formats and writes synchronization or mode command strings into an output buffer based on device state flags and provided parameters.",
    "cfg_sum": "Formats and writes synchronization or status messages based on input flags and device state, returning the total bytes written.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains a single vague statement that does not align with the source code's functionality, which involves emitting status information based on condition checks in the disk_status function. There are no fact-based claims about the code's semantics, making it completely inaccurate for evaluation purposes.",
                "The summary 'push a pointer type.' is vague, unrelated to the source code's actual implementation, and fails to mention any aspect of the function's primary purpose of reporting disk status in different formats based on status type. It does not capture any critical semantic units such as inputs, outputs, conditions, or constants. This is noise rather than an accurate description.",
                "The summary's sole claim ('push a pointer type') is unrelated to the source code's functionality, which formats disk log status information. This is pure NOISE with no accurate claims, providing no insight into purpose, I/O, or behavior. The worst failure mode is excessive NOISE, and there is no useful detail to aid understanding."
            ]
        },
        "bint5": {
            "summary": "Outputs the status of a dirty log , providing information or table details based on the specified status type .\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary accurately conveys that the function outputs the status of a dirty log and that the output varies depending on the specified status type, which aligns with the switch cases in the source code. It does not contain contradictory or irrelevant information, though it is broad and lacks specifics about the exact data emitted. All claims are accurate but low-detail, yielding a high proportion of correctness.",
                "The summary captures the primary purpose by stating that the function outputs the status of a dirty log and differentiates behavior based on the status type. However, it omits key secondary details such as the specific output formats used in STATUSTYPE_INFO (including device name and status flags) and STATUSTYPE_TABLE (including sync state and region size), as well as the conditional logic determining these values. This results in partial coverage and lack of detail on observable outputs.",
                "The summary makes one broad claim that the function outputs the status of a dirty log and varies the output based on the specified status type. This is generally accurate and matches the source logic, which emits different formatted strings depending on STATUSTYPE_INFO or STATUSTYPE_TABLE. However, the claim is very generic, lacking specifics about the details included in each status output (e.g., device name, failure flags, sync mode, region size). There are no inaccurate or contradictory statements, but the gain is low because the summary provides minimal insight beyond a safe, high-level description."
            ]
        },
        "cpbcs": {
            "summary": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function outputs the status of a dirty log and distinguishes between providing information or table details depending on the status type. This matches the source code, which switches on the status type to format different output using DMEMIT for STATUSTYPE_INFO and STATUSTYPE_TABLE. The claim is broad but accurate and directly related to the function\u2019s behavior.",
                "The summary correctly captures the primary purpose of the function: it outputs the status of a dirty log and differentiates output based on the status type. However, it lacks coverage of important secondary details from the code, such as the specific formats used for STATUSTYPE_INFO and STATUSTYPE_TABLE, the inclusion of log type name, log device name, status flags ('F', 'D', 'A'), sync values, and region size. Without these details, completeness is limited to the core functional intent.",
                "The summary makes a single broad claim that the function outputs the status of a dirty log and provides information or table details based on the status type. This is accurate and aligns with the code\u2019s switch logic for STATUSTYPE_INFO and STATUSTYPE_TABLE. The claim is SAFE but low in informational value, lacking deeper specifics such as emitted format details, key variables used, or conditions checked. There are no inaccuracies or contradictions, so there\u2019s no negative impact, but the gain is low due to generic wording."
            ]
        },
        "misum": {
            "summary": "Outputs the status of a dirty log, providing information or table details based on the specified status type.\n",
            "score": [
                0.9,
                0.5,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function outputs the status of a dirty log and that the output varies based on the status type, which matches the INFO and TABLE branches in the source code. While the summary is broad and omits specific details of the output format, it contains no contradictions or irrelevant content, making it entirely accurate given its generality.",
                "The summary correctly identifies the primary purpose of the function: to output the status of a dirty log with information or table details depending on the status type. However, it omits all secondary details such as the specific output format, inclusion of device name, state indicators ('F', 'D', 'A'), handling of sync mode values, region size, and sync emission. This lack of coverage of key constants and output specifics prevents a higher score.",
                "The summary correctly captures the general purpose of the function \u2014 outputting dirty log status information or table details depending on the status type \u2014 which aligns with the source code\u2019s switch on STATUSTYPE_INFO and STATUSTYPE_TABLE and corresponding DMEMIT calls. However, it is very broad and lacks specifics about the exact output format, the fields included, or conditionals within the emitted data. There are no inaccurate or contradictory claims, but the gain is low due to the limited detail, making it safe but minimally informative."
            ]
        }
    }
}
{
    "project_name": "readline",
    "function_addr": 223328,
    "strip_function_name": "rl_insert_text",
    "strip_decompiled_code": "__int64 __fastcall rl_insert_text(char *src)\n{\n  unsigned int v1; // r13d\n  unsigned int v3; // eax\n  unsigned int v4; // r12d\n  int v5; // ecx\n  __int64 v6; // rdi\n  __int64 v7; // rdi\n  __int64 v8; // rdx\n  char v9; // si\n  _BYTE *v10; // rax\n  int v11; // eax\n\n  v1 = 0;\n  if ( src )\n  {\n    if ( *src )\n    {\n      v3 = strlen(src);\n      v4 = v3;\n      v1 = v3;\n      if ( v3 )\n      {\n        v5 = rl_end[0];\n        v6 = rl_end[0] + v3;\n        if ( (int)v6 >= rl_line_buffer_len )\n        {\n          rl_extend_line_buffer(v6);\n          v5 = rl_end[0];\n        }\n        v7 = rl_point[0];\n        if ( rl_point[0] <= v5 )\n        {\n          v8 = v5;\n          do\n          {\n            --v5;\n            v9 = rl_line_buffer[v8];\n            v10 = &rl_line_buffer[v8--];\n            v10[v1] = v9;\n            v7 = rl_point[0];\n          }\n          while ( v5 >= rl_point[0] );\n        }\n        strncpy(&rl_line_buffer[v7], src, (int)v4);\n        if ( !rl_doing_an_undo )\n        {\n          if ( v4 == 1 )\n          {\n            if ( rl_undo_list )\n            {\n              if ( rl_undo_list[6] == 1 )\n              {\n                v11 = rl_undo_list[3];\n                if ( v11 == rl_point[0] && v11 - rl_undo_list[2] <= 19 )\n                {\n                  rl_undo_list[3] = v11 + 1;\nLABEL_18:\n                  rl_point[0] = v4 + v11;\n                  rl_end[0] += v4;\n                  rl_line_buffer[rl_end[0]] = 0;\n                  return v1;\n                }\n              }\n            }\n          }\n          rl_add_undo(1LL, rl_point[0], rl_point[0] + v4, 0LL);\n        }\n        v11 = rl_point[0];\n        goto LABEL_18;\n      }\n    }\n  }\n  return v1;\n}\n",
    "function_name": "rl_insert_text",
    "decompiled_code": "int __fastcall rl_insert_text(const char *string)\n{\n  int v1; // r13d\n  int v3; // eax\n  int v4; // r12d\n  int v5; // ecx\n  __int64 v6; // rdi\n  __int64 v7; // rdx\n  char v8; // si\n  char *v9; // rax\n  int end; // eax\n\n  v1 = 0;\n  if ( string )\n  {\n    if ( *string )\n    {\n      v3 = strlen(string);\n      v4 = v3;\n      v1 = v3;\n      if ( v3 )\n      {\n        v5 = rl_end;\n        if ( rl_end + v3 >= rl_line_buffer_len )\n        {\n          ((void (*)(void))rl_extend_line_buffer)();\n          v5 = rl_end;\n        }\n        v6 = rl_point;\n        if ( rl_point <= v5 )\n        {\n          v7 = v5;\n          do\n          {\n            --v5;\n            v8 = rl_line_buffer[v7];\n            v9 = &rl_line_buffer[v7--];\n            v9[v1] = v8;\n            v6 = rl_point;\n          }\n          while ( v5 >= rl_point );\n        }\n        strncpy(&rl_line_buffer[v6], string, v4);\n        if ( !rl_doing_an_undo )\n        {\n          if ( v4 == 1 )\n          {\n            if ( rl_undo_list )\n            {\n              if ( rl_undo_list->what == undo_code::UNDO_INSERT )\n              {\n                end = rl_undo_list->end;\n                if ( end == rl_point && end - rl_undo_list->start <= 19 )\n                {\n                  rl_undo_list->end = end + 1;\nLABEL_18:\n                  rl_point = v4 + end;\n                  rl_end += v4;\n                  rl_line_buffer[rl_end] = 0;\n                  return v1;\n                }\n              }\n            }\n          }\n          ((void (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))rl_add_undo)(\n            1LL,\n            (unsigned int)rl_point,\n            (unsigned int)(rl_point + v4),\n            0LL);\n        }\n        end = rl_point;\n        goto LABEL_18;\n      }\n    }\n  }\n  return v1;\n}\n",
    "source_code": "int\nrl_insert_text (const char *string)\n{\n  register int i, l;\n\n  l = (string && *string) ? strlen (string) : 0;\n  if (l == 0)\n    return 0;\n\n  if (rl_end + l >= rl_line_buffer_len)\n    rl_extend_line_buffer (rl_end + l);\n\n  for (i = rl_end; i >= rl_point; i--)\n    rl_line_buffer[i + l] = rl_line_buffer[i];\n\n  strncpy (rl_line_buffer + rl_point, string, l);\n\n  /* Remember how to undo this if we aren't undoing something. */\n  if (_rl_doing_an_undo == 0)\n    {\n      /* If possible and desirable, concatenate the undos. */\n      if ((l == 1) &&\n\t  rl_undo_list &&\n\t  (rl_undo_list->what == UNDO_INSERT) &&\n\t  (rl_undo_list->end == rl_point) &&\n\t  (rl_undo_list->end - rl_undo_list->start < 20))\n\trl_undo_list->end++;\n      else\n\trl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);\n    }\n  rl_point += l;\n  rl_end += l;\n  rl_line_buffer[rl_end] = '\\0';\n  return l;\n}",
    "comment": "Inserts a given string into a line buffer at a specified point, adjusting the buffer and managing undo operations accordingly.",
    "hext5_sum": "get the elf linker hash table from a link_info structure.",
    "bint5_sum": "Inserts a string of text into the line buffer at a specified cursor position , expanding the line buffer if necessary .\n",
    "cpbcs_sum": "Inserts a new line buffer into a buffer, updating the buffer size and ensuring it does not exceed the current buffer size.\n",
    "misum_sum": "Converts a list of input, appending characters to a specified line buffer, while handling line breaks and memory management.\n",
    "decom_sum": "Inserts the given string into the readline buffer at the current cursor position, shifting existing text and updating undo history and buffer metadata.",
    "cfg_sum": "Inserts a given string into the line buffer at the cursor position, shifting content, resizing if needed, and updating undo history and buffer state.",
    "work_score": {
        "hext5": {
            "summary": "get the elf linker hash table from a link_info structure.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function retrieves an ELF linker hash table from a link_info structure, but the source code clearly defines rl_insert_text, which manipulates a line buffer and performs text insertion with undo support. None of the summary\u2019s content matches the implementation, making the claim entirely inaccurate.",
                "The summary refers to retrieving an ELF linker hash table from a link_info structure, which is unrelated to the source code provided. The source implements text insertion into a readline buffer with buffer extension, undo management, and pointer adjustments. The summary misses the primary purpose and all secondary details, making it entirely inaccurate.",
                "The summary describes retrieving an ELF linker hash table from a link_info structure, which is entirely unrelated to the provided C function. The source implements rl_insert_text, handling string insertion into a readline buffer with undo support. This mismatch is a FATAL error regarding the primary purpose, making the summary wholly inaccurate."
            ]
        },
        "bint5": {
            "summary": "Inserts a string of text into the line buffer at a specified cursor position , expanding the line buffer if necessary .\n",
            "score": [
                1.0,
                0.5,
                0.5
            ],
            "reason": [
                "The summary contains one primary claim: that the function inserts a string of text into the line buffer at a specified cursor position and expands the buffer if needed. Both aspects are supported by the source code: it determines insertion length, shifts existing content from the cursor position (rl_point), and calls rl_extend_line_buffer when required. No contradictory or extraneous claims are present, so the accuracy is very high.",
                "The summary correctly identifies the primary purpose of the function as inserting a string into the line buffer at the current cursor position and mentions buffer expansion if needed, which matches the source code's logic. However, it omits key secondary details such as handling cases where the string is empty, shifting existing buffer content, updating undo history, adjusting cursor and buffer end positions, and null-terminating the buffer. This results in incomplete coverage despite accurately capturing the main function role.",
                "The summary correctly states that the function inserts a string into the line buffer at the cursor position and expands the buffer if needed. These are accurate and match the core behavior in the source code. However, it omits other significant operations such as shifting existing content, handling undo history, and updating cursor/end positions, resulting in only broad, low-information claims. There are no inaccuracies or contradictions, but the gain is low due to lack of detail."
            ]
        },
        "cpbcs": {
            "summary": "Inserts a new line buffer into a buffer, updating the buffer size and ensuring it does not exceed the current buffer size.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior: it claims to insert a 'new line buffer' rather than inserting text into the existing line buffer, and misstates that it ensures the size does not exceed the current buffer size, whereas the code extends the buffer if needed. These inaccuracies mean less than half of the claims align with the source code.",
                "The summary misstates the primary purpose by saying it \"inserts a new line buffer\" instead of inserting text into an existing line buffer. It omits critical secondary details such as handling empty input, extending the buffer when needed, shifting existing content, copying the string, managing undo behavior, updating positions, and null-terminating the buffer. While it vaguely mentions updating the buffer size, it inaccurately describes constraints as \"ensuring it does not exceed\" rather than extending capacity when necessary.",
                "The summary contains one main claim: that the function inserts a new line buffer into a buffer, updating size and ensuring it does not exceed the current buffer size. This is inaccurate\u2014rl_insert_text inserts a given string into the existing line buffer at a point, shifting content and extending the buffer if needed, not inserting a 'new line buffer.' The claim misstates the core operation, which is a FATAL error regarding the primary purpose. No accurate details are present to offset this, resulting in low reliability."
            ]
        },
        "misum": {
            "summary": "Converts a list of input, appending characters to a specified line buffer, while handling line breaks and memory management.\n",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains multiple inaccuracies: it claims the function converts a list of input, which is not reflected in the code, and references handling of line breaks, which the implementation does not address. While it correctly indicates appending characters to a line buffer and mentions memory management, less than half of the claims match the source code accurately, leading to a low precision of fact-based claims.",
                "The summary misrepresents the primary purpose \u2014 the function inserts a given string at the current point in a line buffer, not converting a list of input or handling line breaks. It omits key secondary details such as calculating length, extending the buffer when needed, shifting existing content, copying new text, adjusting undo information, updating pointer positions, and null-terminating the buffer. This indicates missed primary purpose and coverage of critical secondary behavior.",
                "The summary makes broad claims about 'converting a list of input' and 'handling line breaks' which are inaccurate relative to the source code. The function inserts a given string into a line buffer with memory management and undo handling, not list conversion or explicit line break handling. This introduces substantive NOISE with no FATAL errors, but the description fails to convey precise implementation details, resulting in low-information output with minimal positive gain."
            ]
        }
    }
}
{
    "project_name": "glpk",
    "function_addr": 536656,
    "strip_function_name": "sub_83050",
    "strip_decompiled_code": "__int64 __fastcall sub_83050(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // r13d\n  int v3; // edx\n  __int64 v5; // rbx\n  int v6; // r12d\n  __int64 v7; // r8\n  char *v8; // rcx\n  char v9; // al\n  _BYTE *v10; // rsi\n\n  v2 = *(_DWORD *)(a1 + 32);\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(int *)a1 <= 0 )\n  {\n    v6 = 0;\n  }\n  else\n  {\n    v5 = 1LL;\n    v6 = 0;\n    do\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + v5) & 0x10) != 0 )\n      {\n        if ( ++v6 > v3 )\n          glp_assert_(\"k <= ks->n\", \"misc/ks.c\", 255LL);\n        v7 = v6;\n        v8 = (char *)(a2 + v6);\n        v9 = *v8;\n        if ( (unsigned __int8)*v8 > 1u )\n        {\n          glp_assert_(\"x[k] == 0 || x[k] == 1\", \"misc/ks.c\", 256LL);\n          v8 = (char *)(a2 + v6);\n          v7 = v6;\n          v9 = *v8;\n        }\n        v10 = (_BYTE *)(v5 + *(_QWORD *)(a1 + 40));\n        if ( (*v10 & 1) != 0 )\n          v9 = 1 - v9;\n        *v10 = v9;\n        v3 = *(_DWORD *)(a1 + 4);\n        if ( *v8 )\n          v2 += *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v7);\n      }\n      ++v5;\n    }\n    while ( *(_DWORD *)a1 >= (int)v5 );\n  }\n  if ( v6 != v3 )\n    glp_assert_(\"k == ks->n\", \"misc/ks.c\", 265LL);\n  return v2;\n}\n",
    "function_name": "restore",
    "decompiled_code": "__int64 __fastcall restore(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // r13d\n  int v3; // edx\n  __int64 v5; // rbx\n  int v6; // r12d\n  __int64 v7; // r8\n  char *v8; // rcx\n  char v9; // al\n  _BYTE *v10; // rsi\n\n  v2 = *(_DWORD *)(a1 + 32);\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(int *)a1 <= 0 )\n  {\n    v6 = 0;\n  }\n  else\n  {\n    v5 = 1LL;\n    v6 = 0;\n    do\n    {\n      if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + v5) & 0x10) != 0 )\n      {\n        if ( ++v6 > v3 )\n          ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\"k <= ks->n\", \"misc/ks.c\", 255LL);\n        v7 = v6;\n        v8 = (char *)(a2 + v6);\n        v9 = *v8;\n        if ( (unsigned __int8)*v8 > 1u )\n        {\n          ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\n            \"x[k] == 0 || x[k] == 1\",\n            \"misc/ks.c\",\n            256LL);\n          v8 = (char *)(a2 + v6);\n          v7 = v6;\n          v9 = *v8;\n        }\n        v10 = (_BYTE *)(v5 + *(_QWORD *)(a1 + 40));\n        if ( (*v10 & 1) != 0 )\n          v9 = 1 - v9;\n        *v10 = v9;\n        v3 = *(_DWORD *)(a1 + 4);\n        if ( *v8 )\n          v2 += *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v7);\n      }\n      ++v5;\n    }\n    while ( *(_DWORD *)a1 >= (int)v5 );\n  }\n  if ( v6 != v3 )\n    ((void (__fastcall *)(const char *, const char *, __int64))glp_assert_)(\"k == ks->n\", \"misc/ks.c\", 265LL);\n  return v2;\n}\n",
    "source_code": "\nstatic int restore(struct ks *ks, char x[])\n{     int j, k, z;\n      z = ks->c0;\n      for (j = 1, k = 0; j <= ks->orig_n; j++)\n      {  if (ks->x[j] & 0x10)\n         {  k++;\n            xassert(k <= ks->n);\n            xassert(x[k] == 0 || x[k] == 1);\n            if (ks->x[j] & 1)\n               ks->x[j] = 1 - x[k];\n            else\n               ks->x[j] = x[k];\n            if (x[k])\n               z += ks->c[k];\n         }\n      }\n      xassert(k == ks->n);\n      return z;\n}",
    "comment": "Restores values in the `ks->x` array based on conditions and updates a sum `z` based on corresponding values from the `x` array.",
    "hext5_sum": "returns (the former by obstack_free). this can handle different kinds of stabs (s,n,d) and different kinds of stab sections. if stab_secname_obstack_end is non-null, then stab_secname and stabstr_secname will be freed if possible",
    "bint5_sum": "Finds the index of the first non-zero element in a key-value pair within the specified range of an array .\n",
    "cpbcs_sum": "Extracts the value from a variable table and updates the column list with the column of each column in the given column structure.\n",
    "misum_sum": "Extracts a linear programming problem from a linear programming problem, converting each column to a representation if necessary, and stores the index after the index.\n",
    "decom_sum": "Validates and updates a binary selection array for flagged items, toggling bits as needed and summing associated weights, ensuring index consistency via assertions.",
    "cfg_sum": "Validates and updates a set of flagged items based on binary state inputs, enforcing consistency with assertions and returning the updated aggregate value.",
    "work_score": {
        "hext5": {
            "summary": "returns (the former by obstack_free). this can handle different kinds of stabs (s,n,d) and different kinds of stab sections. if stab_secname_obstack_end is non-null, then stab_secname and stabstr_secname will be freed if possible",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's claims about handling stabs, freeing memory via obstack_free, and conditional freeing of stab_secname-related variables do not match any logic present in the provided restore function, which manipulates ks->x and computes z. All claims are unrelated to the source code and thus inaccurate.",
                "The summary is entirely unrelated to the provided source code. It discusses freeing stab sections and obstack memory management, which has no connection to the restore function's purpose of updating ks->x values based on bitwise checks, validating inputs with xassert, accumulating z, and returning it. The primary purpose and all secondary details of the function are missed.",
                "The summary's claims relate to freeing memory via obstack_free and handling various stab section types, which are unrelated to the provided source code that restores values in an array and calculates a sum. All extracted claims are NOISE with no overlap in data structures, function purpose, or I/O from the actual implementation. The worst failure mode is overwhelming NOISE, resulting in no usable insight for understanding the function."
            ]
        },
        "bint5": {
            "summary": "Finds the index of the first non-zero element in a key-value pair within the specified range of an array .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function finds the index of the first non-zero element in a key-value pair, which does not align with the source code. The code actually iterates through elements of ks->x with bitmask checks, updates values based on conditions, and computes a sum, without any clear operation related to key-value pair searching or finding a first non-zero element. This makes the single claim inaccurate, resulting in no accurate claims.",
                "The summary describes finding the index of the first non-zero element in a key-value pair, which is unrelated to the actual function. The source code restores values in ks->x based on input array x, applies assertions on bounds and binary values, updates ks->x conditionally, and accumulates a sum in z, returning it. The primary purpose and all secondary details are missed, and the claim is inaccurate with respect to the source implementation.",
                "The summary claims the function finds the index of the first non-zero element in a key-value pair, which is entirely inaccurate per the code. The code instead iterates over ks->x[], updates values based on bitwise flags, validates conditions with assertions, and accumulates a sum z to return. This is a FATAL error about the primary purpose, as it misrepresents what the function does, providing no accurate insight."
            ]
        },
        "cpbcs": {
            "summary": "Extracts the value from a variable table and updates the column list with the column of each column in the given column structure.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims that the function extracts values from a variable table and updates a column list based on a column structure, which does not align with the source code. The source code iterates over ks->x elements, applies bitwise checks, updates ks->x based on the x array, asserts conditions, and updates an accumulator z. There is no direct mention of a variable table, column list, or column structure. All claims are inaccurate, resulting in no accurate matches.",
                "The summary is inaccurate because it describes extracting values from a variable table and updating a column list, which does not align with the source code's actual purpose of restoring values in ks->x based on conditions and input array x, performing assertions, calculating a sum z, and returning it. The PRIMARY PURPOSE and key secondary details such as iteration over ks->orig_n, bitwise condition checks, value inversion, sum accumulation, and final assertion are entirely missed.",
                "The summary's claims about extracting values from a variable table and updating a column list do not align with the source code, which processes elements in an array based on bitwise flags, performs assertions, updates ks->x[], and calculates a sum. These are semantic contradictions regarding the function's primary purpose, making them FATAL errors. There are no accurate claims, resulting in high negative impact and zero net benefit."
            ]
        },
        "misum": {
            "summary": "Extracts a linear programming problem from a linear programming problem, converting each column to a representation if necessary, and stores the index after the index.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes extracting a linear programming problem and converting columns, which is unrelated to and contradicts the source code's actual function. The source code restores values in an array based on bitwise conditions and updates a sum, with assertions ensuring correctness. None of the summary's claims are accurate about the source implementation, resulting in 0% accurate claims.",
                "The summary's claims about extracting and converting a linear programming problem do not align with the source code, which iterates over ks->x elements, applies bitwise checks, updates values, asserts constraints, and computes a sum. It misses the primary purpose of restoring ks->x states from array x and validating them, and does not reference key secondary details such as bitwise condition checks, assertions, and sum calculation. The summary content is inaccurate and unrelated to actual logic.",
                "The summary contains only inaccurate claims unrelated to the actual code. The function `restore` operates on internal arrays, applies bitmask checks, updates values, asserts constraints, and calculates a sum, but the summary incorrectly describes extracting and converting a linear programming problem. This is pure NOISE with no factual alignment, offering no insight into the implementation. The worst failure mode is overwhelming NOISE, leading to no net benefit."
            ]
        }
    }
}
{
    "project_name": "protobuf",
    "function_addr": 22480,
    "strip_function_name": "sub_57D0",
    "strip_decompiled_code": "__int64 __fastcall sub_57D0(__int64 a1)\n{\n  __int64 v1; // r13\n  unsigned int v2; // ebp\n  __int64 v3; // r12\n  unsigned int v4; // r14d\n  __int64 v5; // rbx\n  int v6; // eax\n  __int64 v7; // r15\n  int v9; // edx\n  __int64 v10; // [rsp+0h] [rbp-58h]\n\n  if ( !a1 )\n    return 0LL;\n  v1 = *(_QWORD *)(a1 + 64);\n  if ( !v1 )\n    return 0LL;\n  v2 = *(_DWORD *)(a1 + 48);\n  v3 = 0LL;\nLABEL_4:\n  if ( v2 <= 1 )\n  {\n    v7 = 0LL;\n    if ( v2 )\n    {\nLABEL_11:\n      v7 = v10 + 72LL * *(unsigned int *)(v1 + 4 * v3);\n      if ( 9 * *(_DWORD *)(v1 + 4 * v3) )\n        return 0LL;\n    }\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = v2 >> 1;\n      v5 = (v2 >> 1) + (unsigned int)v3;\n      v6 = 9 * *(_DWORD *)(v1 + 4 * v5);\n      v7 = *(_QWORD *)(a1 + 56) + 72LL * *(unsigned int *)(v1 + 4 * v5);\n      if ( !v6 )\n        break;\n      if ( v6 < 0 )\n      {\n        v9 = v3 + v2 - 1;\n        v3 = (unsigned int)(v5 + 1);\n        v2 = v9 - v5;\n        goto LABEL_4;\n      }\n      v2 >>= 1;\n      if ( v4 == 1 )\n        goto LABEL_11;\n    }\n  }\n  return v7;\n}\n",
    "function_name": "protobuf_c_message_descriptor_get_field_by_name",
    "decompiled_code": "const char **__fastcall protobuf_c_message_descriptor_get_field_by_name(__int64 a1, const char *a2)\n{\n  __int64 v2; // r13\n  unsigned int v3; // ebp\n  __int64 v4; // r12\n  unsigned int v5; // r14d\n  __int64 v6; // rbx\n  const char **v7; // r15\n  int v8; // eax\n  int v10; // edx\n  __int64 v11; // [rsp+8h] [rbp-50h]\n\n  if ( !a1 )\n    return 0LL;\n  v2 = *(_QWORD *)(a1 + 64);\n  if ( !v2 )\n    return 0LL;\n  v3 = *(_DWORD *)(a1 + 48);\n  v4 = 0LL;\nLABEL_4:\n  if ( v3 <= 1 )\n  {\n    v7 = 0LL;\n    if ( v3 )\n    {\n      v11 = *(_QWORD *)(a1 + 56);\nLABEL_12:\n      v7 = (const char **)(v11 + 72LL * *(unsigned int *)(v2 + 4 * v4));\n      if ( strcmp(*v7, a2) )\n        return 0LL;\n    }\n  }\n  else\n  {\n    v11 = *(_QWORD *)(a1 + 56);\n    while ( 1 )\n    {\n      v5 = v3 >> 1;\n      v6 = (v3 >> 1) + (unsigned int)v4;\n      v7 = (const char **)(v11 + 72LL * *(unsigned int *)(v2 + 4 * v6));\n      v8 = strcmp(*v7, a2);\n      if ( !v8 )\n        break;\n      if ( v8 < 0 )\n      {\n        v10 = v4 + v3 - 1;\n        v4 = (unsigned int)(v6 + 1);\n        v3 = v10 - v6;\n        goto LABEL_4;\n      }\n      v3 >>= 1;\n      if ( v5 == 1 )\n        goto LABEL_12;\n    }\n  }\n  return v7;\n}\n",
    "source_code": "\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\tconst ProtobufCFieldDescriptor *field;\n\n\tif (desc == NULL || desc->fields_sorted_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_fields;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}",
    "comment": "Retrieves the field descriptor with a matching name from a sorted list of fields in a ProtobufC message descriptor.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search .\n",
    "cpbcs_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
    "misum_sum": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
    "decom_sum": "Performs a binary search over an index array to locate an entry with zero status and return its corresponding 72-byte structure address.",
    "cfg_sum": "Searches an indexed data structure for an entry with a zero-valued computed key and returns its corresponding address offset if found.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "All claims in the summary are inaccurate because they describe processing strings, replacing control characters, escape sequences, and Unicode handling, which are unrelated to the source code. The source code instead implements a binary search for a field descriptor by name within a protobuf message descriptor. No claim matches the actual functionality.",
                "The summary is entirely inaccurate because it describes string sanitization, Unicode handling, and escape sequence replacement, none of which are implemented in the provided function. The source code instead searches for a field descriptor by name using a binary search logic and returns it or NULL. The response misses the primary purpose, inputs, outputs, and all key details of the actual function.",
                "All claims in the summary are unrelated to the actual function, which searches for a field by name in a ProtobufCMessageDescriptor using a binary search. The summary's statements about replacing control characters, using a static buffer, and handling Unicode display are pure NOISE and do not reflect any aspect of the source code. No accurate claims were found, leading to high negative impact due to irrelevant information."
            ]
        },
        "bint5": {
            "summary": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search .\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function retrieves a method descriptor from a ProtobufCServiceDescriptor, while the source code clearly works with ProtobufCMessageDescriptor and returns a ProtobufCFieldDescriptor. Although it correctly mentions binary search, the core claim about the target type and object is inaccurate, making the majority of the claims misaligned with the source.",
                "The summary is inaccurate because it describes retrieving a method descriptor from a ProtobufCServiceDescriptor, while the source code retrieves a field descriptor from a ProtobufCMessageDescriptor. This contradicts the primary purpose of the function and fails to capture its actual inputs, outputs, and binary search logic over `fields_sorted_by_name`.",
                "The summary contains a FATAL inaccuracy by claiming the function retrieves a method descriptor from a ProtobufCServiceDescriptor, whereas the code retrieves a field descriptor from a ProtobufCMessageDescriptor. This misidentifies the primary purpose and misstates key I/O. While it correctly notes binary search, the core semantics are wrong, making it unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves a method descriptor from a ProtobufCServiceDescriptor, but the source shows it retrieves a field descriptor from a ProtobufCMessageDescriptor. It also specifies method search, whereas the code searches for a field by name. The binary search detail matches, but the object types and target entity are incorrect, making the majority of the claims inaccurate.",
                "The summary is inaccurate because it describes retrieving a method descriptor from a ProtobufCServiceDescriptor, whereas the source code retrieves a field descriptor from a ProtobufCMessageDescriptor. This misidentifies both the data type and the lookup target, missing the primary purpose entirely and failing to mention the binary search on field names and related null checks.",
                "The summary is inaccurate because it describes retrieving a method descriptor from a ProtobufCServiceDescriptor, while the source code retrieves a field descriptor from a ProtobufCMessageDescriptor. This contradicts the core purpose and key I/O of the function, making it a FATAL error with high negative impact. There is no accurate, high-information content to offset the error."
            ]
        },
        "misum": {
            "summary": "Retrieves the method descriptor from a ProtobufCServiceDescriptor by searching for a method name using binary search.\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves a method descriptor from a ProtobufCServiceDescriptor using binary search. In reality, the source code retrieves a field descriptor from a ProtobufCMessageDescriptor by searching for a field name. The descriptor type, the searched entity (method vs. field), and the source structure type are all inaccurately described, leaving 0% of claims aligned with the source implementation.",
                "The summary misidentifies the type of descriptor and the item being retrieved, referring to a 'method descriptor' from a 'ProtobufCServiceDescriptor' instead of a 'field descriptor' from a 'ProtobufCMessageDescriptor'. While it correctly notes the use of binary search to locate by name, the primary purpose is inaccurately stated and tied to the wrong data structures, leading to an incorrect description of the core functionality.",
                "The summary incorrectly describes retrieving a method descriptor from a ProtobufCServiceDescriptor, while the source code retrieves a field descriptor from a ProtobufCMessageDescriptor. This is a FATAL error impacting the primary purpose of the function, as it misidentifies the core input/output and intent. Although it mentions binary search, the key object type and role are wrong, leading to high negative impact and no reliable gain."
            ]
        }
    }
}
{
    "project_name": "poke",
    "function_addr": 544320,
    "strip_function_name": "sub_84E40",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_84E40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)\n{\n  __int64 v8; // r12\n  __int64 v9; // rdi\n  int v10; // eax\n  __int64 v11; // rdi\n  __int64 v12; // r12\n  int v13; // eax\n  __int64 v14; // rdi\n  __int64 v15; // r12\n  int v16; // eax\n  __int64 v17; // rdi\n  __int64 v18; // r12\n  int v19; // eax\n  __int64 v20; // rdi\n  __int64 v21; // r12\n  unsigned __int64 result; // rax\n  _QWORD *v23; // rcx\n  __int64 v24; // r8\n  __int64 v25; // r9\n\n  sub_81170((__int64 *)(a1 + 16), 5);\n  v8 = *(_QWORD *)(a1 + 16);\n  if ( a2 )\n    ++*(_DWORD *)(a2 + 60);\n  v9 = *(_QWORD *)(a1 + 8);\n  *(_QWORD *)(v8 + 32) = a2;\n  v10 = sub_8A6E0(v9);\n  v11 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v8 + 16) = v10;\n  v12 = *(_QWORD *)(a1 + 16);\n  v13 = sub_8A6E0(v11);\n  v14 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v12 + 20) = v13;\n  v15 = *(_QWORD *)(a1 + 16);\n  v16 = sub_8A6E0(v14);\n  v17 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v15 + 24) = v16;\n  v18 = *(_QWORD *)(a1 + 16);\n  v19 = sub_8A6E0(v17);\n  v20 = *(_QWORD *)(a1 + 8);\n  *(_DWORD *)(v18 + 56) = v19;\n  v21 = *(_QWORD *)(a1 + 16);\n  result = sub_8A6E0(v20);\n  *(_DWORD *)(v21 + 52) = result;\n  if ( a2 )\n    return sub_81880(a1, 0xE8u, 0LL, v23, v24, v25, a7);\n  return result;\n}\n",
    "function_name": "pkl_asm_for",
    "decompiled_code": "void __fastcall pkl_asm_for(pkl_asm_0 pasm, pkl_ast_node head)\n{\n  pkl_asm_level *level; // r12\n  pvm_program *program; // rdi\n  pvm_program_label v5; // eax\n  pvm_program *v6; // rdi\n  pkl_asm_level *v7; // r12\n  pvm_program_label v8; // eax\n  pvm_program *v9; // rdi\n  pkl_asm_level *v10; // r12\n  pvm_program_label v11; // eax\n  pvm_program *v12; // rdi\n  pkl_asm_level *v13; // r12\n  pvm_program_label v14; // eax\n  pvm_program *v15; // rdi\n  pkl_asm_level *v16; // r12\n\n  pkl_asm_pushlevel((pkl_asm_0)&pasm->level, 5);\n  level = pasm->level;\n  if ( head )\n    ++*((_DWORD *)head + 15);\n  program = pasm->program;\n  level->node1 = head;\n  v5 = pvm_program_fresh_label(program);\n  v6 = pasm->program;\n  level->label1 = v5;\n  v7 = pasm->level;\n  v8 = pvm_program_fresh_label(v6);\n  v9 = pasm->program;\n  v7->label2 = v8;\n  v10 = pasm->level;\n  v11 = pvm_program_fresh_label(v9);\n  v12 = pasm->program;\n  v10->label3 = v11;\n  v13 = pasm->level;\n  v14 = pvm_program_fresh_label(v12);\n  v15 = pasm->program;\n  v13->continue_label = v14;\n  v16 = pasm->level;\n  v16->break_label = pvm_program_fresh_label(v15);\n  if ( head )\n    pkl_asm_insn_0(pasm, pkl_asm_insn::PKL_INSN_PUSHF, 0LL);\n}\n",
    "source_code": "\nvoid\npkl_asm_for (pkl_asm pasm, pkl_ast_node head)\n{\n  pkl_asm_pushlevel (pasm, PKL_ASM_ENV_FOR_LOOP);\n\n  pasm->level->node1 = ASTREF (head);\n  pasm->level->label1 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label2 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label3 = pvm_program_fresh_label (pasm->program);\n  pasm->level->continue_label = pvm_program_fresh_label (pasm->program);\n  pasm->level->break_label = pvm_program_fresh_label (pasm->program);\n\n  if (head)\n    pkl_asm_insn (pasm, PKL_INSN_PUSHF, 0);\n}",
    "comment": "Initializes a for loop's environment in the assembly context, assigning labels and pushing the loop node if a valid head is provided.",
    "hext5_sum": "p is redefine node. hash value is generated from its \"source\" filed.",
    "bint5_sum": "Initializes loop labels and node references for a 'for-in ' loop based on the specified label type , which is either an array or a string .\n",
    "cpbcs_sum": "Finalizes a conditional assembly by writing an HTML span name, and referencing the result to the output buffer.\n",
    "misum_sum": "Encodes loop and values in a structured format by assigning values and referencing the given argument in the specified byte stream.\n",
    "decom_sum": "Initializes a data structure at a1+16 with values from a1+8, links it to a2, and optionally triggers a further operation when a2 is provided.",
    "cfg_sum": "Updates a target data structure with computed values from a source object, increments a counter if provided, and triggers an additional action when applicable.",
    "work_score": {
        "hext5": {
            "summary": "p is redefine node. hash value is generated from its \"source\" filed.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary states that 'p is redefine node' and that a hash value is generated from its 'source' field, but the source code shows a function setting loop labels and handling AST nodes without any hash generation or 'source' field. None of the claims align with the function's operations, resulting in complete inaccuracy.",
                "The summary contains claims unrelated to the source code semantics. It mentions a variable 'p' being redefined and a hash value generated from a 'source' field, none of which appear in the provided function. This misses the primary purpose of the function, which is to set up a 'for' loop context in the assembler with labels for loop control and possibly emit a PUSHF instruction if a head node is provided. No accurate or relevant claims are made, so there is no coverage of the main functionality or secondary details.",
                "The summary claims that 'p is redefine node' and that a hash value is generated from its 'source' field. Neither claim matches the source code, which deals with setting up labels and continuing/break logic for a 'for' loop in pkl_asm_for. These are NOISE since they do not target the actual code semantics. With no accurate claims and only irrelevant statements, the worst failure mode is overwhelming NOISE, yielding no positive gain."
            ]
        },
        "bint5": {
            "summary": "Initializes loop labels and node references for a 'for-in ' loop based on the specified label type , which is either an array or a string .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function initializes loop labels and stores a node reference, which matches the code assigning multiple label fields and node1. However, it inaccurately describes the loop as a 'for-in' loop and claims the label type is based on being an array or a string, which is not reflected in the source \u2014 there is no type check or label type differentiation in the code. As a result, less than half of the claims are accurate.",
                "The summary incorrectly specifies that the function is for a 'for-in' loop and depends on a label type of either array or string, which is not supported by the source code. The code sets up a generic 'for' loop environment, initializing several fresh labels and storing the head node reference. This means the primary purpose is misrepresented and secondary details like the exact labels and conditional instruction insertion are missing, leading to very low accuracy and completeness.",
                "The summary contains a FATAL inaccuracy: it claims the function is for a 'for-in' loop based on a label type of array or string, but the source code does not check or use any label type or distinguish array vs string. The actual primary purpose is to set up labels and node references for a 'for' loop at the assembly level, not dependent on such types. This directly contradicts the key semantics and primary purpose, making the description unreliable despite mentioning initialization of labels and node references."
            ]
        },
        "cpbcs": {
            "summary": "Finalizes a conditional assembly by writing an HTML span name, and referencing the result to the output buffer.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes actions related to HTML output and conditional assembly, which do not appear in the source code. The source code deals with setting up labels and environment for a 'for' loop in pkl_asm, with no operations involving HTML spans or output buffers. All claims are inaccurate relative to the code, resulting in zero alignment.",
                "The summary claims the function finalizes a conditional assembly, writes an HTML span, and references the result to an output buffer. None of these actions appear in the source code, which instead sets up labels and environment for a 'for' loop in an assembler context, and optionally pushes a frame if 'head' is provided. The primary purpose and secondary details of the source are completely missed, and the given claims are unrelated to code semantics.",
                "The summary describes an unrelated process involving HTML output and conditional assembly, which does not match the source code's actual purpose of setting up labels and environment for a 'for' loop in a program's assembly context. This is a FATAL inaccuracy targeting the primary purpose, making the response unreliable."
            ]
        },
        "misum": {
            "summary": "Encodes loop and values in a structured format by assigning values and referencing the given argument in the specified byte stream.\n",
            "score": [
                0.2,
                0.1,
                0.4
            ],
            "reason": [
                "The summary's claim that the function encodes loop and values in a structured format via a byte stream is not supported by the source code. The source shows setup for a 'for' loop environment by pushing a level, storing AST references, generating labels, and optionally inserting an instruction, but it does not involve encoding into a byte stream or generic value assignment beyond loop control structures. Thus, the factual alignment is low, with most claims inaccurate.",
                "The summary fails to capture the primary purpose of setting up a FOR loop execution environment in the assembler, including creation of multiple control flow labels and conditional instruction insertion. It instead describes an unrelated encoding of loop and values into a byte stream, which contradicts the source code semantics. No accurate claims align with the actual implementation.",
                "The summary is broadly accurate in that the function sets up structured information for a loop based on the given argument, but it uses vague, low-information terminology like 'structured format' and 'specified byte stream' that do not clearly correspond to the details of the implementation. There are no clearly false claims (no FATAL errors), but the description omits important specifics such as label creation for loop control and conditional instruction insertion. This results in safe but low-gain output, with the main shortcoming being its lack of actionable detail."
            ]
        }
    }
}
{
    "project_name": "libredwg",
    "function_addr": 9908448,
    "strip_function_name": "dwg_object_polyline_2d_get_numpoints",
    "strip_decompiled_code": "__int64 __fastcall dwg_object_polyline_2d_get_numpoints(__int64 a1, _DWORD *a2)\n{\n  unsigned int v2; // ebp\n  _DWORD *v4; // r13\n  __int64 v5; // rdx\n  __int64 v6; // r14\n  __int64 v7; // rax\n  __int64 v8; // rbx\n  __int64 v9; // r13\n  __int64 object; // rax\n\n  if ( !a1 || *(_DWORD *)(a1 + 16) != 15 )\n  {\n    if ( dword_11106F8 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( dword_11106F8 )\n        __fprintf_chk();\n      fputc(10, stderr);\n    }\n    *a2 = 1;\n    return 0;\n  }\n  v4 = *(_DWORD **)(a1 + 88);\n  v5 = *(_QWORD *)(a1 + 56);\n  v6 = *(_QWORD *)(v5 + 8);\n  *a2 = 0;\n  if ( *v4 <= 0x18u )\n  {\n    v2 = 0;\n    if ( *v4 > 0x14u )\n    {\n      v8 = dwg_ref_object(v4, *(_QWORD *)(v6 + 16));\n      v9 = dwg_ref_object(v4, *(_QWORD *)(v6 + 24));\n      if ( v8 )\n      {\n        do\n        {\n          if ( dwg_object_to_VERTEX_2D(v8) )\n            ++v2;\n          else\n            *a2 = 1;\n          object = dwg_next_object(v8);\n          v8 = object;\n        }\n        while ( object && v9 != object );\n      }\n      else\n      {\n        *a2 = 1;\n      }\n    }\n    else\n    {\nLABEL_8:\n      v7 = dwg_next_object(a1);\n      if ( v7 )\n      {\n        while ( *(_DWORD *)(v7 + 16) != 6 )\n        {\n          if ( !dwg_object_to_VERTEX_2D(v7) )\n          {\n            *a2 = 1;\n            goto LABEL_8;\n          }\n          ++v2;\n          v7 = dwg_next_object(a1);\n          if ( !v7 )\n            return v2;\n        }\n      }\n    }\n    return v2;\n  }\n  return *(unsigned int *)(*(_QWORD *)(v5 + 8) + 12LL);\n}\n",
    "function_name": "dwg_object_polyline_2d_get_numpoints",
    "decompiled_code": "BITCODE_BL __fastcall dwg_object_polyline_2d_get_numpoints(const dwg_object *obj, int *error)\n{\n  BITCODE_BL v2; // ebp\n  _dwg_struct *parent; // r13\n  Dwg_Object_Entity *entity; // rdx\n  Dwg_Entity_UNUSED *UNUSED; // r14\n  Dwg_Object *v7; // rax\n  Dwg_Object *v8; // rbx\n  __int64 v9; // r13\n  __int64 v10; // rax\n\n  if ( !obj || obj->type != 15 )\n  {\n    if ( loglevel_9 )\n    {\n      fwrite(\"ERROR: \", 1uLL, 7uLL, stderr);\n      if ( loglevel_9 )\n        ((void (*)(struct _IO_FILE *, __int64, const char *, ...))__fprintf_chk)(\n          stderr,\n          1LL,\n          \"%s: empty or wrong arg\",\n          \"dwg_object_polyline_2d_get_numpoints\");\n      fputc(10, stderr);\n    }\n    *error = 1;\n    return 0;\n  }\n  parent = obj->parent;\n  entity = obj->tio.entity;\n  UNUSED = entity->tio.UNUSED;\n  *error = 0;\n  if ( parent->header.version <= (unsigned int)DWG_VERSION_TYPE::R_2000 )\n  {\n    v2 = 0;\n    if ( parent->header.version > (unsigned int)DWG_VERSION_TYPE::R_12c1 )\n    {\n      v8 = (Dwg_Object *)((__int64 (__fastcall *)(_dwg_struct *, _QWORD))dwg_ref_object_localalias_21)(\n                           parent,\n                           *((_QWORD *)UNUSED + 2));\n      v9 = ((__int64 (__fastcall *)(_dwg_struct *, _QWORD))dwg_ref_object_localalias_21)(\n             parent,\n             *((_QWORD *)UNUSED + 3));\n      if ( v8 )\n      {\n        do\n        {\n          if ( dwg_object_to_VERTEX_2D(v8) )\n            ++v2;\n          else\n            *error = 1;\n          v10 = ((__int64 (__fastcall *)(Dwg_Object *))dwg_next_object)(v8);\n          v8 = (Dwg_Object *)v10;\n        }\n        while ( v10 && v9 != v10 );\n      }\n      else\n      {\n        *error = 1;\n      }\n    }\n    else\n    {\nLABEL_8:\n      v7 = (Dwg_Object *)((__int64 (__fastcall *)(const dwg_object *))dwg_next_object)(obj);\n      if ( v7 )\n      {\n        while ( v7->type != 6 )\n        {\n          if ( !dwg_object_to_VERTEX_2D(v7) )\n          {\n            *error = 1;\n            goto LABEL_8;\n          }\n          ++v2;\n          v7 = (Dwg_Object *)((__int64 (__fastcall *)(const dwg_object *))dwg_next_object)(obj);\n          if ( !v7 )\n            return v2;\n        }\n      }\n    }\n    return v2;\n  }\n  return entity->tio.UNUSED[3];\n}\n",
    "source_code": "BITCODE_BL\ndwg_object_polyline_2d_get_numpoints (const dwg_object *restrict obj,\n                                      int *restrict error)\n{\n  if (obj && obj->type == DWG_TYPE_POLYLINE_2D)\n    {\n      BITCODE_BL num_points = 0;\n      Dwg_Data *dwg = obj->parent;\n      Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;\n      Dwg_Entity_VERTEX_2D *vertex;\n      *error = 0;\n\n      if (dwg->header.version >= R_2004)\n        return obj->tio.entity->tio.POLYLINE_2D->num_owned;\n      // iterate over first_vertex - last_vertex\n      else if (dwg->header.version >= R_13)\n        {\n          Dwg_Object *vobj = dwg_ref_object (dwg, _obj->first_vertex);\n          Dwg_Object *vlast = dwg_ref_object (dwg, _obj->last_vertex);\n          if (!vobj)\n            *error = 1;\n          else\n            {\n              do\n                {\n                  if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                    {\n                      num_points++;\n                    }\n                  else\n                    {\n                      *error = 1; // return not all vertices, but some\n                    }\n                }\n              while ((vobj = dwg_next_object (vobj)) && vobj != vlast);\n            }\n        }\n      else // <r13: iterate over vertices until seqend\n        {\n          Dwg_Object *vobj;\n          while ((vobj = dwg_next_object (obj))\n                 && vobj->type != DWG_TYPE_SEQEND)\n            {\n              if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                num_points++;\n              else\n                *error = 1; // return not all vertices, but some\n            }\n        }\n      return num_points;\n    }\n  else\n    {\n      LOG_ERROR (\"%s: empty or wrong arg\", __FUNCTION__)\n      *error = 1;\n      return 0L;\n    }\n}",
    "comment": "Counts the number of 2D vertices in a polyline object based on DWG version and returns the count or an error code.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Counts the number of 2D vertices in a polyline object , returning an error if any vertex is invalid or if the object is incorrect .\n",
    "cpbcs_sum": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
    "misum_sum": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
    "decom_sum": "Retrieves the number of 2D vertex points in a DWG polyline object, returning an error if the object type or structure is invalid.",
    "cfg_sum": "Counts the number of 2D vertex objects in a polyline, validating type and references, and sets an error flag on invalid data.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains a vague and context-free statement that does not describe the function\u2019s behavior, logic, or semantics from the source code. It does not extract any fact-based claims about how the function processes polylines, handles errors, or counts points. As such, no claims can be marked as accurate, resulting in no alignment with the evaluation steps.",
                "The summary 'push a pointer type.' is vague and unrelated to the function's actual purpose, which determines the number of points in a POLYLINE_2D object with version-dependent logic and error handling. It fails to mention the primary purpose or any secondary details, making it entirely inaccurate.",
                "The summary contains only the vague statement 'push a pointer type,' which is unrelated to the actual function that computes the number of points in a 2D polyline based on DWG version and vertex iteration. This is pure NOISE with no accurate or relevant claims, providing no insight into the primary purpose, inputs, outputs, or logic of the source code."
            ]
        },
        "bint5": {
            "summary": "Counts the number of 2D vertices in a polyline object , returning an error if any vertex is invalid or if the object is incorrect .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function counts the number of 2D vertices in a polyline object, which matches the code logic. It also notes returning an error if a vertex is invalid or if the object is incorrect, which aligns with the implementation that sets *error to 1 in such cases. No contradictory or irrelevant claims are present, making all details accurate.",
                "The summary correctly identifies the primary purpose of counting 2D vertices in a polyline object and notes that an error is returned for invalid vertices or incorrect objects, aligning with the code's main functionality. However, it omits key secondary details such as version-specific logic (R_2004, R_13, and pre-R_13 handling), the different iteration approaches for vertices, and the nuance of partial success when some vertices are invalid. This lack of detail limits completeness despite accurate primary coverage.",
                "The summary correctly states that the function counts the number of 2D vertices in a polyline object and returns an error if any vertex is invalid or if the object is incorrect. These claims match the source, which iterates over vertices depending on DWG version, counts valid VERTEX_2D entities, and sets the error flag when vertices are invalid or the object is wrong. No inaccuracies are present, but the description is broad and omits key specifics about DWG version handling and iteration logic, giving it low informational gain."
            ]
        },
        "cpbcs": {
            "summary": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
            "score": [
                0.2,
                0.3,
                0.2
            ],
            "reason": [
                "The summary is inaccurate because the source code counts 2D vertices in a DWG_TYPE_POLYLINE_2D object, not 3D vertices. While it correctly notes that an error is returned if vertices are invalid or the object is wrong, the fundamental claim about vertex dimensionality contradicts the implementation.",
                "The summary is inaccurate because the function counts 2D vertices for a DWG_TYPE_POLYLINE_2D object, not 3D vertices. While it correctly notes that an error is returned if the object is invalid or contains invalid vertices, it misses important secondary details such as differing logic based on DWG version (R_2004, R_13, and pre-R_13 cases) and the num_owned shortcut for newer versions. The primary purpose is partially captured but with a significant semantic error about vertex type, making it unreliable.",
                "The summary contains a factual inaccuracy: it claims the function counts 3D vertices, but the source code clearly processes 2D vertices (VERTEX_2D). This is a FATAL error because it misrepresents the primary purpose of the function, which is to count 2D polyline vertices. While it is correct that the function returns an error for invalid vertices or wrong object type, the core semantic mismatch on vertex dimension undermines reliability."
            ]
        },
        "misum": {
            "summary": "Counts the number of 3D vertices in a polyline object, returning an error if any vertex is invalid or if the object is incorrect.\n",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function as counting 3D vertices, while the source code clearly operates on 2D vertices (Dwg_Entity_VERTEX_2D). It is correct that the function counts vertices in a polyline object and sets an error flag if a vertex is invalid or if the object type is incorrect, but the dimensionality mismatch is a significant factual error. As a result, only about half of the claims are accurate.",
                "The summary inaccurately states that the function counts 3D vertices, whereas the code handles 2D vertices in a POLYLINE_2D object. While it correctly notes error handling for invalid vertices and incorrect object types, the primary purpose is misstated, which means the main claim is incorrect despite partial alignment on secondary behavior.",
                "The summary incorrectly states that the function counts 3D vertices, while the source code clearly handles 2D vertices (Dwg_Entity_VERTEX_2D). This is a FATAL error because it misrepresents the primary purpose of the function. Although it correctly notes that an error is returned for invalid vertices or wrong object type, the core dimensionality mismatch undermines reliability."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 6038306,
    "strip_function_name": "sub_5C2322",
    "strip_decompiled_code": "__int64 __fastcall sub_5C2322(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __m128i *v10; // rbx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __int64 v13; // rax\n  __m128 v14; // xmm4\n  __m128 v15; // xmm5\n  __int64 v16; // rdi\n  const char *v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n\n  v10 = sub_51816D((const char *)0xB8, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  qword_89A638 = (__int64)v10;\n  v10->m128i_i32[3] = 1024;\n  v13 = sub_51812F((const char *)0x400, a10, a1, a2, a3, a4, v11, v12, a7, a8);\n  v10[1].m128i_i64[1] = v13;\n  v10[2].m128i_i64[0] = v13;\n  v10[3].m128i_i64[0] = (__int64)v10[3].m128i_i64;\n  v10[3].m128i_i64[1] = (__int64)v10[3].m128i_i64;\n  v16 = *(_QWORD *)(a10 + 8);\n  if ( v16 )\n  {\n    v18 = (const char *)sub_518195(v16, a10, a1, a2, a3, a4, *(double *)v14.m128_u64, *(double *)v15.m128_u64, a7, a8);\n    v10[2].m128i_i64[1] = (__int64)v18;\n    if ( !(unsigned int)sub_5C1052(v18, 1LL, v19, v20, v21, v22, a1, a2, a3, a4, v23, v24, a7, a8) )\n      return 0LL;\n    if ( v10->m128i_i32[1] )\n      sub_5C0E5C(1, 1LL, v25, v26, v27, v28, a1, a2, a3, a4, v14, v15, a7, a8);\n    v10[4].m128i_i8[8] = 0;\n  }\n  sub_5C17D1(a1, a2, a3, a4, *(double *)v14.m128_u64, *(double *)v15.m128_u64, a7, a8);\n  return 0LL;\n}\n",
    "function_name": "ed_main",
    "decompiled_code": "__int64 __fastcall ed_main(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __m128i *v10; // rbx\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  __m128 v13; // xmm4\n  __m128 v14; // xmm5\n  __int64 v15; // rax\n  const __m128i *v16; // rdi\n  int *v18; // rax\n  __int64 v19; // rdx\n  __int64 v20; // rcx\n  __int64 v21; // r8\n  __int64 v22; // r9\n  __m128 v23; // xmm4\n  __m128 v24; // xmm5\n  __int64 v25; // rdx\n  __int64 v26; // rcx\n  __int64 v27; // r8\n  __int64 v28; // r9\n\n  v10 = xzalloc(0xB8uLL, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  ptr_to_globals = (__int64)v10;\n  v10->m128i_i32[3] = 1024;\n  xmalloc(0x400uLL, a10, a1, a2, a3, a4, v11, v12, a7, a8);\n  v10[1].m128i_i64[1] = v15;\n  v10[2].m128i_i64[0] = v15;\n  v10[3].m128i_i64[0] = (__int64)v10[3].m128i_i64;\n  v10[3].m128i_i64[1] = (__int64)v10[3].m128i_i64;\n  v16 = *(const __m128i **)(a10 + 8);\n  if ( v16 )\n  {\n    v18 = xstrdup(v16, a10, a1, a2, a3, a4, *(double *)v13.m128_u64, *(double *)v14.m128_u64, a7, a8);\n    v10[2].m128i_i64[1] = (__int64)v18;\n    if ( !(unsigned int)readLines((const char *)v18, 1LL, v19, v20, v21, v22, a1, a2, a3, a4, v23, v24, a7, a8) )\n      return 0LL;\n    if ( v10->m128i_i32[1] )\n      setCurNum(1, 1LL, v25, v26, v27, v28, a1, a2, a3, a4, v13, v14, a7, a8);\n    v10[4].m128i_i8[8] = 0;\n  }\n  doCommands(a1, a2, a3, a4, v13, v14, a7, a8);\n  return 0LL;\n}\n",
    "source_code": "int ed_main(int argc UNUSED_PARAM, char **argv)\n{\n\tINIT_G();\n\n\tbufSize = INITBUF_SIZE;\n\tbufBase = xmalloc(bufSize);\n\tbufPtr = bufBase;\n\tlines.next = &lines;\n\tlines.prev = &lines;\n\n\tif (argv[1]) {\n\t\tfileName = xstrdup(argv[1]);\n\t\tif (!readLines(fileName, 1)) {\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (lastNum)\n\t\t\tsetCurNum(1);\n\t\tdirty = FALSE;\n\t}\n\n\tdoCommands();\n\treturn EXIT_SUCCESS;\n}",
    "comment": "Initializes a buffer, reads lines from a specified file if provided, and then executes commands in a loop.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Initializes an event-driven daemon that monitors input device events , processes them , and logs relevant actions accordingly .\n",
    "cpbcs_sum": "Initializes a new peer structure with an identifier and associated info and allocates a new file descriptor.\n",
    "misum_sum": "Allocates and initializes a new mount structure, setting its properties and registering the provided file stream with those handling.\n",
    "decom_sum": "Initializes and configures a 128-bit data structure, links resources, validates them, and performs final setup if validation succeeds.",
    "cfg_sum": "The function initializes a data structure with provided parameters, validates related resources, executes follow-up routines if checks pass, and finalizes state before returning.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary contains a vague and low-information statement that does not accurately reflect the source code's implementation. It fails to capture any of the function's actual operations, such as memory allocation, file handling, or loop execution, and does not correspond to a specific code semantics. This is pure noise with no accurate claims extracted.",
                "The summary 'push a pointer type' does not align with the source code, which initializes buffers, sets up linked list pointers, processes an optional filename with reading logic, and executes commands. It misses the primary purpose and observable behavior entirely, providing unrelated and low-information content.",
                "The summary 'push a pointer type.' is vague and unrelated to the source code's actual functionality. It does not reference the file reading, buffer initialization, command loop, or return semantics shown in the code. This is purely NOISE with no accurate claims, providing no meaningful insight and failing to align with the evaluation steps."
            ]
        },
        "bint5": {
            "summary": "Initializes an event-driven daemon that monitors input device events , processes them , and logs relevant actions accordingly .\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary claims the code initializes an event-driven daemon that monitors input device events and logs actions, but the source code shows a main function for what appears to be a line-editing or file-handling program: it initializes buffers, duplicates a filename argument, reads file lines, sets a current line number, and runs commands. None of these operations pertain to event-driven daemons or input device monitoring. All claims are inaccurate.",
                "The summary inaccurately states that the code initializes an event-driven daemon monitoring input device events and logging actions, which is not reflected in the source. The actual code initializes buffers, sets up linked list pointers, optionally loads a file, sets state variables, and runs commands before exiting. It misses the primary purpose entirely and introduces unrelated behavior, so there is no accurate claim coverage.",
                "The summary's claim that the code initializes an event-driven daemon for monitoring input device events and logging actions is entirely inaccurate. The source code instead initializes buffers, reads lines from a file if provided, and processes commands. This is a FATAL error about the primary purpose, as it misidentifies the core function of the program, leading to a complete mismatch with actual I/O and logic."
            ]
        },
        "cpbcs": {
            "summary": "Initializes a new peer structure with an identifier and associated info and allocates a new file descriptor.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about initializing a peer structure, assigning an identifier, associating info, and allocating a file descriptor do not align with the source code, which initializes editing buffers, reads a file if provided, and processes commands. None of the atomic claims match the actual implementation, leading to zero accurate claims.",
                "The summary describes initializing a peer structure with an identifier and allocating a file descriptor, which does not match the source code's actual behavior. The function in the source initializes buffer structures, sets up linked list pointers, optionally loads a file's lines, and then processes commands. The summary misses the primary purpose entirely and introduces unrelated concepts, making the claims inaccurate and providing no coverage of the actual semantics.",
                "The summary contains entirely inaccurate statements. The source code does not initialize a 'peer structure', assign an identifier, associate info, or allocate a file descriptor. Instead, it initializes buffers, optionally reads a file from argv[1], and processes commands. These mismatches are fatal because they misstate the primary purpose and key operations, leading to high negative impact."
            ]
        },
        "misum": {
            "summary": "Allocates and initializes a new mount structure, setting its properties and registering the provided file stream with those handling.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims that the function allocates and initializes a new mount structure, sets its properties, and registers a provided file stream, but the source code shows initialization of buffers, setting linked list pointers, optionally reading lines from a file, setting flags, and running commands. None of the atomic claims in the summary match the semantics of the source code, resulting in no accurate claims.",
                "The summary describes allocating and initializing a mount structure and registering a file stream, which contradicts the actual source code. The code initializes editor buffers, handles optional file loading, and processes commands. None of the described actions in the summary match the function's primary purpose or secondary behaviors, resulting in no accurate claims and no coverage of critical semantic units.",
                "The summary claims the function allocates and initializes a mount structure, sets its properties, and registers a file stream. This is completely inaccurate: the source code initializes buffers, sets up a linked list, handles an optional filename by reading lines from it, and processes commands. The claim targets code semantics but describes a different purpose and entities, making it a FATAL error affecting the primary purpose. There are no accurate claims, so the net benefit is zero."
            ]
        }
    }
}
{
    "project_name": "gmp",
    "function_addr": 344960,
    "strip_function_name": "sub_54380",
    "strip_decompiled_code": "__int64 __fastcall sub_54380(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v8; // r12\n  __int64 v9; // r14\n  __int64 v10; // rbx\n  __int64 v11; // r8\n  __int64 v12; // rax\n  __int64 v13; // rbp\n  __int64 v14; // r11\n  __int64 v18; // [rsp+20h] [rbp-48h]\n\n  v8 = a2;\n  v9 = a4;\n  if ( a4 > 165 )\n  {\n    do\n    {\n      v10 = v9 >> 1;\n      v13 = v9 - (v9 >> 1);\n      v18 = __gmpn_dcpi1_bdiv_qr_n(a1, v8, a3, v9 >> 1, a5, a6);\n      __gmpn_mullo_n(a6, a1, a3 + 8 * v13, v9 >> 1);\n      __gmpn_add_n(v8 + 8 * v13, v8 + 8 * v13, a6, v9 >> 1);\n      v11 = 8 * (v9 >> 1);\n      v14 = v8 + v11;\n      if ( v9 >> 1 < v13 )\n      {\n        v12 = __gmpn_addmul_1(v8 + 8 * v10, a1, v9 >> 1, *(_QWORD *)(a3 + 8 * v10));\n        v11 = 8 * v10;\n        v14 = v8 + 8 * v10;\n        *(_QWORD *)(v8 + 8 * v9 - 8) += v18 + v12;\n      }\n      a1 += v11;\n      v8 = v14;\n      v9 -= v9 >> 1;\n    }\n    while ( v13 > 165 );\n  }\n  else\n  {\n    v13 = a4;\n    v14 = a2;\n  }\n  return __gmpn_sbpi1_bdiv_q(a1, v14, v13, a3, v13, a5);\n}\n",
    "function_name": "mpn_dcpi1_bdiv_q_n",
    "decompiled_code": "void __fastcall mpn_dcpi1_bdiv_q_n(mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)\n{\n  mp_size_t v9; // r14\n  __int64 v10; // rbx\n  __int64 v11; // rbp\n  __int64 v12; // r8\n  mp_limb_t *v13; // r11\n  __int64 v14; // rax\n  __int64 v17; // [rsp+88h] [rbp+20h]\n\n  v9 = n;\n  if ( n > 165 )\n  {\n    do\n    {\n      v10 = v9 >> 1;\n      v11 = v9 - (v9 >> 1);\n      v17 = ((__int64 (__fastcall *)(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr))__gmpn_dcpi1_bdiv_qr_n)(\n              qp,\n              np,\n              dp,\n              v9 >> 1,\n              dinv,\n              tp);\n      ((void (__fastcall *)(mp_ptr, mp_ptr, const mp_limb_t *, mp_size_t))__gmpn_mullo_n)(tp, qp, &dp[v11], v9 >> 1);\n      ((void (__fastcall *)(mp_limb_t *, mp_limb_t *, mp_ptr, mp_size_t))__gmpn_add_n)(&np[v11], &np[v11], tp, v9 >> 1);\n      v12 = v9 >> 1;\n      v13 = &np[v12];\n      if ( v9 >> 1 < v11 )\n      {\n        v14 = ((__int64 (__fastcall *)(mp_limb_t *, mp_ptr, mp_size_t, const mp_limb_t))__gmpn_addmul_1)(\n                &np[v10],\n                qp,\n                v9 >> 1,\n                dp[v10]);\n        v12 = v10;\n        v13 = &np[v10];\n        np[v9 - 1] += v17 + v14;\n      }\n      qp = (mp_ptr)((char *)qp + v12 * 8);\n      np = v13;\n      v9 -= v9 >> 1;\n    }\n    while ( v11 > 165 );\n  }\n  JUMPOUT(0xB6E0LL);\n}\n",
    "source_code": "\nstatic void\nmpn_dcpi1_bdiv_q_n (mp_ptr qp,\n\t\t    mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t    mp_limb_t dinv, mp_ptr tp)\n{\n  while (ABOVE_THRESHOLD (n, DC_BDIV_Q_THRESHOLD))\n    {\n      mp_size_t lo, hi;\n      mp_limb_t cy;\n\n      lo = n >> 1;\t\t\t/* floor(n/2) */\n      hi = n - lo;\t\t\t/* ceil(n/2) */\n\n      cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, lo, dinv, tp);\n\n      mpn_mullo_n (tp, qp, dp + hi, lo);\n      mpn_add_n (np + hi, np + hi, tp, lo);\n\n      if (lo < hi)\n\t{\n\t  cy += mpn_addmul_1 (np + lo, qp, lo, dp[lo]);\n\t  np[n - 1] += cy;\n\t}\n      qp += lo;\n      np += lo;\n      n -= lo;\n    }\n  mpn_sbpi1_bdiv_q (qp, np, n, dp, n, dinv);\n}",
    "comment": "Divides a multi-precision number by another using a divide-and-conquer approach, updating quotient and remainder for large input sizes.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Computes the quotient and remainder of the division of ` a ` and ` b ` raised to ` x ` , storing the result in ` r ` .\n",
    "cpbcs_sum": "Adds two multi-precision integers represented by the first set of two base integers using the iterative function.\n",
    "misum_sum": "Calculates the product of two multi-precision integers using division approximation and stores the result in `rp` storing the result in `rp`\n",
    "decom_sum": "Performs multi-precision division of large integers using a divide-and-conquer algorithm with GMP's dcpi1 and sbpi1 division routines.",
    "cfg_sum": "Performs recursive multi-precision division using GMP algorithms, adjusting operands and combining partial results to produce a final quotient and remainder.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' does not accurately describe the source code's behavior. The function shown performs a divide-and-conquer division operation on multi-precision numbers, with no apparent operation matching 'push a pointer type.' This makes the claim irrelevant to the implementation and thus inaccurate.",
                "The summary 'push a pointer type' is vague, does not reference the function\u2019s primary purpose of performing a recursive division operation when above a threshold, and fails to capture any specific implementation details from the source code such as handling of lo/hi splits, use of mpn_mullo_n, mpn_add_n, conditional addmul, or the final call to mpn_sbpi1_bdiv_q. It is unrelated to the core semantics and therefore provides no accurate coverage.",
                "The summary contains only a vague phrase ('push a pointer type') that does not map to the source code's actual functionality of performing a division algorithm using recursive splitting and multiple GMP functions. This is NOISE with no specific, accurate detail. Since all claims are low-info and unrelated to code semantics, there is no positive gain."
            ]
        },
        "bint5": {
            "summary": "Computes the quotient and remainder of the division of ` a ` and ` b ` raised to ` x ` , storing the result in ` r ` .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim about computing the quotient and remainder of 'a' and 'b' raised to 'x' bears no relation to the source code. The function in the source implements a recursive division algorithm for multi-precision integers but does not involve exponentiation, specific variables 'a' or 'b', or store results in 'r'. All claims are inaccurate, yielding no alignment with the code semantics.",
                "The summary is inaccurate because it describes computing the quotient and remainder of `a` and `b` raised to `x`, which does not match the source code. The function in the source performs a divide-and-conquer division algorithm (`bdiv_q_n`) on multi-precision numbers using specific limb operations, without any exponentiation or storing results in `r`. This misses the primary purpose entirely and adds unrelated operations.",
                "The summary makes a specific claim that the function computes the quotient and remainder of `a` and `b` raised to `x`, storing the result in `r`. This is a semantic description of the core purpose, but it is entirely inaccurate for the given source code. The actual code is an internal GMP function for division of multi-precision numbers using a divide-and-conquer algorithm on limb arrays, with no exponentiation or simple `a`/`b` variables. This is a FATAL error on the primary purpose, leading to high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Adds two multi-precision integers represented by the first set of two base integers using the iterative function.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as adding two multi-precision integers from two base integers, which contradicts the source code. The source code implements an iterative division algorithm (`mpn_dcpi1_bdiv_q_n`) for multi-precision numbers, involving division, multiplication, and addition steps as part of the algorithm, not a simple addition of two integers. None of the claims in the summary accurately match the function's actual purpose or semantics.",
                "The summary is inaccurate because it describes the function as adding two multi-precision integers, which misses the primary purpose of the source code \u2014 performing a recursive divide-and-conquer division (bdiv) operation to compute quotient limbs using other GMP routines. It does not mention key behaviors like threshold-based recursion, splitting inputs, multiplication, addition, carry handling, or the final call to the subroutine mpn_sbpi1_bdiv_q. This fails to capture both the primary purpose and secondary details.",
                "The summary claims the function adds two multi-precision integers, which is inaccurate. The source code implements a division quotient algorithm (bdiv) using divide-and-conquer strategies, calling helper functions for quotient/remainder computation, multiplication, and addition/multiplication adjustments. This is a FATAL error since it misstates the primary purpose and I/O behavior of the function. The claim contains no accurate or useful specifics aligned with the code, resulting in zero net benefit."
            ]
        },
        "misum": {
            "summary": "Calculates the product of two multi-precision integers using division approximation and stores the result in `rp` storing the result in `rp`\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function calculates a product of two multi-precision integers and stores the result in `rp`, but the source code shows a divide-and-conquer division with quotient computation (`mpn_dcpi1_bdiv_q_n`) involving multiple intermediate steps, and there is no `rp` variable present. This is a direct semantic mismatch, with all claims being inaccurate and unrelated to the actual function purpose.",
                "The summary incorrectly states that the function calculates the product of two multi-precision integers, whereas the source code implements a division algorithm (`mpn_dcpi1_bdiv_q_n`) using a recursive approach with thresholds, partial quotient calculations, multiplication of partial results, and addition to update the numerator. It also references an `rp` variable which does not exist in the source code. This misses the primary purpose and most secondary details, and contains factual inaccuracies.",
                "The summary claims the function calculates the product of two multi-precision integers using division approximation and stores the result in `rp`. This is inaccurate: the source implements a division algorithm (`mpn_dcpi1_bdiv_q_n`) to compute a quotient (`qp`) using recursive splitting, not a product, and there is no parameter `rp` in the function signature. The core purpose is misrepresented, which is a FATAL error affecting the primary purpose, yielding high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580562848,
    "strip_function_name": "sub_FFFFFFFF811A35A0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811A35A0(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        __int16 a3,\n        __int64 a4,\n        __int64 a5,\n        volatile signed __int32 **a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  unsigned __int64 v16; // rax\n  volatile signed __int32 *v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r12d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // rdx\n  __int64 v24; // rcx\n  int v25; // r8d\n  int v26; // r9d\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  __int64 result; // rax\n  signed __int32 v30; // et0\n  volatile signed __int32 *v32[7]; // [rsp+8h] [rbp-38h] BYREF\n\n  v16 = sub_FFFFFFFF811A3160(a5, 16877, 1, a7, a8, a9, a10, a11, a12, a13, a14);\n  if ( !v16 )\n    return 4294967284LL;\n  *(_WORD *)(v16 + 96) |= a3 << 8;\n  *(_QWORD *)(v16 + 72) = a1;\n  v17 = (volatile signed __int32 *)v16;\n  v32[1] = 0LL;\n  v32[0] = a2;\n  *(_QWORD *)(v16 + 56) = a4;\n  sub_FFFFFFFF8178F210(&unk_FFFFFFFF81C41440);\n  v20 = sub_FFFFFFFF811A33A0(v32, (__int64)v17, a7, a8, a9, a10, v18, v19, a13, a14);\n  sub_FFFFFFFF811A34E0((__int64)v32, (__int64)v17, a7, a8, a9, a10, v21, v22, a13, a14);\n  if ( v20 )\n  {\n    v30 = _InterlockedDecrement(v17);\n    LOBYTE(v23) = v30 == 0;\n    result = v20;\n    if ( !v30 )\n    {\n      sub_FFFFFFFF811A2C80((unsigned __int64)v17, (__int64)v17, v23, v24, v25, v26, a7, a8, a9, a10, v27, v28, a13, a14);\n      return v20;\n    }\n  }\n  else\n  {\n    *a6 = v17;\n    return 0LL;\n  }\n  return result;\n}\n",
    "function_name": "create_dir",
    "decompiled_code": "__int64 __fastcall create_dir(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        __int16 a3,\n        __int64 a4,\n        __int64 *a5,\n        volatile signed __int32 **a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13,\n        double a14)\n{\n  __int64 *v16; // rax\n  volatile signed __int32 *v17; // rbx\n  double v18; // xmm4_8\n  double v19; // xmm5_8\n  unsigned int v20; // r12d\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 *v23; // rdx\n  __int64 v24; // rcx\n  int v25; // r8d\n  int v26; // r9d\n  double v27; // xmm4_8\n  double v28; // xmm5_8\n  __int64 result; // rax\n  signed __int32 v30; // et0\n  volatile signed __int32 *v32[7]; // [rsp+8h] [rbp-38h] BYREF\n\n  v16 = sysfs_new_dirent(a5, 16877, 1, a7, a8, a9, a10, a11, a12, a13, a14);\n  if ( !v16 )\n    return 4294967284LL;\n  *((_WORD *)v16 + 48) |= a3 << 8;\n  v16[9] = a1;\n  v17 = (volatile signed __int32 *)v16;\n  v32[1] = 0LL;\n  v32[0] = a2;\n  v16[7] = a4;\n  mutex_lock((__int64)&sysfs_mutex);\n  v20 = sysfs_add_one(v32, (__int64)v17, a7, a8, a9, a10, v18, v19, a13, a14);\n  sysfs_addrm_finish((__int64)v32, (__int64)v17, a7, a8, a9, a10, v21, v22, a13, a14);\n  if ( v20 )\n  {\n    v30 = _InterlockedDecrement(v17);\n    LOBYTE(v23) = v30 == 0;\n    result = v20;\n    if ( !v30 )\n    {\n      release_sysfs_dirent((__int64)v17, (__int64)v17, v23, v24, v25, v26, a7, a8, a9, a10, v27, v28, a13, a14);\n      return v20;\n    }\n  }\n  else\n  {\n    *a6 = v17;\n    return 0LL;\n  }\n  return result;\n}\n",
    "source_code": "\nstatic int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,\n\tenum kobj_ns_type type, const void *ns, const char *name,\n\tstruct sysfs_dirent **p_sd)\n{\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct sysfs_addrm_cxt acxt;\n\tstruct sysfs_dirent *sd;\n\tint rc;\n\n\t/* allocate */\n\tsd = sysfs_new_dirent(name, mode, SYSFS_DIR);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\n\tsd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);\n\tsd->s_ns = ns;\n\tsd->s_dir.kobj = kobj;\n\n\t/* link in */\n\tsysfs_addrm_start(&acxt, parent_sd);\n\trc = sysfs_add_one(&acxt, sd);\n\tsysfs_addrm_finish(&acxt);\n\n\tif (rc == 0)\n\t\t*p_sd = sd;\n\telse\n\t\tsysfs_put(sd);\n\n\treturn rc;\n}",
    "comment": "Creates a directory entry in a configuration filesystem, ensuring it does not already exist and managing reference counts for the parent directory.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Renames a sysfs directory entry by updating its name , parent , and namespace , ensuring no conflicts with existing entries .\n",
    "cpbcs_sum": "Adds a new mount to a specified namespace, creating a sysfs directory if successful, and ensures the directory is properly marked as needed.\n",
    "misum_sum": "Creates and registers an inode for a specified device with specified attributes and device index, handling errors during the process.\n",
    "decom_sum": "Initializes a structure with provided parameters, processes it through two setup routines, and returns it via output pointer or cleans up on error.",
    "cfg_sum": "Initializes and configures a data structure with provided parameters, validates through processing functions, atomically updates reference counts, and returns success or specific error codes.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.1,
                0.4
            ],
            "reason": [
                "The summary makes a vague statement about 'pushing a pointer type' that does not correspond to any specific or clear action in the source code. The function is about creating and linking a sysfs directory, handling struct pointers, but the phrasing neither specifically matches the code's operations nor conveys accurate semantics. This is effectively noise, making the proportion of accurate claims 0%.",
                "The summary is extremely vague and does not reflect the primary purpose of the function, which is to create and link a sysfs directory entry with specific attributes and error handling. It makes no mention of the directory creation, mode settings, namespace handling, linking, or cleanup, thus missing both the primary purpose and all secondary details.",
                "The summary contains only the vague phrase 'push a pointer type', which is not grounded in the actual code functionality. It does not accurately describe the function's behavior of creating and linking a sysfs directory entry, making this a NOISE claim. There are no accurate details, and the lack of relevant information yields low net benefit due to overwhelming NOISE."
            ]
        },
        "bint5": {
            "summary": "Renames a sysfs directory entry by updating its name , parent , and namespace , ensuring no conflicts with existing entries .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function renames a sysfs directory entry by updating its name, parent, and namespace to avoid conflicts, but the source code shows it creates a new sysfs directory entry with a given name, namespace, and parent, not performing a rename or handling name conflict detection explicitly. All key elements in the summary (rename, conflict checking) contradict the actual semantics, making the claims inaccurate.",
                "The summary incorrectly states that the function renames a sysfs directory entry by updating its name, parent, and namespace, which contradicts the source code. The actual implementation creates a new sysfs directory entry with specified attributes, sets its flags and namespace, links it to the parent, and handles errors. The PRIMARY PURPOSE of creation is completely missed, resulting in no accurate claims and no coverage of secondary details.",
                "The summary claims that the function renames a sysfs directory entry by updating its name, parent, and namespace to avoid conflicts. This is inaccurate \u2014 the source code creates a new directory entry with a fixed mode and links it, setting its namespace and type, but does not perform any renaming or conflict-check logic. This is a FATAL error regarding the primary purpose and semantics of the function, leading to a high negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Adds a new mount to a specified namespace, creating a sysfs directory if successful, and ensures the directory is properly marked as needed.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function adds a new mount to a specified namespace, which is inaccurate because the source code creates a directory entry in sysfs rather than handling mounts. While it correctly mentions creating a sysfs directory and marking it, this is tied to storing namespace/type data in the dirent, not related to mounting. Most claims are inaccurate, with accurate details being minimal.",
                "The summary incorrectly states the function adds a new mount to a namespace, which contradicts the source code\u2019s primary purpose of creating and linking a sysfs directory entry. While it mentions creating a sysfs directory, it misrepresents the context as mounting, and omits key secondary details such as permission modes, namespace handling, error handling with -ENOMEM, and cleanup via sysfs_put on failure.",
                "The summary incorrectly claims the function adds a new mount, which is a FATAL error since the source code's primary purpose is creating a sysfs directory entry in a specified namespace, not mounting a filesystem. While it mentions creating a sysfs directory and marking it, the inaccurate mount-related statement directly misrepresents key I/O semantics, making the summary unreliable despite containing minor accurate elements."
            ]
        },
        "misum": {
            "summary": "Creates and registers an inode for a specified device with specified attributes and device index, handling errors during the process.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims that the function creates and registers an inode for a specified device with specific attributes and device index, which is inaccurate. The code instead creates a sysfs directory entry (not a device inode), sets namespace type and pointer, associates it with a kobject, and links it into the sysfs hierarchy. There is no mention of device index or registering an inode. The only accurate part is that it handles errors during the process. Overall, most claims are inaccurate relative to the source code.",
                "The summary incorrectly describes the function as creating and registering an inode for a device with specific attributes and index, which is inaccurate. The source code shows that the function creates a sysfs directory entry for a kobject with given namespace data, sets permissions, links it into the sysfs hierarchy, and handles errors if allocation or addition fails. The summary misses the primary purpose (creation of sysfs directory entry for a kobject) and introduces incorrect elements (device-specific inode, attributes, device index) not present in the code.",
                "The summary claims the function creates and registers an inode for a specified device with attributes and device index, but the source code shows it creates a sysfs directory entry linked to a kobject, not specifically an inode for a device nor involving a device index. This is a semantic mismatch targeting the function's primary purpose, making it a FATAL error. There are no accurate, high-value details to offset the inaccuracy."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071582126582,
    "strip_function_name": "sub_FFFFFFFF813211F6",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813211F6(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  __int64 result; // rax\n  char v12; // r13\n  unsigned int v13; // ebx\n  __int64 v14; // rdx\n  unsigned int v15; // r12d\n  __int64 v16; // rax\n  __int64 v17; // r14\n  __int64 v18; // r14\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned int v21; // eax\n  __int64 v22; // rdx\n\n  result = 4097LL;\n  if ( a1 )\n  {\n    result = 8LL;\n    v12 = *(_BYTE *)(a1 + 11);\n    if ( v12 )\n    {\n      result = sub_FFFFFFFF81323698(0LL, a2, a3);\n      v13 = result;\n      if ( !(_DWORD)result )\n      {\n        v14 = qword_FFFFFFFF81E9EC20;\n        v15 = 0;\n        v16 = qword_FFFFFFFF81E9EC20;\n        while ( v15 != dword_FFFFFFFF81E9EC28 )\n        {\n          v17 = v16;\n          a2 = v16;\n          v16 += 32LL;\n          v18 = v17 - qword_FFFFFFFF81E9EC20;\n          if ( v12 == *(_BYTE *)(v16 - 8) )\n          {\n            v13 = 8;\n            if ( *(_DWORD *)(a2 + 20) != 1413763908 )\n            {\n              v13 = 6;\n              if ( sub_FFFFFFFF8132088D(v15, a2, qword_FFFFFFFF81E9EC20) )\n              {\n                if ( qword_FFFFFFFF81E9E9D8 )\n                {\n                  a2 = *(_QWORD *)(qword_FFFFFFFF81E9EC20 + v18 + 8);\n                  qword_FFFFFFFF81E9E9D8(1LL, a2, qword_FFFFFFFF81E9E9D0);\n                }\n                v13 = sub_FFFFFFFF81320720(v15, a2, v14, a4, a5, a6, a7, v19, v20, a10, a11);\n                if ( !v13 )\n                {\n                  v21 = sub_FFFFFFFF813207F2(v15, a2, v14);\n                  a2 = 0LL;\n                  v13 = v21;\n                  sub_FFFFFFFF813208D0(v15, 0LL, v22);\n                }\n              }\n            }\n            break;\n          }\n          ++v15;\n        }\n        sub_FFFFFFFF8132371B(0LL, a2, v14);\n        return v13;\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "acpi_unload_parent_table",
    "decompiled_code": "__int64 __fastcall acpi_unload_parent_table(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  char v11; // r13\n  int v12; // r8d\n  int v13; // r9d\n  unsigned int v14; // ebx\n  __int64 v15; // rdx\n  __int64 v16; // rcx\n  unsigned int v17; // r12d\n  __int64 v18; // rax\n  __int64 v19; // r14\n  __int64 v20; // r14\n  double v21; // xmm4_8\n  double v22; // xmm5_8\n  unsigned int v23; // eax\n\n  result = 4097LL;\n  if ( a1 )\n  {\n    result = 8LL;\n    v11 = *(_BYTE *)(a1 + 11);\n    if ( v11 )\n    {\n      result = acpi_ut_acquire_mutex(0);\n      v14 = result;\n      if ( !(_DWORD)result )\n      {\n        v15 = acpi_gbl_root_table_list;\n        v16 = (unsigned int)dword_FFFFFFFF81E9EC28;\n        v17 = 0;\n        v18 = acpi_gbl_root_table_list;\n        while ( v17 != dword_FFFFFFFF81E9EC28 )\n        {\n          v19 = v18;\n          a2 = v18;\n          v18 += 32LL;\n          v20 = v19 - acpi_gbl_root_table_list;\n          if ( v11 == *(_BYTE *)(v18 - 8) )\n          {\n            v14 = 8;\n            if ( *(_DWORD *)(a2 + 20) != 1413763908 )\n            {\n              v14 = 6;\n              if ( acpi_tb_is_table_loaded(v17, a2) )\n              {\n                if ( acpi_gbl_table_handler )\n                {\n                  a2 = *(_QWORD *)(acpi_gbl_root_table_list + v20 + 8);\n                  a3 = acpi_gbl_table_handler(1LL, a2, acpi_gbl_table_handler_context);\n                }\n                v14 = acpi_tb_delete_namespace_by_owner(v17, a2, a3, a4, a5, a6, v21, v22, a9, a10);\n                if ( !v14 )\n                {\n                  v23 = acpi_tb_release_owner_id(v17, a2);\n                  a2 = 0LL;\n                  v14 = v23;\n                  acpi_tb_set_table_loaded_flag(v17, 0LL);\n                }\n              }\n            }\n            break;\n          }\n          ++v17;\n        }\n        acpi_ut_release_mutex(0, a2, v15, v16, v12, v13);\n        return v14;\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "acpi_status acpi_unload_parent_table(acpi_handle object)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, object);\n\tacpi_status status = AE_NOT_EXIST;\n\tacpi_owner_id owner_id;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_unload_parent_table);\n\n\t/* Parameter validation */\n\n\tif (!object) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t/*\n\t * The node owner_id is currently the same as the parent table ID.\n\t * However, this could change in the future.\n\t */\n\towner_id = node->owner_id;\n\tif (!owner_id) {\n\n\t\t/* owner_id==0 means DSDT is the owner. DSDT cannot be unloaded */\n\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t/* Must acquire the interpreter lock during this operation */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Find the table in the global table list */\n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\tif (owner_id != acpi_gbl_root_table_list.tables[i].owner_id) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Allow unload of SSDT and OEMx tables only. Do not allow unload\n\t\t * of the DSDT. No other types of tables should get here, since\n\t\t * only these types can contain AML and thus are the only types\n\t\t * that can create namespace objects.\n\t\t */\n\t\tif (ACPI_COMPARE_NAME\n\t\t    (acpi_gbl_root_table_list.tables[i].signature.ascii,\n\t\t     ACPI_SIG_DSDT)) {\n\t\t\tstatus = AE_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Ensure the table is actually loaded */\n\n\t\tif (!acpi_tb_is_table_loaded(i)) {\n\t\t\tstatus = AE_NOT_EXIST;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Invoke table handler if present */\n\n\t\tif (acpi_gbl_table_handler) {\n\t\t\t(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,\n\t\t\t\t\t\t     acpi_gbl_root_table_list.\n\t\t\t\t\t\t     tables[i].pointer,\n\t\t\t\t\t\t     acpi_gbl_table_handler_context);\n\t\t}\n\n\t\t/*\n\t\t * Delete all namespace objects owned by this table. Note that\n\t\t * these objects can appear anywhere in the namespace by virtue\n\t\t * of the AML \"Scope\" operator. Thus, we need to track ownership\n\t\t * by an ID, not simply a position within the hierarchy.\n\t\t */\n\t\tstatus = acpi_tb_delete_namespace_by_owner(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = acpi_tb_release_owner_id(i);\n\t\tacpi_tb_set_table_loaded_flag(i, FALSE);\n\t\tbreak;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\n\treturn_ACPI_STATUS(status);\n}",
    "comment": "Unloads ACPI tables by deleting namespace objects and calling the table handler, ensuring conditions to prevent unloading the DSDT are met.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Registers a new interface or reactivates an invalid one in the global list , ensuring unique interface names while managing mutexes and synchronization .\n",
    "cpbcs_sum": "Deletes a specified table from the ACPI table list, ensuring no duplicate tables exist.\n",
    "misum_sum": "Checks for active thermal trip points and manages state changes in the ACPI namespace, ensuring proper state management.\n",
    "decom_sum": "Processes an entry matching a specific byte ID from a global list, invokes related callbacks, and performs further parameterized operations before returning a status code.",
    "cfg_sum": "Processes a structure identified by a specific byte, validates and updates matching entries, triggers callbacks, and executes related operations, returning the final status code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains only a vague remark about pushing a pointer type, which does not accurately or specifically reflect the function's logic or purpose in the source code. It fails to describe the unloading process, parameter validation, table checks, or lock handling, making it unrelated to the actual semantics.",
                "The summary only states 'push a pointer type,' which does not describe the primary purpose of the function or any of its observable behaviors. It fails to identify that the function unloads a parent ACPI table, performs parameter validation, checks owner IDs, handles locking, and processes specific table types. No accurate claims are made that align with the source code semantics.",
                "The summary \"push a pointer type\" is vague and unrelated to the actual function, which unloads an ACPI parent table after multiple validations, mutex acquisition, table checks, and namespace object deletions. This is pure NOISE with no accurate or useful claims about the source code, offering no insight or force multipliers for understanding."
            ]
        },
        "bint5": {
            "summary": "Registers a new interface or reactivates an invalid one in the global list , ensuring unique interface names while managing mutexes and synchronization .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes registering or reactivating an interface with unique name enforcement and mutex handling, which does not match the source code. The actual function unloads a parent ACPI table, checks parameters, prevents unloading certain tables, manages mutex locking, and handles namespace cleanup. None of the claims in the summary match the function's purpose or details, making them inaccurate.",
                "The summary is entirely inaccurate: it describes registering or reactivating interfaces and ensuring unique names, which is unrelated to the source code's actual purpose of unloading a parent ACPI table, validating parameters, preventing unload of DSDT, managing interpreter mutex, and handling table removal. It misses the primary purpose and all secondary details from the code.",
                "The summary is entirely inaccurate, describing an interface registration/reactivation process with unique names, which is unrelated to the actual code. The source function unloads a parent ACPI table, validates parameters, ensures certain tables cannot be unloaded, manages interpreter mutexes, and deletes namespace objects. This misrepresentation targets the primary purpose and key side effects, making it a FATAL error."
            ]
        },
        "cpbcs": {
            "summary": "Deletes a specified table from the ACPI table list, ensuring no duplicate tables exist.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function deletes a specified table from the ACPI table list and ensures no duplicate tables exist. While the function does unload a table matching a given owner_id and releases resources, there is no logic in the source code that checks for or ensures absence of duplicate tables. This means part of the claim is inaccurate, resulting in less than half of the claims matching the actual code behavior.",
                "The summary generically states that the function deletes a specified table from the ACPI table list and ensures no duplicate tables exist, but this is inaccurate. The source code shows the function unloads a parent table associated with a namespace node, with checks for null parameters, DSDT type, table load state, invoking handlers, deleting namespace objects, and managing locks. There is no logic about preventing duplicates, and key details such as DSDT protection, mutex acquisition, and namespace/object deletion are omitted, meaning the primary purpose is partially missed and secondary details are entirely absent.",
                "The summary claims the function deletes a specified table from the ACPI table list and ensures no duplicate tables exist. The first part is somewhat aligned since the function can unload certain ACPI tables after validations, but it omits important constraints, such as prohibiting DSDT unload and only supporting certain table types. The 'ensuring no duplicate tables exist' claim is unsupported and inaccurate, as the code performs no such duplication check\u2014this is a FATAL inaccuracy regarding function purpose. This misrepresentation of the primary function leads to low reliability."
            ]
        },
        "misum": {
            "summary": "Checks for active thermal trip points and manages state changes in the ACPI namespace, ensuring proper state management.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about active thermal trip points and ACPI namespace state management do not match the source code, which deals with unloading a parent ACPI table, validating parameters, preventing DSDT unload, acquiring a mutex, processing table handlers, and deleting namespace objects by owner ID. None of the claims accurately reflect the function's actual semantics, resulting in 0% accurate claims.",
                "The summary does not align with the source code at all. The function is for unloading the parent ACPI table associated with a given object, handling parameter validation, DSDT restrictions, mutex acquisition, table lookup, unload permissions, and namespace cleanup. The provided summary mentions thermal trip points and state changes, which are unrelated to the actual primary purpose or secondary details of the function.",
                "The summary\u2019s claim about checking active thermal trip points and managing state changes in the ACPI namespace is entirely inaccurate relative to the source code. The source function unloads a parent ACPI table, validates parameters, enforces restrictions on unloading certain tables, and releases related resources. There is no thermal trip point handling or generic state management logic as described. This is a FATAL error affecting the primary purpose, making the summary unreliable."
            ]
        }
    }
}
{
    "project_name": "bash",
    "function_addr": 823136,
    "strip_function_name": "_rl_dispatch_callback",
    "strip_decompiled_code": "__int64 __fastcall rl_dispatch_callback(__int64 a1)\n{\n  unsigned int v2; // edi\n  int v4; // ebp\n  __int64 v5; // rdi\n  int v6; // eax\n  unsigned int v7; // eax\n\n  if ( (*(_BYTE *)a1 & 1) != 0 )\n  {\n    v2 = *(_DWORD *)(a1 + 40);\n  }\n  else\n  {\n    v6 = sub_C7CE0(*(_DWORD *)(a1 + 12));\n    if ( v6 < 0 )\n      rl_abort_internal();\n    v7 = rl_dispatch_subseq((unsigned int)v6, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 4));\n    *(_DWORD *)a1 |= 1u;\n    v2 = v7;\n  }\n  if ( v2 == -3 )\n  {\n    if ( rl_caught_signal )\n      rl_signal_handler((unsigned int)rl_caught_signal);\n    goto LABEL_6;\n  }\n  v4 = sub_C8DB0(v2, *(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 12), *(_DWORD *)a1 & 2);\n  if ( rl_caught_signal )\n    rl_signal_handler((unsigned int)rl_caught_signal);\n  if ( v4 >= 0 )\n    goto LABEL_28;\n  if ( v4 != -1 )\n  {\n    if ( v4 == -3 )\n    {\nLABEL_6:\n      if ( rl_kscxt )\n        *(_DWORD *)(rl_kscxt + 40) = -3;\n      return 4294967293LL;\n    }\n    goto LABEL_21;\n  }\n  if ( (*(_BYTE *)a1 & 2) == 0 )\n  {\nLABEL_28:\n    while ( 1 )\n    {\n      v5 = rl_kscxt;\n      if ( !rl_kscxt )\n        break;\n      rl_kscxt = *(_QWORD *)(rl_kscxt + 32);\n      xfree(v5);\n    }\n    rl_readline_state &= ~0x200000uLL;\n    return (unsigned int)v4;\n  }\nLABEL_21:\n  rl_kscxt = *(_QWORD *)(a1 + 32);\n  if ( rl_kscxt )\n    *(_DWORD *)(rl_kscxt + 40) = v4;\n  xfree(a1);\n  return (unsigned int)v4;\n}\n",
    "function_name": "_rl_dispatch_callback",
    "decompiled_code": "int __fastcall rl_dispatch_callback(_rl_keyseq_cxt *cxt)\n{\n  int childval; // edi\n  int v4; // ebp\n  _rl_keyseq_cxt *v5; // rdi\n  int v6; // eax\n  int v7; // eax\n\n  if ( (cxt->flags & 1) != 0 )\n  {\n    childval = cxt->childval;\n  }\n  else\n  {\n    v6 = rl_subseq_getchar(cxt->okey);\n    if ( v6 < 0 )\n      rl_abort_internal();\n    v7 = rl_dispatch_subseq(v6, cxt->dmap, cxt->subseq_arg);\n    cxt->flags |= 1u;\n    childval = v7;\n  }\n  if ( childval == -3 )\n  {\n    if ( rl_caught_signal )\n      rl_signal_handler(rl_caught_signal);\n    goto LABEL_6;\n  }\n  v4 = rl_subseq_result(childval, cxt->oldmap, cxt->okey, cxt->flags & 2);\n  if ( rl_caught_signal )\n    rl_signal_handler(rl_caught_signal);\n  if ( v4 >= 0 )\n    goto LABEL_28;\n  if ( v4 != -1 )\n  {\n    if ( v4 == -3 )\n    {\nLABEL_6:\n      if ( rl_kscxt )\n        rl_kscxt->childval = -3;\n      return -3;\n    }\n    goto LABEL_21;\n  }\n  if ( (cxt->flags & 2) == 0 )\n  {\nLABEL_28:\n    while ( 1 )\n    {\n      v5 = rl_kscxt;\n      if ( !rl_kscxt )\n        break;\n      rl_kscxt = rl_kscxt->ocxt;\n      xfree(v5);\n    }\n    rl_readline_state &= ~0x200000uLL;\n    return v4;\n  }\nLABEL_21:\n  rl_kscxt = cxt->ocxt;\n  if ( rl_kscxt )\n    rl_kscxt->childval = v4;\n  xfree(cxt);\n  return v4;\n}\n",
    "source_code": "int\n_rl_dispatch_callback (_rl_keyseq_cxt *cxt)\n{\n  int nkey, r;\n\n  /* For now */\n  /* The first time this context is used, we want to read input and dispatch\n     on it.  When traversing the chain of contexts back `up', we want to use\n     the value from the next context down.  We're simulating recursion using\n     a chain of contexts. */\n  if ((cxt->flags & KSEQ_DISPATCHED) == 0)\n    {\n      nkey = _rl_subseq_getchar (cxt->okey);\n      if (nkey < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);\n      cxt->flags |= KSEQ_DISPATCHED;\n    }\n  else\n    r = cxt->childval;\n\n  /* For now */\n  if (r != -3)\t/* don't do this if we indicate there will be other matches */\n    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));\n\n  RL_CHECK_SIGNALS ();\n  /* We only treat values < 0 specially to simulate recursion. */\n  if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))\t/* success! or failure! */\n    {\n      _rl_keyseq_chain_dispose ();\n      RL_UNSETSTATE (RL_STATE_MULTIKEY);\n      return r;\n    }\n\n  if (r != -3)\t\t\t/* magic value that says we added to the chain */\n    _rl_kscxt = cxt->ocxt;\n  if (_rl_kscxt)\n    _rl_kscxt->childval = r;\n  if (r != -3)\n    _rl_keyseq_cxt_dispose (cxt);\n\n  return r;\n}",
    "comment": "Handles key sequence input and dispatches actions based on the context, managing recursion through context chaining and returning results based on input validity.",
    "hext5_sum": "get the index of a g++ global constructor or destructor from the symbol name.",
    "bint5_sum": "Dispatches a command sequence based on its state , handling subsequences and signals , while managing signal handlers and rescheduling as necessary .\n",
    "cpbcs_sum": "Processes a callback command by handling its arguments, managing state transitions and executing a callback function while stopping the input.\n",
    "misum_sum": "Handles fatal signals by managing signal handlers, updating signal handlers and ensuring the buffer is ready for the correct state.\n",
    "decom_sum": "Processes a readline command sequence, handles signals, updates context state, and frees resources based on execution and error conditions.",
    "cfg_sum": "Handles readline command dispatching, processes caught signals, updates context state, frees resources, and returns appropriate status or error codes.",
    "work_score": {
        "hext5": {
            "summary": "get the index of a g++ global constructor or destructor from the symbol name.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves the index of a g++ global constructor or destructor from a symbol name, which is completely unrelated to the actual source code. The code handles input key sequence dispatch and recursion simulation in a readline-like context, not symbol parsing or constructor/destructor indexing. This makes the sole claim entirely inaccurate.",
                "The summary describes retrieving an index of a g++ global constructor or destructor from a symbol name, which is entirely unrelated to the provided source code. The function in the source handles reading input, dispatching key sequences, simulating recursion via context chains, and disposing contexts based on result codes. Since the summary neither captures the primary purpose nor any secondary details of the actual function, it is completely inaccurate.",
                "The summary's claim that the function gets the index of a g++ global constructor or destructor from the symbol name is entirely unrelated to the source code, which handles key sequence dispatching in a readline context. This is a complete mismatch, making the claim [INACCURATE] as NOISE with no correct factual alignment. The worst failure mode is overwhelming NOISE, leading to no usable insight."
            ]
        },
        "bint5": {
            "summary": "Dispatches a command sequence based on its state , handling subsequences and signals , while managing signal handlers and rescheduling as necessary .\n",
            "score": [
                0.7,
                0.5,
                0.5
            ],
            "reason": [
                "The summary makes a broad and somewhat generic claim that the function dispatches a command sequence based on state, handles subsequences, and manages signals. These are generally supported by the code: it checks flags to determine behavior, invokes subsequence handling functions, and calls RL_CHECK_SIGNALS. However, the mention of 'managing signal handlers and rescheduling as necessary' is not directly reflected in the source code; there is only a signal check macro and no explicit scheduling or signal handler management. Most claims are accurate but at least one is overstated or unsupported.",
                "The summary captures the primary purpose in broad terms by mentioning dispatching command sequences and handling signals, which aligns loosely with the function\u2019s core action of reading input and dispatching based on sequence context. However, it misses critical secondary details such as the specific branching on KSEQ_DISPATCHED flag, handling of magic values like -3, aborting on negative key input, recursion simulation via context chains, disposal of contexts, and unsetting state. The reference to 'rescheduling' is unsupported by the source and is inaccurate.",
                "The summary makes broad claims about dispatching based on state, handling subsequences, and managing signals, which are SAFE but low\u2011info. However, it incorrectly adds 'rescheduling as necessary,' which is not supported by the source code, making it NOISE. There are no FATAL contradictions about primary purpose, key I/O, or side effects, but the overall gain is low due to vague wording and the introduction of an unsupported concept. Worst failure mode: NOISE."
            ]
        },
        "cpbcs": {
            "summary": "Processes a callback command by handling its arguments, managing state transitions and executing a callback function while stopping the input.\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary is overly broad and omits key implementation specifics visible in the source code, such as the conditional dispatch logic based on KSEQ_DISPATCHED flags, handling special return values like -3, simulating recursion via context chains, and managing child values. While it vaguely references managing state transitions and executing a callback, it fails to accurately capture the actual sequence of operations, input reading, and result processing present in the code. Most claims are either too generic or do not align directly with the semantics, resulting in less than half being precise.",
                "The summary captures a vague idea of managing state transitions and executing something akin to a callback, which loosely aligns with the function's role in processing key sequences and controlling state. However, it misses the primary purpose of the function: reading a key input, dispatching subsequence commands, handling specific return codes (-1, -3), simulating recursion with contexts, and cleaning up. It omits critical details such as input handling, abort conditions, magic return value handling, recursion simulation, and cleanup operations. The lack of specificity and missing primary mechanics result in poor coverage of the actual implementation.",
                "The summary makes broad, low-information claims about processing a callback, managing state, and stopping input, which are generally safe but lack specificity. There are no direct contradictions with the source code, but it omits key implementation details such as the handling of KSEQ_DISPATCHED flags, input reading via _rl_subseq_getchar, special result codes like -3, and the recursion simulation through context chains. The gain is low because it does not convey the specific control flow or conditions that would provide deep insight to a developer."
            ]
        },
        "misum": {
            "summary": "Handles fatal signals by managing signal handlers, updating signal handlers and ensuring the buffer is ready for the correct state.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary makes claims about handling fatal signals, managing signal handlers, and ensuring buffer readiness. None of these behaviors are present in the source code, which instead handles key sequence dispatch, result processing, and context management without signal handler updates or buffer preparation logic. This makes all extracted claims inaccurate.",
                "The summary's claims about handling fatal signals, managing/updating signal handlers, and preparing a buffer do not match the source code's actual purpose, which is to dispatch key sequences in a simulated recursion context, handle specific return codes, and clean up state. There is no signal handler modification nor buffer preparation logic; the only signal-related code is a macro call likely for signal checking, not handling. The summary entirely misses the primary purpose and critical details.",
                "The summary's claims about handling fatal signals, managing and updating signal handlers, and ensuring the buffer is ready do not correspond to any behavior in the provided source. The code is concerned with dispatching key sequences, handling recursion simulation, processing results, and disposing contexts, but there is no signal handler management or buffer readiness logic. All claims are inaccurate and constitute high NOISE unrelated to the implementation, providing no useful insight."
            ]
        }
    }
}
{
    "project_name": "xorriso",
    "function_addr": 5092624,
    "strip_function_name": "sub_4DB510",
    "strip_decompiled_code": "__int64 __fastcall sub_4DB510(char *s2, _DWORD *a2, int *a3, int *a4, int *a5, _DWORD *a6)\n{\n  __int64 v8; // rax\n  char *v9; // rbx\n  int *v10; // r14\n  int v11; // r15d\n  int v12; // eax\n  int v13; // eax\n  __int64 v15; // rdx\n  unsigned int v16; // [rsp+8h] [rbp-50h]\n\n  v8 = sub_4E19C0(1uLL, 0x400uLL);\n  if ( !v8 )\n    return 0xFFFFFFFFLL;\n  v9 = (char *)v8;\n  if ( dword_7713EC < 0 )\n  {\nLABEL_9:\n    v13 = sub_4F27F0(s2, a2, a3, a4, a5, a6);\n  }\n  else\n  {\n    v10 = (int *)&unk_783BE0;\n    v11 = 0;\n    while ( 1 )\n    {\n      if ( v10[56] >= 0 )\n      {\n        v12 = sub_4DB2B0((__int64)v10, v9);\n        if ( v12 < 0 )\n        {\n          v13 = 1;\n          goto LABEL_10;\n        }\n        if ( v12 )\n        {\n          v13 = strcmp(v9, s2);\n          if ( !v13 )\n            break;\n        }\n      }\n      ++v11;\n      v10 += 596;\n      if ( dword_7713EC < v11 )\n        goto LABEL_9;\n    }\n    v15 = 596LL * v11;\n    *a3 = dword_783BE8[v15];\n    *a4 = dword_783BF0[v15];\n    *a5 = dword_783BEC[v15];\n    *a6 = dword_783BF4[v15];\n    *a2 = *(_DWORD *)((char *)&unk_783BE4 + v15 * 4);\n    if ( *a3 >= 0 && *a4 >= 0 && *a5 >= 0 )\n      v13 = *a6 >= 0;\n  }\nLABEL_10:\n  v16 = v13;\n  free(v9);\n  return v16;\n}\n",
    "function_name": "burn_drive_obtain_scsi_adr",
    "decompiled_code": "__int64 __fastcall burn_drive_obtain_scsi_adr(\n        char *a1,\n        int *bus_no,\n        burn_drive *a3,\n        int *a4,\n        int *target_no,\n        int *lun_no)\n{\n  size_t v6; // rax\n  char *v9; // rax\n  char *v10; // rbx\n  burn_drive *v11; // r14\n  int v12; // r15d\n  int adr; // eax\n  int v14; // eax\n  unsigned int v16; // [rsp+8h] [rbp-50h]\n\n  v9 = (char *)burn_alloc_mem(v6, 1uLL, 0);\n  if ( !v9 )\n    return 0xFFFFFFFFLL;\n  v10 = v9;\n  if ( drivetop < 0 )\n  {\nLABEL_9:\n    v14 = sg_obtain_scsi_adr(a1, bus_no, &a3->drive_role, a4, target_no, lun_no);\n  }\n  else\n  {\n    v11 = drive_array;\n    v12 = 0;\n    while ( 1 )\n    {\n      if ( v11->global_index >= 0 )\n      {\n        adr = burn_drive_d_get_adr((__int64)v11, v10);\n        if ( adr < 0 )\n        {\n          v14 = 1;\n          goto LABEL_10;\n        }\n        if ( adr )\n        {\n          v14 = strcmp(v10, a1);\n          if ( !v14 )\n            break;\n        }\n      }\n      ++v12;\n      ++v11;\n      if ( drivetop < v12 )\n        goto LABEL_9;\n    }\n    a3->drive_role = drive_array[v12].host;\n    *a4 = drive_array[v12].channel;\n    *target_no = drive_array[v12].id;\n    *lun_no = drive_array[v12].lun;\n    *bus_no = drive_array[v12].bus_no;\n    if ( a3->drive_role >= 0 && *a4 >= 0 && *target_no >= 0 )\n      v14 = *lun_no >= 0;\n  }\nLABEL_10:\n  v16 = v14;\n  free(v10);\n  return v16;\n}\n",
    "source_code": "int burn_drive_obtain_scsi_adr(char *path,\n\t\t\t       int *bus_no, int *host_no, int *channel_no,\n\t\t\t       int *target_no, int *lun_no)\n{\n\tint ret, i;\n\tchar *adr = NULL;\n\n\tBURN_ALLOC_MEM(adr, char, BURN_DRIVE_ADR_LEN);\n\n\t/* open drives cannot be inquired by sg_obtain_scsi_adr() */\n\tfor (i = 0; i < drivetop + 1; i++) {\n\t\tif (drive_array[i].global_index < 0)\n\tcontinue;\n\t\tret = burn_drive_d_get_adr(&(drive_array[i]),adr);\n\t\tif (ret < 0)\n\t\t\t{ret = 1; goto ex;}\n\t\tif (ret == 0)\n\tcontinue;\n\t\tif (strcmp(adr, path) == 0) {\n\t\t\t*host_no = drive_array[i].host;\n\t\t\t*channel_no = drive_array[i].channel;\n\t\t\t*target_no = drive_array[i].id;\n\t\t\t*lun_no = drive_array[i].lun;\n\t\t\t*bus_no = drive_array[i].bus_no;\n\t\t\tif (*host_no < 0 || *channel_no < 0 ||\n\t\t\t    *target_no < 0 || *lun_no < 0)\n\t\t\t\t{ret = 0; goto ex;}\n\t\t\t{ret = 1; goto ex;}\n\t\t}\n\t}\n\n\tret = sg_obtain_scsi_adr(path, bus_no, host_no, channel_no,\n\t\t\t\t target_no, lun_no);\nex:;\n\tBURN_FREE_MEM(adr);\n\treturn ret;\n}",
    "comment": "Retrieves the SCSI address information for a specified drive path, utilizing both local and SCSI inquiry methods.",
    "hext5_sum": "| a this function build the following tree, from regular expression a*:",
    "bint5_sum": "Retrieves the media and session IDs of a drive based on its current profile and specified flags , returning results through output parameters .\n",
    "cpbcs_sum": "Reads data from a specified file descriptor, copies it to a buffer and handles potential errors during the read operation.\n",
    "misum_sum": "Reads the symbolic link Information Structure (CIS) from a drive, extracts a pattern and potential header data with support and memory allocation.\n",
    "decom_sum": "Searches a table for a matching string and returns associated integer fields, or delegates to an alternate lookup when no match is found.",
    "cfg_sum": "Searches a global record list for a matching string, retrieves associated integer fields, validates them, and returns a status code after cleanup.",
    "work_score": {
        "hext5": {
            "summary": "| a this function build the following tree, from regular expression a*:",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary claims the function builds a tree from a regular expression 'a*', which is unrelated to the source code. The actual code retrieves and returns SCSI address information for a drive. All extracted claims are inaccurate and do not match the implementation, resulting in no accurate claims.",
                "The summary describes building a tree from a regular expression 'a*', which is entirely unrelated to the source code's actual purpose of obtaining SCSI address information for a drive based on a given path. It misses the primary purpose and all secondary details of the function, resulting in no accurate claims.",
                "The summary's only claim states that the function builds a tree from the regular expression 'a*', which is completely unrelated to the source code's actual purpose of obtaining SCSI address information for a drive. This is a FATAL error affecting the primary purpose of the function. No accurate claims are present, so the negative impact is high and there is no positive gain."
            ]
        },
        "bint5": {
            "summary": "Retrieves the media and session IDs of a drive based on its current profile and specified flags , returning results through output parameters .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves media and session IDs based on profile and flags, which is entirely unrelated to the actual implementation. The source code obtains SCSI addressing information (host, channel, target, LUN, bus) by matching a path to known drives or querying via sg_obtain_scsi_adr. None of the described behavior in the summary matches the code logic, so all claims are inaccurate.",
                "The summary is entirely inaccurate: it describes retrieving media and session IDs based on profile and flags, which does not match the source code's purpose. The actual function obtains SCSI address components (bus, host, channel, target, lun) for a drive that matches a given path, using local lookup or a fallback function. The primary purpose is missed, and none of the key secondary details from the code are covered.",
                "The summary's sole claim about retrieving media and session IDs based on profile and flags is completely inaccurate. The source code actually obtains SCSI address components (bus, host, channel, target, lun) for a given path, either through its drive array or by calling sg_obtain_scsi_adr. This mismatch targets the primary purpose incorrectly, making it a FATAL error with no accurate claims to offset it."
            ]
        },
        "cpbcs": {
            "summary": "Reads data from a specified file descriptor, copies it to a buffer and handles potential errors during the read operation.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function reads from a file descriptor, copies to a buffer, and handles read errors. The source code instead searches for a drive matching a given path, retrieves SCSI address details, and interacts with drive data structures. None of the described operations match the actual implementation, making all claims inaccurate.",
                "The summary is entirely inaccurate, describing reading from a file descriptor and copying to a buffer, which does not match the source code's actual behavior of locating a SCSI device address and retrieving its bus/host/channel/target/LUN details. It misses the primary purpose and all secondary details, making none of its claims aligned with the code.",
                "The summary claims the function reads from a file descriptor to a buffer and handles potential read errors, but the source code actually searches an internal drive array for a matching SCSI address and fills out address components. This is a direct contradiction about the primary purpose and key I/O, making it a FATAL error. There are no accurate claims present, and the misrepresentation is severe."
            ]
        },
        "misum": {
            "summary": "Reads the symbolic link Information Structure (CIS) from a drive, extracts a pattern and potential header data with support and memory allocation.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary describes reading a symbolic link Information Structure (CIS) and extracting patterns and header data, which is unrelated to the actual source code's behavior. The function in the source code obtains SCSI address information for a given path, iterating through available drives, comparing addresses, and setting bus/host/channel/target/LUN numbers. None of the claims in the summary align with these semantics, resulting in no accurate fact-based claims.",
                "The summary describes reading a symbolic link Information Structure and extracting a pattern/header, which is unrelated to the source code. The function in the source code obtains SCSI address information for a given path, iterating over drive data, comparing paths, and retrieving host, channel, target, LUN, and bus numbers, with memory allocation and fallback to sg_obtain_scsi_adr(). The primary purpose is entirely missed and no accurate claims are made.",
                "The summary's claims about reading a 'symbolic link Information Structure (CIS)' and extracting patterns or header data do not match the source code, which instead obtains SCSI address details from drive structures and calls sg_obtain_scsi_adr. These claims are unrelated to the primary purpose or I/O of the function, representing NOISE. There are no accurate, specific mappings to the code's actual operations, leading to overwhelming inaccuracy and no useful gain."
            ]
        }
    }
}
{
    "project_name": "bool",
    "function_addr": 4201200,
    "strip_function_name": "sub_401AF0",
    "strip_decompiled_code": "__int64 __fastcall sub_401AF0(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 result; // rax\n  __int64 v3; // rax\n  bool v4; // zf\n  __int64 v5; // rbx\n  __int64 v6; // rax\n  int v7; // r13d\n  __int64 v8; // rbp\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // rbx\n  __int64 v12; // r14\n\n  sub_403DC0();\n  qword_608860 = sub_403E20(128LL);\n  *(_DWORD *)(qword_608860 + 104) = sub_402820(a1);\n  v1 = qword_608860;\n  result = *(unsigned int *)(qword_608860 + 104);\n  if ( (_DWORD)result )\n  {\n    v3 = sub_403E20((unsigned int)(qword_608848 + 17));\n    v4 = (byte_608858 & 4) == 0;\n    *(_QWORD *)(v1 + 96) = v3;\n    if ( v4 )\n    {\n      v5 = qword_608860;\n      v6 = sub_403E20((unsigned int)(8 * *(_DWORD *)(qword_608860 + 104)));\n      v7 = dword_608850;\n      *(_QWORD *)(v5 + 88) = v6;\n      if ( !v7 )\n        v7 = 1;\n      result = *(unsigned int *)(qword_608860 + 104);\n      if ( (int)result > 0 )\n      {\n        v8 = 0LL;\n        do\n        {\n          v9 = sub_403E20((unsigned int)(8 * v7));\n          v10 = v9;\n          if ( v7 > 0 )\n          {\n            v11 = 8LL * (unsigned int)(v7 - 1) + 8 + v9;\n            v12 = v9;\n            do\n            {\n              v12 += 8LL;\n              *(_QWORD *)(v12 - 8) = sub_403E20((unsigned int)(qword_608848 + 17));\n            }\n            while ( v11 != v12 );\n          }\n          result = *(unsigned int *)(qword_608860 + 104);\n          *(_QWORD *)(*(_QWORD *)(qword_608860 + 88) + 8 * v8++) = v10;\n        }\n        while ( (int)result > (int)v8 );\n      }\n    }\n    else\n    {\n      return *(unsigned int *)(qword_608860 + 104);\n    }\n  }\n  return result;\n}\n",
    "function_name": "context_init",
    "decompiled_code": "__int64 __fastcall context_init(char *a1)\n{\n  context *v1; // rbx\n  __int64 result; // rax\n  line *v3; // rax\n  bool v4; // zf\n  context *v5; // rbx\n  line ***v6; // rax\n  signed int occurrences; // r13d\n  __int64 v8; // rbp\n  line **v9; // rax\n  line **v10; // r12\n  line **v11; // rbx\n  line **v12; // r14\n\n  mem_init();\n  context_0 = (context *)mem_alloc(128);\n  context_0->num_pat = expr_init(a1);\n  v1 = context_0;\n  result = (unsigned int)context_0->num_pat;\n  if ( (_DWORD)result )\n  {\n    v3 = (line *)mem_alloc(opt.context + 17);\n    v4 = (*((_BYTE *)&opt + 24) & 4) == 0;\n    v1->tmp = v3;\n    if ( v4 )\n    {\n      v5 = context_0;\n      v6 = (line ***)mem_alloc(8 * context_0->num_pat);\n      occurrences = opt.occurrences;\n      v5->lines = v6;\n      if ( !occurrences )\n        occurrences = 1;\n      result = (unsigned int)context_0->num_pat;\n      if ( (int)result > 0 )\n      {\n        v8 = 0LL;\n        do\n        {\n          v9 = (line **)mem_alloc(8 * occurrences);\n          v10 = v9;\n          if ( occurrences > 0 )\n          {\n            v11 = &v9[(unsigned int)(occurrences - 1) + 1];\n            v12 = v9;\n            do\n              *v12++ = (line *)mem_alloc(opt.context + 17);\n            while ( v11 != v12 );\n          }\n          result = (unsigned int)context_0->num_pat;\n          context_0->lines[v8++] = v10;\n        }\n        while ( (int)result > (int)v8 );\n      }\n    }\n    else\n    {\n      return (unsigned int)context_0->num_pat;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint\ncontext_init (char *str)\n{\n  mem_init ();\n  context = mem_alloc (sizeof (struct context));\n  context->num_pat = expr_init (str);\n  if (!context->num_pat)\n    return 0;\n\n  context->tmp = mem_alloc (sizeof (struct line) - sizeof (char[4])\n      + opt.context + 1);\n\n  if (!opt.out_quiet)\n    {\n      register int i, j, occurrences;\n      struct line **line;\n\n      context->lines = mem_alloc (context->num_pat\n\t  * sizeof (struct line **));\n      occurrences = opt.occurrences ? opt.occurrences : 1;\n\n      for (i = 0; i < context->num_pat; i++)\n\t{\n\t  line = mem_alloc (occurrences * sizeof (struct line *));\n\t  for (j = 0; j < occurrences; j++)\n\t    line[j] = mem_alloc (sizeof (struct line) - sizeof (char[4])\n\t\t+ opt.context + 1);\n\n\t  context->lines[i] = line;\n\t}\n    }\n\n  return context->num_pat;\n}",
    "comment": "Initializes the context structure, allocating memory for patterns and lines based on given input and options, and returns the number of patterns.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Processes a new file pattern by allocating memory , extracting matches , and inserting it into a pattern list while handling errors appropriately .\n",
    "cpbcs_sum": "Copies the current number of history chains to a new document while handling potential file size limits and ensuring proper memory management.\n",
    "misum_sum": "Copies the contents of a `format_arg_list`, to a new destination file, marking the result as needed, and handling errors appropriately.\n",
    "decom_sum": "Allocates and initializes a multi-level data structure based on input size and configuration flags, returning the primary element count.",
    "cfg_sum": "Initializes global structures based on input, allocates nested memory arrays conditionally, updates configuration values, and returns the processed element count.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' does not correspond to any specific operation or semantic in the provided source code for context_init. The code allocates memory for several pointer arrays and structures but does not perform any explicit push operation. This claim is vague, lacks relevance to the actual logic, and is therefore inaccurate.",
                "The summary 'push a pointer type' is vague, does not reflect the primary purpose of the function, and fails to cover any specific semantics from the source code. The source function initializes memory structures, sets up a context, handles conditional allocations, and returns the number of patterns, none of which are captured. This is effectively noise and provides no accurate coverage.",
                "The summary contains only a vague phrase that does not match the source code's behavior or purpose. It provides no accurate, verifiable facts about the implementation, input/output, or side effects, and is effectively noise. The lack of meaningful or specific details means there is no actionable gain for understanding the function."
            ]
        },
        "bint5": {
            "summary": "Processes a new file pattern by allocating memory , extracting matches , and inserting it into a pattern list while handling errors appropriately .\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function processes a new file pattern, extracts matches, and inserts it into a pattern list, with error handling. In the source code, the function initializes memory, allocates space for a context structure, sets num_pat from expr_init, allocates line buffers, and returns num_pat. There is no explicit processing of a file pattern, match extraction, or insertion into a pattern list; only a return of num_pat if allocation fails. Most claims are inaccurate, with only the general notion of memory allocation and some error handling aligning.",
                "The summary misrepresents the function's purpose and behavior. The source code shows the function initializes a context structure, allocates various memory blocks based on the number of patterns and options, and returns the number of patterns extracted from the input string via expr_init. The summary incorrectly describes processing a file pattern, extracting matches, and inserting into a pattern list, which are not evident in the code. It also claims error handling, but the only such behavior is returning 0 when num_pat is falsy, and the rest is not covered accurately. Primary purpose and secondary details are both missed.",
                "The summary claims the function processes a new file pattern, extracts matches, and inserts them into a pattern list, but the source code shows it initializes context memory structures and allocates buffers based on patterns from expr_init without performing match extraction or list insertion. This is a FATAL inaccuracy regarding the primary purpose and key operations, which directly contradicts the implementation."
            ]
        },
        "cpbcs": {
            "summary": "Copies the current number of history chains to a new document while handling potential file size limits and ensuring proper memory management.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about copying history chains to a new document, handling file size limits, and memory management are misleading: none of these concepts (history chains, files, file size limits, new document) appear in the source code. The only partially related aspect is memory allocation, which is mentioned in the source, but the rest is inaccurate. As a result, the majority of claims are incorrect.",
                "The summary is inaccurate regarding the source code's primary purpose, as it describes copying history chains and managing file size limits, which are not present in the implementation. The actual function initializes a context structure, allocates memory for patterns and lines, and returns the number of patterns. While the mention of memory management is tangentially related, the core behavior and secondary details in the summary do not align with the source, missing the actual primary purpose and critical operations.",
                "The summary's claims about copying history chains to a document, handling file size limits, and memory management are predominantly inaccurate relative to the source. The source code initializes a context structure, allocates memory for lines based on patterns from an input string, and does not involve documents, history chains, or file size handling. This is a FATAL mismatch with the primary purpose of the function, which is context initialization, making the output unreliable."
            ]
        },
        "misum": {
            "summary": "Copies the contents of a `format_arg_list`, to a new destination file, marking the result as needed, and handling errors appropriately.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes copying a `format_arg_list` to a new file with error handling, which is unrelated to the actual source code that initializes a `context` structure, allocates memory for patterns and lines, and sets up occurrence-related data. All claims in the summary are inaccurate as they do not reflect any operations present in the implementation, resulting in no alignment with the source.",
                "The summary describes copying a `format_arg_list` to a destination file with marking and error handling, which is entirely unrelated to the source code. The source function initializes a context structure, allocates memory for patterns and lines, and returns the number of patterns. The summary misses the primary purpose and all secondary details, making all claims inaccurate.",
                "The summary describes copying a `format_arg_list` to a file and marking results, which is entirely unrelated to the source code. The source code initializes a context structure, allocates memory for lines based on patterns, and sets up context-related buffers. This introduces a complete mismatch, meaning all claims are NOISE with no accurate alignment and no useful insight. The worst failure mode is overwhelming NOISE with zero relevance to the code."
            ]
        }
    }
}
{
    "project_name": "nginx",
    "function_addr": 226656,
    "strip_function_name": "ngx_proxy_protocol_write",
    "strip_decompiled_code": "char *__fastcall ngx_proxy_protocol_write(\n        __int64 a1,\n        __int64 a2,\n        char *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int16 v12; // ax\n  char *v13; // rbx\n  char *v14; // rbx\n  char *v15; // r13\n  unsigned __int16 port; // ax\n\n  if ( (__int64)&a3[-a2] <= 106 )\n    return 0LL;\n  if ( ngx_connection_local_sockaddr(a1, 0LL, 0LL, a4, a5, a6, a7, a8, a9, a10, a11) )\n    return 0LL;\n  v12 = **(_WORD **)(a1 + 104);\n  if ( v12 == 2 )\n  {\n    qmemcpy((void *)a2, \"PROXY TCP4 \", 11);\n    v13 = (char *)(a2 + 11);\n    goto LABEL_6;\n  }\n  if ( v12 == 10 )\n  {\n    qmemcpy((void *)a2, \"PROXY TCP6 \", 11);\n    v13 = (char *)(a2 + 11);\nLABEL_6:\n    v14 = &v13[ngx_sock_ntop(*(__int16 **)(a1 + 104), *(_DWORD *)(a1 + 112), v13, a3 - v13, 0LL)];\n    *v14 = 32;\n    v15 = &v14[ngx_sock_ntop(*(__int16 **)(a1 + 168), *(_DWORD *)(a1 + 176), v14 + 1, a3 - (v14 + 1), 0LL) + 1];\n    LOWORD(v14) = ngx_inet_get_port(*(_WORD **)(a1 + 104));\n    port = ngx_inet_get_port(*(_WORD **)(a1 + 168));\n    return ngx_slprintf(v15, a3, \" %ui %ui\\r\\n\", (unsigned __int16)v14, port);\n  }\n  *(_BYTE *)(a2 + 14) = 10;\n  qmemcpy((void *)a2, \"PROXY UNKNOW\", 12);\n  *(_WORD *)(a2 + 12) = 3406;\n  return (char *)(a2 + 15);\n}\n",
    "function_name": "ngx_proxy_protocol_write",
    "decompiled_code": "u_char *__fastcall ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n{\n  sa_family_t sa_family; // ax\n  u_char *v5; // rbx\n  u_char *v6; // rbx\n  u_char *v7; // r13\n  in_port_t port; // ax\n\n  if ( last - buf <= 106 )\n    return 0LL;\n  if ( ngx_connection_local_sockaddr(c, 0LL, 0LL) )\n    return 0LL;\n  sa_family = c->sockaddr->sa_family;\n  if ( sa_family == 2 )\n  {\n    qmemcpy(buf, \"PROXY TCP4 \", 11);\n    v5 = buf + 11;\n    goto LABEL_6;\n  }\n  if ( sa_family == 10 )\n  {\n    qmemcpy(buf, \"PROXY TCP6 \", 11);\n    v5 = buf + 11;\nLABEL_6:\n    v6 = &v5[ngx_sock_ntop(c->sockaddr, c->socklen, v5, last - v5, 0LL)];\n    *v6 = 32;\n    v7 = &v6[ngx_sock_ntop(c->local_sockaddr, c->local_socklen, v6 + 1, last - (v6 + 1), 0LL) + 1];\n    LOWORD(v6) = ngx_inet_get_port(c->sockaddr);\n    port = ngx_inet_get_port(c->local_sockaddr);\n    return ngx_slprintf(v7, last, \" %ui %ui\\r\\n\", (unsigned __int16)v6, port);\n  }\n  buf[14] = 10;\n  qmemcpy(buf, \"PROXY UNKNOW\", 12);\n  *((_WORD *)buf + 6) = 3406;\n  return buf + 15;\n}\n",
    "source_code": "\n\nu_char *\nngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n{\n    ngx_uint_t  port, lport;\n\n    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {\n        return NULL;\n    }\n\n    if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n        return NULL;\n    }\n\n    switch (c->sockaddr->sa_family) {\n\n    case AF_INET:\n        buf = ngx_cpymem(buf, \"PROXY TCP4 \", sizeof(\"PROXY TCP4 \") - 1);\n        break;\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        buf = ngx_cpymem(buf, \"PROXY TCP6 \", sizeof(\"PROXY TCP6 \") - 1);\n        break;\n#endif\n\n    default:\n        return ngx_cpymem(buf, \"PROXY UNKNOWN\" CRLF,\n                          sizeof(\"PROXY UNKNOWN\" CRLF) - 1);\n    }\n\n    buf += ngx_sock_ntop(c->sockaddr, c->socklen, buf, last - buf, 0);\n\n    *buf++ = ' ';\n\n    buf += ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, last - buf,\n                         0);\n\n    port = ngx_inet_get_port(c->sockaddr);\n    lport = ngx_inet_get_port(c->local_sockaddr);\n\n    return ngx_slprintf(buf, last, \" %ui %ui\" CRLF, port, lport);\n}",
    "comment": "Constructs and writes a PROXY protocol header, including client and server IP addresses and ports, to the provided buffer.",
    "hext5_sum": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
    "bint5_sum": "Formats and writes the PROXY protocol header to a connection based on its address and port , handling both IPv4 and IPv6 cases .\n",
    "cpbcs_sum": "Writes data to a buffer of data from a socket, handling both single and asynchronous operations accordingly.\n",
    "misum_sum": "Handles TCP connections to a specified address and port, managing retransmission states and sending a packet if the address is not a TCP connection.\n",
    "decom_sum": "Constructs and writes a PROXY protocol v1 header with client and server IP addresses and ports into the provided buffer.",
    "cfg_sum": "Formats and writes a PROXY protocol header with source and destination IP addresses and ports, returning NULL if validation or address retrieval fails.",
    "work_score": {
        "hext5": {
            "summary": "returns a version of in with any control characters replaced by escape sequences. uses a static buffer if necessary. if unicode display is enabled, then also handles the conversion of unicode characters.",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary describes behavior related to replacing control characters, using a static buffer, and handling Unicode display, none of which are reflected in the source code. The actual function constructs a PROXY protocol header using connection addresses and ports, with no logic for control character escaping or Unicode handling. All claims are inaccurate against the provided implementation.",
                "The summary's claims are entirely unrelated to the source code. The described functionality about replacing control characters, using a static buffer, and handling Unicode display does not match the actual implementation, which constructs and writes a PROXY protocol header string using socket addresses and ports. This misses the primary purpose and all secondary details of the source function.",
                "All claims in the summary are unrelated to the source code, which constructs and writes a PROXY protocol header using socket addresses and ports. The summary instead describes processing of a string by replacing control characters, escaping sequences, and handling Unicode, none of which appear in the function. This produces overwhelming NOISE with no accurate claims, resulting in no usable insight."
            ]
        },
        "bint5": {
            "summary": "Formats and writes the PROXY protocol header to a connection based on its address and port , handling both IPv4 and IPv6 cases .\n",
            "score": [
                1.0,
                0.6,
                0.5
            ],
            "reason": [
                "The summary contains one main claim: that the function formats and writes the PROXY protocol header based on the connection's address and port, handling both IPv4 and IPv6. This matches the source code, which writes 'PROXY TCP4' or 'PROXY TCP6' depending on the address family, includes address and port fields, and sends the formatted header. There are no contradictory or irrelevant statements, making the claim fully accurate.",
                "The summary correctly captures the primary purpose: formatting and writing a PROXY protocol header using the connection's address and port, and mentions IPv4 and IPv6 handling, which aligns with the switch cases in the code. However, it omits key secondary details such as the buffer size check, behavior when address family is unsupported (PROXY UNKNOWN), the specific use of remote and local addresses and ports, and failure cases returning NULL. This partial coverage limits completeness.",
                "The summary correctly states that the function formats and writes a PROXY protocol header based on the connection's address and port, and that it handles both IPv4 and IPv6 cases. These claims align with the source code's implementation, which checks the socket family, writes either 'PROXY TCP4' or 'PROXY TCP6', and appends the relevant addresses and ports. However, the summary omits details like the handling of unknown address families and buffer length checks, so while accurate, it provides low informational gain. There are no inaccurate or contradictory claims, and the content is safe but broad."
            ]
        },
        "cpbcs": {
            "summary": "Writes data to a buffer of data from a socket, handling both single and asynchronous operations accordingly.\n",
            "score": [
                0.3,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function writes data to a buffer from a socket, which is partially accurate as the code formats and writes a PROXY protocol header into the buffer using socket address information. However, it inaccurately mentions handling both single and asynchronous operations, which is not reflected in the source code. There is no logic related to asynchronous operations in the implementation. Therefore, only part of the claim matches, with the remainder being unrelated or incorrect.",
                "The summary is inaccurate because it misrepresents the primary purpose of the function. The source function constructs and writes a PROXY protocol header into a buffer based on a connection's addresses and ports, with specific handling for IPv4, IPv6, and unknown families, and includes buffer size checks. The summary instead vaguely mentions writing data from a socket and handling single/asynchronous operations, which are not present in the code. It misses both the primary purpose and all secondary details such as address formatting, port extraction, and error/size checks.",
                "The summary claims the function writes data from a socket to a buffer and handles both single and asynchronous operations. While the first part is broadly true (SAFE), the mention of handling asynchronous operations is unsupported and incorrect given the code simply writes a PROXY protocol header based on socket addresses and ports without any async logic. This is a FATAL error because it misrepresents the primary behavior. The accurate content is too generic to provide meaningful insight."
            ]
        },
        "misum": {
            "summary": "Handles TCP connections to a specified address and port, managing retransmission states and sending a packet if the address is not a TCP connection.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims are largely inaccurate. It asserts handling TCP connections to a specified address and port, managing retransmission states, and sending a packet if not a TCP connection. The source code instead formats and writes a PROXY protocol header, detects whether the connection uses IPv4, IPv6, or unknown, and appends address and port information. There is no retransmission management or packet sending logic beyond writing to a buffer. None of the specific claims match the implementation, resulting in minimal accuracy.",
                "The summary's claims about handling TCP connections, managing retransmission states, and sending a packet if the address is not TCP do not match the source code. The function actually formats and writes a PROXY protocol header based on the socket family and connection details, with no logic for retransmission or dynamic connection management. This misses the primary purpose and contains inaccurate details unrelated to the implementation.",
                "The summary claims the function handles TCP connections to a specified address and port, manages retransmission states, and sends a packet if the address is not TCP. These are inaccurate: the actual code constructs a PROXY protocol header based on the connection\u2019s address family, without any retransmission logic or conditional packet sending beyond handling unknown families. This is a FATAL error as it misrepresents the primary purpose and key I/O behavior of the function, providing no accurate insight."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071580876272,
    "strip_function_name": "sub_FFFFFFFF811EFDF0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF811EFDF0(\n        __int64 a1,\n        unsigned __int64 a2,\n        unsigned int a3,\n        unsigned int a4,\n        volatile signed __int8 *a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  unsigned int v16; // eax\n  int v17; // r8d\n  int v18; // r9d\n  double v19; // xmm4_8\n  double v20; // xmm5_8\n  unsigned __int64 v21; // rax\n  double v22; // xmm4_8\n  double v23; // xmm5_8\n  __int64 result; // rax\n  unsigned __int64 v25; // [rsp+0h] [rbp-58h]\n  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a4 >= a3 )\n  {\n    v16 = sub_FFFFFFFF811AFDD0(a1, (__int64)v26, a6, a7, a8, a9, a10, a11, a12, a13);\n    if ( !v16 )\n      goto LABEL_3;\nLABEL_10:\n    sub_FFFFFFFF811CA2C0(\n      *(_QWORD *)(a1 + 40),\n      (__int64)\"ext4_write_inline_data_end\",\n      734,\n      v16,\n      v17,\n      v18,\n      a6,\n      a7,\n      a8,\n      a9,\n      v19,\n      v20,\n      a12,\n      a13);\n    return 0LL;\n  }\n  if ( (*(_QWORD *)a5 & 8) == 0 )\n    return 0LL;\n  v16 = sub_FFFFFFFF811AFDD0(a1, (__int64)v26, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( v16 )\n    goto LABEL_10;\nLABEL_3:\n  sub_FFFFFFFF8178FDC0(a1 - 88);\n  if ( (*(_QWORD *)(a1 - 96) & 0x10000000) == 0 || !*(_WORD *)(a1 + 678) )\n    BUG();\n  v21 = __readgsqword(0xA760u) - 8152;\n  ++*(_DWORD *)(v21 + 28);\n  v25 = v21;\n  sub_FFFFFFFF811EF1C0(\n    (unsigned __int16 *)a1,\n    v26,\n    ((__int64)(a5 + 0x160000000000LL) >> 6 << 12) - 0x780000000000LL,\n    a2,\n    a3);\n  --*(_DWORD *)(v25 + 28);\n  _InterlockedOr8(a5, 8u);\n  _InterlockedAnd8(a5, 0xEFu);\n  sub_FFFFFFFF810644C0((volatile signed __int64 *)(a1 - 88));\n  result = a4;\n  if ( v26[0] )\n  {\n    sub_FFFFFFFF81163E20(v26[0], a6, a7, a8, a9, v22, v23, a12, a13);\n    return a4;\n  }\n  return result;\n}\n",
    "function_name": "ext4_write_inline_data_end",
    "decompiled_code": "__int64 __fastcall ext4_write_inline_data_end(\n        __int64 a1,\n        unsigned __int64 a2,\n        unsigned int a3,\n        unsigned int a4,\n        volatile signed __int8 *a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12,\n        double a13)\n{\n  int inode_loc; // eax\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  unsigned __int64 v19; // rax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 result; // rax\n  unsigned __int64 v23; // [rsp+0h] [rbp-58h]\n  __int64 v24[8]; // [rsp+18h] [rbp-40h] BYREF\n\n  if ( a4 >= a3 )\n  {\n    inode_loc = ext4_get_inode_loc(a1, (__int64)v24, a6, a7, a8, a9, a10, a11, a12, a13);\n    if ( !inode_loc )\n      goto LABEL_3;\nLABEL_10:\n    _ext4_std_error(\n      *(_QWORD *)(a1 + 40),\n      \"ext4_write_inline_data_end\",\n      0x2DEu,\n      inode_loc,\n      a6,\n      a7,\n      a8,\n      a9,\n      v17,\n      v18,\n      a12,\n      a13);\n    return 0LL;\n  }\n  if ( (*(_QWORD *)a5 & 8) == 0 )\n    return 0LL;\n  inode_loc = ext4_get_inode_loc(a1, (__int64)v24, a6, a7, a8, a9, a10, a11, a12, a13);\n  if ( inode_loc )\n    goto LABEL_10;\nLABEL_3:\n  down_write((volatile signed __int64 *)(a1 - 88));\n  if ( (*(_QWORD *)(a1 - 96) & 0x10000000) == 0 || !*(_WORD *)(a1 + 678) )\n    BUG();\n  v19 = __readgsqword(0xA760u) - 8152;\n  ++*(_DWORD *)(v19 + 28);\n  v23 = v19;\n  ext4_write_inline_data(\n    (unsigned __int16 *)a1,\n    v24,\n    ((__int64)(a5 + 0x160000000000LL) >> 6 << 12) - 0x780000000000LL,\n    a2,\n    a3);\n  --*(_DWORD *)(v23 + 28);\n  _InterlockedOr8(a5, 8u);\n  _InterlockedAnd8(a5, 0xEFu);\n  up_write((volatile signed __int64 *)(a1 - 88), (__int64)v24);\n  result = a4;\n  if ( v24[0] )\n  {\n    _brelse(v24[0], a6, a7, a8, a9, v20, v21, a12, a13);\n    return a4;\n  }\n  return result;\n}\n",
    "source_code": "\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
    "comment": "Writes inline data to the inode's page, marking it as up-to-date and clearing its dirty state after successfully copying the specified length.",
    "hext5_sum": "dump the symbol table.",
    "bint5_sum": "Reads inline data from an inode into a buffer , ensuring the requested length does not exceed the inode 's inline size .\n",
    "cpbcs_sum": "Writes inline data to a journaled inode by validating write pointer and ensuring the buffer is not empty before returning the write result.\n",
    "misum_sum": "Writes inline data to a journal, ensuring the inode size consistency and updating the buffer's flags accordingly.\n",
    "decom_sum": "Handles completion of ext4 inline data write, performing validation, locking, metadata updates, and finalizing with block mapping and cleanup operations.",
    "cfg_sum": "Handles inline data write operations in an ext4 filesystem, performing validation, synchronization, state updates, and logging before returning execution status.",
    "work_score": {
        "hext5": {
            "summary": "dump the symbol table.",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary makes a broad, vague claim about dumping a symbol table, which does not directly relate to or accurately describe any part of the provided source code. The source function handles inline data writing for ext4 inodes, not symbol table operations. This results in 0% accurate claims.",
                "The summary 'dump the symbol table' is entirely inaccurate; it does not describe the function's primary purpose of writing inline data to an ext4 inode or any of its key behaviors such as error handling, mapping pages, or clearing dirty flags. It fails to capture any CSU from the source code and is unrelated to its semantics.",
                "The summary contains only a vague and irrelevant statement ('dump the symbol table') that does not describe the source code\u2019s implementation or purpose. It does not match any functionality in the provided function, which writes inline data in an ext4 filesystem inode. This constitutes pure NOISE with no accurate claims, resulting in high negative impact due to total lack of relevance."
            ]
        },
        "bint5": {
            "summary": "Reads inline data from an inode into a buffer , ensuring the requested length does not exceed the inode 's inline size .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function reads inline data from an inode, when the source code actually writes inline data to the inode from a page buffer. It also mentions ensuring the requested length does not exceed the inode's inline size, which is not explicitly implemented in the code. Both claims contradict the source semantics, leaving no accurate claims.",
                "The summary is inaccurate as it describes reading inline data into a buffer and enforcing a size limit, while the source code function writes inline data from a page into an inode. It misses the primary purpose, incorrectly states the direction of data transfer, and omits key secondary details such as error handling, page status checks, inode location retrieval, synchronization via xattr_sem, and clearing page dirty state.",
                "The summary claims the function reads inline data from an inode into a buffer and checks length against inline size, but the source code clearly writes inline data from a page to the inode. This is a FATAL inaccuracy about the primary purpose and key I/O, fundamentally contradicting the implementation, outweighing any potential accurate elements."
            ]
        },
        "cpbcs": {
            "summary": "Writes inline data to a journaled inode by validating write pointer and ensuring the buffer is not empty before returning the write result.\n",
            "score": [
                0.2,
                0.5,
                0.2
            ],
            "reason": [
                "The summary claims the function validates a write pointer and ensures the buffer is not empty, which does not align with the source. The code checks 'copied < len' and 'PageUptodate', retrieves inode location, and writes inline data, but there is no explicit pointer validation or generic buffer-empty check described in the summary. Only the broad idea of writing inline data to an inode matches, making most claims inaccurate.",
                "The summary captures the general idea of writing inline data to an inode but omits key secondary details from the code, such as handling mismatched `copied` and `len`, checking `PageUptodate`, retrieving and validating inode location, locking via `xattr_sem`, and clearing page dirty state. The mention of 'validating write pointer' and 'ensuring the buffer is not empty' is vague and does not accurately reflect the specific error handling and page state checks performed. Therefore, it covers the primary purpose partially but lacks critical implementation specifics.",
                "The summary contains mostly inaccurate information. The claim that the function writes inline data to a journaled inode is broadly correct (SAFE), but it inaccurately describes the preconditions: the code checks if the copied length is less than len and whether the page is up-to-date, not whether the buffer is 'not empty.' It also omits and misstates details of the function\u2019s key logic, such as how it obtains the inode location, uses locking, memory mapping, and updates page status. This misrepresentation of the core write condition is a FATAL error because it changes the semantics of when writing occurs."
            ]
        },
        "misum": {
            "summary": "Writes inline data to a journal, ensuring the inode size consistency and updating the buffer's flags accordingly.\n",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function writes inline data to a journal and ensures inode size consistency, neither of which is present in the source code. The source code writes inline data directly to the inode, uses locking, maps the page, updates and clears page flags, and handles error conditions. Only the mention of updating buffer/page flags loosely aligns with the code. Most claims are inaccurate, resulting in a low proportion of accurate statements.",
                "The summary captures the primary purpose partially\u2014it conveys that the function writes inline data and updates flags, which aligns with writing inline data into the inode and updating page flags. However, it inaccurately mentions writing to a 'journal' and ensuring 'inode size consistency,' which are not implemented in the code. It misses secondary details such as error handling when 'copied < len' or 'ext4_get_inode_loc' fails, use of synchronization via xattr_sem, use of kmap_atomic/kunmap_atomic, clearing the page dirty bit, and ensuring the presence of inline data.",
                "The summary contains a key FATAL error: it claims the function writes inline data to a journal and ensures inode size consistency, neither of which is supported by the source implementation. The code writes inline data directly into the inode structure via ext4_write_inline_data, uses kmap_atomic for page mapping, and updates page flags like SetPageUptodate and ClearPageDirty. No journaling or inode size adjustments are performed. This misrepresentation affects the primary purpose and semantics of the function, making the summary unreliable despite minor mention of buffer flag updates."
            ]
        }
    }
}
{
    "project_name": "lua",
    "function_addr": 79888,
    "strip_function_name": "sub_13810",
    "strip_decompiled_code": "void __fastcall sub_13810(__int64 a1, int a2)\n{\n  __int64 v3; // rbp\n  int v4; // r10d\n  __int64 *v5; // rdi\n  __int64 *v6; // r9\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // rax\n\n  v3 = *(_QWORD *)(a1 + 24);\n  v4 = *(_DWORD *)(v3 + 60);\n  if ( v4 < a2 )\n  {\n    v10 = sub_ECF0(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n    v4 = *(_DWORD *)(v3 + 60);\n    *(_QWORD *)(v3 + 48) = v10;\n    if ( a2 > v4 )\n    {\n      v11 = (_QWORD *)(v10 + 8LL * v4);\n      v12 = v10 + 8 * (v4 + (unsigned __int64)(unsigned int)(a2 - 1 - v4)) + 8;\n      do\n        *v11++ = 0LL;\n      while ( v11 != (_QWORD *)v12 );\n    }\n  }\n  if ( v4 > 0 )\n  {\n    v5 = *(__int64 **)(v3 + 48);\n    v6 = v5;\n    do\n    {\n      v7 = *v6;\n      *v6 = 0LL;\n      if ( v7 )\n      {\n        do\n        {\n          v8 = *(_QWORD *)(v7 + 16);\n          v9 = &v5[*(_DWORD *)(v7 + 12) & (unsigned int)(a2 - 1)];\n          *(_QWORD *)(v7 + 16) = *v9;\n          *v9 = v7;\n          v7 = v8;\n        }\n        while ( v8 );\n      }\n      ++v6;\n    }\n    while ( &v5[(unsigned int)(v4 - 1) + 1] != v6 );\n  }\n  if ( a2 < v4 )\n    *(_QWORD *)(v3 + 48) = sub_ECF0(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n  *(_DWORD *)(v3 + 60) = a2;\n}\n",
    "function_name": "luaS_resize",
    "decompiled_code": "void __fastcall luaS_resize(_QWORD *a1, int a2)\n{\n  __int64 v3; // rbp\n  int v4; // r10d\n  __int64 *v5; // rdi\n  __int64 *v6; // r9\n  __int64 v7; // rax\n  __int64 v8; // rcx\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  _QWORD *v11; // rdx\n  unsigned __int64 v12; // rax\n\n  v3 = a1[3];\n  v4 = *(_DWORD *)(v3 + 60);\n  if ( v4 < a2 )\n  {\n    v10 = luaM_realloc_(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n    v4 = *(_DWORD *)(v3 + 60);\n    *(_QWORD *)(v3 + 48) = v10;\n    if ( a2 > v4 )\n    {\n      v11 = (_QWORD *)(v10 + 8LL * v4);\n      v12 = v10 + 8 * (v4 + (unsigned __int64)(unsigned int)(a2 - 1 - v4)) + 8;\n      do\n        *v11++ = 0LL;\n      while ( v11 != (_QWORD *)v12 );\n    }\n  }\n  if ( v4 > 0 )\n  {\n    v5 = *(__int64 **)(v3 + 48);\n    v6 = v5;\n    do\n    {\n      v7 = *v6;\n      *v6 = 0LL;\n      if ( v7 )\n      {\n        do\n        {\n          v8 = *(_QWORD *)(v7 + 16);\n          v9 = &v5[*(_DWORD *)(v7 + 12) & (unsigned int)(a2 - 1)];\n          *(_QWORD *)(v7 + 16) = *v9;\n          *v9 = v7;\n          v7 = v8;\n        }\n        while ( v8 );\n      }\n      ++v6;\n    }\n    while ( &v5[(unsigned int)(v4 - 1) + 1] != v6 );\n  }\n  if ( a2 < v4 )\n    *(_QWORD *)(v3 + 48) = luaM_realloc_(a1, *(_QWORD *)(v3 + 48), 8LL * v4, 8LL * a2);\n  *(_DWORD *)(v3 + 60) = a2;\n}\n",
    "source_code": "void luaS_resize(lua_State* L, int newsize) {\n  int i;\n  stringtable* tb = &G(L)->strt; // global string table\n  if (newsize > tb->size) { /* grow table if needed */\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n    for (i = tb->size; i < newsize; i++)\n      // open hash table, tb->hash is the pointer for linked list\n      tb->hash[i] = NULL;\n  }\n  for (i = 0; i < tb->size; i++) { /* rehash */\n    TString* p = tb->hash[i];\n    tb->hash[i] = NULL;\n    while (p) { /* for each node in the list */\n      TString* hnext = p->u.hnext; /* save next */\n      unsigned int h = lmod(p->hash, newsize); /* new position */\n      p->u.hnext = tb->hash[h]; /* chain it */\n      tb->hash[h] = p;\n      p = hnext;\n    }\n  }\n  if (newsize < tb->size) { /* shrink table if needed */\n    /* vanishing slice should be empty */\n    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n  }\n  tb->size = newsize;\n}",
    "comment": "Resizes the global string table, rehashes existing strings, and reallocates memory based on the new size provided.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Sorts an array of file names using either ` strcoll ` or ` strcmp ` based on the specified sorting type while managing memory allocation .\n",
    "cpbcs_sum": "Resizes the resources array and clears the non-zero elements from the context's cache if no indices are present.\n",
    "misum_sum": "Inserts a new element into a dynamically allocated array, updating the linked list and initializing it with the specified index and index.\n",
    "decom_sum": "Resizes a hash table to the specified bucket count and rehashes all existing entries into the new table.",
    "cfg_sum": "Resizes a hash table to the specified bucket count and rehashes all existing entries, zero-initializing any newly allocated bucket slots.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary contains only a vague statement about pushing a pointer type, which is unrelated to the actual source code logic of resizing and rehashing the Lua string table. There are no specific or accurate claims matching the implementation details, resulting in no alignment with the evaluation steps.",
                "The summary 'push a pointer type' does not describe the function's primary purpose or any of its observable behavior. The source code implements resizing of Lua's global string table, including growing, shrinking, and rehashing entries, which is entirely unrelated to pushing a pointer type. The claim is inaccurate and misses all key semantic units from the source.",
                "The summary's sole claim ('push a pointer type') is unrelated to the source function, which resizes and rehashes Lua's global string table. This is a NOISE error unrelated to code semantics. Since there is no accurate information provided and the noise is total, the content has no net benefit."
            ]
        },
        "bint5": {
            "summary": "Sorts an array of file names using either ` strcoll ` or ` strcmp ` based on the specified sorting type while managing memory allocation .\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes sorting file names using `strcoll` or `strcmp` with memory management, which is entirely unrelated to the source code. The source code adjusts the size of a Lua string hash table, reallocates memory, and rehashes entries, with no file name sorting or string comparison functions. All claims are inaccurate, leading to no alignment with the source implementation.",
                "The summary's claim about sorting an array of file names using `strcoll` or `strcmp` and managing memory allocation is entirely unrelated to the source code, which resizes Lua's global string table, reallocates its hash array, rehashes entries, and handles growth/shrink operations. The primary purpose and all secondary details of the actual function are missed, and the claim is inaccurate as it describes a different functionality entirely.",
                "The summary claims the function sorts an array of file names using `strcoll` or `strcmp`, which is entirely unrelated to the source code. The source implements resizing and rehashing of Lua's global string table. This mismatch is a FATAL error affecting the primary purpose of the function, making the description highly misleading and unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Resizes the resources array and clears the non-zero elements from the context's cache if no indices are present.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about resizing a 'resources array' and clearing non-zero elements from a 'context's cache' do not match the source code, which resizes a global string hash table, initializes new slots to NULL, and rehashes existing entries. No claim in the summary correctly reflects the implementation, resulting in a lack of accurate correspondence.",
                "The summary does not match the source code's primary purpose or secondary details. The function actually resizes the global string table in Lua, reallocating memory, initializing new slots to NULL, rehashing existing entries, and handling both growth and shrink scenarios. The provided summary incorrectly describes a 'resources array' and clearing a cache, which is unrelated to the source code semantics. Therefore, it misses the primary purpose entirely and contains inaccurate claims.",
                "The summary introduces unrelated concepts such as a 'resources array' and 'context's cache', which do not appear in the source code. The actual function resizes the global string table, reallocates its hash vector, rehashes existing entries, and clears unused slots, none of which are reflected accurately in the summary. This represents a FATAL error in describing the primary purpose and key operations, making the information unreliable."
            ]
        },
        "misum": {
            "summary": "Inserts a new element into a dynamically allocated array, updating the linked list and initializing it with the specified index and index.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly describes the function as inserting a new element into an array with a specified index, which does not match the source code. The actual function resizes and rehashes a string table, reallocating memory and adjusting linked lists for hash buckets, not performing a targeted insertion. This makes the main claim inaccurate, resulting in no accurate claims.",
                "The summary is inaccurate: it claims the function inserts a new element into a dynamically allocated array, which contradicts the source code. The source code resizes a global string hash table, reallocates memory if growing or shrinking, rehashes all existing elements, initializes new slots to NULL when growing, and asserts conditions on shrink. The primary purpose and most secondary details are completely missed, resulting in no accurate coverage.",
                "The summary claims that the function inserts a new element into a dynamically allocated array at a specified index, initializing it accordingly. This is inaccurate: the source code resizes a global string hash table, reallocating memory and rehashing linked list entries, but it does not insert a specific new element at a given index. This is a semantic contradiction about the primary purpose, making it a FATAL error that undermines reliability."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 165072,
    "strip_function_name": "ssl3_get_req_cert_type",
    "strip_decompiled_code": "__int64 __fastcall ssl3_get_req_cert_type(__int64 a1, _BYTE *a2)\n{\n  __int64 v2; // rax\n  __int64 result; // rax\n  __int64 v4; // r10\n  int v5; // r8d\n  __int64 v6; // r9\n  int v7; // ecx\n\n  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 936LL) + 24LL);\n  if ( *(int *)a1 > 768 && (v2 & 0x200) != 0 )\n  {\n    *a2 = 21;\n    a2[1] = 22;\n    return 2LL;\n  }\n  if ( (v2 & 0xA) != 0 )\n  {\n    *a2 = 3;\n    a2[1] = 4;\n    v6 = 3LL;\n    v7 = 4;\n    v4 = 2LL;\n    v5 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  else\n  {\n    v4 = 0LL;\n    v5 = 0;\n    v6 = 1LL;\n    v7 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  if ( (v2 & 0xE) != 0 )\n  {\n    a2[v4] = 5;\n    a2[v6] = 6;\n    LODWORD(v6) = v7 + 1;\n    v4 = v7;\n    v5 = v7;\n    v7 += 2;\n    v6 = (int)v6;\n  }\nLABEL_6:\n  a2[v4] = 1;\n  a2[v6] = 2;\n  if ( (v2 & 0x60) != 0 )\n  {\n    result = (unsigned int)v7;\n    if ( *(int *)a1 <= 768 )\n      return result;\n    a2[v7] = 65;\n    v7 = v5 + 4;\n    a2[v5 + 3] = 66;\n  }\n  result = (unsigned int)v7;\n  if ( *(int *)a1 > 768 )\n  {\n    result = (unsigned int)(v7 + 1);\n    a2[v7] = 64;\n  }\n  return result;\n}\n",
    "function_name": "ssl3_get_req_cert_type",
    "decompiled_code": "__int64 __fastcall ssl3_get_req_cert_type(__int64 a1, _BYTE *a2)\n{\n  __int64 v2; // rax\n  __int64 result; // rax\n  __int64 v4; // r10\n  int v5; // r8d\n  __int64 v6; // r9\n  int v7; // ecx\n\n  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 936LL) + 24LL);\n  if ( *(int *)a1 > 768 && (v2 & 0x200) != 0 )\n  {\n    *a2 = 21;\n    a2[1] = 22;\n    return 2LL;\n  }\n  if ( (v2 & 0xA) != 0 )\n  {\n    *a2 = 3;\n    a2[1] = 4;\n    v6 = 3LL;\n    v7 = 4;\n    v4 = 2LL;\n    v5 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  else\n  {\n    v4 = 0LL;\n    v5 = 0;\n    v6 = 1LL;\n    v7 = 2;\n    if ( *(_DWORD *)a1 != 768 )\n      goto LABEL_6;\n  }\n  if ( (v2 & 0xE) != 0 )\n  {\n    a2[v4] = 5;\n    a2[v6] = 6;\n    LODWORD(v6) = v7 + 1;\n    v4 = v7;\n    v5 = v7;\n    v7 += 2;\n    v6 = (int)v6;\n  }\nLABEL_6:\n  a2[v4] = 1;\n  a2[v6] = 2;\n  if ( (v2 & 0x60) != 0 )\n  {\n    result = (unsigned int)v7;\n    if ( *(int *)a1 <= 768 )\n      return result;\n    a2[v7] = 65;\n    v7 = v5 + 4;\n    a2[v5 + 3] = 66;\n  }\n  result = (unsigned int)v7;\n  if ( *(int *)a1 > 768 )\n  {\n    result = (unsigned int)(v7 + 1);\n    a2[v7] = 64;\n  }\n  return result;\n}\n",
    "source_code": "\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\n\t{\n\tint ret=0;\n\tunsigned long alg_k;\n\n\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n#ifndef OPENSSL_NO_GOST\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tif (alg_k & SSL_kGOST)\n\t\t\t{\n\t\t\tp[ret++]=TLS_CT_GOST94_SIGN;\n\t\t\tp[ret++]=TLS_CT_GOST01_SIGN;\n\t\t\treturn(ret);\n\t\t\t}\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (alg_k & (SSL_kDHr|SSL_kEDH))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_FIXED_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_FIXED_DH;\n#  endif\n\t\t}\n\tif ((s->version == SSL3_VERSION) &&\n\t\t(alg_k & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\n#  endif\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_RSA\n\tp[ret++]=SSL3_CT_RSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_DSA\n\tp[ret++]=SSL3_CT_DSS_SIGN;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->version >= TLS1_VERSION))\n\t\t{\n\t\tp[ret++]=TLS_CT_RSA_FIXED_ECDH;\n\t\tp[ret++]=TLS_CT_ECDSA_FIXED_ECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDSA\n\t/* ECDSA certs can be used with RSA cipher suites as well \n\t * so we don't need to check for SSL_kECDH or SSL_kEECDH\n\t */\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tp[ret++]=TLS_CT_ECDSA_SIGN;\n\t\t}\n#endif\t\n\treturn(ret);\n\t}",
    "comment": "Determines and populates the required certificate types based on the SSL connection's cipher algorithms and version.",
    "hext5_sum": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
    "bint5_sum": "Determines the SSL certificate type based on the handshake message type and updates the provided SSL_CERT_TYPE structure accordingly .\n",
    "cpbcs_sum": "Constructs and sets an OCSP cipher node based on the provided key and supported types, returning the appropriate digest type and permissions.\n",
    "misum_sum": "Constructs and returns a string representation of a DTLS ClientHello message, writing the result to a buffer, while checking for length constraints.\n",
    "decom_sum": "Constructs and returns a list of supported SSL client certificate types in `a2` based on protocol version and connection option bitmask.",
    "cfg_sum": "Constructs a list of requested certificate type codes based on protocol version and bitmask flags, then returns the total number of codes generated.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing a printable version of the given section's name. like print_symbol, except that it does not try to print multibyte characters, it just interprets them as hex values.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer and printing section names have no relation to the actual code, which builds a list of certificate types based on the cipher's key exchange algorithm and protocol version. None of the claims align with the source code's functionality, making them entirely inaccurate.",
                "The summary describes functionality related to returning a pointer to a static buffer with a printable name of a section, which is unrelated to the actual source code. The source function determines acceptable certificate types based on cipher algorithm, protocol version, and configuration macros, and returns the count of types added to the output array. The summary misses the primary purpose entirely, contains no accurate claims about the implementation, and fails to mention any relevant conditions or constants.",
                "The summary describes a function that returns a pointer to a static buffer with a printable version of a section's name, which is unrelated to the actual code. The source code implements ssl3_get_req_cert_type, which populates a provided buffer with certificate type constants based on cipher and version conditions, and returns an integer count. This is a complete semantic mismatch, making the claim entirely inaccurate. The worst failure mode is FATAL, targeting the primary purpose and key I/O incorrectly."
            ]
        },
        "bint5": {
            "summary": "Determines the SSL certificate type based on the handshake message type and updates the provided SSL_CERT_TYPE structure accordingly .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function determines the certificate type based on the handshake message type and updates an SSL_CERT_TYPE structure. In reality, the code determines supported certificate types based on the negotiated cipher's key exchange algorithm and protocol version, fills an array with corresponding constants, and returns their count; there is no reference to handshake message type or an SSL_CERT_TYPE structure. This is a substantive semantic mismatch, making the sole claim inaccurate.",
                "The summary is inaccurate because it describes determining the certificate type based on a handshake message type and updating an SSL_CERT_TYPE structure, which is not shown in the source code. The function instead inspects the cipher's key exchange algorithm and version to append appropriate certificate type codes to the provided buffer and return the count. The primary purpose is missed and there is no coverage of important secondary details such as handling of GOST, DH, RSA, DSA, and ECDSA cases.",
                "The summary claims the function determines the certificate type based on the handshake message type and updates an SSL_CERT_TYPE structure. This is inaccurate: the source code derives acceptable certificate types from the cipher's key algorithm and TLS/SSL version, writing them into the provided buffer, not from a handshake message type, and it does not update any SSL_CERT_TYPE structure. This is a FATAL error impacting the primary purpose description, with no accurate claims present, making it unreliable."
            ]
        },
        "cpbcs": {
            "summary": "Constructs and sets an OCSP cipher node based on the provided key and supported types, returning the appropriate digest type and permissions.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about constructing and setting an OCSP cipher node, returning digest type and permissions are entirely unrelated to the source code, which selects certificate types based on SSL/TLS version and key exchange algorithms. None of the claims match the actual function behavior, resulting in 0% accuracy.",
                "The summary is inaccurate: it mentions constructing and setting an OCSP cipher node, digest type, and permissions, none of which are present in the source code. The actual function determines certificate types supported based on the SSL structure's algorithm key and protocol version, populating them into the provided buffer. The primary purpose is entirely missed, making the claims irrelevant to the CSU list.",
                "The summary's claim that the function constructs and sets an OCSP cipher node and returns a digest type with permissions is entirely inaccurate when compared to the source code. The actual function determines supported certificate types based on key exchange algorithms and protocol version, writes them into the provided buffer, and returns a count. This is a FATAL error in describing the primary purpose and I/O behavior, so the description is unreliable despite having no other useful accurate details."
            ]
        },
        "misum": {
            "summary": "Constructs and returns a string representation of a DTLS ClientHello message, writing the result to a buffer, while checking for length constraints.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary is entirely inaccurate: the source function does not construct a DTLS ClientHello message or write a string representation to a buffer, nor does it check for length constraints. Instead, it determines and populates an array with supported certificate types based on cipher algorithm and protocol version. All claims target semantics but contradict the actual implementation, resulting in no accurate claims.",
                "The summary is entirely inaccurate. The source code defines a function that populates a buffer with appropriate certificate type codes based on the SSL/TLS version and algorithm key, returning the count of types added. It does not construct a DTLS ClientHello message, produce a string representation, or check length constraints. The primary purpose and all secondary details in the source are missed, and the claims target unrelated functionality.",
                "The summary makes a specific claim about constructing and returning a string representation of a DTLS ClientHello message, which is entirely incorrect. The function in the source code determines and writes certificate types to a provided buffer based on the cipher's key exchange algorithm, not related to DTLS ClientHello message construction. This is a FATAL inaccuracy about the primary purpose and I/O, severely misleading the reader."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071583530080,
    "strip_function_name": "sub_FFFFFFFF81477C60",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81477C60(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // r8d\n  int v6; // r9d\n\n  *(_DWORD *)(a2 + 4) = 46;\n  *(_DWORD *)(a2 + 8) = 0;\n  result = sub_FFFFFFFF81477910(a1 + 1856, (_DWORD *)(a2 + 4));\n  if ( (_DWORD)result )\n    return result;\n  result = *(_QWORD *)(a1 + 2696);\n  if ( (*(_BYTE *)(result + 316) & 1) == 0 )\n    return result;\n  if ( *(_WORD *)(a1 + 2934) != 4277 )\n    goto LABEL_15;\n  *(_DWORD *)(a2 + 4) &= ~2u;\n  result = *(unsigned int *)(a1 + 2380);\n  if ( (result & 4) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 3696) & 1) == 0 )\n    {\nLABEL_6:\n      *(_DWORD *)(a2 + 8) |= 2u;\n      result = *(unsigned int *)(a1 + 2380);\n      goto LABEL_7;\n    }\n    sub_FFFFFFFF815DB960(\n      *(_QWORD *)(a1 + 2688),\n      (unsigned int)\"Interface does not support directed (unicast) frame wake-up packets\\n\",\n      v3,\n      v4,\n      v5,\n      v6);\nLABEL_15:\n    result = *(unsigned int *)(a1 + 2380);\n    if ( (result & 4) == 0 )\n      goto LABEL_7;\n    goto LABEL_6;\n  }\nLABEL_7:\n  if ( (result & 8) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 4u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 0x10) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 8u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 2) != 0 )\n    *(_DWORD *)(a2 + 8) |= 0x20u;\n  return result;\n}\n",
    "function_name": "e1000_get_wol",
    "decompiled_code": "__int64 __fastcall e1000_get_wol(\n        __int64 a1,\n        __int64 a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n\n  *(_DWORD *)(a2 + 4) = 46;\n  *(_DWORD *)(a2 + 8) = 0;\n  result = e1000_wol_exclusion_isra_13(a1 + 1856, (_DWORD *)(a2 + 4));\n  if ( (_DWORD)result )\n    return result;\n  result = *(_QWORD *)(a1 + 2696);\n  if ( (*(_BYTE *)(result + 316) & 1) == 0 )\n    return result;\n  if ( *(_WORD *)(a1 + 2934) != 4277 )\n    goto LABEL_15;\n  *(_DWORD *)(a2 + 4) &= ~2u;\n  result = *(unsigned int *)(a1 + 2380);\n  if ( (result & 4) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 3696) & 1) == 0 )\n    {\nLABEL_6:\n      *(_DWORD *)(a2 + 8) |= 2u;\n      result = *(unsigned int *)(a1 + 2380);\n      goto LABEL_7;\n    }\n    netdev_err(\n      *(_QWORD *)(a1 + 2688),\n      (__int64)\"Interface does not support directed (unicast) frame wake-up packets\\n\",\n      a3,\n      a4,\n      a5,\n      a6,\n      v11,\n      v12,\n      a9,\n      a10);\nLABEL_15:\n    result = *(unsigned int *)(a1 + 2380);\n    if ( (result & 4) == 0 )\n      goto LABEL_7;\n    goto LABEL_6;\n  }\nLABEL_7:\n  if ( (result & 8) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 4u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 0x10) != 0 )\n  {\n    *(_DWORD *)(a2 + 8) |= 8u;\n    result = *(unsigned int *)(a1 + 2380);\n  }\n  if ( (result & 2) != 0 )\n    *(_DWORD *)(a2 + 8) |= 0x20u;\n  return result;\n}\n",
    "source_code": "\nstatic void e1000_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t                 WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\t/* this function will set ->supported = 0 and return 1 if wol is not\n\t * supported by this hardware\n\t */\n\tif (e1000_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\t/* apply any specific unsupported masks here */\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t/* KSP3 does not support UCAST wake-ups */\n\t\twol->supported &= ~WAKE_UCAST;\n\n\t\tif (adapter->wol & E1000_WUFC_EX)\n\t\t\te_err(drv, \"Interface does not support directed \"\n\t\t\t      \"(unicast) frame wake-up packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n}",
    "comment": "Configures wake-on-LAN options for the network device based on adapter capabilities and supported wake-up frame types.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Retrieves the Ethernet device 's MAC address , modifying it if necessary , and stores it in the provided ethtool_cmd structure .\n",
    "cpbcs_sum": "Initializes the e1000 network adapter and sets up hardware quirks for the network device and interrupt handling based on its state.\n",
    "misum_sum": "Initializes the PHY device by setting its advertising capabilities and determining the auto-negotiation process based on its current link status and flags.\n",
    "decom_sum": "Configures wake-up packet capability flags for a network interface based on hardware status and supported unicast, multicast, and pattern match features.",
    "cfg_sum": "Configures wake-up capability flags for a network interface based on hardware status, bitmask checks, and support for directed frame wake-up packets.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary contains only the vague statement 'push a pointer type,' which does not correspond to any specific behavior or semantics in the provided source code. It fails to identify any factual claims about the Wake-on-LAN logic, supported flags, hardware conditions, or function behavior. As there are no accurate claims to evaluate, the proportion of correct information is effectively zero.",
                "The summary 'push a pointer type' is vague, unrelated to the source code\u2019s functionality, and fails to identify the primary purpose, which is populating ethtool Wake-on-LAN information based on hardware capabilities and adapter settings. No secondary details or constants from the code are addressed, making it entirely inaccurate.",
                "The summary's single claim 'push a pointer type' does not match any aspect of the source code's functionality, which is concerned with configuring Wake-on-LAN settings for a network device. This is pure NOISE with no ACCURATE claims present, providing no benefit and making it unreliable."
            ]
        },
        "bint5": {
            "summary": "Retrieves the Ethernet device 's MAC address , modifying it if necessary , and stores it in the provided ethtool_cmd structure .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves and possibly modifies the Ethernet device's MAC address and stores it in an ethtool_cmd structure, which contradicts the source code. The source function instead configures Wake-on-LAN options in an ethtool_wolinfo structure and contains no logic for MAC address retrieval or modification. All claims are inaccurate, resulting in no alignment with the source's semantics.",
                "The summary is completely inaccurate; it describes retrieving and possibly modifying a MAC address into an ethtool_cmd structure, which is unrelated to the source code's actual function of populating an ethtool_wolinfo structure with supported and configured Wake-on-LAN options. It fails to capture the primary purpose or any secondary details from the implementation.",
                "The summary claims the function retrieves and possibly modifies the Ethernet device's MAC address and stores it in an ethtool_cmd structure. This is entirely inaccurate: the source code handles Wake-on-LAN capabilities, setting supported wake-up types and current options in an ethtool_wolinfo structure. This mismatch targets the primary purpose and key I/O of the function, making it a FATAL error."
            ]
        },
        "cpbcs": {
            "summary": "Initializes the e1000 network adapter and sets up hardware quirks for the network device and interrupt handling based on its state.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claim that the function initializes the e1000 network adapter and sets up hardware quirks for network device and interrupt handling is inaccurate. The source code shows a function that populates a struct ethtool_wolinfo with supported wake-on-LAN capabilities, applies exclusions, and sets wol options based on adapter configuration\u2014not initialization of the adapter or interrupt handling. This is a clear semantic mismatch, with none of the claims aligning with the implementation.",
                "The summary incorrectly describes the function as initializing the e1000 network adapter and configuring hardware quirks and interrupt handling, which contradicts the actual implementation. The source code shows the function retrieves and configures Wake-on-LAN settings, checks hardware support, applies device-specific masks, and sets wol options based on adapter flags. The primary purpose and secondary details in the source code are entirely missed, leading to no accurate claim coverage.",
                "The summary inaccurately claims that the function initializes the e1000 network adapter and sets up hardware quirks for interrupt handling, which contradicts the source code. The actual function retrieves and sets wake-on-LAN capabilities (supported types and selected options) based on hardware support and adapter settings. This is a FATAL error targeting primary purpose and key I/O, resulting in high negative impact and no alignment with the source logic."
            ]
        },
        "misum": {
            "summary": "Initializes the PHY device by setting its advertising capabilities and determining the auto-negotiation process based on its current link status and flags.\n",
            "score": [
                0.0,
                0.1,
                0.1
            ],
            "reason": [
                "The summary describes PHY initialization, advertising capabilities, and auto-negotiation, none of which occur in the provided function. The actual code retrieves and sets Wake-on-LAN settings for a network device, including supported modes and options, making the summary entirely inaccurate.",
                "The summary is entirely inaccurate: it describes initializing a PHY device, setting advertising capabilities, and handling auto-negotiation, none of which occur in the source code. The function in the source retrieves and sets Wake-on-LAN information for a network device, including supported modes, hardware-specific exclusions, and wolopts flags. The primary purpose is missed completely, and no accurate claims match the implementation.",
                "The summary describes initializing a PHY device and managing auto-negotiation based on link status, which is unrelated to the source code. The actual function `e1000_get_wol` deals with configuring Wake-on-LAN support and options, not PHY setup or link negotiation. This is a NOISE failure with no accurate claims, resulting in no useful alignment with the code."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071578930512,
    "strip_function_name": "sub_FFFFFFFF81014D50",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81014D50(__int64 a1)\n{\n  __int64 v1; // rbx\n  int v2; // eax\n  int v3; // edx\n  int v4; // edx\n  __int64 result; // rax\n  int v6; // edx\n  __int64 v7; // rcx\n  __int64 i; // rax\n  __int64 v9; // rsi\n\n  if ( !dword_FFFFFFFF81CB5600 )\n    return 4294967201LL;\n  v1 = *(_QWORD *)(a1 + 232);\n  v2 = *(_DWORD *)(a1 + 232) & 1;\n  if ( (v1 & 2) != 0 )\n  {\n    if ( dword_FFFFFFFF81CB8498 > 1 && !(unsigned __int8)sub_FFFFFFFF81047B60(21LL) )\n      return 4294967283LL;\n    v2 = v1 & 1 | 2;\n  }\n  if ( (v1 & 8) != 0 )\n    v2 |= 0xFFCu;\n  if ( (v1 & 0x10) != 0 )\n    v2 |= 0xC54u;\n  v3 = v2;\n  if ( (v1 & 0x20) != 0 )\n  {\n    LOBYTE(v3) = v2 | 0xA8;\n    v2 = v3;\n  }\n  v4 = v2;\n  if ( (v1 & 0x40) != 0 )\n  {\n    BYTE1(v4) = BYTE1(v2) | 8;\n    v2 = v4;\n  }\n  *(_DWORD *)(a1 + 344) = v2;\n  result = 0LL;\n  if ( qword_FFFFFFFF81CB5610 )\n  {\n    v6 = 7;\n    v7 = 0LL;\n    for ( i = 1LL; ; i *= 2LL )\n    {\n      if ( (i & *(_QWORD *)(a1 + 232)) != 0 )\n      {\n        v9 = *(int *)(qword_FFFFFFFF81CB5610 + 4 * i);\n        if ( v9 == -1 )\n          return 4294967201LL;\n        v7 |= v9;\n      }\n      if ( !--v6 )\n      {\n        *(_DWORD *)(a1 + 352) = 2;\n        result = 0LL;\n        *(_QWORD *)(a1 + 336) = qword_FFFFFFFF81CB5608 & ~v7;\n        return result;\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "intel_pmu_setup_lbr_filter",
    "decompiled_code": "__int64 __fastcall intel_pmu_setup_lbr_filter(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rbx\n  int v7; // eax\n  int v8; // edx\n  int v9; // edx\n  __int64 result; // rax\n  int v11; // edx\n  __int64 v12; // rcx\n  __int64 i; // rax\n  __int64 v14; // rsi\n\n  if ( !dword_FFFFFFFF81CB5600 )\n    return 4294967201LL;\n  v6 = *(_QWORD *)(a1 + 232);\n  v7 = *(_DWORD *)(a1 + 232) & 1;\n  if ( (v6 & 2) != 0 )\n  {\n    if ( sysctl_perf_event_paranoid > 1 && !(unsigned __int8)capable(0x15u, a2, a3, a4, a5, a6) )\n      return 4294967283LL;\n    v7 = v6 & 1 | 2;\n  }\n  if ( (v6 & 8) != 0 )\n    v7 |= 0xFFCu;\n  if ( (v6 & 0x10) != 0 )\n    v7 |= 0xC54u;\n  v8 = v7;\n  if ( (v6 & 0x20) != 0 )\n  {\n    LOBYTE(v8) = v7 | 0xA8;\n    v7 = v8;\n  }\n  v9 = v7;\n  if ( (v6 & 0x40) != 0 )\n  {\n    BYTE1(v9) = BYTE1(v7) | 8;\n    v7 = v9;\n  }\n  *(_DWORD *)(a1 + 344) = v7;\n  result = 0LL;\n  if ( qword_FFFFFFFF81CB5610 )\n  {\n    v11 = 7;\n    v12 = 0LL;\n    for ( i = 1LL; ; i *= 2LL )\n    {\n      if ( (i & *(_QWORD *)(a1 + 232)) != 0 )\n      {\n        v14 = *(int *)(qword_FFFFFFFF81CB5610 + 4 * i);\n        if ( v14 == -1 )\n          return 4294967201LL;\n        v12 |= v14;\n      }\n      if ( !--v11 )\n      {\n        *(_DWORD *)(a1 + 352) = 2;\n        result = 0LL;\n        *(_QWORD *)(a1 + 336) = qword_FFFFFFFF81CB5608 & ~v12;\n        return result;\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint intel_pmu_setup_lbr_filter(struct perf_event *event)\n{\n\tint ret = 0;\n\n\t/*\n\t * no LBR on this PMU\n\t */\n\tif (!x86_pmu.lbr_nr)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * setup SW LBR filter\n\t */\n\tret = intel_pmu_setup_sw_lbr_filter(event);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * setup HW LBR filter, if any\n\t */\n\tif (x86_pmu.lbr_sel_map)\n\t\tret = intel_pmu_setup_hw_lbr_filter(event);\n\n\treturn ret;\n}",
    "comment": "Configures both software and hardware LBR filters for a performance event if LBR support is available on the PMU.",
    "hext5_sum": " a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
    "bint5_sum": "Configures performance monitoring event registers for Intel PMU , enabling or disabling features based on event configuration and CPU capabilities .\n",
    "cpbcs_sum": "Initializes performance monitoring events for a performance event by setting event attributes based on event flags and updating event counts accordingly.\n",
    "misum_sum": "Initializes uncore performance monitoring unit architecture by configuring event attributes and validating CPU model settings.\n",
    "decom_sum": "Configures device control flags from bitmask at offset 232, validates conditions, and updates related state fields and masks in the provided structure.",
    "cfg_sum": "Validates configuration flags from the input structure, applies corresponding state updates, and returns specific error codes when validation fails or disabled entries are detected.",
    "work_score": {
        "hext5": {
            "summary": " a stack frame looks like this: %fp0->| | | args to next subroutine | %sp0->| one word struct-ret address | | | previous frame pointer (%fp0)| | | local variables |",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary describes the layout of a stack frame using registers like %fp0 and %sp0, which is unrelated to the source code's logic for setting up LBR filters in a performance monitoring unit. None of the claims address or match the functions, conditions, or semantics in the code, resulting in 0% accurate claims.",
                "The summary describes stack frame layout details using register names and memory arrangement, which is unrelated to the source code\u2019s purpose of setting up LBR filters for a perf event. It does not capture the primary purpose, inputs, outputs, conditional checks, or function calls present in the implementation, making all claims irrelevant and inaccurate.",
                "The summary describes a generic stack frame layout, which is unrelated to the provided source code implementing `intel_pmu_setup_lbr_filter`. All claims are NOISE, with no accurate alignment to the code\u2019s purpose, inputs, or outputs. The worst failure mode is overwhelming NOISE, resulting in no useful insight for understanding the implementation."
            ]
        },
        "bint5": {
            "summary": "Configures performance monitoring event registers for Intel PMU , enabling or disabling features based on event configuration and CPU capabilities .\n",
            "score": [
                0.2,
                0.2,
                0.5
            ],
            "reason": [
                "The summary makes broad claims about configuring performance monitoring registers and enabling/disabling features, but the source code specifically sets up software and hardware LBR filters for Intel PMU based on CPU capabilities. The summary omits the focus on LBR filters and introduces unspecified 'event registers' and general enable/disable behavior, which are not evident in the source. This results in a low proportion of accurate claims, with most being too vague or slightly misleading in relation to the actual implementation.",
                "The summary broadly states configuration of PMU registers and feature enablement but fails to capture the primary purpose, which is setting up LBR filters for an event in Intel PMUs. It omits key flow details such as checking for LBR support, invoking software and hardware filter setup functions, and handling different return codes. Although not contradictory, it is too generic and does not align closely with the specific implementation semantics.",
                "The summary contains a broad SAFE claim about configuring PMU registers based on event configuration and CPU capabilities, which loosely matches the code\u2019s conditional setup of software and hardware LBR filters depending on PMU state. However, it lacks specific details from the source such as the use of LBR filters, specific functions called, or early return on unsupported PMUs. There are no clear inaccuracies, but the information is generic and provides low insight, resulting in low gain without fatal errors."
            ]
        },
        "cpbcs": {
            "summary": "Initializes performance monitoring events for a performance event by setting event attributes based on event flags and updating event counts accordingly.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes performance monitoring events by setting attributes based on event flags and updating event counts, which does not align with the source code. The actual implementation checks for LBR support, sets up software and possibly hardware LBR filters, and returns an appropriate status code. None of the summary's described actions (event attributes, flags, counts) are present, making the claims inaccurate.",
                "The summary fails to identify the primary purpose \u2014 configuring LBR filters for a perf event on Intel PMUs, including the conditions for no LBR support and separate setup for software and possibly hardware filters. It instead inaccurately describes initializing performance monitoring events with attribute setting and count updates, which is not reflected in the source. This misalignment shows it misses both the primary purpose and key secondary details, with most claims inaccurate to the source code.",
                "The summary's claims about initializing performance monitoring events, setting event attributes based on flags, and updating event counts are inaccurate relative to the source. The code instead checks for LBR support, sets up SW and optionally HW LBR filters, and returns relevant error codes. This is a semantic mismatch on the primary purpose of the function, constituting a FATAL error that misrepresents its core behavior."
            ]
        },
        "misum": {
            "summary": "Initializes uncore performance monitoring unit architecture by configuring event attributes and validating CPU model settings.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function initializes an uncore PMU by configuring event attributes and validating CPU model settings, which does not match the source code. The code configures last branch recording (LBR) filters for a PMU, checks for LBR availability, and sets up software/hardware LBR filters, without reference to uncore PMUs, CPU model validation, or general event attribute configuration. All claims are inaccurate, leading to no alignment.",
                "The summary claims the function initializes an uncore PMU and validates CPU model settings, which is inaccurate. The source code shows the function specifically sets up LBR filtering for a perf_event on an x86 PMU, with checks for LBR availability and calls to setup software and optionally hardware LBR filters. The summary misses the primary purpose and all secondary details in the source implementation, instead describing unrelated functionality.",
                "The summary claims the function initializes an uncore PMU by configuring event attributes and validating CPU model settings. This is inaccurate because the source code is for setting up LBR filters for events on an x86 PMU, not uncore PMU initialization, CPU model validation, or generic event attribute configuration. This is a FATAL error targeting the primary purpose of the function, leading to low reliability and high negative impact."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071592452338,
    "strip_function_name": "sub_FFFFFFFF81CFA0F2",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81CFA0F2(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8)\n{\n  __int64 v8; // rbx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int i; // eax\n  unsigned __int64 v14; // rsi\n  __int64 v15; // rcx\n  int j; // eax\n\n  v8 = 0LL;\n  sub_FFFFFFFF8178A70F((__int64)&unk_FFFFFFFF819A0BD2, a1, a2, a3, a4, a5, a6, a7, a8, \"dquot_6.5.2\");\n  sub_FFFFFFFF8119FA40(off_FFFFFFFF81C40A00, a1, a2, a3, a4, v9, v10, a7, a8);\n  qword_FFFFFFFF81E936D0 = sub_FFFFFFFF811057E0((__int64)\"dquot\", 0xF0uLL, 0x20uLL, 1449984, 0LL);\n  qword_FFFFFFFF81E936C0 = sub_FFFFFFFF810EB290(32LL, 0LL);\n  if ( !qword_FFFFFFFF81E936C0 )\n    sub_FFFFFFFF8178A51B((__int64)\"Cannot create dquot hash table\", a1, a2, a3, a4, v11, v12, a7, a8);\n  do\n  {\n    if ( (unsigned int)sub_FFFFFFFF812C77E0((__int64)&unk_FFFFFFFF81E93580 + v8, 0LL, a1, a2, a3, a4, v11, v12, a7, a8) )\n      sub_FFFFFFFF8178A51B((__int64)\"Cannot create dquot stat counters\", a1, a2, a3, a4, v11, v12, a7, a8);\n    v8 += 40LL;\n  }\n  while ( v8 != 320 );\n  for ( i = 0; 0x200uLL >> ((unsigned __int8)i + 1); ++i )\n    ;\n  dword_FFFFFFFF81E936CC = i;\n  v14 = 1LL << i;\n  v15 = qword_FFFFFFFF81E936C0;\n  dword_FFFFFFFF81E936C8 = (1LL << i) - 1;\n  for ( j = 0; v14 > j; ++j )\n    *(_QWORD *)(v15 + 8LL * j) = 0LL;\n  sub_FFFFFFFF8178A70F(\n    (__int64)\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n    a1,\n    a2,\n    a3,\n    a4,\n    v11,\n    v12,\n    a7,\n    a8,\n    v14,\n    0LL,\n    4096LL);\n  sub_FFFFFFFF810F5F40((__int64)&off_FFFFFFFF81C40D40);\n  return 0LL;\n}\n",
    "function_name": "dquot_init",
    "decompiled_code": "__int64 __fastcall dquot_init(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)\n{\n  __int64 v8; // rbx\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  double v13; // xmm4_8\n  double v14; // xmm5_8\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  int i; // eax\n  unsigned __int64 v18; // rsi\n  __int64 v19; // rcx\n  int j; // eax\n\n  v8 = 0LL;\n  printk((__int64)&unk_FFFFFFFF819A0BD2, a1, a2, a3, a4, a5, a6, a7, a8, \"dquot_6.5.2\");\n  register_sysctl_table((__int64 **)sys_table, a1, a2, a3, a4, v9, v10, a7, a8);\n  dquot_cachep = (__int64)kmem_cache_create(\n                            (__int64 *)\"dquot\",\n                            0xF0uLL,\n                            0x20uLL,\n                            1449984,\n                            0LL,\n                            a1,\n                            a2,\n                            a3,\n                            a4,\n                            v11,\n                            v12,\n                            a7,\n                            a8);\n  dquot_hash = _get_free_pages(0x20u, 0, a1, a2, a3, a4, v13, v14, a7, a8);\n  if ( !dquot_hash )\n    panic((__int64)\"Cannot create dquot hash table\", a1, a2, a3, a4, v15, v16, a7, a8);\n  do\n  {\n    if ( (unsigned int)_percpu_counter_init((__int64)&unk_FFFFFFFF81E93580 + v8, 0LL, a1, a2, a3, a4, v15, v16, a7, a8) )\n      panic((__int64)\"Cannot create dquot stat counters\", a1, a2, a3, a4, v15, v16, a7, a8);\n    v8 += 40LL;\n  }\n  while ( v8 != 320 );\n  for ( i = 0; 0x200uLL >> ((unsigned __int8)i + 1); ++i )\n    ;\n  dq_hash_bits = i;\n  v18 = 1LL << i;\n  v19 = dquot_hash;\n  dq_hash_mask = (1LL << i) - 1;\n  for ( j = 0; v18 > j; ++j )\n    *(_QWORD *)(v19 + 8LL * j) = 0LL;\n  printk(\n    (__int64)\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n    a1,\n    a2,\n    a3,\n    a4,\n    v15,\n    v16,\n    a7,\n    a8,\n    v18,\n    0LL,\n    4096LL);\n  register_shrinker((__int64)&dqcache_shrinker, v18);\n  return 0LL;\n}\n",
    "source_code": "\nstatic int __init dquot_init(void)\n{\n\tint i, ret;\n\tunsigned long nr_hash, order;\n\n\tprintk(KERN_NOTICE \"VFS: Disk quotas %s\\n\", __DQUOT_VERSION__);\n\n\tregister_sysctl_table(sys_table);\n\n\tdquot_cachep = kmem_cache_create(\"dquot\",\n\t\t\tsizeof(struct dquot), sizeof(unsigned long) * 4,\n\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tNULL);\n\n\torder = 0;\n\tdquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);\n\tif (!dquot_hash)\n\t\tpanic(\"Cannot create dquot hash table\");\n\n\tfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\n\t\tret = percpu_counter_init(&dqstats.counter[i], 0);\n\t\tif (ret)\n\t\t\tpanic(\"Cannot create dquot stat counters\");\n\t}\n\n\t/* Find power-of-two hlist_heads which can fit into allocation */\n\tnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\n\tdq_hash_bits = 0;\n\tdo {\n\t\tdq_hash_bits++;\n\t} while (nr_hash >> dq_hash_bits);\n\tdq_hash_bits--;\n\n\tnr_hash = 1UL << dq_hash_bits;\n\tdq_hash_mask = nr_hash - 1;\n\tfor (i = 0; i < nr_hash; i++)\n\t\tINIT_HLIST_HEAD(dquot_hash + i);\n\n\tprintk(\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n\t\t\tnr_hash, order, (PAGE_SIZE << order));\n\n\tregister_shrinker(&dqcache_shrinker);\n\n\treturn 0;\n}",
    "comment": "Initializes the disk quota subsystem by creating a cache, allocating a hash table, and setting up statistical counters.",
    "hext5_sum": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
    "bint5_sum": "Initializes the dquot subsystem by registering the sysctl table and creating a sysctl table for dynamic device management .\n",
    "cpbcs_sum": "Initializes memory management caches, including page allocation numbers and a sysctl table, while ensuring thread safety with a mutex.\n",
    "misum_sum": "Initializes memory management caches, sets up CPU-specific entries, and prepares for available page lists, and registers the cache for writeback operations.\n",
    "decom_sum": "Initializes the disk quota subsystem by creating the dquot hash table, allocating stat counters, and logging cache configuration details.",
    "cfg_sum": "Initializes quota management structures, creates and configures the dquot hash table and statistics counters, and logs configuration details while handling initialization errors.",
    "work_score": {
        "hext5": {
            "summary": "returns a pointer to a static buffer containing the converted value. the value is converted according to the printf formating character fmtch. if num_bytes is non-zero then it specifies the maximum number of bytes to be displayed in the converted value and fmtch is ignored - hex is always used.",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary's claims about returning a pointer to a static buffer, applying printf formatting, handling num_bytes with hex output, and ignoring fmtch do not align with the provided source code, which initializes disk quota structures and hash tables without any value conversion or formatting logic. All claims are unrelated to the code, resulting in no accurate statements.",
                "The summary describes a function that returns a pointer to a static buffer containing a converted value using printf formatting, which is entirely unrelated to the source code provided. The source code initializes disk quota structures, registers system tables and shrinkers, allocates hash tables, and sets up counters, with no buffer conversion or printf formatting behavior. The summary misses the primary purpose and all secondary details of the function, making all claims inaccurate.",
                "All claims in the summary describe behavior related to string conversion and printf formatting, which is entirely unrelated to the source code\u2019s actual functionality of initializing disk quota structures, caches, hash tables, and counters. This is pure NOISE with no overlap to the code semantics, making the summary completely unaligned and providing zero useful insight."
            ]
        },
        "bint5": {
            "summary": "Initializes the dquot subsystem by registering the sysctl table and creating a sysctl table for dynamic device management .\n",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary correctly notes that the function registers a sysctl table, which matches the source code. However, it inaccurately claims creation of a sysctl table for dynamic device management, which is not present in the code. The function instead creates a kmem cache and initializes quota-related data structures. This results in less than half of the claims being accurate.",
                "The summary correctly notes that the function initializes part of the dquot subsystem and registers a sysctl table, aligning with the code\u2019s primary purpose. However, it inaccurately adds that it creates a sysctl table for dynamic device management, which is not reflected in the source. It omits critical secondary details such as cache creation, hash table allocation and initialization, panic handling when allocations fail, counter initialization, hash bit/mask calculation, and registering a shrinker, resulting in incomplete coverage.",
                "The summary makes two claims: (1) initializes the dquot subsystem by registering the sysctl table [ACCURATE - the code calls register_sysctl_table], (2) creates a sysctl table for dynamic device management [INACCURATE - the code does not indicate dynamic device management; it creates a dquot cache, hash table, and counters for disk quota handling]. The second claim is a FATAL error because it misidentifies the primary purpose of the initialization, substituting an unrelated \u2018dynamic device management\u2019 role for the actual disk quota initialization, making the description misleading for key functionality."
            ]
        },
        "cpbcs": {
            "summary": "Initializes memory management caches, including page allocation numbers and a sysctl table, while ensuring thread safety with a mutex.\n",
            "score": [
                0.3,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims memory management caches are initialized and page allocation numbers are handled, which aligns partially with the code's initialization of caches, allocation of pages, and sysctl table registration. However, it inaccurately states that thread safety is ensured with a mutex, which is not present in the source; the code uses other mechanisms like percpu counters and panic handling. This introduces a major semantic mismatch, leaving less than half of the claims accurate.",
                "The summary misses the primary purpose of initializing disk quota structures and related data (e.g., dquot_cachep, dquot_hash, dqstats), and introduces an inaccurate detail about ensuring thread safety with a mutex, which is not present in the source. While it correctly mentions sysctl table registration and some memory allocation, it omits key secondary details like panic handling, hash table setup, and shrinker registration.",
                "The summary contains one accurate, low-detail claim about initializing memory management caches and registering a sysctl table, which aligns broadly with `kmem_cache_create` and `register_sysctl_table` in the source. However, it introduces an inaccurate claim about ensuring thread safety with a mutex, which is not present in the code. This is a FATAL error targeting a key side effect, since mutex-based thread safety is not implemented at all. Due to the presence of this FATAL in a primary purpose area, reliability is heavily compromised."
            ]
        },
        "misum": {
            "summary": "Initializes memory management caches, sets up CPU-specific entries, and prepares for available page lists, and registers the cache for writeback operations.\n",
            "score": [
                0.2,
                0.2,
                0.4
            ],
            "reason": [
                "The summary contains mostly inaccurate claims about the code: it does initialize a slab cache and CPU-specific stat counters, which is somewhat accurate, but it incorrectly describes preparing available page lists or registering cache for writeback, which the source code does not do. Less than half of the claims align with the code implementation.",
                "The summary captures a vague notion of initialization but misses the primary purpose of initializing disk quota structures, hash tables, per-CPU counters, and registering relevant sysctl and shrinker components. It incorrectly mentions preparing available page lists and writeback registration, which are not present in the source code. While 'initializes memory management caches' loosely fits the kmem_cache_create step, most secondary details and the core disk quota context are absent or replaced with inaccurate elements.",
                "The summary contains multiple inaccurate claims. It mentions setting up CPU-specific entries, which loosely matches the percpu counter initialization, but incorrectly states preparing for available page lists and registering the cache for writeback, which are not present in the source code. These are NOISE errors and do not reflect actual logic. No FATAL errors targeting primary purpose are present, but the majority of content is inaccurate, giving low net benefit and minimal accurate details beyond generic initialization references."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071586672864,
    "strip_function_name": "sub_FFFFFFFF817770E0",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF817770E0(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v11; // rsi\n  char *v12; // rax\n  __int64 *v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  char *v19; // rbx\n  __int64 v20; // r14\n  unsigned int v21; // r12d\n  __int64 result; // rax\n  __int64 v23[4]; // [rsp+7h] [rbp-21h] BYREF\n\n  v11 = 208LL;\n  v12 = (char *)sub_FFFFFFFF815CF830(3776, 0xD0u, 0, 0xFFFFFFFF, a1, a2, a3, a4, a5, a6, a7, a8);\n  v19 = v12;\n  if ( !v12 )\n  {\n    v21 = -22;\n    goto LABEL_4;\n  }\n  v11 = *(unsigned int *)(a10 + 4);\n  v20 = sub_FFFFFFFF81607D60(v12, v11, *(_DWORD *)a10, dword_FFFFFFFF81CA0800, 0, 2);\n  if ( !v20 )\n  {\n    v21 = -12;\n    goto LABEL_4;\n  }\n  v11 = 1LL;\n  LOBYTE(v23[0]) = byte_FFFFFFFF81EBF448;\n  v21 = sub_FFFFFFFF812C91D0(v19, 1, 1LL, v23);\n  if ( v21 )\n  {\nLABEL_4:\n    sub_FFFFFFFF815CFEE0(\n      (unsigned __int64)v19,\n      (volatile signed __int32 *)v11,\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8);\n    return v21;\n  }\n  *(_DWORD *)(v20 - 20) = *((_DWORD *)v19 + 52) + *((_DWORD *)v19 + 49) - (v20 - 20);\n  result = sub_FFFFFFFF81607160(\n             *(_QWORD *)(*(_QWORD *)(a10 + 40) + 192LL),\n             (unsigned __int64)v19,\n             *(unsigned int *)(a10 + 4),\n             64LL,\n             v15,\n             v16,\n             a1,\n             a2,\n             a3,\n             a4,\n             v17,\n             v18,\n             a7,\n             a8);\n  if ( (int)result > 0 )\n    return 0LL;\n  return result;\n}\n",
    "function_name": "netlbl_unlabel_list",
    "decompiled_code": "__int64 __fastcall netlbl_unlabel_list(\n        double a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v11; // rsi\n  char *v12; // rax\n  __int64 *v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  int v16; // r9d\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  char *v19; // rbx\n  __int64 v20; // r14\n  unsigned int v21; // r12d\n  __int64 result; // rax\n  __int64 v23[4]; // [rsp+7h] [rbp-21h] BYREF\n\n  v11 = 208LL;\n  v12 = (char *)_alloc_skb(3776, 0xD0u, 0, -1, a1, a2, a3, a4, a5, a6, a7, a8);\n  v19 = v12;\n  if ( !v12 )\n  {\n    v21 = -22;\n    goto LABEL_4;\n  }\n  v11 = *(unsigned int *)(a10 + 4);\n  v20 = genlmsg_put(v12, v11, *(_DWORD *)a10, netlbl_unlabel_gnl_family, 0, 2, a1, a2, a3, a4, v17, v18, a7, a8);\n  if ( !v20 )\n  {\n    v21 = -12;\n    goto LABEL_4;\n  }\n  v11 = 1LL;\n  LOBYTE(v23[0]) = netlabel_unlabel_acceptflg;\n  v21 = nla_put(v19, 1, 1, v23);\n  if ( v21 )\n  {\nLABEL_4:\n    kfree_skb(\n      (volatile signed __int32 *)v19,\n      (volatile signed __int32 *)v11,\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8);\n    return v21;\n  }\n  *(_DWORD *)(v20 - 20) = *((_DWORD *)v19 + 52) + *((_DWORD *)v19 + 49) - (v20 - 20);\n  result = netlink_unicast(\n             *(_QWORD *)(*(_QWORD *)(a10 + 40) + 192LL),\n             (__int64)v19,\n             *(_DWORD *)(a10 + 4),\n             64,\n             a1,\n             a2,\n             a3,\n             a4,\n             v17,\n             v18,\n             a7,\n             a8);\n  if ( (int)result > 0 )\n    return 0LL;\n  return result;\n}\n",
    "source_code": "static int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct sk_buff *ans_skb;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\tgoto list_failure;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\n\t\t\t\t 0, NLBL_UNLABEL_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u8(ans_skb,\n\t\t\t     NLBL_UNLABEL_A_ACPTFLG,\n\t\t\t     netlabel_unlabel_acceptflg);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}",
    "comment": "Generates and replies with a netlabel unlabeling response containing an acceptance flag in a netlink message or returns an error.",
    "hext5_sum": "1f1(b+eps,b,x) |eps|<=1, b > 0",
    "bint5_sum": "Generates and sends a Netlink message containing the protocol version in response to a management query .\n",
    "cpbcs_sum": "Retrieves and lists a network label domain mapping entry, responding to a Generic Netlink request within kernel space.\n",
    "misum_sum": "Retrieves the transmission and protocol of a network device based on the protocol version and protocol from the nl80211 protocol.\n",
    "decom_sum": "Allocates and initializes a communication object, configures it with parameters, then sends data to a hardware device and returns the operation status.",
    "cfg_sum": "Allocates and configures a data structure using provided parameters, performs initialization checks, updates metadata, and executes a final operation, returning success or specific error codes.",
    "work_score": {
        "hext5": {
            "summary": "1f1(b+eps,b,x) |eps|<=1, b > 0",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains mathematical notation unrelated to the source code, which is about a kernel function handling netlabel unlabel list operations and error handling. None of the claims in the summary target or align with the code\u2019s semantics, so there are no accurate claims to score.",
                "The summary contains mathematical notation unrelated to the source function, which constructs and sends a generic netlink reply with specific attributes and error handling. None of the claims address the primary purpose, input/output behavior, or secondary implementation details of the code, resulting in no accurate coverage.",
                "The summary contains only a mathematical expression unrelated to the source code\u2019s function, inputs, or outputs, making it entirely [INACCURATE] as NOISE. There are no fact-based claims about the source\u2019s semantics, structure, or behavior, resulting in zero alignment and no useful insights."
            ]
        },
        "bint5": {
            "summary": "Generates and sends a Netlink message containing the protocol version in response to a management query .\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function generates and sends a Netlink message containing the protocol version, but the source code shows it sends a message containing the accept flag value (netlabel_unlabel_acceptflg) instead. This is a clear semantic mismatch, making the claim inaccurate with no other accurate statements present.",
                "The summary misidentifies the content of the Netlink message as containing a protocol version, which is not present in the source code. The function's primary purpose is to construct and send a Netlink reply containing an acceptance flag (netlabel_unlabel_acceptflg), not a protocol version, so the primary purpose was missed. While it correctly mentions generating and sending a Netlink message in response to a query, key details about message contents, allocation failure handling, and constants are completely absent.",
                "The summary\u2019s claim that the function sends a Netlink message containing the protocol version is inaccurate. The source code actually sends a message containing an accept flag (netlabel_unlabel_acceptflg), not a protocol version. This is a FATAL error targeting key I/O semantics, undermining trust in the summary\u2019s reliability. There are no accurate or useful details present to offset this negative impact."
            ]
        },
        "cpbcs": {
            "summary": "Retrieves and lists a network label domain mapping entry, responding to a Generic Netlink request within kernel space.\n",
            "score": [
                0.1,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves and lists a network label domain mapping entry, which is inaccurate because the source code instead constructs a Generic Netlink reply containing an \"unlabel accept\" flag. There is no evidence in the code of listing or retrieving domain mapping entries. This is a semantic mismatch, and all claims are inaccurate according to the evaluation steps.",
                "The summary incorrectly states that the function retrieves and lists a network label domain mapping entry, which is not evident in the code. The actual primary purpose is to create and send a Generic Netlink reply containing the netlabel unlabel accept flag. While it does respond to a Generic Netlink request in kernel space\u2014capturing part of the primary context\u2014the summary misses key behaviors such as message creation, memory allocation checks, error handling paths, and inclusion of NLBL_UNLABEL_A_ACPTFLG. This misrepresentation of the main functionality and omission of critical details results in very low alignment.",
                "The summary claims the function retrieves and lists a network label domain mapping entry, but the source code shows it constructs and sends a Generic Netlink reply containing only the unlabel accept flag, not a domain mapping list. This is a FATAL inaccuracy targeting the primary purpose of the function. There are no accurate or helpful specifics; the description is misleading and contradicts the code's semantics."
            ]
        },
        "misum": {
            "summary": "Retrieves the transmission and protocol of a network device based on the protocol version and protocol from the nl80211 protocol.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves transmission and protocol information from the nl80211 protocol, which is unrelated to the source code. The source code instead constructs and sends a netlabel unlabel list reply, managing memory and error handling. None of the claims match the source implementation, resulting in all being inaccurate.",
                "The summary is entirely inaccurate: it describes retrieving transmission and protocol info from the nl80211 protocol, which is unrelated to the provided source code. The source handles creating and sending a generic netlink reply for unlabeling, including allocating a skb, populating message data, handling memory errors, and returning a result. It misses the primary purpose and all secondary details of the actual function implementation.",
                "The summary claims the function retrieves transmission and protocol details of a network device via nl80211, which is entirely unrelated to the source code. The actual code constructs and sends a generic netlink reply with the 'netlabel unlabel accept' flag. This is a FATAL inaccuracy affecting the primary purpose, making the summary unreliable with no accurate claims."
            ]
        }
    }
}
{
    "project_name": "binutils",
    "function_addr": 4341728,
    "strip_function_name": "sub_423FE0",
    "strip_decompiled_code": "__int64 *__fastcall sub_423FE0(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rax\n  __int64 *result; // rax\n  char *v4; // rax\n\n  v1 = *(_QWORD *)(a1 + 8);\n  if ( (*(_BYTE *)a1 & 1) != 0 )\n  {\n    if ( qword_7EA588 == v1 )\n    {\n      a1 = *(_QWORD *)(a1 + 24);\n      v1 = *(_QWORD *)(a1 + 8);\n    }\n    else\n    {\n      v2 = sub_422EC0(a1);\n      v1 = *(_QWORD *)(v2 + 8);\n      a1 = v2;\n    }\n  }\n  result = (__int64 *)*(unsigned int *)(v1 + 24);\n  if ( (char)result >= 0 )\n  {\n    if ( (BYTE1(result) & 1) != 0 )\n    {\n      v4 = dcgettext(0LL, \"section symbols are already global\", 5);\n      return sub_4176A0(v4);\n    }\n    else\n    {\n      if ( (*(_BYTE *)a1 & 1) != 0 )\n      {\n        if ( v1 == qword_7EA588 && v1 == *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + 32LL) )\n        {\n          v1 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL);\n          return sub_417850(\"can't make register symbol `%s' global\", *(const char **)(v1 + 8));\n        }\n      }\n      else if ( *(_QWORD *)(v1 + 32) == qword_7EA588 )\n      {\n        return sub_417850(\"can't make register symbol `%s' global\", *(const char **)(v1 + 8));\n      }\n      LOBYTE(result) = (unsigned __int8)result & 0x7E;\n      result = (__int64 *)((unsigned int)result | 2);\n      *(_DWORD *)(v1 + 24) = (_DWORD)result;\n    }\n  }\n  return result;\n}\n",
    "function_name": "S_SET_EXTERNAL",
    "decompiled_code": "void __fastcall S_SET_EXTERNAL(symbolS *s)\n{\n  asymbol *bsym; // rdx\n  symbolS *v2; // rax\n  flagword flags; // eax\n  char *v4; // rax\n\n  bsym = s->bsym;\n  if ( (*(_BYTE *)&s->sy_flags & 1) != 0 )\n  {\n    if ( reg_section == (segT)bsym )\n    {\n      s = s->sy_value.X_op_symbol;\n      bsym = s->bsym;\n    }\n    else\n    {\n      v2 = (symbolS *)local_symbol_convert((__int64)s);\n      bsym = v2->bsym;\n      s = v2;\n    }\n  }\n  flags = bsym->flags;\n  if ( (flags & 0x80u) == 0 )\n  {\n    if ( (flags & 0x100) != 0 )\n    {\n      v4 = dcgettext(0LL, &byte_4F5ED0[480], 5);\n      as_warn(v4);\n    }\n    else\n    {\n      if ( (*(_BYTE *)&s->sy_flags & 1) != 0 )\n      {\n        if ( bsym == (asymbol *)reg_section && bsym == (asymbol *)s->sy_value.X_op_symbol->bsym->section )\n        {\n          bsym = s->sy_value.X_op_symbol->bsym;\nLABEL_10:\n          as_bad(&byte_4F5ED0[520], bsym->name);\n          return;\n        }\n      }\n      else if ( bsym->section == reg_section )\n      {\n        goto LABEL_10;\n      }\n      LOBYTE(flags) = flags & 0x7E;\n      bsym->flags = flags | 2;\n    }\n  }\n}\n",
    "source_code": "\nvoid\nS_SET_EXTERNAL (symbolS *s)\n{\n  if (LOCAL_SYMBOL_CHECK (s))\n    s = local_symbol_convert ((struct local_symbol *) s);\n  if ((s->bsym->flags & BSF_WEAK) != 0)\n    {\n      /* Let .weak override .global.  */\n      return;\n    }\n  if (s->bsym->flags & BSF_SECTION_SYM)\n    {\n      /* Do not reassign section symbols.  */\n      as_warn (_(\"section symbols are already global\"));\n      return;\n    }\n#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK\n  if (S_GET_SEGMENT (s) == reg_section)\n    {\n      as_bad (\"can't make register symbol `%s' global\",\n\t      S_GET_NAME (s));\n      return;\n    }\n#endif\n  s->bsym->flags |= BSF_GLOBAL;\n  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);\n\n#ifdef TE_PE\n  if (! an_external_name && S_GET_NAME(s)[0] != '.')\n    an_external_name = S_GET_NAME (s);\n#endif\n}",
    "comment": "Sets a symbol as global, overriding weak and local flags while preventing reassignment of section or register symbols.",
    "hext5_sum": "this function is called when we want to merge a new symbol with an existing symbol. it handles the various cases which arise when we find a definition in a dynamic object, or when there is already a definition in a dynamic object. the new symbol is described by name, sym, psec, and pvalue. we set sym_hash to the hash table entry. we set poldbfd to the old symbol's bfd. we set pold_weak if the old symbol was weak. we set pold_alignment to the alignment of an old common symbol. we set override if the old symbol is overriding a",
    "bint5_sum": "Retrieves or creates a section symbol for a given section , ensuring it is not already defined or already marked as global .\n",
    "cpbcs_sum": "Marks a symbol as thread-local if it is not already classified as its section and checks for valid section flags.\n",
    "misum_sum": "Marks a symbol as thread-local if it is not already classified and marks its segment as local if it is not already present.\n",
    "decom_sum": "Marks a non-register section symbol as global, unless already global, and returns an error if the symbol is a register or already global.",
    "cfg_sum": "Marks a section symbol as global unless it is already global or a register symbol, issuing error messages for invalid conversion attempts.",
    "work_score": {
        "hext5": {
            "summary": "this function is called when we want to merge a new symbol with an existing symbol. it handles the various cases which arise when we find a definition in a dynamic object, or when there is already a definition in a dynamic object. the new symbol is described by name, sym, psec, and pvalue. we set sym_hash to the hash table entry. we set poldbfd to the old symbol's bfd. we set pold_weak if the old symbol was weak. we set pold_alignment to the alignment of an old common symbol. we set override if the old symbol is overriding a",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims focus on merging symbols, dynamic object definitions, and fields like sym_hash, poldbfd, pold_weak, and pold_alignment, none of which are present in the source code. The source function deals with setting a symbol as external, checking for weak flags, section symbols, and register symbols, and modifying flags accordingly. All major claims contradict or are unrelated to the code's semantics, resulting in no accurate matches.",
                "The summary describes merging symbols in a dynamic object, involving parameters like name, sym, psec, pvalue, and setting various metadata fields. None of these behaviors or variables (e.g., sym_hash, poldbfd, pold_weak, pold_alignment) appear in the source code, which actually handles making a symbol global with checks for local, weak, section, and register symbols. The primary purpose and key conditions in the implementation are completely missed, and the described functionality is unrelated to the actual code.",
                "The summary\u2019s claims about merging symbols, dynamic objects, and manipulating fields like sym_hash, poldbfd, pold_weak, and pold_alignment are entirely unrelated to the source code, which sets flags on a symbol and handles weak, section, and register symbols. These are NOISE claims, with no accurate overlap and no specific details correctly describing the actual function\u2019s purpose or behavior. With overwhelming noise and no correct force-multiplying information, the content is not useful for understanding the code."
            ]
        },
        "bint5": {
            "summary": "Retrieves or creates a section symbol for a given section , ensuring it is not already defined or already marked as global .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function retrieves or creates a section symbol and checks if it is not already defined or marked as global, but the source code does not perform creation or retrieval of section symbols. Instead, it modifies symbol flags, warns if section symbols are already global, and handles special cases for weak and register symbols. The claims are specific to functionality not present in the code, so they largely contradict the source implementation.",
                "The summary incorrectly states that the function retrieves or creates a section symbol and checks if it's already defined or global, which does not align with the source code. The actual function modifies an existing symbol to mark it as global, with specific conditions for weak symbols, section symbols, register symbols, and updates related flags. The primary purpose and key conditions from the code are missed, and the summary is factually inaccurate regarding the operation on section symbols.",
                "The summary claims that the function retrieves or creates a section symbol and ensures it is not already defined or marked as global. This is inaccurate: the source code does not create or retrieve section symbols but modifies an existing symbol's flags to make it global unless it meets certain conditions (weak, section symbol, register symbol). The claim targets the semantics of the function and misrepresents its primary purpose, which is a FATAL error around its key role and I/O behavior."
            ]
        },
        "cpbcs": {
            "summary": "Marks a symbol as thread-local if it is not already classified as its section and checks for valid section flags.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function marks a symbol as thread-local and checks for valid section flags, but in reality the code marks a symbol as global (unless weak or a section symbol) and handles specific flag and section checks. The 'thread-local' mention is inaccurate, and much of the behavior is misrepresented, resulting in most claims being incorrect.",
                "The summary incorrectly states that the function marks a symbol as thread-local, which contradicts the code\u2019s actual primary purpose of marking a symbol as global (while handling weak, section, and register symbols). Although it loosely mentions checking section-related conditions, it misses the actual section symbol warning and other key secondary details such as handling weak symbols, register symbols, and flag modifications.",
                "The summary's claim that the function marks a symbol as thread-local is a FATAL inaccuracy\u2014 the source code actually marks a symbol as global, clears local/weak flags, and warns/rejects in certain conditions. There is no mention of thread-local behavior in the code. The rest of the claim about checking section flags is partially aligned (it does check section-related flags and warns), but the core purpose is misrepresented, which is a critical semantic error impacting the primary function purpose."
            ]
        },
        "misum": {
            "summary": "Marks a symbol as thread-local if it is not already classified and marks its segment as local if it is not already present.\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary's claims about marking a symbol as thread-local and marking its segment as local do not align with the source code, which instead checks for weak, section, and register symbol flags, updates global-related flags, and never mentions thread-local status or segment marking as local. Both claims are inaccurate, resulting in no accurate matches.",
                "The summary is inaccurate: it claims the function marks a symbol as thread-local and its segment as local, which is not reflected in the source. The source function instead converts local symbols, skips weak and section symbols, blocks globalizing register symbols, and sets BSF_GLOBAL while clearing BSF_LOCAL and BSF_WEAK. Since the stated purpose and behavior in the summary contradict the code, it entirely misses the primary purpose and all secondary details.",
                "The summary contains only inaccurate claims. It states that the function marks a symbol as thread-local and sets its segment as local, which directly contradicts the source code. The code instead checks for local symbols, weak symbols, section symbols, and register symbols, and marks them as global while adjusting flags. This is a FATAL error affecting the primary purpose of the function, as it misrepresents the key action performed."
            ]
        }
    }
}
{
    "project_name": "busybox",
    "function_addr": 5587923,
    "strip_function_name": "sub_5543D3",
    "strip_decompiled_code": "__int64 __fastcall sub_5543D3(\n        _DWORD *a1,\n        int a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  _BYTE *v11; // r13\n  __int64 v12; // rbp\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 result; // rax\n  int v20; // ebx\n  _BYTE *v21; // rax\n  _BYTE *v22; // r12\n  _DWORD v23[18]; // [rsp+0h] [rbp-48h] BYREF\n\n  v11 = a1;\n  v12 = a3;\n  if ( sub_400580(a3, 46LL) )\n  {\n    if ( (unsigned int)sub_554FD9(v23, v12, 2LL) )\n    {\nLABEL_3:\n      sub_517A10(\"\\\"%s\\\" is invalid lladdr\", v12, v13, v14, v15, v16, a4, a5, a6, a7, v17, v18, a10, a11, v23[0]);\n      return 0xFFFFFFFFLL;\n    }\n    result = 0xFFFFFFFFLL;\n    if ( a2 > 3 )\n    {\n      *a1 = v23[1];\n      return 4LL;\n    }\n  }\n  else\n  {\n    result = 1LL;\n    if ( a2 > 0 )\n    {\n      v20 = 0;\n      while ( 1 )\n      {\n        v21 = (_BYTE *)sub_400580(v12, 58LL);\n        v22 = v21;\n        if ( v21 )\n        {\n          *v21 = 0;\n          v22 = v21 + 1;\n        }\n        if ( (unsigned int)sub_441CB0(v12, (__int64)\"%x\", (unsigned int)v23) != 1 || v23[0] > 0xFFu )\n          break;\n        *v11 = v23[0];\n        if ( !v22 )\n          return (unsigned int)(v20 + 1);\n        ++v20;\n        ++v11;\n        if ( v20 == a2 )\n          return (unsigned int)(v20 + 1);\n        v12 = (__int64)v22;\n      }\n      goto LABEL_3;\n    }\n  }\n  return result;\n}\n",
    "function_name": "ll_addr_a2n",
    "decompiled_code": "__int64 __fastcall ll_addr_a2n(\n        _DWORD *a1,\n        int a2,\n        const char *a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  _BYTE *v11; // r13\n  const char *v12; // rbp\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 result; // rax\n  int v20; // ebx\n  char *v21; // rax\n  char *v22; // r12\n  _DWORD v23[18]; // [rsp+0h] [rbp-48h] BYREF\n\n  v11 = a1;\n  v12 = a3;\n  if ( strchr(a3, 46) )\n  {\n    if ( (unsigned int)get_addr_1((__int64)v23, (__int64)v12, 2) )\n    {\nLABEL_3:\n      bb_error_msg(\n        (const __m128i *)\"\\\"%s\\\" is invalid lladdr\",\n        (__int64)v12,\n        v13,\n        v14,\n        v15,\n        v16,\n        a4,\n        a5,\n        a6,\n        a7,\n        v17,\n        v18,\n        a10,\n        a11,\n        v23[0]);\n      return 0xFFFFFFFFLL;\n    }\n    result = 0xFFFFFFFFLL;\n    if ( a2 > 3 )\n    {\n      *a1 = v23[1];\n      return 4LL;\n    }\n  }\n  else\n  {\n    result = 1LL;\n    if ( a2 > 0 )\n    {\n      v20 = 0;\n      while ( 1 )\n      {\n        v21 = strchr(v12, 58);\n        v22 = v21;\n        if ( v21 )\n        {\n          *v21 = 0;\n          v22 = v21 + 1;\n        }\n        if ( (unsigned int)sscanf((__int64)v12, (__int64)\"%x\", v23) != 1 || v23[0] > 0xFFu )\n          break;\n        *v11 = v23[0];\n        if ( !v22 )\n          return (unsigned int)(v20 + 1);\n        ++v20;\n        ++v11;\n        if ( v20 == a2 )\n          return (unsigned int)(v20 + 1);\n        v12 = v22;\n      }\n      goto LABEL_3;\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nint FAST_FUNC ll_addr_a2n(unsigned char *lladdr, int len, char *arg)\n{\n\tint i;\n\n\tif (strchr(arg, '.')) {\n\t\tinet_prefix pfx;\n\t\tif (get_addr_1(&pfx, arg, AF_INET)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 4) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(lladdr, pfx.data, 4);\n\t\treturn 4;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tint temp;\n\t\tchar *cp = strchr(arg, ':');\n\t\tif (cp) {\n\t\t\t*cp = 0;\n\t\t\tcp++;\n\t\t}\n\t\tif (sscanf(arg, \"%x\", &temp) != 1 || (temp < 0 || temp > 255)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tlladdr[i] = temp;\n\t\tif (!cp) {\n\t\t\tbreak;\n\t\t}\n\t\targ = cp;\n\t}\n\treturn i+1;\n}",
    "comment": "Converts a string representation of a link-layer address to its binary format, supporting both IPv4 addresses and hexadecimal notation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Parses a DHCP option string to extract IP address and netmask , adding it to a given IP address structure .\n",
    "cpbcs_sum": "The function decodes a string of specified IP address and stores it in a buffer, ensuring proper newline alignment and formatting.\n",
    "misum_sum": "Parses a string for a numerical number, validating the range of a valid IPv4 address and length, and stores it in a dynamically allocated structure.\n",
    "decom_sum": "Parses a string-form link-layer address in dot or colon notation into bytes, validating each component and storing them in the provided buffer.",
    "cfg_sum": "Parses and validates a colon- or dot-separated hardware address string, stores parsed bytes into the buffer, and returns length or an error code.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.1,
                0.4
            ],
            "reason": [
                "The summary contains only a vague phrase unrelated to the source code's actual functionality. It fails to extract any fact-based claims about how the function processes input, validates formats, or returns values. Since there are no accurate claims to evaluate, alignment with the evaluation steps is nonexistent.",
                "The summary 'push a pointer type.' is vague, unrelated to the actual function\u2019s purpose, and fails to describe any fact-based claims about converting string representations of link-layer addresses into binary form. It misses the primary functionality, input processing, parsing logic, error handling, and output behavior present in the source code.",
                "The summary 'push a pointer type' does not describe any aspect of the provided function's behavior, inputs, outputs, or purpose. It is unrelated to the source code's logic (converting address strings to byte arrays), making it a NOISE claim. There are no accurate claims, and the only content is irrelevant, resulting in overwhelming NOISE and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Parses a DHCP option string to extract IP address and netmask , adding it to a given IP address structure .\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function parses a DHCP option string to extract an IP address and netmask and adds it to an IP address structure, which is inaccurate. The source code shows the function converts an ASCII link-layer address string into a numeric format, handling both dotted IPv4 and colon-separated hex formats, without any DHCP-specific parsing or netmask handling. None of the claimed behaviors match the code, so all claims are inaccurate.",
                "The summary incorrectly describes the function as parsing a DHCP option string to extract IP address and netmask, which contradicts the source code. The actual implementation parses a link-layer address string (in either dotted IP format or colon-delimited hex format) into a byte array, with validation and error messaging. The summary misses the primary purpose entirely and includes unrelated concepts like DHCP and netmask.",
                "The summary claims the function parses a DHCP option string to extract IP address and netmask and add it to an IP address structure, but the source code shows it parses a string representing a link-layer address in either dotted-decimal or colon-separated hex format, validates it, and writes the parsed bytes into a buffer. This is a direct contradiction targeting the primary purpose and I/O, making it a FATAL error with no accurate claims present."
            ]
        },
        "cpbcs": {
            "summary": "The function decodes a string of specified IP address and stores it in a buffer, ensuring proper newline alignment and formatting.\n",
            "score": [
                0.2,
                0.1,
                0.2
            ],
            "reason": [
                "The summary claims the function decodes a string of a specified IP address and stores it in a buffer, which partially aligns with the code's IPv4 parsing logic when a dot is present. However, it omits that the function also parses colon-separated byte values for link-layer addresses, and it introduces an inaccurate detail about 'ensuring proper newline alignment and formatting,' which is not present in the implementation. Most of the claim content is inaccurate or incomplete in representing the function's behavior.",
                "The summary is inaccurate: it claims the function decodes an IP address and handles newline alignment/formatting, but the source shows it parses either IPv4 dotted-decimal or colon-separated byte values into a hardware address buffer. It also omits important behaviors such as error handling for invalid inputs, length checks, and return value semantics. The primary purpose is misrepresented and key secondary details are missing, resulting in no valid claim coverage.",
                "The summary contains a FATAL inaccuracy: it claims the function decodes a string IP address with newline alignment and formatting, which is not in the source code's semantics. The source code actually parses either an IPv4 dotted string or colon-delimited hex bytes into a byte array without any newline alignment logic. This misrepresentation targets the primary purpose of the function, making it unreliable."
            ]
        },
        "misum": {
            "summary": "Parses a string for a numerical number, validating the range of a valid IPv4 address and length, and stores it in a dynamically allocated structure.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. While the function does parse strings and validate values within the 0\u2013255 range (consistent with IPv4 address octets), it also handles colon-separated formats and does not allocate any dynamic structures\u2014it writes directly into a provided buffer. The claim about a dynamically allocated structure is incorrect, and the summary omits key control flow details such as handling lengths and multiple formats. Less than half of the claims are accurate.",
                "The summary incorrectly states that the function stores the parsed data in a dynamically allocated structure, which is not present in the source code. It also focuses solely on parsing a numerical number for IPv4 and length validation, missing the primary purpose of converting either a dotted IPv4 or colon-separated byte values into a provided buffer. It omits key secondary details such as in-place string modification, byte range checks, branching based on string format, and usage of the provided length parameter. Overall, it fails to capture the core behavior or supporting logic from the source.",
                "The summary makes inaccurate claims about the source code's core purpose and output. It wrongly describes storing data in a dynamically allocated structure, whereas the function writes into a provided buffer. It also oversimplifies processing, implying it only validates IPv4 addresses, while the code also parses colon-separated hex values for link-layer addresses. These inaccuracies target the primary purpose, making them FATAL errors. There are no clearly accurate, high-value details to offset this."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071579841792,
    "strip_function_name": "sub_FFFFFFFF810F3500",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810F3500(volatile signed __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  unsigned int v4; // r15d\n  _QWORD *v5; // rax\n  int v6; // ebx\n  __int64 v7; // rbx\n  __int64 *v8; // rbx\n  __int64 v9; // rcx\n  _BOOL8 v10; // [rsp-38h] [rbp-38h]\n\n  result = *(_QWORD *)a1;\n  if ( (*(_QWORD *)a1 & 0x20) != 0 )\n  {\n    result = *(_QWORD *)a1;\n    if ( (*(_QWORD *)a1 & 0x40) == 0 )\n    {\n      result = *(_QWORD *)a1;\n      if ( (*(_QWORD *)a1 & 0x100000) == 0 )\n      {\n        v3 = *((_QWORD *)a1 + 4);\n        v10 = (*(_QWORD *)a1 & 0x80000LL) == 0;\n        v4 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 4 : 2;\n        v5 = (_QWORD *)*((_QWORD *)a1 + 5);\n        v6 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 2 : 0;\n        *(_QWORD *)(v3 + 8) = v5;\n        *v5 = v3;\n        *((_QWORD *)a1 + 4) = 0xDEAD000000000100LL;\n        v7 = (unsigned int)(v6 + 1);\n        *((_QWORD *)a1 + 5) = 0xDEAD000000000200LL;\n        sub_FFFFFFFF81101110(a2 - 968, (unsigned int)v7, 0xFFFFFFFFLL);\n        _InterlockedOr8(a1, 0x40u);\n        v8 = (__int64 *)(a2 + 16 * v7);\n        v9 = *v8;\n        *(_QWORD *)(v9 + 8) = a1 + 32;\n        *((_QWORD *)a1 + 5) = v8;\n        *((_QWORD *)a1 + 4) = v9;\n        *v8 = (__int64)(a1 + 32);\n        sub_FFFFFFFF81101110(a2 - 968, v4, 1LL);\n        __incgsqword(0xDE08u);\n        result = a2 + 8 * v10;\n        ++*(_QWORD *)(result + 96);\n        ++*(_QWORD *)(result + 80);\n      }\n    }\n  }\n  return result;\n}\n",
    "function_name": "__activate_page",
    "decompiled_code": "__int64 __fastcall _activate_page(volatile signed __int8 *a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  unsigned int v4; // r15d\n  _QWORD *v5; // rax\n  int v6; // ebx\n  __int64 v7; // rbx\n  __int64 *v8; // rbx\n  __int64 v9; // rcx\n  _BOOL8 v10; // [rsp-38h] [rbp-38h]\n\n  result = *(_QWORD *)a1;\n  if ( (*(_QWORD *)a1 & 0x20) != 0 )\n  {\n    result = *(_QWORD *)a1;\n    if ( (*(_QWORD *)a1 & 0x40) == 0 )\n    {\n      result = *(_QWORD *)a1;\n      if ( (*(_QWORD *)a1 & 0x100000) == 0 )\n      {\n        v3 = *((_QWORD *)a1 + 4);\n        v10 = (*(_QWORD *)a1 & 0x80000LL) == 0;\n        v4 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 4 : 2;\n        v5 = (_QWORD *)*((_QWORD *)a1 + 5);\n        v6 = ((*(_QWORD *)a1 >> 19) & 1LL) == 0 ? 2 : 0;\n        *(_QWORD *)(v3 + 8) = v5;\n        *v5 = v3;\n        *((_QWORD *)a1 + 4) = 0xDEAD000000000100LL;\n        v7 = (unsigned int)(v6 + 1);\n        *((_QWORD *)a1 + 5) = 0xDEAD000000000200LL;\n        _mod_zone_page_state(a2 - 968, v7, -1);\n        _InterlockedOr8(a1, 0x40u);\n        v8 = (__int64 *)(a2 + 16 * v7);\n        v9 = *v8;\n        *(_QWORD *)(v9 + 8) = a1 + 32;\n        *((_QWORD *)a1 + 5) = v8;\n        *((_QWORD *)a1 + 4) = v9;\n        *v8 = (__int64)(a1 + 32);\n        _mod_zone_page_state(a2 - 968, v4, 1);\n        __incgsqword(0xDE08u);\n        result = a2 + 8 * v10;\n        ++*(_QWORD *)(result + 96);\n        ++*(_QWORD *)(result + 80);\n      }\n    }\n  }\n  return result;\n}\n",
    "source_code": "\nstatic void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}",
    "comment": "Activates a page by removing it from the LRU list and updating its status if it is inactive and eligible for activation.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Deactivates an LRU page by removing it from the active list , updating its state , and potentially moving it to the inactive list .\n",
    "cpbcs_sum": "Deactivates an LRU page by removing it from the active list, updating its state, and potentially moving it to the inactive list.\n",
    "misum_sum": "Deactivates an LRU page by removing it from the active list, updating its state, and inserting it into the LRU list.\n",
    "decom_sum": "Updates queue pointers and flags for a device structure, moves it between lists, and increments per\u2011CPU counters based on status bits.",
    "cfg_sum": "Updates linked list pointers and atomic counters when specific status flags are set, performing synchronization and state transitions for a flagged object.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary's single claim ('push a pointer type') does not match the function's semantics; the code activates a page in the LRU list under certain conditions, not pushing a pointer. The claim is vague and unrelated to the actual behavior, making it inaccurate.",
                "The summary 'push a pointer type' does not reflect the source code's primary purpose or behavior. The function activates a page in the LRU list under specific conditions, updates related statistics, and moves the page between lists. The given summary is vague, unrelated to memory management logic, and fails to capture primary purpose or secondary details from the source.",
                "The summary makes a vague claim ('push a pointer type') that is unrelated to the actual function in the source code, which deals with activating a page in the LRU list within Linux memory management. This is a NOISE error because it does not describe any behavior of the provided code, and no accurate claims are made. With only irrelevant content, there is no positive gain."
            ]
        },
        "bint5": {
            "summary": "Deactivates an LRU page by removing it from the active list , updating its state , and potentially moving it to the inactive list .\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function deactivates an LRU page and moves it to the inactive list, while the source code shows it activates a page that meets certain conditions, sets it as active, and moves it to the active list. This is a semantic contradiction targeting the code, making the main claim inaccurate.",
                "The summary is inaccurate because it describes deactivation of an LRU page, whereas the source code performs activation of a page: it removes an inactive eligible LRU page from its list, marks it active, adds it to the active list, and updates statistics. This misstatement fails to capture the primary purpose and misrepresents key actions, resulting in no meaningful coverage of the critical semantic units.",
                "The summary claims the function deactivates an LRU page and moves it to the inactive list, which directly contradicts the source code: the implementation activates a page by moving it from the inactive to the active list. This is a FATAL inaccuracy concerning the primary purpose and key logic of the function, leading to high negative impact and making the summary misleading."
            ]
        },
        "cpbcs": {
            "summary": "Deactivates an LRU page by removing it from the active list, updating its state, and potentially moving it to the inactive list.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function deactivates a page and moves it to the inactive list, whereas the source code clearly activates an eligible LRU page by setting it active, moving it from its inactive list to the active list, and updating statistics. All key semantic claims in the summary contradict the source implementation, resulting in no accurate claims.",
                "The summary incorrectly states that the function deactivates a page and moves it to the inactive list, while the source code shows it activates a page by setting it active, removing it from the current LRU list, adjusting the LRU type to its active variant, and adding it back. This means the primary purpose is misidentified, leading to an inaccurate depiction of core behavior. Since the core semantic is wrong, there is no valid coverage of primary or secondary details.",
                "The summary contains a FATAL inaccuracy regarding the primary purpose \u2014 it claims the function deactivates a page and moves it to the inactive list, while the source code explicitly does the opposite: it activates an eligible inactive LRU page by removing it from its current list, flagging it active, and moving it to the corresponding active LRU list. This is a direct contradiction of the core functionality, severely misleading the reader."
            ]
        },
        "misum": {
            "summary": "Deactivates an LRU page by removing it from the active list, updating its state, and inserting it into the LRU list.\n",
            "score": [
                0.1,
                0.1,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function deactivates an LRU page, while the source code actually activates it by moving it from the inactive list to the active list and updating relevant statistics. This contradiction means the core claim is inaccurate with respect to the implementation.",
                "The summary incorrectly describes the function's primary purpose, stating it deactivates an LRU page, while the code in fact activates an eligible inactive page by moving it from the inactive to the active LRU list and updating relevant statistics. This misrepresentation misses the primary purpose and key behavioral details, leading to no accurate claim coverage.",
                "The summary makes a FATAL error by stating the function deactivates a page, when in fact the code activates an inactive LRU page by removing it from the inactive list, setting it active, and adding it to the active list. This directly contradicts the primary purpose of the code. No accurate claims provide compensating value."
            ]
        }
    }
}
{
    "project_name": "vmlinux",
    "function_addr": 18446744071585720688,
    "strip_function_name": "sub_FFFFFFFF8168E970",
    "strip_decompiled_code": "unsigned __int64 __fastcall sub_FFFFFFFF8168E970(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 *v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  int v14; // r9d\n  double v15; // xmm4_8\n  double v16; // xmm5_8\n  volatile signed __int32 *v17; // rdi\n  __int64 v18; // rsi\n  __int64 v19; // rdi\n  __int64 v20; // rdx\n  __int64 v21; // rcx\n  __int64 v22; // r8\n  int v23; // r9d\n\n  sub_FFFFFFFF815CFFC0(a1 + 112, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( *(_DWORD *)(a1 + 236) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 27);\n    sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 475, (__int64)v11, v12, v13, v14);\n    if ( !*(_QWORD *)(a1 + 64) )\n      goto LABEL_3;\n  }\n  else if ( !*(_QWORD *)(a1 + 64) )\n  {\n    goto LABEL_3;\n  }\n  a2 = (_DWORD *)(qword_1C0 + 28);\n  sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 476, (__int64)v11, v12, v13, v14);\nLABEL_3:\n  if ( *(_QWORD *)(a1 + 512) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 29);\n    sub_FFFFFFFF8103BB80((__int64)\"net/unix/af_unix.c\", 477, (__int64)v11, v12, v13, v14);\n  }\n  if ( (*(_QWORD *)(a1 + 208) & 1) == 0 )\n    return sub_FFFFFFFF8178A70F((unsigned int)&unk_FFFFFFFF81A16D80, a1, (_DWORD)v11, v12, v13, v14);\n  v17 = *(volatile signed __int32 **)(a1 + 632);\n  if ( v17 )\n  {\n    if ( !_InterlockedDecrement(v17) )\n      sub_FFFFFFFF8112DCD0((unsigned __int64)v17, a3, a4, a5, a6, v15, v16, a9, a10, (__int64)a2, v11, v12, v13, v14);\n  }\n  _InterlockedDecrement64(&qword_FFFFFFFF81EB37E0);\n  sub_FFFFFFFF81043110();\n  v18 = *(_QWORD *)(a1 + 40);\n  v19 = *(_QWORD *)(a1 + 48);\n  sub_FFFFFFFF815C9370(v19, v18, 0xFFFFFFFF);\n  return sub_FFFFFFFF81043640(v19, v18, v20, v21, v22, v23);\n}\n",
    "function_name": "unix_sock_destructor",
    "decompiled_code": "unsigned __int64 __fastcall unix_sock_destructor(\n        __int64 a1,\n        volatile signed __int32 *a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10)\n{\n  __int64 *v11; // rdx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 *v14; // rdi\n  __int64 v15; // rsi\n  const char *v16; // rdi\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n\n  skb_queue_purge(a1 + 112, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n  if ( *(_DWORD *)(a1 + 236) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 27);\n    warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DBu, a3, a4, a5, a6, v12, v13, a9, a10);\n    if ( !*(_QWORD *)(a1 + 64) )\n      goto LABEL_3;\n  }\n  else if ( !*(_QWORD *)(a1 + 64) )\n  {\n    goto LABEL_3;\n  }\n  a2 = (_DWORD *)(qword_1C0 + 28);\n  warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DCu, a3, a4, a5, a6, v12, v13, a9, a10);\nLABEL_3:\n  if ( *(_QWORD *)(a1 + 512) )\n  {\n    a2 = (_DWORD *)(qword_1C0 + 29);\n    warn_slowpath_null(\"net/unix/af_unix.c\", 0x1DDu, a3, a4, a5, a6, v12, v13, a9, a10);\n  }\n  if ( (*(_QWORD *)(a1 + 208) & 1) == 0 )\n    return printk((__int64)&unk_FFFFFFFF81A16D80, a3, a4, a5, a6, v12, v13, a9, a10, a1);\n  v14 = *(__int64 **)(a1 + 632);\n  if ( v14 )\n  {\n    if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )\n      kfree(v14, a3, a4, a5, a6, v12, v13, a9, a10, (__int64)a2, v11);\n  }\n  _InterlockedDecrement64(&unix_nr_socks);\n  local_bh_disable();\n  v15 = *(_QWORD *)(a1 + 40);\n  v16 = *(const char **)(a1 + 48);\n  sock_prot_inuse_add((__int64)v16, v15, 0xFFFFFFFF);\n  return local_bh_enable(v16, v15, a3, a4, a5, a6, v17, v18, a9, a10);\n}\n",
    "source_code": "\nstatic void unix_sock_destructor(struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(!sk_unhashed(sk));\n\tWARN_ON(sk->sk_socket);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tprintk(KERN_INFO \"Attempt to release alive unix socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tif (u->addr)\n\t\tunix_release_addr(u->addr);\n\n\tatomic_long_dec(&unix_nr_socks);\n\tlocal_bh_disable();\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n#ifdef UNIX_REFCNT_DEBUG\n\tprintk(KERN_DEBUG \"UNIX %p is destroyed, %ld are still alive.\\n\", sk,\n\t\tatomic_long_read(&unix_nr_socks));\n#endif\n}",
    "comment": "Destroys a Unix socket, purging its receive queue and decrementing the count of active sockets if the socket is marked as dead.",
    "hext5_sum": "p^1_{-1/2 + i lambda}",
    "bint5_sum": "Cleans up and frees resources associated with a Unix socket , including multicast addresses , credentials , and the socket structure itself .\n",
    "cpbcs_sum": "Cleans up the XFRM device by purging error queue and ensuring the socket is dead before decrementing its reference count.\n",
    "misum_sum": "Releases resources and cleans up a socket buffer if the socket is properly marked for proper cleanup.\n",
    "decom_sum": "Handles UNIX socket cleanup by logging state, releasing references, decrementing global counters, and invoking final teardown routines based on connection and flag conditions.",
    "cfg_sum": "Handles AF_UNIX socket state checks, logs status, decrements reference counters, performs resource cleanup, and finalizes connection termination based on control flags.",
    "work_score": {
        "hext5": {
            "summary": "p^1_{-1/2 + i lambda}",
            "score": [
                0.0,
                0.0,
                0.0
            ],
            "reason": [
                "The summary contains only a mathematical expression and does not make any fact-based claims about the source code's functionality or semantics. As such, none of the claims are relevant or accurate in relation to the source implementation, resulting in no alignment with the evaluation steps.",
                "The provided summary consists only of a mathematical expression and contains no fact-based claims about the source code. It does not identify the primary purpose, behavior, or any secondary details of the function, resulting in no alignment with the evaluation steps.",
                "The summary contains only a mathematical expression unrelated to the source code\u2019s logic. It makes no fact-based claims about the function, its purpose, inputs/outputs, or side effects, resulting in pure NOISE. There is zero alignment with the source implementation and no useful insight provided."
            ]
        },
        "bint5": {
            "summary": "Cleans up and frees resources associated with a Unix socket , including multicast addresses , credentials , and the socket structure itself .\n",
            "score": [
                0.2,
                0.4,
                0.2
            ],
            "reason": [
                "The summary claims cleanup of multicast addresses, credentials, and the socket structure, but the source code only shows purging the receive queue, releasing the bound address, adjusting counters, and ensuring proper socket state. Multicast addresses and credentials are not handled here, making most claims inaccurate and only the broad idea of resource cleanup accurate, resulting in low alignment.",
                "The summary incorrectly states cleanup of multicast addresses and credentials, which are not present in the source code. It also omits key secondary details such as purging the receive queue, performing WARN_ON checks, handling SOCK_DEAD cases, releasing the bound address, decrementing socket counters, and updating protocol usage. While it loosely identifies the primary purpose of resource cleanup, the inaccuracies and missing critical semantic units reduce alignment significantly.",
                "The summary introduces several inaccurate claims: it mentions multicast addresses and credentials cleanup, which are not handled in the source code. The function purges the receive queue, checks socket state, optionally releases the bound address (not multicast), decrements counters, and manages protocol usage. These extra elements are FATAL inaccuracies since they mislead about the primary purpose and key resources handled. There is little accurate content beyond a generic statement about cleaning up a Unix socket, leading to high negative impact and low gain."
            ]
        },
        "cpbcs": {
            "summary": "Cleans up the XFRM device by purging error queue and ensuring the socket is dead before decrementing its reference count.\n",
            "score": [
                0.0,
                0.2,
                0.2
            ],
            "reason": [
                "The summary contains claims about cleaning up an XFRM device, purging an error queue, and decrementing a reference count, which do not match the source code. The source function is a destructor for a Unix socket that purges the receive queue, warns on certain conditions, releases an address, and updates socket counts. None of the key entities or queues mentioned in the summary are accurate to the code, resulting in no correct claims.",
                "The summary incorrectly describes the function as cleaning up an XFRM device and purging an error queue, which contradicts the source code that manages UNIX socket cleanup and purges the receive queue. While it does mention ensuring the socket is dead before decrementing a reference count, the misidentified device type and wrong queue type demonstrate fundamental inaccuracies, resulting in no reliable coverage of the primary purpose.",
                "The summary claims the function cleans up an XFRM device and purges an error queue, which is incorrect. The source code cleans up a unix socket, purging its receive queue, issuing warnings, and checking it is dead before decrementing the socket count. These are FATAL inaccuracies regarding the primary purpose and key I/O, making the description highly misleading."
            ]
        },
        "misum": {
            "summary": "Releases resources and cleans up a socket buffer if the socket is properly marked for proper cleanup.\n",
            "score": [
                0.2,
                0.5,
                0.5
            ],
            "reason": [
                "The summary makes a single broad claim that the function releases resources and cleans up a socket buffer if the socket is properly marked for cleanup. While the code does release resources and purge the receive queue, it performs these actions regardless of the SOCK_DEAD flag; the early return is only for alive sockets after certain WARN checks. The condition in the summary incorrectly ties buffer cleanup to the socket being marked for cleanup, which contradicts the source logic, resulting in the claim being inaccurate.",
                "The summary identifies a general cleanup and resource release behavior, which aligns loosely with the function\u2019s primary purpose of releasing resources tied to a unix socket. However, it inaccurately implies cleanup happens only if the socket is marked for cleanup, missing that the function also performs actions and checks (e.g., WARN_ONs, address release, decrementing counters) outside that condition. It omits important secondary details like purging the receive queue, handling the SOCK_DEAD check with an early return, updating protocol inuse counters, and conditional debug logging. This covers the primary idea but lacks coverage of critical secondary behaviors.",
                "The summary provides a broad, vague SAFE claim about releasing resources and cleaning up a socket buffer if the socket is properly marked. This loosely matches the code\u2019s cleanup logic, which purges receive queues and releases addresses only for sockets flagged as dead. However, it omits most details such as WARN_ON checks, decrementing counters, and disabling bottom halves, offering low insight. There are no factual contradictions (no FATAL), but the net benefit is low due to generic wording and lack of specifics."
            ]
        }
    }
}
{
    "project_name": "mailutils",
    "function_addr": 682751,
    "strip_function_name": "sub_A6AFF",
    "strip_decompiled_code": "__int64 __fastcall sub_A6AFF(__int64 a1, int a2, int a3, int *a4)\n{\n  int v5; // eax\n  int v7; // [rsp+24h] [rbp-13Ch]\n  int i; // [rsp+28h] [rbp-138h]\n  int v9; // [rsp+2Ch] [rbp-134h]\n  void *v10; // [rsp+38h] [rbp-128h]\n  void *dest; // [rsp+48h] [rbp-118h]\n  _BYTE src[264]; // [rsp+50h] [rbp-110h] BYREF\n  unsigned __int64 v13; // [rsp+158h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( a2 != 6 )\n    return 38LL;\n  if ( a3 == 1 )\n  {\n    if ( !a4 )\n      return 22LL;\n    v7 = 0;\n    v9 = *a4;\n    for ( i = 0; i <= 255; ++i )\n    {\n      if ( (unsigned int)i <= 0x7F && (v9 & mu_c_tab[i]) != 0 )\n      {\n        v5 = v7++;\n        src[v5] = i;\n      }\n    }\n    v10 = malloc(v7);\n    if ( !v10 )\n      return 12LL;\n    memcpy(v10, src, v7);\n    sub_A6985(a1);\n    *(_QWORD *)(a1 + 248) = v10;\n    *(_QWORD *)(a1 + 256) = v7;\n    return 0LL;\n  }\n  if ( a3 <= 1 )\n  {\n    if ( a3 )\n      return 38LL;\n    if ( a4 )\n    {\n      dest = malloc(*((_QWORD *)a4 + 1));\n      if ( !dest )\n        return 12LL;\n      memcpy(dest, *(const void **)a4, *((_QWORD *)a4 + 1));\n      sub_A6985(a1);\n      *(_QWORD *)(a1 + 248) = dest;\n      *(_QWORD *)(a1 + 256) = *((_QWORD *)a4 + 1);\n    }\n    else\n    {\n      sub_A6985(a1);\n    }\n    return 0LL;\n  }\n  if ( a3 != 2 )\n  {\n    if ( a3 != 3 )\n      return 38LL;\n    *(_DWORD *)(a1 + 232) &= ~1u;\n    *(_QWORD *)(a1 + 152) = 0LL;\n    return 0LL;\n  }\n  if ( a4 )\n    return sub_A6AAA(a1, *(_QWORD *)a4);\n  else\n    return 22LL;\n}\n",
    "function_name": "_nullstream_ctl",
    "decompiled_code": "// bad sp value at call has been detected, the output may be wrong!\nint __cdecl nullstream_ctl(_mu_stream *str, int code, int opcode, void *arg)\n{\n  int v5; // eax\n  int cnt; // [rsp+24h] [rbp-13Ch]\n  int i; // [rsp+28h] [rbp-138h]\n  int classa; // [rsp+2Ch] [rbp-134h]\n  char *p_0; // [rsp+38h] [rbp-128h]\n  char *p; // [rsp+48h] [rbp-118h]\n  char buf[264]; // [rsp+50h] [rbp-110h] BYREF\n  unsigned __int64 v13; // [rsp+158h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( code != 6 )\n    return 38;\n  if ( opcode == 1 )\n  {\n    if ( !arg )\n      return 22;\n    cnt = 0;\n    classa = *(_DWORD *)arg;\n    for ( i = 0; i <= 255; ++i )\n    {\n      if ( (unsigned int)i <= 0x7F && (classa & mu_c_tab[i]) != 0 )\n      {\n        v5 = cnt++;\n        buf[v5] = i;\n      }\n    }\n    p_0 = (char *)malloc(cnt);\n    if ( !p_0 )\n      return 12;\n    memcpy(p_0, buf, cnt);\n    nullstream_free_pattern((_mu_nullstream *)str);\n    str[1].buffer = p_0;\n    str[1].level = cnt;\n    return 0;\n  }\n  if ( opcode <= 1 )\n  {\n    if ( opcode )\n      return 38;\n    if ( arg )\n    {\n      p = (char *)malloc(*((_QWORD *)arg + 1));\n      if ( !p )\n        return 12;\n      memcpy(p, *(const void **)arg, *((_QWORD *)arg + 1));\n      nullstream_free_pattern((_mu_nullstream *)str);\n      str[1].buffer = p;\n      str[1].level = *((_QWORD *)arg + 1);\n    }\n    else\n    {\n      nullstream_free_pattern((_mu_nullstream *)str);\n    }\n    return 0;\n  }\n  if ( opcode != 2 )\n  {\n    if ( opcode != 3 )\n      return 38;\n    str[1].ref_count &= ~1u;\n    str->size = 0LL;\n    return 0;\n  }\n  if ( arg )\n    return nullstream_truncate(str, *(_QWORD *)arg);\n  else\n    return 22;\n}\n",
    "source_code": "\nstatic int\n_nullstream_ctl (struct _mu_stream *str, int code, int opcode, void *arg)\n{\n  struct _mu_nullstream *np = (struct _mu_nullstream *)str;\n\n  if (code != MU_IOCTL_NULLSTREAM)\n    /* Only this code is supported */\n    return ENOSYS;\n  switch (opcode)\n    {\n    case MU_IOCTL_NULLSTREAM_SET_PATTERN:\n      if (!arg)\n\t_nullstream_free_pattern (np);\n      else\n\t{\n\t  struct mu_nullstream_pattern *pat = arg;\n\t  char *p;\n\t  \n\t  p = malloc (pat->size);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, pat->pattern, pat->size);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = pat->size;\n\t}\n      break;\n\n    case MU_IOCTL_NULLSTREAM_SET_PATCLASS:\n      if (!arg)\n\treturn EINVAL;\n      else\n\t{\n\t  char buf[256];\n\t  int cnt = 0, i;\n\t  int class = *(int*)arg;\n\t  char *p;\n\t  \n\t  for (i = 0; i < 256; i++)\n\t    {\n\t      if (mu_c_is_class (i, class))\n\t\tbuf[cnt++] = i;\n\t    }\n\n\t  p = malloc (cnt);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, buf, cnt);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = cnt;\n\t}\n      break;\n\t  \n    case MU_IOCTL_NULLSTREAM_SETSIZE:\n      if (!arg)\n\treturn EINVAL;\n      else\n\treturn _nullstream_truncate (str, *(mu_off_t*)arg);\n      break;\n\n    case MU_IOCTL_NULLSTREAM_CLRSIZE:\n      np->mode &= ~MU_NULLSTREAM_SIZE;\n      np->base.size = NULL;\n      break;\n      \n    default:\n      return ENOSYS;\n    }\n  return 0;\n}",
    "comment": "Handles control operations for a nullstream, including setting patterns, pattern classes, and managing size-related functionalities.",
    "hext5_sum": "push a pointer type.",
    "bint5_sum": "Handles socket options for IPv6 , including multicast membership , source filtering , and destination filtering , while ensuring proper state management and error handling .\n",
    "cpbcs_sum": "Manages a configuration file by setting, clearing, start and end positions based on specified flags, and count, returning appropriate status codes based on node types.\n",
    "misum_sum": "Sets a value in a specified environment by converting a character array to a long integer and handling errors appropriately.\n",
    "decom_sum": "Configures or updates a data buffer and related state based on mode and input parameters, handling memory allocation, copying, and flag resetting as needed.",
    "cfg_sum": "Handles configuration updates based on mode, allocating and copying byte lists or buffers, clearing flags, and returning status codes for validation errors.",
    "work_score": {
        "hext5": {
            "summary": "push a pointer type.",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary 'push a pointer type.' is vague, lacks context, and does not accurately describe any functionality or behavior in the source code. It neither references the control codes, condition checks, nor operations performed in the function, making it effectively noise with no factual alignment to the implementation.",
                "The summary is vague and unrelated to the function\u2019s actual purpose or behavior. It does not mention the control handling for nullstream, the different opcodes, input validation, memory allocation, or error codes present in the source code. Since it fails to capture the primary purpose or any verifiable secondary detail from the implementation, alignment is nonexistent.",
                "The summary's lone claim 'push a pointer type' is vague and unrelated to the source code's actual behavior, which involves handling ioctl commands to set patterns, pattern classes, sizes, and clearing size for a nullstream. This is pure NOISE with no accurate details about the implementation, providing no useful insight."
            ]
        },
        "bint5": {
            "summary": "Handles socket options for IPv6 , including multicast membership , source filtering , and destination filtering , while ensuring proper state management and error handling .\n",
            "score": [
                0.0,
                0.0,
                0.2
            ],
            "reason": [
                "The summary describes handling of IPv6 socket options, multicast membership, and source/destination filtering, which is entirely unrelated to the provided source code. The source function deals with nullstream control operations such as setting patterns, pattern classes, size adjustments, and clearing size, with corresponding error handling. None of the claims in the summary match the actual implementation, making all claims inaccurate.",
                "The summary discusses IPv6 socket options, multicast membership, and filtering, which are entirely unrelated to the source code's purpose. The source function manages control operations for a nullstream, including setting patterns, pattern classes, size, and clearing size, with associated error handling. None of these behaviors are reflected in the summary, meaning the primary purpose and all secondary details are missed.",
                "All claims in the summary are unrelated to the provided source code. The summary speaks about IPv6 socket options, multicast membership, and filtering, but the code implements control operations for a null stream, including pattern setting, class-based pattern generation, size setting, and clearing. This is pure NOISE with no accurate claims, leading to high negative impact from irrelevance."
            ]
        },
        "cpbcs": {
            "summary": "Manages a configuration file by setting, clearing, start and end positions based on specified flags, and count, returning appropriate status codes based on node types.\n",
            "score": [
                0.0,
                0.1,
                0.2
            ],
            "reason": [
                "The summary's claims about managing a configuration file, start/end positions, and node types are unrelated to the source code, which handles nullstream control operations such as setting patterns, pattern classes, size, and clearing size with related error codes. None of the summary's claims accurately reflect the implementation, resulting in no ACCURATE claims.",
                "The summary is inaccurate because it describes managing a configuration file with start/end positions and node types, which is unrelated to the source code. The actual function in the source handles ioctl control commands for a null stream, setting patterns, pattern classes, size, clearing size, and returning errors like ENOSYS, EINVAL, and ENOMEM. The primary purpose and all key behaviors are missed entirely.",
                "The summary's claims about managing a configuration file, setting/clearing start and end positions, and handling node types do not correspond to the source code, which deals with nullstream control operations such as setting patterns, classes, sizes, and returning status codes for specific IOCTL commands. These are FATAL inaccuracies about the primary purpose and key I/O, resulting in a high negative impact."
            ]
        },
        "misum": {
            "summary": "Sets a value in a specified environment by converting a character array to a long integer and handling errors appropriately.\n",
            "score": [
                0.0,
                0.0,
                0.1
            ],
            "reason": [
                "The summary describes setting a value in an environment by converting a character array to a long integer and handling errors, which does not match any part of the provided source code's functionality. The source code handles ioctl operations for a nullstream, involving setting patterns, pattern classes, size operations, and clearing size, with no mention of character array conversion or environment variables. All claims in the summary are therefore inaccurate, resulting in no accurate matches.",
                "The summary is entirely inaccurate: it describes setting an environment variable by converting a char array to a long and handling errors, which is unrelated to the source code. The actual function processes control commands for a nullstream with multiple opcodes, handling patterns, classes, size, and specific error codes. It fails to capture the primary purpose or any secondary details, so no claims align with the code.",
                "The summary describes setting an environment value from a character array to a long integer with error handling, which is entirely unrelated to the source function. The code deals with handling different ioctl operations for a null stream, managing patterns, pattern classes, stream sizes, and error codes, without any environment variables or character-to-long conversion. This is a clear NOISE case with no accurate claims, leading to zero net benefit."
            ]
        }
    }
}
{
    "project_name": "openssl",
    "function_addr": 872080,
    "strip_function_name": "sub_D4E90",
    "strip_decompiled_code": "__int64 __fastcall sub_D4E90(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)\n{\n  __int64 v4; // r13\n  int *v5; // r15\n  unsigned __int64 v6; // r14\n  unsigned __int8 *v7; // r12\n  __int64 v8; // r13\n  __int64 v10; // rsi\n  unsigned __int8 *v11; // rdi\n  __int64 v12; // rdx\n  unsigned __int64 v13; // rax\n  unsigned __int8 *v15; // [rsp+8h] [rbp-60h]\n  __int64 v16; // [rsp+18h] [rbp-50h]\n  unsigned __int8 *v17; // [rsp+20h] [rbp-48h]\n\n  v4 = a1;\n  v16 = a2;\n  v17 = a3;\n  if ( a4 <= 0x3FFFFFFFFFFFFFFFLL )\n  {\n    v12 = a4;\n  }\n  else\n  {\n    v5 = (int *)(a1 + 88);\n    v6 = a4;\n    v7 = a3;\n    v15 = (unsigned __int8 *)(a1 + 40);\n    v8 = a2;\n    do\n    {\n      v10 = v8;\n      v11 = v7;\n      v8 += 0x4000000000000000LL;\n      v7 += 0x4000000000000000LL;\n      DES_ede3_cfb64_encrypt(\n        v11,\n        v10,\n        0x4000000000000000LL,\n        *(_QWORD *)(a1 + 120),\n        *(_QWORD *)(a1 + 120) + 128LL,\n        *(_QWORD *)(a1 + 120) + 256LL,\n        v15,\n        v5,\n        *(unsigned int *)(a1 + 16));\n      v6 -= 0x4000000000000000LL;\n    }\n    while ( v6 > 0x3FFFFFFFFFFFFFFFLL );\n    v4 = a1;\n    v12 = a4 & 0x3FFFFFFFFFFFFFFFLL;\n    v13 = (((a4 - 0x4000000000000000LL) >> 62) + 1) << 62;\n    v17 += v13;\n    v16 += v13;\n  }\n  if ( v12 )\n    DES_ede3_cfb64_encrypt(\n      v17,\n      v16,\n      v12,\n      *(_QWORD *)(v4 + 120),\n      *(_QWORD *)(v4 + 120) + 128LL,\n      *(_QWORD *)(v4 + 120) + 256LL,\n      (unsigned __int8 *)(v4 + 40),\n      (int *)(v4 + 88),\n      *(unsigned int *)(v4 + 16));\n  return 1LL;\n}\n",
    "function_name": "des_ede_cfb64_cipher",
    "decompiled_code": "__int64 __fastcall des_ede_cfb64_cipher(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)\n{\n  __int64 v4; // r13\n  int *v5; // r15\n  unsigned __int64 v6; // r14\n  unsigned __int8 *v7; // r12\n  __int64 v8; // r13\n  __int64 v10; // rsi\n  unsigned __int8 *v11; // rdi\n  __int64 v12; // rdx\n  unsigned __int64 v13; // rax\n  unsigned __int8 *v15; // [rsp+8h] [rbp-60h]\n  __int64 v16; // [rsp+18h] [rbp-50h]\n  unsigned __int8 *v17; // [rsp+20h] [rbp-48h]\n\n  v4 = a1;\n  v16 = a2;\n  v17 = a3;\n  if ( a4 <= 0x3FFFFFFFFFFFFFFFLL )\n  {\n    v12 = a4;\n  }\n  else\n  {\n    v5 = (int *)(a1 + 88);\n    v6 = a4;\n    v7 = a3;\n    v15 = (unsigned __int8 *)(a1 + 40);\n    v8 = a2;\n    do\n    {\n      v10 = v8;\n      v11 = v7;\n      v8 += 0x4000000000000000LL;\n      v7 += 0x4000000000000000LL;\n      DES_ede3_cfb64_encrypt(\n        v11,\n        v10,\n        0x4000000000000000LL,\n        *(_DWORD **)(a1 + 120),\n        (_DWORD *)(*(_QWORD *)(a1 + 120) + 128LL),\n        (_DWORD *)(*(_QWORD *)(a1 + 120) + 256LL),\n        v15,\n        v5,\n        *(unsigned int *)(a1 + 16));\n      v6 -= 0x4000000000000000LL;\n    }\n    while ( v6 > 0x3FFFFFFFFFFFFFFFLL );\n    v4 = a1;\n    v12 = a4 & 0x3FFFFFFFFFFFFFFFLL;\n    v13 = (((a4 - 0x4000000000000000LL) >> 62) + 1) << 62;\n    v17 += v13;\n    v16 += v13;\n  }\n  if ( v12 )\n    DES_ede3_cfb64_encrypt(\n      v17,\n      v16,\n      v12,\n      *(_DWORD **)(v4 + 120),\n      (_DWORD *)(*(_QWORD *)(v4 + 120) + 128LL),\n      (_DWORD *)(*(_QWORD *)(v4 + 120) + 256LL),\n      (unsigned __int8 *)(v4 + 40),\n      (int *)(v4 + 88),\n      *(unsigned int *)(v4 + 16));\n  return 1LL;\n}\n",
    "source_code": "\nstatic int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n\t\t\t      const unsigned char *in, size_t inl)\n{\n\twhile (inl>=EVP_MAXCHUNK)\n\t\t{\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, \n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n\t\t\t       (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\t\tinl-=EVP_MAXCHUNK;\n\t\tin +=EVP_MAXCHUNK;\n\t\tout+=EVP_MAXCHUNK;\n\t\t}\n\tif (inl)\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)inl,\n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n                               (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\treturn 1;\n}",
    "comment": "Encrypts input data using Triple DES in CFB64 mode, processing it in chunks of EVP_MAXCHUNK size.",
    "hext5_sum": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
    "bint5_sum": "Encrypts input data using DES in CFB mode , processing it in chunks and updating the cipher context accordingly .\n",
    "cpbcs_sum": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
    "misum_sum": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
    "decom_sum": "Encrypts data in 3DES CFB64 mode, processing large inputs in 2^62-byte chunks using context state from the provided structure.",
    "cfg_sum": "Encrypts input data using Triple DES in CFB64 mode, processing large blocks iteratively and handling remaining bytes with maintained encryption state.",
    "work_score": {
        "hext5": {
            "summary": "(x) dx = 1/(x * sqrt(2 pi sigma^2)) exp(-(ln(x) - zeta)^2/2 sigma^2) dx for x > 0. lognormal random numbers are the exponentials of gaussian random numbers the lognormal distribution has the form",
            "score": [
                0.0,
                0.0,
                0.4
            ],
            "reason": [
                "The summary presents a mathematical formula for a lognormal distribution unrelated to the provided source code, which implements a DES-EDE3 CFB64 cipher function in C. None of the claims in the summary reflect the source code\u2019s functionality or semantics, making all claims inaccurate.",
                "The summary contains mathematical statements about the lognormal distribution and Gaussian random numbers, which are unrelated to the given source code. It does not mention the function's purpose, which involves performing 3DES CFB64 encryption in chunks, nor any inputs, outputs, or internal logic. All claims are irrelevant, making them inaccurate, and the primary purpose is completely missed.",
                "The summary contains only mathematical descriptions of a lognormal distribution, which is entirely unrelated to the source code implementing a DES-EDE CFB64 encryption function. All claims are NOISE, with no accurate mapping to the code\u2019s purpose, inputs, or behavior, resulting in overwhelming irrelevance and no useful insight."
            ]
        },
        "bint5": {
            "summary": "Encrypts input data using DES in CFB mode , processing it in chunks and updating the cipher context accordingly .\n",
            "score": [
                0.9,
                0.6,
                0.5
            ],
            "reason": [
                "The summary correctly states that the function encrypts input data using DES in CFB mode and processes it in chunks. While it omits the detail that the code uses Triple DES (DES-EDE3) specifically rather than single DES, its mention of updating the cipher context aligns with the updating of the IV and num parameters in the code. Most claims are accurate, with only a minor specificity gap.",
                "The summary correctly captures the primary purpose of the function, which is to perform encryption using DES in CFB mode. It also notes that the data is processed in chunks and implies state updates by mentioning the cipher context. However, it omits secondary details such as the use of triple-DES (DES-ede3), the specific chunk size constant (EVP_MAXCHUNK), handling of partial final chunks, and the fixed return value. This limits coverage of key secondary details from the source code.",
                "The summary contains a single accurate claim: it describes using DES in CFB mode, processing data in chunks, and updating the cipher context, all of which match the source function's purpose and implementation. The claim is broad but correct, offering low informational gain due to lack of specifics about the triple-DES variant or exact function parameters. There are no inaccuracies or contradictions, so the worst failure mode is absent, but the detail level is minimal."
            ]
        },
        "cpbcs": {
            "summary": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary claims the function uses OFB mode, but the source code clearly uses DES_ede3_cfb64_encrypt, which is CFB mode, making this a direct semantic contradiction. While it correctly mentions processing in chunks of EVP_MAXCHUNK, the mode misidentification is a critical inaccuracy, leaving less than half of the claims accurate.",
                "The summary misidentifies the encryption mode as OFB, while the source code explicitly uses DES_ede3_cfb64_encrypt, which implements CFB64 mode. Although it correctly notes chunked processing with EVP_MAXCHUNK, the incorrect mode contradicts a core semantic unit (the primary purpose), resulting in an inaccurate description overall.",
                "The summary contains a FATAL error: it incorrectly states that the code uses OFB mode, while the source clearly calls DES_ede3_cfb64_encrypt, which implements CFB mode. This misidentifies the primary purpose (encryption mode), making the summary unreliable despite correctly noting chunked processing via EVP_MAXCHUNK. The worst failure mode is a FATAL error on core semantics."
            ]
        },
        "misum": {
            "summary": "Encrypts input data using DES EDE3 in OFB mode, processing in chunks of EVP_MAXCHUNK size.\n",
            "score": [
                0.2,
                0.2,
                0.2
            ],
            "reason": [
                "The summary incorrectly states that the function uses OFB mode, while the source code clearly shows it calls DES_ede3_cfb64_encrypt, which is CFB mode. The chunk processing and EVP_MAXCHUNK detail are accurate, but the core encryption mode claim is incorrect, making a significant portion of the claims inaccurate. This results in less than half of the claims being accurate.",
                "The summary incorrectly states that the function uses OFB mode, while the source code clearly shows it calls DES_ede3_cfb64_encrypt, which implements CFB mode. Although it accurately notes chunked processing by EVP_MAXCHUNK, the primary purpose is misrepresented, which makes the claim inaccurate and fails to cover essential implementation details.",
                "The summary claims the function uses DES EDE3 in OFB mode, but the source code clearly uses DES_ede3_cfb64_encrypt, which is CFB mode. This is a FATAL inaccuracy affecting the primary purpose of the function. The chunk processing detail is accurate, but the mode misstatement undermines reliability."
            ]
        }
    }
}
