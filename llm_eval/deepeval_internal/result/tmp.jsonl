{
    "source_code": "\nint\nmu_get_host_name (char **host)\n{\n  char *hostname = NULL;\n  size_t size = 0;\n  char *p;\n\n  while (1)\n    {\n      if (size == 0)\n\t{\n\t  size = MAXHOSTNAMELEN;\n\t  p = malloc (size);\n\t}\n      else\n\t{\n\t  size_t ns = size * 2;\n\t  if (ns < size)\n\t    {\n\t      free (hostname);\n\t      return ENOMEM;\n\t    }\n\t  size = ns;\n\t  p = realloc (hostname, size);\n\t}\n      if (!p)\n\t{\n\t  free (hostname);\n\t  return ENOMEM;\n\t}\n      hostname = p;\n      hostname[size - 1] = 0;\n      if (gethostname (hostname, size - 1) == 0)\n\t{\n\t  if (!hostname[size - 1])\n\t    break;\n\t}\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n\t       && errno != ENOMEM)\n\t{\n\t  int rc = errno;\n\t  free (hostname);\n\t  return rc;\n\t}\n    }\n\n  /* Try to return fully qualified host name */\n  if (!strchr (hostname, '.'))\n    {\n      struct hostent *hp = gethostbyname (hostname);\n      if (hp)\n\t{\n\t  size_t len = strlen (hp->h_name);\n\t  if (size < len + 1)\n\t    {\n\t      p = realloc (hostname, len + 1);\n\t      if (!p)\n\t\t{\n\t\t  free (hostname);\n\t\t  return ENOMEM;\n\t\t}\n\t      hostname = p;\n\t    }\n\t  strcpy (hostname, hp->h_name);\n\t}\n    }\n  \n  *host = hostname;\n  return 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall mu_get_host_name(char **a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-34h]\n  char *ptr; // [rsp+20h] [rbp-30h]\n  size_t size; // [rsp+28h] [rbp-28h]\n  char *v5; // [rsp+30h] [rbp-20h]\n  char *v6; // [rsp+30h] [rbp-20h]\n  size_t v7; // [rsp+38h] [rbp-18h]\n  struct hostent *v8; // [rsp+40h] [rbp-10h]\n  size_t v9; // [rsp+48h] [rbp-8h]\n\n  ptr = 0LL;\n  size = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      if ( size )\n      {\n        v7 = 2 * size;\n        if ( 2 * size < size )\n          goto LABEL_20;\n        size *= 2LL;\n        v5 = (char *)realloc(ptr, v7);\n      }\n      else\n      {\n        size = 64LL;\n        v5 = (char *)malloc(0x40uLL);\n      }\n      if ( !v5 )\n        goto LABEL_20;\n      ptr = v5;\n      v5[size - 1] = 0;\n      if ( !gethostname(v5, size - 1) )\n        break;\n      if ( *__errno_location() && *__errno_location() != 36 && *__errno_location() != 22 && *__errno_location() != 12 )\n      {\n        v2 = *__errno_location();\n        free(v5);\n        return v2;\n      }\n    }\n  }\n  while ( v5[size - 1] );\n  if ( !strchr(v5, 46) )\n  {\n    v8 = gethostbyname(v5);\n    if ( v8 )\n    {\n      v9 = strlen(v8->h_name);\n      if ( size < v9 + 1 )\n      {\n        v6 = (char *)realloc(v5, v9 + 1);\n        if ( !v6 )\n        {\nLABEL_20:\n          free(ptr);\n          return 12LL;\n        }\n        ptr = v6;\n      }\n      strcpy(ptr, v8->h_name);\n    }\n  }\n  *a1 = ptr;\n  return 0LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[ '{                                                                                                  \\n     char *(*alloc_func)(size_t) = malloc;                                                     \\n     char *(*realloc_func)(",
        "<s><asm_token>\n\"static char *\\nmu_expand_path (const char *path, const char *home)\\n{\\n  char *rpath = NULL;\\n  char *p, *r",
        "<s><asm_token>\n'static char **\\nget_fnames (const char *path)\\n{\\n  char **fnames = NULL;\\n  char *p, *q, *q1;\\n",
        "<s><asm_token>\n  'MU_PATH_SEP_T mu_path_sep_get_default (void)\\n{\\n  char *path;\\n  MU_PATH_SEP_",
        "<s><asm_token>\n  'static char **\\nmake_arglist (const char *cmdline)\\n{\\n  char **argv;\\n  char *s, *t;\\n  int i, arg"
    ],
    "prorec_sum": "Retrieves the system's host name, expanding the buffer as needed and resolving the fully qualified name if no domain is present.",
    "extracted_features": [
        "gethostname",
        "__errno_location",
        "gethostbyname",
        "strchr",
        "strlen",
        "strcpy"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[ '{                                                                                                  \\n     char *(*alloc_func)(size_t) = malloc;                                                     \\n     char *(*realloc_func)(",
        "\"static char *\\nmu_expand_path (const char *path, const char *home)\\n{\\n  char *rpath = NULL;\\n  char *p, *r",
        "'static char **\\nget_fnames (const char *path)\\n{\\n  char **fnames = NULL;\\n  char *p, *q, *q1;\\n",
        "  'MU_PATH_SEP_T mu_path_sep_get_default (void)\\n{\\n  char *path;\\n  MU_PATH_SEP_",
        "  'static char **\\nmake_arglist (const char *cmdline)\\n{\\n  char **argv;\\n  char *s, *t;\\n  int i, arg"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Retrieves the local host name, expanding buffer if needed, and resolves it to a fully qualified name when missing a domain.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves the system's host name, expanding the buffer as needed and resolving the fully qualified name if no domain is present.",
            "score": [
                0.9387942589422738,
                0.815452309254229,
                0.8734140346099661
            ],
            "reason": [
                "The summary accurately describes the function's purpose and behavior: it retrieves the system's host name and expands the buffer as needed, consistent with the code's logic. It also mentions resolving the fully qualified name if no domain is present, aligning with the function's use of 'gethostbyname' to achieve this. Nearly all claims in the summary are specific and correctly reflect the function's behavior, indicating high precision.",
                "The summary accurately covers the core purpose of the function, which is to retrieve the system's host name and expand the buffer as needed. It also mentions resolving the fully qualified name if no domain is present, which aligns with the secondary behavior of checking for a dot and using `gethostbyname`. However, it lacks details on error handling and specific conditions like `ENOMEM`, `ENAMETOOLONG`, and `EINVAL`, which are critical for complete coverage.",
                "The summary accurately describes the function's primary purpose of retrieving the system's host name and expanding the buffer as needed. It also correctly mentions resolving the fully qualified name if no domain is present, which aligns with the source code's logic of checking for a dot and using gethostbyname. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves the local host name, expanding buffer if needed, and resolves it to a fully qualified name when missing a domain.",
            "score": [
                0.9211515508103251,
                0.825107346627129,
                0.8737994445621691
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it retrieves the local host name, expands the buffer as needed, and resolves it to a fully qualified name if missing a domain. These claims align well with the source code, which includes buffer allocation and expansion, hostname retrieval, and domain resolution. The summary captures the key operations performed by the function, with only minor omissions in detail.",
                "The summary accurately covers the core primary purpose of the function, which is to retrieve the local host name and resolve it to a fully qualified name if necessary. It mentions expanding the buffer, which aligns with the dynamic memory allocation and resizing logic in the source code. However, it lacks details on error handling and specific conditions checked in the source code, such as handling errors like ENOMEM, ENAMETOOLONG, and EINVAL.",
                "The summary accurately describes the function's primary purpose of retrieving the local host name and expanding the buffer as needed. It also correctly notes the resolution to a fully qualified name when the domain is missing, which aligns with the source code's logic. The claims are specific and detailed, providing high gain with negligible noise."
            ]
        }
    }
}
{
    "source_code": "int drm_markbufs(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tstruct drm_buf_desc *request = data;\n\tint order;\n\tstruct drm_buf_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\treturn -EINVAL;\n\n\tif (!dma)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"%d, %d, %d\\n\",\n\t\t  request->size, request->low_mark, request->high_mark);\n\torder = drm_order(request->size);\n\tif (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)\n\t\treturn -EINVAL;\n\tentry = &dma->bufs[order];\n\n\tif (request->low_mark < 0 || request->low_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\tif (request->high_mark < 0 || request->high_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\n\tentry->freelist.low_mark = request->low_mark;\n\tentry->freelist.high_mark = request->high_mark;\n\n\treturn 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81372A30(__int64 a1, _DWORD *a2)\n{\n  __int64 v2; // r12\n  unsigned __int64 v4; // rsi\n  unsigned __int64 v5; // rax\n  int i; // ecx\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // rdx\n  int v11; // esi\n  int v12; // eax\n\n  v2 = *(_QWORD *)(a1 + 400);\n  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 888) + 416LL) & 0x20) == 0 )\n    return 4294967274LL;\n  if ( !v2 )\n    return 4294967274LL;\n  sub_FFFFFFFF81379AC0(1, (unsigned int)\"drm\", (unsigned int)\"drm_markbufs\", (unsigned int)\"%d, %d, %d\\n\", a2[1], a2[2]);\n  v4 = (int)a2[1];\n  v5 = v4 >> 1;\n  if ( !(v4 >> 1) )\n    return 4294967274LL;\n  for ( i = 0; ; ++i )\n  {\n    v5 >>= 1;\n    v7 = i + 1;\n    if ( !v5 )\n      break;\n  }\n  if ( (v4 & (v4 - 1)) != 0 )\n  {\n    v7 = i + 2;\n    v8 = i - 3;\n  }\n  else\n  {\n    v8 = i - 4;\n  }\n  if ( v8 > 0x11 )\n    return 4294967274LL;\n  v9 = a2[2];\n  if ( v9 < 0 )\n    return 4294967274LL;\n  v10 = (_DWORD *)(v2 + 88LL * v7);\n  v11 = v10[1];\n  if ( v9 > v11 )\n    return 4294967274LL;\n  v12 = a2[3];\n  if ( v11 < v12 || v12 < 0 )\n    return 4294967274LL;\n  v10[18] = v9;\n  v10[19] = a2[3];\n  return 0LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    \\nstatic int\\nintel_dp_link_down(struct intel_encoder *encoder, int old_crtc_state)\\n{\\n\\",
        "<s><asm_token>\n\"int\\ngen6_render_ring_init_hw(struct intel_engine_cs *ring)\\n{\\n\\tstruct drm_i915_private *dev",
        "<s><asm_token>\n'int\\ngma_i2c_read_byte(struct drm_device *dev, uint8_t addr, uint8_t *data)\\n{\\n\\tstruct",
        "<s><asm_token>\n\\'\\nstatic int drm_atomic_check_only(struct drm_device *dev, struct drm_atomic_state *state)\\n{\\n\\tstruct drm_",
        "<s><asm_token>\n\\'\\nstatic int i915_gem_set_caching(struct drm_crtc *crtc, unsigned int caching)\\n{\\n\\tstruct drm"
    ],
    "prorec_sum": "Validates DRM buffer parameters and updates buffer metadata entries after confirming alignment, size constraints, and device state readiness.",
    "extracted_features": [
        "drm",
        "drm_markbufs"
    ],
    "filter_strong": [],
    "filter_backup": [
        "[\n'    \\nstatic int\\nintel_dp_link_down(struct intel_encoder *encoder, int old_crtc_state)\\n{\\n\\",
        "'int\\ngma_i2c_read_byte(struct drm_device *dev, uint8_t addr, uint8_t *data)\\n{\\n\\tstruct",
        "\\'\\nstatic int drm_atomic_check_only(struct drm_device *dev, struct drm_atomic_state *state)\\n{\\n\\tstruct drm_",
        "\\'\\nstatic int i915_gem_set_caching(struct drm_crtc *crtc, unsigned int caching)\\n{\\n\\tstruct drm"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "\"int\\ngen6_render_ring_init_hw(struct intel_engine_cs *ring)\\n{\\n\\tstruct drm_i915_private *dev"
    ],
    "debug_log": [
        "Idx 0: Backup (Contains 'drm' which matches one of the extracted string literals.)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Backup (Contains 'drm_device' which includes the 'drm' literal.)",
        "Idx 3: Backup (Contains 'drm_device' which includes the 'drm' literal.)",
        "Idx 4: Backup (Contains 'drm_crtc' which includes the 'drm' literal.)"
    ],
    "filter_prorec_sum": "Validates DRM buffer parameters and updates specific buffer state fields after ensuring proper alignment, range limits, and feature enablement.",
    "work_score": {
        "prorec": {
            "summary": "Validates DRM buffer parameters and updates buffer metadata entries after confirming alignment, size constraints, and device state readiness.",
            "score": [
                0.8107926642496025,
                0.7527625707374335,
                0.7869959760201503
            ],
            "reason": [
                "The summary accurately describes the function's purpose of validating DRM buffer parameters and updating buffer metadata entries. It correctly mentions the checks for alignment, size constraints, and device state readiness, which are present in the source code through various conditional checks and assignments. Most claims are specific and verifiable, aligning well with the function's behavior.",
                "The summary accurately covers the core purpose of the function, which is to validate DRM buffer parameters and update buffer metadata entries. It mentions key operations such as alignment, size constraints, and device state readiness, which align with the checks and updates performed in the source code. However, it lacks mention of specific error conditions like returning -EINVAL for invalid parameters, which prevents a higher score.",
                "The summary accurately describes the function's purpose of validating DRM buffer parameters and updating metadata entries, aligning with the source code's checks on device readiness, size constraints, and buffer marks. The claims are specific and verifiable, providing high gain by summarizing the core functionality without introducing noise or inaccuracies."
            ]
        },
        "filter_prorec": {
            "summary": "Validates DRM buffer parameters and updates specific buffer state fields after ensuring proper alignment, range limits, and feature enablement.",
            "score": [
                0.8716283474815658,
                0.7892095524624287,
                0.8041980106791737
            ],
            "reason": [
                "The summary accurately describes the function's behavior, including validation of DRM buffer parameters, updating buffer state fields, and checking feature enablement. It aligns well with the source code, which performs these checks and updates, indicating high precision in the claims.",
                "The summary accurately covers the core purpose of the function, which is to validate DRM buffer parameters and update buffer state fields. It mentions key operations such as ensuring feature enablement and checking range limits, aligning well with the source code's checks for DRIVER_HAVE_DMA, order limits, and buffer count constraints. However, it lacks specific mention of error handling for invalid conditions, which is a critical aspect of the function's behavior.",
                "The summary accurately captures the core functionality of the function, which involves validating DRM buffer parameters and updating buffer state fields. It correctly mentions the checks for feature enablement and range limits, aligning well with the source code. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic const char* findlocal(lua_State* L, CallInfo* ci, int n, StkId* pos) {\n  const char* name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0) /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  } else\n    base = ci->func + 1;\n  if (name == NULL) { /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\"; /* generic name for any valid slot */\n    else\n      return NULL; /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}",
    "strip_decompiled_code": "const char *__fastcall sub_9BE0(__int64 a1, __int64 *a2, int a3, _QWORD *a4)\n{\n  __int64 v6; // rdx\n  __int64 v7; // r12\n  __int64 v8; // rdi\n  int v9; // ebp\n  const char *result; // rax\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  _QWORD *v13; // [rsp+8h] [rbp-30h]\n\n  v6 = *a2;\n  if ( (*((_BYTE *)a2 + 66) & 2) != 0 )\n  {\n    v7 = a2[4];\n    v8 = *(_QWORD *)(*(_QWORD *)v6 + 24LL);\n    if ( a3 < 0 )\n    {\n      v9 = -a3;\n      if ( v9 < (int)(((v7 - v6) >> 4) - *(unsigned __int8 *)(v8 + 10)) )\n      {\n        *a4 = v6 + 16 * (v9 + (unsigned __int64)*(unsigned __int8 *)(v8 + 10));\n        return \"(*vararg)\";\n      }\n      return 0LL;\n    }\n    v13 = a4;\n    result = (const char *)sub_CF30(v8, (unsigned int)a3, (unsigned int)((a2[5] - *(_QWORD *)(v8 + 56)) >> 2) - 1);\n    v12 = a3;\n    a4 = v13;\n    if ( result )\n    {\nLABEL_11:\n      *a4 = v7 + 16 * v12 - 16;\n      return result;\n    }\n  }\n  else\n  {\n    v7 = v6 + 16;\n  }\n  if ( *(__int64 **)(a1 + 32) == a2 )\n    v11 = *(_QWORD *)(a1 + 16);\n  else\n    v11 = *(_QWORD *)a2[3];\n  v12 = a3;\n  if ( (v11 - v7) >> 4 >= a3 && a3 > 0 )\n  {\n    result = \"(*temporary)\";\n    goto LABEL_11;\n  }\n  return 0LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    if (obj->data.str.str == NULL)\\n\\treturn 0;\\n\\n\\t/* Find the position of the string. */\\n\\t",
        "<s><asm_token>\n\"static int\\nset_option (struct lr_parser *parser, const char *option_name,\\n             const char *option_value, void *data)\\n{\\n ",
        "<s><asm_token>\n'static ngx_int_t\\nngx_http_lua_post_subrequest(ngx_http_request_t *r, void *parent, ngx_int",
        "<s><asm_token>\nc = '    ngx_queue_insert_head(&(q)->queue, &(e)->queue);\\n    (e)->prev = (q)->last;\\n    (e",
        "<s><asm_token>\ngives_line_breaks = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"
    ],
    "prorec_sum": "Retrieves a specific argument or temporary variable from a parser\u2019s stack and returns its descriptive name, storing its memory address in the provided pointer.",
    "extracted_features": [
        "(*vararg)",
        "(*temporary)",
        "sub_CF30"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        {
            "fragment": "gives_line_breaks = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0",
            "reason": "Only shows repetitive data initialization with numeric values and no control flow or logic."
        },
        "[\n'    if (obj->data.str.str == NULL)\\n\\treturn 0;\\n\\n\\t/* Find the position of the string. */\\n\\t",
        "\"static int\\nset_option (struct lr_parser *parser, const char *option_name,\\n             const char *option_value, void *data)\\n{\\n ",
        "'static ngx_int_t\\nngx_http_lua_post_subrequest(ngx_http_request_t *r, void *parent, ngx_int",
        "c = '    ngx_queue_insert_head(&(q)->queue, &(e)->queue);\\n    (e)->prev = (q)->last;\\n    (e"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Retrieves a function argument or temporary value index and returns its label while storing the corresponding memory location pointer.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves a specific argument or temporary variable from a parser\u2019s stack and returns its descriptive name, storing its memory address in the provided pointer.",
            "score": [
                0.378757981293229,
                0.3958678380724698,
                0.42713522108273977
            ],
            "reason": [
                "The summary correctly identifies that the function retrieves a variable from a stack and returns its name, which aligns with the source code's behavior of finding local or temporary variables. However, it inaccurately describes the function as dealing with a parser's stack, which is not specified in the source code. Additionally, the summary mentions storing a memory address, which is misleading as the function stores a stack position, not a memory address. These inaccuracies result in mixed reliability.",
                "The summary mentions retrieving a specific argument or temporary variable and returning its descriptive name, which aligns with the function's purpose of finding local variable names. However, it inaccurately describes storing a memory address, which is not explicitly covered in the source code. The core purpose of finding local names is mentioned, but secondary details like handling varargs, stack limits, and returning NULL for invalid slots are missing.",
                "The summary correctly identifies the function's purpose of retrieving a variable name from the stack, which aligns with the source code's logic of finding local or temporary variable names. However, it inaccurately describes the function as storing a memory address, which is misleading since the function stores a stack position, not a memory address. This introduces noise but does not contradict the core functionality, resulting in a mediocre net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves a function argument or temporary value index and returns its label while storing the corresponding memory location pointer.",
            "score": [
                0.536415420370843,
                0.4626831729547087,
                0.5290434369597603
            ],
            "reason": [
                "The summary accurately describes the function's purpose of retrieving a label for a function argument or temporary value and storing the corresponding memory location pointer. However, it lacks specificity regarding the conditions under which different names are returned, such as handling vararg values or the use of '(*temporary)' for valid slots without standard names. This results in mixed reliability, as only some claims are precise and aligned with the source code.",
                "The summary covers the core purpose of retrieving a function argument or temporary value index and returning its label, which aligns with the function's operation of finding local variable names. However, it lacks detail on secondary aspects such as handling vararg values, the conditions under which a generic name is returned, and the specific logic for setting the memory location pointer.",
                "The summary correctly identifies the function's purpose of retrieving a label for a function argument or temporary value and storing the corresponding memory location pointer, which aligns with the source code's behavior. However, it lacks specificity regarding the conditions under which different labels are returned, such as handling vararg values and the use of '(*temporary)' for valid slots without standard names. The summary is somewhat generic and does not provide detailed insights into the function's logic, resulting in a low net benefit."
            ]
        }
    }
}
{
    "source_code": "  \nvoid\nmu_ident_stat (mu_stream_t str)\n{\n  size_t count, i;\n  mu_iterator_t itr;\n  \n  mu_stream_printf (str, \"BEGIN IDENT STAT\\n\");\n\n  mu_assoc_count (nametab, &count);\n  mu_stream_printf (str, \"N=%zu\\n\", count);\n\n  if (count > 0)\n    {\n      int rc = mu_assoc_get_iterator (nametab, &itr);\n      if (rc)\n\tmu_stream_printf (str, \"mu_assoc_get_iterator: %s\\n\",\n\t\t\t  mu_strerror (rc));\n      else\n\t{\n\t  i = 0;\n\t  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);\n\t       mu_iterator_next (itr), i++)\n\t    {\n\t      const char *key;\n\t      struct mu_ident_ref *ref;\n\t      \n\t      mu_iterator_current_kv (itr,\n\t\t\t\t      (const void **)&key, (void **)&ref);  \n\t      mu_stream_printf (str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n\t    }\n\t}\n      mu_iterator_destroy (&itr);\n    }\n  mu_stream_printf (str, \"END IDENT STAT\\n\");\n}",
    "strip_decompiled_code": "unsigned __int64 __fastcall mu_ident_stat(int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  int v9; // edx\n  int v10; // ecx\n  int v11; // r8d\n  int v12; // r9d\n  int v13; // eax\n  int v14; // ecx\n  int v15; // r8d\n  int v16; // r9d\n  int v17; // r9d\n  char v19; // [rsp+0h] [rbp-50h]\n  char v20; // [rsp+0h] [rbp-50h]\n  char v21; // [rsp+0h] [rbp-50h]\n  unsigned int iterator; // [rsp+1Ch] [rbp-34h]\n  __int64 v23; // [rsp+20h] [rbp-30h] BYREF\n  __int64 v24; // [rsp+28h] [rbp-28h] BYREF\n  __int64 v25; // [rsp+30h] [rbp-20h] BYREF\n  _QWORD *v26; // [rsp+38h] [rbp-18h] BYREF\n  __int64 v27; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v28; // [rsp+48h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  mu_stream_printf(a1, (int)\"BEGIN IDENT STAT\\n\", a3, a4, a5, a6, v19);\n  mu_assoc_count(qword_2DFC80, &v23);\n  mu_stream_printf(a1, (int)\"N=%zu\\n\", v23, v6, v7, v8, v20);\n  if ( v23 )\n  {\n    iterator = mu_assoc_get_iterator(qword_2DFC80, &v24);\n    if ( iterator )\n    {\n      v13 = mu_strerror(iterator);\n      mu_stream_printf(a1, (int)\"mu_assoc_get_iterator: %s\\n\", v13, v14, v15, v16, v21);\n    }\n    else\n    {\n      v27 = 0LL;\n      mu_iterator_first(v24);\n      while ( !(unsigned int)mu_iterator_is_done(v24) )\n      {\n        mu_iterator_current_kv(v24, &v25, &v26);\n        mu_stream_printf(a1, (int)\"%04zu: %s: %zu\\n\", v27, v25, *v26, v17, v21);\n        mu_iterator_next(v24);\n        ++v27;\n      }\n    }\n    mu_iterator_destroy(&v24);\n  }\n  mu_stream_printf(a1, (int)\"END IDENT STAT\\n\", v9, v10, v11, v12, v21);\n  return __readfsqword(0x28u) ^ v28;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[ ' \\nstatic void\\nmu_imap_list_write_response (mu_imap_t imap, mu_imap_response_t res)\\n{\\n",
        "<s><asm_token>\n\"static void\\n_dump_group (mu_group_t group, int level)\\n{\\n  int i;\\n  mu_group_iter_t iter;\\n  mu",
        "<s><asm_token>\n'  \\nstatic void\\nreport_duplicate_field (mu_imap_parser_t parser, mu_imap_field_t field)\\n{\\n  mu_",
        "<s><asm_token>\n\\'\\nstatic void\\nmu_test_cmd_test_fatal (mu_cmd_t cmd, mu_cmd_arg_t arg, void *data)\\n{\\n",
        "<s><asm_token>\n\\'\\nstatic void\\nmu_test_smtp_message (mu_message_t msg)\\n{\\n  mu_smtp_message_t smtp_msg = mu"
    ],
    "prorec_sum": "Outputs association statistics, iterating over key-value pairs to print each entry\u2019s index, key, and value between BEGIN and END IDENT STAT markers.",
    "extracted_features": [
        "BEGIN IDENT STAT",
        "END IDENT STAT",
        "mu_assoc_count",
        "mu_assoc_get_iterator",
        "mu_strerror",
        "mu_iterator_first",
        "mu_iterator_is_done",
        "mu_iterator_current_kv",
        "mu_iterator_next",
        "mu_iterator_destroy"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[ ' \\nstatic void\\nmu_imap_list_write_response (mu_imap_t imap, mu_imap_response_t res)\\n{\\n",
        "\"static void\\n_dump_group (mu_group_t group, int level)\\n{\\n  int i;\\n  mu_group_iter_t iter;\\n  mu",
        "'  \\nstatic void\\nreport_duplicate_field (mu_imap_parser_t parser, mu_imap_field_t field)\\n{\\n  mu_",
        "\\'\\nstatic void\\nmu_test_cmd_test_fatal (mu_cmd_t cmd, mu_cmd_arg_t arg, void *data)\\n{\\n",
        "\\'\\nstatic void\\nmu_test_smtp_message (mu_message_t msg)\\n{\\n  mu_smtp_message_t smtp_msg = mu"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Outputs identification statistics by counting entries in an association, iterating key-value pairs, and printing formatted results to the provided stream.",
    "work_score": {
        "prorec": {
            "summary": "Outputs association statistics, iterating over key-value pairs to print each entry\u2019s index, key, and value between BEGIN and END IDENT STAT markers.",
            "score": [
                0.9169054336338421,
                0.8374400083027792,
                0.8706448596106661
            ],
            "reason": [
                "The summary accurately describes the function's behavior, capturing the key aspects of iterating over key-value pairs and printing each entry's index, key, and value between specific markers. The claims are highly specific and verifiable against the source code, with only minor omissions regarding error handling.",
                "The summary accurately covers the core purpose of the function, which is to output association statistics by iterating over key-value pairs and printing each entry's index, key, and value. This aligns with the function's operation of printing statistics between 'BEGIN IDENT STAT' and 'END IDENT STAT' markers. The summary captures the main functionality and includes key details such as the iteration over key-value pairs and the output format. However, it lacks mention of error handling when obtaining the iterator and the destruction of the iterator, which are critical secondary behaviors.",
                "The summary accurately describes the function's behavior, capturing the core purpose of outputting association statistics and iterating over key-value pairs. It correctly mentions the printing of each entry's index, key, and value between specific markers, aligning well with the source code. There is minimal noise and the claims provide high gain by being specific and detailed, saving the engineer time."
            ]
        },
        "filter_prorec": {
            "summary": "Outputs identification statistics by counting entries in an association, iterating key-value pairs, and printing formatted results to the provided stream.",
            "score": [
                0.8974460172009022,
                0.7846541866382288,
                0.8326336505858845
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it outputs identification statistics, counts entries in an association, iterates over key-value pairs, and prints formatted results to a stream. These claims align well with the source code, which includes counting entries with 'mu_assoc_count', iterating with 'mu_assoc_get_iterator', and printing with 'mu_stream_printf'. The summary captures the core functionality without inaccuracies, achieving high precision.",
                "The summary accurately covers the core purpose of the function, which is to output identification statistics by counting entries in an association and iterating over key-value pairs to print formatted results. It captures the main domain operation of iterating and printing statistics, aligning well with the source code. However, it lacks mention of error handling and specific stream operations, which are critical secondary behaviors.",
                "The summary accurately captures the primary purpose of the function, which is to output identification statistics by counting entries in an association, iterating over key-value pairs, and printing formatted results to the provided stream. This aligns well with the source code, which performs these actions. The claims are specific and verifiable, providing high gain by clearly stating the function's core behavior without introducing noise or inaccuracies."
            ]
        }
    }
}
{
    "source_code": "\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n Fixup:\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF812D3CE0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // rax\n  __int64 v10; // r12\n  __int64 v11; // r13\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  __int64 (__fastcall *v14)(__int64); // rax\n  unsigned int v15; // ebx\n  __int64 result; // rax\n\n  v9 = *(_QWORD *)(a1 + 144);\n  v10 = a1 - 152;\n  if ( !v9 )\n  {\n    if ( !(unsigned __int8)sub_FFFFFFFF812D3760(\n                             *(_WORD *)(a1 - 92),\n                             *(_WORD *)(a1 - 90),\n                             *(_QWORD **)(a1 - 64),\n                             a2,\n                             a3,\n                             a4,\n                             a5,\n                             a6,\n                             a7,\n                             a8,\n                             a9) )\n    {\nLABEL_10:\n      if ( !*(_QWORD *)(a1 - 128) )\n        sub_FFFFFFFF812D1F30(v10);\n      goto LABEL_6;\n    }\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  }\n  v11 = *(_QWORD *)(v9 + 104);\n  if ( (unsigned __int8)sub_FFFFFFFF812D3760(\n                          *(_WORD *)(a1 - 92),\n                          *(_WORD *)(a1 - 90),\n                          *(_QWORD **)(a1 - 64),\n                          a2,\n                          a3,\n                          a4,\n                          a5,\n                          a6,\n                          a7,\n                          a8,\n                          a9) )\n    return sub_FFFFFFFF812D3050(a1, a2, a3, a4, a5, v12, v13, a8, a9);\n  if ( !v11 )\n    goto LABEL_10;\n  *(_BYTE *)(a1 + 1067) &= ~1u;\n  v14 = *(__int64 (__fastcall **)(__int64))(v11 + 48);\n  if ( !v14 || (v15 = v14(a1), sub_FFFFFFFF813F7A40(\"pci_pm_poweroff\", *(_QWORD *)(v11 + 48), v15), (result = v15) == 0) )\n  {\nLABEL_6:\n    sub_FFFFFFFF812DB930(5LL, v10);\n    return 0LL;\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]'\t\tif (pci_is_pcie(pdev)) {\\n\\t\\t\\tstruct pci_dev *parent = pdev->bus->self;\\",
        "<s><asm_token>\n\"static int ehci_hcd_relinquish_port(struct usb_hcd *hcd, int portnum)\\n{\\n\\tstruct ehci_",
        "<s><asm_token>\n'static int ata_pci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\\n{\\n\\tstruct ata",
        "<s><asm_token>\nsnippet = '''\nstatic int pci_bus_probe(struct device *dev)\\n\\t{\\n\\tstruct pci_bus *bus = to_pci_",
        "<s><asm_token>\nt = '    if (pci_is_enabled(dev)) {\\n        pci_set_master(dev);\\n        pci_try_set_mwi(dev"
    ],
    "prorec_sum": "Manages PCI device power-off by checking conditions, invoking device-specific callbacks, and performing fallback shutdown if no suitable handler is available.",
    "extracted_features": [
        "pci_pm_poweroff"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[...]'\t\tif (pci_is_pcie(pdev)) {\\n\\t\\t\\tstruct pci_dev *parent = pdev->bus->self;\\",
        "\"static int ehci_hcd_relinquish_port(struct usb_hcd *hcd, int portnum)\\n{\\n\\tstruct ehci_",
        "'static int ata_pci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\\n{\\n\\tstruct ata",
        "snippet = '''\nstatic int pci_bus_probe(struct device *dev)\\n\\t{\\n\\tstruct pci_bus *bus = to_pci_",
        "t = '    if (pci_is_enabled(dev)) {\\n        pci_set_master(dev);\\n        pci_try_set_mwi(dev"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Handles PCI device power-off by checking conditions, invoking optional callbacks, and issuing fallback or alternative actions based on power management checks.",
    "work_score": {
        "prorec": {
            "summary": "Manages PCI device power-off by checking conditions, invoking device-specific callbacks, and performing fallback shutdown if no suitable handler is available.",
            "score": [
                0.8684135148466249,
                0.6896241122704295,
                0.809721582469253
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it manages PCI device power-off by checking conditions (such as legacy PM support and presence of device-specific poweroff callbacks), invoking these callbacks if available, and performing a fallback shutdown if no suitable handler is present. These claims align well with the source code, indicating high precision in the summary.",
                "The summary accurately covers the core purpose of the function, which is to manage PCI device power-off by checking conditions and invoking device-specific callbacks. It mentions performing fallback shutdown, aligning with the source code's logic of default suspend and fixup operations. However, it lacks details on specific error handling and the legacy PM support check, which are critical secondary behaviors.",
                "The summary accurately describes the function's core purpose of managing PCI device power-off by checking conditions and invoking device-specific callbacks. It correctly mentions the fallback shutdown mechanism when no suitable handler is available, aligning well with the source code. The claims are specific and provide a clear understanding of the function's behavior, offering high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Handles PCI device power-off by checking conditions, invoking optional callbacks, and issuing fallback or alternative actions based on power management checks.",
            "score": [
                0.8425181943340403,
                0.5395289736498932,
                0.7745945767991096
            ],
            "reason": [
                "The summary accurately describes the function's behavior by mentioning the handling of PCI device power-off, checking conditions, invoking optional callbacks, and issuing fallback actions. These elements align well with the source code, which includes checks for legacy PM support, optional poweroff callbacks, and fallback actions like pci_pm_default_suspend and pci_fixup_device. The summary captures the core logic and flow of the function, with over 80% of claims being accurate.",
                "The summary covers the core purpose of handling PCI device power-off, mentioning condition checks and fallback actions, aligning with the source code's logic. However, it lacks specificity regarding the legacy support check, the invocation of 'pci_legacy_suspend', and the 'pci_fixup_device' function, which are critical secondary behaviors.",
                "The summary accurately describes the function's behavior by mentioning the handling of PCI device power-off, checking conditions, invoking optional callbacks, and issuing fallback actions. These elements align well with the source code, which checks for legacy PM support, invokes poweroff callbacks if available, and uses fallback actions. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "int Xorriso_register_node_target(struct XorrisO *xorriso, int node_idx,\n                                 char *disk_path, int flag)\n{\n int l;\n\n if(xorriso->node_targets_availmem == 0)\n   return(2);\n if(xorriso->hln_targets == NULL || node_idx < 0 ||\n    node_idx >= xorriso->hln_count)\n   return(0);\n if(xorriso->hln_targets[node_idx] != NULL) {\n   xorriso->node_targets_availmem+= strlen(xorriso->hln_targets[node_idx]) +1;\n   free(xorriso->hln_targets[node_idx]);\n }\n l= strlen(disk_path);\n if(xorriso->node_targets_availmem <= l + 1) {\n   sprintf(xorriso->info_text,\n \"Hardlink target buffer exceeds -temp_mem_limit. Hardlinks may get divided.\");\n   Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, \"FAILURE\", 0);\n   xorriso->node_targets_availmem= 0;\n   return(0);\n }\n xorriso->hln_targets[node_idx]= strdup(disk_path);\n if(xorriso->hln_targets[node_idx] == NULL) {\n   Xorriso_no_malloc_memory(xorriso, NULL, 0);\n   return(-1);\n }\n xorriso->node_targets_availmem-= (l + 1);\n return(1);\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_481150(__int64 a1, int a2, const char *a3)\n{\n  __int64 result; // rax\n  __int64 v4; // rbp\n  __int64 v5; // rcx\n  void *v7; // r15\n  __int64 v8; // r15\n  char **v9; // r14\n\n  result = 2LL;\n  v4 = *(_QWORD *)(a1 + 135592);\n  if ( v4 )\n  {\n    v5 = *(_QWORD *)(a1 + 135576);\n    result = 0LL;\n    if ( v5 )\n    {\n      if ( a2 >= 0 && *(_DWORD *)(a1 + 135560) > a2 )\n      {\n        v7 = *(void **)(v5 + 8LL * a2);\n        if ( v7 )\n        {\n          *(_QWORD *)(a1 + 135592) = v4 + strlen(*(const char **)(v5 + 8LL * a2)) + 1;\n          free(v7);\n          v4 = *(_QWORD *)(a1 + 135592);\n        }\n        v8 = (int)(strlen(a3) + 1);\n        if ( v8 >= v4 )\n        {\n          *(__m128i *)(a1 + 176644) = _mm_load_si128((const __m128i *)&xmmword_512970);\n          strcpy((char *)(a1 + 176708), \"t divided.\");\n          *(__m128i *)(a1 + 176660) = _mm_load_si128((const __m128i *)&xmmword_512980);\n          *(__m128i *)(a1 + 176676) = _mm_load_si128((const __m128i *)&xmmword_512990);\n          *(__m128i *)(a1 + 176692) = _mm_load_si128((const __m128i *)&xmmword_5129A0);\n          sub_4118F0((_DWORD *)a1, 0, (const char *)(a1 + 176644), 0, \"FAILURE\", 0);\n          *(_QWORD *)(a1 + 135592) = 0LL;\n          return 0LL;\n        }\n        else\n        {\n          v9 = (char **)(*(_QWORD *)(a1 + 135576) + 8LL * a2);\n          *v9 = strdup(a3);\n          if ( *(_QWORD *)(*(_QWORD *)(a1 + 135576) + 8LL * a2) )\n          {\n            result = 1LL;\n            *(_QWORD *)(a1 + 135592) = v4 - v8;\n          }\n          else\n          {\n            sub_40FA60(a1, 0LL, 0);\n            return 0xFFFFFFFFLL;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'int iso9660_read_directory_record(iso9660_file *file, unsigned int rec_nr,\\n\\t\\t\\t\\",
        "<s><asm_token>\n\"int iso9660_make_dir(struct iso9660_filesystem *fs, const char *name, int flags, int *result)\\n{\\n",
        "<s><asm_token>\n'int XorArchive::read_volume_header(XorArchive::VolumeHeader *vh, int vol)\\n{\\n    char *buf;\\n    int len;\\n",
        "<s><asm_token>\ni('\\nint iso9660_set_path_component(struct iso9660_file *file, char *path, int len, int *l)\\n",
        "<s><asm_token>\nn'int Xorriso_xor_path_append(struct Xorriso_xor_path *path, const char *str, int flags)\\n{\\n    struct"
    ],
    "prorec_sum": "Updates a string entry in an indexed array within a filesystem structure, freeing old data, enforcing size limits, and reporting failure if constraints are exceeded.",
    "extracted_features": [
        "strcpy",
        "strlen",
        "strdup",
        "FAILURE",
        "t divided."
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'int iso9660_read_directory_record(iso9660_file *file, unsigned int rec_nr,\\n\\t\\t\\t\\",
        "\"int iso9660_make_dir(struct iso9660_filesystem *fs, const char *name, int flags, int *result)\\n{\\n",
        "'int XorArchive::read_volume_header(XorArchive::VolumeHeader *vh, int vol)\\n{\\n    char *buf;\\n    int len;\\n",
        "i('\\nint iso9660_set_path_component(struct iso9660_file *file, char *path, int len, int *l)\\n",
        "n'int Xorriso_xor_path_append(struct Xorriso_xor_path *path, const char *str, int flags)\\n{\\n    struct"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Updates a string entry in a bounded array, adjusting remaining capacity, and reports failure if the new string exceeds the available space.",
    "work_score": {
        "prorec": {
            "summary": "Updates a string entry in an indexed array within a filesystem structure, freeing old data, enforcing size limits, and reporting failure if constraints are exceeded.",
            "score": [
                0.8811851546876366,
                0.6257841525746193,
                0.8060396470946127
            ],
            "reason": [
                "The summary accurately describes the function's behavior: updating a string entry in an indexed array, freeing old data, enforcing size limits, and reporting failure if constraints are exceeded. These claims align well with the source code, which checks memory availability, frees old entries, and handles size constraints with error reporting. The summary captures the core functionality and constraints, with only minor omissions regarding specific return values.",
                "The summary covers the core purpose of updating a string entry in an indexed array and freeing old data, which aligns with the function's operation of managing hardlink targets. It mentions enforcing size limits and reporting failure, which are secondary behaviors present in the source code. However, it lacks detail on specific error conditions and the exact nature of the constraints, such as memory availability checks and specific return values.",
                "The summary accurately describes the function's behavior, including updating a string entry, freeing old data, enforcing size limits, and reporting failure if constraints are exceeded. These claims align well with the source code, which checks memory availability, frees existing data, and handles memory constraints with error reporting. The claims are specific and provide a clear understanding of the function's core actions, resulting in high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Updates a string entry in a bounded array, adjusting remaining capacity, and reports failure if the new string exceeds the available space.",
            "score": [
                0.8757273462888516,
                0.6392594224819315,
                0.8302131765530254
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it updates a string entry in a bounded array, adjusts remaining capacity, and reports failure if the new string exceeds available space. These claims align well with the source code, which checks memory availability, updates the array, and handles errors when limits are exceeded. The summary captures the core functionality and logic of the function, with only minor omissions regarding specific error codes returned.",
                "The summary accurately covers the core purpose of updating a string entry in a bounded array and adjusting remaining capacity, which aligns with the function's operation of managing node targets and memory. However, it lacks coverage of secondary details such as handling specific error conditions (e.g., returning 2 when memory is unavailable, or -1 when strdup fails), and the specific messages submitted upon failure.",
                "The summary accurately describes the function's behavior of updating a string entry in a bounded array and adjusting the remaining capacity. It correctly notes the function's failure reporting when the new string exceeds available space, aligning well with the source code. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nstatic const char *\nget_symbol_index_type (Filedata * filedata, unsigned int type)\n{\n  static char buff[32];\n\n  switch (type)\n    {\n    case SHN_UNDEF:\treturn \"UND\";\n    case SHN_ABS:\treturn \"ABS\";\n    case SHN_COMMON:\treturn \"COM\";\n    default:\n      if (type == SHN_IA_64_ANSI_COMMON\n\t  && filedata->file_header.e_machine == EM_IA_64\n\t  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)\n\treturn \"ANSI_COM\";\n      else if ((filedata->file_header.e_machine == EM_X86_64\n\t\t|| filedata->file_header.e_machine == EM_L1OM\n\t\t|| filedata->file_header.e_machine == EM_K1OM)\n\t       && type == SHN_X86_64_LCOMMON)\n\treturn \"LARGE_COM\";\n      else if ((type == SHN_MIPS_SCOMMON\n\t\t&& filedata->file_header.e_machine == EM_MIPS)\n\t       || (type == SHN_TIC6X_SCOMMON\n\t\t   && filedata->file_header.e_machine == EM_TI_C6000))\n\treturn \"SCOM\";\n      else if (type == SHN_MIPS_SUNDEFINED\n\t       && filedata->file_header.e_machine == EM_MIPS)\n\treturn \"SUND\";\n      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)\n\tsprintf (buff, \"PRC[0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LOOS && type <= SHN_HIOS)\n\tsprintf (buff, \"OS [0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LORESERVE)\n\tsprintf (buff, \"RSV[0x%04x]\", type & 0xffff);\n      else if (type >= filedata->file_header.e_shnum)\n\tsprintf (buff, _(\"bad section index[%3d]\"), type);\n      else\n\tsprintf (buff, \"%3d\", type);\n      break;\n    }\n\n  return buff;\n}",
    "strip_decompiled_code": "char *__fastcall sub_407060(__int64 a1, unsigned int a2)\n{\n  char *result; // rax\n  __int16 v3; // dx\n  char *v4; // rax\n\n  result = \"ABS\";\n  if ( a2 == -15 )\n    return result;\n  result = \"COM\";\n  if ( a2 == -14 )\n    return result;\n  result = \"UND\";\n  if ( !a2 )\n    return result;\n  v3 = *(_WORD *)(a1 + 82);\n  if ( a2 == -256 )\n  {\n    if ( v3 == 50 )\n    {\n      result = \"ANSI_COM\";\n      if ( *(_BYTE *)(a1 + 31) == 1 )\n        return result;\n    }\n    else\n    {\n      result = \"SCOM\";\n      if ( v3 == 140 )\n        return result;\n    }\n    goto LABEL_10;\n  }\n  if ( (unsigned __int16)(v3 - 180) > 1u && v3 != 62 || (result = \"LARGE_COM\", a2 != -254) )\n  {\n    if ( a2 == -253 )\n    {\n      result = \"SCOM\";\n      if ( v3 == 8 )\n        return result;\n      goto LABEL_10;\n    }\n    if ( a2 != -252 || (result = \"SUND\", v3 != 8) )\n    {\n      if ( a2 + 256 > 0x1F )\n      {\n        if ( a2 + 224 <= 0x1F )\n        {\n          sprintf(byte_68E680, \"OS [0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else if ( a2 > 0xFFFFFEFF )\n        {\n          sprintf(byte_68E680, \"RSV[0x%04x]\", (unsigned __int16)a2);\n          return byte_68E680;\n        }\n        else\n        {\n          if ( a2 >= *(_DWORD *)(a1 + 100) )\n          {\n            v4 = dcgettext(0LL, \"bad section index[%3d]\", 5);\n            sprintf(byte_68E680, v4, a2);\n          }\n          else\n          {\n            sprintf(byte_68E680, \"%3d\", a2);\n          }\n          return byte_68E680;\n        }\n      }\nLABEL_10:\n      sprintf(byte_68E680, \"PRC[0x%04x]\", (unsigned __int16)a2);\n      return byte_68E680;\n    }\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'  case PTR_64:                                 /* pointer 64-bit */\\\n'    if (p_type == NULL)\\n      p_type = \"ptr",
        "<s><asm_token>\n\"static void\\nprint_header_field (struct http_header *hdr, const char *field_name)\\n{\\n  if (strcmp (field_name, \\\"Accept",
        "<s><asm_token>\n'static void\\nprint_type (int type)\\n{\\n  switch (type)\\n    {\\n    case T_A: printf (\"A\"); break;\\n    case T_",
        "<s><asm_token>\ns'\\nstatic void\\noutput_escaped_string (const char *str, size_t len)\\n{\\n  const char *p = str;\\n  const char *",
        "<s><asm_token>\nt1('\\nstatic void\\nget_dns_type (const char *str)\\n{\\n  int type;\\n\\n  if (strcmp (str, \"a\")"
    ],
    "prorec_sum": "Returns a descriptive string label or formatted code representing a section type based on the given numeric identifier and header field values.",
    "extracted_features": [
        "ABS",
        "COM",
        "UND",
        "ANSI_COM",
        "SCOM",
        "LARGE_COM",
        "SUND",
        "OS [0x%04x]",
        "RSV[0x%04x]",
        "bad section index[%3d]",
        "PRC[0x%04x]",
        "sprintf",
        "dcgettext"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'  case PTR_64:                                 /* pointer 64-bit */\\\n'    if (p_type == NULL)\\n      p_type = \"ptr",
        "\"static void\\nprint_header_field (struct http_header *hdr, const char *field_name)\\n{\\n  if (strcmp (field_name, \\\"Accept",
        "'static void\\nprint_type (int type)\\n{\\n  switch (type)\\n    {\\n    case T_A: printf (\"A\"); break;\\n    case T_",
        "s'\\nstatic void\\noutput_escaped_string (const char *str, size_t len)\\n{\\n  const char *p = str;\\n  const char *",
        "t1('\\nstatic void\\nget_dns_type (const char *str)\\n{\\n  int type;\\n\\n  if (strcmp (str, \"a\")"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Returns a descriptive string label for a given section code based on specific numeric values, structural fields, and predefined formatting rules.",
    "work_score": {
        "prorec": {
            "summary": "Returns a descriptive string label or formatted code representing a section type based on the given numeric identifier and header field values.",
            "score": [
                0.7885321289886477,
                0.48680741697457763,
                0.6286115899290211
            ],
            "reason": [
                "The summary accurately describes the function's behavior, which returns a string label or formatted code based on the numeric identifier and header field values. This aligns with the source code, where different section types are mapped to specific string labels or formatted codes. The summary captures the core functionality without any inaccuracies, demonstrating high precision.",
                "The summary covers the core purpose by stating that the function returns a descriptive string label based on a numeric identifier, which aligns with the function's operation of mapping section types to string labels. However, it lacks coverage of secondary details such as specific conditions and edge cases handled by the switch statement, including machine-specific checks and formatted outputs for various ranges.",
                "The summary provides a generic description of the function's purpose, which is accurate but lacks specificity. It correctly states that the function returns a string label based on a numeric identifier and header field values, aligning with the source code's behavior. However, it does not detail the specific conditions or cases handled by the function, such as the various machine types and section types, which would provide higher gain. There is no fatal inaccuracy, but the lack of detailed claims results in low net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Returns a descriptive string label for a given section code based on specific numeric values, structural fields, and predefined formatting rules.",
            "score": [
                0.6000615434494975,
                0.4892021927138052,
                0.6006412091734218
            ],
            "reason": [
                "The summary accurately describes the function's purpose of returning a descriptive string label for a given section code based on specific numeric values and predefined formatting rules. However, it lacks specificity regarding the various conditions and cases handled by the function, such as the specific section codes and machine types. This results in a mixed reliability as the summary captures the general behavior but misses detailed, domain-specific semantics present in the source code.",
                "The summary accurately covers the core purpose of the function, which is to return a descriptive string label for a given section code based on specific numeric values and predefined formatting rules. However, it lacks coverage of secondary behavior-critical semantics such as the specific conditions and machine types handled in the switch cases, and the use of the static buffer for formatted output.",
                "The summary provides a generic overview of the function's purpose, mentioning descriptive string labels and formatting rules, which aligns with the source code's behavior. However, it lacks specific details about the various cases and conditions handled by the function, such as the specific section codes and machine types. This results in low informational gain, and the absence of detailed claims makes the summary mediocre in terms of accuracy and insight."
            ]
        }
    }
}
{
    "source_code": "\nstruct local_symbol *\nlocal_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n{\n  const char *name_copy;\n  struct local_symbol *ret;\n\n  ++local_symbol_count;\n\n  name_copy = save_symbol_name (name);\n\n  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n  ret->lsy_flags.sy_local_symbol = 1;\n  ret->lsy_flags.sy_resolved = 0;\n  ret->lsy_name = name_copy;\n  ret->lsy_section = section;\n  local_symbol_set_frag (ret, frag);\n  ret->lsy_value = val;\n\n  hash_jam (local_hash, name_copy, (void *) ret);\n\n  return ret;\n}",
    "strip_decompiled_code": "char *__fastcall sub_4216B0(const char *a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  char *v7; // rax\n  char *chunk_limit; // rcx\n  char *object_base; // r13\n  char *v10; // rdi\n  char *v11; // rsi\n  char v12; // dl\n  __int64 v13; // rdi\n  char *v15; // [rsp+8h] [rbp-30h]\n\n  ++qword_7E5280;\n  v7 = sub_421280(a1);\n  chunk_limit = stru_7EA840.chunk_limit;\n  if ( (char *)(stru_7EA840.chunk_limit - stru_7EA840.next_free) <= (char *)0x27 )\n  {\n    v15 = v7;\n    obstack_newchunk(&stru_7EA840, 40LL);\n    object_base = stru_7EA840.object_base;\n    chunk_limit = stru_7EA840.chunk_limit;\n    v7 = v15;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  else\n  {\n    object_base = stru_7EA840.object_base;\n    v10 = stru_7EA840.next_free + 40;\n    if ( stru_7EA840.next_free + 40 != stru_7EA840.object_base )\n      goto LABEL_3;\n  }\n  *((_BYTE *)&stru_7EA840 + 80) |= 2u;\nLABEL_3:\n  v11 = (char *)(~*(_QWORD *)&stru_7EA840.alignment_mask & (unsigned __int64)&v10[*(_QWORD *)&stru_7EA840.alignment_mask]);\n  stru_7EA840.next_free = v11;\n  if ( (char *)(v11 - (char *)stru_7EA840.chunk) > (char *)(chunk_limit - (char *)stru_7EA840.chunk) )\n  {\n    stru_7EA840.next_free = chunk_limit;\n    v11 = chunk_limit;\n  }\n  v12 = *object_base;\n  v13 = qword_7E5288;\n  stru_7EA840.object_base = v11;\n  *((_QWORD *)object_base + 3) = a4;\n  *((_QWORD *)object_base + 1) = a2;\n  *((_QWORD *)object_base + 4) = a3;\n  *((_QWORD *)object_base + 2) = v7;\n  *object_base = v12 & 0xFA | 1;\n  sub_411620(v13, v7, (__int64)object_base);\n  return object_base;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    {\\n      /* Find the place to insert the new entry.  */\\n      if (data->sorted == NULL)\\n        {\\n          data->sorted = new_",
        "<s><asm_token>\n\"static void\\npush_char (int c, struct obstack *obstack)\\n{\\n  if (c == 0)\\n    { /* Handle embedded nulls */\\n",
        "<s><asm_token>\n'void\\nadd_path (const char *path, const char *dir, const char *base, const char *suffix)\\n{\\n  struct path_data *p;\\",
        "<s><asm_token>\n  'void\\n_bfd_elf_link_hash_table_init (bfd *abfd, struct bfd_link_info *info,\\n                               struct elf",
        "<s><asm_token>\n  'void\\nadd_lto_file (struct lto_file_decl_data *new_file_data, struct lto_file_decl_data *file_data"
    ],
    "prorec_sum": "Allocates space in an obstack for a new object, stores provided fields, updates control flags, and registers it with a global table.",
    "extracted_features": [
        "obstack_newchunk",
        "stru_7EA840",
        "alignment_mask",
        "chunk_limit",
        "object_base"
    ],
    "filter_strong": [],
    "filter_backup": [
        "\"static void\\npush_char (int c, struct obstack *obstack)\\n{\\n  if (c == 0)\\n    { /* Handle embedded nulls */\\n"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'    {\\n      /* Find the place to insert the new entry.  */\\n      if (data->sorted == NULL)\\n        {\\n          data->sorted = new_",
        "'void\\nadd_path (const char *path, const char *dir, const char *base, const char *suffix)\\n{\\n  struct path_data *p;\\",
        "  'void\\n_bfd_elf_link_hash_table_init (bfd *abfd, struct bfd_link_info *info,\\n                               struct elf",
        "  'void\\nadd_lto_file (struct lto_file_decl_data *new_file_data, struct lto_file_decl_data *file_data"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Contains 'struct obstack' which matches the 'obstack_newchunk' and obstack-related memory allocation in the decompiled function.)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Allocates space in an obstack for a new object, stores provided parameters into it, and registers it through a handler function.",
    "work_score": {
        "prorec": {
            "summary": "Allocates space in an obstack for a new object, stores provided fields, updates control flags, and registers it with a global table.",
            "score": [
                0.876502969136569,
                0.6834036312808103,
                0.8543087926846648
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it allocates space in an obstack, stores provided fields (name, section, value, frag), updates control flags (sy_local_symbol, sy_resolved), and registers the object with a global table (hash_jam). These claims align well with the source code, indicating high precision and coverage of the function's operations.",
                "The summary accurately covers the core purpose of the function, which is to allocate space for a new local symbol object, store provided fields, update control flags, and register it with a global table. It captures the allocation in an obstack, setting of fields like name, section, and value, and the registration with a hash table. However, it lacks mention of specific details such as the increment of the local symbol count and the setting of the 'sy_local_symbol' and 'sy_resolved' flags, which are critical for complete coverage.",
                "The summary accurately describes the function's behavior: it allocates space in an obstack, stores provided fields (name, section, value, frag), updates control flags (sy_local_symbol, sy_resolved), and registers the object with a global table (hash_jam). The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates space in an obstack for a new object, stores provided parameters into it, and registers it through a handler function.",
            "score": [
                0.7123570177138806,
                0.41303312574916556,
                0.6644609898747942
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it allocates space in an obstack, stores provided parameters, and registers the object through a handler function. These claims align well with the source code, where 'obstack_alloc' is used for allocation, parameters are stored in the 'ret' structure, and 'hash_jam' registers the object. The summary captures the core operations, with over 80% of claims being accurate.",
                "The summary covers the core purpose of allocating space in an obstack and storing parameters, which aligns with the function's main operation. However, it lacks detail on secondary aspects such as setting flags, handling the name copy, and hashing the symbol, which are critical behaviors in the source code.",
                "The summary accurately describes the function's behavior of allocating space in an obstack and storing provided parameters, which aligns with the source code. It mentions registering through a handler function, which corresponds to 'hash_jam', but lacks specificity about the function's primary purpose and key I/O details. The claims are mostly accurate with low noise, providing a net positive benefit."
            ]
        }
    }
}
{
    "source_code": "int loadkmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct kbentry ke;\n\tint i, j, fd;\n\tuint16_t ibuff[NR_KEYS];\n/*\tconst char *tty_name = CURRENT_TTY; */\n\tRESERVE_CONFIG_BUFFER(flags, MAX_NR_KEYMAPS);\n\n\t/* When user accidentally runs \"loadkmap FILE\"\n\t * instead of \"loadkmap <FILE\", we end up waiting for input from tty.\n\t * Let's prevent it: */\n\tif (argv[1])\n\t\tbb_show_usage();\n/* bb_warn_ignoring_args(argv[1]); */\n\n\tfd = get_console_fd_or_die();\n/* or maybe:\n\topt = getopt32(argv, \"C:\", &tty_name);\n\tfd = xopen_nonblocking(tty_name);\n*/\n\n\txread(STDIN_FILENO, flags, 7);\n\tif (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))\n\t\tbb_error_msg_and_die(\"not a valid binary keymap\");\n\n\txread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);\n\n\tfor (i = 0; i < MAX_NR_KEYMAPS; i++) {\n\t\tif (flags[i] != 1)\n\t\t\tcontinue;\n\t\txread(STDIN_FILENO, ibuff, NR_KEYS * sizeof(uint16_t));\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tke.kb_index = j;\n\t\t\tke.kb_table = i;\n\t\t\tke.kb_value = ibuff[j];\n\t\t\t/*\n\t\t\t * Note: table[idx:0] can contain special value\n\t\t\t * K_ALLOCATED (marks allocated tables in kernel).\n\t\t\t * dumpkmap saves the value as-is; but attempts\n\t\t\t * to load it here fail, since it isn't a valid\n\t\t\t * key value: it is K(KT_SPEC,126) == 2<<8 + 126,\n\t\t\t * whereas last valid KT_SPEC is\n\t\t\t * K_BARENUMLOCK == K(KT_SPEC,19).\n\t\t\t * So far we just ignore these errors:\n\t\t\t */\n\t\t\tioctl(fd, KDSKBENT, &ke);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t\tRELEASE_CONFIG_BUFFER(flags);\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_5A89C0(\n        __m128 a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        double a5,\n        double a6,\n        __m128 a7,\n        __m128 a8,\n        __int64 a9,\n        __int64 a10)\n{\n  __int64 v10; // rax\n  _BYTE *v11; // r12\n  unsigned int v12; // r13d\n  __int64 v13; // rdx\n  __int64 v14; // rcx\n  __int64 v15; // r8\n  __int64 v16; // r9\n  __m128 v17; // xmm4\n  __m128 v18; // xmm5\n  __int64 v19; // rbx\n  __int64 v20; // rbp\n  __int16 v21; // ax\n  char v23[2]; // [rsp+0h] [rbp-138h] BYREF\n  __int16 v24; // [rsp+2h] [rbp-136h]\n  _WORD v25[148]; // [rsp+10h] [rbp-128h] BYREF\n\n  v10 = sub_51812F((const char *)0x100, a10, a1, a2, a3, a4, a5, a6, a7, a8);\n  if ( *(_QWORD *)(a10 + 8) )\n    sub_516747(256LL, a10);\n  v11 = (_BYTE *)v10;\n  v12 = sub_5D081B(*(double *)a1.m128_u64);\n  sub_5D9D86(0LL, v11, 7LL);\n  if ( !sub_5170F0(v11, \"bkeymap\") )\n    sub_51797B(\n      \"not a valid binary keymap\",\n      (__int64)\"bkeymap\",\n      v13,\n      v14,\n      v15,\n      v16,\n      a1,\n      a2,\n      a3,\n      a4,\n      v17,\n      v18,\n      a7,\n      a8,\n      v23[0]);\n  v19 = 0LL;\n  sub_5D9D86(0LL, v11, 256LL);\n  do\n  {\n    if ( v11[v19] == 1 )\n    {\n      v20 = 0LL;\n      sub_5D9D86(0LL, v25, 256LL);\n      do\n      {\n        v21 = v25[v20];\n        v23[1] = v20++;\n        v23[0] = v19;\n        v24 = v21;\n        sub_4AF0E0(v12, 0x4B47u, (unsigned __int64)v23);\n      }\n      while ( v20 != 128 );\n    }\n    ++v19;\n  }\n  while ( v19 != 256 );\n  return 0LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'\t\t\tif (len == 0) { /* end of list */\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\",
        "<s><asm_token>\n\"static int IFCONFIG_do_ip(int argc, char **argv)\\n{\\n\\tint ifindex;\\n\\tchar *ifname;\\n\\tint flags;\\",
        "<s><asm_token>\n'static int\\nifconfig_status(int argc UNUSED_PARAM, char **argv)\\n{\\n\\tstruct ifreq ifr;\\n\\tint s;\\",
        "<s><asm_token>\ni_tt('s', \"setuid\")\\n's' : {\\n\\tif (argv[1][2] == \\'\\\\0') {\\n\\t\\tif",
        "<s><asm_token>\nnstr('\\nstatic int\\nget_inet_addr(const char *host, int family, struct in_addr *in_addr)\\n{\\n\\tstruct addrinfo hints;\\"
    ],
    "prorec_sum": "Processes a binary keymap file, validates its format, and registers all defined key mappings into the system using the provided device identifier.",
    "extracted_features": [
        "bkeymap",
        "not a valid binary keymap"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'\t\t\tif (len == 0) { /* end of list */\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\",
        "\"static int IFCONFIG_do_ip(int argc, char **argv)\\n{\\n\\tint ifindex;\\n\\tchar *ifname;\\n\\tint flags;\\",
        "'static int\\nifconfig_status(int argc UNUSED_PARAM, char **argv)\\n{\\n\\tstruct ifreq ifr;\\n\\tint s;\\",
        "i_tt('s', \"setuid\")\\n's' : {\\n\\tif (argv[1][2] == \\'\\\\0') {\\n\\t\\tif",
        "nstr('\\nstatic int\\nget_inet_addr(const char *host, int family, struct in_addr *in_addr)\\n{\\n\\tstruct addrinfo hints;\\"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Processes a binary keymap file, validates its header, and registers mappings for active keys using a given device identifier.",
    "work_score": {
        "prorec": {
            "summary": "Processes a binary keymap file, validates its format, and registers all defined key mappings into the system using the provided device identifier.",
            "score": [
                0.4734152183442424,
                0.5095650818840042,
                0.5802924119854732
            ],
            "reason": [
                "The summary correctly identifies that the function processes a binary keymap file and validates its format, which aligns with the code's use of 'xread' and 'is_prefixed_with' functions. However, the claim that it registers key mappings using a provided device identifier is inaccurate, as the code uses 'get_console_fd_or_die' to obtain a file descriptor, not a device identifier. This results in mixed reliability, with approximately 50-80% of claims being accurate.",
                "The summary correctly identifies the core purpose of processing a binary keymap file and registering key mappings, which aligns with the function's operation of reading and validating a keymap file and using ioctl to set key mappings. However, it inaccurately mentions using a 'provided device identifier,' which is not explicitly handled in the code. The summary lacks details on error handling, such as checking for a valid binary keymap and ignoring certain errors, and does not mention the cleanup process or the prevention of incorrect usage.",
                "The summary correctly identifies the processing of a binary keymap file and the validation of its format, which aligns with the function's core actions. However, it inaccurately mentions 'registers all defined key mappings into the system using the provided device identifier,' which is misleading as the function uses a fixed console file descriptor obtained internally, not a user-provided identifier. This introduces noise, reducing the net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Processes a binary keymap file, validates its header, and registers mappings for active keys using a given device identifier.",
            "score": [
                0.5215519997036461,
                0.5064643505894567,
                0.6824521871616028
            ],
            "reason": [
                "The summary accurately mentions processing a binary keymap file and validating its header, which aligns with the code's use of 'xread' and 'is_prefixed_with' functions. However, the claim about registering mappings for active keys using a given device identifier is inaccurate, as the code uses 'ioctl' with 'fd' obtained from 'get_console_fd_or_die', not a device identifier from the input. This results in mixed reliability, with approximately 50-80% accuracy.",
                "The summary covers the core purpose of processing a binary keymap file and validating its header, which aligns with the function's operation of reading and checking the keymap magic. However, it lacks detail on secondary behaviors such as handling errors when the keymap is invalid, the specific use of ioctl for registering mappings, and the cleanup operations. The mention of 'device identifier' is vague and does not accurately reflect the use of file descriptors in the source code.",
                "The summary accurately describes the function's primary purpose of processing a binary keymap file and validating its header, which aligns with the source code's logic of checking the keymap magic. It also correctly mentions registering mappings for active keys, reflecting the loop that sets key entries using ioctl. However, the summary lacks specificity regarding the handling of input and error conditions, such as the prevention of incorrect usage and the handling of invalid keymap values, which limits the gain from the accurate claims."
            ]
        }
    }
}
{
    "source_code": "\nstatic int i915_ring_freq_table(struct seq_file *m, void *unused)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tint ret;\n\tint gpu_freq, ia_freq;\n\n\tif (!(IS_GEN6(dev) || IS_GEN7(dev))) {\n\t\tseq_printf(m, \"unsupported on this chipset\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->rps.hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\tfor (gpu_freq = dev_priv->rps.min_delay;\n\t     gpu_freq <= dev_priv->rps.max_delay;\n\t     gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsandybridge_pcode_read(dev_priv,\n\t\t\t\t       GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t\t       &ia_freq);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   gpu_freq * GT_FREQUENCY_MULTIPLIER,\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tmutex_unlock(&dev_priv->rps.hw_lock);\n\n\treturn 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF8139BAC0(\n        _QWORD *a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9)\n{\n  __int64 v9; // r15\n  __int64 result; // rax\n  double v11; // xmm4_8\n  double v12; // xmm5_8\n  int v13; // r14d\n  unsigned int v14; // ebx\n  __int64 v15; // rdx\n  double v16; // xmm4_8\n  double v17; // xmm5_8\n  int v18; // [rsp+4h] [rbp-2Ch] BYREF\n\n  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 16LL) + 456LL) + 840LL);\n  if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v9 + 16) + 5LL) - 6) <= 1u )\n  {\n    result = sub_FFFFFFFF8178F4A0(v9 + 8880);\n    if ( !(_DWORD)result )\n    {\n      sub_FFFFFFFF81155B50(\n        a1,\n        (__int64)\"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v11,\n        v12,\n        a8,\n        a9);\n      v13 = *(unsigned __int8 *)(v9 + 8743);\n      v14 = 50 * v13;\n      if ( *(_BYTE *)(v9 + 8744) >= *(_BYTE *)(v9 + 8743) )\n      {\n        do\n        {\n          v18 = v13++;\n          sub_FFFFFFFF813DA900(v9, 9LL, &v18);\n          v15 = v14;\n          v14 += 50;\n          sub_FFFFFFFF81155B50(\n            a1,\n            (__int64)\"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n            a2,\n            a3,\n            a4,\n            a5,\n            v16,\n            v17,\n            a8,\n            a9,\n            v15,\n            100 * (unsigned int)(unsigned __int8)v18,\n            100 * (unsigned int)BYTE1(v18));\n        }\n        while ( *(unsigned __int8 *)(v9 + 8744) >= v13 );\n      }\n      sub_FFFFFFFF8178F1B0(v9 + 8880);\n      return 0LL;\n    }\n  }\n  else\n  {\n    sub_FFFFFFFF81155B50(a1, (__int64)\"unsupported on this chipset\\n\", a2, a3, a4, a5, a6, a7, a8, a9);\n    return 0LL;\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]'    return 0;\\n}'\n'static int i915_ring_freq_table_show(struct seq_file *m, void *data)\\n{\\",
        "<s><asm_token>\n\"static int tpm_show_pubek(struct seq_file *m, void *v)\\n{\\n\\tstruct tpm_chip *chip = m->private;\\",
        "<s><asm_token>\n'static int gpio_debugfs_show(struct seq_file *s, void *unused)\\\\n{\\n\\tstruct gpio_chip *chip = s->private",
        "<s><asm_token>\ns_str(''',\\nstatic int vfio_iommu_show_device(struct seq_file *m,\\n\\t\\t\\t\\tstruct vfio",
        "<s><asm_token>\nt = '        if (page_to_nid(page) != nid) {\\n            printk(KERN_ERR \"Node %d: page %p is from node"
    ],
    "prorec_sum": "Displays a formatted table of GPU, effective CPU, and ring frequencies if supported by the chipset, otherwise reports unsupported hardware.",
    "extracted_features": [
        "GPU freq (MHz)",
        "Effective CPU freq (MHz)",
        "Effective Ring freq (MHz)",
        "unsupported on this chipset"
    ],
    "filter_strong": [
        "[...]'    return 0;\\n}'\n'static int i915_ring_freq_table_show(struct seq_file *m, void *data)\\n{\\"
    ],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "\"static int tpm_show_pubek(struct seq_file *m, void *v)\\n{\\n\\tstruct tpm_chip *chip = m->private;\\",
        "'static int gpio_debugfs_show(struct seq_file *s, void *unused)\\\\n{\\n\\tstruct gpio_chip *chip = s->private",
        "s_str(''',\\nstatic int vfio_iommu_show_device(struct seq_file *m,\\n\\t\\t\\t\\tstruct vfio",
        "t = '        if (page_to_nid(page) != nid) {\\n            printk(KERN_ERR \"Node %d: page %p is from node"
    ],
    "debug_log": [
        "Idx 0: Strong (Candidate 0 snippet name i915_ring_freq_table_show strongly suggests it is source for printing GPU/Ring frequency table as reflected by string literals in decompiled code.)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Displays the GPU, effective CPU, and ring frequency table for supported Intel chipsets via a seq_file interface.",
    "work_score": {
        "prorec": {
            "summary": "Displays a formatted table of GPU, effective CPU, and ring frequencies if supported by the chipset, otherwise reports unsupported hardware.",
            "score": [
                0.9567004804076443,
                0.8276907440435208,
                0.8894328961455054
            ],
            "reason": [
                "The summary accurately reflects the function's behavior: it displays a formatted table of GPU, effective CPU, and ring frequencies, and reports unsupported hardware for non-Gen6/Gen7 chipsets. All claims are precise and align with the source code semantics.",
                "The summary accurately captures the core purpose of the function, which is to display a formatted table of frequencies if the chipset is supported. This is consistent with the function's check for GEN6 or GEN7 chipsets and the subsequent frequency table output. The summary also correctly mentions the handling of unsupported hardware. While the core is covered, the summary misses details regarding the locking mechanism and specific frequency calculations involving the 'sandybridge_pcode_read' and 'GT_FREQUENCY_MULTIPLIER', thus not fully covering all secondary details.",
                "The summary accurately describes the function's behavior: it displays a formatted table of GPU, CPU, and ring frequencies, and correctly notes the condition for unsupported hardware. The claims are specific and align well with the source code, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Displays the GPU, effective CPU, and ring frequency table for supported Intel chipsets via a seq_file interface.",
            "score": [
                0.8722086334639826,
                0.6361281322206072,
                0.8229972624612836
            ],
            "reason": [
                "The summary accurately describes the function's behavior of displaying GPU, CPU, and ring frequencies for supported Intel chipsets using a seq_file interface. The claim aligns well with the source code, which checks for supported chipsets (GEN6 or GEN7) and prints the frequency table. The summary captures the core functionality without introducing inaccuracies, achieving high precision.",
                "The summary accurately covers the core purpose of displaying the GPU, CPU, and ring frequency table for supported Intel chipsets, which aligns with the function's primary operation. However, it lacks details on secondary behaviors such as the chipset support check, the use of mutex for synchronization, and the specific frequency calculations and formatting in the output.",
                "The summary accurately describes the function's primary purpose of displaying frequency tables for supported Intel chipsets using a seq_file interface, which aligns with the source code's behavior. The claim is specific and provides clear insight into the function's domain-semantic behavior, representing a high gain. There is no noise or inaccuracies present, making the net benefit high."
            ]
        }
    }
}
{
    "source_code": "\n\nngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    ngx_time_t  *tp;\n    ngx_uint_t   n;\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    long         size;\n#endif\n\n#if (NGX_HAVE_OS_SPECIFIC_INIT)\n    if (ngx_os_specific_init(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_init_setproctitle(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_pagesize = getpagesize();\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n    if (ngx_ncpu == 0) {\n        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n#endif\n\n    if (ngx_ncpu < 1) {\n        ngx_ncpu = 1;\n    }\n\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n    if (size > 0) {\n        ngx_cacheline_size = size;\n    }\n#endif\n\n    ngx_cpuinfo();\n\n    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, errno,\n                      \"getrlimit(RLIMIT_NOFILE) failed\");\n        return NGX_ERROR;\n    }\n\n    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n\n#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n    ngx_inherited_nonblocking = 1;\n#else\n    ngx_inherited_nonblocking = 0;\n#endif\n\n    tp = ngx_timeofday();\n    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}",
    "strip_decompiled_code": "__int64 __fastcall ngx_os_init(\n        _QWORD *a1,\n        __m128 a2,\n        __m128 a3,\n        __m128 a4,\n        __m128 a5,\n        double a6,\n        double a7,\n        __m128 a8,\n        __m128 a9)\n{\n  double v9; // xmm4_8\n  double v10; // xmm5_8\n  int v11; // eax\n  unsigned __int64 v12; // rax\n  __int64 i; // rdx\n  __int64 v14; // rax\n  __int64 v15; // rax\n  int *v16; // rax\n  __int64 v17; // r8\n  __int64 v18; // r9\n  __m128 v19; // xmm4\n  __m128 v20; // xmm5\n\n  if ( ngx_os_specific_init() || ngx_init_setproctitle(a1, a2, a3, a4, a5, v9, v10, a8, a9) )\n    return -1LL;\n  v11 = getpagesize();\n  ngx_cacheline_size = 64LL;\n  ngx_pagesize = v11;\n  v12 = (unsigned __int64)v11 >> 1;\n  if ( v12 )\n  {\n    for ( i = ngx_pagesize_shift + 1; ; ++i )\n    {\n      v12 >>= 1;\n      if ( !v12 )\n        break;\n    }\n    ngx_pagesize_shift = i;\n  }\n  v14 = ngx_ncpu;\n  if ( !ngx_ncpu )\n  {\n    v14 = sysconf(84);\n    ngx_ncpu = v14;\n  }\n  if ( v14 <= 0 )\n    ngx_ncpu = 1LL;\n  v15 = sysconf(190);\n  if ( v15 > 0 )\n    ngx_cacheline_size = v15;\n  ngx_cpuinfo();\n  if ( getrlimit64(RLIMIT_NOFILE, &rlmt) == -1 )\n  {\n    if ( *a1 > 1uLL )\n    {\n      v16 = __errno_location();\n      ngx_log_error_core(\n        2uLL,\n        (__int64)a1,\n        *v16,\n        (unsigned int)\"getrlimit(RLIMIT_NOFILE) failed\",\n        v17,\n        v18,\n        a2,\n        a3,\n        a4,\n        a5,\n        v19,\n        v20,\n        a8,\n        a9);\n    }\n    return -1LL;\n  }\n  ngx_inherited_nonblocking = 1LL;\n  ngx_max_sockets = rlmt.rlim_cur;\n  srandom(*(_DWORD *)(ngx_cached_time + 8) ^ *(_DWORD *)ngx_cached_time ^ (ngx_pid << 16));\n  return 0LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n    '\\n\\n    ngx_uint_t  i;\\n\\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->",
        "<s><asm_token>\n\"ngx_pid_t\\nngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,",
        "<s><asm_token>\n'    static ngx_pid_t\\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\\n{\\n    ngx",
        "<s><asm_token>\n  'ngx_cycle_t *\\nngx_init_cycle(ngx_cycle_t *old_cycle)\\n{\\n    void                *r;\\n    ng",
        "<s><asm_token>\n  '    if (p[0] == \\'\\\\0\\') {\\n'\n'\\t\\t    return NGX_CONF_OK;\\n'\n'\\t\\"
    ],
    "prorec_sum": "Initializes OS-specific parameters, retrieves system page size, CPU and cache info, sets resource limits, and seeds the random number generator for Nginx.",
    "extracted_features": [
        "ngx_os_specific_init",
        "ngx_init_setproctitle",
        "getpagesize",
        "ngx_cacheline_size",
        "ngx_pagesize",
        "ngx_pagesize_shift",
        "sysconf",
        "ngx_ncpu",
        "ngx_cpuinfo",
        "getrlimit64",
        "RLIMIT_NOFILE",
        "__errno_location",
        "ngx_log_error_core",
        "ngx_inherited_nonblocking",
        "ngx_max_sockets",
        "srandom"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n    '\\n\\n    ngx_uint_t  i;\\n\\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->",
        "\"ngx_pid_t\\nngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,",
        "'    static ngx_pid_t\\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\\n{\\n    ngx",
        "  'ngx_cycle_t *\\nngx_init_cycle(ngx_cycle_t *old_cycle)\\n{\\n    void                *r;\\n    ng",
        "  '    if (p[0] == \\'\\\\0\\') {\\n'\n'\\t\\t    return NGX_CONF_OK;\\n'\n'\\t\\"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Initializes OS-specific settings for Nginx, determines system page and cache parameters, retrieves resource limits, and seeds the random number generator.",
    "work_score": {
        "prorec": {
            "summary": "Initializes OS-specific parameters, retrieves system page size, CPU and cache info, sets resource limits, and seeds the random number generator for Nginx.",
            "score": [
                0.9060396470946127,
                0.8128899086616755,
                0.8567410236189852
            ],
            "reason": [
                "The summary accurately describes the function's operations: initializing OS-specific parameters, retrieving system page size, CPU and cache info, setting resource limits, and seeding the random number generator. These claims align well with the source code, which includes calls to functions for OS-specific initialization, page size retrieval, CPU info, cache line size setting, resource limit retrieval, and random number seeding. The summary captures over 80% of the function's key operations, demonstrating high precision.",
                "The summary accurately covers the core purpose of the function, which is to initialize OS-specific parameters for Nginx, including retrieving system page size, CPU and cache info, setting resource limits, and seeding the random number generator. It captures most key points, including the initialization of OS-specific settings, page size, CPU/cache information, and resource limits. However, it lacks mention of some specific details like handling of non-blocking inheritance and error logging for resource limit retrieval.",
                "The summary accurately captures the core functionalities of the ngx_os_init function, including initializing OS-specific parameters, retrieving system page size, CPU and cache info, setting resource limits, and seeding the random number generator. These claims are specific and verifiable against the source code, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Initializes OS-specific settings for Nginx, determines system page and cache parameters, retrieves resource limits, and seeds the random number generator.",
            "score": [
                0.8795394657717484,
                0.7860699326363977,
                0.819360151676993
            ],
            "reason": [
                "The summary accurately reflects the key operations of the function: initializing OS-specific settings, determining system page and cache parameters, retrieving resource limits, and seeding the random number generator. These claims align well with the source code, which includes calls to OS-specific initialization functions, setting page size and cache line size, retrieving file descriptor limits, and using system time to seed the random number generator. The summary captures over 80% of the accurate claims from the source code.",
                "The summary accurately covers the core purpose of the function, which is to initialize OS-specific settings for Nginx. It mentions determining system page and cache parameters, retrieving resource limits, and seeding the random number generator, which are key operations performed by the function. However, it lacks mention of some secondary details such as handling CPU information and non-blocking socket inheritance.",
                "The summary accurately captures the primary purpose of the function, which is to initialize OS-specific settings for Nginx, determine system page and cache parameters, retrieve resource limits, and seed the random number generator. These claims align well with the source code, providing specific insights into the function's operations. There is minimal noise, and the claims are mostly specific and detailed, offering high gain by saving the engineer time in understanding the function's behavior."
            ]
        }
    }
}
{
    "source_code": "\nvoid\ndatamash_ops_free ( struct datamash_ops* p )\n{\n  assert (p != NULL);                            /* LCOV_EXCL_LINE */\n  for (size_t i=0; i<p->num_grps; ++i)\n    free (p->grps[i].name);\n  free (p->grps);\n  p->grps = NULL;\n\n  #ifndef _STANDALONE_\n  for (size_t i=0; i<p->num_ops; ++i)\n    field_op_free (&p->ops[i]);\n  #endif\n\n  free (p->ops);\n  p->ops = NULL;\n\n  for  (size_t i=0; i<_fields_used; ++i) {\n    free (_fields[i].name);\n  }\n  free (_fields);\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  free (_params);\n  _params_alloc = 0;\n  _params_used = 0;\n\n  free (p);\n}",
    "strip_decompiled_code": "void __fastcall sub_7CB0(void *ptr)\n{\n  __int64 v1; // r12\n  unsigned __int64 v2; // rbp\n  void *v4; // rdi\n  bool v5; // zf\n  __int64 v6; // r12\n  unsigned __int64 v7; // rbp\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  void *v10; // r13\n  void **v11; // rbp\n  void **v12; // r12\n  void *v13; // rdi\n\n  if ( !ptr )\n    __assert_fail(\"p != NULL\", \"src/op-parser.c\", 0x319u, \"datamash_ops_free\");\n  v1 = 0LL;\n  v2 = 0LL;\n  while ( *((_QWORD *)ptr + 2) > v2 )\n  {\n    ++v2;\n    v4 = *(void **)(*((_QWORD *)ptr + 1) + v1 + 16);\n    v1 += 24LL;\n    free(v4);\n  }\n  free(*((void **)ptr + 1));\n  v5 = *((_QWORD *)ptr + 5) == 0LL;\n  *((_QWORD *)ptr + 1) = 0LL;\n  if ( !v5 )\n  {\n    v6 = 0LL;\n    v7 = 0LL;\n    do\n    {\n      ++v7;\n      v8 = v6 + *((_QWORD *)ptr + 4);\n      v6 += 192LL;\n      sub_96F0(v8);\n    }\n    while ( *((_QWORD *)ptr + 5) > v7 );\n  }\n  free(*((void **)ptr + 4));\n  v9 = qword_222938;\n  *((_QWORD *)ptr + 4) = 0LL;\n  v10 = qword_222948;\n  if ( v9 )\n  {\n    v11 = (void **)((char *)qword_222948 + 16);\n    v12 = (void **)((char *)qword_222948 + 32 * v9 + 16);\n    do\n    {\n      v13 = *v11;\n      v11 += 4;\n      free(v13);\n    }\n    while ( v12 != v11 );\n  }\n  free(v10);\n  qword_222948 = 0LL;\n  qword_222940 = 0LL;\n  qword_222938 = 0LL;\n  free(qword_222930);\n  qword_222928 = 0LL;\n  qword_222920 = 0LL;\n  free(ptr);\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    if (s->stack == NULL)\\n        return;\\n\\n    for (p = s->stack; p != NULL; p = p->next)\\n        free",
        "<s><asm_token>\n\"void\\nfree_struct_decls (void)\\n{\\n  struct struct_decl *decl;\\n  struct struct_decl *next;\\n\\n  for (decl =",
        "<s><asm_token>\n'void\\nzconf_free (zconf_t *conf)\\n{\\n  assert (conf);\\n\\n  if (conf->helplang)\\n    free (",
        "<s><asm_token>\nv_str('''\\nvoid\nxfree_all_read_only_files (void)\n{\n  while (ro_files != NULL)\n    {\n      struct ro",
        "<s><asm_token>\no('  {\\n    int i;\\n    int size;\\n    int *temp;\\n\\n    if (top_level_symbols == NULL)\\n      return;\\n\\"
    ],
    "prorec_sum": "Frees all dynamically allocated memory associated with an operation parser structure, including its internal arrays, related global buffers, and the structure itself.",
    "extracted_features": [
        "datamash_ops_free",
        "__assert_fail",
        "\"p != NULL\"",
        "\"src/op-parser.c\""
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'    if (s->stack == NULL)\\n        return;\\n\\n    for (p = s->stack; p != NULL; p = p->next)\\n        free",
        "\"void\\nfree_struct_decls (void)\\n{\\n  struct struct_decl *decl;\\n  struct struct_decl *next;\\n\\n  for (decl =",
        "'void\\nzconf_free (zconf_t *conf)\\n{\\n  assert (conf);\\n\\n  if (conf->helplang)\\n    free (",
        "v_str('''\\nvoid\nxfree_all_read_only_files (void)\n{\n  while (ro_files != NULL)\n    {\n      struct ro",
        "o('  {\\n    int i;\\n    int size;\\n    int *temp;\\n\\n    if (top_level_symbols == NULL)\\n      return;\\n\\"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Frees all allocated memory and resources associated with datamash operation structures and global state, then releases the main structure itself.",
    "work_score": {
        "prorec": {
            "summary": "Frees all dynamically allocated memory associated with an operation parser structure, including its internal arrays, related global buffers, and the structure itself.",
            "score": [
                0.9450023899192779,
                0.8307357996604383,
                0.8634613808381367
            ],
            "reason": [
                "The summary accurately describes the function's behavior by stating that it frees all dynamically allocated memory associated with the operation parser structure, including internal arrays, related global buffers, and the structure itself. This aligns with the source code, which shows memory deallocation for various components of the structure and related global variables. All claims in the summary are accurate and verifiable against the source code.",
                "The summary accurately covers the core purpose of the function, which is to free all dynamically allocated memory associated with the operation parser structure, including its internal arrays and the structure itself. It also mentions related global buffers, aligning with the freeing of global fields and parameters. The summary captures most key points, including the freeing of internal arrays and global buffers, but lacks mention of specific edge cases like conditional freeing of operations when _STANDALONE_ is not defined.",
                "The summary accurately describes the function's primary purpose of freeing dynamically allocated memory associated with the operation parser structure, including internal arrays and global buffers. The claims are specific and align well with the source code, providing high gain by clearly stating the function's behavior without introducing noise or inaccuracies."
            ]
        },
        "filter_prorec": {
            "summary": "Frees all allocated memory and resources associated with datamash operation structures and global state, then releases the main structure itself.",
            "score": [
                0.909823456867834,
                0.8400358142525446,
                0.8857889647275361
            ],
            "reason": [
                "The summary accurately describes the function's behavior of freeing allocated memory for datamash operation structures and global state, and then releasing the main structure itself. This aligns with the source code, which includes freeing memory for groups, operations, fields, and parameters, followed by freeing the main structure. The claims are highly specific and verifiable, with over 80% accuracy.",
                "The summary accurately covers the core purpose of the function, which is to free all allocated memory and resources associated with datamash operation structures and global state, and then release the main structure itself. This aligns with the source code's operations of freeing memory for 'grps', 'ops', '_fields', and '_params', as well as setting pointers to NULL and resetting counters. The summary captures the primary purpose and most key points, including the freeing of global state, but lacks mention of specific branches or conditional compilation directives.",
                "The summary accurately describes the function's purpose, which is to free all allocated memory and resources associated with the datamash operation structures and global state, then release the main structure itself. This aligns well with the source code, as the function indeed frees memory for 'p->grps', 'p->ops', and global variables like '_fields', '_params', and finally 'p'. There are no inaccuracies or noise, and the claims provide specific and detailed insight into the function's purpose and behavior, thus offering high net benefit."
            ]
        }
    }
}
{
    "source_code": "\nbfd_boolean\n_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *htab;\n  struct eh_frame_hdr_info *hdr_info;\n  struct bfd_link_hash_entry *bh = NULL;\n  struct elf_link_hash_entry *h;\n\n  htab = elf_hash_table (info);\n  hdr_info = &htab->eh_info;\n  if (hdr_info->hdr_sec == NULL)\n    return TRUE;\n\n  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section)\n      || info->eh_frame_hdr_type == 0\n      || (info->eh_frame_hdr_type == DWARF2_EH_HDR\n\t  && !_bfd_elf_eh_frame_present (info))\n      || (info->eh_frame_hdr_type == COMPACT_EH_HDR\n\t  && !_bfd_elf_eh_frame_entry_present (info)))\n    {\n      hdr_info->hdr_sec->flags |= SEC_EXCLUDE;\n      hdr_info->hdr_sec = NULL;\n      return TRUE;\n    }\n\n  /* Add a hidden symbol so that systems without access to PHDRs can\n     find the table.  */\n  if (! (_bfd_generic_link_add_one_symbol\n\t (info, info->output_bfd, \"__GNU_EH_FRAME_HDR\", BSF_LOCAL,\n\t  hdr_info->hdr_sec, 0, NULL, FALSE, FALSE, &bh)))\n    return FALSE;\n\n  h = (struct elf_link_hash_entry *) bh;\n  h->def_regular = 1;\n  h->other = STV_HIDDEN;\n  get_elf_backend_data\n    (info->output_bfd)->elf_backend_hide_symbol (info, h, TRUE);\n\n  if (!hdr_info->frame_hdr_is_compact)\n    hdr_info->u.dwarf.table = TRUE;\n  return TRUE;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_450A10(__int64 a1)\n{\n  __int64 v1; // rbp\n  __int64 v2; // r8\n  char v3; // al\n  __int64 result; // rax\n  __int64 v5; // rsi\n  int v6; // eax\n  __int64 v7; // [rsp+8h] [rbp-30h]\n  __int64 v8[4]; // [rsp+18h] [rbp-20h] BYREF\n\n  v1 = *(_QWORD *)(a1 + 40);\n  v8[0] = 0LL;\n  v2 = *(_QWORD *)(v1 + 296);\n  if ( !v2 )\n    return 1LL;\n  if ( *(char ***)(v2 + 104) == &off_70B6D0 )\n    goto LABEL_12;\n  v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n  if ( !v3 )\n    goto LABEL_12;\n  if ( v3 != 64 )\n  {\nLABEL_5:\n    if ( v3 == (char)0x80 )\n    {\n      v7 = v2;\n      v6 = sub_4509B0(a1);\n      v2 = v7;\n      if ( !v6 )\n        goto LABEL_12;\n    }\n    result = sub_490F80(a1, *(_QWORD *)(a1 + 80), (int)\"__GNU_EH_FRAME_HDR\", 1, v2, 0, 0LL, 0, 0, (__int64)v8);\n    if ( !(_DWORD)result )\n      return result;\n    v5 = v8[0];\n    *(_BYTE *)(v8[0] + 99) |= 2u;\n    *(_BYTE *)(v5 + 97) = 2;\n    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8LL) + 864LL)\n                                                      + 432LL))(\n      a1,\n      v5,\n      1LL);\n    if ( !*(_DWORD *)(v1 + 308) )\n      *(_DWORD *)(v1 + 324) = 1;\n    return 1LL;\n  }\n  if ( (unsigned int)sub_450950(a1) )\n  {\n    v2 = *(_QWORD *)(v1 + 296);\n    v3 = *(_BYTE *)(a1 + 3) & 0xC0;\n    goto LABEL_5;\n  }\n  v2 = *(_QWORD *)(v1 + 296);\nLABEL_12:\n  *(_DWORD *)(v2 + 32) |= 0x8000u;\n  result = 1LL;\n  *(_QWORD *)(v1 + 296) = 0LL;\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[',\\n    '\\n\\t\\t\\t\\t\\tif (parent->dir_ops->file_rename) {\\n\\t\\t\\t\\t\\",
        "<s><asm_token>\n\"static int\\n_libisofs_close_session(struct libisofs_session *session, int flags)\\n{\\n    int rc = 0;\\n\\",
        "<s><asm_token>\n'int iso9660_is_directory(struct iso9660_node *node)\\n{\\n\\tstruct iso9660_directory_record",
        "<s><asm_token>\ni'\\nstatic int cd9660_lookup(struct vnode *dvp, struct vnode **vpp, char *name, int namelen, struct vnode *d",
        "<s><asm_token>\nn'int iso9660_parse_directory_record(struct iso9660_dir_record *dir, const uint8_t *buf,\\n\\t"
    ],
    "prorec_sum": "Configures and registers the `__GNU_EH_FRAME_HDR` section for an object, adjusting related flags and state based on header bits and validation results.",
    "extracted_features": [
        "__GNU_EH_FRAME_HDR"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[',\\n    '\\n\\t\\t\\t\\t\\tif (parent->dir_ops->file_rename) {\\n\\t\\t\\t\\t\\",
        "\"static int\\n_libisofs_close_session(struct libisofs_session *session, int flags)\\n{\\n    int rc = 0;\\n\\",
        "'int iso9660_is_directory(struct iso9660_node *node)\\n{\\n\\tstruct iso9660_directory_record",
        "i'\\nstatic int cd9660_lookup(struct vnode *dvp, struct vnode **vpp, char *name, int namelen, struct vnode *d",
        "n'int iso9660_parse_directory_record(struct iso9660_dir_record *dir, const uint8_t *buf,\\n\\t"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Loads and processes the \"__GNU_EH_FRAME_HDR\" section if header flags permit, updating related structures and state, otherwise marks and clears the associated entry.",
    "work_score": {
        "prorec": {
            "summary": "Configures and registers the `__GNU_EH_FRAME_HDR` section for an object, adjusting related flags and state based on header bits and validation results.",
            "score": [
                0.2971230977127538,
                0.44355917895306884,
                0.4108147054455122
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions configuring and registering the `__GNU_EH_FRAME_HDR` section, which is misleading as the function primarily checks conditions to exclude the section or add a hidden symbol. The summary fails to capture the conditional logic and exclusion process, resulting in less than 50% accuracy.",
                "The summary covers the core purpose of configuring and registering the `__GNU_EH_FRAME_HDR` section, which aligns with the function's operation of adding a hidden symbol for the section. However, it lacks detail on the specific conditions under which the section is excluded or included, such as the checks for `hdr_sec`, `eh_frame_hdr_type`, and the presence of frame entries. The summary also does not mention the handling of the `def_regular` and `other` attributes or the hiding of the symbol, which are critical behaviors in the source code.",
                "The summary provides a generic overview of the function's purpose but lacks specificity and detail. It correctly mentions the configuration and registration of the `__GNU_EH_FRAME_HDR` section, which aligns with the source code. However, it fails to capture specific conditions and actions such as the exclusion of sections based on header type and the addition of hidden symbols. The summary is low-info and does not provide detailed insights into the function's behavior, resulting in low net benefit without any fatal inaccuracies."
            ]
        },
        "filter_prorec": {
            "summary": "Loads and processes the \"__GNU_EH_FRAME_HDR\" section if header flags permit, updating related structures and state, otherwise marks and clears the associated entry.",
            "score": [
                0.40976018895650307,
                0.46835442553157713,
                0.44341562306825527
            ],
            "reason": [
                "The summary correctly identifies the processing of the '__GNU_EH_FRAME_HDR' section and the updating of related structures, which aligns with the source code's logic of adding a hidden symbol and modifying the hash entry. However, it inaccurately simplifies the conditions under which the section is processed or marked for exclusion, missing specific checks like 'hdr_sec == NULL' and 'eh_frame_hdr_type'. This results in mixed reliability with approximately 50-80% accuracy.",
                "The summary covers the core purpose by mentioning the processing of the '__GNU_EH_FRAME_HDR' section, which aligns with the function's operation of adding a hidden symbol for the section. However, it lacks detail on the specific conditions under which the section is marked and cleared, such as the checks for 'hdr_sec' being NULL, 'eh_frame_hdr_type', and the presence of EH frame entries. The summary also does not mention the setting of flags or the handling of the 'def_regular' and 'other' attributes, which are critical to the function's behavior.",
                "The summary contains a mix of accurate and inaccurate claims. It correctly mentions processing the '__GNU_EH_FRAME_HDR' section, which aligns with the source code's logic of adding a hidden symbol for systems without PHDR access. However, it inaccurately suggests that the function primarily updates structures and state based on header flags, which is misleading as the function's primary purpose is to determine whether to exclude the section based on specific conditions. The noise from the inaccurate claim is noticeable, reducing the net benefit."
            ]
        }
    }
}
{
    "source_code": "static int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D; /* The absolute value is stored. */\n  long Q;\n  mp_limb_t tl;\n\n  /* Test on the absolute value. */\n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */\n  if (mpz_root (Qk, n, 2))\n    return 0; /* A square is composite. */\n\n  /* Check Ds up to square root (in case, n is prime)\n     or avoid overflows */\n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */\n  /* For those Ds we have (D/n) = (n/|D|) */\n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */\n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */\n  b0 = mpz_scan0 (n, 0);\n\n  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */\n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t/* If Ud != 0 */\n    while (V->_mp_size != 0 && --b0 != 0)\t/* while Vk != 0 */\n      /* V <- V ^ 2 - 2Q^k */\n      /* Q^{2k} = (Q^k)^2 */\n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_985F(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+18h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+30h] [rbp-40h]\n  int v9[4]; // [rsp+40h] [rbp-30h] BYREF\n  _BYTE v10[4]; // [rsp+50h] [rbp-20h] BYREF\n  int v11; // [rsp+54h] [rbp-1Ch]\n  _QWORD *v12; // [rsp+58h] [rbp-18h]\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  sub_4EC0((__int64)v10, *(_QWORD *)(a1 + 8), abs32(*(_DWORD *)(a1 + 4)));\n  if ( ((v11 != 0) & (unsigned int)*v12) == 0 )\n    __assert_fail(\"mpz_odd_p (n)\", \"mini-gmp/mini-gmp.c\", 0xD88u, \"gmp_stronglucas\");\n  if ( sub_8DB1((int *)a2, (__int64)v10, 2uLL) )\n    return 0LL;\n  if ( *(_DWORD *)(a2 + 4) == 1 )\n    v3 = **(_QWORD **)(a2 + 8) - 1LL;\n  else\n    v3 = -1LL;\n  v7 = v3;\n  v6 = 3LL;\n  do\n  {\n    if ( v6 >= v7 )\n    {\n      if ( v6 == -1LL )\n        return 1LL;\n      else\n        return 2LL;\n    }\n    v6 += 2LL;\n    v8 = sub_74BB((__int64)v10, v6);\n    if ( !v8 )\n      return 0LL;\n  }\n  while ( (unsigned int)sub_92C2(v8, v6) == 1 );\n  sub_4834((__int64)v9);\n  v5 = sub_B280(v10, 0LL);\n  if ( (v6 & 2) != 0 )\n    v4 = (v6 >> 2) + 1;\n  else\n    v4 = -(__int64)(v6 >> 2);\n  if ( !sub_955F(v9, (int *)a2, v4, v5, (__int64)v10) )\n  {\n    while ( v9[1] )\n    {\n      if ( !--v5 )\n        break;\n      sub_94D4(v9, (int *)a2, (__int64)v10);\n    }\n  }\n  sub_48C3((__int64)v9);\n  return v5 != 0;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]\n'\\n\\nstatic int\\n__mu_is_valid_port (mu_uint_t port)\\n{\\n  if (port < 1024)\\",
        "<s><asm_token>\n\"static int\\nmpz_set_ui (mpz_t rop, unsigned long int op)\\n{\\n  mp_size_t size;\\n  mp_limb",
        "<s><asm_token>\n'    \\nstatic int\\nnum_is_prime(mp_int *num)\\n{\\n  mp_int tmp;\\n  mp_err res;\\n  int ret;\\",
        "<s><asm_token>\ns'\\n\\nstatic int\\nbit_count (mu_uint32_t x)\\n{\\n  mu_uint32_t c;\\n\\n  c =",
        "<s><asm_token>\nt = \\n    '  if (mu_mpz_cmp_ui (z, 1) == 0)\\n    return 1;\\n  /* z > 1,"
    ],
    "prorec_sum": "Performs a strong Lucas primality test on a given large integer using mini-GMP routines to determine if it is prime.",
    "extracted_features": [
        "mpz_odd_p",
        "gmp_stronglucas",
        "mini-gmp/mini-gmp.c"
    ],
    "filter_strong": [],
    "filter_backup": [
        "\"static int\\nmpz_set_ui (mpz_t rop, unsigned long int op)\\n{\\n  mp_size_t size;\\n  mp_limb",
        "'    \\nstatic int\\nnum_is_prime(mp_int *num)\\n{\\n  mp_int tmp;\\n  mp_err res;\\n  int ret;\\",
        "t = \\n    '  if (mu_mpz_cmp_ui (z, 1) == 0)\\n    return 1;\\n  /* z > 1,"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[...]\n'\\n\\nstatic int\\n__mu_is_valid_port (mu_uint_t port)\\n{\\n  if (port < 1024)\\",
        "s'\\n\\nstatic int\\nbit_count (mu_uint32_t x)\\n{\\n  mu_uint32_t c;\\n\\n  c ="
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Contains mpz_set_ui, which is related to mpz operations as in extracted feature mpz_odd_p.)",
        "Idx 2: Backup (Function name num_is_prime suggests prime testing similar to Lucas test in mini-gmp, indicating domain similarity.)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Backup (Contains mu_mpz_cmp_ui referencing mpz handling, matching extracted mpz_odd_p related domain.)"
    ],
    "filter_prorec_sum": "Checks if a given large integer is an odd prime using a strong Lucas primality test implementation from the mini-GMP library.",
    "work_score": {
        "prorec": {
            "summary": "Performs a strong Lucas primality test on a given large integer using mini-GMP routines to determine if it is prime.",
            "score": [
                0.353434101878937,
                0.454979954869691,
                0.4791123001774366
            ],
            "reason": [
                "The summary contains only one claim, which is that the function performs a strong Lucas primality test using mini-GMP routines. This claim is partially accurate as the function indeed performs a Lucas primality test, but the summary lacks specificity and does not accurately reflect the detailed operations and conditions present in the source code, such as the handling of specific values of D, the use of mpz_roinit_normal_n, and the specific checks and operations performed within the function. The claim is too generic and misses critical details, leading to less than 50% accuracy.",
                "The summary accurately identifies the core purpose of the function as performing a strong Lucas primality test, which aligns with the source code's operation of testing a number's primality using Lucas sequences. However, it lacks coverage of secondary details such as the specific handling of square numbers, the search for a suitable D value, and the iterative Lucas sequence calculations. These omissions result in a weak coverage of behavior-critical semantics beyond the core purpose.",
                "The summary accurately identifies the function's primary purpose as performing a Lucas primality test, which aligns with the source code's implementation of the test using mini-GMP routines. However, the summary lacks specificity regarding the function's detailed operations, such as handling of specific variables and conditions, resulting in low informational gain. There is no fatal inaccuracy, but the summary is generic and does not provide detailed insights into the function's behavior."
            ]
        },
        "filter_prorec": {
            "summary": "Checks if a given large integer is an odd prime using a strong Lucas primality test implementation from the mini-GMP library.",
            "score": [
                0.6213975755057778,
                0.3507946963828735,
                0.46761117508616284
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking if a given large integer is an odd prime using a strong Lucas primality test. This aligns with the source code, which includes assertions for oddness and uses Lucas sequences for primality testing. The claim is highly specific and verifiable, reflecting the domain-semantic behavior of the function.",
                "The summary identifies the use of a strong Lucas primality test, which aligns with the core purpose of the function. However, it inaccurately claims the function checks for odd primes, while the source code checks if a number is composite or not, returning 0 for squares and handling various conditions for D values. The summary lacks coverage of secondary details such as handling of square roots, the sequence of D values, and the use of the Lucas sequence.",
                "The summary correctly identifies the function as implementing a strong Lucas primality test, which is accurate. However, it inaccurately claims the function checks if a number is an odd prime, whereas the function checks for composite numbers using Lucas sequences. This introduces noise, but no fatal inaccuracies regarding the core purpose. The gain is low due to the generic nature of the summary."
            ]
        }
    }
}
{
    "source_code": "\n\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret = 0;\n\tBN_CTX *new_ctx = NULL;\n\t\n\tif (p != NULL)\n\t\t{\n\t\tif (!BN_copy(p, &group->field)) return 0;\n\t\t}\n\n\tif (a != NULL || b != NULL)\n\t\t{\n\t\tif (group->meth->field_decode)\n\t\t\t{\n\t\t\tif (ctx == NULL)\n\t\t\t\t{\n\t\t\t\tctx = new_ctx = BN_CTX_new();\n\t\t\t\tif (ctx == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(a, &group->a)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(b, &group->b)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tret = 1;\n\t\n err:\n\tif (new_ctx)\n\t\tBN_CTX_free(new_ctx);\n\treturn ret;\n\t}",
    "strip_decompiled_code": "__int64 __fastcall ec_GFp_simple_group_get_curve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _BYTE *a5)\n{\n  _DWORD *v9; // r8\n  _BOOL8 v10; // rbx\n  int v11; // eax\n  int v12; // eax\n  _BYTE *v13; // rax\n  _DWORD *ptr; // [rsp+8h] [rbp-40h]\n  _DWORD *ptra; // [rsp+8h] [rbp-40h]\n\n  if ( a2 && !BN_copy(a2, a1 + 104) )\n    return 0LL;\n  if ( !a3 && !a4 )\n    return 1LL;\n  if ( *(_QWORD *)(*(_QWORD *)a1 + 288LL) )\n  {\n    v9 = 0LL;\n    if ( a5 )\n    {\nLABEL_8:\n      if ( !a3\n        || (ptr = v9,\n            LODWORD(v10) = 0,\n            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                    a1,\n                    a3,\n                    a1 + 152,\n                    a5),\n            v9 = ptr,\n            v11) )\n      {\n        LODWORD(v10) = 1;\n        if ( a4 )\n        {\n          ptra = v9;\n          v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _BYTE *))(*(_QWORD *)a1 + 288LL))(\n                  a1,\n                  a4,\n                  a1 + 176,\n                  a5);\n          v9 = ptra;\n          v10 = v12 != 0;\n        }\n      }\n      if ( v9 )\n        BN_CTX_free(v9);\n      return v10;\n    }\n    v13 = BN_CTX_new();\n    a5 = v13;\n    if ( v13 )\n    {\n      v9 = v13;\n      goto LABEL_8;\n    }\n    return 0LL;\n  }\n  if ( a3 && !BN_copy(a3, a1 + 152) )\n    return 0LL;\n  if ( !a4 )\n    return 1LL;\n  return BN_copy(a4, a1 + 176) != 0;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'bool X509_NAME_cmp_ex(X509_NAME *a, X509_NAME *b, int flags)\\n\\t{\\n",
        "<s><asm_token>\n\"int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned char **pp)\\n{\\n\\tint ret;\\",
        "<s><asm_token>\n'int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *ctx, int type,\\n\\t\\",
        "<s><asm_token>\ns = '\\nint X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\\n{\\n    int i;\\",
        "<s><asm_token>\nt = '    if (ret == 0) {\\n        if (pkey->pkey.rsa != NULL) {\\n            if (pkey->pkey.rsa->"
    ],
    "prorec_sum": "Retrieves the prime field curve parameters a, b, and p from an EC group, using BN_copy or group-specific methods with optional BN_CTX management.",
    "extracted_features": [
        "BN_copy",
        "BN_CTX_new",
        "BN_CTX_free"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'bool X509_NAME_cmp_ex(X509_NAME *a, X509_NAME *b, int flags)\\n\\t{\\n",
        "\"int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned char **pp)\\n{\\n\\tint ret;\\",
        "'int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *ctx, int type,\\n\\t\\",
        "s = '\\nint X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\\n{\\n    int i;\\",
        "t = '    if (ret == 0) {\\n        if (pkey->pkey.rsa != NULL) {\\n            if (pkey->pkey.rsa->"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Retrieves the elliptic curve parameters a, b, and field prime from a GFp group, using BN_copy or a method callback with optional BN_CTX.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves the prime field curve parameters a, b, and p from an EC group, using BN_copy or group-specific methods with optional BN_CTX management.",
            "score": [
                0.9152824462021423,
                0.7810595845145529,
                0.8587903468443953
            ],
            "reason": [
                "The summary accurately describes the function's behavior, stating that it retrieves the curve parameters a, b, and p from an EC group using BN_copy or group-specific methods, which aligns with the source code. It also correctly mentions optional BN_CTX management, reflecting the conditional creation and freeing of BN_CTX. Nearly all claims are precise and verifiable, with high alignment to the source code semantics.",
                "The summary accurately covers the core purpose of the function, which is to retrieve the prime field curve parameters a, b, and p from an EC group. It mentions the use of BN_copy and group-specific methods, aligning with the source code's operations. The summary also notes optional BN_CTX management, reflecting the conditional creation and freeing of BN_CTX in the code. However, it lacks detail on error handling and specific conditions under which different methods are used, such as field_decode versus BN_copy.",
                "The summary accurately describes the primary purpose and functionality of the source code. It points out the retrieval of curve parameters 'a', 'b', and 'p' from an EC_GROUP, highlighting the use of 'BN_copy' and group-specific methods, with optional 'BN_CTX' management. This is a highly specific and verifiable claim that aligns with the source code's operations. There are no inaccuracies or noise, and the information provided gives high insight into the core functionalities of the function, ultimately saving an engineer time."
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves the elliptic curve parameters a, b, and field prime from a GFp group, using BN_copy or a method callback with optional BN_CTX.",
            "score": [
                0.8869886463840929,
                0.7792009361747573,
                0.8092474163537071
            ],
            "reason": [
                "The summary accurately describes the function's behavior, mentioning the retrieval of elliptic curve parameters a, b, and field prime using BN_copy or a method callback, which aligns with the source code. The use of optional BN_CTX is correctly noted, reflecting the conditional creation and use of BN_CTX in the function. Nearly all claims are precise and verifiable, with high alignment to the source code semantics.",
                "The summary accurately covers the core purpose of the function, which is to retrieve elliptic curve parameters a, b, and field prime from a GFp group. It mentions the use of BN_copy and method callbacks, aligning with the source code's operations. However, it lacks details on error handling and the creation of a new BN_CTX when ctx is NULL, which are critical secondary behaviors.",
                "The summary accurately describes the function's purpose of retrieving elliptic curve parameters a, b, and field prime from a GFp group. It correctly mentions the use of BN_copy and method callbacks, aligning with the source code's logic. The mention of optional BN_CTX is also accurate, reflecting the code's handling of context creation. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum pipe pipe, bool state)\n{\n\tint reg;\n\tu32 val;\n\tbool cur_state;\n\tenum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,\n\t\t\t\t\t\t\t\t      pipe);\n\n\t/* if we need the pipe A quirk it must be always on */\n\tif (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)\n\t\tstate = true;\n\n\tif (!intel_using_power_well(dev_priv->dev) &&\n\t    cpu_transcoder != TRANSCODER_EDP) {\n\t\tcur_state = false;\n\t} else {\n\t\treg = PIPECONF(cpu_transcoder);\n\t\tval = I915_READ(reg);\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\t}\n\n\tWARN(cur_state != state,\n\t     \"pipe %c assertion failure (expected %s, current %s)\\n\",\n\t     pipe_name(pipe), state_string(state), state_string(cur_state));\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF813B56F0(\n        _QWORD *a1,\n        unsigned int a2,\n        char a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11)\n{\n  char v12; // r14\n  int v13; // r12d\n  double v14; // xmm4_8\n  double v15; // xmm5_8\n  __int64 result; // rax\n  char *v17; // r9\n  char *v18; // r8\n\n  v12 = a3;\n  v13 = *(_DWORD *)(a1[a2 + 1065] + 2172LL);\n  if ( !a2 && (a1[947] & 1) != 0 )\n  {\n    if ( (unsigned __int8)sub_FFFFFFFF813D9840(*a1) >= (unsigned __int8)(v13 != 15) )\n    {\n      v12 = 1;\nLABEL_5:\n      result = sub_FFFFFFFF8138E6A0((__int64)a1, *(_DWORD *)a1[2] + (v13 << 12) + 458760);\n      if ( v12 == (int)result < 0 )\n        return result;\n      v18 = \"off\";\n      v17 = \"off\";\n      if ( (int)result < 0 )\n        v17 = \"on\";\n      if ( v12 )\n        v18 = \"on\";\n      return sub_FFFFFFFF8103BAE0(\n               (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n               1241,\n               (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n               a4,\n               a5,\n               a6,\n               a7,\n               v14,\n               v15,\n               a10,\n               a11,\n               a2 + 65,\n               v18,\n               v17);\n    }\n    goto LABEL_9;\n  }\n  result = sub_FFFFFFFF813D9840(*a1);\n  if ( (unsigned __int8)result >= (unsigned __int8)(v13 != 15) )\n    goto LABEL_5;\n  if ( a3 )\n  {\nLABEL_9:\n    v17 = \"off\";\n    v18 = \"on\";\n    return sub_FFFFFFFF8103BAE0(\n             (__int64)\"drivers/gpu/drm/i915/intel_display.c\",\n             1241,\n             (__int64)\"pipe %c assertion failure (expected %s, current %s)\\n\",\n             a4,\n             a5,\n             a6,\n             a7,\n             v14,\n             v15,\n             a10,\n             a11,\n             a2 + 65,\n             v18,\n             v17);\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[1, '\\n\\t\\tif (p->reg_blocks[i].flags & RADEON_RESET_BLOCK_LEGACY) {\\n\\t",
        "<s><asm_token>\n\"void radeon_gpu_init(struct radeon_device *rdev)\\n{\\n\\tint r;\\n\\tint i;\\n\\n\\tr->",
        "<s><asm_token>\n'void amdgpu_device_ip_block_add(struct amdgpu_device *adev, uint32_t id)\\n{\\n\\tstruct amdgpu_",
        "<s><asm_token>\ns_('[   2]   16 bit decoding: [0x00000000] => 0x00000000\\n[",
        "<s><asm_token>\nt('\\nstatic void\\nradeon_crtc_dpms(struct drm_crtc *crtc, int mode)\\n{\\n\\tstruct drm_"
    ],
    "prorec_sum": "Checks an Intel GPU display pipe\u2019s enabled state and logs an assertion failure if it differs from the expected on/off configuration.",
    "extracted_features": [
        "drivers/gpu/drm/i915/intel_display.c",
        "pipe %c assertion failure (expected %s, current %s)\\n"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        {
            "fragment": "s_('[   2]   16 bit decoding: [0x00000000] => 0x00000000\\n[",
            "reason": "Primarily output/data formatting with no recognizable C control flow or logic."
        },
        "[1, '\\n\\t\\tif (p->reg_blocks[i].flags & RADEON_RESET_BLOCK_LEGACY) {\\n\\t",
        "\"void radeon_gpu_init(struct radeon_device *rdev)\\n{\\n\\tint r;\\n\\tint i;\\n\\n\\tr->",
        "'void amdgpu_device_ip_block_add(struct amdgpu_device *adev, uint32_t id)\\n{\\n\\tstruct amdgpu_",
        "t('\\nstatic void\\nradeon_crtc_dpms(struct drm_crtc *crtc, int mode)\\n{\\n\\tstruct drm_"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Checks an Intel GPU display pipe\u2019s state against expectations and logs an assertion failure with pipe ID and on/off status details.",
    "work_score": {
        "prorec": {
            "summary": "Checks an Intel GPU display pipe\u2019s enabled state and logs an assertion failure if it differs from the expected on/off configuration.",
            "score": [
                0.8872753207182333,
                0.643746267653026,
                0.8400673806983635
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking the enabled state of an Intel GPU display pipe and logging an assertion failure if the current state differs from the expected state. This aligns well with the source code, which includes logic for determining the current state and comparing it to the expected state, with a warning issued if they do not match. The summary captures the core functionality without introducing inaccuracies, reflecting high precision in its claims.",
                "The summary accurately covers the core purpose of the function, which is to check the enabled state of an Intel GPU display pipe and log an assertion failure if it differs from the expected state. This aligns with the source code's operation of verifying the pipe's state and issuing a warning if there is a mismatch. The summary captures the primary purpose with specificity, but lacks mention of secondary details such as handling of quirks for pipe A, power well usage, and specific transcoder conditions.",
                "The summary accurately describes the function's primary purpose of checking the enabled state of an Intel GPU display pipe and logging an assertion failure if there is a mismatch. This aligns with the source code's logic, which involves reading the pipe configuration and comparing the current state with the expected state. The claim is specific and provides clear insight into the function's behavior, resulting in high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Checks an Intel GPU display pipe\u2019s state against expectations and logs an assertion failure with pipe ID and on/off status details.",
            "score": [
                0.8947052090001819,
                0.7660831879385535,
                0.8191037317802751
            ],
            "reason": [
                "The summary accurately describes the function's purpose of checking the state of an Intel GPU display pipe against expected values and logging assertion failures with details. The mention of 'pipe ID and on/off status details' aligns with the function's use of pipe names and state strings in the warning message. The summary captures the core functionality without introducing inaccuracies, reflecting high precision.",
                "The summary accurately covers the core purpose of the function, which is to check the state of an Intel GPU display pipe against expectations and log an assertion failure if there is a mismatch. This aligns with the function's operation of comparing the current state of the pipe with the expected state and issuing a warning if they differ. The summary also mentions logging details such as pipe ID and on/off status, which are critical secondary behaviors. However, it does not explicitly mention the handling of the PIPE_A quirk or the conditions under which the current state is determined, which are important edge cases and conditions in the source code.",
                "The summary accurately describes the function's primary purpose of checking the state of an Intel GPU display pipe against expected values and logging assertion failures with relevant details. This aligns with the source code's logic, which includes checking the pipe state and logging discrepancies. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n\t{\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tCMS_SignerInfo *si;\n\tint i;\n\tsinfos = CMS_get0_SignerInfos(cms);\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tif (!cms_SignerInfo_content_sign(cms, si, chain))\n\t\t\treturn 0;\n\t\t}\n\tcms->d.signedData->encapContentInfo->partial = 0;\n\treturn 1;\n\t}",
    "strip_decompiled_code": "__int64 __fastcall cms_SignedData_final(__int64 *a1, int *a2)\n{\n  int v2; // r12d\n  unsigned int *v3; // r13\n  __int64 v4; // rbx\n  int v6; // eax\n  _BYTE *v7; // rax\n  char *v8; // [rsp+18h] [rbp-D0h]\n  void *v9; // [rsp+18h] [rbp-D0h]\n  int v10; // [rsp+2Ch] [rbp-BCh] BYREF\n  void *v11[6]; // [rsp+30h] [rbp-B8h] BYREF\n  char v12[72]; // [rsp+60h] [rbp-88h] BYREF\n  unsigned __int64 v13; // [rsp+A8h] [rbp-40h]\n\n  v2 = 0;\n  v13 = __readfsqword(0x28u);\n  v3 = (unsigned int *)CMS_get0_SignerInfos(a1);\n  if ( (int)sk_num(v3) <= 0 )\n  {\nLABEL_16:\n    *(_DWORD *)(*(_QWORD *)(a1[1] + 16) + 16LL) = 0;\n    return 1LL;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v4 = sk_value((__int64)v3, v2);\n      EVP_MD_CTX_init(v11);\n      if ( !*(_QWORD *)(v4 + 64) )\n        break;\n      if ( !(unsigned int)cms_DigestAlgorithm_find_ctx((__int64 *)v11, a2, *(_QWORD **)(v4 + 16)) )\n        goto LABEL_4;\n      if ( (int)CMS_signed_get_attr_count(v4) < 0 )\n      {\n        v6 = EVP_PKEY_size(*(_QWORD *)(v4 + 64));\n        v7 = CRYPTO_malloc(v6, (__int64)\"cms_sd.c\", 0x295u);\n        if ( !v7 )\n        {\n          ERR_put_error(0x2Eu, 150, 65, (__int64)\"cms_sd.c\", 665);\n          goto LABEL_4;\n        }\n        v9 = v7;\n        if ( !(unsigned int)EVP_SignFinal(v11, (__int64)v7, &v10, *(_QWORD *)(v4 + 64)) )\n        {\n          ERR_put_error(0x2Eu, 150, 139, (__int64)\"cms_sd.c\", 671);\n          CRYPTO_free(v9);\nLABEL_4:\n          EVP_MD_CTX_cleanup((__int64 *)v11);\n          return 0LL;\n        }\n        ASN1_STRING_set0(*(_QWORD *)(v4 + 40), (__int64)v9, v10);\n      }\n      else\n      {\n        v8 = **(char ***)(a1[1] + 16);\n        if ( !(unsigned int)EVP_DigestFinal_ex(v11, (__int64)v12, &v10)\n          || !CMS_signed_add1_attr_by_NID(v4, 0x33u, 4u, v12, v10)\n          || (int)CMS_signed_add1_attr_by_NID(v4, 0x32u, 6u, v8, -1) <= 0\n          || !(unsigned int)CMS_SignerInfo_sign(v4) )\n        {\n          goto LABEL_4;\n        }\n      }\n      ++v2;\n      EVP_MD_CTX_cleanup((__int64 *)v11);\n      if ( v2 >= (int)sk_num(v3) )\n        goto LABEL_16;\n    }\n    ERR_put_error(0x2Eu, 150, 133, (__int64)\"cms_sd.c\", 629);\n    return 0LL;\n  }\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    if (i2d_ASN1_OCTET_STRING(oct, &derp) <= 0)\\n        return 0;\\n    derlen =",
        "<s><asm_token>\n\"int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)\\n\\t{\\n\\tBIO *in=",
        "<s><asm_token>\n'int i2d_OCSP_REQUEST_bio(BIO *bp, OCSP_REQUEST *req)\\n\\t{\\n\\tunsigned char *p,*pp;\\",
        "<s><asm_token>\ni('\\nint EVP_PKEY_CTX_set_hkdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md)\\n",
        "<s><asm_token>\nnstr('\\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\n\\t{\\n"
    ],
    "prorec_sum": "Finalizes signing for each CMS signer by completing digests, adding required signed attributes, generating signatures, and storing them in the signer information structures.",
    "extracted_features": [
        "CMS_get0_SignerInfos",
        "sk_num",
        "sk_value",
        "EVP_MD_CTX_init",
        "cms_DigestAlgorithm_find_ctx",
        "CMS_signed_get_attr_count",
        "EVP_PKEY_size",
        "CRYPTO_malloc",
        "ERR_put_error",
        "EVP_SignFinal",
        "ASN1_STRING_set0",
        "EVP_DigestFinal_ex",
        "CMS_signed_add1_attr_by_NID",
        "CMS_SignerInfo_sign",
        "\"cms_sd.c\""
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'    if (i2d_ASN1_OCTET_STRING(oct, &derp) <= 0)\\n        return 0;\\n    derlen =",
        "\"int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)\\n\\t{\\n\\tBIO *in=",
        "'int i2d_OCSP_REQUEST_bio(BIO *bp, OCSP_REQUEST *req)\\n\\t{\\n\\tunsigned char *p,*pp;\\",
        "i('\\nint EVP_PKEY_CTX_set_hkdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md)\\n",
        "nstr('\\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\n\\t{\\n"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Finalizes CMS SignedData by processing each signer\u2019s digest context, adding required signed attributes, generating signatures, and storing them in the structure.",
    "work_score": {
        "prorec": {
            "summary": "Finalizes signing for each CMS signer by completing digests, adding required signed attributes, generating signatures, and storing them in the signer information structures.",
            "score": [
                0.4879058174018772,
                0.4458028194277164,
                0.42836300412826567
            ],
            "reason": [
                "The summary accurately describes the function's purpose of finalizing signing for each CMS signer, which aligns with the loop iterating over signer information structures and calling cms_SignerInfo_content_sign. However, it inaccurately claims the function completes digests and adds signed attributes, which are not explicitly shown in the source code. Thus, only about 50% of the claims are accurate.",
                "The summary covers the core purpose of finalizing signing for each CMS signer, which aligns with the function's operation of iterating over signer information and signing content. However, it lacks coverage of secondary details such as the handling of the 'partial' flag and the return values indicating success or failure.",
                "The summary provides a general description of the function's purpose, mentioning the finalization of signing for CMS signers, which aligns with the source code's loop over signer information and the signing process. However, it lacks specific details about the function's implementation, such as the use of CMS_get0_SignerInfos and cms_SignerInfo_content_sign, resulting in low gain. There is no fatal inaccuracy, but the summary's generic nature limits its informativeness, leading to a mediocre net benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Finalizes CMS SignedData by processing each signer\u2019s digest context, adding required signed attributes, generating signatures, and storing them in the structure.",
            "score": [
                0.42601322500097966,
                0.46691349539825133,
                0.45065787718370676
            ],
            "reason": [
                "The summary correctly mentions the finalization of CMS SignedData and processing of each signer, which aligns with the loop iterating over signer infos and calling cms_SignerInfo_content_sign. However, it inaccurately claims the addition of signed attributes and storage of signatures, which are not explicitly evident in the source code. Thus, about half of the claims are accurate.",
                "The summary covers the core purpose of finalizing CMS SignedData by processing signer information, which aligns with the loop iterating over signer infos and signing content. However, it lacks details on setting 'partial' to 0 and the return values, which are critical for understanding the function's complete behavior.",
                "The summary correctly identifies the function's purpose of finalizing CMS SignedData by processing signer information, which aligns with the loop iterating over signer infos and calling cms_SignerInfo_content_sign. However, it inaccurately describes the addition of signed attributes and storage of signatures, which are not explicitly shown in the source code. The inaccuracies are more noise than fatal, as they do not contradict the core function behavior, but they reduce the clarity and specificity of the summary."
            ]
        }
    }
}
{
    "source_code": "static void tcp_set_skb_tso_segs(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int mss_now)\n{\n\tif (skb->len <= mss_now || !sk_can_gso(sk) ||\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\t/* Avoid the costly divide in the normal\n\t\t * non-TSO case.\n\t\t */\n\t\tskb_shinfo(skb)->gso_segs = 1;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t} else {\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss_now);\n\t\tskb_shinfo(skb)->gso_size = mss_now;\n\t\tskb_shinfo(skb)->gso_type = sk->sk_gso_type;\n\t}\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF81640B50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  unsigned int v6; // r12d\n  __int64 v7; // rcx\n  __int64 v8; // rcx\n  unsigned int v9; // edx\n  __int64 result; // rax\n\n  v6 = a3;\n  v7 = *(unsigned int *)(a2 + 200);\n  if ( (*(_BYTE *)(a2 + 124) & 2) == 0 )\n    goto LABEL_2;\n  v8 = *(_QWORD *)(a2 + 208) + v7;\n  if ( (unsigned __int16)*(_DWORD *)(v8 + 36) != 1 && !byte_FFFFFFFF81CAC6A7 )\n  {\n    sub_FFFFFFFF8103BB80((__int64)\"net/ipv4/tcp_output.c\", 993, a3, v8, a5, a6);\n    byte_FFFFFFFF81CAC6A7 = 1;\n    v7 = *(unsigned int *)(a2 + 200);\nLABEL_2:\n    v8 = *(_QWORD *)(a2 + 208) + v7;\n  }\n  v9 = *(_DWORD *)(a2 + 104);\n  if ( v9 > v6\n    && *(_DWORD *)(a1 + 304) << 16 == (*(_QWORD *)(a1 + 288) & (int)(*(_DWORD *)(a1 + 304) << 16))\n    && (*(_BYTE *)(a2 + 124) & 0xC) != 0 )\n  {\n    *(_WORD *)(v8 + 4) = (v9 + v6 - 1) / v6;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = v6;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = *(_DWORD *)(a1 + 304);\n  }\n  else\n  {\n    *(_WORD *)(v8 + 4) = 1;\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + *(unsigned int *)(a2 + 200) + 2LL) = 0;\n    result = *(unsigned int *)(a2 + 200);\n    *(_WORD *)(*(_QWORD *)(a2 + 208) + result + 6) = 0;\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'static void\\nwrite_fragment_data(struct ieee80211_tx_data *tx, struct sk_buff *skb,\\n\\t\\t",
        "<s><asm_token>\n\"static void nf_ct_refresh_acct(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\\n\\t\\t\\t   ",
        "<s><asm_token>\n'static void __skb_copy_header(struct sk_buff *newskb, const struct sk_buff *oldskb)\\n{\\n\\tint header_len = old",
        "<s><asm_token>\ns_indented('    /* Check if this is a padded packet */\\n    if (len < ETH_ZLEN) {\\n        if (net_ratelimit())",
        "<s><asm_token>\nt('struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)\\n{\\n\\tstruct net_device *dev;\\n\\"
    ],
    "prorec_sum": "Configures TCP segment header fields based on connection state and packet size, logging anomalies once, before finalizing length and identifier values.",
    "extracted_features": [
        "net/ipv4/tcp_output.c",
        "sub_FFFFFFFF8103BB80"
    ],
    "filter_strong": [],
    "filter_backup": [
        "\"static void nf_ct_refresh_acct(struct nf_conn *ct, enum ip_conntrack_info ctinfo,\\n\\t\\t\\t   "
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'static void\\nwrite_fragment_data(struct ieee80211_tx_data *tx, struct sk_buff *skb,\\n\\t\\t",
        "'static void __skb_copy_header(struct sk_buff *newskb, const struct sk_buff *oldskb)\\n{\\n\\tint header_len = old",
        "s_indented('    /* Check if this is a padded packet */\\n    if (len < ETH_ZLEN) {\\n        if (net_ratelimit())",
        "t('struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)\\n{\\n\\tstruct net_device *dev;\\n\\"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Candidate deals with nf_conn and ip_conntrack_info which are part of netfilter networking stack; shares domain proximity to net/ipv4 indicated by net subsystem string.)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Calculates and updates TCP output segment header fields based on connection state, segment size, and flags, with a one-time debug log on anomaly.",
    "work_score": {
        "prorec": {
            "summary": "Configures TCP segment header fields based on connection state and packet size, logging anomalies once, before finalizing length and identifier values.",
            "score": [
                0.13775406687981456,
                0.18349856346527008,
                0.19781301698540701
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions configuring TCP segment header fields based on connection state and logging anomalies, which are not present in the source code. The function actually sets GSO segment fields based on packet size and MSS, without any logging or connection state handling. Thus, less than 50% of the claims are accurate.",
                "The summary does not accurately cover the core purpose of the function, which is to set TSO segment fields based on packet size and connection capabilities. It incorrectly mentions logging anomalies and finalizing length and identifier values, which are not present in the source code. The summary lacks coverage of key behaviors such as conditional checks and setting specific fields like gso_segs, gso_size, and gso_type.",
                "The summary contains a FATAL inaccuracy regarding the PRIMARY PURPOSE of the function. It incorrectly states that the function configures TCP segment header fields based on connection state and logs anomalies, which contradicts the source code. The function actually sets GSO segment fields based on packet size and MSS, without any logging or connection state configuration. This severe misrepresentation of the core domain action results in a score reflecting negative benefit."
            ]
        },
        "filter_prorec": {
            "summary": "Calculates and updates TCP output segment header fields based on connection state, segment size, and flags, with a one-time debug log on anomaly.",
            "score": [
                0.1697850832137175,
                0.275379213684856,
                0.30679186468022734
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions calculating and updating TCP output segment header fields based on connection state, segment size, and flags, which is partially correct as the function updates segment size and type based on conditions. However, it incorrectly includes a 'one-time debug log on anomaly,' which is not present in the source code. This results in less than 50% of the claims being accurate.",
                "The summary does not accurately cover the core primary purpose of the function, which is to set TSO segment fields based on MSS and connection state. It incorrectly mentions a debug log on anomaly, which is not present in the source code. While it touches on TCP segment header fields, it lacks specificity and misses key details like handling non-TSO cases and conditions for setting gso_segs, gso_size, and gso_type.",
                "The summary inaccurately claims a debug log on anomaly, which is not present in the source code, constituting a FATAL error regarding side effects. The summary's description of calculating and updating TCP output segment header fields is correct but generic, providing low gain. The presence of a severe FATAL error on side effects results in a negative net benefit."
            ]
        }
    }
}
{
    "source_code": "\nSEXP attribute_hidden do_dynunload(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    char buf[2 * PATH_MAX];\n\n    checkArity(op,args);\n    if (!isString(CAR(args)) || LENGTH(CAR(args)) != 1)\n\terror(_(\"character argument expected\"));\n    GetFullDLLPath(call, buf, translateChar(STRING_ELT(CAR(args), 0)));\n    if(!DeleteDLL(buf))\n\terror(_(\"shared object '%s\\' was not loaded\"), buf);\n    return R_NilValue;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_6DF00(__int64 a1, __int64 a2, __int64 a3)\n{\n  __int64 v5; // rbp\n  __int64 v6; // rax\n  __int64 v7; // rdi\n  __int64 v8; // rdi\n  __int64 v9; // rax\n  unsigned int v11; // eax\n  int v12; // edx\n  int v13; // ecx\n  int v14; // r8d\n  int v15; // r9d\n  unsigned int v16; // eax\n  int v17; // edx\n  int v18; // ecx\n  int v19; // r8d\n  int v20; // r9d\n  char v21[8200]; // [rsp+0h] [rbp-2028h] BYREF\n  unsigned __int64 v22; // [rsp+2008h] [rbp-20h]\n\n  v22 = __readfsqword(0x28u);\n  Rf_checkArityCall(a2, a3, a1);\n  v5 = *(_QWORD *)(a3 + 32);\n  if ( (*(_BYTE *)v5 & 0x1F) != 0x10 || v5 == *(_QWORD *)&R_NilValue )\n    goto LABEL_13;\n  if ( *(char *)v5 < 0 )\n    v6 = ALTREP_LENGTH(*(_QWORD *)(a3 + 32));\n  else\n    v6 = *(_QWORD *)(v5 + 32);\n  if ( v6 > 0x7FFFFFFF )\n    R_BadLongVector(v5, \"Rdynload.c\", 960LL);\n  if ( (_DWORD)v6 != 1 )\n  {\nLABEL_13:\n    v11 = (unsigned int)dcgettext(0LL, \"character argument expected\", 5);\n    Rf_error(v11, (unsigned int)\"character argument expected\", v12, v13, v14, v15);\n  }\n  v7 = *(_QWORD *)(a3 + 32);\n  if ( *(char *)v7 < 0 )\n    v8 = ALTSTRING_ELT(v7, 0LL);\n  else\n    v8 = *(_QWORD *)(v7 + 48);\n  v9 = Rf_translateChar(v8);\n  (*((void (__fastcall **)(__int64, char *, __int64))off_512010 + 7))(a1, v21, v9);\n  if ( !(unsigned int)sub_6D7D0(v21) )\n  {\n    v16 = (unsigned int)dcgettext(0LL, \"shared object '%s' was not loaded\", 5);\n    Rf_error(v16, (unsigned int)v21, v17, v18, v19, v20);\n  }\n  return *(_QWORD *)&R_NilValue;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]\n\\'\\n\\t\\tif(x != NA_STRING)\\n\\t\\t\\tPROTECT(x = coerceVector(x, STRSX",
        "<s><asm_token>\n\"SEXP attribute_hidden do_date(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP ans;\\n",
        "<s><asm_token>\n'SEXP attribute_hidden do_read_csv(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP s",
        "<s><asm_token>\nSNOW('\\nSEXP attribute_hidden do_as_logical(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n",
        "<s><asm_token>\nEOL\n'    return 0;'\n'}'\n\n'SEXP attribute_hidden do_file_info(SEXP call, SEXP op, SEXP"
    ],
    "prorec_sum": "Validates a single character argument specifying a shared object name, loads it, and raises an error if the object is not found.",
    "extracted_features": [
        "Rf_checkArityCall",
        "ALTREP_LENGTH",
        "R_BadLongVector",
        "dcgettext",
        "character argument expected",
        "ALTSTRING_ELT",
        "Rf_translateChar",
        "shared object '%s' was not loaded"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[...]\n\\'\\n\\t\\tif(x != NA_STRING)\\n\\t\\t\\tPROTECT(x = coerceVector(x, STRSX",
        "\"SEXP attribute_hidden do_date(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP ans;\\n",
        "'SEXP attribute_hidden do_read_csv(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP s",
        "SNOW('\\nSEXP attribute_hidden do_as_logical(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n",
        "EOL\n'    return 0;'\n'}'\n\n'SEXP attribute_hidden do_file_info(SEXP call, SEXP op, SEXP"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Validates a single string argument and reports an error if the specified shared object was not successfully loaded.",
    "work_score": {
        "prorec": {
            "summary": "Validates a single character argument specifying a shared object name, loads it, and raises an error if the object is not found.",
            "score": [
                0.2052947911810365,
                0.20255398279909778,
                0.2267075935148914
            ],
            "reason": [
                "The summary inaccurately describes the function's behavior. It mentions loading a shared object, which is not present in the source code. The function actually validates a single character argument, checks if the shared object was loaded, and raises an error if it was not. Only one claim about argument validation is accurate, resulting in less than 50% accuracy.",
                "The summary inaccurately describes the function's behavior. It mentions loading a shared object, which contradicts the source code that actually deletes a DLL. The summary correctly notes the validation of a single character argument but fails to cover the core purpose of unloading a DLL. Additionally, it does not address error handling or other critical behaviors such as path translation.",
                "The summary inaccurately describes the function's behavior. It mentions loading a shared object, which contradicts the source code that actually unloads a DLL. This is a FATAL error regarding the PRIMARY PURPOSE of the function. Additionally, the summary fails to mention key aspects like error handling for incorrect arguments, contributing to a lack of accurate claims."
            ]
        },
        "filter_prorec": {
            "summary": "Validates a single string argument and reports an error if the specified shared object was not successfully loaded.",
            "score": [
                0.2613960045961693,
                0.25248405477923674,
                0.27848079513720614
            ],
            "reason": [
                "The summary inaccurately states that the function reports an error if the shared object was not successfully loaded, whereas the source code shows it reports an error if the shared object was not successfully unloaded. Additionally, the summary correctly mentions the validation of a single string argument, but misses other details like checking the length of the argument. Less than 50% of the claims are accurate.",
                "The summary inaccurately states the function reports an error if the shared object was not successfully loaded, whereas the source code shows it reports an error if the shared object was not successfully unloaded. The core purpose of unloading a DLL is not covered, and while the summary mentions argument validation, it misses other secondary details like error handling for incorrect argument types.",
                "The summary inaccurately describes the function's behavior by stating it reports an error if the shared object was not successfully loaded, whereas the source code indicates it reports an error if the shared object was not successfully unloaded. This is a FATAL error concerning the PRIMARY PURPOSE of the function, which is to unload a DLL. There are no accurate claims to provide positive gain."
            ]
        }
    }
}
{
    "source_code": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED)\n\t\treturn 0;\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF810AF780(__int64 a1)\n{\n  _QWORD *v2; // rbx\n  __int64 v3; // r13\n  int v4; // ebx\n  __int64 v5; // rax\n  int v6; // [rsp-2Ch] [rbp-2Ch] BYREF\n  _UNKNOWN **v7; // [rsp-28h] [rbp-28h]\n\n  if ( !dword_FFFFFFFF81E66B68 )\n    return 0LL;\n  v7 = (_UNKNOWN **)off_FFFFFFFF81C365F0;\n  v2 = off_FFFFFFFF81C365F0;\n  if ( off_FFFFFFFF81C365F0 == (_UNKNOWN *)&off_FFFFFFFF81C365F0 )\n  {\nLABEL_11:\n    v3 = 0LL;\n    v4 = 1;\n  }\n  else\n  {\n    while ( !(unsigned int)sub_FFFFFFFF810AD5F0(a1, v2 + 4, 0LL, 0LL, &v6, 1LL) )\n    {\n      v7 = (_UNKNOWN **)*v2;\n      v2 = v7;\n      if ( v7 == &off_FFFFFFFF81C365F0 )\n        goto LABEL_11;\n    }\n    v3 = 0LL;\n    if ( v6 == 2 )\n      v3 = sub_FFFFFFFF81100020(v2[39], 32LL);\n    v4 = v6;\n    if ( !v6 )\n      return 0LL;\n  }\n  v5 = sub_FFFFFFFF8112CA50(qword_FFFFFFFF81E8C750, 32976LL, 864LL);\n  if ( v5 )\n  {\n    *(_DWORD *)(v5 + 8) = v4;\n    *(_QWORD *)(v5 + 600) = v3;\n    *(_QWORD *)(v5 + 80) = -(__int64)(v4 == 2);\n    *(_QWORD *)(v5 + 760) = v5 + 760;\n    *(_QWORD *)(v5 + 768) = v5 + 760;\n    *(_QWORD *)(v5 + 584) = v5 + 584;\n    *(_QWORD *)(v5 + 592) = v5 + 584;\n    *(_QWORD *)(a1 + 1464) = v5;\n    _InterlockedOr8((volatile signed __int8 *)(*(_QWORD *)(a1 + 8) + 16LL), 0x80u);\n    return 0LL;\n  }\n  sub_FFFFFFFF8112DCD0(v3);\n  sub_FFFFFFFF810A8A10((int)\"out of memory in audit_alloc\", 32976LL);\n  return 4294967284LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...] = \\n\\t\\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)) == 0)",
        "<s><asm_token>\n\"int kvm_arch_init_vm(struct kvm *kvm)\\n{\\n\\tint ret;\\n\\n\\tret = kvm_mmu_init(",
        "<s><asm_token>\n'int btrfs_add_dev_item(struct btrfs_trans_handle *trans,\\n\\t\\t\\t struct btrfs_root *root,\\n\\",
        "<s><asm_token>\n\\'\\nstatic int __init iommu_sysfs_init(void)\\n{\\n\\tstruct device *dev;\\n\\tstruct dentry *dentry;\\n\\t",
        "<s><asm_token>\n\\'\\nstatic int __init blk_dev_init(void)\\n{\\n\\tint ret;\\n\\n\\tret = bioset_init(&blk_b"
    ],
    "prorec_sum": "Allocates and initializes an audit data structure for the given object, setting type-specific fields and marking it with an audit flag.",
    "extracted_features": [
        "out of memory in audit_alloc",
        "_InterlockedOr8"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[...] = \\n\\t\\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)) == 0)",
        "\"int kvm_arch_init_vm(struct kvm *kvm)\\n{\\n\\tint ret;\\n\\n\\tret = kvm_mmu_init(",
        "'int btrfs_add_dev_item(struct btrfs_trans_handle *trans,\\n\\t\\t\\t struct btrfs_root *root,\\n\\",
        "\\'\\nstatic int __init iommu_sysfs_init(void)\\n{\\n\\tstruct device *dev;\\n\\tstruct dentry *dentry;\\n\\t",
        "\\'\\nstatic int __init blk_dev_init(void)\\n{\\n\\tint ret;\\n\\n\\tret = bioset_init(&blk_b"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Allocates and initializes an audit data structure for the given object, linking it to global lists and handling out-of-memory errors.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes an audit data structure for the given object, setting type-specific fields and marking it with an audit flag.",
            "score": [
                0.45963089628231557,
                0.448437209479672,
                0.48816900830175636
            ],
            "reason": [
                "The summary correctly identifies that the function allocates and initializes an audit data structure, which aligns with the creation of 'audit_context'. However, it inaccurately generalizes the setting of 'type-specific fields' and marking with an 'audit flag', as the function specifically sets 'filterkey' and 'TIF_SYSCALL_AUDIT' flag, which are not mentioned. The claims are partially accurate but lack specificity and precision.",
                "The summary covers the core purpose of allocating and initializing an audit data structure, which aligns with the function's primary operation. However, it lacks detail on secondary aspects such as handling memory allocation failure, the condition for auditing being enabled, and setting the syscall audit flag.",
                "The summary correctly identifies the allocation and initialization of an audit data structure, which aligns with the function's purpose. However, it lacks specificity regarding the conditions under which the function returns early without allocation, such as when auditing is disabled or memory allocation fails. The summary also omits details about setting the filter key and thread flag, resulting in a low net benefit due to missing key points and noticeable noise."
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes an audit data structure for the given object, linking it to global lists and handling out-of-memory errors.",
            "score": [
                0.23050441541006433,
                0.27753849184756024,
                0.2605175641819733
            ],
            "reason": [
                "The summary inaccurately claims that the function links the audit data structure to global lists, which is not supported by the source code. It correctly mentions handling out-of-memory errors but fails to accurately describe the function's behavior regarding audit enabling and task filtering. Less than 50% of the claims are accurate.",
                "The summary inaccurately claims linking to global lists, which is not present in the source code. It correctly mentions allocation and initialization of an audit data structure, but fails to cover the core purpose of setting the task's audit context and handling specific conditions like audit being disabled or memory errors.",
                "The summary inaccurately claims that the function links the audit data structure to global lists, which is not supported by the source code, making it a FATAL error regarding the function's core behavior. The summary correctly mentions handling out-of-memory errors, but this is overshadowed by the inaccurate claim about global lists, resulting in a net benefit close to zero."
            ]
        }
    }
}
{
    "source_code": "\nstatic void\nshow_arch (FILE *stream, int ext, int check)\n{\n  static char message[] = MESSAGE_TEMPLATE;\n  char *start = message + 27;\n  char *p;\n  int size = sizeof (MESSAGE_TEMPLATE);\n  int left;\n  const char *name;\n  int len;\n  unsigned int j;\n\n  p = start;\n  left = size - (start - message);\n  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)\n    {\n      /* Should it be skipped?  */\n      if (cpu_arch [j].skip)\n\tcontinue;\n\n      name = cpu_arch [j].name;\n      len = cpu_arch [j].len;\n      if (*name == '.')\n\t{\n\t  /* It is an extension.  Skip if we aren't asked to show it.  */\n\t  if (ext)\n\t    {\n\t      name++;\n\t      len--;\n\t    }\n\t  else\n\t    continue;\n\t}\n      else if (ext)\n\t{\n\t  /* It is an processor.  Skip if we show only extension.  */\n\t  continue;\n\t}\n      else if (check && ! cpu_arch[j].flags.bitfield.cpui386)\n\t{\n\t  /* It is an impossible processor - skip.  */\n\t  continue;\n\t}\n\n      p = output_message (stream, p, message, start, &left, name, len);\n    }\n\n  /* Display disabled extensions.  */\n  if (ext)\n    for (j = 0; j < ARRAY_SIZE (cpu_noarch); j++)\n      {\n\tname = cpu_noarch [j].name;\n\tlen = cpu_noarch [j].len;\n\tp = output_message (stream, p, message, start, &left, name,\n\t\t\t    len);\n      }\n\n  *p = '\\0';\n  fprintf (stream, \"%s\\n\", message);\n}",
    "strip_decompiled_code": "int __fastcall sub_42F890(FILE *stream, int a2, int a3)\n{\n  char **v4; // rbx\n  int v5; // edx\n  unsigned int v6; // ebp\n  char *v7; // rax\n  char *v8; // rcx\n  int v9; // r8d\n  char **v10; // rbx\n  const char *v11; // rcx\n  int v12; // r8d\n  int v14[11]; // [rsp+Ch] [rbp-2Ch] BYREF\n\n  v4 = &off_4FBB00;\n  v5 = 0;\n  v6 = 0;\n  v7 = asc_7D76E0 + 27;\n  v14[0] = 54;\n  while ( 1 )\n  {\n    if ( !v5 )\n    {\n      v8 = *v4;\n      v9 = *((_DWORD *)v4 + 2);\n      if ( **v4 == 46 )\n      {\n        if ( a2 )\n        {\n          ++v8;\n          --v9;\nLABEL_5:\n          v7 = (char *)sub_42F7E0(stream, v7, v14, v8, v9);\n        }\n      }\n      else if ( !a2 && (!a3 || (*((_BYTE *)&xmmword_4FBB10 + 40 * v6) & 4) != 0) )\n      {\n        goto LABEL_5;\n      }\n    }\n    ++v6;\n    v4 += 5;\n    if ( v6 == 124 )\n      break;\n    v5 = *((_DWORD *)v4 + 8);\n  }\n  if ( a2 )\n  {\n    v10 = &off_4FB780;\n    v11 = \"no87\";\n    v12 = 4;\n    while ( 1 )\n    {\n      v7 = (char *)sub_42F7E0(stream, v7, v14, v11, v12);\n      if ( v10 == &off_4FBB00 )\n        break;\n      v12 = *((_DWORD *)v10 + 2);\n      v11 = *v10;\n      v10 += 4;\n    }\n  }\n  *v7 = 0;\n  return fprintf(stream, \"%s\\n\", asc_7D76E0);\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\",
        "<s><asm_token>\n\"static void\\npp_define_directive (pp_directive_macro_t *macro, int flags, const char *name, const char *replacement, int argc,",
        "<s><asm_token>\n'static void\\nformat_file_name (char *buf, size_t buf_size, const char *file_name,\\n                   const char *dir_name, int flags",
        "<s><asm_token>\ns'\\n\\nstatic void\\nwrite_file_data (FILE *file, const char *filename, int level)\\n{\\n  struct file_data *f;\\n  char",
        "<s><asm_token>\nt('      if (in_file_size > 0)\\n\\t\\t{',\\n\\t\\t\\tfor (i = 0; i < in_file"
    ],
    "prorec_sum": "Generates a formatted string from predefined name fragments and writes it to the given stream, appending an extra set when the second flag is set.",
    "extracted_features": [
        "fprintf",
        "no87",
        "FILE *stream",
        "asc_7D76E0"
    ],
    "filter_strong": [],
    "filter_backup": [
        "'static void\\nformat_file_name (char *buf, size_t buf_size, const char *file_name,\\n                   const char *dir_name, int flags",
        "s'\\n\\nstatic void\\nwrite_file_data (FILE *file, const char *filename, int level)\\n{\\n  struct file_data *f;\\n  char"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        {
            "fragment": "[',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\",
            "reason": "Contains only formatting artifacts and punctuation, no recognizable C logic or control flow."
        },
        "\"static void\\npp_define_directive (pp_directive_macro_t *macro, int flags, const char *name, const char *replacement, int argc,",
        "t('      if (in_file_size > 0)\\n\\t\\t{',\\n\\t\\t\\tfor (i = 0; i < in_file"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Candidate 1 works with file names and directories using flags which places it in a file I/O domain; matching the 'FILE *stream' and formatted output domain.)",
        "Idx 2: Backup (Candidate 2 writes file data using FILE pointers and filenames, matching the file I/O domain indicated by 'FILE *stream' and fprintf usage.)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Formats and writes a composed filename string to the output stream based on directory entries, flags, and specified formatting rules.",
    "work_score": {
        "prorec": {
            "summary": "Generates a formatted string from predefined name fragments and writes it to the given stream, appending an extra set when the second flag is set.",
            "score": [
                0.5104330260459641,
                0.3584472763991424,
                0.3881554981910426
            ],
            "reason": [
                "The summary correctly identifies that the function generates a formatted string from predefined name fragments and writes it to the given stream, which aligns with the function's behavior. However, the claim about appending an extra set when the second flag is set is only partially accurate. The function appends additional names from 'cpu_noarch' when the 'ext' flag is set, not the second flag 'check'. This results in mixed reliability, with approximately 50-80% of the claims being accurate.",
                "The summary mentions generating a formatted string and writing it to a stream, which aligns with the function's core purpose of constructing and outputting a message. However, it lacks specificity about the conditions under which different name fragments are appended, such as handling extensions and processor checks, which are critical behaviors in the source code.",
                "The summary provides a generic description of the function's behavior, mentioning the generation of a formatted string and writing it to a stream. However, it lacks specificity about the conditions under which different name fragments are included, such as the handling of extensions and processors based on the flags. The claim about appending an extra set when the second flag is set is vague and does not accurately capture the logic of the 'check' and 'ext' flags in the source code. The summary is mostly noise with low informational gain, as it does not provide detailed insights into the function's behavior."
            ]
        },
        "filter_prorec": {
            "summary": "Formats and writes a composed filename string to the output stream based on directory entries, flags, and specified formatting rules.",
            "score": [
                0.10421608138467076,
                0.203520704472973,
                0.1883633398280918
            ],
            "reason": [
                "The summary is inaccurate as it does not correctly describe the function's purpose. The function does not format or write a filename string; instead, it processes architectural names based on certain flags and writes these to an output stream. This misunderstanding results in the summary not aligning with any specific code behavior within the source provided.",
                "The summary does not cover the core primary purpose of the function, which is to display architecture names based on conditions such as extensions and processor checks. The summary incorrectly describes the function as formatting and writing a filename string, which is inaccurate. There is minimal secondary information provided, and the core functionality related to architecture names and conditions is missing.",
                "The summary inaccurately describes the function's purpose, stating it formats and writes a filename string, which contradicts the source code's actual behavior of composing and displaying architecture-related messages. This is a severe FATAL error regarding the core domain action, leading to a low score. There are no accurate claims to provide any positive gain."
            ]
        }
    }
}
{
    "source_code": "\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  long\n    length;\n\n  register long\n    i;\n\n  unsigned char\n    *profile;\n\n  /*\n    Determine length of color profile.\n  */\n  length=(long) GetCharacter(jpeg_info) << 8;\n  length+=(long) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (--length >= 0)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,\"ICC_PROFILE\") != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < length-12; i++)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n\n  /*\n    Read color profile.\n  */\n  profile=error_manager->buffer;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"ICC profile chunk: %ld bytes\",\n    length);\n\n  for (i=0 ; i < length; i++)\n   profile[i]=GetCharacter(jpeg_info);\n\n  (void) AppendImageProfile(image,\"ICM\",profile,length);\n\n  return(True);\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_13CA90(__int64 a1)\n{\n  __int64 v1; // rbx\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  unsigned __int8 *v5; // rbx\n  __int64 v6; // rbp\n  __int64 v7; // r13\n  size_t v8; // r13\n  __int64 *v9; // r15\n  __int64 v10; // rbp\n  _BYTE *v11; // rbx\n  __int64 v12; // [rsp+8h] [rbp-60h]\n  unsigned __int8 v13[12]; // [rsp+1Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+28h] [rbp-40h] BYREF\n\n  v14 = __readfsqword(0x28u);\n  v1 = (__int64)(int)sub_13BF80(a1) << 8;\n  v2 = v1 + (int)sub_13BF80(a1);\n  if ( v2 > 16 )\n  {\n    v5 = v13;\n    do\n      *v5++ = sub_13BF80(a1);\n    while ( v5 != (unsigned __int8 *)&v14 );\n    if ( (unsigned int)sub_9AC60(v13, \"ICC_PROFILE\") )\n    {\n      v6 = v2 - 14;\n      v7 = 0LL;\n      do\n      {\n        ++v7;\n        sub_13BF80(a1);\n      }\n      while ( v6 != v7 );\n    }\n    else\n    {\n      v8 = v2 - 16;\n      sub_13BF80(a1);\n      sub_13BF80(a1);\n      v9 = *(__int64 **)(a1 + 24);\n      v12 = *v9;\n      sub_5BCA0(150, (__int64)\"coders/jpeg.c\");\n      if ( v2 - 16 > 0 )\n      {\n        v10 = (__int64)v9 + v2 + 464;\n        v11 = v9 + 60;\n        do\n          *v11++ = sub_13BF80(a1);\n        while ( v11 != (_BYTE *)v10 );\n      }\n      sub_6E110(v12, \"ICM\", v9 + 60, v8);\n    }\n  }\n  else\n  {\n    v3 = v2 - 3;\n    if ( v3 >= 0 )\n    {\n      do\n      {\n        --v3;\n        sub_13BF80(a1);\n      }\n      while ( v3 != -1 );\n    }\n  }\n  return 1LL;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\",
        "<s><asm_token>\n\"static int\\nset_unsafe_char (int c)\\n{\\n  int i;\\n  int ret = 0;\\n  for (i = 0; i <",
        "<s><asm_token>\n'static int\\nwrite_floodfill_span(const PNG_FLOODY_SPAN * const span,\\n    png_structp png_ptr)\\",
        "<s><asm_token>\n  'bool\\nscan_wc (struct scan_state *ss)\\n{\\n  bool result = false;\\n  wchar_t wc;\\n  size_t i;\\",
        "<s><asm_token>\n  'static int\\nutf8_is_valid_string (const unsigned char *str, size_t len)\\n{\\n  const unsigned char *const end = str + len;\\"
    ],
    "prorec_sum": "Reads JPEG segment bytes, detects an \u201cICC_PROFILE\u201d marker, and if found extracts and stores the embedded ICC color profile data.",
    "extracted_features": [
        "ICC_PROFILE",
        "coders/jpeg.c",
        "ICM"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        {
            "fragment": "[',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\",
            "reason": "Only contains formatting characters and escape sequences, no C logic or intelligible code flow."
        },
        "\"static int\\nset_unsafe_char (int c)\\n{\\n  int i;\\n  int ret = 0;\\n  for (i = 0; i <",
        "'static int\\nwrite_floodfill_span(const PNG_FLOODY_SPAN * const span,\\n    png_structp png_ptr)\\",
        "  'bool\\nscan_wc (struct scan_state *ss)\\n{\\n  bool result = false;\\n  wchar_t wc;\\n  size_t i;\\",
        "  'static int\\nutf8_is_valid_string (const unsigned char *str, size_t len)\\n{\\n  const unsigned char *const end = str + len;\\"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Processes a JPEG ICC_PROFILE segment, reading its bytes and storing the ICM data into the image structure for further handling.",
    "work_score": {
        "prorec": {
            "summary": "Reads JPEG segment bytes, detects an \u201cICC_PROFILE\u201d marker, and if found extracts and stores the embedded ICC color profile data.",
            "score": [
                0.8694923495991462,
                0.7950337946226471,
                0.8393274361577803
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it reads JPEG segment bytes, checks for an 'ICC_PROFILE' marker, and extracts the ICC color profile data if the marker is found. These claims align well with the source code, which includes logic for reading bytes, checking the 'ICC_PROFILE' marker, and extracting the profile data. The summary captures the core functionality without introducing inaccuracies.",
                "The summary accurately covers the core primary purpose of the function, which is to read JPEG segment bytes and extract the ICC color profile data if the 'ICC_PROFILE' marker is found. This aligns with the source code's operations of checking for the 'ICC_PROFILE' marker and extracting the profile data. The summary captures the main domain-specific action but lacks mention of secondary details such as handling non-ICC profiles, logging events, and appending the profile to the image, which are critical behaviors in the source code.",
                "The summary accurately describes the function's primary purpose of reading JPEG segment bytes and detecting the 'ICC_PROFILE' marker. It correctly identifies the extraction and storage of the ICC color profile data, which aligns with the source code's operations. The claims are specific and detailed, providing high gain by clearly outlining the function's core behavior without introducing noise or inaccuracies."
            ]
        },
        "filter_prorec": {
            "summary": "Processes a JPEG ICC_PROFILE segment, reading its bytes and storing the ICM data into the image structure for further handling.",
            "score": [
                0.8655615398099611,
                0.7814124546574756,
                0.8188940625827146
            ],
            "reason": [
                "The summary accurately describes the function's purpose of processing a JPEG ICC_PROFILE segment and storing the ICM data into the image structure. The claims are highly specific and verifiable against the source code, which includes reading bytes and appending the profile to the image. The summary aligns well with the function's behavior, with over 80% of the claims being accurate.",
                "The summary accurately covers the core purpose of the function, which is to process a JPEG ICC_PROFILE segment and store the ICM data into the image structure. This aligns with the source code's operation of reading the ICC profile bytes and appending them to the image profile. While the summary captures the primary purpose, it lacks details on error handling and specific conditions like checking the 'magick' string and handling non-ICC profiles.",
                "The summary accurately describes the function's primary purpose of processing a JPEG ICC_PROFILE segment and storing the ICM data into the image structure, which aligns with the source code's operations. The claims are specific and verifiable, providing high gain by clearly stating the core domain action. There is minimal noise, as the summary focuses on the key functionality without extraneous information."
            ]
        }
    }
}
{
    "source_code": "\nint\ngsl_permutation_linear_to_canonical (gsl_permutation * q,\n                                     const gsl_permutation * p)\n{\n  const size_t n = p->size;\n  size_t i, k, s;\n  size_t t = n;\n\n  const size_t *const pp = p->data;\n  size_t *const qq = q->data;\n\n  if (q->size != p->size)\n    {\n      GSL_ERROR (\"size of q does not match size of p\", GSL_EINVAL);\n    }\n\n  for (i = 0; i < n; i++)\n    {\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          k = pp[k];\n          s++;\n        }\n\n      if (k < i)\n        continue;\n\n      /* Now have k == i, i.e the least in its cycle, and s == cycle length */\n\n      t -= s;\n\n      qq[t] = i;\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          qq[t + s] = k;\n          k = pp[k];\n          s++;\n        }\n\n      if (t == 0)\n        break;\n    }\n\n  return GSL_SUCCESS;\n}",
    "strip_decompiled_code": "__int64 __fastcall gsl_permutation_linear_to_canonical(__int64 *a1, _QWORD *a2)\n{\n  __int64 v2; // r8\n  __int64 v3; // rsi\n  __int64 v4; // r9\n  unsigned __int64 v5; // rdx\n  __int64 v6; // rdi\n  unsigned __int64 v7; // rax\n  __int64 i; // rcx\n  unsigned __int64 v9; // rax\n  unsigned __int64 *v10; // rcx\n\n  v2 = *a1;\n  if ( *a1 == *a2 )\n  {\n    if ( v2 )\n    {\n      v3 = a2[1];\n      v4 = a1[1];\n      v5 = 0LL;\n      v6 = *a1;\n      do\n      {\n        v7 = *(_QWORD *)(v3 + 8 * v5);\n        for ( i = 1LL; v7 > v5; ++i )\n          v7 = *(_QWORD *)(v3 + 8 * v7);\n        if ( v7 >= v5 )\n        {\n          v6 -= i;\n          *(_QWORD *)(v4 + 8 * v6) = v5;\n          v9 = *(_QWORD *)(v3 + 8 * v5);\n          if ( v9 > v5 )\n          {\n            v10 = (unsigned __int64 *)(v4 + 8 * v6 + 8);\n            do\n            {\n              *v10 = v9;\n              v9 = *(_QWORD *)(v3 + 8 * v9);\n              ++v10;\n            }\n            while ( v9 > v5 );\n          }\n          if ( !v6 )\n            break;\n        }\n        ++v5;\n      }\n      while ( v2 != v5 );\n    }\n    return 0LL;\n  }\n  else\n  {\n    gsl_error(\"size of q does not match size of p\", \"canonical.c\", 42LL, 4LL);\n    return 4LL;\n  }\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]\n\\t\\t\\t\\t'\\\\t\\t\\t\\t\\t\\tif (m->rows[i].n_elts == 0)\\n",
        "<s><asm_token>\n\"gsl_vector_view\\ngsl_vector_subvector_with_stride (const gsl_vector * v,\\n                                  size_t offset,\\n                                ",
        "<s><asm_token>\n'gsl_vector_complex *\\ngsl_vector_complex_alloc_from_block (gsl_block_complex * b,\\n                                     size_t offset,\\n",
        "<s><asm_token>\n\\'\\n\\nint\\ngsl_vector_complex_float_set_row(gsl_vector_complex_float * v, const size_t i, const gsl_",
        "<s><asm_token>\n\\'\\n\\nint\\ngsl_block_uchar_add (gsl_block_uchar * b, const gsl_block_uchar * b2)\\n{\\n  if"
    ],
    "prorec_sum": "Converts a linear permutation array into canonical cycle form, validating equal sizes and reporting an error if permutations differ in length.",
    "extracted_features": [
        "gsl_error",
        "size of q does not match size of p",
        "canonical.c"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[...]\n\\t\\t\\t\\t'\\\\t\\t\\t\\t\\t\\tif (m->rows[i].n_elts == 0)\\n",
        "\"gsl_vector_view\\ngsl_vector_subvector_with_stride (const gsl_vector * v,\\n                                  size_t offset,\\n                                ",
        "'gsl_vector_complex *\\ngsl_vector_complex_alloc_from_block (gsl_block_complex * b,\\n                                     size_t offset,\\n",
        "\\'\\n\\nint\\ngsl_vector_complex_float_set_row(gsl_vector_complex_float * v, const size_t i, const gsl_",
        "\\'\\n\\nint\\ngsl_block_uchar_add (gsl_block_uchar * b, const gsl_block_uchar * b2)\\n{\\n  if"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Converts a linear permutation representation into canonical cycle form, validating matching sizes and reporting an error if dimensions differ.",
    "work_score": {
        "prorec": {
            "summary": "Converts a linear permutation array into canonical cycle form, validating equal sizes and reporting an error if permutations differ in length.",
            "score": [
                0.8574487299484707,
                0.8023469777027792,
                0.8090979511047657
            ],
            "reason": [
                "The summary accurately describes the function's purpose of converting a linear permutation array into canonical cycle form, which aligns with the source code's logic. It correctly mentions the validation of equal sizes and the error reporting if sizes differ, which are specific behaviors observed in the code. However, the summary could be more detailed by mentioning the cycle length calculation and the specific handling of permutation cycles, which are key aspects of the function's implementation.",
                "The summary accurately covers the core purpose of converting a linear permutation array into canonical cycle form, which aligns with the source code's operation. It also mentions the validation of equal sizes and error reporting for size mismatch, covering key secondary behaviors related to input validation and error handling. However, it lacks details on the cycle detection and arrangement process, which are critical for complete coverage.",
                "The summary accurately describes the function's primary purpose of converting a linear permutation array into canonical cycle form and correctly notes the validation of equal sizes with error reporting if sizes differ. These are specific and detailed claims that align well with the source code, providing high gain. There is minimal noise, as the summary focuses on key aspects of the function's behavior."
            ]
        },
        "filter_prorec": {
            "summary": "Converts a linear permutation representation into canonical cycle form, validating matching sizes and reporting an error if dimensions differ.",
            "score": [
                0.8539594963599481,
                0.8010853117187315,
                0.8094544497527238
            ],
            "reason": [
                "The summary accurately describes the function's purpose of converting a linear permutation to a canonical cycle form and correctly notes the validation of matching sizes with error reporting if dimensions differ. These claims align well with the source code, which includes logic for size checking and permutation conversion. The summary captures the core functionality and error handling, indicating high precision.",
                "The summary accurately covers the core purpose of the function, which is converting a linear permutation representation into canonical cycle form. It also mentions the validation of matching sizes and error reporting, which are key secondary behaviors. However, it lacks details on the cycle length calculation and the specific handling of permutation cycles, which are critical for complete coverage.",
                "The summary accurately describes the primary purpose of the function, which is to convert a linear permutation representation into canonical cycle form. It correctly mentions the validation of matching sizes and the reporting of an error if dimensions differ, aligning with the source code's behavior. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\n\f\nint\nalias_cb(enum grecs_callback_command cmd,\n\t grecs_locus_t *locus,\n\t void *varptr,\n\t grecs_value_t *value,\n\t void *cb_data)\n{\n    char **argv;\n    int argc;\n    int i;\n\n    if (cmd != grecs_callback_set_value) {\n\tgrecs_error(locus, 0, _(\"Unexpected block statement\"));\n\treturn 1;\n    }\n    if (value->type != GRECS_TYPE_ARRAY) {\n\tgrecs_error(locus, 0, _(\"Not enough arguments for alias\"));\n\treturn 1;\n    }\n    argc = value->v.arg.c - 1;\n    argv = xcalloc(argc + 1, sizeof(argv[0]));\n    for (i = 0; i < argc; i++) {\n\tif (value->v.arg.v[i+1]->type != GRECS_TYPE_STRING) {\n\t    grecs_error(locus, 0, _(\"argument %d has wrong type\"), i+1);\n\t    return 1;\n\t}\n\targv[i] = xstrdup(value->v.arg.v[i+1]->v.string);\n    }\n    argv[i] = NULL;\n    return alias_install(value->v.arg.v[0]->v.string, argc, argv, locus);\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_11B00(int a1, const __m128i *a2, __int64 a3, __int64 a4)\n{\n  const char *v5; // rsi\n  __int64 v8; // rbx\n  int v9; // r14d\n  _QWORD *v10; // rax\n  __int64 v11; // r13\n  __int64 v12; // rax\n  __int64 v13; // r12\n  __int64 v14; // rbx\n  __int64 v15; // r12\n\n  v5 = \"Unexpected block statement\";\n  if ( a1 != 2 )\n    goto LABEL_4;\n  if ( *(_DWORD *)a4 != 2 )\n  {\n    v5 = \"Not enough arguments for alias\";\nLABEL_4:\n    dcgettext(0LL, v5, 5);\n    grecs_error();\n    return 1LL;\n  }\n  v8 = *(_QWORD *)(a4 + 40);\n  v9 = v8 - 1;\n  v10 = (_QWORD *)sub_2F900((int)v8, 8LL);\n  v11 = (__int64)v10;\n  if ( (int)v8 - 1 > 0 )\n  {\n    v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8LL);\n    if ( *(_DWORD *)v12 )\n    {\nLABEL_13:\n      dcgettext(0LL, \"argument %d has wrong type\", 5);\n      grecs_error();\n      return 1LL;\n    }\n    v13 = (unsigned int)(v8 - 2);\n    v14 = 1LL;\n    v15 = v13 + 1;\n    while ( 1 )\n    {\n      *(_QWORD *)(v11 + 8 * v14 - 8) = sub_2F970(*(void **)(v12 + 40));\n      if ( v14 == v15 )\n        break;\n      ++v14;\n      v12 = *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8 * v14);\n      if ( *(_DWORD *)v12 )\n        goto LABEL_13;\n    }\n    v10 = (_QWORD *)(v11 + 8 * v14);\n  }\n  *v10 = 0LL;\n  return sub_ACE0(*(void **)(**(_QWORD **)(a4 + 48) + 40LL), v9, v11, a2);\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'\\nstatic int\\nconfig_define_list_handler (struct config_file *cf,\\n                             struct config_list *list,\\n                             int argc, char",
        "<s><asm_token>\n\"static int\\nparse_set_mnt_field(char const *str, struct mnt_field *field)\\n{\\n    int rc = 0;\\n    char",
        "<s><asm_token>\n'static int\\nparse_range(const char *range, const char *name, unsigned long *first,\\n               unsigned long *last)\\n{\\n  char *r = xstr",
        "<s><asm_token>\nsnippet_indent('''\\nstatic int\nopt_str_list(void *opt_data, const char *opt_name, const char *opt_arg)\\n{\\n",
        "<s><asm_token>\nt = '    char *name = strdup (str);\\n    char *saveptr;\\n    char *token;\\n    char *value;\\n    int token_num = "
    ],
    "prorec_sum": "Validates alias command arguments, converts them to strings, and invokes a handler with the alias name and processed argument list.",
    "extracted_features": [
        "Unexpected block statement",
        "Not enough arguments for alias",
        "argument %d has wrong type",
        "dcgettext",
        "grecs_error"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'\\nstatic int\\nconfig_define_list_handler (struct config_file *cf,\\n                             struct config_list *list,\\n                             int argc, char",
        "\"static int\\nparse_set_mnt_field(char const *str, struct mnt_field *field)\\n{\\n    int rc = 0;\\n    char",
        "'static int\\nparse_range(const char *range, const char *name, unsigned long *first,\\n               unsigned long *last)\\n{\\n  char *r = xstr",
        "snippet_indent('''\\nstatic int\nopt_str_list(void *opt_data, const char *opt_name, const char *opt_arg)\\n{\\n",
        "t = '    char *name = strdup (str);\\n    char *saveptr;\\n    char *token;\\n    char *value;\\n    int token_num = "
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Validates alias arguments, converts them to strings, and invokes a command handler, reporting errors for unexpected blocks or incorrect argument types.",
    "work_score": {
        "prorec": {
            "summary": "Validates alias command arguments, converts them to strings, and invokes a handler with the alias name and processed argument list.",
            "score": [
                0.8576054706294121,
                0.6940086274430967,
                0.8041980106791737
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it validates alias command arguments, converts them to strings, and invokes a handler with the alias name and processed argument list. These claims align well with the source code, which checks the command type and argument types, processes them into strings, and calls alias_install with the alias name and arguments. The summary captures the core functionality without inaccuracies, indicating high precision.",
                "The summary accurately covers the core purpose of the function, which is to validate alias command arguments, convert them to strings, and invoke a handler with the alias name and processed argument list. This aligns with the source code's operations of checking command type, validating argument types, converting arguments to strings, and calling alias_install. However, the summary lacks details on error handling and specific conditions checked in the source code, such as unexpected block statements and wrong argument types.",
                "The summary accurately describes the core functionality of the function, which validates alias command arguments, converts them to strings, and invokes a handler with the alias name and processed argument list. These claims align well with the source code, providing specific insights into the function's behavior. There is minimal noise, and the claims are specific and detailed, offering high gain by clearly outlining the function's purpose and key operations."
            ]
        },
        "filter_prorec": {
            "summary": "Validates alias arguments, converts them to strings, and invokes a command handler, reporting errors for unexpected blocks or incorrect argument types.",
            "score": [
                0.9152824450568084,
                0.6801591978648122,
                0.8041980106791737
            ],
            "reason": [
                "The summary accurately describes the function's operation as validating alias arguments, converting arguments to strings, and reporting errors for unexpected blocks or incorrect types. It also mentions invoking a command handler, aligning with the function's call to 'alias_install'. Nearly all claims are accurate and relevant to the source code.",
                "The summary accurately covers the core purpose of the function, which is to validate alias arguments, convert them to strings, and invoke a command handler. It correctly mentions error reporting for unexpected blocks and incorrect argument types, aligning with the source code's checks for command type and argument types. However, it lacks detail on the allocation of memory for arguments and the specific invocation of 'alias_install', which are critical secondary behaviors.",
                "The summary accurately describes the function's behavior, including validation of alias arguments, conversion to strings, and invocation of a command handler. It correctly mentions error reporting for unexpected blocks and incorrect argument types, aligning well with the source code. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nvoid ironlake_edp_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_device *dev = intel_dp_to_dev(intel_dp);\n\tstruct drm_i915_private *dev_priv = dev->dev_private;\n\tu32 pp;\n\tu32 pp_ctrl_reg;\n\n\tif (!is_edp(intel_dp))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"Turn eDP power off\\n\");\n\n\tWARN(!intel_dp->want_panel_vdd, \"Need VDD to turn off panel\\n\");\n\n\tpp = ironlake_get_pp_control(intel_dp);\n\t/* We need to switch off panel power _and_ force vdd, for otherwise some\n\t * panels get very unhappy and cease to work. */\n\tpp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = IS_VALLEYVIEW(dev) ? PIPEA_PP_CONTROL : PCH_PP_CONTROL;\n\n\tI915_WRITE(pp_ctrl_reg, pp);\n\tPOSTING_READ(pp_ctrl_reg);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tironlake_wait_panel_off(intel_dp);\n}",
    "strip_decompiled_code": "void __fastcall sub_FFFFFFFF813CB4F0(\n        __int64 a1,\n        double a2,\n        double a3,\n        double a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        __int64 a10,\n        __int64 a11,\n        __int64 a12,\n        __int64 a13,\n        __int64 a14)\n{\n  char v14; // bl\n  __int64 v15; // r12\n  __int64 *v16; // r13\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  double v20; // xmm4_8\n  double v21; // xmm5_8\n  __int64 v22; // r8\n  __int64 v23; // r9\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  char v26; // [rsp-20h] [rbp-20h]\n\n  if ( *(_DWORD *)(a1 - 96) == 8 )\n  {\n    v15 = *(_QWORD *)(a1 - 184);\n    v16 = *(__int64 **)(v15 + 840);\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_edp_panel_off\",\n      (__int64)\"Turn eDP power off\\n\",\n      a13,\n      a14,\n      v14);\n    if ( !*(_BYTE *)(a1 + 912) )\n      sub_FFFFFFFF8103BAE0(\n        (__int64)\"drivers/gpu/drm/i915/intel_dp.c\",\n        1148,\n        (__int64)\"Need VDD to turn off panel\\n\",\n        a2,\n        a3,\n        a4,\n        a5,\n        v17,\n        v18,\n        a8,\n        a9);\n    v19 = sub_FFFFFFFF813C8A00(a1);\n    sub_FFFFFFFF8138EC40(\n      v16,\n      (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v15 + 840) + 16LL) + 7LL) & 8) == 0 ? 815620 : 1970692,\n      v19 & 0xFFFFFFF0,\n      a2,\n      a3,\n      a4,\n      a5,\n      v20,\n      v21,\n      a8,\n      a9);\n    *(_BYTE *)(a1 + 912) = 0;\n    sub_FFFFFFFF81379AC0(\n      4,\n      (int)\"drm\",\n      (__int64)\"ironlake_wait_panel_off\",\n      (__int64)\"Wait for panel power off time\\n\",\n      v22,\n      v23,\n      v26);\n    sub_FFFFFFFF813CA800(a1, 0xB000000F, 0, a2, a3, a4, a5, v24, v25, a8, a9);\n  }\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[0, '        \\n    /* 830M can have a PCH display.  It is only used for CRT2.\\\\n     * If it is being used,",
        "<s><asm_token>\n\"void intel_update_watermarks(struct drm_crtc *crtc)\\n{\\n\\tstruct drm_device *dev = crtc->dev;\\",
        "<s><asm_token>\n'void intel_crtc_update_cursor(struct drm_crtc *crtc, bool on)\\n{\\n\\tstruct drm_i915_",
        "<s><asm_token>\nvstr('\\nvoid intel_prepare_reset(struct drm_i915_private *dev_priv)\\n{\\n\\tstruct drm_device *dev = dev_",
        "<s><asm_token>\no(''',\\n\\t\\t\\t\\tif (IS_PINEVIEW(dev)) {\\n\\t\\t\\t\\t\\t/* Pine"
    ],
    "prorec_sum": "Turns off the Ironlake eDP panel, logs the action, ensures required power conditions, updates hardware state, and waits for the panel power-off delay.",
    "extracted_features": [
        "ironlake_edp_panel_off",
        "Turn eDP power off",
        "drivers/gpu/drm/i915/intel_dp.c",
        "Need VDD to turn off panel",
        "ironlake_wait_panel_off"
    ],
    "filter_strong": [],
    "filter_backup": [
        "\"void intel_update_watermarks(struct drm_crtc *crtc)\\n{\\n\\tstruct drm_device *dev = crtc->dev;\\",
        "'void intel_crtc_update_cursor(struct drm_crtc *crtc, bool on)\\n{\\n\\tstruct drm_i915_",
        "vstr('\\nvoid intel_prepare_reset(struct drm_i915_private *dev_priv)\\n{\\n\\tstruct drm_device *dev = dev_"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[0, '        \\n    /* 830M can have a PCH display.  It is only used for CRT2.\\\\n     * If it is being used,",
        "o(''',\\n\\t\\t\\t\\tif (IS_PINEVIEW(dev)) {\\n\\t\\t\\t\\t\\t/* Pine"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Candidate 1 refers to intel_update_watermarks in a DRM context, aligning with the GPU/DRM i915 domain from extracted features, though it lacks the specific Ironlake/eDP strings.)",
        "Idx 2: Backup (Candidate 2 contains intel_crtc_update_cursor with drm_i915 references, matching the overall DRM/i915 panel control domain but not the specific Ironlake strings.)",
        "Idx 3: Backup (Candidate 3 refers to intel_prepare_reset and drm_i915_private, matching the DRM/i915 GPU control domain from extracted features even if specific Ironlake/eDP strings are absent.)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Turns off the Ironlake eDP panel, logs status, updates power control registers, clears VDD state, and waits for panel power-down timing.",
    "work_score": {
        "prorec": {
            "summary": "Turns off the Ironlake eDP panel, logs the action, ensures required power conditions, updates hardware state, and waits for the panel power-off delay.",
            "score": [
                0.8870329592741933,
                0.7985475205330739,
                0.8487369692186972
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it turns off the eDP panel, logs the action, checks power conditions, updates the hardware state, and waits for the panel to power off. These claims align well with the source code, which includes turning off the panel, logging with DRM_DEBUG_KMS, ensuring VDD is needed, updating pp control register, and calling ironlake_wait_panel_off. Over 80% of the claims are accurate.",
                "The summary accurately covers the core purpose of the function, which is to turn off the Ironlake eDP panel. It mentions logging the action, ensuring power conditions, updating hardware state, and waiting for the panel power-off delay, which aligns well with the source code's operations such as checking eDP status, logging, modifying power control registers, and waiting for the panel to turn off. However, it lacks mention of specific error handling or edge cases like the WARN statement for VDD requirement.",
                "The summary accurately describes the function's primary purpose of turning off the Ironlake eDP panel and logging the action, which aligns with the source code. It correctly mentions ensuring required power conditions and updating hardware state, reflecting the manipulation of power control registers and the setting of 'want_panel_vdd' to false. The mention of waiting for the panel power-off delay corresponds to the call to 'ironlake_wait_panel_off'. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Turns off the Ironlake eDP panel, logs status, updates power control registers, clears VDD state, and waits for panel power-down timing.",
            "score": [
                0.8748697717913672,
                0.8302149186954976,
                0.8292728958821319
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it turns off the Ironlake eDP panel, logs the status, updates power control registers, clears the VDD state, and waits for panel power-down timing. Each claim corresponds to specific actions in the source code, such as logging with DRM_DEBUG_KMS, updating registers with I915_WRITE, and clearing VDD state by setting want_panel_vdd to false. Over 80% of the claims are accurate and aligned with the source code.",
                "The summary accurately covers the core purpose of the function, which is to turn off the Ironlake eDP panel. It also mentions key secondary behaviors such as logging status, updating power control registers, clearing the VDD state, and waiting for panel power-down timing. However, it does not explicitly mention the warning about needing VDD to turn off the panel or the specific register used for power control, which are important details in the source code.",
                "The summary accurately describes the function's primary purpose of turning off the Ironlake eDP panel and includes key actions such as logging status, updating power control registers, clearing VDD state, and waiting for panel power-down timing. These claims are specific and verifiable against the source code, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nint\ngsl_multilarge_nlinear_eval_df(const CBLAS_TRANSPOSE_t TransJ,\n                               const gsl_vector *x,\n                               const gsl_vector *f,\n                               const gsl_vector *u,\n                               const gsl_vector *swts,\n                               const double h,\n                               const gsl_multilarge_nlinear_fdtype fdtype,\n                               gsl_multilarge_nlinear_fdf *fdf,\n                               gsl_vector *v,\n                               gsl_matrix *JTJ,\n                               gsl_vector *work)\n{\n  const size_t n = fdf->n;\n  const size_t p = fdf->p;\n\n  if (u != NULL && ((TransJ == CblasNoTrans && u->size != p) ||\n                    (TransJ == CblasTrans && u->size != n)))\n    {\n      GSL_ERROR(\"u vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (v != NULL && ((TransJ == CblasNoTrans && v->size != n) ||\n                         (TransJ == CblasTrans && v->size != p)))\n    {\n      GSL_ERROR(\"v vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (JTJ != NULL && ((JTJ->size1 != p) || (JTJ->size2 != p)))\n    {\n      GSL_ERROR(\"JTJ matrix has wrong size\", GSL_EBADLEN);\n    }\n  else\n    {\n      int status;\n\n      if (fdf->df)\n        {\n          /* call user-supplied function */\n          status = ((*((fdf)->df)) (TransJ, x, u, fdf->params, v, JTJ));\n\n          if (v)\n            ++(fdf->nevaldfu);\n\n          if (JTJ)\n            ++(fdf->nevaldf2);\n        }\n      else\n        {\n#if 0\n          /* use finite difference Jacobian approximation */\n          status = gsl_multilarge_nlinear_df(h, fdtype, x, swts, fdf, f, df, work);\n#endif\n        }\n\n      return status;\n    }\n}",
    "strip_decompiled_code": "__int64 __fastcall gsl_multilarge_nlinear_eval_df(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        _QWORD *a4,\n        __int64 a5,\n        __int64 a6,\n        _QWORD *a7,\n        _QWORD *a8,\n        _QWORD *a9)\n{\n  bool v10; // zf\n  __int64 v11; // r8\n  __int64 v12; // rcx\n  __int64 (__fastcall *v13)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *); // r10\n  __int64 result; // rax\n\n  v10 = a4 == 0LL;\n  v11 = a7[3];\n  v12 = a7[4];\n  if ( v10 )\n  {\n    if ( !a8 )\n      goto LABEL_4;\n    if ( (_DWORD)a1 != 111 )\n    {\n      if ( (_DWORD)a1 != 112 )\n        goto LABEL_4;\nLABEL_23:\n      if ( *a8 == v12 )\n        goto LABEL_4;\n      goto LABEL_24;\n    }\nLABEL_15:\n    if ( *a8 == v11 )\n      goto LABEL_4;\nLABEL_24:\n    gsl_error(\"v vector has wrong size\", \"fdf.c\", 480LL, 19LL);\n    return 19LL;\n  }\n  if ( (_DWORD)a1 == 111 )\n  {\n    if ( *a4 != v12 )\n    {\nLABEL_19:\n      gsl_error(\"u vector has wrong size\", \"fdf.c\", 475LL, 19LL);\n      return 19LL;\n    }\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_15;\n  }\n  if ( (_DWORD)a1 == 112 )\n  {\n    if ( *a4 != v11 )\n      goto LABEL_19;\n    if ( !a8 )\n      goto LABEL_4;\n    goto LABEL_23;\n  }\nLABEL_4:\n  if ( !a9 || *a9 == v12 && a9[1] == v12 )\n  {\n    v13 = (__int64 (__fastcall *)(__int64, __int64, _QWORD *, _QWORD, _QWORD *, _QWORD *))a7[1];\n    if ( v13 )\n    {\n      result = v13(a1, a2, a4, a7[5], a8, a9);\n      if ( a8 )\n        ++a7[7];\n      if ( a9 )\n        ++a7[8];\n    }\n  }\n  else\n  {\n    gsl_error(\"JTJ matrix has wrong size\", \"fdf.c\", 484LL, 19LL);\n    return 19LL;\n  }\n  return result;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'\\n\\nstatic int\\nassign_row_major(gsl_matrix * m, const gsl_vector_view v)\\n{\\n  size_t i,",
        "<s><asm_token>\n\"int\\ngsl_matrix_set_row_vector (gsl_matrix * m, const size_t i, const gsl_vector * v)\\n{\\n  size_",
        "<s><asm_token>\n'gsl_vector_complex_view gsl_vector_complex_subvector_with_stride (const gsl_vector_complex * v, size_t i, size_",
        "<s><asm_token>\nsnippet_template = '''\nstatic int\\n{name}(const gsl_matrix * m, const gsl_vector * v, gsl_vector * x, gsl_",
        "<s><asm_token>\nt = '    if (a->size1 != b->size1 || a->size2 != b->size2)\\n        {\\n          gsl_error (\"vectors have different lengths"
    ],
    "prorec_sum": "Validates input vector and matrix dimensions for a nonlinear large-scale evaluation, reporting size errors before invoking the model\u2019s derivative function.",
    "extracted_features": [
        "gsl_error",
        "\"v vector has wrong size\"",
        "\"u vector has wrong size\"",
        "\"JTJ matrix has wrong size\"",
        "fdf.c"
    ],
    "filter_strong": [],
    "filter_backup": [
        "t = '    if (a->size1 != b->size1 || a->size2 != b->size2)\\n        {\\n          gsl_error (\"vectors have different lengths"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'\\n\\nstatic int\\nassign_row_major(gsl_matrix * m, const gsl_vector_view v)\\n{\\n  size_t i,",
        "\"int\\ngsl_matrix_set_row_vector (gsl_matrix * m, const size_t i, const gsl_vector * v)\\n{\\n  size_",
        "'gsl_vector_complex_view gsl_vector_complex_subvector_with_stride (const gsl_vector_complex * v, size_t i, size_",
        "snippet_template = '''\nstatic int\\n{name}(const gsl_matrix * m, const gsl_vector * v, gsl_vector * x, gsl_"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Backup (Candidate 4 includes a gsl_error call within an error message about mismatched vector lengths, which is conceptually similar to the 'v vector has wrong size' and other GSL error checks extracted from the decompiled code.)"
    ],
    "filter_prorec_sum": "Validates vector and matrix dimensions for nonlinear evaluation, reports size errors, and calls the appropriate evaluation routine while updating call counters.",
    "work_score": {
        "prorec": {
            "summary": "Validates input vector and matrix dimensions for a nonlinear large-scale evaluation, reporting size errors before invoking the model\u2019s derivative function.",
            "score": [
                0.8891423058905723,
                0.6415616711127632,
                0.8138241828650365
            ],
            "reason": [
                "The summary accurately describes the function's behavior of validating input vector and matrix dimensions, as evidenced by the checks for size mismatches and error reporting in the source code. It also correctly mentions the invocation of the model's derivative function, aligning well with the function's logic. The claims are highly specific and verifiable, with over 80% accuracy.",
                "The summary accurately covers the core purpose of the function, which is to validate input vector and matrix dimensions and report size errors. However, it lacks detail on secondary aspects such as the invocation of user-supplied functions, the conditions under which finite difference Jacobian approximation might be used, and the increment of evaluation counters. These omissions result in incomplete coverage of behavior-critical semantics.",
                "The summary accurately describes the function's primary purpose of validating input vector and matrix dimensions, which aligns with the source code's checks for size errors. It correctly mentions the reporting of size errors and the invocation of the derivative function, which are key aspects of the function's behavior. The claims are specific and relevant, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Validates vector and matrix dimensions for nonlinear evaluation, reports size errors, and calls the appropriate evaluation routine while updating call counters.",
            "score": [
                0.9105671034963965,
                0.798279179270804,
                0.8495480181414562
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it validates vector and matrix dimensions, reports size errors using GSL_ERROR, and calls the appropriate evaluation routine. It also mentions updating call counters, which aligns with the increment operations on 'nevaldfu' and 'nevaldf2'. The claims are highly specific and verifiable, with over 80% accuracy.",
                "The summary accurately covers the core purpose of the function, which involves validating vector and matrix dimensions and reporting size errors. It also mentions calling the appropriate evaluation routine and updating call counters, which aligns with the source code's behavior of invoking user-supplied functions and incrementing evaluation counters. However, it lacks detail on the specific conditions under which errors are reported and does not mention the finite difference Jacobian approximation, which is conditionally compiled out.",
                "The summary accurately describes the function's primary purpose of validating vector and matrix dimensions, reporting size errors, and calling the appropriate evaluation routine. It correctly mentions the update of call counters, which aligns with the source code's behavior. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "\nSEXP attribute_hidden do_Rhome(SEXP call, SEXP op, SEXP args, SEXP rho)\n{\n    char *path;\n    checkArity(op, args);\n    if (!(path = R_HomeDir()))\n\terror(_(\"unable to determine R home location\"));\n    return mkString(path);\n}",
    "strip_decompiled_code": "unsigned __int8 *__fastcall sub_1804F0(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __m128 a4,\n        __m128 a5,\n        __m128 a6,\n        __m128 a7,\n        double a8,\n        double a9,\n        __m128 a10,\n        __m128 a11)\n{\n  __int64 v11; // rax\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __m128 v15; // xmm4\n  __m128 v16; // xmm5\n  char *v17; // rbp\n  unsigned __int8 *v18; // rbx\n  __int64 v19; // rax\n  _BYTE *v20; // rax\n  __int64 v21; // rcx\n  int v22; // r8d\n  int v23; // r9d\n  double v24; // xmm4_8\n  double v25; // xmm5_8\n  unsigned int v27; // eax\n  __int64 v28; // rdx\n  __int64 v29; // rcx\n  __int64 v30; // r8\n  __int64 v31; // r9\n  __m128 v32; // xmm4\n  __m128 v33; // xmm5\n\n  Rf_checkArityCall(a2, a3, a1);\n  v11 = R_HomeDir();\n  if ( !v11 )\n  {\n    v27 = (unsigned int)dcgettext(0LL, \"unable to determine R home location\", 5);\n    Rf_error(\n      v27,\n      (__int64)\"unable to determine R home location\",\n      v28,\n      v29,\n      v30,\n      v31,\n      a4,\n      a5,\n      a6,\n      a7,\n      v32,\n      v33,\n      a10,\n      a11);\n  }\n  v17 = (char *)v11;\n  v18 = (unsigned __int8 *)Rf_allocVector3(0x10u, 1LL, 0LL, a4, a5, a6, a7, v15, v16, a10, a11, v12, v13, v14);\n  v19 = R_PPStackTop;\n  if ( R_PPStackTop >= R_PPStackSize )\n    R_signal_protect_error(\n      *(double *)a4.m128_u64,\n      *(double *)a5.m128_u64,\n      *(double *)a6.m128_u64,\n      *(double *)a7.m128_u64);\n  ++R_PPStackTop;\n  *(_QWORD *)(R_PPStack + 8 * v19) = v18;\n  v20 = (_BYTE *)Rf_mkChar(v17, 1);\n  SET_STRING_ELT(v18, 0LL, v20, a4, a5, a6, a7, v24, v25, a10, a11, v21, v22, v23);\n  --R_PPStackTop;\n  return v18;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'SEXP R_ParseEval(SEXP call, SEXP op, SEXP args, SEXP env) {\\n    SEXP rho,",
        "<s><asm_token>\n\"SEXP attribute_hidden do_getenv(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP ans;\\",
        "<s><asm_token>\n'SEXP attribute_hidden do_file_append(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP s",
        "<s><asm_token>\n\\'\\nstatic SEXP attribute_hidden do_getSrcref(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n   ",
        "<s><asm_token>\n\\'\\nstatic SEXP make_package_list(SEXP packages)\\n{\\n    SEXP pkgs = PROTECT(allocVector(STRSXP,"
    ],
    "prorec_sum": "Returns a single-element character vector containing R\u2019s home directory path, raising an error if the home location cannot be determined.",
    "extracted_features": [
        "Rf_checkArityCall",
        "R_HomeDir",
        "dcgettext",
        "unable to determine R home location",
        "Rf_error",
        "Rf_allocVector3",
        "R_PPStackTop",
        "R_signal_protect_error",
        "Rf_mkChar",
        "SET_STRING_ELT"
    ],
    "filter_strong": [],
    "filter_backup": [
        "\"SEXP attribute_hidden do_getenv(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP ans;\\",
        "\\'\\nstatic SEXP make_package_list(SEXP packages)\\n{\\n    SEXP pkgs = PROTECT(allocVector(STRSXP,"
    ],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'SEXP R_ParseEval(SEXP call, SEXP op, SEXP args, SEXP env) {\\n    SEXP rho,",
        "'SEXP attribute_hidden do_file_append(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n    SEXP s",
        "\\'\\nstatic SEXP attribute_hidden do_getSrcref(SEXP call, SEXP op, SEXP args, SEXP env)\\n{\\n   "
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Backup (Candidate 1 references do_getenv which implies environment interaction similar to 'R_HomeDir', aligning with getenv/domain-specific functionality.)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Backup (Candidate 4 uses allocVector(STRSXP), which is related to Rf_allocVector-like functionality, indicating domain similarity.)"
    ],
    "filter_prorec_sum": "Returns a character vector containing the R home directory path, raising an error if the location cannot be determined.",
    "work_score": {
        "prorec": {
            "summary": "Returns a single-element character vector containing R\u2019s home directory path, raising an error if the home location cannot be determined.",
            "score": [
                0.9840104966103722,
                0.874899928027982,
                0.9312046211015128
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it returns a character vector with R's home directory path and raises an error if the path cannot be determined. Both claims are specific and verifiable against the source code, showing high precision.",
                "The summary accurately covers the core primary purpose of the function, which is to return a single-element character vector containing R's home directory path. It also correctly mentions the error handling aspect, which is a critical behavior in the source code. The summary is near-complete, capturing both the main operation and the error condition, but lacks mention of the checkArity function call, which is a secondary detail.",
                "The summary accurately describes the function's behavior: it returns a single-element character vector with R's home directory path and raises an error if the path cannot be determined. This aligns with the source code, which checks the path using R_HomeDir() and raises an error if the path is null. The claims are specific and detailed, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Returns a character vector containing the R home directory path, raising an error if the location cannot be determined.",
            "score": [
                0.9791028484220015,
                0.855800709702466,
                0.9031327952438286
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it returns the R home directory path as a character vector and raises an error if the location cannot be determined. Both claims are specific and verifiable against the source code, showing high precision.",
                "The summary accurately covers the core purpose of the function, which is to return the R home directory path as a character vector. It also correctly mentions the error handling aspect when the path cannot be determined, aligning well with the source code's behavior-critical semantics.",
                "The summary accurately describes the function's primary purpose and key I/O behavior: returning the R home directory path and raising an error if it cannot be determined. These claims are specific and verifiable against the source code, providing high gain with minimal noise."
            ]
        }
    }
}
{
    "source_code": "int\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}",
    "strip_decompiled_code": "__int64 __fastcall evutil_read_file_(char *a1, __int64 *a2, unsigned __int64 *a3)\n{\n  int v4; // eax\n  int v5; // ebp\n  __int64 v6; // r12\n  __off_t st_size; // rdx\n  unsigned __int64 v8; // r15\n  _BYTE *v9; // rbx\n  int v10; // eax\n  unsigned int v12; // [rsp+8h] [rbp-E0h]\n  int v13; // [rsp+Ch] [rbp-DCh]\n  stat stat_buf; // [rsp+10h] [rbp-D8h] BYREF\n  unsigned __int64 v15; // [rsp+A8h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  if ( !a2 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  if ( !a3 )\n    event_errx(-559030611, (char)\"%s:%d: Assertion %s failed in %s\");\n  *a2 = 0LL;\n  *a3 = 0LL;\n  v4 = evutil_open_closeonexec_(a1, 0);\n  v5 = v4;\n  if ( v4 < 0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v12 = __fxstat(1, v4, &stat_buf);\n    if ( v12 || stat_buf.st_size > 0x7FFFFFFFFFFFFFFEuLL || (v6 = event_mm_malloc_(stat_buf.st_size + 1)) == 0 )\n    {\n      close(v5);\n      return (unsigned int)-2;\n    }\n    else\n    {\n      st_size = stat_buf.st_size;\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v9 = (_BYTE *)(v6 + v8);\n        v10 = read(v5, (void *)(v6 + v8), st_size - v8);\n        if ( v10 <= 0 )\n          break;\n        st_size = stat_buf.st_size;\n        v8 += v10;\n        if ( stat_buf.st_size <= v8 )\n        {\n          v9 = (_BYTE *)(v6 + v8);\n          close(v5);\n          goto LABEL_11;\n        }\n      }\n      v13 = v10;\n      close(v5);\n      if ( !v13 )\n      {\nLABEL_11:\n        *v9 = 0;\n        *a3 = v8;\n        *a2 = v6;\n        return v12;\n      }\n      event_mm_free_(v6);\n      return (unsigned int)-2;\n    }\n  }\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    { \\n\\tint fd = -1;\\n\\tstruct stat sb;\\n\\tstruct sockaddr_storage ss;\\n\\tstruct sockaddr",
        "<s><asm_token>\n\"static int\\n_bufferevent_openssl_enable_tls(struct bufferevent *bufev, int sock)\\n{\\n\tstruct bufferevent_openssl",
        "<s><asm_token>\n'int\\nbufferevent_socket_connect_hostname(struct bufferevent *bev, struct evdns_base *dns_base, const char *hostname, ev_",
        "<s><asm_token>\niq = '    if (evthread_use_pthreads_impl)\\n        {\\n            pthread_attr_t attr;\\n            int r;\\n            pthread_attr",
        "<s><asm_token>\nn_i('\\nint\\nbufferevent_enable_locking(struct bufferevent *bufev, int locking)\\n{\\n\tstruct bufferevent_private *buf"
    ],
    "prorec_sum": "Reads the entire contents of a file into a newly allocated null-terminated buffer, returning its size and handling errors appropriately.",
    "extracted_features": [
        "event_errx",
        "evutil_open_closeonexec_",
        "__fxstat",
        "stat_buf.st_size",
        "event_mm_malloc_",
        "event_mm_free_",
        "read",
        "close",
        "Assertion %s failed in %s"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'    { \\n\\tint fd = -1;\\n\\tstruct stat sb;\\n\\tstruct sockaddr_storage ss;\\n\\tstruct sockaddr",
        "\"static int\\n_bufferevent_openssl_enable_tls(struct bufferevent *bufev, int sock)\\n{\\n\tstruct bufferevent_openssl",
        "'int\\nbufferevent_socket_connect_hostname(struct bufferevent *bev, struct evdns_base *dns_base, const char *hostname, ev_",
        "iq = '    if (evthread_use_pthreads_impl)\\n        {\\n            pthread_attr_t attr;\\n            int r;\\n            pthread_attr",
        "n_i('\\nint\\nbufferevent_enable_locking(struct bufferevent *bufev, int locking)\\n{\\n\tstruct bufferevent_private *buf"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Reads the entire contents of a file into a newly allocated, null-terminated buffer and returns its address and length via output parameters.",
    "work_score": {
        "prorec": {
            "summary": "Reads the entire contents of a file into a newly allocated null-terminated buffer, returning its size and handling errors appropriately.",
            "score": [
                0.8972554803472992,
                0.8188594351660482,
                0.8546256038693057
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it reads the entire contents of a file into a newly allocated null-terminated buffer, returns its size, and handles errors appropriately. These claims align well with the source code, which includes error handling, memory allocation, and null-termination of the buffer. The summary captures the core functionality and error management, with over 80% of claims being accurate.",
                "The summary accurately covers the core purpose of the function, which is to read the entire contents of a file into a newly allocated null-terminated buffer and return its size. It also mentions error handling, which is a key secondary behavior. However, it lacks details on specific error codes, binary mode handling, and platform-specific reading constraints, which are present in the source code.",
                "The summary accurately describes the function's primary purpose of reading a file into a null-terminated buffer and returning its size, which aligns with the source code. It correctly notes error handling, which is a key aspect of the function. The claims are specific and verifiable, providing high gain with minimal noise."
            ]
        },
        "filter_prorec": {
            "summary": "Reads the entire contents of a file into a newly allocated, null-terminated buffer and returns its address and length via output parameters.",
            "score": [
                0.9224061149533739,
                0.7668061073418787,
                0.8972554804389572
            ],
            "reason": [
                "The summary accurately describes the function's behavior: it reads the entire contents of a file into a newly allocated, null-terminated buffer and returns its address and length via output parameters. This aligns with the source code, which uses `read` to fill a buffer, null-terminates it, and sets output parameters `content_out` and `len_out`.",
                "The summary accurately covers the core primary purpose of the function, which is to read the entire contents of a file into a newly allocated, null-terminated buffer and return its address and length via output parameters. This aligns with the function's operations of opening a file, reading its contents, and handling memory allocation. The summary does not mention error handling or specific edge cases like binary mode or file size checks, which are critical secondary behaviors in the source code.",
                "The summary accurately describes the primary purpose of the function, which is to read the entire contents of a file into a newly allocated, null-terminated buffer and return its address and length via output parameters. This aligns with the core domain action and key I/O of the function as seen in the source code. There is no noise or inaccuracies present, and the summary provides specific and detailed information that saves the engineer time, indicating high gain."
            ]
        }
    }
}
{
    "source_code": "\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch(status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"3 %s %s %c\", log->type->name, lc->log_dev->name,\n\t\t       lc->log_dev_flush_failed ? 'F' :\n\t\t       lc->log_dev_failed ? 'D' :\n\t\t       'A');\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %s %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\n\t\t       lc->region_size);\n\t\tDMEMIT_SYNC;\n\t}\n\n\treturn sz;\n}",
    "strip_decompiled_code": "__int64 __fastcall sub_FFFFFFFF815267B0(\n        _QWORD **a1,\n        int a2,\n        __int64 a3,\n        unsigned int a4,\n        double a5,\n        double a6,\n        double a7,\n        double a8,\n        double a9,\n        double a10,\n        double a11,\n        double a12)\n{\n  _QWORD *v14; // r13\n  unsigned int v15; // ebx\n  double v17; // xmm4_8\n  double v18; // xmm5_8\n  int v19; // eax\n  char *v20; // rcx\n  __int64 v21; // r9\n\n  v14 = a1[2];\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return 0;\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v15 = sub_FFFFFFFF812B8480(\n            a3,\n            a4,\n            (__int64)\"%s %u %s %u \",\n            a5,\n            a6,\n            a7,\n            a8,\n            a9,\n            a10,\n            a11,\n            a12,\n            **a1,\n            3 - (unsigned int)(*((_DWORD *)v14 + 19) == 0),\n            v14[17] + 12LL,\n            *((_DWORD *)v14 + 5));\n    v19 = *((_DWORD *)v14 + 19);\n    if ( !v19 || a4 <= v15 )\n      return v15;\n    v20 = \"no\";\n    if ( v19 != 1 )\n      v20 = (char *)&unk_FFFFFFFF81999F6F;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3 + (int)v15,\n                           a4 - v15,\n                           (__int64)\"%ssync \",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           v17,\n                           v18,\n                           a11,\n                           a12,\n                           v20)\n         + v15;\n  }\n  else\n  {\n    v15 = 0;\n    if ( !a4 )\n      return v15;\n    v21 = 70LL;\n    if ( !*((_DWORD *)v14 + 33) )\n      v21 = *((_DWORD *)v14 + 32) == 0 ? 65 : 68;\n    return (unsigned int)sub_FFFFFFFF812B8480(\n                           a3,\n                           a4,\n                           (__int64)\"3 %s %s %c\",\n                           a5,\n                           a6,\n                           a7,\n                           a8,\n                           a9,\n                           a10,\n                           a11,\n                           a12,\n                           **a1,\n                           v14[17] + 12LL,\n                           v21);\n  }\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[...]\n'static int show_map_fd(struct seq_file *m, void *v)\\n{\\n\\tstruct proc_maps_private *priv = m->private;\\",
        "<s><asm_token>\n\"static int pci_slot_create_sysfs_dev(struct pci_slot *slot)\\n{\\n\\tstruct pci_dev *dev = slot->",
        "<s><asm_token>\n'static int __dmi_checksum(const u8 *data, int len)\\n{\\n\\tint i, sum = 0;\\n\\n\\tfor (i =",
        "<s><asm_token>\ns_printf('\\nstatic int print_x2apic_flags(struct seq_file *m, int node, int cpu)\\n{\\n\\tstruct cpuinfo_x86",
        "<s><asm_token>\nt1('int\\nhwloc_obj_snprintf(char * __hwloc_restrict buffer, size_t size,\\n                   hwloc_topology_t topology"
    ],
    "prorec_sum": "Formats and writes synchronization or status information into a buffer based on provided parameters and internal structure fields.",
    "extracted_features": [
        "%s %u %s %u ",
        "%ssync ",
        "3 %s %s %c"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[...]\n'static int show_map_fd(struct seq_file *m, void *v)\\n{\\n\\tstruct proc_maps_private *priv = m->private;\\",
        "\"static int pci_slot_create_sysfs_dev(struct pci_slot *slot)\\n{\\n\\tstruct pci_dev *dev = slot->",
        "'static int __dmi_checksum(const u8 *data, int len)\\n{\\n\\tint i, sum = 0;\\n\\n\\tfor (i =",
        "s_printf('\\nstatic int print_x2apic_flags(struct seq_file *m, int node, int cpu)\\n{\\n\\tstruct cpuinfo_x86",
        "t1('int\\nhwloc_obj_snprintf(char * __hwloc_restrict buffer, size_t size,\\n                   hwloc_topology_t topology"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Formats and writes synchronization or status command strings with device-specific fields into a provided buffer based on mode and internal state flags.",
    "work_score": {
        "prorec": {
            "summary": "Formats and writes synchronization or status information into a buffer based on provided parameters and internal structure fields.",
            "score": [
                0.6352040821883651,
                0.43239297867616333,
                0.6403118657211345
            ],
            "reason": [
                "The summary accurately describes the function's behavior of formatting and writing status information based on parameters and internal structure fields. It captures the core functionality of the function, which involves using the DMEMIT macro to format strings based on the status type and internal fields like log_dev->name and region_size. However, it lacks specific details about the different cases handled (STATUSTYPE_INFO and STATUSTYPE_TABLE) and the conditions checked (e.g., lc->log_dev_flush_failed). Despite these omissions, the summary aligns well with the source code's primary operations.",
                "The summary covers the core purpose of formatting and writing status information based on parameters and internal fields, aligning with the function's operation of emitting formatted strings based on the status type. However, it lacks detail on specific behaviors such as handling different status types, the conditional logic for 'F', 'D', 'A', and the use of DMEMIT_SYNC, which are critical for complete coverage.",
                "The summary accurately describes the function's purpose of formatting and writing synchronization or status information based on parameters and internal fields, aligning with the source code's behavior. While the claims are somewhat generic, they correctly capture the core functionality without introducing noise or inaccuracies. The gain is moderate due to the lack of specific details, but the summary is still useful for understanding the function's primary purpose."
            ]
        },
        "filter_prorec": {
            "summary": "Formats and writes synchronization or status command strings with device-specific fields into a provided buffer based on mode and internal state flags.",
            "score": [
                0.8671742399062398,
                0.5956781569927793,
                0.7591815108810366
            ],
            "reason": [
                "The summary accurately describes the core functionality of the function, which formats and writes strings reflecting the synchronization or status commands based on device-specific fields and internal states. It mentions 'mode' (status type) and 'internal state flags', aligning well with the source code's use of STATUSTYPE_INFO and STATUSTYPE_TABLE cases. Over 80% of claims are accurate.",
                "The summary covers the core purpose of formatting and writing command strings based on mode and internal state flags, aligning with the function's operation of emitting formatted strings depending on the status type. However, it lacks detail on specific secondary behaviors such as the handling of different status types (STATUSTYPE_INFO and STATUSTYPE_TABLE) and the specific fields used in formatting (e.g., device names, sync status, and region size).",
                "The summary accurately captures the function's purpose of formatting and writing status command strings based on mode and internal state flags, aligning with the source code's behavior. The claims are specific and verifiable, providing high gain by summarizing the function's core action effectively. There is minimal noise, and the summary offers a clear understanding of the function's operation, making it a valuable resource for engineers."
            ]
        }
    }
}
{
    "source_code": "int\nrl_insert_text (const char *string)\n{\n  register int i, l;\n\n  l = (string && *string) ? strlen (string) : 0;\n  if (l == 0)\n    return 0;\n\n  if (rl_end + l >= rl_line_buffer_len)\n    rl_extend_line_buffer (rl_end + l);\n\n  for (i = rl_end; i >= rl_point; i--)\n    rl_line_buffer[i + l] = rl_line_buffer[i];\n\n  strncpy (rl_line_buffer + rl_point, string, l);\n\n  /* Remember how to undo this if we aren't undoing something. */\n  if (_rl_doing_an_undo == 0)\n    {\n      /* If possible and desirable, concatenate the undos. */\n      if ((l == 1) &&\n\t  rl_undo_list &&\n\t  (rl_undo_list->what == UNDO_INSERT) &&\n\t  (rl_undo_list->end == rl_point) &&\n\t  (rl_undo_list->end - rl_undo_list->start < 20))\n\trl_undo_list->end++;\n      else\n\trl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);\n    }\n  rl_point += l;\n  rl_end += l;\n  rl_line_buffer[rl_end] = '\\0';\n  return l;\n}",
    "strip_decompiled_code": "__int64 __fastcall rl_insert_text(char *src)\n{\n  unsigned int v1; // r13d\n  unsigned int v3; // eax\n  unsigned int v4; // r12d\n  int v5; // ecx\n  __int64 v6; // rdi\n  __int64 v7; // rdi\n  __int64 v8; // rdx\n  char v9; // si\n  _BYTE *v10; // rax\n  int v11; // eax\n\n  v1 = 0;\n  if ( src )\n  {\n    if ( *src )\n    {\n      v3 = strlen(src);\n      v4 = v3;\n      v1 = v3;\n      if ( v3 )\n      {\n        v5 = rl_end[0];\n        v6 = rl_end[0] + v3;\n        if ( (int)v6 >= rl_line_buffer_len )\n        {\n          rl_extend_line_buffer(v6);\n          v5 = rl_end[0];\n        }\n        v7 = rl_point[0];\n        if ( rl_point[0] <= v5 )\n        {\n          v8 = v5;\n          do\n          {\n            --v5;\n            v9 = rl_line_buffer[v8];\n            v10 = &rl_line_buffer[v8--];\n            v10[v1] = v9;\n            v7 = rl_point[0];\n          }\n          while ( v5 >= rl_point[0] );\n        }\n        strncpy(&rl_line_buffer[v7], src, (int)v4);\n        if ( !rl_doing_an_undo )\n        {\n          if ( v4 == 1 )\n          {\n            if ( rl_undo_list )\n            {\n              if ( rl_undo_list[6] == 1 )\n              {\n                v11 = rl_undo_list[3];\n                if ( v11 == rl_point[0] && v11 - rl_undo_list[2] <= 19 )\n                {\n                  rl_undo_list[3] = v11 + 1;\nLABEL_18:\n                  rl_point[0] = v4 + v11;\n                  rl_end[0] += v4;\n                  rl_line_buffer[rl_end[0]] = 0;\n                  return v1;\n                }\n              }\n            }\n          }\n          rl_add_undo(1LL, rl_point[0], rl_point[0] + v4, 0LL);\n        }\n        v11 = rl_point[0];\n        goto LABEL_18;\n      }\n    }\n  }\n  return v1;\n}\n",
    "probed_sources": [
        "<s><asm_token>\n[\n'    if (ret == 0) {\\n      ret = strlen (buf);\\n      if (ret > 0 && buf[ret - 1] == '\\n",
        "<s><asm_token>\n\"static int\\nfind_line_number (char *line)\\n{\\n  int i;\\n  char *p;\\n\\n  if (line == 0)\\n   ",
        "<s><asm_token>\n'int\\n_rl_read_init_file (const char *filename)\\n{\\n  int i;\\n  FILE *fp;\\n  char *line;\\n  int len",
        "<s><asm_token>\nsnippet = '''\n#ifdef HAVE_WCHAR_H\n  if (HANDLE_MULTIBYTE && mb_cur_max > 1)",
        "<s><asm_token>\nt = '\\n    for (i = 0; i < len; i++) {\\n      if (i > 0 && str[i] == \\'\\\\n\\') {\\n"
    ],
    "prorec_sum": "Inserts the given text into the readline buffer at the cursor position, shifting existing text, updating cursor/end indexes, and managing undo information.",
    "extracted_features": [
        "strlen",
        "strncpy",
        "rl_extend_line_buffer",
        "rl_add_undo",
        "rl_line_buffer",
        "rl_point",
        "rl_end",
        "rl_undo_list",
        "rl_doing_an_undo"
    ],
    "filter_strong": [],
    "filter_backup": [],
    "filter_uncertain": [],
    "filter_junk": [
        "[\n'    if (ret == 0) {\\n      ret = strlen (buf);\\n      if (ret > 0 && buf[ret - 1] == '\\n",
        "\"static int\\nfind_line_number (char *line)\\n{\\n  int i;\\n  char *p;\\n\\n  if (line == 0)\\n   ",
        "'int\\n_rl_read_init_file (const char *filename)\\n{\\n  int i;\\n  FILE *fp;\\n  char *line;\\n  int len",
        "snippet = '''\n#ifdef HAVE_WCHAR_H\n  if (HANDLE_MULTIBYTE && mb_cur_max > 1)",
        "t = '\\n    for (i = 0; i < len; i++) {\\n      if (i > 0 && str[i] == \\'\\\\n\\') {\\n"
    ],
    "debug_log": [
        "Idx 0: Uncertain (GT has features but Candidate unrelated)",
        "Idx 1: Uncertain (GT has features but Candidate unrelated)",
        "Idx 2: Uncertain (GT has features but Candidate unrelated)",
        "Idx 3: Uncertain (GT has features but Candidate unrelated)",
        "Idx 4: Uncertain (GT has features but Candidate unrelated)"
    ],
    "filter_prorec_sum": "Inserts the given text into the readline buffer at the cursor position, shifting existing content and recording undo information if enabled.",
    "work_score": {
        "prorec": {
            "summary": "Inserts the given text into the readline buffer at the cursor position, shifting existing text, updating cursor/end indexes, and managing undo information.",
            "score": [
                0.9381164168349905,
                0.8467755658527938,
                0.8915353393638871
            ],
            "reason": [
                "The summary accurately describes the function's behavior: inserting text into the readline buffer at the cursor position, shifting existing text, updating cursor/end indexes, and managing undo information. These claims align well with the source code, which includes logic for extending the buffer, shifting text, updating indexes, and handling undo operations. The summary captures the core functionality and semantics of the function, with over 80% of claims being accurate.",
                "The summary accurately covers the core primary purpose of the function, which is to insert text into the readline buffer at the cursor position. It also mentions key secondary behaviors such as shifting existing text, updating cursor and end indexes, and managing undo information, which are critical aspects of the function's operation. The summary is near-complete, capturing most key points including side effects and external interactions.",
                "The summary accurately describes the function's primary purpose of inserting text into the readline buffer at the cursor position, shifting existing text, updating cursor and end indexes, and managing undo information. These claims are specific and verifiable against the source code, providing high gain by clearly outlining the function's behavior and effects. There is negligible noise, as all claims are relevant and correct."
            ]
        },
        "filter_prorec": {
            "summary": "Inserts the given text into the readline buffer at the cursor position, shifting existing content and recording undo information if enabled.",
            "score": [
                0.9023677186172548,
                0.8202278220427729,
                0.8872086712551865
            ],
            "reason": [
                "The summary accurately describes the function's behavior: inserting text into the readline buffer at the cursor position, shifting existing content, and recording undo information if enabled. These claims align well with the source code, which performs these operations, including handling the undo functionality and adjusting the buffer. The summary captures the core functionality without introducing inaccuracies.",
                "The summary accurately covers the core purpose of the function, which is inserting text into the readline buffer at the cursor position. It mentions shifting existing content and recording undo information, which aligns with the source code's operations of adjusting the buffer and handling undo functionality. However, it lacks details on edge cases like buffer extension and specific conditions for undo concatenation.",
                "The summary accurately describes the primary purpose of the function, which is to insert text into the readline buffer at the cursor position, shift existing content, and record undo information. These claims are specific and verifiable against the source code, providing high gain with minimal noise. There are no inaccuracies or noise overwhelming the accurate claims, resulting in a high net benefit."
            ]
        }
    }
}
