{
    "source_code": "\nstatic void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
    "comment": "Allocates or reallocates memory for an array based on its current size, growth constraints, and item size, ensuring safe memory usage.",
    "prorec_sum": "Adjusts a buffer size by growing it with overflow checks, caps it to limits, and reallocates memory if insufficient for requested additional elements.",
    "filter_prorec_sum": "Resizes an allocated buffer by growing its size within specified limits, ensuring safe multiplication and invoking allocation routines when expansion is required.",
    "work_score": {
        "prorec": {
            "summary": "Adjusts a buffer size by growing it with overflow checks, caps it to limits, and reallocates memory if insufficient for requested additional elements.",
            "score": [
                0.9044436760575044,
                0.8803768446992304,
                0.9526345384077255
            ]
        },
        "filter_prorec": {
            "summary": "Resizes an allocated buffer by growing its size within specified limits, ensuring safe multiplication and invoking allocation routines when expansion is required.",
            "score": [
                0.8460056399076794,
                0.588380083303903,
                0.8198270585660522
            ]
        }
    }
}
{
    "source_code": "\nint\nmu_get_host_name (char **host)\n{\n  char *hostname = NULL;\n  size_t size = 0;\n  char *p;\n\n  while (1)\n    {\n      if (size == 0)\n\t{\n\t  size = MAXHOSTNAMELEN;\n\t  p = malloc (size);\n\t}\n      else\n\t{\n\t  size_t ns = size * 2;\n\t  if (ns < size)\n\t    {\n\t      free (hostname);\n\t      return ENOMEM;\n\t    }\n\t  size = ns;\n\t  p = realloc (hostname, size);\n\t}\n      if (!p)\n\t{\n\t  free (hostname);\n\t  return ENOMEM;\n\t}\n      hostname = p;\n      hostname[size - 1] = 0;\n      if (gethostname (hostname, size - 1) == 0)\n\t{\n\t  if (!hostname[size - 1])\n\t    break;\n\t}\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n\t       && errno != ENOMEM)\n\t{\n\t  int rc = errno;\n\t  free (hostname);\n\t  return rc;\n\t}\n    }\n\n  /* Try to return fully qualified host name */\n  if (!strchr (hostname, '.'))\n    {\n      struct hostent *hp = gethostbyname (hostname);\n      if (hp)\n\t{\n\t  size_t len = strlen (hp->h_name);\n\t  if (size < len + 1)\n\t    {\n\t      p = realloc (hostname, len + 1);\n\t      if (!p)\n\t\t{\n\t\t  free (hostname);\n\t\t  return ENOMEM;\n\t\t}\n\t      hostname = p;\n\t    }\n\t  strcpy (hostname, hp->h_name);\n\t}\n    }\n  \n  *host = hostname;\n  return 0;\n}",
    "comment": "Retrieves the host name of the machine, expanding the buffer as needed, and attempts to return the fully qualified host name if not present.",
    "prorec_sum": "Retrieves the system\u2019s host name, dynamically resizing the buffer if needed, and resolves it to a fully qualified domain name when missing.",
    "filter_prorec_sum": "Allocates and resizes a buffer to retrieve the system\u2019s hostname, resolving to a fully qualified domain name if only a short name is returned.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves the system\u2019s host name, dynamically resizing the buffer if needed, and resolves it to a fully qualified domain name when missing.",
            "score": [
                0.9601766539714165,
                0.9231264243584032,
                0.9924227722029582
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and resizes a buffer to retrieve the system\u2019s hostname, resolving to a fully qualified domain name if only a short name is returned.",
            "score": [
                0.9660945015709779,
                0.8983119608267117,
                0.9917229154182688
            ]
        }
    }
}
{
    "source_code": "static int do_sysinfo(struct sysinfo *info)\n{\n\tunsigned long mem_total, sav_total;\n\tunsigned int mem_unit, bitcount;\n\tstruct timespec tp;\n\n\tmemset(info, 0, sizeof(struct sysinfo));\n\n\tktime_get_ts(&tp);\n\tmonotonic_to_bootbased(&tp);\n\tinfo->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);\n\n\tget_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);\n\n\tinfo->procs = nr_threads;\n\n\tsi_meminfo(info);\n\tsi_swapinfo(info);\n\n\t/*\n\t * If the sum of all the available memory (i.e. ram + swap)\n\t * is less than can be stored in a 32 bit unsigned long then\n\t * we can be binary compatible with 2.2.x kernels.  If not,\n\t * well, in that case 2.2.x was broken anyways...\n\t *\n\t *  -Erik Andersen <andersee@debian.org>\n\t */\n\n\tmem_total = info->totalram + info->totalswap;\n\tif (mem_total < info->totalram || mem_total < info->totalswap)\n\t\tgoto out;\n\tbitcount = 0;\n\tmem_unit = info->mem_unit;\n\twhile (mem_unit > 1) {\n\t\tbitcount++;\n\t\tmem_unit >>= 1;\n\t\tsav_total = mem_total;\n\t\tmem_total <<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If mem_total did not overflow, multiply all memory values by\n\t * info->mem_unit and set it to 1.  This leaves things compatible\n\t * with 2.2.x, and also retains compatibility with earlier 2.4.x\n\t * kernels...\n\t */\n\n\tinfo->mem_unit = 1;\n\tinfo->totalram <<= bitcount;\n\tinfo->freeram <<= bitcount;\n\tinfo->sharedram <<= bitcount;\n\tinfo->bufferram <<= bitcount;\n\tinfo->totalswap <<= bitcount;\n\tinfo->freeswap <<= bitcount;\n\tinfo->totalhigh <<= bitcount;\n\tinfo->freehigh <<= bitcount;\n\nout:\n\treturn 0;\n}",
    "comment": "Populates the `sysinfo` structure with system uptime, load averages, process count, and adjusted memory and swap information, ensuring compatibility with older kernels.",
    "prorec_sum": "Initializes a 0x70-byte structure, invokes multiple setup routines, and conditionally left-shifts several 64-bit fields based on computed size thresholds.",
    "filter_prorec_sum": "Initializes a 0x70-byte structure, invokes several setup routines, and scales multiple numeric fields based on calculated size and shift factor.",
    "work_score": {
        "prorec": {
            "summary": "Initializes a 0x70-byte structure, invokes multiple setup routines, and conditionally left-shifts several 64-bit fields based on computed size thresholds.",
            "score": [
                0.1854133476412211,
                0.34242391863407223,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Initializes a 0x70-byte structure, invokes several setup routines, and scales multiple numeric fields based on calculated size and shift factor.",
            "score": [
                0.2652141124267079,
                0.4133309362653351,
                0.0
            ]
        }
    }
}
{
    "source_code": "int drm_markbufs(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tstruct drm_buf_desc *request = data;\n\tint order;\n\tstruct drm_buf_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\treturn -EINVAL;\n\n\tif (!dma)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"%d, %d, %d\\n\",\n\t\t  request->size, request->low_mark, request->high_mark);\n\torder = drm_order(request->size);\n\tif (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)\n\t\treturn -EINVAL;\n\tentry = &dma->bufs[order];\n\n\tif (request->low_mark < 0 || request->low_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\tif (request->high_mark < 0 || request->high_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\n\tentry->freelist.low_mark = request->low_mark;\n\tentry->freelist.high_mark = request->high_mark;\n\n\treturn 0;\n}",
    "comment": "Configures buffer management parameters, including size and free list thresholds, for a Direct Rendering Manager (DRM) device's DMA buffers.",
    "prorec_sum": "Validates DRM buffer parameters and updates selected buffer indices if they meet alignment, range, and capacity constraints, otherwise returning an error code.",
    "filter_prorec_sum": "Validates DRM buffer parameters and updates two entries in a buffer descriptor within a device structure if all checks pass.",
    "work_score": {
        "prorec": {
            "summary": "Validates DRM buffer parameters and updates selected buffer indices if they meet alignment, range, and capacity constraints, otherwise returning an error code.",
            "score": [
                0.7950951780102973,
                0.8793083343636349,
                0.9271314088912612
            ]
        },
        "filter_prorec": {
            "summary": "Validates DRM buffer parameters and updates two entries in a buffer descriptor within a device structure if all checks pass.",
            "score": [
                0.7175886229564122,
                0.7639746070806186,
                0.8674742397226402
            ]
        }
    }
}
{
    "source_code": "\nstatic const char* findlocal(lua_State* L, CallInfo* ci, int n, StkId* pos) {\n  const char* name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0) /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  } else\n    base = ci->func + 1;\n  if (name == NULL) { /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\"; /* generic name for any valid slot */\n    else\n      return NULL; /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}",
    "comment": "Retrieves the local variable name from a Lua function's call frame or returns a generic name for temporary slots if no name exists.",
    "prorec_sum": "Retrieves a specific argument or temporary value from parser state and returns its name while updating the provided pointer to its location.",
    "filter_prorec_sum": "Retrieves a specific argument\u2019s stack address and returns a label string for vararg or temporary variables based on index and context.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves a specific argument or temporary value from parser state and returns its name while updating the provided pointer to its location.",
            "score": [
                0.5365211802282934,
                0.6183293402612507,
                0.0819635058215509
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves a specific argument\u2019s stack address and returns a label string for vararg or temporary variables based on index and context.",
            "score": [
                0.6185135455567812,
                0.5882529310708688,
                0.11838289701736453
            ]
        }
    }
}
{
    "source_code": "  \nvoid\nmu_ident_stat (mu_stream_t str)\n{\n  size_t count, i;\n  mu_iterator_t itr;\n  \n  mu_stream_printf (str, \"BEGIN IDENT STAT\\n\");\n\n  mu_assoc_count (nametab, &count);\n  mu_stream_printf (str, \"N=%zu\\n\", count);\n\n  if (count > 0)\n    {\n      int rc = mu_assoc_get_iterator (nametab, &itr);\n      if (rc)\n\tmu_stream_printf (str, \"mu_assoc_get_iterator: %s\\n\",\n\t\t\t  mu_strerror (rc));\n      else\n\t{\n\t  i = 0;\n\t  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);\n\t       mu_iterator_next (itr), i++)\n\t    {\n\t      const char *key;\n\t      struct mu_ident_ref *ref;\n\t      \n\t      mu_iterator_current_kv (itr,\n\t\t\t\t      (const void **)&key, (void **)&ref);  \n\t      mu_stream_printf (str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n\t    }\n\t}\n      mu_iterator_destroy (&itr);\n    }\n  mu_stream_printf (str, \"END IDENT STAT\\n\");\n}",
    "comment": "Outputs the count and details of identifiers from a name table to a specified stream, including key-value pairs and their associated counts.",
    "prorec_sum": "Outputs a formatted statistical report of all key\u2013value pairs in the global `qword_2DFC80` association to the provided stream.",
    "filter_prorec_sum": "Outputs statistics from the global identifier association, including total count and each key-value pair, to the specified stream.",
    "work_score": {
        "prorec": {
            "summary": "Outputs a formatted statistical report of all key\u2013value pairs in the global `qword_2DFC80` association to the provided stream.",
            "score": [
                0.010422728379810803,
                0.0067871925721861345,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Outputs statistics from the global identifier association, including total count and each key-value pair, to the specified stream.",
            "score": [
                0.9414364909303583,
                0.860975448535562,
                0.9812689589125736
            ]
        }
    }
}
{
    "source_code": "\nstatic int\nnfs3_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs3_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct nfs3_linkres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tres.fattr = nfs_alloc_fattr();\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.fattr == NULL || res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_post_op_update_inode(inode, res.fattr);\nout:\n\tnfs_free_fattr(res.dir_attr);\n\tnfs_free_fattr(res.fattr);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}",
    "comment": "Links a source inode to a target directory inode with a specified name using an NFS procedure and updates their attributes.",
    "prorec_sum": "Generates two data structures from input parameters, processes them through helper functions, and returns a status code indicating resource or operation result.",
    "filter_prorec_sum": "Allocates and initializes two data structures from input parameters, processes them via helper routines, and returns a status code indicating success or resource error.",
    "work_score": {
        "prorec": {
            "summary": "Generates two data structures from input parameters, processes them through helper functions, and returns a status code indicating resource or operation result.",
            "score": [
                0.5040991934204351,
                0.5740892955625058,
                0.3259072980513816
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes two data structures from input parameters, processes them via helper routines, and returns a status code indicating success or resource error.",
            "score": [
                0.6218917637296897,
                0.6982245795803972,
                0.714953247580525
            ]
        }
    }
}
{
    "source_code": "static void tsc_refine_calibration_work(struct work_struct *work)\n{\n\tstatic u64 tsc_start = -1, ref_start;\n\tstatic int hpet;\n\tu64 tsc_stop, ref_stop, delta;\n\tunsigned long freq;\n\n\t/* Don't bother refining TSC on unstable systems */\n\tif (check_tsc_unstable())\n\t\tgoto out;\n\n\t/*\n\t * Since the work is started early in boot, we may be\n\t * delayed the first time we expire. So set the workqueue\n\t * again once we know timers are working.\n\t */\n\tif (tsc_start == -1) {\n\t\t/*\n\t\t * Only set hpet once, to avoid mixing hardware\n\t\t * if the hpet becomes enabled later.\n\t\t */\n\t\thpet = is_hpet_enabled();\n\t\tschedule_delayed_work(&tsc_irqwork, HZ);\n\t\ttsc_start = tsc_read_refs(&ref_start, hpet);\n\t\treturn;\n\t}\n\n\ttsc_stop = tsc_read_refs(&ref_stop, hpet);\n\n\t/* hpet or pmtimer available ? */\n\tif (ref_start == ref_stop)\n\t\tgoto out;\n\n\t/* Check, whether the sampling was disturbed by an SMI */\n\tif (tsc_start == ULLONG_MAX || tsc_stop == ULLONG_MAX)\n\t\tgoto out;\n\n\tdelta = tsc_stop - tsc_start;\n\tdelta *= 1000000LL;\n\tif (hpet)\n\t\tfreq = calc_hpet_ref(delta, ref_start, ref_stop);\n\telse\n\t\tfreq = calc_pmtimer_ref(delta, ref_start, ref_stop);\n\n\t/* Make sure we're within 1% */\n\tif (abs(tsc_khz - freq) > tsc_khz/100)\n\t\tgoto out;\n\n\ttsc_khz = freq;\n\tpr_info(\"Refined TSC clocksource calibration: %lu.%03lu MHz\\n\",\n\t\t(unsigned long)tsc_khz / 1000,\n\t\t(unsigned long)tsc_khz % 1000);\n\nout:\n\tclocksource_register_khz(&clocksource_tsc, tsc_khz);\n}",
    "comment": "Refines TSC clocksource calibration by measuring timer frequencies and adjusting the TSC frequency if within 1% accuracy after initial readings.",
    "prorec_sum": "Calculates CPU clock frequency or timing interval using hardware counters, updating stored values and invoking callbacks when deviations exceed a defined threshold.",
    "filter_prorec_sum": "Calculates elapsed time between successive clock readings to update and return the current scheduler clock value in microseconds.",
    "work_score": {
        "prorec": {
            "summary": "Calculates CPU clock frequency or timing interval using hardware counters, updating stored values and invoking callbacks when deviations exceed a defined threshold.",
            "score": [
                0.26622830543713,
                0.21971443584930989,
                0.006032482752515417
            ]
        },
        "filter_prorec": {
            "summary": "Calculates elapsed time between successive clock readings to update and return the current scheduler clock value in microseconds.",
            "score": [
                0.05189008570582243,
                0.042478962581732095,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n Fixup:\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}",
    "comment": "Handles the power-off process for PCI devices, utilizing legacy support or device-specific power management operations, and fixes up device state afterward.",
    "prorec_sum": "Manages PCI device power-off by checking conditions, invoking callbacks, and performing fallback shutdown procedures when necessary.",
    "filter_prorec_sum": "Handles PCI device power management by checking conditions, invoking callbacks, and powering off the device when required.",
    "work_score": {
        "prorec": {
            "summary": "Manages PCI device power-off by checking conditions, invoking callbacks, and performing fallback shutdown procedures when necessary.",
            "score": [
                0.7748138218909905,
                0.8646941692145802,
                0.8728679290533476
            ]
        },
        "filter_prorec": {
            "summary": "Handles PCI device power management by checking conditions, invoking callbacks, and powering off the device when required.",
            "score": [
                0.5594661100729722,
                0.5095450322143413,
                0.6705780843560061
            ]
        }
    }
}
{
    "source_code": "static void drm_cleanup_buf_error(struct drm_device * dev,\n\t\t\t\t  struct drm_buf_entry * entry)\n{\n\tint i;\n\n\tif (entry->seg_count) {\n\t\tfor (i = 0; i < entry->seg_count; i++) {\n\t\t\tif (entry->seglist[i]) {\n\t\t\t\tdrm_pci_free(dev, entry->seglist[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(entry->seglist);\n\n\t\tentry->seg_count = 0;\n\t}\n\n\tif (entry->buf_count) {\n\t\tfor (i = 0; i < entry->buf_count; i++) {\n\t\t\tkfree(entry->buflist[i].dev_private);\n\t\t}\n\t\tkfree(entry->buflist);\n\n\t\tentry->buf_count = 0;\n\t}\n}",
    "comment": "Cleans up allocated buffer memory and frees associated resources in a DRM device's buffer entry structure.",
    "prorec_sum": "Processes and clears two indexed lists of associated objects, invoking a provided handler function on each element with given parameters.",
    "filter_prorec_sum": "Processes and clears indexed entries from two lists within a structure, invoking a helper to handle each entry with provided parameters.",
    "work_score": {
        "prorec": {
            "summary": "Processes and clears two indexed lists of associated objects, invoking a provided handler function on each element with given parameters.",
            "score": [
                0.1853380731069205,
                0.17941473915342596,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Processes and clears indexed entries from two lists within a structure, invoking a helper to handle each entry with provided parameters.",
            "score": [
                0.5462432683086611,
                0.4800668506242312,
                0.018617702521082368
            ]
        }
    }
}
{
    "source_code": "int Xorriso_register_node_target(struct XorrisO *xorriso, int node_idx,\n                                 char *disk_path, int flag)\n{\n int l;\n\n if(xorriso->node_targets_availmem == 0)\n   return(2);\n if(xorriso->hln_targets == NULL || node_idx < 0 ||\n    node_idx >= xorriso->hln_count)\n   return(0);\n if(xorriso->hln_targets[node_idx] != NULL) {\n   xorriso->node_targets_availmem+= strlen(xorriso->hln_targets[node_idx]) +1;\n   free(xorriso->hln_targets[node_idx]);\n }\n l= strlen(disk_path);\n if(xorriso->node_targets_availmem <= l + 1) {\n   sprintf(xorriso->info_text,\n \"Hardlink target buffer exceeds -temp_mem_limit. Hardlinks may get divided.\");\n   Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, \"FAILURE\", 0);\n   xorriso->node_targets_availmem= 0;\n   return(0);\n }\n xorriso->hln_targets[node_idx]= strdup(disk_path);\n if(xorriso->hln_targets[node_idx] == NULL) {\n   Xorriso_no_malloc_memory(xorriso, NULL, 0);\n   return(-1);\n }\n xorriso->node_targets_availmem-= (l + 1);\n return(1);\n}",
    "comment": "Registers a hardlink target for a specified node index in the Xorriso structure, managing memory and error handling accordingly.",
    "prorec_sum": "Updates a specified string entry in a stored array, adjusting available space and reporting failure if the new string exceeds the remaining capacity.",
    "filter_prorec_sum": "Updates a specified path component string in an ISO9660 file structure, enforcing remaining length limits and reporting errors when capacity is exceeded.",
    "work_score": {
        "prorec": {
            "summary": "Updates a specified string entry in a stored array, adjusting available space and reporting failure if the new string exceeds the remaining capacity.",
            "score": [
                0.8873695741896481,
                0.8668212034493259,
                0.8519063283266842
            ]
        },
        "filter_prorec": {
            "summary": "Updates a specified path component string in an ISO9660 file structure, enforcing remaining length limits and reporting errors when capacity is exceeded.",
            "score": [
                0.32880479338448687,
                0.23285717519268795,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstatic const char *\nget_symbol_index_type (Filedata * filedata, unsigned int type)\n{\n  static char buff[32];\n\n  switch (type)\n    {\n    case SHN_UNDEF:\treturn \"UND\";\n    case SHN_ABS:\treturn \"ABS\";\n    case SHN_COMMON:\treturn \"COM\";\n    default:\n      if (type == SHN_IA_64_ANSI_COMMON\n\t  && filedata->file_header.e_machine == EM_IA_64\n\t  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)\n\treturn \"ANSI_COM\";\n      else if ((filedata->file_header.e_machine == EM_X86_64\n\t\t|| filedata->file_header.e_machine == EM_L1OM\n\t\t|| filedata->file_header.e_machine == EM_K1OM)\n\t       && type == SHN_X86_64_LCOMMON)\n\treturn \"LARGE_COM\";\n      else if ((type == SHN_MIPS_SCOMMON\n\t\t&& filedata->file_header.e_machine == EM_MIPS)\n\t       || (type == SHN_TIC6X_SCOMMON\n\t\t   && filedata->file_header.e_machine == EM_TI_C6000))\n\treturn \"SCOM\";\n      else if (type == SHN_MIPS_SUNDEFINED\n\t       && filedata->file_header.e_machine == EM_MIPS)\n\treturn \"SUND\";\n      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)\n\tsprintf (buff, \"PRC[0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LOOS && type <= SHN_HIOS)\n\tsprintf (buff, \"OS [0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LORESERVE)\n\tsprintf (buff, \"RSV[0x%04x]\", type & 0xffff);\n      else if (type >= filedata->file_header.e_shnum)\n\tsprintf (buff, _(\"bad section index[%3d]\"), type);\n      else\n\tsprintf (buff, \"%3d\", type);\n      break;\n    }\n\n  return buff;\n}",
    "comment": "Returns a string representation of a symbol index type based on the provided type and file header information.",
    "prorec_sum": "Maps specific numeric codes and header field values to corresponding section type strings or formatted identifiers for output.",
    "filter_prorec_sum": "Maps specific numeric codes and header attributes to predefined section type strings or formatted identifiers for display or diagnostic output.",
    "work_score": {
        "prorec": {
            "summary": "Maps specific numeric codes and header field values to corresponding section type strings or formatted identifiers for output.",
            "score": [
                0.8372175933156323,
                0.8398480180859347,
                0.6730753685107458
            ]
        },
        "filter_prorec": {
            "summary": "Maps specific numeric codes and header attributes to predefined section type strings or formatted identifiers for display or diagnostic output.",
            "score": [
                0.8618828176878164,
                0.7831180104943669,
                0.7705170634833916
            ]
        }
    }
}
{
    "source_code": "\nvoid *\nFcompile (char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  kwset_t kwset;\n  char *buf = NULL;\n  idx_t bufalloc = 0;\n\n  kwset = kwsinit (true);\n\n  char const *p = pattern;\n  do\n    {\n      char const *sep = rawmemchr (p, '\\n');\n      idx_t len = sep - p;\n\n      if (match_lines)\n        {\n          if (eolbyte == '\\n' && pattern < p)\n            p--;\n          else\n            {\n              if (bufalloc < len + 2)\n                {\n                  free (buf);\n                  bufalloc = len;\n                  buf = xpalloc (NULL, &bufalloc, 2, -1, 1);\n                  buf[0] = eolbyte;\n                }\n              memcpy (buf + 1, p, len);\n              buf[len + 1] = eolbyte;\n              p = buf;\n            }\n          len += 2;\n        }\n      kwsincr (kwset, p, len);\n\n      p = sep + 1;\n    }\n  while (p <= pattern + size);\n\n  free (buf);\n\n  idx_t words = kwswords (kwset);\n  kwsprep (kwset);\n\n  struct kwsearch *kwsearch = xmalloc (sizeof *kwsearch);\n  kwsearch->kwset = kwset;\n  kwsearch->words = words;\n  kwsearch->pattern = pattern;\n  kwsearch->size = size;\n  kwsearch->re = NULL;\n  return kwsearch;\n}",
    "comment": "Processes a pattern string, initializes a keyword set, and returns a structure containing the keyword set and its associated properties.",
    "prorec_sum": "Processes newline-delimited data from the source obstack, conditionally modifies line endings, stores chunks into a new obstack, and returns related context pointers.",
    "filter_prorec_sum": "Processes a memory range line-by-line, conditionally modifies line endings, accumulates data into an obstack, and returns a struct bundling the results.",
    "work_score": {
        "prorec": {
            "summary": "Processes newline-delimited data from the source obstack, conditionally modifies line endings, stores chunks into a new obstack, and returns related context pointers.",
            "score": [
                0.11388003496272839,
                0.11287123635379404,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Processes a memory range line-by-line, conditionally modifies line endings, accumulates data into an obstack, and returns a struct bundling the results.",
            "score": [
                0.2199022808419305,
                0.24820887433146588,
                0.0
            ]
        }
    }
}
{
    "source_code": "bool pm_wakeup_pending(void)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&events_lock, flags);\n\tif (events_check_enabled) {\n\t\tunsigned int cnt, inpr;\n\n\t\tsplit_counters(&cnt, &inpr);\n\t\tret = (cnt != saved_count || inpr > 0);\n\t\tevents_check_enabled = !ret;\n\t}\n\tspin_unlock_irqrestore(&events_lock, flags);\n\n\tif (ret)\n\t\tprint_active_wakeup_sources();\n\n\treturn ret;\n}",
    "comment": "Checks if a wakeup event is pending by comparing counters and prints active wakeup sources if there is a pending event.",
    "prorec_sum": "Checks a shared state flag, updates it, and conditionally triggers a handler for the first or highest-priority entry in a linked device list.",
    "filter_prorec_sum": "Checks a global flag and condition, then iterates a device list to trigger actions on flagged entries or the most recent unflagged device.",
    "work_score": {
        "prorec": {
            "summary": "Checks a shared state flag, updates it, and conditionally triggers a handler for the first or highest-priority entry in a linked device list.",
            "score": [
                0.0572824452049651,
                0.04986161403903086,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Checks a global flag and condition, then iterates a device list to trigger actions on flagged entries or the most recent unflagged device.",
            "score": [
                0.0104234411261739,
                0.01277442939719019,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstruct local_symbol *\nlocal_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n{\n  const char *name_copy;\n  struct local_symbol *ret;\n\n  ++local_symbol_count;\n\n  name_copy = save_symbol_name (name);\n\n  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n  ret->lsy_flags.sy_local_symbol = 1;\n  ret->lsy_flags.sy_resolved = 0;\n  ret->lsy_name = name_copy;\n  ret->lsy_section = section;\n  local_symbol_set_frag (ret, frag);\n  ret->lsy_value = val;\n\n  hash_jam (local_hash, name_copy, (void *) ret);\n\n  return ret;\n}",
    "comment": "Creates and initializes a local symbol structure, copying its name, setting properties, and storing it in a hash table.",
    "prorec_sum": "Allocates space in an obstack for a new object, stores provided parameters, updates bookkeeping fields, and registers the object via a callback.",
    "filter_prorec_sum": "Allocates space in a global obstack and stores provided parameters into a structured object before invoking a callback with the new object.",
    "work_score": {
        "prorec": {
            "summary": "Allocates space in an obstack for a new object, stores provided parameters, updates bookkeeping fields, and registers the object via a callback.",
            "score": [
                0.725676387036122,
                0.883686419906,
                0.8341541832868288
            ]
        },
        "filter_prorec": {
            "summary": "Allocates space in a global obstack and stores provided parameters into a structured object before invoking a callback with the new object.",
            "score": [
                0.5895461593317954,
                0.5590436262612226,
                0.2771744327438183
            ]
        }
    }
}
{
    "source_code": "\nstatic void\ngss_pipe_release(struct inode *inode)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tstruct gss_upcall_msg *gss_msg;\n\nrestart:\n\tspin_lock(&pipe->lock);\n\tlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\n\n\t\tif (!list_empty(&gss_msg->msg.list))\n\t\t\tcontinue;\n\t\tgss_msg->msg.errno = -EPIPE;\n\t\tatomic_inc(&gss_msg->count);\n\t\t__gss_unhash_msg(gss_msg);\n\t\tspin_unlock(&pipe->lock);\n\t\tgss_release_msg(gss_msg);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&pipe->lock);\n\n\tput_pipe_version(net);\n}",
    "comment": "Releases GSS upcall messages in a pipe by unhashing and incrementing the error count for empty message lists before freeing resources.",
    "prorec_sum": "Iterates through and updates linked entries, applies provided callback with numeric parameters, increments counters, then finalizes processing via a secondary handler.",
    "filter_prorec_sum": "Iterates through and updates linked queue entries with provided parameters, invoking two processing callbacks before finalizing with a completion routine.",
    "work_score": {
        "prorec": {
            "summary": "Iterates through and updates linked entries, applies provided callback with numeric parameters, increments counters, then finalizes processing via a secondary handler.",
            "score": [
                0.2127479798719465,
                0.19289566711696587,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Iterates through and updates linked queue entries with provided parameters, invoking two processing callbacks before finalizing with a completion routine.",
            "score": [
                0.12321417659482461,
                0.09271501813318936,
                0.0
            ]
        }
    }
}
{
    "source_code": "void FAST_FUNC add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name)\n{\n\tint i;\n\tino_dev_hashtable_bucket_t *bucket;\n\n\tif (!name)\n\t\tname = \"\";\n\tbucket = xmalloc(sizeof(ino_dev_hashtable_bucket_t) + strlen(name));\n\tbucket->ino = statbuf->st_ino;\n\tbucket->dev = statbuf->st_dev;\n\tbucket->isdir = !!S_ISDIR(statbuf->st_mode);\n\tstrcpy(bucket->name, name);\n\n\tif (!ino_dev_hashtable)\n\t\tino_dev_hashtable = xzalloc(HASH_SIZE * sizeof(*ino_dev_hashtable));\n\n\ti = hash_inode(statbuf->st_ino);\n\tbucket->next = ino_dev_hashtable[i];\n\tino_dev_hashtable[i] = bucket;\n}",
    "comment": "Adds a new entry to the inode-device hashtable using the provided stat structure and name, allocating memory for the bucket dynamically.",
    "prorec_sum": "Creates a new entry for a given file path, sets metadata, and links it into a hash table based on its identifier.",
    "filter_prorec_sum": "Adds a new entry structure to a hash bucket and links it into an existing list, initializing fields from the given parameters.",
    "work_score": {
        "prorec": {
            "summary": "Creates a new entry for a given file path, sets metadata, and links it into a hash table based on its identifier.",
            "score": [
                0.5532839228659695,
                0.6302276677159042,
                0.30457881929418695
            ]
        },
        "filter_prorec": {
            "summary": "Adds a new entry structure to a hash bucket and links it into an existing list, initializing fields from the given parameters.",
            "score": [
                0.9139745139023662,
                0.8810106643101632,
                0.8739540282763457
            ]
        }
    }
}
{
    "source_code": "int loadkmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct kbentry ke;\n\tint i, j, fd;\n\tuint16_t ibuff[NR_KEYS];\n/*\tconst char *tty_name = CURRENT_TTY; */\n\tRESERVE_CONFIG_BUFFER(flags, MAX_NR_KEYMAPS);\n\n\t/* When user accidentally runs \"loadkmap FILE\"\n\t * instead of \"loadkmap <FILE\", we end up waiting for input from tty.\n\t * Let's prevent it: */\n\tif (argv[1])\n\t\tbb_show_usage();\n/* bb_warn_ignoring_args(argv[1]); */\n\n\tfd = get_console_fd_or_die();\n/* or maybe:\n\topt = getopt32(argv, \"C:\", &tty_name);\n\tfd = xopen_nonblocking(tty_name);\n*/\n\n\txread(STDIN_FILENO, flags, 7);\n\tif (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))\n\t\tbb_error_msg_and_die(\"not a valid binary keymap\");\n\n\txread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);\n\n\tfor (i = 0; i < MAX_NR_KEYMAPS; i++) {\n\t\tif (flags[i] != 1)\n\t\t\tcontinue;\n\t\txread(STDIN_FILENO, ibuff, NR_KEYS * sizeof(uint16_t));\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tke.kb_index = j;\n\t\t\tke.kb_table = i;\n\t\t\tke.kb_value = ibuff[j];\n\t\t\t/*\n\t\t\t * Note: table[idx:0] can contain special value\n\t\t\t * K_ALLOCATED (marks allocated tables in kernel).\n\t\t\t * dumpkmap saves the value as-is; but attempts\n\t\t\t * to load it here fail, since it isn't a valid\n\t\t\t * key value: it is K(KT_SPEC,126) == 2<<8 + 126,\n\t\t\t * whereas last valid KT_SPEC is\n\t\t\t * K_BARENUMLOCK == K(KT_SPEC,19).\n\t\t\t * So far we just ignore these errors:\n\t\t\t */\n\t\t\tioctl(fd, KDSKBENT, &ke);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t\tRELEASE_CONFIG_BUFFER(flags);\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "comment": "Loads a binary keymap from standard input and updates the keyboard mapping using ioctl calls for each valid keymap.",
    "prorec_sum": "Processes and validates a binary keymap file, iterating key mapping entries and registering active mappings using a hardware-specific function.",
    "filter_prorec_sum": "Validates a binary keymap file and registers all defined key mappings by iterating through 256 keys and 128 subcodes.",
    "work_score": {
        "prorec": {
            "summary": "Processes and validates a binary keymap file, iterating key mapping entries and registering active mappings using a hardware-specific function.",
            "score": [
                0.5752816356500331,
                0.5958416388128893,
                0.2832472937442315
            ]
        },
        "filter_prorec": {
            "summary": "Validates a binary keymap file and registers all defined key mappings by iterating through 256 keys and 128 subcodes.",
            "score": [
                0.2667016003139585,
                0.3011877346642778,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstatic int i915_ring_freq_table(struct seq_file *m, void *unused)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tint ret;\n\tint gpu_freq, ia_freq;\n\n\tif (!(IS_GEN6(dev) || IS_GEN7(dev))) {\n\t\tseq_printf(m, \"unsupported on this chipset\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->rps.hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\tfor (gpu_freq = dev_priv->rps.min_delay;\n\t     gpu_freq <= dev_priv->rps.max_delay;\n\t     gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsandybridge_pcode_read(dev_priv,\n\t\t\t\t       GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t\t       &ia_freq);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   gpu_freq * GT_FREQUENCY_MULTIPLIER,\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tmutex_unlock(&dev_priv->rps.hw_lock);\n\n\treturn 0;\n}",
    "comment": "Retrieves and prints GPU, effective CPU, and effective Ring frequencies for Intel Gen6 and Gen7 chipsets, while protecting access with a mutex lock.",
    "prorec_sum": "Outputs a formatted table of GPU, CPU, and ring frequencies, iterating over available entries, or reports chipset incompatibility.",
    "filter_prorec_sum": "Outputs a formatted table of GPU, CPU, and Ring frequencies via seq_file, or an error message if unsupported on the chipset.",
    "work_score": {
        "prorec": {
            "summary": "Outputs a formatted table of GPU, CPU, and ring frequencies, iterating over available entries, or reports chipset incompatibility.",
            "score": [
                0.9496286479404092,
                0.9077238235598889,
                0.9907229548884828
            ]
        },
        "filter_prorec": {
            "summary": "Outputs a formatted table of GPU, CPU, and Ring frequencies via seq_file, or an error message if unsupported on the chipset.",
            "score": [
                0.9777299861174692,
                0.9065592097598518,
                0.9968187215876609
            ]
        }
    }
}
{
    "source_code": "\nstatic void\nlisting_page (list_info_type *list)\n{\n  /* Grope around, see if we can see a title or subtitle edict coming up\n     soon.  (we look down 10 lines of the page and see if it's there)  */\n  if ((eject || (on_page >= (unsigned int) paper_height))\n      && paper_height != 0)\n    {\n      unsigned int c = 10;\n      int had_title = 0;\n      int had_subtitle = 0;\n\n      page++;\n\n      while (c != 0 && list)\n\t{\n\t  if (list->edict == EDICT_SBTTL && !had_subtitle)\n\t    {\n\t      had_subtitle = 1;\n\t      subtitle = list->edict_arg;\n\t    }\n\t  if (list->edict == EDICT_TITLE && !had_title)\n\t    {\n\t      had_title = 1;\n\t      title = list->edict_arg;\n\t    }\n\t  list = list->next;\n\t  c--;\n\t}\n\n      if (page > 1)\n\t{\n\t  fprintf (list_file, \"\\f\");\n\t}\n\n      fprintf (list_file, \"%s %s \\t\\t\\tpage %d\\n\", LISTING_HEADER, fn, page);\n      fprintf (list_file, \"%s\\n\", title);\n      fprintf (list_file, \"%s\\n\", subtitle);\n      on_page = 3;\n      eject = 0;\n    }\n}",
    "comment": "The function checks for titles and subtitles in a list before printing the current page header, title, and subtitle to a file.",
    "prorec_sum": "Generates a GAS listing page header and outputs stored source and location lines to the listing file, updating related pagination state variables.",
    "filter_prorec_sum": "Generates a new \u201cGAS LISTING\u201d page header and writes stored location strings to the listing file, updating related global tracking variables.",
    "work_score": {
        "prorec": {
            "summary": "Generates a GAS listing page header and outputs stored source and location lines to the listing file, updating related pagination state variables.",
            "score": [
                0.2695319947419054,
                0.23838703441923093,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Generates a new \u201cGAS LISTING\u201d page header and writes stored location strings to the listing file, updating related global tracking variables.",
            "score": [
                0.3371796368362222,
                0.28763960552894663,
                0.0037294945013154543
            ]
        }
    }
}
{
    "source_code": "\nint\ngsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * s,\n                             const double xtol, const double gtol,\n                             const double ftol, int *info)\n{\n  int status;\n  double gnorm, fnorm, phi;\n\n  *info = 0;\n\n  status = gsl_multifit_test_delta(s->dx, s->x, xtol*xtol, xtol);\n  if (status == GSL_SUCCESS)\n    {\n      *info = 1;\n      return GSL_SUCCESS;\n    }\n\n  /* compute gradient g = J^T f */\n  (s->type->gradient) (s->state, s->g);\n\n  /* compute gnorm = max_i( g_i * max(x_i, 1) ) */\n  gnorm = scaled_infnorm(s->x, s->g);\n\n  /* compute fnorm = ||f|| */\n  fnorm = gsl_blas_dnrm2(s->f);\n  phi = 0.5 * fnorm * fnorm;\n\n  if (gnorm <= gtol * GSL_MAX(phi, 1.0))\n    {\n      *info = 2;\n      return GSL_SUCCESS;\n    }\n\n#if 0\n  if (dfnorm <= ftol * GSL_MAX(fnorm, 1.0))\n    {\n      *info = 3;\n      return GSL_SUCCESS;\n    }\n#endif\n\n  return GSL_CONTINUE;\n}",
    "comment": "Evaluates the convergence of a multifit solver by checking parameter changes, gradient norms, and function norms against specified tolerances.",
    "prorec_sum": "Checks for solver convergence using parameter deltas and residual norms, updating status codes or adjusting thresholds based on iteration results.",
    "filter_prorec_sum": "Checks solver convergence using delta and residual norms, updating status or returning a specific code if termination thresholds are met.",
    "work_score": {
        "prorec": {
            "summary": "Checks for solver convergence using parameter deltas and residual norms, updating status codes or adjusting thresholds based on iteration results.",
            "score": [
                0.4089338562843075,
                0.47217511107730264,
                0.0817453493745183
            ]
        },
        "filter_prorec": {
            "summary": "Checks solver convergence using delta and residual norms, updating status or returning a specific code if termination thresholds are met.",
            "score": [
                0.8012607529282105,
                0.7901475283271302,
                0.8818202194158159
            ]
        }
    }
}
{
    "source_code": "\nZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem)\n{\n    ZSTD_CStream* zcs;\n\n    if (!customMem.customAlloc && !customMem.customFree) customMem = defaultCustomMem;\n    if (!customMem.customAlloc || !customMem.customFree) return NULL;\n\n    zcs = (ZSTD_CStream*)ZSTD_malloc(sizeof(ZSTD_CStream), customMem);\n    if (zcs==NULL) return NULL;\n    memset(zcs, 0, sizeof(ZSTD_CStream));\n    memcpy(&zcs->customMem, &customMem, sizeof(ZSTD_customMem));\n    zcs->cctx = ZSTD_createCCtx_advanced(customMem);\n    if (zcs->cctx == NULL) { ZSTD_freeCStream(zcs); return NULL; }\n    return zcs;\n}",
    "comment": "Creates and initializes a ZSTD_CStream object with custom memory allocation, returning NULL on failure or invalid parameters.",
    "prorec_sum": "Allocates and initializes a 200-byte structure with provided function pointers and parameters, invoking a secondary setup routine before returning the created object.",
    "filter_prorec_sum": "Allocates and initializes a 200-byte structure with provided callback functions and parameters, then creates and stores an associated resource handle.",
    "work_score": {
        "prorec": {
            "summary": "Allocates and initializes a 200-byte structure with provided function pointers and parameters, invoking a secondary setup routine before returning the created object.",
            "score": [
                0.08111300831512863,
                0.1449184614645153,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Allocates and initializes a 200-byte structure with provided callback functions and parameters, then creates and stores an associated resource handle.",
            "score": [
                0.1034691283520653,
                0.17330843207178043,
                0.0
            ]
        }
    }
}
{
    "source_code": "static enum mu_filter_result\n_crlfdot_decoder (void *xd,\n\t\t  enum mu_filter_command cmd,\n\t\t  struct mu_filter_io *iobuf)\n{\n  int *pstate = xd;\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n\n  switch (cmd)\n    {\n    case mu_filter_init:\n      *pstate = crlfdot_decode_init;\n      return mu_filter_ok;\n      \n    case mu_filter_done:\n      return mu_filter_ok;\n      \n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; *pstate != crlfdot_decode_end && i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n\n      if (c == '\\r')\n\t{\n\t  if (i + 1 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr == '\\n')\n\t    continue;\n\t}\n      else if (c == '.' &&\n\t       (*pstate == crlfdot_decode_init ||\n\t\t*pstate == crlfdot_decode_crlf))\n\t{\n\t  /* Make sure we have two more characters in the buffer */\n\t  if (i + 2 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr != '\\r')\n\t    continue;\n\t}\n      else\n\t*pstate = new_decode_state (*pstate, c);\n      optr[j++] = c;\n    }\n  \n  if (*pstate == crlfdot_decode_end)\n    {\n      j -= 2; /* remove the trailing .\\n */\n      iobuf->eof = 1;\n    }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "comment": "Decodes input data by processing CRLF sequences and dots, modifying the state and output buffer accordingly, until reaching the end condition.",
    "prorec_sum": "Processes an input byte stream, updating state via sub_61307, handling CR/LF and dots, and writing parsed bytes into a destination buffer.",
    "filter_prorec_sum": "Processes an input byte stream, updating parser state and copying valid bytes to output until termination conditions or parser completion are met.",
    "work_score": {
        "prorec": {
            "summary": "Processes an input byte stream, updating state via sub_61307, handling CR/LF and dots, and writing parsed bytes into a destination buffer.",
            "score": [
                0.3996353448605618,
                0.46903493129422086,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Processes an input byte stream, updating parser state and copying valid bytes to output until termination conditions or parser completion are met.",
            "score": [
                0.8186406801279592,
                0.7798411907960504,
                0.8811544129486949
            ]
        }
    }
}
{
    "source_code": "\nstatic int\ntry_load_plugin (const char *pname, bfd *abfd, int *has_plugin_p)\n{\n  void *plugin_handle;\n  struct ld_plugin_tv tv[4];\n  int i;\n  ld_plugin_onload onload;\n  enum ld_plugin_status status;\n\n  *has_plugin_p = 0;\n\n  plugin_handle = dlopen (pname, RTLD_NOW);\n  if (!plugin_handle)\n    {\n      _bfd_error_handler (\"%s\\n\", dlerror ());\n      return 0;\n    }\n\n  onload = dlsym (plugin_handle, \"onload\");\n  if (!onload)\n    goto err;\n\n  i = 0;\n  tv[i].tv_tag = LDPT_MESSAGE;\n  tv[i].tv_u.tv_message = message;\n\n  ++i;\n  tv[i].tv_tag = LDPT_REGISTER_CLAIM_FILE_HOOK;\n  tv[i].tv_u.tv_register_claim_file = register_claim_file;\n\n  ++i;\n  tv[i].tv_tag = LDPT_ADD_SYMBOLS;\n  tv[i].tv_u.tv_add_symbols = add_symbols;\n\n  ++i;\n  tv[i].tv_tag = LDPT_NULL;\n  tv[i].tv_u.tv_val = 0;\n\n  status = (*onload)(tv);\n\n  if (status != LDPS_OK)\n    goto err;\n\n  *has_plugin_p = 1;\n\n  abfd->plugin_format = bfd_plugin_no;\n\n  if (!claim_file)\n    goto err;\n\n  if (!try_claim (abfd))\n    goto err;\n\n  abfd->plugin_format = bfd_plugin_yes;\n\n  return 1;\n\n err:\n  return 0;\n}",
    "comment": "Loads a plugin from a specified path, initializes it, and claims a file if successful, returning the status of the operation.",
    "prorec_sum": "Loads a shared library, calls its `onload` function with callbacks, and updates flags and state based on returned data and file descriptor position.",
    "filter_prorec_sum": "Loads a shared library, invokes its `onload` function with callbacks, and conditionally updates flags based on runtime checks and file descriptor state.",
    "work_score": {
        "prorec": {
            "summary": "Loads a shared library, calls its `onload` function with callbacks, and updates flags and state based on returned data and file descriptor position.",
            "score": [
                0.4836139227963362,
                0.524475961981254,
                0.010421210627349072
            ]
        },
        "filter_prorec": {
            "summary": "Loads a shared library, invokes its `onload` function with callbacks, and conditionally updates flags based on runtime checks and file descriptor state.",
            "score": [
                0.8166879159251781,
                0.8548562016573836,
                0.8851202011041878
            ]
        }
    }
}
{
    "source_code": "static int\nxmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map,\n\t\t\t\txmlNodePtr node)\n{\n    xmlNodePtr cur;\n    xmlNsPtr ns;\n    xmlNsMapItemPtr mi;\n    int shadowed;\n\n    if ((map == NULL) || (*map != NULL))\n\treturn (-1);\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))\n        return (-1);\n    /*\n    * Get in-scope ns-decls of @parent.\n    */\n    cur = node;\n    while ((cur != NULL) && (cur != (xmlNodePtr) cur->doc)) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    if (cur->nsDef != NULL) {\n\t\tns = cur->nsDef;\n\t\tdo {\n\t\t    shadowed = 0;\n\t\t    if (XML_NSMAP_NOTEMPTY(*map)) {\n\t\t\t/*\n\t\t\t* Skip shadowed prefixes.\n\t\t\t*/\n\t\t\tXML_NSMAP_FOREACH(*map, mi) {\n\t\t\t    if ((ns->prefix == mi->newNs->prefix) ||\n\t\t\t\txmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n\t\t\t\tshadowed = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t    * Insert mapping.\n\t\t    */\n\t\t    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n\t\t\tns, XML_TREE_NSMAP_PARENT);\n\t\t    if (mi == NULL)\n\t\t\treturn (-1);\n\t\t    if (shadowed)\n\t\t\tmi->shadowDepth = 0;\n\t\t    ns = ns->next;\n\t\t} while (ns != NULL);\n\t    }\n\t}\n\tcur = cur->parent;\n    }\n    return (0);\n}",
    "comment": "Gathers in-scope namespace declarations from the given node's ancestors and updates the namespace mapping, avoiding shadowed prefixes.",
    "prorec_sum": "Traverses XML node structures, matching namespace names, and adds corresponding entries to a target list using sub_51530 for insertion.",
    "filter_prorec_sum": "Traverses XML namespace nodes from a given element, matching names and invoking sub_51530 to process or add them to the target list.",
    "work_score": {
        "prorec": {
            "summary": "Traverses XML node structures, matching namespace names, and adds corresponding entries to a target list using sub_51530 for insertion.",
            "score": [
                0.20694861993297495,
                0.19413956768939183,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Traverses XML namespace nodes from a given element, matching names and invoking sub_51530 to process or add them to the target list.",
            "score": [
                0.036349890431453334,
                0.15012223867413152,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_trigger *trig;\n\tint len = 0;\n\n\tdown_read(&triggers_list_lock);\n\tdown_read(&led_cdev->trigger_lock);\n\n\tif (!led_cdev->trigger)\n\t\tlen += sprintf(buf+len, \"[none] \");\n\telse\n\t\tlen += sprintf(buf+len, \"none \");\n\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\n\t\t\t\t\t\t\ttrig->name))\n\t\t\tlen += sprintf(buf+len, \"[%s] \", trig->name);\n\t\telse\n\t\t\tlen += sprintf(buf+len, \"%s \", trig->name);\n\t}\n\tup_read(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n\n\tlen += sprintf(len+buf, \"\\n\");\n\treturn len;\n}",
    "comment": "Retrieves the current LED trigger state and lists available triggers, marking the active trigger with brackets in the output buffer.",
    "prorec_sum": "Formats a textual status line into the provided buffer by listing registered entries or \"none\", then finalizes and returns the resulting length.",
    "filter_prorec_sum": "Builds a status string into the provided buffer, listing \u201cnone\u201d or formatted entries from a global list, then returns the resulting length.",
    "work_score": {
        "prorec": {
            "summary": "Formats a textual status line into the provided buffer by listing registered entries or \"none\", then finalizes and returns the resulting length.",
            "score": [
                0.7397785876122639,
                0.7128843616954326,
                0.8650231242943376
            ]
        },
        "filter_prorec": {
            "summary": "Builds a status string into the provided buffer, listing \u201cnone\u201d or formatted entries from a global list, then returns the resulting length.",
            "score": [
                0.8795098984947337,
                0.8589916225181942,
                0.9194460221344519
            ]
        }
    }
}
{
    "source_code": "\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t__be32 saddr = iph->saddr;\n\t__be32 daddr = iph->daddr;\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),\n\t\t\t    skb->dev->ifindex);\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}",
    "comment": "Processes received ICMP packets, checks for an associated socket, and queues the packet for delivery if a corresponding socket is found.",
    "prorec_sum": "Processes packet-related data from control structures, prepares and associates buffers, invokes follow-up handling, and manages reference counts for cleanup operations.",
    "filter_prorec_sum": "Processes network buffer metadata, obtains a related object, invokes data copy and update routines, and decrements its reference count to trigger cleanup if needed.",
    "work_score": {
        "prorec": {
            "summary": "Processes packet-related data from control structures, prepares and associates buffers, invokes follow-up handling, and manages reference counts for cleanup operations.",
            "score": [
                0.5115279957184852,
                0.6082481175322153,
                0.026862001759146215
            ]
        },
        "filter_prorec": {
            "summary": "Processes network buffer metadata, obtains a related object, invokes data copy and update routines, and decrements its reference count to trigger cleanup if needed.",
            "score": [
                0.2817142403726546,
                0.2951465163235692,
                0.0
            ]
        }
    }
}
{
    "source_code": "static int snd_seq_device_free(struct snd_seq_device *dev)\n{\n\tstruct ops_list *ops;\n\n\tif (snd_BUG_ON(!dev))\n\t\treturn -EINVAL;\n\n\tops = find_driver(dev->id, 0);\n\tif (ops == NULL)\n\t\treturn -ENXIO;\n\n\t/* remove the device from the list */\n\tmutex_lock(&ops->reg_mutex);\n\tlist_del(&dev->list);\n\tops->num_devices--;\n\tmutex_unlock(&ops->reg_mutex);\n\n\tfree_device(dev, ops);\n\tif (dev->private_free)\n\t\tdev->private_free(dev);\n\tkfree(dev);\n\n\tunlock_driver(ops);\n\n\treturn 0;\n}",
    "comment": "Frees a sequencer device by removing it from the list, releasing resources, and invoking the device's private cleanup function if defined.",
    "prorec_sum": "Handles codec object cleanup by unlinking structures, updating power state via callback, and decrementing relevant reference counters before returning success or error.",
    "filter_prorec_sum": "Detaches and cleans up a hda_codec power-state object, updates linked lists, invokes optional callbacks, and performs final resource decrement and release operations.",
    "work_score": {
        "prorec": {
            "summary": "Handles codec object cleanup by unlinking structures, updating power state via callback, and decrementing relevant reference counters before returning success or error.",
            "score": [
                0.08156237018985427,
                0.08520131041805498,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Detaches and cleans up a hda_codec power-state object, updates linked lists, invokes optional callbacks, and performs final resource decrement and release operations.",
            "score": [
                0.06702737650121553,
                0.15108541368191516,
                0.0
            ]
        }
    }
}
{
    "source_code": "static void\nmixed_string_buffer_flush_curr (struct mixed_string_buffer *bp)\n{\n  if (bp->curr_type == utf8_encoded)\n    mixed_string_buffer_flush_utf16_surr (bp);\n  if (bp->curr_type != -1)\n    {\n      if (bp->curr_buflen > 0)\n        {\n          struct mixed_string_segment *segment =\n            segment_alloc (bp->curr_type, bp->curr_buffer, bp->curr_buflen);\n          mixed_string_buffer_add_segment (bp, segment);\n        }\n      bp->curr_buflen = 0;\n    }\n}",
    "comment": "Flushes the current buffer to segments based on its type, handling UTF-8 encoding and resetting the buffer length after addition.",
    "prorec_sum": "Buffers and stores a data block with its state flag into a dynamically resized list, clearing temporary storage after insertion.",
    "filter_prorec_sum": "Appends a new memory-copied data block with its state code into a dynamically resized list and clears the source buffer reference.",
    "work_score": {
        "prorec": {
            "summary": "Buffers and stores a data block with its state flag into a dynamically resized list, clearing temporary storage after insertion.",
            "score": [
                0.2690581615263324,
                0.34304375281946964,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Appends a new memory-copied data block with its state code into a dynamically resized list and clears the source buffer reference.",
            "score": [
                0.14251135021221653,
                0.275991048692802,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstruct sequence *\nnew_C_string_sequence (const char * delimitor)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n  res->open = rule_new (xustrdup (delimitor), NULL,\n\t\t\trhs_new_single (NULL, 0, Plain_fface),\n\t\t\t__FILE__, __LINE__);\n  res->face = String_fface;\n  res->exceptions = new_C_exceptions ();\n  res->close = words_new (\"C Close: strings\", \"C Close: regex\", 5, 5);\n  words_add_string (res->close,\n\t\t    rule_new (xustrdup (delimitor), NULL,\n\t\t\t      rhs_new_single (NULL, 0, Plain_fface),\n\t\t\t      __FILE__, __LINE__));\n  words_finalize (res->close);\n  return res;\n}",
    "comment": "Creates and initializes a new string sequence structure with a specified delimiter and associated rules for processing strings.",
    "prorec_sum": "Constructs and returns a data structure for C string parsing, including usual escape exceptions and closing rules based on the provided source delimiter.",
    "filter_prorec_sum": "Builds and returns a structure containing C-string handling rules, including escape sequence exceptions and closing patterns, based on the provided source string.",
    "work_score": {
        "prorec": {
            "summary": "Constructs and returns a data structure for C string parsing, including usual escape exceptions and closing rules based on the provided source delimiter.",
            "score": [
                0.5578773529546376,
                0.6182253944000242,
                0.19943956262189014
            ]
        },
        "filter_prorec": {
            "summary": "Builds and returns a structure containing C-string handling rules, including escape sequence exceptions and closing patterns, based on the provided source string.",
            "score": [
                0.4545404934178947,
                0.48032820243725105,
                0.0
            ]
        }
    }
}
{
    "source_code": "int mmc_get_phys_format_info(struct burn_drive *d, int *disk_category,\n\t\t\tchar **book_name, int *part_version, int *num_layers,\n\t\t\tint *num_blocks, int flag)\n{\n\tint ret, reply_len, prf;\n\tchar *reply = NULL;\n\tstatic char book_names[][16] = {\n\t\t\"DVD-ROM\", \"DVD-RAM\", \"DVD-R\", \"DVD-RW\",\n\t\t\"HD DVD-ROM\", \"HD DVD-RAM\", \"HD DVD-R\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW\", \"DVD+R\", \"unknown\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW DL\", \"DVD+R DL\", \"unknown\"\n\t};\n\n\tprf = d->current_profile;\n\tif (!(prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15 ||\n\t      prf == 0x51))\n\t\treturn 0; /* Not a [HD] DVD-R[W] loaded */\n\tret = mmc_read_disc_structure(d, 0, 0, 0x10, 12, &reply,\n\t\t\t\t\t\t\t &reply_len, 0);\n\tif (ret <= 0)\n\t\tgoto ex;\n\tif(reply_len < 12) {\n\t\tlibdax_msgs_submit(libdax_messenger, -1, 0x00000002,\n\t\t\tLIBDAX_MSGS_SEV_DEBUG, LIBDAX_MSGS_PRIO_ZERO,\n\t\t\t\"READ DISC STRUCTURE format 10h: Less than 12 bytes\",\n\t\t\t0, 0);\n\t\t{ret = 0; goto ex;}\n\t}\n\t*disk_category = (reply[0] >> 4) & 0xf;\n\t*book_name = book_names[*disk_category];\n\t*part_version = reply[0] & 0xf;\n\t*num_layers = ((reply[2] >> 5) & 0x3) + 1;\n\t*num_blocks = ((reply[9] << 16) | (reply[10] << 8) | reply[11]) -\n\t              ((reply[5] << 16) | (reply[6] << 8) | reply[7]) + 1;\n\tret = 1;\nex:;\n\tif (reply != NULL)\n\t\tfree(reply);\n\treturn ret;\n}",
    "comment": "Retrieves physical format information of a disc in the drive, including disk category, book name, version, layer count, and block count.",
    "prorec_sum": "Parses and extracts disc structure data from a device, populating track-related parameters before freeing allocated memory.",
    "filter_prorec_sum": "Extracts and parses the \u201cREAD DISC STRUCTURE\u201d format\u202f0x10h data from a CD device, populating fields like layer, track, and sector count.",
    "work_score": {
        "prorec": {
            "summary": "Parses and extracts disc structure data from a device, populating track-related parameters before freeing allocated memory.",
            "score": [
                0.41321344196581505,
                0.45096442520791263,
                0.08862461152641496
            ]
        },
        "filter_prorec": {
            "summary": "Extracts and parses the \u201cREAD DISC STRUCTURE\u201d format\u202f0x10h data from a CD device, populating fields like layer, track, and sector count.",
            "score": [
                0.26531489081165693,
                0.205572188356125,
                0.0
            ]
        }
    }
}
{
    "source_code": "int aaip_add_acl_st_mode(char *acl_text, mode_t st_mode, int flag)\n{\n char *wpt;\n int tag_types= 0;\n\n tag_types = aaip_cleanout_st_mode(acl_text, &st_mode, 1);\n if(!(tag_types & (4 | 32))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"user::%c%c%c\\n\",\n           st_mode & S_IRUSR ? 'r' : '-',\n           st_mode & S_IWUSR ? 'w' : '-',\n           st_mode & S_IXUSR ? 'x' : '-');\n }\n if(!(tag_types & (2 | 16 | 1024))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"group::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n if(!(tag_types & (1 | 8))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"other::%c%c%c\\n\",\n         st_mode & S_IROTH ? 'r' : '-',\n         st_mode & S_IWOTH ? 'w' : '-',\n         st_mode & S_IXOTH ? 'x' : '-');\n }\n if((tag_types & (128 | 256)) && !(tag_types & 512)) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"mask::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n return(1); \n}",
    "comment": "Adds entries for user, group, other, and mask permissions to an ACL string based on the provided `mode_t` and existing ACL tags.",
    "prorec_sum": "Formats and appends user, group, other, and mask permission strings based on access mode bits retrieved from the provided input parameters.",
    "filter_prorec_sum": "Formats and appends user, group, other, and mask permission strings to the provided buffer based on access bit flags.",
    "work_score": {
        "prorec": {
            "summary": "Formats and appends user, group, other, and mask permission strings based on access mode bits retrieved from the provided input parameters.",
            "score": [
                0.94932677855413,
                0.9046219953123142,
                0.9856398272722016
            ]
        },
        "filter_prorec": {
            "summary": "Formats and appends user, group, other, and mask permission strings to the provided buffer based on access bit flags.",
            "score": [
                0.9567416729841793,
                0.9012673508351116,
                0.9779968906869699
            ]
        }
    }
}
{
    "source_code": "int get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint cpu = t->cpu_id;\n\tunsigned long long msr;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(stderr, \"Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tt->tsc = rdtsc();\t/* we are running on local CPU of interest */\n\n\tif (has_aperf) {\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\t\tif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\n\t\t\treturn -4;\n\t}\n\n\tif (do_smi) {\n\t\tif (get_msr(cpu, MSR_SMI_COUNT, &msr))\n\t\t\treturn -5;\n\t\tt->smi_count = msr & 0xFFFFFFFF;\n\t}\n\tif (extra_delta_offset32) {\n\t\tif (get_msr(cpu, extra_delta_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_delta32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_delta_offset64)\n\t\tif (get_msr(cpu, extra_delta_offset64, &t->extra_delta64))\n\t\t\treturn -5;\n\n\tif (extra_msr_offset32) {\n\t\tif (get_msr(cpu, extra_msr_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_msr32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_msr_offset64)\n\t\tif (get_msr(cpu, extra_msr_offset64, &t->extra_msr64))\n\t\t\treturn -5;\n\n\t/* collect core counters only for 1st thread in core */\n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\n\t\t\treturn -6;\n\t\tif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t}\n\n\tif (do_snb_cstates)\n\t\tif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\n\t\t\treturn -8;\n\n\tif (do_dts) {\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn -9;\n\t\tc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\n\n\t/* collect package counters only for 1st core in package */\n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\n\t\t\treturn -9;\n\t\tif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\treturn -10;\n\t}\n\tif (do_snb_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\n\t\t\treturn -11;\n\t\tif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\n\t\t\treturn -12;\n\t}\n\tif (do_c8_c9_c10) {\n\t\tif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\n\t\t\treturn -13;\n\t}\n\tif (do_rapl & RAPL_PKG) {\n\t\tif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_CORES) {\n\t\tif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\n\t\t\treturn -14;\n\t\tp->energy_cores = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\n\t\t\treturn -15;\n\t\tp->energy_dram = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->energy_gfx = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_PKG_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_dram_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_ptm) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn -17;\n\t\tp->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\treturn 0;\n}",
    "comment": "Aggregates packet and byte counters from multiple CPU entries into a single counter array based on the provided old counters.",
    "prorec_sum": "Iterates over indexed data structures, aggregating 64\u2011bit values into an output array while synchronizing on a shared lock flag for concurrent access safety.",
    "filter_prorec_sum": "Iterates over indexed data blocks, accumulating values into an output array while monitoring a synchronization flag and handling concurrent access pauses.",
    "work_score": {
        "prorec": {
            "summary": "Iterates over indexed data structures, aggregating 64\u2011bit values into an output array while synchronizing on a shared lock flag for concurrent access safety.",
            "score": [
                0.011665819710099097,
                0.003308598136812591,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Iterates over indexed data blocks, accumulating values into an output array while monitoring a synchronization flag and handling concurrent access pauses.",
            "score": [
                0.0014063625119123502,
                0.0017986208021029773,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nstatic R_xlen_t\ncompact_intseq_Get_region(SEXP sx, R_xlen_t i, R_xlen_t n, int *buf)\n{\n    /* should not get here if x is already expanded */\n    CHECK_NOT_EXPANDED(sx);\n\n    SEXP info = COMPACT_SEQ_INFO(sx);\n    R_xlen_t size = COMPACT_INTSEQ_INFO_LENGTH(info);\n    R_xlen_t n1 = COMPACT_INTSEQ_INFO_FIRST(info);\n    int inc = COMPACT_INTSEQ_INFO_INCR(info);\n\n    R_xlen_t ncopy = size - i > n ? n : size - i;\n    if (inc == 1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 + k + i);\n\treturn ncopy;\n    }\n    else if (inc == -1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 - k - i);\n\treturn ncopy;\n    }\n    else\n\terror(\"compact sequences with increment %d not supported yet\", inc);\n}",
    "comment": "Extracts a specified region from a compact integer sequence into a buffer, handling both increasing and decreasing increments.",
    "prorec_sum": "Generates a contiguous integer sequence from vector metadata, supporting increments of 1 or -1, and raises errors for unsupported compact sequence formats.",
    "filter_prorec_sum": "Generates a sequence of integer indices from vector metadata, supporting increments of 1 or -1, and errors on unsupported increments or expanded vectors.",
    "work_score": {
        "prorec": {
            "summary": "Generates a contiguous integer sequence from vector metadata, supporting increments of 1 or -1, and raises errors for unsupported compact sequence formats.",
            "score": [
                0.9631886500207203,
                0.9243080161665601,
                0.9954045260848993
            ]
        },
        "filter_prorec": {
            "summary": "Generates a sequence of integer indices from vector metadata, supporting increments of 1 or -1, and errors on unsupported increments or expanded vectors.",
            "score": [
                0.9599051079127214,
                0.9280197497542384,
                1.0
            ]
        }
    }
}
{
    "source_code": "\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}",
    "comment": "Determines if a character is a valid starting character for an XML document name based on XML-1.0 specifications or old document properties.",
    "prorec_sum": "Determines if a given Unicode code point is a valid XML name character, considering configuration flags and extended character ranges.",
    "filter_prorec_sum": "Checks whether a given Unicode codepoint is valid for use in XML names, considering specific character ranges and configuration flags.",
    "work_score": {
        "prorec": {
            "summary": "Determines if a given Unicode code point is a valid XML name character, considering configuration flags and extended character ranges.",
            "score": [
                0.8478190102114121,
                0.8471145969015588,
                0.9425008572876216
            ]
        },
        "filter_prorec": {
            "summary": "Checks whether a given Unicode codepoint is valid for use in XML names, considering specific character ranges and configuration flags.",
            "score": [
                0.8926358128837075,
                0.8339274236082914,
                0.9352929713200904
            ]
        }
    }
}
{
    "source_code": "\nstatic void uncore_pci_remove(struct pci_dev *pdev)\n{\n\tstruct intel_uncore_box *box = pci_get_drvdata(pdev);\n\tstruct intel_uncore_pmu *pmu = box->pmu;\n\tint cpu, phys_id = pcibus_to_physid[pdev->bus->number];\n\n\tif (WARN_ON_ONCE(phys_id != box->phys_id))\n\t\treturn;\n\n\tpci_set_drvdata(pdev, NULL);\n\n\traw_spin_lock(&uncore_box_lock);\n\tlist_del(&box->list);\n\traw_spin_unlock(&uncore_box_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (*per_cpu_ptr(pmu->box, cpu) == box) {\n\t\t\t*per_cpu_ptr(pmu->box, cpu) = NULL;\n\t\t\tatomic_dec(&box->refcnt);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&box->refcnt) != 1);\n\tkfree(box);\n}",
    "comment": "Removes an uncore PCI device, updates reference counts, and frees associated resources while ensuring proper synchronization in a multi-CPU environment.",
    "prorec_sum": "Unregisters and cleans up an Intel uncore performance event object, removing references, updating global counters, and logging inconsistencies.",
    "filter_prorec_sum": "Removes and cleans up an Intel uncore performance event, unlinking it from tracking lists, updating counters, and invoking related teardown routines.",
    "work_score": {
        "prorec": {
            "summary": "Unregisters and cleans up an Intel uncore performance event object, removing references, updating global counters, and logging inconsistencies.",
            "score": [
                0.5429442126864893,
                0.6002756286454413,
                0.11377640753224023
            ]
        },
        "filter_prorec": {
            "summary": "Removes and cleans up an Intel uncore performance event, unlinking it from tracking lists, updating counters, and invoking related teardown routines.",
            "score": [
                0.5300014673496876,
                0.6744723340211949,
                0.1204626703104417
            ]
        }
    }
}
{
    "source_code": "\nstatic void sig_child_handler(int sig_no UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint l;\n\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"child\");\n\twhile ((pid = wait_any_nohang(&wstat)) > 0) {\n\t\tfor (l = 0; l < dirn; ++l) {\n\t\t\tif (dir[l].ppid == pid) {\n\t\t\t\tdir[l].ppid = 0;\n\t\t\t\tprocessorstop(&dir[l]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "comment": "Handles SIGCHLD signals by cleaning up and processing terminated child processes that match entries in the directory.",
    "prorec_sum": "Processes incoming events from `sub_518073`, logs an \u201cend\u201d message with status details, and conditionally triggers further handling via `sub_54173A`.",
    "filter_prorec_sum": "Processes incoming event codes, logs formatted \u201cend\u201d messages with status and signal details, and triggers final handling if the global active flag is set.",
    "work_score": {
        "prorec": {
            "summary": "Processes incoming events from `sub_518073`, logs an \u201cend\u201d message with status details, and conditionally triggers further handling via `sub_54173A`.",
            "score": [
                0.0,
                0.005340332885823078,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Processes incoming event codes, logs formatted \u201cend\u201d messages with status and signal details, and triggers final handling if the global active flag is set.",
            "score": [
                0.03827267484429088,
                0.012279849969700463,
                0.0
            ]
        }
    }
}
{
    "source_code": "\nint\nrl_arrow_keys (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (ch < 0)\n    return (1);\n\n  switch (_rl_to_upper (ch))\n    {\n    case 'A':\n      rl_get_previous_history (count, ch);\n      break;\n\n    case 'B':\n      rl_get_next_history (count, ch);\n      break;\n\n    case 'C':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, ch);\n      else\n\trl_forward_byte (count, ch);\n      break;\n\n    case 'D':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_backward_char (count, ch);\n      else\n\trl_backward_byte (count, ch);\n      break;\n\n    default:\n      rl_ding ();\n    }\n\n  return 0;\n}",
    "comment": "Handles arrow key inputs to navigate command history or move the cursor forward/backward, depending on the key pressed and character encoding.",
    "prorec_sum": "Handles arrow key input by reading a key and invoking history navigation or character movement functions, ringing a bell for unsupported keys.",
    "filter_prorec_sum": "Handles arrow key input in readline, executing history navigation or cursor movement functions, and rings the terminal bell for unrecognized keys.",
    "work_score": {
        "prorec": {
            "summary": "Handles arrow key input by reading a key and invoking history navigation or character movement functions, ringing a bell for unsupported keys.",
            "score": [
                0.9439148173053047,
                0.8872394960603552,
                0.9615077510118816
            ]
        },
        "filter_prorec": {
            "summary": "Handles arrow key input in readline, executing history navigation or cursor movement functions, and rings the terminal bell for unrecognized keys.",
            "score": [
                0.9573690008579051,
                0.9055421914786594,
                0.9871700373600616
            ]
        }
    }
}
{
    "source_code": "\nint rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tif (enabled == 0 && rtc->uie_irq_active) {\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, 0);\n\t}\n#endif\n\t/* make sure we're changing state */\n\tif (rtc->uie_rtctimer.enabled == enabled)\n\t\tgoto out;\n\n\tif (rtc->uie_unsupported) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (enabled) {\n\t\tstruct rtc_time tm;\n\t\tktime_t now, onesec;\n\n\t\t__rtc_read_time(rtc, &tm);\n\t\tonesec = ktime_set(1, 0);\n\t\tnow = rtc_tm_to_ktime(tm);\n\t\trtc->uie_rtctimer.node.expires = ktime_add(now, onesec);\n\t\trtc->uie_rtctimer.period = ktime_set(1, 0);\n\t\terr = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);\n\t} else\n\t\trtc_timer_remove(rtc, &rtc->uie_rtctimer);\n\nout:\n\tmutex_unlock(&rtc->ops_lock);\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\t/*\n\t * Enable emulation if the driver did not provide\n\t * the update_irq_enable function pointer or if returned\n\t * -EINVAL to signal that it has been configured without\n\t * interrupts or that are not available at the moment.\n\t */\n\tif (err == -EINVAL)\n\t\terr = rtc_dev_update_irq_enable_emul(rtc, enabled);\n#endif\n\treturn err;\n\n}",
    "comment": "Updates the RTC interrupt state, enabling or disabling the timer based on the provided flag, while handling potential emulation requirements.",
    "prorec_sum": "Changes a device\u2019s power state, updating related timing fields and invoking appropriate initialization or shutdown routines based on the requested state.",
    "filter_prorec_sum": "Handles a state change request for a device, updating timestamps and invoking appropriate setup or teardown routines based on the requested mode.",
    "work_score": {
        "prorec": {
            "summary": "Changes a device\u2019s power state, updating related timing fields and invoking appropriate initialization or shutdown routines based on the requested state.",
            "score": [
                0.06642122379974608,
                0.03360780117991903,
                0.0
            ]
        },
        "filter_prorec": {
            "summary": "Handles a state change request for a device, updating timestamps and invoking appropriate setup or teardown routines based on the requested mode.",
            "score": [
                0.4635624872901511,
                0.4889409730492604,
                0.4744371082784478
            ]
        }
    }
}
{
    "source_code": "\nstatic ngx_int_t\nngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)\n{\n    struct tcp_info  ti;\n    socklen_t        len;\n    uint32_t         value;\n\n    len = sizeof(struct tcp_info);\n    if (getsockopt(r->connection->fd, IPPROTO_TCP, TCP_INFO, &ti, &len) == -1) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    switch (data) {\n    case 0:\n        value = ti.tcpi_rtt;\n        break;\n\n    case 1:\n        value = ti.tcpi_rttvar;\n        break;\n\n    case 2:\n        value = ti.tcpi_snd_cwnd;\n        break;\n\n    case 3:\n        value = ti.tcpi_rcv_space;\n        break;\n\n    /* suppress warning */\n    default:\n        value = 0;\n        break;\n    }\n\n    v->len = ngx_sprintf(v->data, \"%uD\", value) - v->data;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}",
    "comment": "Retrieves TCP connection statistics like RTT, RTT variance, send window size, or receive space and stores the result in an HTTP variable.",
    "prorec_sum": "Retrieves TCP connection statistics via getsockopt and stores a selected numeric value into a dynamically allocated buffer for later use.",
    "filter_prorec_sum": "Retrieves TCP connection statistics via `getsockopt` and formats a selected metric into a buffer for use in the provided session structure.",
    "work_score": {
        "prorec": {
            "summary": "Retrieves TCP connection statistics via getsockopt and stores a selected numeric value into a dynamically allocated buffer for later use.",
            "score": [
                0.9440863359509098,
                0.7843717870778281,
                0.9657464908360183
            ]
        },
        "filter_prorec": {
            "summary": "Retrieves TCP connection statistics via `getsockopt` and formats a selected metric into a buffer for use in the provided session structure.",
            "score": [
                0.904948884945618,
                0.7503581605669545,
                0.9431275407874621
            ]
        }
    }
}
