{
    "filter2_prorec_sum": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
    "filter2_prorec_aug_sum": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
    "filter2_prorec_aug2_sum": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
    "source_code": "\nstatic void *\nxpalloc (void *pa, ptrdiff_t *nitems, ptrdiff_t nitems_incr_min,\n\t ptrdiff_t nitems_max, ptrdiff_t item_size)\n{\n  ptrdiff_t n0 = *nitems;\n\n  /* The approximate size to use for initial small allocation\n     requests.  This is the largest \"small\" request for the GNU C\n     library malloc.  */\n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n  /* If the array is tiny, grow it to about (but no greater than)\n     DEFAULT_MXFAST bytes.  Otherwise, grow it by about 50%.\n     Adjust the growth according to three constraints: NITEMS_INCR_MIN,\n     NITEMS_MAX, and what the C language can represent safely.  */\n\n  ptrdiff_t n, nbytes;\n  if (INT_ADD_WRAPV (n0, n0 >> 1, &n))\n    n = PTRDIFF_MAX;\n  if (0 <= nitems_max && nitems_max < n)\n    n = nitems_max;\n\n  ptrdiff_t adjusted_nbytes\n    = ((INT_MULTIPLY_WRAPV (n, item_size, &nbytes) || SIZE_MAX < nbytes)\n       ? MIN (PTRDIFF_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / item_size;\n      nbytes = adjusted_nbytes - adjusted_nbytes % item_size;\n    }\n\n  if (! pa)\n    *nitems = 0;\n  if (n - n0 < nitems_incr_min\n      && (INT_ADD_WRAPV (n0, nitems_incr_min, &n)\n\t  || (0 <= nitems_max && nitems_max < n)\n\t  || INT_MULTIPLY_WRAPV (n, item_size, &nbytes)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *nitems = n;\n  return pa;\n}",
    "decom_sum": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Adjusts buffer size with overflow and limit checks, reallocating memory if needed, then updates the size and returns the allocation result.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Retrieves the local hostname, enlarging buffer as needed, and resolves it to a fully qualified domain name if it lacks a domain component.",
    "filter2_prorec_aug_sum": "Retrieves the system hostname, dynamically resizing the buffer as needed, and resolves it to its full domain name if it lacks a dot, returning it through the output parameter.",
    "filter2_prorec_aug2_sum": "Allocates buffer and retrieves the system hostname, expanding buffer as needed, then resolves and stores the fully qualified domain name if hostname lacks a dot.",
    "source_code": "\nint\nmu_get_host_name (char **host)\n{\n  char *hostname = NULL;\n  size_t size = 0;\n  char *p;\n\n  while (1)\n    {\n      if (size == 0)\n\t{\n\t  size = MAXHOSTNAMELEN;\n\t  p = malloc (size);\n\t}\n      else\n\t{\n\t  size_t ns = size * 2;\n\t  if (ns < size)\n\t    {\n\t      free (hostname);\n\t      return ENOMEM;\n\t    }\n\t  size = ns;\n\t  p = realloc (hostname, size);\n\t}\n      if (!p)\n\t{\n\t  free (hostname);\n\t  return ENOMEM;\n\t}\n      hostname = p;\n      hostname[size - 1] = 0;\n      if (gethostname (hostname, size - 1) == 0)\n\t{\n\t  if (!hostname[size - 1])\n\t    break;\n\t}\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n\t       && errno != ENOMEM)\n\t{\n\t  int rc = errno;\n\t  free (hostname);\n\t  return rc;\n\t}\n    }\n\n  /* Try to return fully qualified host name */\n  if (!strchr (hostname, '.'))\n    {\n      struct hostent *hp = gethostbyname (hostname);\n      if (hp)\n\t{\n\t  size_t len = strlen (hp->h_name);\n\t  if (size < len + 1)\n\t    {\n\t      p = realloc (hostname, len + 1);\n\t      if (!p)\n\t\t{\n\t\t  free (hostname);\n\t\t  return ENOMEM;\n\t\t}\n\t      hostname = p;\n\t    }\n\t  strcpy (hostname, hp->h_name);\n\t}\n    }\n  \n  *host = hostname;\n  return 0;\n}",
    "decom_sum": "Retrieves the system's hostname, expanding buffer as needed, resolves full name via DNS if missing a dot, and returns it through an output pointer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Retrieves the local hostname, enlarging buffer as needed, and resolves it to a fully qualified domain name if it lacks a domain component.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Retrieves the system hostname, dynamically resizing the buffer as needed, and resolves it to its full domain name if it lacks a dot, returning it through the output parameter.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates buffer and retrieves the system hostname, expanding buffer as needed, then resolves and stores the fully qualified domain name if hostname lacks a dot.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and normalizes a hardware-related state structure, adjusting multiple 64-bit fields' scale based on capacity and predefined configuration constants.",
    "filter2_prorec_aug_sum": "Initializes and normalizes a timestamp structure by zeroing it, setting base values, then scaling multiple 64-bit fields with shifts to ensure consistent internal time representation.",
    "filter2_prorec_aug2_sum": "Initializes and normalizes a hardware-related state structure, adjusting multiple 64-bit fields' scale based on capacity and predefined configuration constants.",
    "source_code": "static int do_sysinfo(struct sysinfo *info)\n{\n\tunsigned long mem_total, sav_total;\n\tunsigned int mem_unit, bitcount;\n\tstruct timespec tp;\n\n\tmemset(info, 0, sizeof(struct sysinfo));\n\n\tktime_get_ts(&tp);\n\tmonotonic_to_bootbased(&tp);\n\tinfo->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);\n\n\tget_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);\n\n\tinfo->procs = nr_threads;\n\n\tsi_meminfo(info);\n\tsi_swapinfo(info);\n\n\t/*\n\t * If the sum of all the available memory (i.e. ram + swap)\n\t * is less than can be stored in a 32 bit unsigned long then\n\t * we can be binary compatible with 2.2.x kernels.  If not,\n\t * well, in that case 2.2.x was broken anyways...\n\t *\n\t *  -Erik Andersen <andersee@debian.org>\n\t */\n\n\tmem_total = info->totalram + info->totalswap;\n\tif (mem_total < info->totalram || mem_total < info->totalswap)\n\t\tgoto out;\n\tbitcount = 0;\n\tmem_unit = info->mem_unit;\n\twhile (mem_unit > 1) {\n\t\tbitcount++;\n\t\tmem_unit >>= 1;\n\t\tsav_total = mem_total;\n\t\tmem_total <<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * If mem_total did not overflow, multiply all memory values by\n\t * info->mem_unit and set it to 1.  This leaves things compatible\n\t * with 2.2.x, and also retains compatibility with earlier 2.4.x\n\t * kernels...\n\t */\n\n\tinfo->mem_unit = 1;\n\tinfo->totalram <<= bitcount;\n\tinfo->freeram <<= bitcount;\n\tinfo->sharedram <<= bitcount;\n\tinfo->bufferram <<= bitcount;\n\tinfo->totalswap <<= bitcount;\n\tinfo->freeswap <<= bitcount;\n\tinfo->totalhigh <<= bitcount;\n\tinfo->freehigh <<= bitcount;\n\nout:\n\treturn 0;\n}",
    "decom_sum": "Initializes and normalizes a hardware-related state structure, adjusting multiple 64-bit fields' scale based on capacity and predefined configuration constants.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and normalizes a hardware-related state structure, adjusting multiple 64-bit fields' scale based on capacity and predefined configuration constants.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and normalizes a timestamp structure by zeroing it, setting base values, then scaling multiple 64-bit fields with shifts to ensure consistent internal time representation.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and normalizes a hardware-related state structure, adjusting multiple 64-bit fields' scale based on capacity and predefined configuration constants.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and updates buffer mark ranges in a DRM device structure based on given parameters and state flags.",
    "filter2_prorec_aug_sum": "Validates buffer parameters and updates specified DRM device mark buffer indices if all size and range checks pass; otherwise returns error code.",
    "filter2_prorec_aug2_sum": "Validates input and updates buffer markers for DRM based on specified indices and limits from device context.",
    "source_code": "int drm_markbufs(struct drm_device *dev, void *data,\n\t\t struct drm_file *file_priv)\n{\n\tstruct drm_device_dma *dma = dev->dma;\n\tstruct drm_buf_desc *request = data;\n\tint order;\n\tstruct drm_buf_entry *entry;\n\n\tif (!drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\treturn -EINVAL;\n\n\tif (!dma)\n\t\treturn -EINVAL;\n\n\tDRM_DEBUG(\"%d, %d, %d\\n\",\n\t\t  request->size, request->low_mark, request->high_mark);\n\torder = drm_order(request->size);\n\tif (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)\n\t\treturn -EINVAL;\n\tentry = &dma->bufs[order];\n\n\tif (request->low_mark < 0 || request->low_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\tif (request->high_mark < 0 || request->high_mark > entry->buf_count)\n\t\treturn -EINVAL;\n\n\tentry->freelist.low_mark = request->low_mark;\n\tentry->freelist.high_mark = request->high_mark;\n\n\treturn 0;\n}",
    "decom_sum": "Validates DRM buffer parameters and updates two buffer indices within a DRM structure after performing size alignment and bounds checking.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and updates buffer mark ranges in a DRM device structure based on given parameters and state flags.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates buffer parameters and updates specified DRM device mark buffer indices if all size and range checks pass; otherwise returns error code.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates input and updates buffer markers for DRM based on specified indices and limits from device context.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
    "filter2_prorec_aug_sum": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
    "filter2_prorec_aug2_sum": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
    "source_code": "\nstatic const char* findlocal(lua_State* L, CallInfo* ci, int n, StkId* pos) {\n  const char* name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0) /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  } else\n    base = ci->func + 1;\n  if (name == NULL) { /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) /* is 'n' inside 'ci' stack? */\n      name = \"(*temporary)\"; /* generic name for any valid slot */\n    else\n      return NULL; /* no name */\n  }\n  *pos = base + (n - 1);\n  return name;\n}",
    "decom_sum": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
            "flag": true,
            "score": [
                0.6,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
            "flag": true,
            "score": [
                0.7,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Resolves a function argument\u2019s memory address and returns a descriptive string for varargs or temporary values based on index and object metadata.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Prints the count and all key-value pairs from the global mu_assoc qword_2DFC80 to stream a1, enclosed by BEGIN and END IDENT STAT markers.",
    "filter2_prorec_aug_sum": "Prints to the given stream a summary of the global identifier association count and each key-value pair by iterating over all entries.",
    "filter2_prorec_aug2_sum": "Prints statistics about entries in the global mu_assoc collection by iterating and outputting each key and its associated value count.",
    "source_code": "  \nvoid\nmu_ident_stat (mu_stream_t str)\n{\n  size_t count, i;\n  mu_iterator_t itr;\n  \n  mu_stream_printf (str, \"BEGIN IDENT STAT\\n\");\n\n  mu_assoc_count (nametab, &count);\n  mu_stream_printf (str, \"N=%zu\\n\", count);\n\n  if (count > 0)\n    {\n      int rc = mu_assoc_get_iterator (nametab, &itr);\n      if (rc)\n\tmu_stream_printf (str, \"mu_assoc_get_iterator: %s\\n\",\n\t\t\t  mu_strerror (rc));\n      else\n\t{\n\t  i = 0;\n\t  for (mu_iterator_first (itr); !mu_iterator_is_done (itr);\n\t       mu_iterator_next (itr), i++)\n\t    {\n\t      const char *key;\n\t      struct mu_ident_ref *ref;\n\t      \n\t      mu_iterator_current_kv (itr,\n\t\t\t\t      (const void **)&key, (void **)&ref);  \n\t      mu_stream_printf (str, \"%04zu: %s: %zu\\n\", i, key, ref->count);\n\t    }\n\t}\n      mu_iterator_destroy (&itr);\n    }\n  mu_stream_printf (str, \"END IDENT STAT\\n\");\n}",
    "decom_sum": "Prints statistics of the global mu_assoc collection to a stream, including total count and each key-value pair in formatted output.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Prints the count and all key-value pairs from the global mu_assoc qword_2DFC80 to stream a1, enclosed by BEGIN and END IDENT STAT markers.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Prints to the given stream a summary of the global identifier association count and each key-value pair by iterating over all entries.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Prints statistics about entries in the global mu_assoc collection by iterating and outputting each key and its associated value count.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and validates two filter instances using input parameters, updates given data structures with these filters, and returns the result status code.",
    "filter2_prorec_aug_sum": "Performs data preparation and validation by generating two data sets from inputs, processing them with a context object, and updating output structures accordingly.",
    "filter2_prorec_aug2_sum": "Creates two filter records from input parameters, applies filtering using context data, updates output structures, and returns the filtering operation status code.",
    "source_code": "\nstatic int\nnfs3_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs3_linkargs\targ = {\n\t\t.fromfh\t\t= NFS_FH(inode),\n\t\t.tofh\t\t= NFS_FH(dir),\n\t\t.toname\t\t= name->name,\n\t\t.tolen\t\t= name->len\n\t};\n\tstruct nfs3_linkres\tres;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs3_procedures[NFS3PROC_LINK],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  link %s\\n\", name->name);\n\tres.fattr = nfs_alloc_fattr();\n\tres.dir_attr = nfs_alloc_fattr();\n\tif (res.fattr == NULL || res.dir_attr == NULL)\n\t\tgoto out;\n\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tnfs_post_op_update_inode(dir, res.dir_attr);\n\tnfs_post_op_update_inode(inode, res.fattr);\nout:\n\tnfs_free_fattr(res.dir_attr);\n\tnfs_free_fattr(res.fattr);\n\tdprintk(\"NFS reply link: %d\\n\", status);\n\treturn status;\n}",
    "decom_sum": "Generates two computed data sets from input parameters, stores them in related structures, processes them, and returns a status code from the main operation.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and validates two filter instances using input parameters, updates given data structures with these filters, and returns the result status code.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs data preparation and validation by generating two data sets from inputs, processing them with a context object, and updating output structures accordingly.",
            "flag": false,
            "score": [
                0.1,
                0.2,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Creates two filter records from input parameters, applies filtering using context data, updates output structures, and returns the filtering operation status code.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Calculates and returns the CPU frequency in MHz by measuring time differences and adjusting based on hardware time counters and scaling factors.",
    "filter2_prorec_aug_sum": "Calculates elapsed time between hardware counter readings and updates a stored rate value, invoking timing callbacks if deviation exceeds one percent.",
    "filter2_prorec_aug2_sum": "Calculates and returns system timer-based frequency metrics, updating global timing data and invoking related scheduler and logging functions.",
    "source_code": "static void tsc_refine_calibration_work(struct work_struct *work)\n{\n\tstatic u64 tsc_start = -1, ref_start;\n\tstatic int hpet;\n\tu64 tsc_stop, ref_stop, delta;\n\tunsigned long freq;\n\n\t/* Don't bother refining TSC on unstable systems */\n\tif (check_tsc_unstable())\n\t\tgoto out;\n\n\t/*\n\t * Since the work is started early in boot, we may be\n\t * delayed the first time we expire. So set the workqueue\n\t * again once we know timers are working.\n\t */\n\tif (tsc_start == -1) {\n\t\t/*\n\t\t * Only set hpet once, to avoid mixing hardware\n\t\t * if the hpet becomes enabled later.\n\t\t */\n\t\thpet = is_hpet_enabled();\n\t\tschedule_delayed_work(&tsc_irqwork, HZ);\n\t\ttsc_start = tsc_read_refs(&ref_start, hpet);\n\t\treturn;\n\t}\n\n\ttsc_stop = tsc_read_refs(&ref_stop, hpet);\n\n\t/* hpet or pmtimer available ? */\n\tif (ref_start == ref_stop)\n\t\tgoto out;\n\n\t/* Check, whether the sampling was disturbed by an SMI */\n\tif (tsc_start == ULLONG_MAX || tsc_stop == ULLONG_MAX)\n\t\tgoto out;\n\n\tdelta = tsc_stop - tsc_start;\n\tdelta *= 1000000LL;\n\tif (hpet)\n\t\tfreq = calc_hpet_ref(delta, ref_start, ref_stop);\n\telse\n\t\tfreq = calc_pmtimer_ref(delta, ref_start, ref_stop);\n\n\t/* Make sure we're within 1% */\n\tif (abs(tsc_khz - freq) > tsc_khz/100)\n\t\tgoto out;\n\n\ttsc_khz = freq;\n\tpr_info(\"Refined TSC clocksource calibration: %lu.%03lu MHz\\n\",\n\t\t(unsigned long)tsc_khz / 1000,\n\t\t(unsigned long)tsc_khz % 1000);\n\nout:\n\tclocksource_register_khz(&clocksource_tsc, tsc_khz);\n}",
    "decom_sum": "Calculates elapsed time between hardware counter readings and updates a stored rate value, invoking timing callbacks if deviation exceeds one percent.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Calculates and returns the CPU frequency in MHz by measuring time differences and adjusting based on hardware time counters and scaling factors.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates elapsed time between hardware counter readings and updates a stored rate value, invoking timing callbacks if deviation exceeds one percent.",
            "flag": true,
            "score": [
                0.6,
                0.5,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates and returns system timer-based frequency metrics, updating global timing data and invoking related scheduler and logging functions.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Handles device power-off by checking device status and invoking a registered power-off callback, falling back to a default handler if unavailable or failed.",
    "filter2_prorec_aug_sum": "Checks device power management state and either performs a power-off sequence or triggers a power-off handler callback, with fallback notification on failure.",
    "filter2_prorec_aug2_sum": "Checks device power state and either initiates power-off via callback or resets device if power-off fails or is unsupported.",
    "source_code": "\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n Fixup:\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}",
    "decom_sum": "Handles PCI device power-off by checking initialization status, invoking shutdown callbacks, and falling back to default power management routines if needed.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Handles device power-off by checking device status and invoking a registered power-off callback, falling back to a default handler if unavailable or failed.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks device power management state and either performs a power-off sequence or triggers a power-off handler callback, with fallback notification on failure.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks device power state and either initiates power-off via callback or resets device if power-off fails or is unsupported.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes and flushes pending objects from two lists, invoking sub_FFFFFFFF8112DCD0 on each referenced entry before resetting their respective counters to zero.",
    "filter2_prorec_aug_sum": "Processes and clears entries in two separate buffers by invoking sub_FFFFFFFF8112DCD0 with provided parameters, and resets their counts to zero.",
    "filter2_prorec_aug2_sum": "Processes and flushes pending objects from two lists, invoking sub_FFFFFFFF8112DCD0 on each referenced entry before resetting their respective counters to zero.",
    "source_code": "static void drm_cleanup_buf_error(struct drm_device * dev,\n\t\t\t\t  struct drm_buf_entry * entry)\n{\n\tint i;\n\n\tif (entry->seg_count) {\n\t\tfor (i = 0; i < entry->seg_count; i++) {\n\t\t\tif (entry->seglist[i]) {\n\t\t\t\tdrm_pci_free(dev, entry->seglist[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(entry->seglist);\n\n\t\tentry->seg_count = 0;\n\t}\n\n\tif (entry->buf_count) {\n\t\tfor (i = 0; i < entry->buf_count; i++) {\n\t\t\tkfree(entry->buflist[i].dev_private);\n\t\t}\n\t\tkfree(entry->buflist);\n\n\t\tentry->buf_count = 0;\n\t}\n}",
    "decom_sum": "Processes and flushes pending objects from two lists, invoking sub_FFFFFFFF8112DCD0 on each referenced entry before resetting their respective counters to zero.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes and flushes pending objects from two lists, invoking sub_FFFFFFFF8112DCD0 on each referenced entry before resetting their respective counters to zero.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes and clears entries in two separate buffers by invoking sub_FFFFFFFF8112DCD0 with provided parameters, and resets their counts to zero.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes and flushes pending objects from two lists, invoking sub_FFFFFFFF8112DCD0 on each referenced entry before resetting their respective counters to zero.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Updates the string at a specified index in an array, reallocating memory if needed, and triggers a failure event if the new string exceeds the buffer size.",
    "filter2_prorec_aug_sum": "Updates a string entry in an indexed array, adjusting available buffer space, and triggers failure handling if space is insufficient or allocation fails.",
    "filter2_prorec_aug2_sum": "Replaces the string at a specified index in an array with a new string, managing buffer size and triggering failure if the new string exceeds available space.",
    "source_code": "int Xorriso_register_node_target(struct XorrisO *xorriso, int node_idx,\n                                 char *disk_path, int flag)\n{\n int l;\n\n if(xorriso->node_targets_availmem == 0)\n   return(2);\n if(xorriso->hln_targets == NULL || node_idx < 0 ||\n    node_idx >= xorriso->hln_count)\n   return(0);\n if(xorriso->hln_targets[node_idx] != NULL) {\n   xorriso->node_targets_availmem+= strlen(xorriso->hln_targets[node_idx]) +1;\n   free(xorriso->hln_targets[node_idx]);\n }\n l= strlen(disk_path);\n if(xorriso->node_targets_availmem <= l + 1) {\n   sprintf(xorriso->info_text,\n \"Hardlink target buffer exceeds -temp_mem_limit. Hardlinks may get divided.\");\n   Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0, \"FAILURE\", 0);\n   xorriso->node_targets_availmem= 0;\n   return(0);\n }\n xorriso->hln_targets[node_idx]= strdup(disk_path);\n if(xorriso->hln_targets[node_idx] == NULL) {\n   Xorriso_no_malloc_memory(xorriso, NULL, 0);\n   return(-1);\n }\n xorriso->node_targets_availmem-= (l + 1);\n return(1);\n}",
    "decom_sum": "Updates a string entry in an indexed array, adjusting available buffer space, and triggers failure handling if space is insufficient or allocation fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Updates the string at a specified index in an array, reallocating memory if needed, and triggers a failure event if the new string exceeds the buffer size.",
            "flag": false,
            "score": [
                0.8,
                0.6,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates a string entry in an indexed array, adjusting available buffer space, and triggers failure handling if space is insufficient or allocation fails.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Replaces the string at a specified index in an array with a new string, managing buffer size and triggering failure if the new string exceeds available space.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
    "filter2_prorec_aug_sum": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
    "filter2_prorec_aug2_sum": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
    "source_code": "\nstatic const char *\nget_symbol_index_type (Filedata * filedata, unsigned int type)\n{\n  static char buff[32];\n\n  switch (type)\n    {\n    case SHN_UNDEF:\treturn \"UND\";\n    case SHN_ABS:\treturn \"ABS\";\n    case SHN_COMMON:\treturn \"COM\";\n    default:\n      if (type == SHN_IA_64_ANSI_COMMON\n\t  && filedata->file_header.e_machine == EM_IA_64\n\t  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)\n\treturn \"ANSI_COM\";\n      else if ((filedata->file_header.e_machine == EM_X86_64\n\t\t|| filedata->file_header.e_machine == EM_L1OM\n\t\t|| filedata->file_header.e_machine == EM_K1OM)\n\t       && type == SHN_X86_64_LCOMMON)\n\treturn \"LARGE_COM\";\n      else if ((type == SHN_MIPS_SCOMMON\n\t\t&& filedata->file_header.e_machine == EM_MIPS)\n\t       || (type == SHN_TIC6X_SCOMMON\n\t\t   && filedata->file_header.e_machine == EM_TI_C6000))\n\treturn \"SCOM\";\n      else if (type == SHN_MIPS_SUNDEFINED\n\t       && filedata->file_header.e_machine == EM_MIPS)\n\treturn \"SUND\";\n      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)\n\tsprintf (buff, \"PRC[0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LOOS && type <= SHN_HIOS)\n\tsprintf (buff, \"OS [0x%04x]\", type & 0xffff);\n      else if (type >= SHN_LORESERVE)\n\tsprintf (buff, \"RSV[0x%04x]\", type & 0xffff);\n      else if (type >= filedata->file_header.e_shnum)\n\tsprintf (buff, _(\"bad section index[%3d]\"), type);\n      else\n\tsprintf (buff, \"%3d\", type);\n      break;\n    }\n\n  return buff;\n}",
    "decom_sum": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Maps section type codes and related header fields to descriptive strings or formatted hex values for display or reporting purposes.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
    "filter2_prorec_aug_sum": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
    "filter2_prorec_aug2_sum": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
    "source_code": "\nvoid *\nFcompile (char *pattern, idx_t size, reg_syntax_t ignored, bool exact)\n{\n  kwset_t kwset;\n  char *buf = NULL;\n  idx_t bufalloc = 0;\n\n  kwset = kwsinit (true);\n\n  char const *p = pattern;\n  do\n    {\n      char const *sep = rawmemchr (p, '\\n');\n      idx_t len = sep - p;\n\n      if (match_lines)\n        {\n          if (eolbyte == '\\n' && pattern < p)\n            p--;\n          else\n            {\n              if (bufalloc < len + 2)\n                {\n                  free (buf);\n                  bufalloc = len;\n                  buf = xpalloc (NULL, &bufalloc, 2, -1, 1);\n                  buf[0] = eolbyte;\n                }\n              memcpy (buf + 1, p, len);\n              buf[len + 1] = eolbyte;\n              p = buf;\n            }\n          len += 2;\n        }\n      kwsincr (kwset, p, len);\n\n      p = sep + 1;\n    }\n  while (p <= pattern + size);\n\n  free (buf);\n\n  idx_t words = kwswords (kwset);\n  kwsprep (kwset);\n\n  struct kwsearch *kwsearch = xmalloc (sizeof *kwsearch);\n  kwsearch->kwset = kwset;\n  kwsearch->words = words;\n  kwsearch->pattern = pattern;\n  kwsearch->size = size;\n  kwsearch->re = NULL;\n  return kwsearch;\n}",
    "decom_sum": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses newline-delimited data from `src`, conditionally transforms lines, stores them in a new obstack, and returns a structured result containing both original and processed data.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks and updates hardware state, then iterates device list to trigger specific handlers for flagged or newest entries based on predefined conditions.",
    "filter2_prorec_aug_sum": "Checks device state changes, updates status, and triggers handlers on flagged or highest-priority device events, returning success if any events handled.",
    "filter2_prorec_aug2_sum": "Checks and updates hardware state, then iterates device list to trigger specific handlers for flagged or newest entries based on predefined conditions.",
    "source_code": "bool pm_wakeup_pending(void)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&events_lock, flags);\n\tif (events_check_enabled) {\n\t\tunsigned int cnt, inpr;\n\n\t\tsplit_counters(&cnt, &inpr);\n\t\tret = (cnt != saved_count || inpr > 0);\n\t\tevents_check_enabled = !ret;\n\t}\n\tspin_unlock_irqrestore(&events_lock, flags);\n\n\tif (ret)\n\t\tprint_active_wakeup_sources();\n\n\treturn ret;\n}",
    "decom_sum": "Checks and updates hardware state, then iterates device list to trigger specific handlers for flagged or newest entries based on predefined conditions.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks and updates hardware state, then iterates device list to trigger specific handlers for flagged or newest entries based on predefined conditions.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks device state changes, updates status, and triggers handlers on flagged or highest-priority device events, returning success if any events handled.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks and updates hardware state, then iterates device list to trigger specific handlers for flagged or newest entries based on predefined conditions.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates a 40-byte aligned chunk from obstack, initializes it with provided parameters, sets flags, and registers the new object for reference tracking.",
    "filter2_prorec_aug_sum": "Allocates a 40-byte object in an obstack, stores parameters and metadata, updates alignment, and registers it via sub_411620.",
    "filter2_prorec_aug2_sum": "Allocates a 40-byte aligned obstack object, initializes it with given parameters, updates obstack pointers, and registers the object via sub_411620.",
    "source_code": "\nstruct local_symbol *\nlocal_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n{\n  const char *name_copy;\n  struct local_symbol *ret;\n\n  ++local_symbol_count;\n\n  name_copy = save_symbol_name (name);\n\n  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n  ret->lsy_flags.sy_local_symbol = 1;\n  ret->lsy_flags.sy_resolved = 0;\n  ret->lsy_name = name_copy;\n  ret->lsy_section = section;\n  local_symbol_set_frag (ret, frag);\n  ret->lsy_value = val;\n\n  hash_jam (local_hash, name_copy, (void *) ret);\n\n  return ret;\n}",
    "decom_sum": "Allocates a 40-byte object in an obstack, stores parameters and metadata, updates alignment, and registers it via sub_411620.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates a 40-byte aligned chunk from obstack, initializes it with provided parameters, sets flags, and registers the new object for reference tracking.",
            "flag": false,
            "score": [
                0.4,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates a 40-byte object in an obstack, stores parameters and metadata, updates alignment, and registers it via sub_411620.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates a 40-byte aligned obstack object, initializes it with given parameters, updates obstack pointers, and registers the object via sub_411620.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
    "filter2_prorec_aug_sum": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
    "filter2_prorec_aug2_sum": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
    "source_code": "\nstatic void\ngss_pipe_release(struct inode *inode)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tstruct gss_upcall_msg *gss_msg;\n\nrestart:\n\tspin_lock(&pipe->lock);\n\tlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\n\n\t\tif (!list_empty(&gss_msg->msg.list))\n\t\t\tcontinue;\n\t\tgss_msg->msg.errno = -EPIPE;\n\t\tatomic_inc(&gss_msg->count);\n\t\t__gss_unhash_msg(gss_msg);\n\t\tspin_unlock(&pipe->lock);\n\t\tgss_release_msg(gss_msg);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&pipe->lock);\n\n\tput_pipe_version(net);\n}",
    "decom_sum": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates through a linked list of objects, updating their state and invoking two processing callbacks before returning a final computed result.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
    "filter2_prorec_aug_sum": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
    "filter2_prorec_aug2_sum": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
    "source_code": "void FAST_FUNC add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name)\n{\n\tint i;\n\tino_dev_hashtable_bucket_t *bucket;\n\n\tif (!name)\n\t\tname = \"\";\n\tbucket = xmalloc(sizeof(ino_dev_hashtable_bucket_t) + strlen(name));\n\tbucket->ino = statbuf->st_ino;\n\tbucket->dev = statbuf->st_dev;\n\tbucket->isdir = !!S_ISDIR(statbuf->st_mode);\n\tstrcpy(bucket->name, name);\n\n\tif (!ino_dev_hashtable)\n\t\tino_dev_hashtable = xzalloc(HASH_SIZE * sizeof(*ino_dev_hashtable));\n\n\ti = hash_inode(statbuf->st_ino);\n\tbucket->next = ino_dev_hashtable[i];\n\tino_dev_hashtable[i] = bucket;\n}",
    "decom_sum": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Creates and links a new data node into a hash table using input parameters and initializes it from existing structure and default values.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
    "filter2_prorec_aug_sum": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
    "filter2_prorec_aug2_sum": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
    "source_code": "int loadkmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct kbentry ke;\n\tint i, j, fd;\n\tuint16_t ibuff[NR_KEYS];\n/*\tconst char *tty_name = CURRENT_TTY; */\n\tRESERVE_CONFIG_BUFFER(flags, MAX_NR_KEYMAPS);\n\n\t/* When user accidentally runs \"loadkmap FILE\"\n\t * instead of \"loadkmap <FILE\", we end up waiting for input from tty.\n\t * Let's prevent it: */\n\tif (argv[1])\n\t\tbb_show_usage();\n/* bb_warn_ignoring_args(argv[1]); */\n\n\tfd = get_console_fd_or_die();\n/* or maybe:\n\topt = getopt32(argv, \"C:\", &tty_name);\n\tfd = xopen_nonblocking(tty_name);\n*/\n\n\txread(STDIN_FILENO, flags, 7);\n\tif (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))\n\t\tbb_error_msg_and_die(\"not a valid binary keymap\");\n\n\txread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);\n\n\tfor (i = 0; i < MAX_NR_KEYMAPS; i++) {\n\t\tif (flags[i] != 1)\n\t\t\tcontinue;\n\t\txread(STDIN_FILENO, ibuff, NR_KEYS * sizeof(uint16_t));\n\t\tfor (j = 0; j < NR_KEYS; j++) {\n\t\t\tke.kb_index = j;\n\t\t\tke.kb_table = i;\n\t\t\tke.kb_value = ibuff[j];\n\t\t\t/*\n\t\t\t * Note: table[idx:0] can contain special value\n\t\t\t * K_ALLOCATED (marks allocated tables in kernel).\n\t\t\t * dumpkmap saves the value as-is; but attempts\n\t\t\t * to load it here fail, since it isn't a valid\n\t\t\t * key value: it is K(KT_SPEC,126) == 2<<8 + 126,\n\t\t\t * whereas last valid KT_SPEC is\n\t\t\t * K_BARENUMLOCK == K(KT_SPEC,19).\n\t\t\t * So far we just ignore these errors:\n\t\t\t */\n\t\t\tioctl(fd, KDSKBENT, &ke);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t\tRELEASE_CONFIG_BUFFER(flags);\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "decom_sum": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses a binary keymap file and sends each defined key mapping to the device using the 0x4B47 command code.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks chipset compatibility, then prints GPU, CPU, and ring frequencies in MHz per performance state, looping through performance levels and formatting frequency data output.",
    "filter2_prorec_aug_sum": "Checks GPU chipset compatibility and outputs GPU, CPU, and ring frequencies per performance state or prints unsupported message otherwise.",
    "filter2_prorec_aug2_sum": "Prints GPU, CPU, and Ring effective frequencies if supported, iterating over hardware units and formatting their MHz values in a tabulated output.",
    "source_code": "\nstatic int i915_ring_freq_table(struct seq_file *m, void *unused)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct drm_device *dev = node->minor->dev;\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tint ret;\n\tint gpu_freq, ia_freq;\n\n\tif (!(IS_GEN6(dev) || IS_GEN7(dev))) {\n\t\tseq_printf(m, \"unsupported on this chipset\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mutex_lock_interruptible(&dev_priv->rps.hw_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"GPU freq (MHz)\\tEffective CPU freq (MHz)\\tEffective Ring freq (MHz)\\n\");\n\n\tfor (gpu_freq = dev_priv->rps.min_delay;\n\t     gpu_freq <= dev_priv->rps.max_delay;\n\t     gpu_freq++) {\n\t\tia_freq = gpu_freq;\n\t\tsandybridge_pcode_read(dev_priv,\n\t\t\t\t       GEN6_PCODE_READ_MIN_FREQ_TABLE,\n\t\t\t\t       &ia_freq);\n\t\tseq_printf(m, \"%d\\t\\t%d\\t\\t\\t\\t%d\\n\",\n\t\t\t   gpu_freq * GT_FREQUENCY_MULTIPLIER,\n\t\t\t   ((ia_freq >> 0) & 0xff) * 100,\n\t\t\t   ((ia_freq >> 8) & 0xff) * 100);\n\t}\n\n\tmutex_unlock(&dev_priv->rps.hw_lock);\n\n\treturn 0;\n}",
    "decom_sum": "Outputs GPU, CPU, and Ring frequency data in MHz for supported chipsets, iterating measurements and formatting results for display.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks chipset compatibility, then prints GPU, CPU, and ring frequencies in MHz per performance state, looping through performance levels and formatting frequency data output.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks GPU chipset compatibility and outputs GPU, CPU, and ring frequencies per performance state or prints unsupported message otherwise.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Prints GPU, CPU, and Ring effective frequencies if supported, iterating over hardware units and formatting their MHz values in a tabulated output.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
    "filter2_prorec_aug_sum": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
    "filter2_prorec_aug2_sum": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
    "source_code": "\nstatic void\nlisting_page (list_info_type *list)\n{\n  /* Grope around, see if we can see a title or subtitle edict coming up\n     soon.  (we look down 10 lines of the page and see if it's there)  */\n  if ((eject || (on_page >= (unsigned int) paper_height))\n      && paper_height != 0)\n    {\n      unsigned int c = 10;\n      int had_title = 0;\n      int had_subtitle = 0;\n\n      page++;\n\n      while (c != 0 && list)\n\t{\n\t  if (list->edict == EDICT_SBTTL && !had_subtitle)\n\t    {\n\t      had_subtitle = 1;\n\t      subtitle = list->edict_arg;\n\t    }\n\t  if (list->edict == EDICT_TITLE && !had_title)\n\t    {\n\t      had_title = 1;\n\t      title = list->edict_arg;\n\t    }\n\t  list = list->next;\n\t  c--;\n\t}\n\n      if (page > 1)\n\t{\n\t  fprintf (list_file, \"\\f\");\n\t}\n\n      fprintf (list_file, \"%s %s \\t\\t\\tpage %d\\n\", LISTING_HEADER, fn, page);\n      fprintf (list_file, \"%s\\n\", title);\n      fprintf (list_file, \"%s\\n\", subtitle);\n      on_page = 3;\n      eject = 0;\n    }\n}",
    "decom_sum": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Generates a new GAS listing page header and prints stored section names to the output file, updating global pagination and state variables.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks convergence criteria in a GSL multifit solver by comparing parameter step size and residual norms against specified tolerances and sets status codes accordingly.",
    "filter2_prorec_aug_sum": "Checks convergence criteria for a nonlinear multifit solver by comparing parameter and residual changes against thresholds, then sets status accordingly.",
    "filter2_prorec_aug2_sum": "Checks convergence of a gsl multifit solver using delta and residual thresholds, updating status codes based on step size and residual norms.",
    "source_code": "\nint\ngsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * s,\n                             const double xtol, const double gtol,\n                             const double ftol, int *info)\n{\n  int status;\n  double gnorm, fnorm, phi;\n\n  *info = 0;\n\n  status = gsl_multifit_test_delta(s->dx, s->x, xtol*xtol, xtol);\n  if (status == GSL_SUCCESS)\n    {\n      *info = 1;\n      return GSL_SUCCESS;\n    }\n\n  /* compute gradient g = J^T f */\n  (s->type->gradient) (s->state, s->g);\n\n  /* compute gnorm = max_i( g_i * max(x_i, 1) ) */\n  gnorm = scaled_infnorm(s->x, s->g);\n\n  /* compute fnorm = ||f|| */\n  fnorm = gsl_blas_dnrm2(s->f);\n  phi = 0.5 * fnorm * fnorm;\n\n  if (gnorm <= gtol * GSL_MAX(phi, 1.0))\n    {\n      *info = 2;\n      return GSL_SUCCESS;\n    }\n\n#if 0\n  if (dfnorm <= ftol * GSL_MAX(fnorm, 1.0))\n    {\n      *info = 3;\n      return GSL_SUCCESS;\n    }\n#endif\n\n  return GSL_CONTINUE;\n}",
    "decom_sum": "Evaluates nonlinear least-squares solver convergence by delta and residual norms, updating status codes and returning early termination or success indicators.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks convergence criteria in a GSL multifit solver by comparing parameter step size and residual norms against specified tolerances and sets status codes accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks convergence criteria for a nonlinear multifit solver by comparing parameter and residual changes against thresholds, then sets status accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks convergence of a gsl multifit solver using delta and residual thresholds, updating status codes based on step size and residual norms.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
    "filter2_prorec_aug_sum": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
    "filter2_prorec_aug2_sum": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
    "source_code": "\nZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem)\n{\n    ZSTD_CStream* zcs;\n\n    if (!customMem.customAlloc && !customMem.customFree) customMem = defaultCustomMem;\n    if (!customMem.customAlloc || !customMem.customFree) return NULL;\n\n    zcs = (ZSTD_CStream*)ZSTD_malloc(sizeof(ZSTD_CStream), customMem);\n    if (zcs==NULL) return NULL;\n    memset(zcs, 0, sizeof(ZSTD_CStream));\n    memcpy(&zcs->customMem, &customMem, sizeof(ZSTD_customMem));\n    zcs->cctx = ZSTD_createCCtx_advanced(customMem);\n    if (zcs->cctx == NULL) { ZSTD_freeCStream(zcs); return NULL; }\n    return zcs;\n}",
    "decom_sum": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes a 200-byte structure with function callbacks, then constructs its internal state via sub_28F50 or cleans up on failure.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses input bytes from a stream updating state and output buffer until termination state or buffer limits, handling carriage return and dot sequences specially.",
    "filter2_prorec_aug_sum": "Parses an input buffer byte-by-byte, updates a parsing state with specific rules for carriage return and dot characters, and writes filtered output accordingly.",
    "filter2_prorec_aug2_sum": "Parses input bytes, updating state machine on characters including carriage return and dot, and stores processed output until termination state or limits reached.",
    "source_code": "static enum mu_filter_result\n_crlfdot_decoder (void *xd,\n\t\t  enum mu_filter_command cmd,\n\t\t  struct mu_filter_io *iobuf)\n{\n  int *pstate = xd;\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n\n  switch (cmd)\n    {\n    case mu_filter_init:\n      *pstate = crlfdot_decode_init;\n      return mu_filter_ok;\n      \n    case mu_filter_done:\n      return mu_filter_ok;\n      \n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; *pstate != crlfdot_decode_end && i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n\n      if (c == '\\r')\n\t{\n\t  if (i + 1 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr == '\\n')\n\t    continue;\n\t}\n      else if (c == '.' &&\n\t       (*pstate == crlfdot_decode_init ||\n\t\t*pstate == crlfdot_decode_crlf))\n\t{\n\t  /* Make sure we have two more characters in the buffer */\n\t  if (i + 2 == isize)\n\t    break;\n\t  *pstate = new_decode_state (*pstate, c);\n\t  if (*iptr != '\\r')\n\t    continue;\n\t}\n      else\n\t*pstate = new_decode_state (*pstate, c);\n      optr[j++] = c;\n    }\n  \n  if (*pstate == crlfdot_decode_end)\n    {\n      j -= 2; /* remove the trailing .\\n */\n      iobuf->eof = 1;\n    }\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "decom_sum": "Parses an input byte stream into a buffer, updating a state machine via `sub_61307` until completion or termination conditions are met.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses input bytes from a stream updating state and output buffer until termination state or buffer limits, handling carriage return and dot sequences specially.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses an input buffer byte-by-byte, updates a parsing state with specific rules for carriage return and dot characters, and writes filtered output accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses input bytes, updating state machine on characters including carriage return and dot, and stores processed output until termination state or limits reached.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
    "filter2_prorec_aug_sum": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
    "filter2_prorec_aug2_sum": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
    "source_code": "\nstatic int\ntry_load_plugin (const char *pname, bfd *abfd, int *has_plugin_p)\n{\n  void *plugin_handle;\n  struct ld_plugin_tv tv[4];\n  int i;\n  ld_plugin_onload onload;\n  enum ld_plugin_status status;\n\n  *has_plugin_p = 0;\n\n  plugin_handle = dlopen (pname, RTLD_NOW);\n  if (!plugin_handle)\n    {\n      _bfd_error_handler (\"%s\\n\", dlerror ());\n      return 0;\n    }\n\n  onload = dlsym (plugin_handle, \"onload\");\n  if (!onload)\n    goto err;\n\n  i = 0;\n  tv[i].tv_tag = LDPT_MESSAGE;\n  tv[i].tv_u.tv_message = message;\n\n  ++i;\n  tv[i].tv_tag = LDPT_REGISTER_CLAIM_FILE_HOOK;\n  tv[i].tv_u.tv_register_claim_file = register_claim_file;\n\n  ++i;\n  tv[i].tv_tag = LDPT_ADD_SYMBOLS;\n  tv[i].tv_u.tv_add_symbols = add_symbols;\n\n  ++i;\n  tv[i].tv_tag = LDPT_NULL;\n  tv[i].tv_u.tv_val = 0;\n\n  status = (*onload)(tv);\n\n  if (status != LDPS_OK)\n    goto err;\n\n  *has_plugin_p = 1;\n\n  abfd->plugin_format = bfd_plugin_no;\n\n  if (!claim_file)\n    goto err;\n\n  if (!try_claim (abfd))\n    goto err;\n\n  abfd->plugin_format = bfd_plugin_yes;\n\n  return 1;\n\n err:\n  return 0;\n}",
    "decom_sum": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
            "flag": true,
            "score": [
                0.3,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Loads a shared library, executes its `onload` initialization, and updates device state flags using file descriptor positioning and custom callbacks.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Traverses nodes starting at a2 to process child nodes of type 1, inserting specific nodes into a1 matching their XML string identifiers.",
    "filter2_prorec_aug_sum": "Traverses XML nodes starting from a2 to locate elements with type 1, then matches and inserts corresponding data into the structure pointed by a1 using xmlStrEqual comparisons.",
    "filter2_prorec_aug2_sum": "Traverses nodes starting at a2 to find type-1 nodes, then for each associated node, inserts or updates entries in the list pointed to by *a1 matching XML node names.",
    "source_code": "static int\nxmlDOMWrapNSNormGatherInScopeNs(xmlNsMapPtr *map,\n\t\t\t\txmlNodePtr node)\n{\n    xmlNodePtr cur;\n    xmlNsPtr ns;\n    xmlNsMapItemPtr mi;\n    int shadowed;\n\n    if ((map == NULL) || (*map != NULL))\n\treturn (-1);\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))\n        return (-1);\n    /*\n    * Get in-scope ns-decls of @parent.\n    */\n    cur = node;\n    while ((cur != NULL) && (cur != (xmlNodePtr) cur->doc)) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    if (cur->nsDef != NULL) {\n\t\tns = cur->nsDef;\n\t\tdo {\n\t\t    shadowed = 0;\n\t\t    if (XML_NSMAP_NOTEMPTY(*map)) {\n\t\t\t/*\n\t\t\t* Skip shadowed prefixes.\n\t\t\t*/\n\t\t\tXML_NSMAP_FOREACH(*map, mi) {\n\t\t\t    if ((ns->prefix == mi->newNs->prefix) ||\n\t\t\t\txmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n\t\t\t\tshadowed = 1;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t    * Insert mapping.\n\t\t    */\n\t\t    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n\t\t\tns, XML_TREE_NSMAP_PARENT);\n\t\t    if (mi == NULL)\n\t\t\treturn (-1);\n\t\t    if (shadowed)\n\t\t\tmi->shadowDepth = 0;\n\t\t    ns = ns->next;\n\t\t} while (ns != NULL);\n\t    }\n\t}\n\tcur = cur->parent;\n    }\n    return (0);\n}",
    "decom_sum": "Processes XML element siblings with type 1 by matching names and inserting them into the target list using sub_51530.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Traverses nodes starting at a2 to process child nodes of type 1, inserting specific nodes into a1 matching their XML string identifiers.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Traverses XML nodes starting from a2 to locate elements with type 1, then matches and inserts corresponding data into the structure pointed by a1 using xmlStrEqual comparisons.",
            "flag": false,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Traverses nodes starting at a2 to find type-1 nodes, then for each associated node, inserts or updates entries in the list pointed to by *a1 matching XML node names.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
    "filter2_prorec_aug_sum": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
    "filter2_prorec_aug2_sum": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
    "source_code": "\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct led_classdev *led_cdev = dev_get_drvdata(dev);\n\tstruct led_trigger *trig;\n\tint len = 0;\n\n\tdown_read(&triggers_list_lock);\n\tdown_read(&led_cdev->trigger_lock);\n\n\tif (!led_cdev->trigger)\n\t\tlen += sprintf(buf+len, \"[none] \");\n\telse\n\t\tlen += sprintf(buf+len, \"none \");\n\n\tlist_for_each_entry(trig, &trigger_list, next_trig) {\n\t\tif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\n\t\t\t\t\t\t\ttrig->name))\n\t\t\tlen += sprintf(buf+len, \"[%s] \", trig->name);\n\t\telse\n\t\t\tlen += sprintf(buf+len, \"%s \", trig->name);\n\t}\n\tup_read(&led_cdev->trigger_lock);\n\tup_read(&triggers_list_lock);\n\n\tlen += sprintf(len+buf, \"\\n\");\n\treturn len;\n}",
    "decom_sum": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Builds a status string in `a11` describing the active configuration entries from a global list and returns its final length including newline.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
    "filter2_prorec_aug_sum": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
    "filter2_prorec_aug2_sum": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
    "source_code": "\nvoid ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t__be32 saddr = iph->saddr;\n\t__be32 daddr = iph->daddr;\n\n\t/* We assume the packet has already been checked by icmp_rcv */\n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t/* Push ICMP header back */\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph->un.echo.id),\n\t\t\t    skb->dev->ifindex);\n\tif (sk != NULL) {\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tping_queue_rcv_skb(sk, skb_get(skb));\n\t\tsock_put(sk);\n\t\treturn;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\n\t/* We're called from icmp_rcv(). kfree_skb() is done there. */\n}",
    "decom_sum": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
            "flag": true,
            "score": [
                0.3,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
            "flag": true,
            "score": [
                0.3,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and updates a data structure from memory offsets, invokes processing routines with given parameters, and handles reference counting and cleanup when usage drops to zero.",
            "flag": true,
            "score": [
                0.2,
                0.1,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and configures a data structure from a1, updates linked list pointers, calls validation and processing routines, then finalizes and returns success or error code.",
    "filter2_prorec_aug_sum": "Removes an object from linked structures, invokes its cleanup routines and callbacks, updates reference counters, and finalizes global state synchronization.",
    "filter2_prorec_aug2_sum": "Initializes and resets data structures at a1, processes a substructure via sub_FFFFFFFF81587760, updates state, invokes a callback if set, then performs final processing and cleanup.",
    "source_code": "static int snd_seq_device_free(struct snd_seq_device *dev)\n{\n\tstruct ops_list *ops;\n\n\tif (snd_BUG_ON(!dev))\n\t\treturn -EINVAL;\n\n\tops = find_driver(dev->id, 0);\n\tif (ops == NULL)\n\t\treturn -ENXIO;\n\n\t/* remove the device from the list */\n\tmutex_lock(&ops->reg_mutex);\n\tlist_del(&dev->list);\n\tops->num_devices--;\n\tmutex_unlock(&ops->reg_mutex);\n\n\tfree_device(dev, ops);\n\tif (dev->private_free)\n\t\tdev->private_free(dev);\n\tkfree(dev);\n\n\tunlock_driver(ops);\n\n\treturn 0;\n}",
    "decom_sum": "Removes an object from linked structures, invokes its cleanup routines and callbacks, updates reference counters, and finalizes global state synchronization.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and configures a data structure from a1, updates linked list pointers, calls validation and processing routines, then finalizes and returns success or error code.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Removes an object from linked structures, invokes its cleanup routines and callbacks, updates reference counters, and finalizes global state synchronization.",
            "flag": true,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and resets data structures at a1, processes a substructure via sub_FFFFFFFF81587760, updates state, invokes a callback if set, then performs final processing and cleanup.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Packages and stores buffered data from the given structure into a dynamically resized array after conditionally processing and clearing state fields.",
    "filter2_prorec_aug_sum": "Packages and stores buffered data from the given structure into a dynamically resized array after conditionally processing and clearing state fields.",
    "filter2_prorec_aug2_sum": "Encodes the current state and buffer into a newly allocated structure, appends it to a dynamically resized array, and resets the buffer count.",
    "source_code": "static void\nmixed_string_buffer_flush_curr (struct mixed_string_buffer *bp)\n{\n  if (bp->curr_type == utf8_encoded)\n    mixed_string_buffer_flush_utf16_surr (bp);\n  if (bp->curr_type != -1)\n    {\n      if (bp->curr_buflen > 0)\n        {\n          struct mixed_string_segment *segment =\n            segment_alloc (bp->curr_type, bp->curr_buffer, bp->curr_buflen);\n          mixed_string_buffer_add_segment (bp, segment);\n        }\n      bp->curr_buflen = 0;\n    }\n}",
    "decom_sum": "Packages and stores buffered data from the given structure into a dynamically resized array after conditionally processing and clearing state fields.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Packages and stores buffered data from the given structure into a dynamically resized array after conditionally processing and clearing state fields.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Packages and stores buffered data from the given structure into a dynamically resized array after conditionally processing and clearing state fields.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Encodes the current state and buffer into a newly allocated structure, appends it to a dynamically resized array, and resets the buffer count.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
    "filter2_prorec_aug_sum": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
    "filter2_prorec_aug2_sum": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
    "source_code": "\nstruct sequence *\nnew_C_string_sequence (const char * delimitor)\n{\n  struct sequence * res = XMALLOC (struct sequence, 1);\n  res->open = rule_new (xustrdup (delimitor), NULL,\n\t\t\trhs_new_single (NULL, 0, Plain_fface),\n\t\t\t__FILE__, __LINE__);\n  res->face = String_fface;\n  res->exceptions = new_C_exceptions ();\n  res->close = words_new (\"C Close: strings\", \"C Close: regex\", 5, 5);\n  words_add_string (res->close,\n\t\t    rule_new (xustrdup (delimitor), NULL,\n\t\t\t      rhs_new_single (NULL, 0, Plain_fface),\n\t\t\t      __FILE__, __LINE__));\n  words_finalize (res->close);\n  return res;\n}",
    "decom_sum": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
            "flag": true,
            "score": [
                0.6,
                0.3,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
            "flag": true,
            "score": [
                0.6,
                0.3,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Constructs and returns a C language parser object, initializing rules for string and regex handling with specific escape sequence exception patterns.",
            "flag": true,
            "score": [
                0.6,
                0.4,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses and extracts detailed format 10h read disc structure information from a device buffer, populating output parameters and validating response length.",
    "filter2_prorec_aug_sum": "Parses and extracts disc structure information from device data format 0x10, populating output parameters and freeing allocated buffer.",
    "filter2_prorec_aug2_sum": "Parses and extracts DVD disc structure format 0x10 response, computing parameters like layer number, start sector, and sector count, validating response length.",
    "source_code": "int mmc_get_phys_format_info(struct burn_drive *d, int *disk_category,\n\t\t\tchar **book_name, int *part_version, int *num_layers,\n\t\t\tint *num_blocks, int flag)\n{\n\tint ret, reply_len, prf;\n\tchar *reply = NULL;\n\tstatic char book_names[][16] = {\n\t\t\"DVD-ROM\", \"DVD-RAM\", \"DVD-R\", \"DVD-RW\",\n\t\t\"HD DVD-ROM\", \"HD DVD-RAM\", \"HD DVD-R\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW\", \"DVD+R\", \"unknown\", \"unknown\",\n\t\t\"unknown\", \"DVD+RW DL\", \"DVD+R DL\", \"unknown\"\n\t};\n\n\tprf = d->current_profile;\n\tif (!(prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15 ||\n\t      prf == 0x51))\n\t\treturn 0; /* Not a [HD] DVD-R[W] loaded */\n\tret = mmc_read_disc_structure(d, 0, 0, 0x10, 12, &reply,\n\t\t\t\t\t\t\t &reply_len, 0);\n\tif (ret <= 0)\n\t\tgoto ex;\n\tif(reply_len < 12) {\n\t\tlibdax_msgs_submit(libdax_messenger, -1, 0x00000002,\n\t\t\tLIBDAX_MSGS_SEV_DEBUG, LIBDAX_MSGS_PRIO_ZERO,\n\t\t\t\"READ DISC STRUCTURE format 10h: Less than 12 bytes\",\n\t\t\t0, 0);\n\t\t{ret = 0; goto ex;}\n\t}\n\t*disk_category = (reply[0] >> 4) & 0xf;\n\t*book_name = book_names[*disk_category];\n\t*part_version = reply[0] & 0xf;\n\t*num_layers = ((reply[2] >> 5) & 0x3) + 1;\n\t*num_blocks = ((reply[9] << 16) | (reply[10] << 8) | reply[11]) -\n\t              ((reply[5] << 16) | (reply[6] << 8) | reply[7]) + 1;\n\tret = 1;\nex:;\n\tif (reply != NULL)\n\t\tfree(reply);\n\treturn ret;\n}",
    "decom_sum": "Parses and extracts disc structure information from device data format 0x10, populating output parameters and freeing allocated buffer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses and extracts detailed format 10h read disc structure information from a device buffer, populating output parameters and validating response length.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses and extracts disc structure information from device data format 0x10, populating output parameters and freeing allocated buffer.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses and extracts DVD disc structure format 0x10 response, computing parameters like layer number, start sector, and sector count, validating response length.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
    "filter2_prorec_aug_sum": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
    "filter2_prorec_aug2_sum": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
    "source_code": "int aaip_add_acl_st_mode(char *acl_text, mode_t st_mode, int flag)\n{\n char *wpt;\n int tag_types= 0;\n\n tag_types = aaip_cleanout_st_mode(acl_text, &st_mode, 1);\n if(!(tag_types & (4 | 32))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"user::%c%c%c\\n\",\n           st_mode & S_IRUSR ? 'r' : '-',\n           st_mode & S_IWUSR ? 'w' : '-',\n           st_mode & S_IXUSR ? 'x' : '-');\n }\n if(!(tag_types & (2 | 16 | 1024))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"group::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n if(!(tag_types & (1 | 8))) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"other::%c%c%c\\n\",\n         st_mode & S_IROTH ? 'r' : '-',\n         st_mode & S_IWOTH ? 'w' : '-',\n         st_mode & S_IXOTH ? 'x' : '-');\n }\n if((tag_types & (128 | 256)) && !(tag_types & 512)) {\n   wpt= acl_text + strlen(acl_text);\n   sprintf(wpt, \"mask::%c%c%c\\n\",\n         st_mode & S_IRGRP ? 'r' : '-',\n         st_mode & S_IWGRP ? 'w' : '-',\n         st_mode & S_IXGRP ? 'x' : '-');\n }\n return(1); \n}",
    "decom_sum": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Formats and appends user, group, other, and mask POSIX permission strings to buffer `s` based on flags from `sub_4CAE00` results.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates over indexed data blocks, aggregating 64-bit values into an output buffer while synchronizing access with spin-wait on a lock flag.",
    "filter2_prorec_aug_sum": "Iterates entries, accumulates offsets and sizes from memory segments matching flags into output arrays based on a condition and updates position until all entries processed.",
    "filter2_prorec_aug2_sum": "Iterates over indexed data blocks, aggregating 64-bit values into an output buffer while synchronizing access with spin-wait on a lock flag.",
    "source_code": "int get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\n{\n\tint cpu = t->cpu_id;\n\tunsigned long long msr;\n\n\tif (cpu_migrate(cpu)) {\n\t\tfprintf(stderr, \"Could not migrate to CPU %d\\n\", cpu);\n\t\treturn -1;\n\t}\n\n\tt->tsc = rdtsc();\t/* we are running on local CPU of interest */\n\n\tif (has_aperf) {\n\t\tif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\n\t\t\treturn -3;\n\t\tif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\n\t\t\treturn -4;\n\t}\n\n\tif (do_smi) {\n\t\tif (get_msr(cpu, MSR_SMI_COUNT, &msr))\n\t\t\treturn -5;\n\t\tt->smi_count = msr & 0xFFFFFFFF;\n\t}\n\tif (extra_delta_offset32) {\n\t\tif (get_msr(cpu, extra_delta_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_delta32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_delta_offset64)\n\t\tif (get_msr(cpu, extra_delta_offset64, &t->extra_delta64))\n\t\t\treturn -5;\n\n\tif (extra_msr_offset32) {\n\t\tif (get_msr(cpu, extra_msr_offset32, &msr))\n\t\t\treturn -5;\n\t\tt->extra_msr32 = msr & 0xFFFFFFFF;\n\t}\n\n\tif (extra_msr_offset64)\n\t\tif (get_msr(cpu, extra_msr_offset64, &t->extra_msr64))\n\t\t\treturn -5;\n\n\t/* collect core counters only for 1st thread in core */\n\tif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\n\t\t\treturn -6;\n\t\tif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\n\t\t\treturn -7;\n\t}\n\n\tif (do_snb_cstates)\n\t\tif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\n\t\t\treturn -8;\n\n\tif (do_dts) {\n\t\tif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\n\t\t\treturn -9;\n\t\tc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\n\n\t/* collect package counters only for 1st core in package */\n\tif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\n\t\treturn 0;\n\n\tif (do_nhm_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\n\t\t\treturn -9;\n\t\tif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\n\t\t\treturn -10;\n\t}\n\tif (do_snb_cstates) {\n\t\tif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\n\t\t\treturn -11;\n\t\tif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\n\t\t\treturn -12;\n\t}\n\tif (do_c8_c9_c10) {\n\t\tif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\n\t\t\treturn -13;\n\t\tif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\n\t\t\treturn -13;\n\t}\n\tif (do_rapl & RAPL_PKG) {\n\t\tif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\n\t\t\treturn -13;\n\t\tp->energy_pkg = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_CORES) {\n\t\tif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\n\t\t\treturn -14;\n\t\tp->energy_cores = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM) {\n\t\tif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\n\t\t\treturn -15;\n\t\tp->energy_dram = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_GFX) {\n\t\tif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->energy_gfx = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_PKG_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_rapl & RAPL_DRAM_PERF_STATUS) {\n\t\tif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\n\t\t\treturn -16;\n\t\tp->rapl_dram_perf_status = msr & 0xFFFFFFFF;\n\t}\n\tif (do_ptm) {\n\t\tif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\n\t\t\treturn -17;\n\t\tp->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\n\t}\n\treturn 0;\n}",
    "decom_sum": "Iterates over indexed data blocks, aggregating 64-bit values into an output buffer while synchronizing access with spin-wait on a lock flag.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates over indexed data blocks, aggregating 64-bit values into an output buffer while synchronizing access with spin-wait on a lock flag.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates entries, accumulates offsets and sizes from memory segments matching flags into output arrays based on a condition and updates position until all entries processed.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates over indexed data blocks, aggregating 64-bit values into an output buffer while synchronizing access with spin-wait on a lock flag.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Generates a compact integer sequence with increment \u00b11 into the provided buffer, enforcing unexpanded vector constraint and bounds.",
    "filter2_prorec_aug_sum": "Generates a sequence of integer values with increment \u00b11 from vector metadata and writes them into a buffer within given bounds, erroring on unsupported increments.",
    "filter2_prorec_aug2_sum": "Generates a sequence of integers into an output buffer based on compact sequence parameters with increment \u00b11, enforcing unexpanded vector constraints.",
    "source_code": "\nstatic R_xlen_t\ncompact_intseq_Get_region(SEXP sx, R_xlen_t i, R_xlen_t n, int *buf)\n{\n    /* should not get here if x is already expanded */\n    CHECK_NOT_EXPANDED(sx);\n\n    SEXP info = COMPACT_SEQ_INFO(sx);\n    R_xlen_t size = COMPACT_INTSEQ_INFO_LENGTH(info);\n    R_xlen_t n1 = COMPACT_INTSEQ_INFO_FIRST(info);\n    int inc = COMPACT_INTSEQ_INFO_INCR(info);\n\n    R_xlen_t ncopy = size - i > n ? n : size - i;\n    if (inc == 1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 + k + i);\n\treturn ncopy;\n    }\n    else if (inc == -1) {\n\tfor (R_xlen_t k = 0; k < ncopy; k++)\n\t    buf[k] = (int) (n1 - k - i);\n\treturn ncopy;\n    }\n    else\n\terror(\"compact sequences with increment %d not supported yet\", inc);\n}",
    "decom_sum": "Generates a numeric sequence from vector metadata with specified start, length, and increment, raising errors for unsupported compact sequence formats.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Generates a compact integer sequence with increment \u00b11 into the provided buffer, enforcing unexpanded vector constraint and bounds.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Generates a sequence of integer values with increment \u00b11 from vector metadata and writes them into a buffer within given bounds, erroring on unsupported increments.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Generates a sequence of integers into an output buffer based on compact sequence parameters with increment \u00b11, enforcing unexpanded vector constraints.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Determines if a character (int) is a valid XML Name start character based on XML specification and context flags.",
    "filter2_prorec_aug_sum": "Checks whether a Unicode character code is a valid XML name start character according to XML naming rules and character ranges.",
    "filter2_prorec_aug2_sum": "Determines if a given code point is a valid XML name character according to XML naming and Unicode character ranges rules.",
    "source_code": "\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}",
    "decom_sum": "Validates whether the given Unicode code point is an allowed XML name character based on XML specification rules and character property checks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Determines if a character (int) is a valid XML Name start character based on XML specification and context flags.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks whether a Unicode character code is a valid XML name start character according to XML naming rules and character ranges.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Determines if a given code point is a valid XML name character according to XML naming and Unicode character ranges rules.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Unregisters and cleans up an Intel uncore performance event, detaching it from tracking structures, marking dead pointers, and logging inconsistencies.",
    "filter2_prorec_aug_sum": "Unregisters and cleans up an Intel uncore performance event, detaching it from tracking structures, marking dead pointers, and logging inconsistencies.",
    "filter2_prorec_aug2_sum": "Validates and resets a perf_event_intel_uncore structure, removes references from a global array, decrements usage count, and logs errors if usage is inconsistent.",
    "source_code": "\nstatic void uncore_pci_remove(struct pci_dev *pdev)\n{\n\tstruct intel_uncore_box *box = pci_get_drvdata(pdev);\n\tstruct intel_uncore_pmu *pmu = box->pmu;\n\tint cpu, phys_id = pcibus_to_physid[pdev->bus->number];\n\n\tif (WARN_ON_ONCE(phys_id != box->phys_id))\n\t\treturn;\n\n\tpci_set_drvdata(pdev, NULL);\n\n\traw_spin_lock(&uncore_box_lock);\n\tlist_del(&box->list);\n\traw_spin_unlock(&uncore_box_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (*per_cpu_ptr(pmu->box, cpu) == box) {\n\t\t\t*per_cpu_ptr(pmu->box, cpu) = NULL;\n\t\t\tatomic_dec(&box->refcnt);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&box->refcnt) != 1);\n\tkfree(box);\n}",
    "decom_sum": "Unregisters and cleans up an Intel uncore performance event, detaching it from tracking structures, marking dead pointers, and logging inconsistencies.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Unregisters and cleans up an Intel uncore performance event, detaching it from tracking structures, marking dead pointers, and logging inconsistencies.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Unregisters and cleans up an Intel uncore performance event, detaching it from tracking structures, marking dead pointers, and logging inconsistencies.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and resets a perf_event_intel_uncore structure, removes references from a global array, decrements usage count, and logs errors if usage is inconsistent.",
            "flag": false,
            "score": [
                0.4,
                0.3,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
    "filter2_prorec_aug_sum": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
    "filter2_prorec_aug2_sum": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
    "source_code": "\nstatic void sig_child_handler(int sig_no UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint l;\n\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"child\");\n\twhile ((pid = wait_any_nohang(&wstat)) > 0) {\n\t\tfor (l = 0; l < dirn; ++l) {\n\t\t\tif (dir[l].ppid == pid) {\n\t\t\t\tdir[l].ppid = 0;\n\t\t\t\tprocessorstop(&dir[l]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "decom_sum": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes incoming events, logs the termination or signal type, decrements counters, and triggers a final handler if any events were processed.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes a read key to navigate history or move the cursor left/right, handling arrow keys and multi-byte character settings, otherwise triggers an alert sound.",
    "filter2_prorec_aug_sum": "Processes arrow key inputs to navigate command history or move the cursor forward/backward by bytes or characters, signaling errors with a ding on unrecognized keys.",
    "filter2_prorec_aug2_sum": "Processes arrow key inputs to navigate command history or move the cursor forward/backward by bytes or characters based on input and encoding settings.",
    "source_code": "\nint\nrl_arrow_keys (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (ch < 0)\n    return (1);\n\n  switch (_rl_to_upper (ch))\n    {\n    case 'A':\n      rl_get_previous_history (count, ch);\n      break;\n\n    case 'B':\n      rl_get_next_history (count, ch);\n      break;\n\n    case 'C':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, ch);\n      else\n\trl_forward_byte (count, ch);\n      break;\n\n    case 'D':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_backward_char (count, ch);\n      else\n\trl_backward_byte (count, ch);\n      break;\n\n    default:\n      rl_ding ();\n    }\n\n  return 0;\n}",
    "decom_sum": "Handles arrow key input by executing history navigation or cursor movement actions, falling back to ringing the terminal bell for unrecognized keys.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes a read key to navigate history or move the cursor left/right, handling arrow keys and multi-byte character settings, otherwise triggers an alert sound.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes arrow key inputs to navigate command history or move the cursor forward/backward by bytes or characters, signaling errors with a ding on unrecognized keys.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes arrow key inputs to navigate command history or move the cursor forward/backward by bytes or characters based on input and encoding settings.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates state and updates timestamp and parameters according to input mode, returning error or invoking update or reset routines accordingly.",
    "filter2_prorec_aug_sum": "Updates device state and timing parameters when the mode changes, performing initialization or shutdown routines while managing synchronization locks.",
    "filter2_prorec_aug2_sum": "Validates and updates device state based on mode change, resetting timing and recalculating parameters when a new mode is set and no error flags exist.",
    "source_code": "\nint rtc_update_irq_enable(struct rtc_device *rtc, unsigned int enabled)\n{\n\tint err = mutex_lock_interruptible(&rtc->ops_lock);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\tif (enabled == 0 && rtc->uie_irq_active) {\n\t\tmutex_unlock(&rtc->ops_lock);\n\t\treturn rtc_dev_update_irq_enable_emul(rtc, 0);\n\t}\n#endif\n\t/* make sure we're changing state */\n\tif (rtc->uie_rtctimer.enabled == enabled)\n\t\tgoto out;\n\n\tif (rtc->uie_unsupported) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (enabled) {\n\t\tstruct rtc_time tm;\n\t\tktime_t now, onesec;\n\n\t\t__rtc_read_time(rtc, &tm);\n\t\tonesec = ktime_set(1, 0);\n\t\tnow = rtc_tm_to_ktime(tm);\n\t\trtc->uie_rtctimer.node.expires = ktime_add(now, onesec);\n\t\trtc->uie_rtctimer.period = ktime_set(1, 0);\n\t\terr = rtc_timer_enqueue(rtc, &rtc->uie_rtctimer);\n\t} else\n\t\trtc_timer_remove(rtc, &rtc->uie_rtctimer);\n\nout:\n\tmutex_unlock(&rtc->ops_lock);\n#ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL\n\t/*\n\t * Enable emulation if the driver did not provide\n\t * the update_irq_enable function pointer or if returned\n\t * -EINVAL to signal that it has been configured without\n\t * interrupts or that are not available at the moment.\n\t */\n\tif (err == -EINVAL)\n\t\terr = rtc_dev_update_irq_enable_emul(rtc, enabled);\n#endif\n\treturn err;\n\n}",
    "decom_sum": "Updates device state and timing parameters when the mode changes, performing initialization or shutdown routines while managing synchronization locks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates state and updates timestamp and parameters according to input mode, returning error or invoking update or reset routines accordingly.",
            "flag": false,
            "score": [
                0.4,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates device state and timing parameters when the mode changes, performing initialization or shutdown routines while managing synchronization locks.",
            "flag": true,
            "score": [
                0.8,
                0.5,
                0.5
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and updates device state based on mode change, resetting timing and recalculating parameters when a new mode is set and no error flags exist.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Retrieves and formats a specific TCP socket option value into a string stored at a2 based on the input parameter a3, setting status flags on failure or success.",
    "filter2_prorec_aug_sum": "Retrieves TCP connection info via getsockopt, selects a specific metric, formats it into a buffer, and updates the target structure fields.",
    "filter2_prorec_aug2_sum": "Retrieves a socket option, allocates memory for and stores a numeric status code string based on a parameter, and updates status flags accordingly.",
    "source_code": "\nstatic ngx_int_t\nngx_http_variable_tcpinfo(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n    uintptr_t data)\n{\n    struct tcp_info  ti;\n    socklen_t        len;\n    uint32_t         value;\n\n    len = sizeof(struct tcp_info);\n    if (getsockopt(r->connection->fd, IPPROTO_TCP, TCP_INFO, &ti, &len) == -1) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ngx_pnalloc(r->pool, NGX_INT32_LEN);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    switch (data) {\n    case 0:\n        value = ti.tcpi_rtt;\n        break;\n\n    case 1:\n        value = ti.tcpi_rttvar;\n        break;\n\n    case 2:\n        value = ti.tcpi_snd_cwnd;\n        break;\n\n    case 3:\n        value = ti.tcpi_rcv_space;\n        break;\n\n    /* suppress warning */\n    default:\n        value = 0;\n        break;\n    }\n\n    v->len = ngx_sprintf(v->data, \"%uD\", value) - v->data;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}",
    "decom_sum": "Retrieves TCP connection info via getsockopt, selects a specific metric, formats it into a buffer, and updates the target structure fields.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Retrieves and formats a specific TCP socket option value into a string stored at a2 based on the input parameter a3, setting status flags on failure or success.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Retrieves TCP connection info via getsockopt, selects a specific metric, formats it into a buffer, and updates the target structure fields.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Retrieves a socket option, allocates memory for and stores a numeric status code string based on a parameter, and updates status flags accordingly.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
    "filter2_prorec_aug_sum": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
    "filter2_prorec_aug2_sum": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
    "source_code": "\nint libjte_write_header(struct libjte_env *o)\n{\n    int ret;\n\n    if (o->jtemplate_out == NULL || o->jjigdo_out == NULL ||\n        o->outfile == NULL || o->jmd5_list == NULL) {\n        sprintf(o->message_buffer,\n               \"Undefined: template_path, jigdo_path, md5_paths, or outfile.\");\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    \n    o->jttemplate = fopen(o->jtemplate_out, \"wb\");\n    if (o->jttemplate == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open template file '%1.1024s' for writing. errno=%d\",\n                o->jtemplate_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n    o->jtjigdo = fopen(o->jjigdo_out, \"wb\");\n    if (o->jtjigdo == NULL) {\n        sprintf(o->message_buffer,\n                \"Cannot open jigdo file '%1.1024s' for writing. errno=%d\",\n                o->jjigdo_out, errno);\n        libjte_add_msg_entry(o, o->message_buffer, 0);\n        return 0;\n    }\n\n    ret = write_jt_header(o, o->jttemplate, o->jtjigdo);\n    if (ret <= 0)\n        return ret;\n    return 1;\n}",
    "decom_sum": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
            "flag": true,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Opens specified template and jigdo output files for writing, reports detailed errors on failure, and processes them through sub_4D0600.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Determines and returns a fixed identifier code based on specific bit patterns and fields within a 20-byte structure at the input address.",
    "filter2_prorec_aug_sum": "Classifies and returns specific constant codes based on bitmask and value checks of a binary header structure at the given memory address.",
    "filter2_prorec_aug2_sum": "Determines and returns a protocol or status code based on specific bit flags and field values within a structured input at address a1.",
    "source_code": "\nint __ipv6_addr_type(const struct in6_addr *addr)\n{\n\t__be32 st;\n\n\tst = addr->s6_addr32[0];\n\n\t/* Consider all addresses with the first three bits different of\n\t   000 and 111 as unicasts.\n\t */\n\tif ((st & htonl(0xE0000000)) != htonl(0x00000000) &&\n\t    (st & htonl(0xE0000000)) != htonl(0xE0000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\n\n\tif ((st & htonl(0xFF000000)) == htonl(0xFF000000)) {\n\t\t/* multicast */\n\t\t/* addr-select 3.1 */\n\t\treturn (IPV6_ADDR_MULTICAST |\n\t\t\tipv6_addr_scope2type(IPV6_ADDR_MC_SCOPE(addr)));\n\t}\n\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFE800000))\n\t\treturn (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFEC00000))\n\t\treturn (IPV6_ADDR_SITELOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_SITELOCAL));\t\t/* addr-select 3.1 */\n\tif ((st & htonl(0xFE000000)) == htonl(0xFC000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t\t\t/* RFC 4193 */\n\n\tif ((addr->s6_addr32[0] | addr->s6_addr32[1]) == 0) {\n\t\tif (addr->s6_addr32[2] == 0) {\n\t\t\tif (addr->s6_addr32[3] == 0)\n\t\t\t\treturn IPV6_ADDR_ANY;\n\n\t\t\tif (addr->s6_addr32[3] == htonl(0x00000001))\n\t\t\t\treturn (IPV6_ADDR_LOOPBACK | IPV6_ADDR_UNICAST |\n\t\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t/* addr-select 3.4 */\n\n\t\t\treturn (IPV6_ADDR_COMPATv4 | IPV6_ADDR_UNICAST |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t\t}\n\n\t\tif (addr->s6_addr32[2] == htonl(0x0000ffff))\n\t\t\treturn (IPV6_ADDR_MAPPED |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.3 */\n\t}\n\n\treturn (IPV6_ADDR_UNICAST |\n\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t/* addr-select 3.4 */\n}",
    "decom_sum": "Classifies and returns specific constant codes based on bitmask and value checks of a binary header structure at the given memory address.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Determines and returns a fixed identifier code based on specific bit patterns and fields within a 20-byte structure at the input address.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Classifies and returns specific constant codes based on bitmask and value checks of a binary header structure at the given memory address.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Determines and returns a protocol or status code based on specific bit flags and field values within a structured input at address a1.",
            "flag": false,
            "score": [
                0.3,
                0.2,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Inserts or reorders a linked list node based on a key derived from input, manages reference counting, and triggers a one-time debug warning on unexpected state.",
    "filter2_prorec_aug_sum": "Inserts and reorders a node in a doubly linked list based on a timestamp offset and manages reference counting with concurrency safeguards.",
    "filter2_prorec_aug2_sum": "Inserts and re-links a node into a doubly-linked list with reference counting and updates associated metadata based on given parameters.",
    "source_code": "static void\nnlmsvc_insert_block_locked(struct nlm_block *block, unsigned long when)\n{\n\tstruct nlm_block *b;\n\tstruct list_head *pos;\n\n\tdprintk(\"lockd: nlmsvc_insert_block(%p, %ld)\\n\", block, when);\n\tif (list_empty(&block->b_list)) {\n\t\tkref_get(&block->b_count);\n\t} else {\n\t\tlist_del_init(&block->b_list);\n\t}\n\n\tpos = &nlm_blocked;\n\tif (when != NLM_NEVER) {\n\t\tif ((when += jiffies) == NLM_NEVER)\n\t\t\twhen ++;\n\t\tlist_for_each(pos, &nlm_blocked) {\n\t\t\tb = list_entry(pos, struct nlm_block, b_list);\n\t\t\tif (time_after(b->b_when,when) || b->b_when == NLM_NEVER)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* On normal exit from the loop, pos == &nlm_blocked,\n\t\t * so we will be adding to the end of the list - good\n\t\t */\n\t}\n\n\tlist_add_tail(&block->b_list, pos);\n\tblock->b_when = when;\n}",
    "decom_sum": "Updates linked list node connections and refcount, then inserts the node into a global ordered list indexed by an adjusted a2 offset value.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Inserts or reorders a linked list node based on a key derived from input, manages reference counting, and triggers a one-time debug warning on unexpected state.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Inserts and reorders a node in a doubly linked list based on a timestamp offset and manages reference counting with concurrency safeguards.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Inserts and re-links a node into a doubly-linked list with reference counting and updates associated metadata based on given parameters.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
    "filter2_prorec_aug_sum": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
    "filter2_prorec_aug2_sum": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
    "source_code": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
    "decom_sum": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates through a linked structure, clears specific status flags, releases associated resources, and finalizes by resetting the global dword_FFFFFFFF81C3BE20 state variable.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates or reloads object data from memory, processes it with given parameters, then frees resources and signals completion status via return value.",
    "filter2_prorec_aug_sum": "Validates or reloads object data from memory, processes it with given parameters, then frees resources and signals completion status via return value.",
    "filter2_prorec_aug2_sum": "Validates and updates a data stream state, conditionally resets internal buffers, and frees associated resources based on integrity checks.",
    "source_code": "int\ngnet_stats_finish_copy(struct gnet_dump *d)\n{\n\tif (d->tail)\n\t\td->tail->nla_len = skb_tail_pointer(d->skb) - (u8 *)d->tail;\n\n\tif (d->compat_tc_stats)\n\t\tif (gnet_stats_copy(d, d->compat_tc_stats, &d->tc_stats,\n\t\t\tsizeof(d->tc_stats)) < 0)\n\t\t\treturn -1;\n\n\tif (d->compat_xstats && d->xstats) {\n\t\tif (gnet_stats_copy(d, d->compat_xstats, d->xstats,\n\t\t\td->xstats_len) < 0)\n\t\t\treturn -1;\n\t}\n\n\tspin_unlock_bh(d->lock);\n\treturn 0;\n}",
    "decom_sum": "Validates or reloads object data from memory, processes it with given parameters, then frees resources and signals completion status via return value.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates or reloads object data from memory, processes it with given parameters, then frees resources and signals completion status via return value.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates or reloads object data from memory, processes it with given parameters, then frees resources and signals completion status via return value.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and updates a data stream state, conditionally resets internal buffers, and frees associated resources based on integrity checks.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Runs the \"./check\" program, waits for its completion, and returns success status, logging warnings if execution or process handling fails.",
    "filter2_prorec_aug_sum": "Runs the \"./check\" program, waits for its completion, and returns success status, logging warnings if execution or process handling fails.",
    "filter2_prorec_aug2_sum": "Checks for the presence and accessibility of the \"./check\" file, waits for a related child process if running, and returns success status accordingly.",
    "source_code": "\nstatic int checkscript(void)\n{\n\tchar *prog[2];\n\tstruct stat s;\n\tint pid, w;\n\n\tif (stat(\"check\", &s) == -1) {\n\t\tif (errno == ENOENT) return 1;\n\t\tbb_perror_msg(WARN\"can't stat %s/check\", *service);\n\t\treturn 0;\n\t}\n\t/* if (!(s.st_mode & S_IXUSR)) return 1; */\n\tprog[0] = (char*)\"./check\";\n\tprog[1] = NULL;\n\tpid = spawn(prog);\n\tif (pid <= 0) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"run\", *service);\n\t\treturn 0;\n\t}\n\twhile (safe_waitpid(pid, &w, 0) == -1) {\n\t\tbb_perror_msg(WARN\"can't %s child %s/check\", \"wait for\", *service);\n\t\treturn 0;\n\t}\n\treturn WEXITSTATUS(w) == 0;\n}",
    "decom_sum": "Runs the \"./check\" program, waits for its completion, and returns success status, logging warnings if execution or process handling fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Runs the \"./check\" program, waits for its completion, and returns success status, logging warnings if execution or process handling fails.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Runs the \"./check\" program, waits for its completion, and returns success status, logging warnings if execution or process handling fails.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks for the presence and accessibility of the \"./check\" file, waits for a related child process if running, and returns success status accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks device state and mode flags to decide whether to call a processing function or return an error code based on specific mode and status conditions.",
    "filter2_prorec_aug_sum": "Dispatches processing requests to `sub_FFFFFFFF81738B20` for specific state codes and flags, otherwise returning error code\u202f4294967201 for unsupported or invalid conditions.",
    "filter2_prorec_aug2_sum": "Dispatches processing requests to `sub_FFFFFFFF81738B20` for specific state codes and flags, otherwise returning error code\u202f4294967201 for unsupported or invalid conditions.",
    "source_code": "\nstatic int ieee80211_scan(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = IEEE80211_WDEV_TO_SUB_IF(req->wdev);\n\n\tswitch (ieee80211_vif_type_p2p(&sdata->vif)) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (sdata->local->ops->hw_scan)\n\t\t\tbreak;\n\t\t/*\n\t\t * FIXME: implement NoA while scanning in software,\n\t\t * for now fall through to allow scanning only when\n\t\t * beaconing hasn't been configured yet\n\t\t */\n\tcase NL80211_IFTYPE_AP:\n\t\t/*\n\t\t * If the scan has been forced (and the driver supports\n\t\t * forcing), don't care about being beaconing already.\n\t\t * This will create problems to the attached stations (e.g. all\n\t\t * the  frames sent while scanning on other channel will be\n\t\t * lost)\n\t\t */\n\t\tif (sdata->u.ap.beacon &&\n\t\t    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||\n\t\t     !(req->flags & NL80211_SCAN_FLAG_AP)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ieee80211_request_scan(sdata, req);\n}",
    "decom_sum": "Dispatches processing requests to `sub_FFFFFFFF81738B20` for specific state codes and flags, otherwise returning error code\u202f4294967201 for unsupported or invalid conditions.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks device state and mode flags to decide whether to call a processing function or return an error code based on specific mode and status conditions.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Dispatches processing requests to `sub_FFFFFFFF81738B20` for specific state codes and flags, otherwise returning error code\u202f4294967201 for unsupported or invalid conditions.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Dispatches processing requests to `sub_FFFFFFFF81738B20` for specific state codes and flags, otherwise returning error code\u202f4294967201 for unsupported or invalid conditions.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Removes a node matching given keys from a linked structure, updates reference counts, performs cleanup, and triggers dependent processing with provided parameters.",
    "filter2_prorec_aug_sum": "Removes a specific entry from a hardware-related linked list, updates associated counters and locks, and triggers cleanup and follow-up processing routines.",
    "filter2_prorec_aug2_sum": "Processes a file structure if flagged, removing a matching entry by a2 and a1, updating counters, managing linked lists, and triggering cleanup and update routines.",
    "source_code": "void dnotify_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct dnotify_mark *dn_mark;\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\n\tinode = file_inode(filp);\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tfsn_mark = fsnotify_find_inode_mark(dnotify_group, inode);\n\tif (!fsn_mark)\n\t\treturn;\n\tdn_mark = container_of(fsn_mark, struct dnotify_mark, fsn_mark);\n\n\tmutex_lock(&dnotify_mark_mutex);\n\n\tspin_lock(&fsn_mark->lock);\n\tprev = &dn_mark->dn;\n\twhile ((dn = *prev) != NULL) {\n\t\tif ((dn->dn_owner == id) && (dn->dn_filp == filp)) {\n\t\t\t*prev = dn->dn_next;\n\t\t\tkmem_cache_free(dnotify_struct_cache, dn);\n\t\t\tdnotify_recalc_inode_mask(fsn_mark);\n\t\t\tbreak;\n\t\t}\n\t\tprev = &dn->dn_next;\n\t}\n\n\tspin_unlock(&fsn_mark->lock);\n\n\t/* nothing else could have found us thanks to the dnotify_mark_mutex */\n\tif (dn_mark->dn == NULL)\n\t\tfsnotify_destroy_mark(fsn_mark, dnotify_group);\n\n\tmutex_unlock(&dnotify_mark_mutex);\n\n\tfsnotify_put_mark(fsn_mark);\n}",
    "decom_sum": "Removes a specific entry from a hardware-related linked list, updates associated counters and locks, and triggers cleanup and follow-up processing routines.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Removes a node matching given keys from a linked structure, updates reference counts, performs cleanup, and triggers dependent processing with provided parameters.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Removes a specific entry from a hardware-related linked list, updates associated counters and locks, and triggers cleanup and follow-up processing routines.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes a file structure if flagged, removing a matching entry by a2 and a1, updating counters, managing linked lists, and triggering cleanup and update routines.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates over active entries in a kernel structure, filters by attribute bits, performs checks, processes matching entries, and returns the count of processed entries.",
    "filter2_prorec_aug_sum": "Iterates over monitored entries, counts those passing status and flag checks, updates spinlock statistics, and resets bits accordingly, returning the final count.",
    "filter2_prorec_aug2_sum": "Counts and processes active memory items from a global list, resetting flags and updating statistics based on specific bitmask and condition checks.",
    "source_code": "\nint x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
    "decom_sum": "Iterates over active processor entries, checks specific status bits, performs conditional operations on each, and increments a global counter for processed entries.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates over active entries in a kernel structure, filters by attribute bits, performs checks, processes matching entries, and returns the count of processed entries.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates over monitored entries, counts those passing status and flag checks, updates spinlock statistics, and resets bits accordingly, returning the final count.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Counts and processes active memory items from a global list, resetting flags and updating statistics based on specific bitmask and condition checks.",
            "flag": false,
            "score": [
                0.4,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
    "filter2_prorec_aug_sum": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
    "filter2_prorec_aug2_sum": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
    "source_code": "int Findjob_set_name_expr(struct FindjoB *o, char *name_expr, int flag)\n{\n char *regexpr= NULL;\n regex_t *name_re;\n struct ExprtesT *t;\n int ret;\n\n regexpr= TSOB_FELD(char, 2*SfileadrL+2);\n if(regexpr == NULL)\n   {ret= -1; goto ex;}\n if(strlen(name_expr)>=SfileadrL)\n   {ret= 0; goto ex;};\n\n ret= Findjob_default_and(o, 0);\n if(ret <= 0)\n   goto ex;\n t= o->cursor->test;\n t->test_type= 1;\n if ((flag & 3) == 1)\n   t->test_type= 13;\n else if((flag & 3) == 2)\n   t->test_type= 16;\n else if((flag & 3) == 3)\n   t->test_type= 20;\n t->arg1= strdup(name_expr);\n if(t->arg1 == NULL)\n   {ret= -1; goto ex;};\n\n if((flag & 3) == 3)\n   {ret= 1; goto ex;}\n\n name_re= (regex_t *) calloc(1, sizeof(regex_t));\n if(name_re == NULL)\n   {ret= -1; goto ex;};\n Xorriso__bourne_to_reg(name_expr, regexpr, 0);\n if(regcomp(name_re, regexpr, 0) != 0) {\n   free((char *) name_re);\n   {ret= 0; goto ex;};\n }\n t->arg2= name_re;\n ret= 1;\nex:;\n Xorriso_free_meM(regexpr);\n return(ret);\n}",
    "decom_sum": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Compiles a provided pattern into a regex, stores it with configuration flags in a context structure, and returns success or error status.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Conditionally updates device flags and settings at specific offsets based on status bits and input parameter, including setting or clearing bits via helper functions.",
    "filter2_prorec_aug_sum": "Updates adapter hardware registers based on device flags and input parameter, modifying status bits via helper functions reflecting device mode and state.",
    "filter2_prorec_aug2_sum": "Modifies specific flag bits within a structure at offsets 3404 and 3412 based on conditionals tied to status flags and input, updating registers via helper functions.",
    "source_code": "\nstatic void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)\n{\n\tu32 reg;\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    (tg3_flag(tp, 5717_PLUS) &&\n\t     (tp->phy_flags & TG3_PHYFLG_MII_SERDES)))\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\ttg3_phy_fet_toggle_apd(tp, enable);\n\t\treturn;\n\t}\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_SCR5_SEL |\n\t      MII_TG3_MISC_SHDW_SCR5_LPED |\n\t      MII_TG3_MISC_SHDW_SCR5_DLPTLM |\n\t      MII_TG3_MISC_SHDW_SCR5_SDTL |\n\t      MII_TG3_MISC_SHDW_SCR5_C125OE;\n\tif (tg3_asic_rev(tp) != ASIC_REV_5784 || !enable)\n\t\treg |= MII_TG3_MISC_SHDW_SCR5_DLLAPD;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n\n\n\treg = MII_TG3_MISC_SHDW_WREN |\n\t      MII_TG3_MISC_SHDW_APD_SEL |\n\t      MII_TG3_MISC_SHDW_APD_WKTM_84MS;\n\tif (enable)\n\t\treg |= MII_TG3_MISC_SHDW_APD_ENABLE;\n\n\ttg3_writephy(tp, MII_TG3_MISC_SHDW, reg);\n}",
    "decom_sum": "Updates specific hardware register values at offsets 27, 28, and 31 based on device state flags and the control parameter `a2`.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Conditionally updates device flags and settings at specific offsets based on status bits and input parameter, including setting or clearing bits via helper functions.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates adapter hardware registers based on device flags and input parameter, modifying status bits via helper functions reflecting device mode and state.",
            "flag": false,
            "score": [
                0.6,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Modifies specific flag bits within a structure at offsets 3404 and 3412 based on conditionals tied to status flags and input, updating registers via helper functions.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
    "filter2_prorec_aug_sum": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
    "filter2_prorec_aug2_sum": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
    "source_code": "\nstatic void calc_mode_timings(int xres, int yres, int refresh,\n\t\t\t      struct fb_videomode *mode)\n{\n\tstruct fb_var_screeninfo *var;\n\n\tvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\n\n\tif (var) {\n\t\tvar->xres = xres;\n\t\tvar->yres = yres;\n\t\tfb_get_mode(FB_VSYNCTIMINGS | FB_IGNOREMON,\n\t\t\t    refresh, var, NULL);\n\t\tmode->xres = xres;\n\t\tmode->yres = yres;\n\t\tmode->pixclock = var->pixclock;\n\t\tmode->refresh = refresh;\n\t\tmode->left_margin = var->left_margin;\n\t\tmode->right_margin = var->right_margin;\n\t\tmode->upper_margin = var->upper_margin;\n\t\tmode->lower_margin = var->lower_margin;\n\t\tmode->hsync_len = var->hsync_len;\n\t\tmode->vsync_len = var->vsync_len;\n\t\tmode->vmode = 0;\n\t\tmode->sync = 0;\n\t\tkfree(var);\n\t}\n}",
    "decom_sum": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates a 160-byte structure, populates it with provided parameters, updates an output buffer with specific fields, and finalizes it via two helper functions.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Recursively loads and processes directory entries into allocated buffers, initializing and updating them while traversing subdirectories based on flags.",
    "filter2_prorec_aug_sum": "Recursively processes and stores data blocks into a fixed 32KB buffer, invoking subsidiary handlers and clearing buffer when required.",
    "filter2_prorec_aug2_sum": "Recursively initializes and processes directory entries, allocating buffers as needed and applying updates via sub_4957F0 calls while traversing subdirectories.",
    "source_code": "int img_collect_inos(IsoImage *image, IsoDir *dir, int flag)\n{\n    int ret, register_dir = 1;\n    IsoDirIter *iter = NULL;\n    IsoNode *node;\n    IsoDir *subdir;\n\n    if (dir == NULL)\n        dir = image->root;\n    if (image->used_inodes == NULL) {\n        image->used_inodes = calloc(ISO_USED_INODE_RANGE / 8, 1);\n        if (image->used_inodes == NULL)\n            return ISO_OUT_OF_MEM;\n    } else if(!(flag & 1)) {\n        memset(image->used_inodes, 0, ISO_USED_INODE_RANGE / 8);\n    } else {\n        register_dir = 0;\n    }\n    if (register_dir) {\n        node = (IsoNode *) dir;\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            return ret;\n    }\n\n    ret = iso_dir_get_children(dir, &iter);\n    if (ret < 0)\n        return ret;\n    while (iso_dir_iter_next(iter, &node) == 1 ) {\n        ret = img_register_ino(image, node, 0);\n        if (ret < 0)\n            goto ex;\n        if (iso_node_get_type(node) == LIBISO_DIR) {\n            subdir = (IsoDir *) node;\n            ret = img_collect_inos(image, subdir, flag | 1);\n            if (ret < 0)\n                goto ex;\n        }\n    }\n    ret = 1;\nex:;\n    if (iter != NULL)\n        iso_dir_iter_free(iter);\n    return ret;\n}",
    "decom_sum": "Recursively processes and stores data blocks into a fixed 32KB buffer, invoking subsidiary handlers and clearing buffer when required.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Recursively loads and processes directory entries into allocated buffers, initializing and updating them while traversing subdirectories based on flags.",
            "flag": false,
            "score": [
                0.4,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Recursively processes and stores data blocks into a fixed 32KB buffer, invoking subsidiary handlers and clearing buffer when required.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Recursively initializes and processes directory entries, allocating buffers as needed and applying updates via sub_4957F0 calls while traversing subdirectories.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Dynamically resizes an internal array and appends duplicated input strings along with associated metadata into the array for XML schema processing.",
    "filter2_prorec_aug_sum": "Dynamically grows an array and appends a duplicated string and associated data, managing memory with xmlMalloc/xmlRealloc and tracking count at structure offsets.",
    "filter2_prorec_aug2_sum": "Dynamically resizes an internal array and appends a duplicated input string and associated metadata, initializing its auxiliary fields to zero.",
    "source_code": "\nstatic void\nxmlFARegExecSaveInputString(xmlRegExecCtxtPtr exec, const xmlChar *value,\n\t                    void *data) {\n#ifdef DEBUG_PUSH\n    printf(\"saving value: %d:%s\\n\", exec->inputStackNr, value);\n#endif\n    if (exec->inputStackMax == 0) {\n\texec->inputStackMax = 4;\n\texec->inputStack = (xmlRegInputTokenPtr)\n\t    xmlMalloc(exec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (exec->inputStack == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax = 0;\n\t    return;\n\t}\n    } else if (exec->inputStackNr + 1 >= exec->inputStackMax) {\n\txmlRegInputTokenPtr tmp;\n\n\texec->inputStackMax *= 2;\n\ttmp = (xmlRegInputTokenPtr) xmlRealloc(exec->inputStack,\n\t\t\texec->inputStackMax * sizeof(xmlRegInputToken));\n\tif (tmp == NULL) {\n\t    xmlRegexpErrMemory(NULL, \"pushing input string\");\n\t    exec->inputStackMax /= 2;\n\t    return;\n\t}\n\texec->inputStack = tmp;\n    }\n    exec->inputStack[exec->inputStackNr].value = xmlStrdup(value);\n    exec->inputStack[exec->inputStackNr].data = data;\n    exec->inputStackNr++;\n    exec->inputStack[exec->inputStackNr].value = NULL;\n    exec->inputStack[exec->inputStackNr].data = NULL;\n}",
    "decom_sum": "Adds a new XML input string and associated data to a dynamically resized array within the parser state structure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Dynamically resizes an internal array and appends duplicated input strings along with associated metadata into the array for XML schema processing.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Dynamically grows an array and appends a duplicated string and associated data, managing memory with xmlMalloc/xmlRealloc and tracking count at structure offsets.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Dynamically resizes an internal array and appends a duplicated input string and associated metadata, initializing its auxiliary fields to zero.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
    "filter2_prorec_aug_sum": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
    "filter2_prorec_aug2_sum": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
    "source_code": "static void statPush(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i;\n\n  /* The three function arguments */\n  Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);\n  int iChng = sqlite3_value_int(argv[1]);\n\n  UNUSED_PARAMETER( argc );\n  UNUSED_PARAMETER( context );\n  assert( p->nCol>0 );\n  assert( iChng<p->nCol );\n\n  if( p->nRow==0 ){\n    /* This is the first call to this function. Do initialization. */\n    for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;\n  }else{\n    /* Second and subsequent calls get processed here */\n    samplePushPrevious(p, iChng);\n\n    /* Update anDLt[], anLt[] and anEq[] to reflect the values that apply\n    ** to the current row of the index. */\n    for(i=0; i<iChng; i++){\n      p->current.anEq[i]++;\n    }\n    for(i=iChng; i<p->nCol; i++){\n      p->current.anDLt[i]++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n      p->current.anLt[i] += p->current.anEq[i];\n#endif\n      p->current.anEq[i] = 1;\n    }\n  }\n  p->nRow++;\n#ifdef SQLITE_ENABLE_STAT3_OR_STAT4\n  if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){\n    sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));\n  }else{\n    sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),\n                                       sqlite3_value_blob(argv[2]));\n  }\n  p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;\n#endif\n\n#ifdef SQLITE_ENABLE_STAT4\n  {\n    tRowcnt nLt = p->current.anLt[p->nCol-1];\n\n    /* Check if this is to be a periodic sample. If so, add it. */\n    if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){\n      p->current.isPSample = 1;\n      p->current.iCol = 0;\n      sampleInsert(p, &p->current, p->nCol-1);\n      p->current.isPSample = 0;\n    }\n\n    /* Update the aBest[] array. */\n    for(i=0; i<(p->nCol-1); i++){\n      p->current.iCol = i;\n      if( i>=iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i]) ){\n        sampleCopy(p, &p->aBest[i], &p->current);\n      }\n    }\n  }\n#endif\n}",
    "decom_sum": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
            "flag": true,
            "score": [
                0.6,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Updates indexed counters and flags within a structure based on the given position, then increments the structure\u2019s main operation count.",
            "flag": true,
            "score": [
                0.6,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Converts a numeric value at a1 into a decimal or hexadecimal ASCII string in a3, with formatting based on a2 (base) and a4 (length/width), returning the string length.",
    "filter2_prorec_aug_sum": "Converts a numeric value at a given address to an ASCII string in decimal or hexadecimal format and stores it into the provided buffer.",
    "filter2_prorec_aug2_sum": "Converts a given numeric value to its ASCII string representation in base 10 or 16, handling leading zeros and formatting output accordingly.",
    "source_code": "\nstatic u32\nacpi_ex_convert_to_ascii(u64 integer, u16 base, u8 *string, u8 data_width)\n{\n\tu64 digit;\n\tu32 i;\n\tu32 j;\n\tu32 k = 0;\n\tu32 hex_length;\n\tu32 decimal_length;\n\tu32 remainder;\n\tu8 supress_zeros;\n\n\tACPI_FUNCTION_ENTRY();\n\n\tswitch (base) {\n\tcase 10:\n\n\t\t/* Setup max length for the decimal number */\n\n\t\tswitch (data_width) {\n\t\tcase 1:\n\t\t\tdecimal_length = ACPI_MAX8_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tdecimal_length = ACPI_MAX32_DECIMAL_DIGITS;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\tdefault:\n\t\t\tdecimal_length = ACPI_MAX64_DECIMAL_DIGITS;\n\t\t\tbreak;\n\t\t}\n\n\t\tsupress_zeros = TRUE;\t/* No leading zeros */\n\t\tremainder = 0;\n\n\t\tfor (i = decimal_length; i > 0; i--) {\n\n\t\t\t/* Divide by nth factor of 10 */\n\n\t\t\tdigit = integer;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t(void)acpi_ut_short_divide(digit, 10, &digit,\n\t\t\t\t\t\t\t   &remainder);\n\t\t\t}\n\n\t\t\t/* Handle leading zeros */\n\n\t\t\tif (remainder != 0) {\n\t\t\t\tsupress_zeros = FALSE;\n\t\t\t}\n\n\t\t\tif (!supress_zeros) {\n\t\t\t\tstring[k] = (u8) (ACPI_ASCII_ZERO + remainder);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 16:\n\n\t\t/* hex_length: 2 ascii hex chars per data byte */\n\n\t\thex_length = ACPI_MUL_2(data_width);\n\t\tfor (i = 0, j = (hex_length - 1); i < hex_length; i++, j--) {\n\n\t\t\t/* Get one hex digit, most significant digits first */\n\n\t\t\tstring[k] =\n\t\t\t    (u8) acpi_ut_hex_to_ascii_char(integer,\n\t\t\t\t\t\t\t   ACPI_MUL_4(j));\n\t\t\tk++;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Since leading zeros are suppressed, we must check for the case where\n\t * the integer equals 0\n\t *\n\t * Finally, null terminate the string and return the length\n\t */\n\tif (!k) {\n\t\tstring[0] = ACPI_ASCII_ZERO;\n\t\tk = 1;\n\t}\n\n\tstring[k] = 0;\n\treturn ((u32) k);\n}",
    "decom_sum": "Converts data at address `a1` into an ASCII string in decimal or hexadecimal format based on `a2` and `a4`, writing the result to `a3`.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Converts a numeric value at a1 into a decimal or hexadecimal ASCII string in a3, with formatting based on a2 (base) and a4 (length/width), returning the string length.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Converts a numeric value at a given address to an ASCII string in decimal or hexadecimal format and stores it into the provided buffer.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Converts a given numeric value to its ASCII string representation in base 10 or 16, handling leading zeros and formatting output accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
    "filter2_prorec_aug_sum": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
    "filter2_prorec_aug2_sum": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
    "source_code": "static void renameTriggerFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  int dist = 3;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TRIGGER \n  ** statement is that the table name is the first token that is immediately\n  ** preceded by either TK_ON or TK_DOT and immediately followed by one\n  ** of TK_WHEN, TK_BEGIN or TK_FOR.\n  */\n  if( zSql ){\n    do {\n\n      if( !*zCsr ){\n        /* Ran out of input before finding the table name. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      }while( token==TK_SPACE );\n      assert( len>0 );\n\n      /* Variable 'dist' stores the number of tokens read since the most\n      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN \n      ** token is read and 'dist' equals 2, the condition stated above\n      ** to be met.\n      **\n      ** Note that ON cannot be a database, table or column name, so\n      ** there is no need to worry about syntax like \n      ** \"CREATE TRIGGER ... ON ON.ON BEGIN ...\" etc.\n      */\n      dist++;\n      if( token==TK_DOT || token==TK_ON ){\n        dist = 0;\n      }\n    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );\n\n    /* Variable tname now contains the token that is the old table-name\n    ** in the CREATE TRIGGER statement.\n    */\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", (int)(((u8*)tname.z) - zSql),\n       zSql, zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}",
    "decom_sum": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses a byte sequence from memory, detects specific opcode patterns, and constructs and dispatches a formatted command string using matched data.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates over descriptor entries from a2, calls processing subroutine on each, sets a specific flag bit if condition met, and returns a computed status value.",
    "filter2_prorec_aug_sum": "Iterates over specific indexed entries in a2, processes them via sub_FFFFFFFF8129B260, updates flags, and validates processed count against a2\u2019s limit field.",
    "filter2_prorec_aug2_sum": "Iterates over ext4 extent tree nodes to update extent status flags and verify consistency against inode metadata.",
    "source_code": "int blk_bio_map_sg(struct request_queue *q, struct bio *bio,\n\t\t   struct scatterlist *sglist)\n{\n\tstruct bio_vec *bvec, *bvprv;\n\tstruct scatterlist *sg;\n\tint nsegs, cluster;\n\tunsigned long i;\n\n\tnsegs = 0;\n\tcluster = blk_queue_cluster(q);\n\n\tbvprv = NULL;\n\tsg = NULL;\n\tbio_for_each_segment(bvec, bio, i) {\n\t\t__blk_segment_map_sg(q, bvec, sglist, &bvprv, &sg,\n\t\t\t\t     &nsegs, &cluster);\n\t} /* segments in bio */\n\n\tif (sg)\n\t\tsg_mark_end(sg);\n\n\tBUG_ON(bio->bi_phys_segments && nsegs > bio->bi_phys_segments);\n\treturn nsegs;\n}",
    "decom_sum": "Iterates over specific indexed entries in a2, processes them via sub_FFFFFFFF8129B260, updates flags, and validates processed count against a2\u2019s limit field.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates over descriptor entries from a2, calls processing subroutine on each, sets a specific flag bit if condition met, and returns a computed status value.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates over specific indexed entries in a2, processes them via sub_FFFFFFFF8129B260, updates flags, and validates processed count against a2\u2019s limit field.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates over ext4 extent tree nodes to update extent status flags and verify consistency against inode metadata.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Sends a specified or adjusted signal to a target process and its group, optionally logging the action and handling special termination or stop cases.",
    "filter2_prorec_aug_sum": "Sends a specified or adjusted signal to a target process and its group, optionally logging the action and handling special termination or stop cases.",
    "filter2_prorec_aug2_sum": "Sends the specified signal to the stored process ID, handling special cases for SIGKILL, SIGSTOP, and managing error reporting and signal resetting.",
    "source_code": "\nstatic void\ncleanup (void)\n{\n  if (close (STDIN_FILENO) < 0)\n    die (EXIT_FAILURE, errno, _(\"closing input file %s\"), quoteaf (input_file));\n\n  /* Don't remove this call to close, even though close_stdout\n     closes standard output.  This close is necessary when cleanup\n     is called as part of a signal handler.  */\n  if (close (STDOUT_FILENO) < 0)\n    die (EXIT_FAILURE, errno,\n         _(\"closing output file %s\"), quoteaf (output_file));\n}",
    "decom_sum": "Sends a specified or adjusted signal to a target process and its group, optionally logging the action and handling special termination or stop cases.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Sends a specified or adjusted signal to a target process and its group, optionally logging the action and handling special termination or stop cases.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Sends a specified or adjusted signal to a target process and its group, optionally logging the action and handling special termination or stop cases.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Sends the specified signal to the stored process ID, handling special cases for SIGKILL, SIGSTOP, and managing error reporting and signal resetting.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
    "filter2_prorec_aug_sum": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
    "filter2_prorec_aug2_sum": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
    "source_code": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
    "decom_sum": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and configures data structures for each registered entry, applies a processing callback with provided parameters, then finalizes and frees allocated resources.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates that specific 64-bit fields in the input structure fit within 32 bits, copies them into the output array, checks bounds, and processes remaining data, returning error codes on failure.",
    "filter2_prorec_aug_sum": "Validates 64-bit field ranges from a2, copies them into a1, then performs a bounds check and data initialization via sub_FFFFFFFF812BA550.",
    "filter2_prorec_aug2_sum": "Validates 32-bit integrity and bounds of fields from a2, copies them into a1, then initializes a1's extended state and returns success or error code.",
    "source_code": "\nstatic int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\t\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tif (!access_ok(VERIFY_WRITE, ubuf, sizeof(*ubuf)) ||\n\t    __put_user(kbuf->f_type, &ubuf->f_type) ||\n\t    __put_user(kbuf->f_bsize, &ubuf->f_bsize) ||\n\t    __put_user(kbuf->f_blocks, &ubuf->f_blocks) ||\n\t    __put_user(kbuf->f_bfree, &ubuf->f_bfree) ||\n\t    __put_user(kbuf->f_bavail, &ubuf->f_bavail) ||\n\t    __put_user(kbuf->f_files, &ubuf->f_files) ||\n\t    __put_user(kbuf->f_ffree, &ubuf->f_ffree) ||\n\t    __put_user(kbuf->f_namelen, &ubuf->f_namelen) ||\n\t    __put_user(kbuf->f_fsid.val[0], &ubuf->f_fsid.val[0]) ||\n\t    __put_user(kbuf->f_fsid.val[1], &ubuf->f_fsid.val[1]) ||\n\t    __put_user(kbuf->f_frsize, &ubuf->f_frsize) ||\n\t    __put_user(kbuf->f_flags, &ubuf->f_flags) ||\n\t    __clear_user(ubuf->f_spare, sizeof(ubuf->f_spare)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "decom_sum": "Validates 64-bit field ranges from a2, copies them into a1, then performs a bounds check and data initialization via sub_FFFFFFFF812BA550.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates that specific 64-bit fields in the input structure fit within 32 bits, copies them into the output array, checks bounds, and processes remaining data, returning error codes on failure.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates 64-bit field ranges from a2, copies them into a1, then performs a bounds check and data initialization via sub_FFFFFFFF812BA550.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates 32-bit integrity and bounds of fields from a2, copies them into a1, then initializes a1's extended state and returns success or error code.",
            "flag": false,
            "score": [
                0.3,
                0.6,
                0.5
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
    "filter2_prorec_aug_sum": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
    "filter2_prorec_aug2_sum": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
    "source_code": "\n\nsize_t ZSTD_compressEnd (ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize)\n{\n    size_t endResult;\n    size_t const cSize = ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1, 1);\n    if (ZSTD_isError(cSize)) return cSize;\n    endResult = ZSTD_writeEpilogue(cctx, (char*)dst + cSize, dstCapacity-cSize);\n    if (ZSTD_isError(endResult)) return endResult;\n    return cSize + endResult;\n}",
    "decom_sum": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
            "flag": true,
            "score": [
                0.4,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
            "flag": true,
            "score": [
                0.4,
                0.3,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes a data block with state-dependent transformations, updating control fields and appending bytes before returning the processed length or an error code.",
            "flag": true,
            "score": [
                0.4,
                0.3,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Configures timing parameters and thresholds in microseconds based on protocol type, retry count, and device characteristics for NFC lock state management.",
    "filter2_prorec_aug_sum": "Calculates and sets timer intervals and parameters based on protocol type, timing values, and flags, enforcing minimum and maximum durations with error checks.",
    "filter2_prorec_aug2_sum": "Calculates and sets timing-related fields in a structure based on protocol type, retry counts, and configured timeouts with enforced minimum and maximum limits.",
    "source_code": "void nfs_init_timeout_values(struct rpc_timeout *to, int proto,\n\t\t\t\t    unsigned int timeo, unsigned int retrans)\n{\n\tto->to_initval = timeo * HZ / 10;\n\tto->to_retries = retrans;\n\n\tswitch (proto) {\n\tcase XPRT_TRANSPORT_TCP:\n\tcase XPRT_TRANSPORT_RDMA:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_TCP_RETRANS;\n\t\tif (to->to_initval == 0)\n\t\t\tto->to_initval = NFS_DEF_TCP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_TCP_TIMEOUT;\n\t\tto->to_increment = to->to_initval;\n\t\tto->to_maxval = to->to_initval + (to->to_increment * to->to_retries);\n\t\tif (to->to_maxval > NFS_MAX_TCP_TIMEOUT)\n\t\t\tto->to_maxval = NFS_MAX_TCP_TIMEOUT;\n\t\tif (to->to_maxval < to->to_initval)\n\t\t\tto->to_maxval = to->to_initval;\n\t\tto->to_exponential = 0;\n\t\tbreak;\n\tcase XPRT_TRANSPORT_UDP:\n\t\tif (to->to_retries == 0)\n\t\t\tto->to_retries = NFS_DEF_UDP_RETRANS;\n\t\tif (!to->to_initval)\n\t\t\tto->to_initval = NFS_DEF_UDP_TIMEO * HZ / 10;\n\t\tif (to->to_initval > NFS_MAX_UDP_TIMEOUT)\n\t\t\tto->to_initval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_maxval = NFS_MAX_UDP_TIMEOUT;\n\t\tto->to_exponential = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "decom_sum": "Calculates and sets timing parameters and mode fields in a control structure based on input arguments, enforcing bounds and defaults for specific operating modes.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Configures timing parameters and thresholds in microseconds based on protocol type, retry count, and device characteristics for NFC lock state management.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates and sets timer intervals and parameters based on protocol type, timing values, and flags, enforcing minimum and maximum durations with error checks.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates and sets timing-related fields in a structure based on protocol type, retry counts, and configured timeouts with enforced minimum and maximum limits.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
    "filter2_prorec_aug_sum": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
    "filter2_prorec_aug2_sum": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
    "source_code": "\nint\nfreadseek (FILE *fp, size_t offset)\n{\n  size_t total_buffered;\n  int fd;\n\n  if (offset == 0)\n    return 0;\n\n  /* Seek over the already read and buffered input as quickly as possible,\n     without doing any system calls.  */\n  total_buffered = freadahead (fp);\n  /* This loop is usually executed at most twice: once for ungetc buffer (if\n     present) and once for the main buffer.  */\n  while (total_buffered > 0)\n    {\n      size_t buffered;\n\n      if (freadptr (fp, &buffered) != NULL && buffered > 0)\n        {\n          size_t increment = (buffered < offset ? buffered : offset);\n\n          freadptrinc (fp, increment);\n          offset -= increment;\n          if (offset == 0)\n            return 0;\n          total_buffered -= increment;\n          if (total_buffered == 0)\n            break;\n        }\n      /* Read one byte.  If we were reading from the ungetc buffer, this\n         switches the stream back to the main buffer.  */\n      if (fgetc (fp) == EOF)\n        goto eof;\n      offset--;\n      if (offset == 0)\n        return 0;\n      total_buffered--;\n    }\n\n  /* Test whether the stream is seekable or not.  */\n  fd = fileno (fp);\n  if (fd >= 0 && lseek (fd, 0, SEEK_CUR) >= 0)\n    {\n      /* FP refers to a regular file.  fseek is most efficient in this case.  */\n      return fseeko (fp, offset, SEEK_CUR);\n    }\n  else\n    {\n      /* FP is a non-seekable stream, possibly not even referring to a file\n         descriptor.  Read OFFSET bytes explicitly and discard them.  */\n      char buf[4096];\n\n      do\n        {\n          size_t count = (sizeof (buf) < offset ? sizeof (buf) : offset);\n          if (fread (buf, 1, count, fp) < count)\n            goto eof;\n          offset -= count;\n        }\n      while (offset > 0);\n\n      return 0;\n   }\n\n eof:\n  /* EOF, or error before or while reading.  */\n  if (ferror (fp))\n    return EOF;\n  else\n    /* Encountered EOF.  */\n    return 0;\n}",
    "decom_sum": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Skips a specified number of bytes in a FILE stream using buffered reads, `lseek`, or manual reading, depending on buffering and seekability.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes an \"xzfile\" connection object with buffers, sets function pointers, and stores given parameters for use in xz compressed file operations.",
    "filter2_prorec_aug_sum": "Allocates and initializes an xzfile connection structure with buffers, function pointers, and configuration parameters for decompression or streaming operations.",
    "filter2_prorec_aug2_sum": "Initializes and returns a configured xzfile connection structure with custom function pointers and allocated buffers using the provided filename and options.",
    "source_code": "\nstatic Rconnection\nnewxzfile(const char *description, const char *mode, int type, int compress)\n{\n    Rconnection new;\n    new = (Rconnection) malloc(sizeof(struct Rconn));\n    if(!new) error(_(\"allocation of xzfile connection failed\"));\n    new->class = (char *) malloc(strlen(\"xzfile\") + 1);\n    if(!new->class) {\n\tfree(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    strcpy(new->class, \"xzfile\");\n    new->description = (char *) malloc(strlen(description) + 1);\n    if(!new->description) {\n\tfree(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    init_con(new, description, CE_NATIVE, mode);\n\n    new->canseek = FALSE;\n    new->open = &xzfile_open;\n    new->close = &xzfile_close;\n    new->vfprintf = &dummy_vfprintf;\n    new->fgetc_internal = &xzfile_fgetc_internal;\n    new->fgetc = &dummy_fgetc;\n    new->seek = &null_seek;\n    new->fflush = &null_fflush;\n    new->read = &xzfile_read;\n    new->write = &xzfile_write;\n    new->private = (void *) malloc(sizeof(struct xzfileconn));\n    memset(new->private, 0, sizeof(struct xzfileconn));\n    if(!new->private) {\n\tfree(new->description); free(new->class); free(new);\n\terror(_(\"allocation of xzfile connection failed\"));\n\t/* for Solaris 12.5 */ new = NULL;\n    }\n    ((Rxzfileconn) new->private)->type = type;\n    ((Rxzfileconn) new->private)->compress = compress;\n    return new;\n}",
    "decom_sum": "Allocates and initializes an xzfile connection structure, assigns I/O handler function pointers, and stores compression parameters a3 and a4.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes an \"xzfile\" connection object with buffers, sets function pointers, and stores given parameters for use in xz compressed file operations.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes an xzfile connection structure with buffers, function pointers, and configuration parameters for decompression or streaming operations.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and returns a configured xzfile connection structure with custom function pointers and allocated buffers using the provided filename and options.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates dimensions, copies and weights matrix and vectors, then scales rows of matrix and vector by the square root of corresponding weights for weighted linear fitting.",
    "filter2_prorec_aug_sum": "Validates input dimensions and applies weights by scaling each row of matrix WX and vector Wy with the square root of non-negative weights from vector W.",
    "filter2_prorec_aug2_sum": "Validates dimensions and applies weighting to matrix and vector data, scaling each row of matrix 'a4' and corresponding vector 'a5' by square roots of weights from vector 'a2'.",
    "source_code": "\nint\ngsl_multifit_linear_applyW(const gsl_matrix * X,\n                           const gsl_vector * w,\n                           const gsl_vector * y,\n                           gsl_matrix * WX,\n                           gsl_vector * Wy)\n{\n  const size_t n = X->size1;\n  const size_t p = X->size2;\n\n  if (n != y->size)\n    {\n      GSL_ERROR(\"y vector does not match X\", GSL_EBADLEN);\n    }\n  else if (w != NULL && n != w->size)\n    {\n      GSL_ERROR(\"weight vector does not match X\", GSL_EBADLEN);\n    }\n  else if (n != WX->size1 || p != WX->size2)\n    {\n      GSL_ERROR(\"WX matrix dimensions do not match X\", GSL_EBADLEN);\n    }\n  else if (n != Wy->size)\n    {\n      GSL_ERROR(\"Wy vector must be length n\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i;\n\n      /* copy WX = X; Wy = y if distinct pointers */\n      if (WX != X)\n        gsl_matrix_memcpy(WX, X);\n      if (Wy != y)\n        gsl_vector_memcpy(Wy, y);\n\n      if (w != NULL)\n        {\n          /* construct WX = sqrt(W) X and Wy = sqrt(W) y */\n          for (i = 0; i < n; ++i)\n            {\n              double wi = gsl_vector_get(w, i);\n              double swi;\n              gsl_vector_view row = gsl_matrix_row(WX, i);\n              double *yi = gsl_vector_ptr(Wy, i);\n\n              if (wi < 0.0)\n                wi = 0.0;\n\n              swi = sqrt(wi);\n              gsl_vector_scale(&row.vector, swi);\n              *yi *= swi;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "decom_sum": "Validates dimensional consistency of input vectors/matrices and applies square-root weight scaling to both matrix rows and corresponding vector elements.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates dimensions, copies and weights matrix and vectors, then scales rows of matrix and vector by the square root of corresponding weights for weighted linear fitting.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates input dimensions and applies weights by scaling each row of matrix WX and vector Wy with the square root of non-negative weights from vector W.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates dimensions and applies weighting to matrix and vector data, scaling each row of matrix 'a4' and corresponding vector 'a5' by square roots of weights from vector 'a2'.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Reads and converts data from an object at a1 based on its type field, handling raw memory, string parsing for special float values, or calling processing callbacks.",
    "filter2_prorec_aug_sum": "Parses data from a structure based on a type field, converts strings like \"NA\", \"NaN\", \"Inf\" to special floating values, or calls handlers for data extraction.",
    "filter2_prorec_aug2_sum": "Reads and parses a value from an object at a1 based on its type field, converting to floating-point or calling specialized handlers, and errors on invalid input.",
    "source_code": "\nstatic double InReal(R_inpstream_t stream)\n{\n    char word[128];\n    char buf[128];\n    double d;\n\n    switch (stream->type) {\n    case R_pstream_ascii_format:\n\tInWord(stream, word, sizeof(word));\n\tif(sscanf(word, \"%127s\", buf) != 1) error(_(\"read error\"));\n\tif (strcmp(buf, \"NA\") == 0)\n\t    return NA_REAL;\n\telse if (strcmp(buf, \"NaN\") == 0)\n\t    return R_NaN;\n\telse if (strcmp(buf, \"Inf\") == 0)\n\t    return R_PosInf;\n\telse if (strcmp(buf, \"-Inf\") == 0)\n\t    return R_NegInf;\n\telse\n\t    if(\n#ifdef Win32\n\t\ttrio_sscanf(buf, \"%lg\", &d)\n#else\n\t\tsscanf(buf, \"%lg\", &d)\n#endif\n\t\t!= 1) error(_(\"read error\"));\n\treturn d;\n    case R_pstream_binary_format:\n\tstream->InBytes(stream, &d, sizeof(double));\n\treturn d;\n    case R_pstream_xdr_format:\n\tstream->InBytes(stream, buf, R_XDR_DOUBLE_SIZE);\n\treturn R_XDRDecodeDouble(buf);\n    default:\n\treturn NA_REAL;\n    }\n}",
    "decom_sum": "Parses numeric or special string values from input based on type code, converting them to double precision and aborting on read or format errors.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Reads and converts data from an object at a1 based on its type field, handling raw memory, string parsing for special float values, or calling processing callbacks.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses data from a structure based on a type field, converts strings like \"NA\", \"NaN\", \"Inf\" to special floating values, or calls handlers for data extraction.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Reads and parses a value from an object at a1 based on its type field, converting to floating-point or calling specialized handlers, and errors on invalid input.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Translates and validates a physical memory address range for DMA access, enforcing permissions and logging warnings on invalid or unsafe mappings.",
    "filter2_prorec_aug_sum": "Calculates and validates a DMA-accessible memory address range, logs errors on invalid access, and updates device state accordingly.",
    "filter2_prorec_aug2_sum": "Calculates and validates a physical memory address range for DMA access, handling errors and logging invalid or unauthorized DMA memory accesses.",
    "source_code": "dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,\n\t\t\t    unsigned long offset, size_t size,\n\t\t\t    enum dma_data_direction dir,\n\t\t\t    struct dma_attrs *attrs)\n{\n\tphys_addr_t map, phys = page_to_phys(page) + offset;\n\tdma_addr_t dev_addr = phys_to_dma(dev, phys);\n\n\tBUG_ON(dir == DMA_NONE);\n\t/*\n\t * If the address happens to be in the device's DMA window,\n\t * we can safely return the device addr and not worry about bounce\n\t * buffering it.\n\t */\n\tif (dma_capable(dev, dev_addr, size) && !swiotlb_force)\n\t\treturn dev_addr;\n\n\t/* Oh well, have to allocate and map a bounce buffer. */\n\tmap = map_single(dev, phys, size, dir);\n\tif (map == SWIOTLB_MAP_ERROR) {\n\t\tswiotlb_full(dev, size, dir, 1);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\tdev_addr = phys_to_dma(dev, map);\n\n\t/* Ensure that the address returned is DMA'ble */\n\tif (!dma_capable(dev, dev_addr, size)) {\n\t\tswiotlb_tbl_unmap_single(dev, map, size, dir);\n\t\treturn phys_to_dma(dev, io_tlb_overflow_buffer);\n\t}\n\n\treturn dev_addr;\n}",
    "decom_sum": "Checks and maps a DMA memory region for a device, handling failures with debug logging and enforcing access range constraints.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Translates and validates a physical memory address range for DMA access, enforcing permissions and logging warnings on invalid or unsafe mappings.",
            "flag": false,
            "score": [
                0.4,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates and validates a DMA-accessible memory address range, logs errors on invalid access, and updates device state accordingly.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates and validates a physical memory address range for DMA access, handling errors and logging invalid or unauthorized DMA memory accesses.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Handles different write operations to a device or context depending on the mode, including partial buffer writes and error conditions, returning bytes written or error codes.",
    "filter2_prorec_aug_sum": "Handles various command codes to transfer data from kernel buffers to a target address or validate writes, returning status codes based on operation success.",
    "filter2_prorec_aug2_sum": "Processes input based on a1 value to read or verify data from a structure at a GS-relative offset, handling fixed-length buffers and returning status codes.",
    "source_code": "\nasmlinkage int sys_modify_ldt(int func, void __user *ptr,\n\t\t\t      unsigned long bytecount)\n{\n\tint ret = -ENOSYS;\n\n\tswitch (func) {\n\tcase 0:\n\t\tret = read_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 1:\n\t\tret = write_ldt(ptr, bytecount, 1);\n\t\tbreak;\n\tcase 2:\n\t\tret = read_default_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 0x11:\n\t\tret = write_ldt(ptr, bytecount, 0);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "decom_sum": "Handles various command codes to transfer data from kernel buffers to a target address or validate writes, returning status codes based on operation success.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Handles different write operations to a device or context depending on the mode, including partial buffer writes and error conditions, returning bytes written or error codes.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Handles various command codes to transfer data from kernel buffers to a target address or validate writes, returning status codes based on operation success.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes input based on a1 value to read or verify data from a structure at a GS-relative offset, handling fixed-length buffers and returning status codes.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Sets the USB device's U1 or U2 Link Power Management (LPM) timeout, validating state and value, logging errors on invalid inputs or hardware communication failure.",
    "filter2_prorec_aug_sum": "Sets the USB hub\u2019s U1 or U2 low power mode timeout value, validating input and logging errors for invalid states or reserved values.",
    "filter2_prorec_aug2_sum": "Sets USB device U1 or U2 low power mode timeout value, validating input and logging errors if setting the timeout fails or if state is unsupported.",
    "source_code": "\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}",
    "decom_sum": "Sets USB U1 or U2 link power management timeout via a device command, validating parameters and logging errors on invalid states or command failures.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Sets the USB device's U1 or U2 Link Power Management (LPM) timeout, validating state and value, logging errors on invalid inputs or hardware communication failure.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Sets the USB hub\u2019s U1 or U2 low power mode timeout value, validating input and logging errors for invalid states or reserved values.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Sets USB device U1 or U2 low power mode timeout value, validating input and logging errors if setting the timeout fails or if state is unsupported.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a structure with request data and copies up to 16 integers from a source pointer, setting default values if the source is empty or small.",
    "filter2_prorec_aug_sum": "Initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a2, and sets default entries to -1.",
    "filter2_prorec_aug2_sum": "Initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a2, and sets default entries to -1.",
    "source_code": "\nstatic struct rpc_cred *\nunx_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\n{\n\tstruct unx_cred\t*cred;\n\tunsigned int groups = 0;\n\tunsigned int i;\n\n\tdprintk(\"RPC:       allocating UNIX cred for uid %d gid %d\\n\",\n\t\t\tfrom_kuid(&init_user_ns, acred->uid),\n\t\t\tfrom_kgid(&init_user_ns, acred->gid));\n\n\tif (!(cred = kmalloc(sizeof(*cred), GFP_NOFS)))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpcauth_init_cred(&cred->uc_base, acred, auth, &unix_credops);\n\tcred->uc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\n\n\tif (acred->group_info != NULL)\n\t\tgroups = acred->group_info->ngroups;\n\tif (groups > NFS_NGROUPS)\n\t\tgroups = NFS_NGROUPS;\n\n\tcred->uc_gid = acred->gid;\n\tfor (i = 0; i < groups; i++)\n\t\tcred->uc_gids[i] = GROUP_AT(acred->group_info, i);\n\tif (i < NFS_NGROUPS)\n\t\tcred->uc_gids[i] = INVALID_GID;\n\n\treturn &cred->uc_base;\n}",
    "decom_sum": "Initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a2, and sets default entries to -1.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a structure with request data and copies up to 16 integers from a source pointer, setting default values if the source is empty or small.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a2, and sets default entries to -1.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a 160-byte structure with input parameters, copies up to 16 configuration values from a2, and sets default entries to -1.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Prints detailed FTP server status, including software version, connection info, session state, transfer settings, and data connection mode, then signals status end.",
    "filter2_prorec_aug_sum": "Prints detailed FTP server status including connection info, login state, transfer type, data connection mode, and session timeout.",
    "filter2_prorec_aug2_sum": "Prints detailed FTP server status, including software version, connection info, session state, transfer settings, and data connection mode, then signals status end.",
    "source_code": "\nvoid\nstatcmd (void)\n{\n  struct sockaddr_storage *sin;\n  unsigned char *a, *p;\n\n  lreply (211, \"%s FTP server status:\", hostname);\n  if (!no_version)\n    printf (\"     ftpd (%s) %s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n  printf (\"     Connected to %s\", cred.remotehost);\n  (void) getnameinfo ((struct sockaddr *) &his_addr, his_addrlen,\n\t\t      addrstr, sizeof (addrstr), NULL, 0, NI_NUMERICHOST);\n  if (!isdigit (cred.remotehost[0]))\n    printf (\" (%s)\", addrstr);\n  printf (\"\\r\\n\");\n  printf (\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if (cred.logged_in)\n    {\n      if (cred.guest)\n\tprintf (\"     Logged in anonymously\\r\\n\");\n      else\n\tprintf (\"     Logged in as %s\\r\\n\", cred.name);\n    }\n  else if (askpasswd)\n    printf (\"     Waiting for password\\r\\n\");\n  else\n    printf (\"     Waiting for user name\\r\\n\");\n  printf (\"     TYPE: %s\", typenames[type]);\n  if (type == TYPE_A || type == TYPE_E)\n    printf (\", FORM: %s\", formnames[form]);\n  if (type == TYPE_L)\n#ifdef CHAR_BIT\n    printf (\" %d\", CHAR_BIT);\n#else\n# if NBBY == 8\n    printf (\" %d\", NBBY);\n# else\n    printf (\" %d\", bytesize);\t/* need definition! */\n# endif\n#endif\n  printf (\"; STRUcture: %s; transfer MODE: %s\\r\\n\",\n\t  strunames[stru], modenames[stru_mode]);\n  if (data != -1)\n    printf (\"     Data connection open\\r\\n\");\n  else if (pdata != -1)\n    {\n      printf (\"     in Passive mode\");\n      sin = &pasv_addr;\n      goto printaddr;\n    }\n  else if (usedefault == 0)\n    {\n      printf (\"     PORT\");\n      sin = &data_dest;\n    printaddr:\n      a = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_addr;\n      p = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_port;\n#define UC(b) (((int) b) & 0xff)\n      printf (\" (%d,%d,%d,%d,%d,%d)\\r\\n\", UC (a[0]),\n\t      UC (a[1]), UC (a[2]), UC (a[3]), UC (p[0]), UC (p[1]));\n#undef UC\n    }\n  else\n    printf (\"     No data connection\\r\\n\");\n  reply (211, \"End of status\");\n}",
    "decom_sum": "Prints detailed FTP server status, including software version, connection info, session state, transfer settings, and data connection mode, then signals status end.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Prints detailed FTP server status, including software version, connection info, session state, transfer settings, and data connection mode, then signals status end.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Prints detailed FTP server status including connection info, login state, transfer type, data connection mode, and session timeout.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Prints detailed FTP server status, including software version, connection info, session state, transfer settings, and data connection mode, then signals status end.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Decodes audio or compressed frame data from input buffer, handling format-dependent byte alignment and returning processed data size in bytes.",
    "filter2_prorec_aug_sum": "Processes and converts audio or data streams by conditionally handling bit-depth and format, performing buffer prep, validation, conversion, and returning processed byte size.",
    "filter2_prorec_aug2_sum": "Processes audio data by conditionally converting or streaming it based on format presence and parameters, returning processed byte count or an error code.",
    "source_code": "\nstatic ssize_t snd_pcm_oss_write2(struct snd_pcm_substream *substream, const char *buf, size_t bytes, int in_kernel)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_sframes_t frames, frames1;\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\n\tif (runtime->oss.plugin_first) {\n\t\tstruct snd_pcm_plugin_channel *channels;\n\t\tsize_t oss_frame_bytes = (runtime->oss.plugin_first->src_width * runtime->oss.plugin_first->src_format.channels) / 8;\n\t\tif (!in_kernel) {\n\t\t\tif (copy_from_user(runtime->oss.buffer, (const char __force __user *)buf, bytes))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf = runtime->oss.buffer;\n\t\t}\n\t\tframes = bytes / oss_frame_bytes;\n\t\tframes1 = snd_pcm_plug_client_channels_buf(substream, (char *)buf, frames, &channels);\n\t\tif (frames1 < 0)\n\t\t\treturn frames1;\n\t\tframes1 = snd_pcm_plug_write_transfer(substream, channels, frames1);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames1 * oss_frame_bytes;\n\t} else\n#endif\n\t{\n\t\tframes = bytes_to_frames(runtime, bytes);\n\t\tframes1 = snd_pcm_oss_write3(substream, buf, frames, in_kernel);\n\t\tif (frames1 <= 0)\n\t\t\treturn frames1;\n\t\tbytes = frames_to_bytes(runtime, frames1);\n\t}\n\treturn bytes;\n}",
    "decom_sum": "Processes data blocks by retrieving buffer parameters, performing conditional setup, and delegating to specialized functions to compute and return the adjusted byte count.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Decodes audio or compressed frame data from input buffer, handling format-dependent byte alignment and returning processed data size in bytes.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes and converts audio or data streams by conditionally handling bit-depth and format, performing buffer prep, validation, conversion, and returning processed byte size.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes audio data by conditionally converting or streaming it based on format presence and parameters, returning processed byte count or an error code.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.5
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
    "filter2_prorec_aug_sum": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
    "filter2_prorec_aug2_sum": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
    "source_code": "static int\nbackward_move_node_structure (WINDOW *window, int behaviour)\n{\n  if (window->node->flags & (N_IsInternal | N_IsManPage))\n    return 1;\n\n  switch (behaviour)\n    {\n    case IS_PageOnly:\n      info_error (\"%s\", msg_at_node_top);\n      return 1;\n\n    case IS_NextOnly:\n      return !info_handle_pointer (\"Prev\", window);\n      break;\n\n    case IS_Continuous:\n      if (window->node->up)\n        {\n          /* If up is the dir node, we are at the top node.\n             Don't do anything. */\n          if (!strncasecmp (window->node->up, \"(dir)\", strlen (\"(dir)\")))\n            {\n              info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n              return 1;\n            }\n          /* If 'Prev' and 'Up' are the same, we are at the first node\n             of the 'Up' node's menu. Go to up node. */\n          else if (window->node->prev\n              && !strcmp(window->node->prev, window->node->up))\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n          /* Otherwise, go to 'Prev' node and go down the last entry\n             in the menus as far as possible. */\n          else if (window->node->prev)\n            {\n              int starting_hist_index = window->hist_index;\n              if (!info_handle_pointer (\"Prev\", window))\n                return 1;\n              if (!(window->node->flags & N_IsIndex))\n                {\n                  while (1)\n                    {\n                      REFERENCE *entry = select_menu_digit (window, '0');\n                      if (!entry)\n                        break;\n                      if (!info_select_reference (window, entry))\n                        break;\n                    }\n                  /* Don't include intermediate nodes in the window's\n                     history.  */\n                  cleanup_history (window, starting_hist_index,\n                                   window->hist_index - 1);\n                }\n            }\n          else /* 'Up' but no 'Prev' */\n            {\n              if (!info_handle_pointer (\"Up\", window))\n                return 1;\n            }\n        }\n      else if (window->node->prev) /* 'Prev' but no 'Up' */\n        {\n          if (!info_handle_pointer (\"Prev\", window))\n            return 1;\n        }\n      else\n        {\n          info_error (\"%s\", _(\"No 'Prev' or 'Up' for this node within this document\"));\n          return 1;\n        }\n\n      break; /* case IS_Continuous: */\n    }\n  return 0;\n}",
    "decom_sum": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Handles navigation commands by executing \"Prev\" or \"Up\" actions, displaying messages, and updating document node state based on navigation context and flags.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a dogleg state structure with multiple gsl_vector objects and copies provided vector data into the new state.",
    "filter2_prorec_aug_sum": "Allocates and initializes a dogleg state structure with multiple gsl_vector objects and copies vector data from the input __m128i array.",
    "filter2_prorec_aug2_sum": "Allocates and initializes a dogleg state structure with gsl_vectors of sizes a2 and a3 and copies SIMD vector data from the input pointer a1.",
    "source_code": "\nstatic void *\ndogleg_alloc (const void * params, const size_t n, const size_t p)\n{\n  dogleg_state_t *state;\n  \n  state = calloc(1, sizeof(dogleg_state_t));\n  if (state == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate dogleg state\", GSL_ENOMEM);\n    }\n\n  state->dx_gn = gsl_vector_alloc(p);\n  if (state->dx_gn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_gn\", GSL_ENOMEM);\n    }\n\n  state->dx_sd = gsl_vector_alloc(p);\n  if (state->dx_sd == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for dx_sd\", GSL_ENOMEM);\n    }\n\n  state->workp1 = gsl_vector_alloc(p);\n  if (state->workp1 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp1\", GSL_ENOMEM);\n    }\n\n  state->workp2 = gsl_vector_alloc(p);\n  if (state->workp2 == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workp2\", GSL_ENOMEM);\n    }\n\n  state->workn = gsl_vector_alloc(n);\n  if (state->workn == NULL)\n    {\n      GSL_ERROR_NULL (\"failed to allocate space for workn\", GSL_ENOMEM);\n    }\n\n  state->n = n;\n  state->p = p;\n  state->params = *(const gsl_multilarge_nlinear_parameters *) params;\n\n  return state;\n}",
    "decom_sum": "Allocates and initializes a GSL dogleg optimization state structure with required working vectors, copying configuration and data from the provided template state.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a dogleg state structure with multiple gsl_vector objects and copies provided vector data into the new state.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a dogleg state structure with multiple gsl_vector objects and copies vector data from the input __m128i array.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes a dogleg state structure with gsl_vectors of sizes a2 and a3 and copies SIMD vector data from the input pointer a1.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes OS-specific parameters including page size, CPU count, cache line size, resource limits, and seeds the random number generator using process-specific values.",
    "filter2_prorec_aug_sum": "Initializes OS-specific parameters including page size, CPU count, cache line size, resource limits, CPU info, and seeds the random number generator for NGINX environment.",
    "filter2_prorec_aug2_sum": "Initializes operating system parameters like page size, CPU count, cacheline size, resource limits, and seeds the random number generator for process initialization.",
    "source_code": "\n\nngx_int_t\nngx_os_init(ngx_log_t *log)\n{\n    ngx_time_t  *tp;\n    ngx_uint_t   n;\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    long         size;\n#endif\n\n#if (NGX_HAVE_OS_SPECIFIC_INIT)\n    if (ngx_os_specific_init(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_init_setproctitle(log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_pagesize = getpagesize();\n    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n\n    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n\n#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n    if (ngx_ncpu == 0) {\n        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n#endif\n\n    if (ngx_ncpu < 1) {\n        ngx_ncpu = 1;\n    }\n\n#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n    if (size > 0) {\n        ngx_cacheline_size = size;\n    }\n#endif\n\n    ngx_cpuinfo();\n\n    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n        ngx_log_error(NGX_LOG_ALERT, log, errno,\n                      \"getrlimit(RLIMIT_NOFILE) failed\");\n        return NGX_ERROR;\n    }\n\n    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n\n#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n    ngx_inherited_nonblocking = 1;\n#else\n    ngx_inherited_nonblocking = 0;\n#endif\n\n    tp = ngx_timeofday();\n    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n\n    return NGX_OK;\n}",
    "decom_sum": "Initializes OS-specific parameters for Nginx, setting system page size, CPU/cache info, file descriptor limits, nonblocking mode, and seeding the random generator.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes OS-specific parameters including page size, CPU count, cache line size, resource limits, and seeds the random number generator using process-specific values.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes OS-specific parameters including page size, CPU count, cache line size, resource limits, CPU info, and seeds the random number generator for NGINX environment.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes operating system parameters like page size, CPU count, cacheline size, resource limits, and seeds the random number generator for process initialization.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates position offsets against buffer boundaries and triggers sub_FFFFFFFF81641390 to process a segment when movement crosses specific size or alignment thresholds.",
    "filter2_prorec_aug_sum": "Performs bounds checks and conditional partial processing on data segments, invoking sub_FFFFFFFF81641390 to handle fixed-size chunk operations within range constraints.",
    "filter2_prorec_aug2_sum": "Validates and adjusts a data range against buffer boundaries, calling a processing routine on the aligned subset and returning success or error status.",
    "source_code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 start_seq, u32 end_seq)\n{\n\tint err;\n\tbool in_sack;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Round if necessary so that SACKs cover only full MSSes\n\t\t * and/or the remaining small portion (if present)\n\t\t */\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn in_sack;\n}",
    "decom_sum": "Validates position offsets against buffer boundaries and triggers sub_FFFFFFFF81641390 to process a segment when movement crosses specific size or alignment thresholds.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates position offsets against buffer boundaries and triggers sub_FFFFFFFF81641390 to process a segment when movement crosses specific size or alignment thresholds.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs bounds checks and conditional partial processing on data segments, invoking sub_FFFFFFFF81641390 to handle fixed-size chunk operations within range constraints.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and adjusts a data range against buffer boundaries, calling a processing routine on the aligned subset and returning success or error status.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
    "filter2_prorec_aug_sum": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
    "filter2_prorec_aug2_sum": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
    "source_code": "static int o_save_ptr_helper(o_string *o, int n)\n{\n\tchar **list = (char**)o->data;\n\tint string_start;\n\tint string_len;\n\n\tif (!o->has_empty_slot) {\n\t\tstring_start = ((n + 0xf) & ~0xf) * sizeof(list[0]);\n\t\tstring_len = o->length - string_start;\n\t\tif (!(n & 0xf)) { /* 0, 0x10, 0x20...? */\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (growing)\\n\", n, string_len, string_start);\n\t\t\t/* list[n] points to string_start, make space for 16 more pointers */\n\t\t\to->maxlen += 0x10 * sizeof(list[0]);\n\t\t\to->data = xrealloc(o->data, o->maxlen + 1);\n\t\t\tlist = (char**)o->data;\n\t\t\tmemmove(list + n + 0x10, list + n, string_len);\n\t\t\to->length += 0x10 * sizeof(list[0]);\n\t\t} else {\n\t\t\tdebug_printf_list(\"list[%d]=%d string_start=%d\\n\",\n\t\t\t\t\tn, string_len, string_start);\n\t\t}\n\t} else {\n\t\t/* We have empty slot at list[n], reuse without growth */\n\t\tstring_start = ((n+1 + 0xf) & ~0xf) * sizeof(list[0]); /* NB: n+1! */\n\t\tstring_len = o->length - string_start;\n\t\tdebug_printf_list(\"list[%d]=%d string_start=%d (empty slot)\\n\",\n\t\t\t\tn, string_len, string_start);\n\t\to->has_empty_slot = 0;\n\t}\n\to->has_quoted_part = 0;\n\tlist[n] = (char*)(uintptr_t)string_len;\n\treturn n + 1;\n}",
    "decom_sum": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates or updates an entry in a data structure, initializes it via sub_4004F0, and stores a size-adjusted offset before returning the next index.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Frees all dynamically allocated memory associated with an operation parser, including internal arrays, related structures, and global state, then releases the parser itself.",
    "filter2_prorec_aug_sum": "Frees all dynamically allocated memory associated with an operation parser, including internal arrays, related structures, and global state, then releases the parser itself.",
    "filter2_prorec_aug2_sum": "Frees all dynamically allocated memory within a complex structure, including nested pointers and global resources, then frees the structure itself.",
    "source_code": "\nvoid\ndatamash_ops_free ( struct datamash_ops* p )\n{\n  assert (p != NULL);                            /* LCOV_EXCL_LINE */\n  for (size_t i=0; i<p->num_grps; ++i)\n    free (p->grps[i].name);\n  free (p->grps);\n  p->grps = NULL;\n\n  #ifndef _STANDALONE_\n  for (size_t i=0; i<p->num_ops; ++i)\n    field_op_free (&p->ops[i]);\n  #endif\n\n  free (p->ops);\n  p->ops = NULL;\n\n  for  (size_t i=0; i<_fields_used; ++i) {\n    free (_fields[i].name);\n  }\n  free (_fields);\n  _fields = NULL;\n  _fields_alloc = 0;\n  _fields_used = 0;\n\n  free (_params);\n  _params_alloc = 0;\n  _params_used = 0;\n\n  free (p);\n}",
    "decom_sum": "Frees all dynamically allocated memory associated with an operation parser, including internal arrays, related structures, and global state, then releases the parser itself.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Frees all dynamically allocated memory associated with an operation parser, including internal arrays, related structures, and global state, then releases the parser itself.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Frees all dynamically allocated memory associated with an operation parser, including internal arrays, related structures, and global state, then releases the parser itself.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Frees all dynamically allocated memory within a complex structure, including nested pointers and global resources, then frees the structure itself.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and processes exception handling frame data from the __GNU_EH_FRAME_HDR section, updating related data structures and flags accordingly.",
    "filter2_prorec_aug_sum": "Updates exception handling frame headers for the binary, conditionally manages GNU EH frame data, and marks related flags in the object's metadata.",
    "filter2_prorec_aug2_sum": "Processes EH_FRAME_HDR for exception handling, updating flags and invoking callbacks based on object state and specific flags at offsets within related structures.",
    "source_code": "\nbfd_boolean\n_bfd_elf_maybe_strip_eh_frame_hdr (struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *htab;\n  struct eh_frame_hdr_info *hdr_info;\n  struct bfd_link_hash_entry *bh = NULL;\n  struct elf_link_hash_entry *h;\n\n  htab = elf_hash_table (info);\n  hdr_info = &htab->eh_info;\n  if (hdr_info->hdr_sec == NULL)\n    return TRUE;\n\n  if (bfd_is_abs_section (hdr_info->hdr_sec->output_section)\n      || info->eh_frame_hdr_type == 0\n      || (info->eh_frame_hdr_type == DWARF2_EH_HDR\n\t  && !_bfd_elf_eh_frame_present (info))\n      || (info->eh_frame_hdr_type == COMPACT_EH_HDR\n\t  && !_bfd_elf_eh_frame_entry_present (info)))\n    {\n      hdr_info->hdr_sec->flags |= SEC_EXCLUDE;\n      hdr_info->hdr_sec = NULL;\n      return TRUE;\n    }\n\n  /* Add a hidden symbol so that systems without access to PHDRs can\n     find the table.  */\n  if (! (_bfd_generic_link_add_one_symbol\n\t (info, info->output_bfd, \"__GNU_EH_FRAME_HDR\", BSF_LOCAL,\n\t  hdr_info->hdr_sec, 0, NULL, FALSE, FALSE, &bh)))\n    return FALSE;\n\n  h = (struct elf_link_hash_entry *) bh;\n  h->def_regular = 1;\n  h->other = STV_HIDDEN;\n  get_elf_backend_data\n    (info->output_bfd)->elf_backend_hide_symbol (info, h, TRUE);\n\n  if (!hdr_info->frame_hdr_is_compact)\n    hdr_info->u.dwarf.table = TRUE;\n  return TRUE;\n}",
    "decom_sum": "Processes and validates a target\u2019s exception handling frame data, updating related structures and flags, or marks the frame as invalid and clears its reference.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and processes exception handling frame data from the __GNU_EH_FRAME_HDR section, updating related data structures and flags accordingly.",
            "flag": false,
            "score": [
                0.7,
                0.5,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates exception handling frame headers for the binary, conditionally manages GNU EH frame data, and marks related flags in the object's metadata.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes EH_FRAME_HDR for exception handling, updating flags and invoking callbacks based on object state and specific flags at offsets within related structures.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs a strong Lucas probable prime test on the input number to deterministically check its primality.",
    "filter2_prorec_aug_sum": "Performs a strong Lucas primality test on the given big integer using mini-GMP routines and returns a result indicating composite, prime, or inconclusive.",
    "filter2_prorec_aug2_sum": "Performs a strong Lucas probable prime test on a number and returns 1 if prime, 0 if composite, or 2 if inconclusive.",
    "source_code": "static int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D; /* The absolute value is stored. */\n  long Q;\n  mp_limb_t tl;\n\n  /* Test on the absolute value. */\n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n  /* assert (mpz_gcd_ui (NULL, n, 6) == 1); */\n  if (mpz_root (Qk, n, 2))\n    return 0; /* A square is composite. */\n\n  /* Check Ds up to square root (in case, n is prime)\n     or avoid overflows */\n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n  /* Search a D such that (D/n) = -1 in the sequence 5,-7,9,-11,.. */\n  /* For those Ds we have (D/n) = (n/|D|) */\n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX); /* (1 + ! ~ D) */\n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n  /* n-(D/n) = n+1 = d*2^{b0}, with d = (n>>b0) | 1 */\n  b0 = mpz_scan0 (n, 0);\n\n  /* D= P^2 - 4Q; P = 1; Q = (1-D)/4 */\n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t/* If Ud != 0 */\n    while (V->_mp_size != 0 && --b0 != 0)\t/* while Vk != 0 */\n      /* V <- V ^ 2 - 2Q^k */\n      /* Q^{2k} = (Q^k)^2 */\n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}",
    "decom_sum": "Performs a strong Lucas primality test on the given big integer using mini-GMP routines and returns a result indicating composite, prime, or inconclusive.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs a strong Lucas probable prime test on the input number to deterministically check its primality.",
            "flag": false,
            "score": [
                0.4,
                0.6,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs a strong Lucas primality test on the given big integer using mini-GMP routines and returns a result indicating composite, prime, or inconclusive.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs a strong Lucas probable prime test on a number and returns 1 if prime, 0 if composite, or 2 if inconclusive.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Copies elliptic curve parameters p, a, b from the group structure into provided BIGNUMs, optionally using BN_CTX and custom field methods for efficient handling.",
    "filter2_prorec_aug_sum": "Copies the elliptic curve's field prime, curve coefficients, and optionally initializes a BN_CTX to retrieve curve parameters via the group's method.",
    "filter2_prorec_aug2_sum": "Retrieves an EC group\u2019s prime-field curve parameters a, b using BN_copy or field-specific method, allocating a BN_CTX if needed.",
    "source_code": "\n\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret = 0;\n\tBN_CTX *new_ctx = NULL;\n\t\n\tif (p != NULL)\n\t\t{\n\t\tif (!BN_copy(p, &group->field)) return 0;\n\t\t}\n\n\tif (a != NULL || b != NULL)\n\t\t{\n\t\tif (group->meth->field_decode)\n\t\t\t{\n\t\t\tif (ctx == NULL)\n\t\t\t\t{\n\t\t\t\tctx = new_ctx = BN_CTX_new();\n\t\t\t\tif (ctx == NULL)\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (a != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(a, &group->a)) goto err;\n\t\t\t\t}\n\t\t\tif (b != NULL)\n\t\t\t\t{\n\t\t\t\tif (!BN_copy(b, &group->b)) goto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tret = 1;\n\t\n err:\n\tif (new_ctx)\n\t\tBN_CTX_free(new_ctx);\n\treturn ret;\n\t}",
    "decom_sum": "Retrieves an EC group\u2019s prime-field curve parameters a, b using BN_copy or field-specific method, allocating a BN_CTX if needed.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Copies elliptic curve parameters p, a, b from the group structure into provided BIGNUMs, optionally using BN_CTX and custom field methods for efficient handling.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Copies the elliptic curve's field prime, curve coefficients, and optionally initializes a BN_CTX to retrieve curve parameters via the group's method.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Retrieves an EC group\u2019s prime-field curve parameters a, b using BN_copy or field-specific method, allocating a BN_CTX if needed.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
    "filter2_prorec_aug_sum": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
    "filter2_prorec_aug2_sum": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
    "source_code": "\nvoid FAST_FUNC bb_perror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\t/* Guard against \"<error message>: Success\" */\n\tbb_verror_msg(s, p, errno ? strerror(errno) : NULL);\n\tva_end(p);\n}",
    "decom_sum": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Computes a transformation from eight double-precision vectors and invokes sub_5176F5 with configuration data for further processing.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes two data structures using geometric parameters, invoking two subroutines if initial collision or intersection tests succeed, and returns the resulting status code.",
    "filter2_prorec_aug_sum": "Processes two data structures using geometric parameters, invoking two subroutines if initial collision or intersection tests succeed, and returns the resulting status code.",
    "filter2_prorec_aug2_sum": "Validates and updates measurement structures by invoking two specialized subroutines and refreshing related data if either indicates changes.",
    "source_code": "int mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t &context->range.level[0].cat);\n\tif (rc != 0)\n\t\tgoto import_netlbl_cat_failure;\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\tebitmap_destroy(&context->range.level[1].cat);\n\treturn rc;\n}",
    "decom_sum": "Processes two data structures using geometric parameters, invoking two subroutines if initial collision or intersection tests succeed, and returns the resulting status code.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes two data structures using geometric parameters, invoking two subroutines if initial collision or intersection tests succeed, and returns the resulting status code.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes two data structures using geometric parameters, invoking two subroutines if initial collision or intersection tests succeed, and returns the resulting status code.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and updates measurement structures by invoking two specialized subroutines and refreshing related data if either indicates changes.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Verifies GPU display pipe state against expected status and logs an assertion failure if the current enablement does not match the expected state.",
    "filter2_prorec_aug_sum": "Checks and asserts the enablement state of a display pipe against hardware status, reporting assertion failure with pipe and expected/current state if mismatched.",
    "filter2_prorec_aug2_sum": "Validates GPU pipe state against hardware status and triggers an assertion failure with detailed pipe status messages on mismatch.",
    "source_code": "\nvoid assert_pipe(struct drm_i915_private *dev_priv,\n\t\t enum pipe pipe, bool state)\n{\n\tint reg;\n\tu32 val;\n\tbool cur_state;\n\tenum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,\n\t\t\t\t\t\t\t\t      pipe);\n\n\t/* if we need the pipe A quirk it must be always on */\n\tif (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)\n\t\tstate = true;\n\n\tif (!intel_using_power_well(dev_priv->dev) &&\n\t    cpu_transcoder != TRANSCODER_EDP) {\n\t\tcur_state = false;\n\t} else {\n\t\treg = PIPECONF(cpu_transcoder);\n\t\tval = I915_READ(reg);\n\t\tcur_state = !!(val & PIPECONF_ENABLE);\n\t}\n\n\tWARN(cur_state != state,\n\t     \"pipe %c assertion failure (expected %s, current %s)\\n\",\n\t     pipe_name(pipe), state_string(state), state_string(cur_state));\n}",
    "decom_sum": "Checks an Intel GPU display pipe\u2019s expected on/off state against hardware status and logs an assertion failure if they differ.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Verifies GPU display pipe state against expected status and logs an assertion failure if the current enablement does not match the expected state.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks and asserts the enablement state of a display pipe against hardware status, reporting assertion failure with pipe and expected/current state if mismatched.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates GPU pipe state against hardware status and triggers an assertion failure with detailed pipe status messages on mismatch.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
    "filter2_prorec_aug_sum": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
    "filter2_prorec_aug2_sum": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
    "source_code": "\n\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\n{\n\tcistpl_longlink_mfc_t mfc;\n\tunsigned int no_funcs, i, no_chains;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!(s->resource_setup_done)) {\n\t\tdev_dbg(&s->dev,\n\t\t\t   \"no resources available, delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\n\tif (pcmcia_validate_mem(s)) {\n\t\tdev_dbg(&s->dev, \"validating mem resources failed, \"\n\t\t       \"delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN; /* try again, but later... */\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\tret = pccard_validate_cis(s, &no_chains);\n\tif (ret || !no_chains) {\n\t\tdev_dbg(&s->dev, \"invalid CIS or invalid resources\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\n\t\tno_funcs = mfc.nfn;\n\telse\n\t\tno_funcs = 1;\n\ts->functions = no_funcs;\n\n\tfor (i = 0; i < no_funcs; i++)\n\t\tpcmcia_device_add(s, i);\n\n\treturn ret;\n}",
    "decom_sum": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates device state and configuration, retrieves a byte sequence, and invokes a processing routine for each entry if initialization succeeds.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Finalizes CMS SignedData by iterating signer infos to compute or add cryptographic signatures and associated authenticated attributes, returning success or error status.",
    "filter2_prorec_aug_sum": "Finalizes CMS SignedData by generating digests or signatures for each signer, adds required attributes, and updates signature fields.",
    "filter2_prorec_aug2_sum": "Finalizes CMS SignedData by computing and embedding signatures or authenticated attributes for all SignerInfos, returning success or failure status.",
    "source_code": "\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n\t{\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tCMS_SignerInfo *si;\n\tint i;\n\tsinfos = CMS_get0_SignerInfos(cms);\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tif (!cms_SignerInfo_content_sign(cms, si, chain))\n\t\t\treturn 0;\n\t\t}\n\tcms->d.signedData->encapContentInfo->partial = 0;\n\treturn 1;\n\t}",
    "decom_sum": "Finalizes CMS SignedData by generating digests or signatures for each signer, adds required attributes, and updates signature fields.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Finalizes CMS SignedData by iterating signer infos to compute or add cryptographic signatures and associated authenticated attributes, returning success or error status.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Finalizes CMS SignedData by generating digests or signatures for each signer, adds required attributes, and updates signature fields.",
            "flag": true,
            "score": [
                0.3,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Finalizes CMS SignedData by computing and embedding signatures or authenticated attributes for all SignerInfos, returning success or failure status.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Adjusts and updates TCP skb header fields based on packet size, flags, and sequence offsets during IPv4 TCP output processing.",
    "filter2_prorec_aug_sum": "Calculates and sets TCP timestamp option lengths and values within the packet header based on segment size, socket state, and TCP flags.",
    "filter2_prorec_aug2_sum": "Calculates and updates TCP segment scaling values in the TCP header based on segment size and connection flags.",
    "source_code": "static void tcp_set_skb_tso_segs(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t unsigned int mss_now)\n{\n\tif (skb->len <= mss_now || !sk_can_gso(sk) ||\n\t    skb->ip_summed == CHECKSUM_NONE) {\n\t\t/* Avoid the costly divide in the normal\n\t\t * non-TSO case.\n\t\t */\n\t\tskb_shinfo(skb)->gso_segs = 1;\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tskb_shinfo(skb)->gso_type = 0;\n\t} else {\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss_now);\n\t\tskb_shinfo(skb)->gso_size = mss_now;\n\t\tskb_shinfo(skb)->gso_type = sk->sk_gso_type;\n\t}\n}",
    "decom_sum": "Configures TCP output segment header fields based on connection state and packet size, enforcing constraints and logging unexpected header conditions once.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Adjusts and updates TCP skb header fields based on packet size, flags, and sequence offsets during IPv4 TCP output processing.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates and sets TCP timestamp option lengths and values within the packet header based on segment size, socket state, and TCP flags.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates and updates TCP segment scaling values in the TCP header based on segment size and connection flags.",
            "flag": false,
            "score": [
                0.4,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates a single-character input, translates it, attempts to load the corresponding shared object, and errors if loading fails.",
    "filter2_prorec_aug_sum": "Validates a single string argument then loads and verifies the specified shared object for R dynamic loading, else raises an error.",
    "filter2_prorec_aug2_sum": "Validates a single-string argument, translates it, attempts to load the corresponding shared object, and throws an error if loading fails.",
    "source_code": "\nSEXP attribute_hidden do_dynunload(SEXP call, SEXP op, SEXP args, SEXP env)\n{\n    char buf[2 * PATH_MAX];\n\n    checkArity(op,args);\n    if (!isString(CAR(args)) || LENGTH(CAR(args)) != 1)\n\terror(_(\"character argument expected\"));\n    GetFullDLLPath(call, buf, translateChar(STRING_ELT(CAR(args), 0)));\n    if(!DeleteDLL(buf))\n\terror(_(\"shared object '%s\\' was not loaded\"), buf);\n    return R_NilValue;\n}",
    "decom_sum": "Loads a named shared object in R, validating the argument as a single character string and raising an error if loading fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates a single-character input, translates it, attempts to load the corresponding shared object, and errors if loading fails.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates a single string argument then loads and verifies the specified shared object for R dynamic loading, else raises an error.",
            "flag": false,
            "score": [
                0.6,
                0.4,
                0.5
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates a single-string argument, translates it, attempts to load the corresponding shared object, and throws an error if loading fails.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
    "filter2_prorec_aug_sum": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
    "filter2_prorec_aug2_sum": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
    "source_code": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED)\n\t\treturn 0;\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "decom_sum": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
            "flag": true,
            "score": [
                0.5,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
            "flag": true,
            "score": [
                0.5,
                0.5,
                0.5
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes an audit record for the given context, linking matched entry data and setting status flags, or reports memory allocation failure.",
            "flag": true,
            "score": [
                0.5,
                0.5,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Adds a matching file name to the results array, updates counters and memory alignment, and logs warnings or fatal errors if limits are exceeded.",
    "filter2_prorec_aug_sum": "Manages a list of matched filenames by adding new entries, validating count limits, updating counters, and adjusting a6 pointer for buffer size alignment.",
    "filter2_prorec_aug2_sum": "Adds a matching file name to the results array, updates counters and memory alignment, and logs warnings or fatal errors if limits are exceeded.",
    "source_code": "int Xorriso_register_matched_adr(struct XorrisO *xorriso,\n                                char *adr, int count_limit,\n                                int *filec, char **filev, off_t *mem, int flag)\n{\n int l;\n\n if(flag&1) {\n   (*filec)++;\n   l= strlen(adr)+1;\n   (*mem)+= sizeof(char *)+l;\n   if(l % sizeof(char *))\n     (*mem)+= sizeof(char *)-(l % sizeof(char *));\n } else {\n   if(*filec >= count_limit) {\n     sprintf(xorriso->info_text,\n         \"Number of matching files changed unexpectedly (> %d)\",\n         count_limit);\n     Xorriso_msgs_submit(xorriso, 0, xorriso->info_text, 0,\n                         (flag&2 ? \"FATAL\" : \"WARNING\"), 0);\n     return(flag&2 ? -1 : 0);\n   }\n   filev[*filec]= strdup(adr);\n   if(filev[*filec]==NULL) {\n     Xorriso_no_pattern_memory(xorriso, (off_t) (strlen(adr)+1), 0);\n     return(-1);\n   }\n   (*filec)++;\n }\n return(1);\n}",
    "decom_sum": "Adds a matching file name to the results array, updates counters and memory alignment, and logs warnings or fatal errors if limits are exceeded.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Adds a matching file name to the results array, updates counters and memory alignment, and logs warnings or fatal errors if limits are exceeded.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Manages a list of matched filenames by adding new entries, validating count limits, updating counters, and adjusting a6 pointer for buffer size alignment.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Adds a matching file name to the results array, updates counters and memory alignment, and logs warnings or fatal errors if limits are exceeded.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes chunks of a given buffer by invoking encryption and validation routines, updating data with encoded values until all input bytes are handled.",
    "filter2_prorec_aug_sum": "Processes and encodes input data in fixed-size chunks by invoking hardware-specific functions and updates the data buffer with encoded output bytes.",
    "filter2_prorec_aug2_sum": "Processes chunks of a UTF-16 string, applies transformations via sub_FFFFFFFF8138EC40, updates bytes with sub_FFFFFFFF8138E6A0, and verifies with sub_FFFFFFFF813DB590.",
    "source_code": "\nstatic int\ngmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,\n\t\tu32 gmbus1_index)\n{\n\tint reg_offset = dev_priv->gpio_mmio_base;\n\tu16 len = msg->len;\n\tu8 *buf = msg->buf;\n\n\tI915_WRITE(GMBUS1 + reg_offset,\n\t\t   gmbus1_index |\n\t\t   GMBUS_CYCLE_WAIT |\n\t\t   (len << GMBUS_BYTE_COUNT_SHIFT) |\n\t\t   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |\n\t\t   GMBUS_SLAVE_READ | GMBUS_SW_RDY);\n\twhile (len) {\n\t\tint ret;\n\t\tu32 val, loop = 0;\n\n\t\tret = gmbus_wait_hw_status(dev_priv, GMBUS_HW_RDY,\n\t\t\t\t\t   GMBUS_HW_RDY_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = I915_READ(GMBUS3 + reg_offset);\n\t\tdo {\n\t\t\t*buf++ = val & 0xff;\n\t\t\tval >>= 8;\n\t\t} while (--len && ++loop < 4);\n\t}\n\n\treturn 0;\n}",
    "decom_sum": "Transfers data from a buffer to hardware registers in 256-byte chunks, issuing commands and reading responses until all bytes are written.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes chunks of a given buffer by invoking encryption and validation routines, updating data with encoded values until all input bytes are handled.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes and encodes input data in fixed-size chunks by invoking hardware-specific functions and updates the data buffer with encoded output bytes.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes chunks of a UTF-16 string, applies transformations via sub_FFFFFFFF8138EC40, updates bytes with sub_FFFFFFFF8138E6A0, and verifies with sub_FFFFFFFF813DB590.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Traverses two linked lists of object structures, processes specific entries via helper routines, sums their counters, and stores the total at offset 4032.",
    "filter2_prorec_aug_sum": "Iterates and processes two linked lists of structures, updating counters and invoking a processing function for each valid element, then stores the total count at a1+4032.",
    "filter2_prorec_aug2_sum": "Traverses two linked lists of object structures, processes specific entries via helper routines, sums their counters, and stores the total at offset 4032.",
    "source_code": "static void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}",
    "decom_sum": "Traverses two linked lists of object structures, processes specific entries via helper routines, sums their counters, and stores the total at offset 4032.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Traverses two linked lists of object structures, processes specific entries via helper routines, sums their counters, and stores the total at offset 4032.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates and processes two linked lists of structures, updating counters and invoking a processing function for each valid element, then stores the total count at a1+4032.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Traverses two linked lists of object structures, processes specific entries via helper routines, sums their counters, and stores the total at offset 4032.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a buffer based on device parameters, calls a setup function, and returns success or error status accordingly.",
    "filter2_prorec_aug_sum": "Allocates and initializes a structured buffer with provided doubles, processes it with a1/a2 parameters, handles errors, and dispatches the result for further handling.",
    "filter2_prorec_aug2_sum": "Allocates memory for a struct based on input parameters, initializes it via sub_FFFFFFFF8166FA00, and returns a device-specific handle or error code.",
    "source_code": "\nstatic void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,\n\t\t\t\t int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mroute_msgsize(mfc->mfc_parent >= MAXVIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = ipmr_fill_mroute(mrt, skb, 0, 0, mfc, cmd);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE, err);\n}",
    "decom_sum": "Allocates and initializes a structured buffer with provided doubles, processes it with a1/a2 parameters, handles errors, and dispatches the result for further handling.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a buffer based on device parameters, calls a setup function, and returns success or error status accordingly.",
            "flag": false,
            "score": [
                0.6,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a structured buffer with provided doubles, processes it with a1/a2 parameters, handles errors, and dispatches the result for further handling.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates memory for a struct based on input parameters, initializes it via sub_FFFFFFFF8166FA00, and returns a device-specific handle or error code.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iteratively clears bits in a status flag by repeatedly validating and processing corresponding tasks until all are handled or a synchronization condition is cleared.",
    "filter2_prorec_aug_sum": "Processes up to eight flagged channels, invoking computation and I/O handlers until each channel is cleared, with synchronization via a GS-based status flag.",
    "filter2_prorec_aug2_sum": "Processes up to eight flagged channels, invoking computation and I/O handlers until each channel is cleared, with synchronization via a GS-based status flag.",
    "source_code": "\nvoid inet_twdr_twkill_work(struct work_struct *work)\n{\n\tstruct inet_timewait_death_row *twdr =\n\t\tcontainer_of(work, struct inet_timewait_death_row, twkill_work);\n\tint i;\n\n\tBUILD_BUG_ON((INET_TWDR_TWKILL_SLOTS - 1) >\n\t\t\t(sizeof(twdr->thread_slots) * 8));\n\n\twhile (twdr->thread_slots) {\n\t\tspin_lock_bh(&twdr->death_lock);\n\t\tfor (i = 0; i < INET_TWDR_TWKILL_SLOTS; i++) {\n\t\t\tif (!(twdr->thread_slots & (1 << i)))\n\t\t\t\tcontinue;\n\n\t\t\twhile (inet_twdr_do_twkill_work(twdr, i) != 0) {\n\t\t\t\tif (need_resched()) {\n\t\t\t\t\tspin_unlock_bh(&twdr->death_lock);\n\t\t\t\t\tschedule();\n\t\t\t\t\tspin_lock_bh(&twdr->death_lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttwdr->thread_slots &= ~(1 << i);\n\t\t}\n\t\tspin_unlock_bh(&twdr->death_lock);\n\t}\n}",
    "decom_sum": "Processes up to eight flagged channels, invoking computation and I/O handlers until each channel is cleared, with synchronization via a GS-based status flag.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iteratively clears bits in a status flag by repeatedly validating and processing corresponding tasks until all are handled or a synchronization condition is cleared.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes up to eight flagged channels, invoking computation and I/O handlers until each channel is cleared, with synchronization via a GS-based status flag.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes up to eight flagged channels, invoking computation and I/O handlers until each channel is cleared, with synchronization via a GS-based status flag.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Manages buffer reference counting and retrieves or initializes packet data before updating usage counters and conditionally processing the buffer with given parameters.",
    "filter2_prorec_aug_sum": "Initializes or retrieves an object, copies associated data into the destination buffer, and manages reference counting with conditional cleanup.",
    "filter2_prorec_aug2_sum": "Manages reference counting for a resource, retrieves associated data to initialize output, and triggers cleanup or further processing after use.",
    "source_code": "\n\nstatic int unix_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u;\n\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, uaddr);\n\tint err = 0;\n\n\tif (peer) {\n\t\tsk = unix_peer_get(sk);\n\n\t\terr = -ENOTCONN;\n\t\tif (!sk)\n\t\t\tgoto out;\n\t\terr = 0;\n\t} else {\n\t\tsock_hold(sk);\n\t}\n\n\tu = unix_sk(sk);\n\tunix_state_lock(sk);\n\tif (!u->addr) {\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tsunaddr->sun_path[0] = 0;\n\t\t*uaddr_len = sizeof(short);\n\t} else {\n\t\tstruct unix_address *addr = u->addr;\n\n\t\t*uaddr_len = addr->len;\n\t\tmemcpy(sunaddr, addr->name, *uaddr_len);\n\t}\n\tunix_state_unlock(sk);\n\tsock_put(sk);\nout:\n\treturn err;\n}",
    "decom_sum": "Initializes or retrieves an object, copies associated data into the destination buffer, and manages reference counting with conditional cleanup.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Manages buffer reference counting and retrieves or initializes packet data before updating usage counters and conditionally processing the buffer with given parameters.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes or retrieves an object, copies associated data into the destination buffer, and manages reference counting with conditional cleanup.",
            "flag": true,
            "score": [
                0.6,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Manages reference counting for a resource, retrieves associated data to initialize output, and triggers cleanup or further processing after use.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Replaces a column's default value with a constant expression if valid, otherwise logs an error, then frees the original default value resource.",
    "filter2_prorec_aug_sum": "Initializes or replaces a table column's value with a constant expression, validating its constancy and updating associated storage references.",
    "filter2_prorec_aug2_sum": "Checks if a column's default value is constant and updates or replaces the stored expression accordingly, logging an error if not constant.",
    "source_code": "void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory. The 'span' of the expression\n      ** is required by pragma table_info.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                    (int)(pSpan->zEnd - pSpan->zStart));\n      x.pLeft = pSpan->pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  sqlite3ExprDelete(db, pSpan->pExpr);\n}",
    "decom_sum": "Initializes or replaces a table column's value with a constant expression, validating its constancy and updating associated storage references.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Replaces a column's default value with a constant expression if valid, otherwise logs an error, then frees the original default value resource.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes or replaces a table column's value with a constant expression, validating its constancy and updating associated storage references.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks if a column's default value is constant and updates or replaces the stored expression accordingly, logging an error if not constant.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and updates device state flags, performs device-specific validation and triggers reinitialization or state update based on device status and timing conditions.",
    "filter2_prorec_aug_sum": "Initializes an object\u2019s state and triggers specific update or reset routines based on validation checks, status flags, and time-related conditions.",
    "filter2_prorec_aug2_sum": "Initializes and conditionally updates device state flags, triggers device movement handling or watchdog routines based on device status and timing checks.",
    "source_code": "\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}",
    "decom_sum": "Initializes an object\u2019s state and triggers specific update or reset routines based on validation checks, status flags, and time-related conditions.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and updates device state flags, performs device-specific validation and triggers reinitialization or state update based on device status and timing conditions.",
            "flag": false,
            "score": [
                0.4,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes an object\u2019s state and triggers specific update or reset routines based on validation checks, status flags, and time-related conditions.",
            "flag": true,
            "score": [
                0.3,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and conditionally updates device state flags, triggers device movement handling or watchdog routines based on device status and timing checks.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Cleans up and unlinks nodes from a linked structure referenced by a2, invokes a cleanup method on each, updates counters, and returns a scaled value based on a global counter.",
    "filter2_prorec_aug_sum": "Iterates through and forcefully unlinks kernel list entries, invokes their cleanup callbacks, updates global counters, then returns a scaled resource usage value.",
    "filter2_prorec_aug2_sum": "Clears and resets a linked list of objects from a global array, updates related pointers and counters, then returns a scaled performance metric value.",
    "source_code": "static int shrink_dqcache_memory(struct shrinker *shrink,\n\t\t\t\t struct shrink_control *sc)\n{\n\tint nr = sc->nr_to_scan;\n\n\tif (nr) {\n\t\tspin_lock(&dq_list_lock);\n\t\tprune_dqcache(nr);\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\treturn ((unsigned)\n\t\tpercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS])\n\t\t/100) * sysctl_vfs_cache_pressure;\n}",
    "decom_sum": "Iterates through and forcefully unlinks kernel list entries, invokes their cleanup callbacks, updates global counters, then returns a scaled resource usage value.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Cleans up and unlinks nodes from a linked structure referenced by a2, invokes a cleanup method on each, updates counters, and returns a scaled value based on a global counter.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates through and forcefully unlinks kernel list entries, invokes their cleanup callbacks, updates global counters, then returns a scaled resource usage value.",
            "flag": true,
            "score": [
                0.4,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Clears and resets a linked list of objects from a global array, updates related pointers and counters, then returns a scaled performance metric value.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
    "filter2_prorec_aug_sum": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
    "filter2_prorec_aug2_sum": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
    "source_code": "\nvoid BN_CTX_end(BN_CTX *ctx)\n\t{\n\tCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\n\tif(ctx->err_stack)\n\t\tctx->err_stack--;\n\telse\n\t\t{\n\t\tunsigned int fp = BN_STACK_pop(&ctx->stack);\n\t\t/* Does this stack frame have anything to release? */\n\t\tif(fp < ctx->used)\n\t\t\tBN_POOL_release(&ctx->pool, ctx->used - fp);\n\t\tctx->used = fp;\n\t\t/* Unjam \"too_many\" in case \"get\" had failed */\n\t\tctx->too_many = 0;\n\t\t}\n\tCTXDBG_EXIT(ctx);\n\t}",
    "decom_sum": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Restores the previous BN_CTX state by popping stack frames, adjusting depth counters, and updating internal block and frame pointers.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
    "filter2_prorec_aug_sum": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
    "filter2_prorec_aug2_sum": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
    "source_code": "\nstatic ssize_t\narray_size_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tsector_t sectors;\n\n\tif (strncmp(buf, \"default\", 7) == 0) {\n\t\tif (mddev->pers)\n\t\t\tsectors = mddev->pers->size(mddev, 0, 0);\n\t\telse\n\t\t\tsectors = mddev->array_sectors;\n\n\t\tmddev->external_size = 0;\n\t} else {\n\t\tif (strict_blocks_to_sectors(buf, &sectors) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->pers && mddev->pers->size(mddev, 0, 0) < sectors)\n\t\t\treturn -E2BIG;\n\n\t\tmddev->external_size = 1;\n\t}\n\n\tmddev->array_sectors = sectors;\n\tif (mddev->pers) {\n\t\tset_capacity(mddev->gendisk, mddev->array_sectors);\n\t\trevalidate_disk(mddev->gendisk);\n\t}\n\treturn len;\n}",
    "decom_sum": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Configures a device's active profile by name, validates capacity, updates internal state, and triggers parameter updates with provided double-precision values.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iteratively processes and validates timer nodes from a linked list, removing and cleaning up invalid or expired timers from the system.",
    "filter2_prorec_aug_sum": "Iterates a linked list, validates and processes each node with specific handlers, removing and cleaning up invalid or completed timer-like entries.",
    "filter2_prorec_aug2_sum": "Processes and removes tasks from a linked timer list, invoking their specific handlers or marking them for cleanup if invalid or unprocessable.",
    "source_code": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "decom_sum": "Iterates through POSIX timer entries, validates their handlers, processes active ones, and safely removes and cleans up invalid or expired timer structures.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iteratively processes and validates timer nodes from a linked list, removing and cleaning up invalid or expired timers from the system.",
            "flag": false,
            "score": [
                0.5,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates a linked list, validates and processes each node with specific handlers, removing and cleaning up invalid or completed timer-like entries.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes and removes tasks from a linked timer list, invoking their specific handlers or marking them for cleanup if invalid or unprocessable.",
            "flag": false,
            "score": [
                0.3,
                0.4,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Safely removes and reinitializes a linked list node from a structure, updates counters, and triggers a hardware-related callback with given parameters.",
    "filter2_prorec_aug_sum": "Processes and rearranges linked list nodes within a device context, conditionally triggers a detailed packet processing routine, and updates device synchronization counters before re-enabling interrupts.",
    "filter2_prorec_aug2_sum": "Safely removes and reinitializes a linked list node from a structure, updates counters, and triggers a hardware-related callback with given parameters.",
    "source_code": "\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_substream *s;\n\tint res = 0;\n\n\tdown_write(&snd_pcm_link_rwsem);\n\twrite_lock_irq(&snd_pcm_link_rwlock);\n\tif (!snd_pcm_stream_linked(substream)) {\n\t\tres = -EALREADY;\n\t\tgoto _end;\n\t}\n\tlist_del(&substream->link_list);\n\tsubstream->group->count--;\n\tif (substream->group->count == 1) {\t/* detach the last stream, too */\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\trelink_to_local(s);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(substream->group);\n\t}\n\trelink_to_local(substream);\n       _end:\n\twrite_unlock_irq(&snd_pcm_link_rwlock);\n\tup_write(&snd_pcm_link_rwsem);\n\treturn res;\n}",
    "decom_sum": "Safely removes and reinitializes a linked list node from a structure, updates counters, and triggers a hardware-related callback with given parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Safely removes and reinitializes a linked list node from a structure, updates counters, and triggers a hardware-related callback with given parameters.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes and rearranges linked list nodes within a device context, conditionally triggers a detailed packet processing routine, and updates device synchronization counters before re-enabling interrupts.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Safely removes and reinitializes a linked list node from a structure, updates counters, and triggers a hardware-related callback with given parameters.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks HTTP request conditions, resets chunked encoding state if active, allocates and assigns chunked filter context, and returns a filter invocation result.",
    "filter2_prorec_aug_sum": "Configures HTTP chunked transfer encoding for an Nginx request if specific state, timing, and module conditions are met, otherwise returns early.",
    "filter2_prorec_aug2_sum": "Initializes chunked transfer encoding in an HTTP request based on status code, connection state, and filter module conditions, allocating necessary filter context.",
    "source_code": "\n\nstatic ngx_int_t\nngx_http_chunked_header_filter(ngx_http_request_t *r)\n{\n    ngx_http_core_loc_conf_t       *clcf;\n    ngx_http_chunked_filter_ctx_t  *ctx;\n\n    if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_out.content_length_n == -1\n        || r->expect_trailers)\n    {\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n\n        } else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }\n    }\n\n    return ngx_http_next_header_filter(r);\n}",
    "decom_sum": "Configures HTTP chunked transfer encoding for an Nginx request if specific state, timing, and module conditions are met, otherwise returns early.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks HTTP request conditions, resets chunked encoding state if active, allocates and assigns chunked filter context, and returns a filter invocation result.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Configures HTTP chunked transfer encoding for an Nginx request if specific state, timing, and module conditions are met, otherwise returns early.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes chunked transfer encoding in an HTTP request based on status code, connection state, and filter module conditions, allocating necessary filter context.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Determines file size in 2KB blocks via device-specific or direct stat call, validates type, and stores block count in the output parameter.",
    "filter2_prorec_aug_sum": "Calculates and validates the file size in 2KB units from a path or inode, returning specific error codes or status based on a4 flag and file type checks.",
    "filter2_prorec_aug2_sum": "Determines file size in 2KB blocks via device-specific or direct stat call, validates type, and stores block count in the output parameter.",
    "source_code": "static int compute_partition_size(Ecma119Image *t, char *disk_path,\n                                  uint32_t *size, int flag)\n{\n    int ret, keep;\n    off_t num;\n    struct stat stbuf;\n    struct iso_interval_reader *ivr;\n    off_t byte_count;\n\n    if (flag & 1) {\n        ret = iso_interval_reader_new(t->image, disk_path,\n                                      &ivr, &byte_count, 0);\n        if (ret < 0)\n            return ret;\n        *size = (byte_count + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        keep = iso_interval_reader_keep(t, ivr, 0);\n        iso_interval_reader_destroy(&ivr, 0);\n        if (keep < 0)\n            return keep;\n        return ISO_SUCCESS + (keep > 0);\n    }\n\n    *size = 0;\n    ret = stat(disk_path, &stbuf);\n    if (ret == -1)\n        return ISO_BAD_PARTITION_FILE;\n    if (! S_ISREG(stbuf.st_mode))\n        return ISO_BAD_PARTITION_FILE;\n    num = ((stbuf.st_size + 2047) / 2048);\n    if (num > 0x3fffffff || num == 0)\n        return ISO_BAD_PARTITION_FILE;\n    *size = num;\n    return ISO_SUCCESS;\n}",
    "decom_sum": "Determines file size in 2KB blocks via device-specific or direct stat call, validates type, and stores block count in the output parameter.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Determines file size in 2KB blocks via device-specific or direct stat call, validates type, and stores block count in the output parameter.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates and validates the file size in 2KB units from a path or inode, returning specific error codes or status based on a4 flag and file type checks.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Determines file size in 2KB blocks via device-specific or direct stat call, validates type, and stores block count in the output parameter.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
    "filter2_prorec_aug_sum": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
    "filter2_prorec_aug2_sum": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
    "source_code": "\nstruct timeval* dtls1_get_timeout(SSL *s, struct timeval* timeleft)\n\t{\n\tstruct timeval timenow;\n\n\t/* If no timeout is set, just return NULL */\n\tif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0)\n\t\t{\n\t\treturn NULL;\n\t\t}\n\n\t/* Get current time */\n\tget_current_time(&timenow);\n\n\t/* If timer already expired, set remaining time to 0 */\n\tif (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\n\t\t(s->d1->next_timeout.tv_sec == timenow.tv_sec &&\n\t\t s->d1->next_timeout.tv_usec <= timenow.tv_usec))\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\treturn timeleft;\n\t\t}\n\n\t/* Calculate time left until timer expires */\n\tmemcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n\ttimeleft->tv_sec -= timenow.tv_sec;\n\ttimeleft->tv_usec -= timenow.tv_usec;\n\tif (timeleft->tv_usec < 0)\n\t\t{\n\t\ttimeleft->tv_sec--;\n\t\ttimeleft->tv_usec += 1000000;\n\t\t}\n\n\t/* If remaining time is less than 15 ms, set it to 0\n\t * to prevent issues because of small devergences with\n\t * socket timeouts.\n\t */\n\tif (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000)\n\t\t{\n\t\tmemset(timeleft, 0, sizeof(struct timeval));\n\t\t}\n\t\n\n\treturn timeleft;\n\t}",
    "decom_sum": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates and returns the remaining DTLS handshake timeout in seconds and microseconds, or zero if the deadline has passed or is too short.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes device state structures, invokes a device callback to retrieve data, and conditionally copies a response payload based on flags and length constraints.",
    "filter2_prorec_aug_sum": "Allocates buffers, sends a command via a callback, parses a length-prefixed response, and optionally copies payload data into the provided output buffer.",
    "filter2_prorec_aug2_sum": "Allocates and initializes device structures, calls a device function to retrieve data, updates a3 with data length, and conditionally copies payload to a2 buffer.",
    "source_code": "static int mmc_get_leadin_text_al(struct burn_drive *d,\n                                  unsigned char **text_packs, int *alloc_len,\n                                  int flag)\n{\n\tstruct buffer *buf = NULL;\n\tstruct command *c = NULL;\n\tunsigned char *data;\n\tint ret, data_length;\n\n\t*text_packs = NULL;\n\n\tBURN_ALLOC_MEM(buf, struct buffer, 1);\n\tBURN_ALLOC_MEM(c, struct command, 1);\n\n\tscsi_init_command(c, MMC_GET_LEADTEXT, sizeof(MMC_GET_LEADTEXT));\n\tc->dxfer_len = *alloc_len;\n\tc->opcode[7]= (c->dxfer_len >> 8) & 0xff;\n\tc->opcode[8]= c->dxfer_len & 0xff;\n\tc->retry = 1;\n\tc->page = buf;\n\tc->page->bytes = 0;\n\tc->page->sectors = 0;\n\n\tc->dir = FROM_DRIVE;\n\td->issue_command(d, c);\n\tif (c->error)\n\t\t{ret = 0; goto ex;}\n\n\tdata = c->page->data;\t\n\tdata_length = (data[0] << 8) + data[1];\n\t*alloc_len = data_length + 2;\n\tif (*alloc_len >= 22 && !(flag & 1)) {\n\t\tBURN_ALLOC_MEM(*text_packs, unsigned char, *alloc_len - 4);\n\t\tmemcpy(*text_packs, data + 4, *alloc_len - 4);\n\t}\n\tret = 1;\t\nex:;\n\tBURN_FREE_MEM(c);\n\tBURN_FREE_MEM(buf);\n\treturn ret;\n}",
    "decom_sum": "Allocates buffers, sends a command via a callback, parses a length-prefixed response, and optionally copies payload data into the provided output buffer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes device state structures, invokes a device callback to retrieve data, and conditionally copies a response payload based on flags and length constraints.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates buffers, sends a command via a callback, parses a length-prefixed response, and optionally copies payload data into the provided output buffer.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes device structures, calls a device function to retrieve data, updates a3 with data length, and conditionally copies payload to a2 buffer.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates multiple hardware state conditions, then links and processes a data structure with synchronized updates if the global execution flag equals one.",
    "filter2_prorec_aug_sum": "Validates multiple hardware state conditions, then links and processes a data structure with synchronized updates if the global execution flag equals one.",
    "filter2_prorec_aug2_sum": "Performs permission checks and, if conditions are met and a status flag is set, increments a counter, updates context with a new pointer, and processes a linked data structure.",
    "source_code": "\nstatic int mntns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct fs_struct *fs = current->fs;\n\tstruct mnt_namespace *mnt_ns = ns;\n\tstruct path root;\n\n\tif (!ns_capable(mnt_ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !nsown_capable(CAP_SYS_CHROOT) ||\n\t    !nsown_capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (fs->users != 1)\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\tput_mnt_ns(nsproxy->mnt_ns);\n\tnsproxy->mnt_ns = mnt_ns;\n\n\t/* Find the root */\n\troot.mnt    = &mnt_ns->root->mnt;\n\troot.dentry = mnt_ns->root->mnt.mnt_root;\n\tpath_get(&root);\n\twhile(d_mountpoint(root.dentry) && follow_down_one(&root))\n\t\t;\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, &root);\n\tset_fs_root(fs, &root);\n\n\tpath_put(&root);\n\treturn 0;\n}",
    "decom_sum": "Validates multiple hardware state conditions, then links and processes a data structure with synchronized updates if the global execution flag equals one.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates multiple hardware state conditions, then links and processes a data structure with synchronized updates if the global execution flag equals one.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates multiple hardware state conditions, then links and processes a data structure with synchronized updates if the global execution flag equals one.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs permission checks and, if conditions are met and a status flag is set, increments a counter, updates context with a new pointer, and processes a linked data structure.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Waits for a BSD ring to become ready by polling its status, timing out with an error if unresponsive, while issuing specific command sequences via v11 interface.",
    "filter2_prorec_aug_sum": "Updates BSD ring buffer pointers, waits for ring readiness with timeout handling, then commits new tail index to signal processed commands.",
    "filter2_prorec_aug2_sum": "Waits for the BSD ring buffer to be ready, writes commands to a device ring buffer, and triggers hardware updates with timeout error handling.",
    "source_code": "\n\nstatic void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,\n\t\t\t\t     u32 value)\n{\n\tdrm_i915_private_t *dev_priv = ring->dev->dev_private;\n\n       /* Every tail move must follow the sequence below */\n\n\t/* Disable notification that the ring is IDLE. The GT\n\t * will then assume that it is busy and bring it out of rc6.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n\n\t/* Clear the context id. Here be magic! */\n\tI915_WRITE64(GEN6_BSD_RNCID, 0x0);\n\n\t/* Wait for the ring not to be idle, i.e. for it to wake up. */\n\tif (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &\n\t\t      GEN6_BSD_SLEEP_INDICATOR) == 0,\n\t\t     50))\n\t\tDRM_ERROR(\"timed out waiting for the BSD ring to wake up\\n\");\n\n\t/* Now that the ring is fully powered up, update the tail */\n\tI915_WRITE_TAIL(ring, value);\n\tPOSTING_READ(RING_TAIL(ring->mmio_base));\n\n\t/* Let the ring send IDLE messages to the GT again,\n\t * and so let it sleep to conserve power when idle.\n\t */\n\tI915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,\n\t\t   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));\n}",
    "decom_sum": "Writes commands to the BSD ring buffer, waits for it to wake up with timeout handling, then issues subsequent hardware operations.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Waits for a BSD ring to become ready by polling its status, timing out with an error if unresponsive, while issuing specific command sequences via v11 interface.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates BSD ring buffer pointers, waits for ring readiness with timeout handling, then commits new tail index to signal processed commands.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Waits for the BSD ring buffer to be ready, writes commands to a device ring buffer, and triggers hardware updates with timeout error handling.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and processes a bitmask transition against a stored state, logs illegal transitions, and triggers handlers for each newly set bit in the mask.",
    "filter2_prorec_aug_sum": "Validates and processes bitwise active state transitions by iterating over changed bits, invoking a handler for each valid transition, logging and rejecting illegal transitions.",
    "filter2_prorec_aug2_sum": "Checks and updates active QC state bits in a1, validates transitions against current state, logs errors, and calls a handler for each newly activated bit.",
    "source_code": "int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active)\n{\n\tint nr_done = 0;\n\tu32 done_mask;\n\n\tdone_mask = ap->qc_active ^ qc_active;\n\n\tif (unlikely(done_mask & qc_active)) {\n\t\tata_port_err(ap, \"illegal qc_active transition (%08x->%08x)\\n\",\n\t\t\t     ap->qc_active, qc_active);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (done_mask) {\n\t\tstruct ata_queued_cmd *qc;\n\t\tunsigned int tag = __ffs(done_mask);\n\n\t\tqc = ata_qc_from_tag(ap, tag);\n\t\tif (qc) {\n\t\t\tata_qc_complete(qc);\n\t\t\tnr_done++;\n\t\t}\n\t\tdone_mask &= ~(1 << tag);\n\t}\n\n\treturn nr_done;\n}",
    "decom_sum": "Validates and processes changes in the `qc_active` bitmask, logging illegal transitions and executing per-bit activation routines for newly enabled states.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and processes a bitmask transition against a stored state, logs illegal transitions, and triggers handlers for each newly set bit in the mask.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates and processes bitwise active state transitions by iterating over changed bits, invoking a handler for each valid transition, logging and rejecting illegal transitions.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks and updates active QC state bits in a1, validates transitions against current state, logs errors, and calls a handler for each newly activated bit.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses and processes consecutive newline-delimited data chunks, updating internal state and concatenating results with error handling and resource cleanup.",
    "filter2_prorec_aug_sum": "Processes m128i command type 10 by repeatedly invoking sub_475C40, updating state fields, and combining results into a final aggregated output buffer.",
    "filter2_prorec_aug2_sum": "Processes m128i command type 10 by repeatedly invoking sub_475C40, updating state fields, and combining results into a final aggregated output buffer.",
    "source_code": "\nstatic bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (__glibc_unlikely (*err != REG_NOERROR && branch == NULL))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
    "decom_sum": "Processes m128i command type 10 by repeatedly invoking sub_475C40, updating state fields, and combining results into a final aggregated output buffer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses and processes consecutive newline-delimited data chunks, updating internal state and concatenating results with error handling and resource cleanup.",
            "flag": false,
            "score": [
                0.2,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes m128i command type 10 by repeatedly invoking sub_475C40, updating state fields, and combining results into a final aggregated output buffer.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes m128i command type 10 by repeatedly invoking sub_475C40, updating state fields, and combining results into a final aggregated output buffer.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
    "filter2_prorec_aug_sum": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
    "filter2_prorec_aug2_sum": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
    "source_code": "static int\nefivar_create_sysfs_entry(struct efivar_entry *new_var)\n{\n\tint i, short_name_size;\n\tchar *short_name;\n\tunsigned long variable_name_size;\n\tefi_char16_t *variable_name;\n\n\tvariable_name = new_var->var.VariableName;\n\tvariable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);\n\n\t/*\n\t * Length of the variable bytes in ASCII, plus the '-' separator,\n\t * plus the GUID, plus trailing NUL\n\t */\n\tshort_name_size = variable_name_size / sizeof(efi_char16_t)\n\t\t\t\t+ 1 + EFI_VARIABLE_GUID_LEN + 1;\n\n\tshort_name = kzalloc(short_name_size, GFP_KERNEL);\n\n\tif (!short_name)\n\t\treturn 1;\n\n\t/* Convert Unicode to normal chars (assume top bits are 0),\n\t   ala UTF-8 */\n\tfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\n\t\tshort_name[i] = variable_name[i] & 0xFF;\n\t}\n\t/* This is ugly, but necessary to separate one vendor's\n\t   private variables from another's.         */\n\n\t*(short_name + strlen(short_name)) = '-';\n\tefi_guid_unparse(&new_var->var.VendorGuid,\n\t\t\t short_name + strlen(short_name));\n\n\tnew_var->kobj.kset = efivars_kset;\n\n\ti = kobject_init_and_add(&new_var->kobj, &efivar_ktype,\n\t\t\t\t   NULL, \"%s\", short_name);\n\tkfree(short_name);\n\tif (i)\n\t\treturn 1;\n\n\tkobject_uevent(&new_var->kobj, KOBJ_ADD);\n\tefivar_entry_add(new_var, &efivar_sysfs_list);\n\n\treturn 0;\n}",
    "decom_sum": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a buffer with formatted pointer data, updates device-specific structures, and triggers processing of the data through hardware-linked callbacks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and synchronizes the physical CPU in an SMP system, sets CPU states, enables interrupts, and finalizes CPU startup routines before entering its main execution loop.",
    "filter2_prorec_aug_sum": "Initializes and configures a physical CPU core during SMP startup, setting state flags, synchronizing with other CPUs, and enabling interrupts before entering CPU main execution.",
    "filter2_prorec_aug2_sum": "Initializes and enters the secondary CPU startup routine by synchronizing, registering, setting flags, and enabling interrupts for the specified CPU core.",
    "source_code": "\nvoid __cpuinit start_secondary(void)\n{\n\tunsigned int cpu;\n\tunsigned long thread_ptr;\n\n\t/*  Calculate thread_info pointer from stack pointer  */\n\t__asm__ __volatile__(\n\t\t\"%0 = SP;\\n\"\n\t\t: \"=r\" (thread_ptr)\n\t);\n\n\tthread_ptr = thread_ptr & ~(THREAD_SIZE-1);\n\n\t__asm__ __volatile__(\n\t\tQUOTED_THREADINFO_REG \" = %0;\\n\"\n\t\t:\n\t\t: \"r\" (thread_ptr)\n\t);\n\n\t/*  Set the memory struct  */\n\tatomic_inc(&init_mm.mm_count);\n\tcurrent->active_mm = &init_mm;\n\n\tcpu = smp_processor_id();\n\n\tsetup_irq(BASE_IPI_IRQ + cpu, &ipi_intdesc);\n\n\t/*  Register the clock_event dummy  */\n\tsetup_percpu_clockdev();\n\n\tprintk(KERN_INFO \"%s cpu %d\\n\", __func__, current_thread_info()->cpu);\n\n\tnotify_cpu_starting(cpu);\n\n\tset_cpu_online(cpu, true);\n\n\tlocal_irq_enable();\n\n\tcpu_startup_entry(CPUHP_ONLINE);\n}",
    "decom_sum": "Initializes and synchronizes a physical CPU during SMP startup, performing required setup, memory barriers, and enabling interrupts before entering operational state.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and synchronizes the physical CPU in an SMP system, sets CPU states, enables interrupts, and finalizes CPU startup routines before entering its main execution loop.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and configures a physical CPU core during SMP startup, setting state flags, synchronizing with other CPUs, and enabling interrupts before entering CPU main execution.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and enters the secondary CPU startup routine by synchronizing, registering, setting flags, and enabling interrupts for the specified CPU core.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and processes ACPI operation regions or objects, iterating through named methods and executing associated handlers to generate return status.",
    "filter2_prorec_aug_sum": "Validates and processes ACPI object data by invoking callback and handling multiple ACPI object cases for evaluation with given parameters.",
    "filter2_prorec_aug2_sum": "Iterates through ACPI operation regions and evaluates AML execution contexts, invoking handlers to perform address space-specific operations based on AML opcode results.",
    "source_code": "\nstatic acpi_status acpi_dev_process_resource(struct acpi_resource *ares,\n\t\t\t\t\t     void *context)\n{\n\tstruct res_proc_context *c = context;\n\tstruct resource r;\n\tint i;\n\n\tif (c->preproc) {\n\t\tint ret;\n\n\t\tret = c->preproc(ares, c->preproc_data);\n\t\tif (ret < 0) {\n\t\t\tc->error = ret;\n\t\t\treturn AE_CTRL_TERMINATE;\n\t\t} else if (ret > 0) {\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\tmemset(&r, 0, sizeof(r));\n\n\tif (acpi_dev_resource_memory(ares, &r)\n\t    || acpi_dev_resource_io(ares, &r)\n\t    || acpi_dev_resource_address_space(ares, &r)\n\t    || acpi_dev_resource_ext_address_space(ares, &r))\n\t\treturn acpi_dev_new_resource_entry(&r, c);\n\n\tfor (i = 0; acpi_dev_resource_interrupt(ares, i, &r); i++) {\n\t\tacpi_status status;\n\n\t\tstatus = acpi_dev_new_resource_entry(&r, c);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn status;\n\t}\n\n\treturn AE_OK;\n}",
    "decom_sum": "Processes input data through multiple parsing and validation routines, then calls a computation function to update the target structure with calculated results.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and processes ACPI operation regions or objects, iterating through named methods and executing associated handlers to generate return status.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates and processes ACPI object data by invoking callback and handling multiple ACPI object cases for evaluation with given parameters.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates through ACPI operation regions and evaluates AML execution contexts, invoking handlers to perform address space-specific operations based on AML opcode results.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs CPU feature checks, configures monitor/mwait loop on a memory address, flushes caches, and halts system on failure condition for low-level CPU status monitoring.",
    "filter2_prorec_aug_sum": "Performs a CPU vendor check, flushes and monitors a memory region, and enters a low-power wait loop until a global flag triggers a callback function.",
    "filter2_prorec_aug2_sum": "Performs CPU feature checks, flushes and monitors a memory address while waiting with MWAIT, and triggers system halt on security policy violation.",
    "source_code": "\nvoid native_play_dead(void)\n{\n\tplay_dead_common();\n\ttboot_shutdown(TB_SHUTDOWN_WFS);\n\n\tmwait_play_dead();\t/* Only returns on failure */\n\tif (cpuidle_play_dead())\n\t\thlt_play_dead();\n}",
    "decom_sum": "Monitors a memory address using Intel MONITOR/MWAIT, flushes caches, and halts the CPU when certain system flags and conditions are met.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs CPU feature checks, configures monitor/mwait loop on a memory address, flushes caches, and halts system on failure condition for low-level CPU status monitoring.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs a CPU vendor check, flushes and monitors a memory region, and enters a low-power wait loop until a global flag triggers a callback function.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs CPU feature checks, flushes and monitors a memory address while waiting with MWAIT, and triggers system halt on security policy violation.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
    "filter2_prorec_aug_sum": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
    "filter2_prorec_aug2_sum": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
    "source_code": "static int apply_envelope(struct ml_effect_state *state, int value,\n\t\t\t  struct ff_envelope *envelope)\n{\n\tstruct ff_effect *effect = state->effect;\n\tunsigned long now = jiffies;\n\tint time_from_level;\n\tint time_of_envelope;\n\tint envelope_level;\n\tint difference;\n\n\tif (envelope->attack_length &&\n\t    time_before(now,\n\t\t\tstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\n\t\tpr_debug(\"value = 0x%x, attack_level = 0x%x\\n\",\n\t\t\t value, envelope->attack_level);\n\t\ttime_from_level = jiffies_to_msecs(now - state->play_at);\n\t\ttime_of_envelope = envelope->attack_length;\n\t\tenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\n\n\t} else if (envelope->fade_length && effect->replay.length &&\n\t\t   time_after(now,\n\t\t\t      state->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\n\t\t   time_before(now, state->stop_at)) {\n\t\ttime_from_level = jiffies_to_msecs(state->stop_at - now);\n\t\ttime_of_envelope = envelope->fade_length;\n\t\tenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\n\t} else\n\t\treturn value;\n\n\tdifference = abs(value) - envelope_level;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\tpr_debug(\"time_from_level = 0x%x\\n\", time_from_level);\n\tpr_debug(\"time_of_envelope = 0x%x\\n\", time_of_envelope);\n\n\tdifference = difference * time_from_level / time_of_envelope;\n\n\tpr_debug(\"difference = %d\\n\", difference);\n\n\treturn value < 0 ?\n\t\t-(difference + envelope_level) : (difference + envelope_level);\n}",
    "decom_sum": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Adjusts a signed 32-bit input value proportionally between limits based on buffer capacity and thresholds retrieved from the provided state and parameter array.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
    "filter2_prorec_aug_sum": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
    "filter2_prorec_aug2_sum": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
    "source_code": "\nvoid write_xattr(char *pathname, unsigned int xattr)\n{\n\tunsigned int count;\n\tstruct xattr_list *xattr_list;\n\tint i;\n\tstatic int nonsuper_error = FALSE;\n\tstatic int ignore_xattrs = FALSE;\n\tstatic int nospace_error = 0;\n\n\tif(ignore_xattrs || xattr == SQUASHFS_INVALID_XATTR ||\n\t\t\tsBlk.s.xattr_id_table_start == SQUASHFS_INVALID_BLK)\n\t\treturn;\n\n\txattr_list = get_xattr(xattr, &count, 1);\n\tif(xattr_list == NULL) {\n\t\tERROR(\"Failed to read xattrs for file %s\\n\", pathname);\n\t\treturn;\n\t}\n\n\tfor(i = 0; i < count; i++) {\n\t\tint prefix = xattr_list[i].type & SQUASHFS_XATTR_PREFIX_MASK;\n\n\t\tif(user_xattrs && prefix != SQUASHFS_XATTR_USER)\n\t\t\tcontinue;\n\n\t\tif(root_process || prefix == SQUASHFS_XATTR_USER) {\n\t\t\tint res = lsetxattr(pathname, xattr_list[i].full_name,\n\t\t\t\txattr_list[i].value, xattr_list[i].vsize, 0);\n\n\t\t\tif(res == -1) {\n\t\t\t\tif(errno == ENOTSUP) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the destination filesystem cannot\n\t\t\t\t\t * suppport xattrs, print error, and\n\t\t\t\t\t * disable xattr output as this error is\n\t\t\t\t\t * unlikely to go away, and printing\n\t\t\t\t\t * screenfulls of the same error message\n\t\t\t\t\t * is rather annoying\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"extended attributes are not \"\n\t\t\t\t\t\t\"supported by the destination \"\n\t\t\t\t\t\t\"filesystem\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tERROR(\"Ignoring xattrs in \"\n\t\t\t\t\t\t\t\t\"filesystem\\n\");\n\t\t\t\t\tERROR(\"To avoid this error message, \"\n\t\t\t\t\t\t\"specify -no-xattrs\\n\");\n\t\t\t\t\tignore_xattrs = TRUE;\n\t\t\t\t} else if((errno == ENOSPC || errno == EDQUOT)\n\t\t\t\t\t\t&& nospace_error < NOSPACE_MAX) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Many filesystems like ext2/3/4 have\n\t\t\t\t\t * limits on the amount of xattr\n\t\t\t\t\t * data that can be stored per file\n\t\t\t\t\t * (typically one block or 4K), so\n\t\t\t\t\t * we shouldn't disable xattr ouput,\n\t\t\t\t\t * as the error may be restriced to one\n\t\t\t\t\t * file only.  If we get a lot of these\n\t\t\t\t\t * then suppress the error messsage\n\t\t\t\t\t */\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \" \n\t\t\t\t\t\t\"no extended attribute space \"\n\t\t\t\t\t\t\"remaining (per file or \"\n\t\t\t\t\t\t\"filesystem limit)\\n\",\n\t\t\t\t\t\txattr_list[i].full_name,\n\t\t\t\t\t\tpathname);\n\t\t\t\t\tif(++ nospace_error == NOSPACE_MAX)\n\t\t\t\t\t\tERROR(\"%d of these errors \"\n\t\t\t\t\t\t\t\"printed, further error \"\n\t\t\t\t\t\t\t\"messages of this type \"\n\t\t\t\t\t\t\t\"are suppressed!\\n\",\n\t\t\t\t\t\t\tNOSPACE_MAX);\n\t\t\t\t} else\n\t\t\t\t\tERROR(\"write_xattr: failed to write \"\n\t\t\t\t\t\t\"xattr %s for file %s because \"\n\t\t\t\t\t\t\"%s\\n\", xattr_list[i].full_name,\n\t\t\t\t\t\tpathname, strerror(errno));\n\t\t\t}\n\t\t} else if(nonsuper_error == FALSE) {\n\t\t\t/*\n\t\t\t * if extract user xattrs only then\n\t\t\t * error message is suppressed, if not\n\t\t\t * print error, and then suppress further error\n\t\t\t * messages to avoid possible screenfulls of the\n\t\t\t * same error message!\n\t\t\t */\n\t\t\tERROR(\"write_xattr: could not write xattr %s \"\n\t\t\t\t\t\"for file %s because you're not \"\n\t\t\t\t\t\"superuser!\\n\",\n\t\t\t\t\txattr_list[i].full_name, pathname);\n\t\t\tERROR(\"write_xattr: to avoid this error message, either\"\n\t\t\t\t\" specify -user-xattrs, -no-xattrs, or run as \"\n\t\t\t\t\"superuser!\\n\");\n\t\t\tERROR(\"Further error messages of this type are \"\n\t\t\t\t\"suppressed!\\n\");\n\t\t\tnonsuper_error = TRUE;\n\t\t}\n\t}\n\n\tfree_xattr(xattr_list, count);\n}",
    "decom_sum": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Sets extended file attributes from a retrieved list onto the specified path, handling specific errno conditions and updating related global state flags.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Manages event queue insertion and processing with state flags, enabling interrupts, and conditionally calling event handling and dispatch functions.",
    "filter2_prorec_aug_sum": "Manages and schedules deferred IRQL tasks with synchronization, enabling interrupts, handling linked list queueing, and dispatching work for execution based on device state.",
    "filter2_prorec_aug2_sum": "Manages and schedules transmission of ten double-precision values by updating linked buffers and invoking a keyed signaling and processing routine.",
    "source_code": "static void __synchronize_srcu(struct srcu_struct *sp, int trycount)\n{\n\tstruct rcu_synchronize rcu;\n\tstruct rcu_head *head = &rcu.head;\n\tbool done = false;\n\n\trcu_lockdep_assert(!lock_is_held(&sp->dep_map) &&\n\t\t\t   !lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"Illegal synchronize_srcu() in same-type SRCU (or RCU) read-side critical section\");\n\n\tmight_sleep();\n\tinit_completion(&rcu.completion);\n\n\thead->next = NULL;\n\thead->func = wakeme_after_rcu;\n\tspin_lock_irq(&sp->queue_lock);\n\tif (!sp->running) {\n\t\t/* steal the processing owner */\n\t\tsp->running = true;\n\t\trcu_batch_queue(&sp->batch_check0, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\n\t\tsrcu_advance_batches(sp, trycount);\n\t\tif (!rcu_batch_empty(&sp->batch_done)) {\n\t\t\tBUG_ON(sp->batch_done.head != head);\n\t\t\trcu_batch_dequeue(&sp->batch_done);\n\t\t\tdone = true;\n\t\t}\n\t\t/* give the processing owner to work_struct */\n\t\tsrcu_reschedule(sp);\n\t} else {\n\t\trcu_batch_queue(&sp->batch_queue, head);\n\t\tspin_unlock_irq(&sp->queue_lock);\n\t}\n\n\tif (!done)\n\t\twait_for_completion(&rcu.completion);\n}",
    "decom_sum": "Initializes internal data structures, links callback pointers, enables interrupts, and processes queued entries with floating\u2011point parameters in a hardware control context.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Manages event queue insertion and processing with state flags, enabling interrupts, and conditionally calling event handling and dispatch functions.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Manages and schedules deferred IRQL tasks with synchronization, enabling interrupts, handling linked list queueing, and dispatching work for execution based on device state.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Manages and schedules transmission of ten double-precision values by updating linked buffers and invoking a keyed signaling and processing routine.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes missing top-level page table entries, recursively populating lower levels to map the virtual address range between a3 and a4.",
    "filter2_prorec_aug_sum": "Recursively processes and maps a memory range by traversing and updating a multi-level page table structure based on address translation and allocation.",
    "filter2_prorec_aug2_sum": "Allocates and initializes missing top-level page table entries, recursively populating lower levels to map the virtual address range between a3 and a4.",
    "source_code": "\nint kernel_ident_mapping_init(struct x86_mapping_info *info, pgd_t *pgd_page,\n\t\t\t      unsigned long addr, unsigned long end)\n{\n\tunsigned long next;\n\tint result;\n\tint off = info->kernel_mapping ? pgd_index(__PAGE_OFFSET) : 0;\n\n\tfor (; addr < end; addr = next) {\n\t\tpgd_t *pgd = pgd_page + pgd_index(addr) + off;\n\t\tpud_t *pud;\n\n\t\tnext = (addr & PGDIR_MASK) + PGDIR_SIZE;\n\t\tif (next > end)\n\t\t\tnext = end;\n\n\t\tif (pgd_present(*pgd)) {\n\t\t\tpud = pud_offset(pgd, 0);\n\t\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpud = (pud_t *)info->alloc_pgt_page(info->context);\n\t\tif (!pud)\n\t\t\treturn -ENOMEM;\n\t\tresult = ident_pud_init(info, pud, addr, next);\n\t\tif (result)\n\t\t\treturn result;\n\t\tset_pgd(pgd, __pgd(__pa(pud) | _KERNPG_TABLE));\n\t}\n\n\treturn 0;\n}",
    "decom_sum": "Allocates and initializes missing top-level page table entries, recursively populating lower levels to map the virtual address range between a3 and a4.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes missing top-level page table entries, recursively populating lower levels to map the virtual address range between a3 and a4.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Recursively processes and maps a memory range by traversing and updating a multi-level page table structure based on address translation and allocation.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes missing top-level page table entries, recursively populating lower levels to map the virtual address range between a3 and a4.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
    "filter2_prorec_aug_sum": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
    "filter2_prorec_aug2_sum": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
    "source_code": "\nstatic reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
    "decom_sum": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and validates an entry structure, allocates required memory, and registers it into a dynamically resized list indexed by a masked identifier.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
    "filter2_prorec_aug_sum": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
    "filter2_prorec_aug2_sum": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
    "source_code": "\napr_fileperms_t apr_unix_mode2perms(mode_t mode)\n{\n    apr_fileperms_t perms = 0;\n\n    if (mode & S_ISUID)\n        perms |= APR_USETID;\n    if (mode & S_IRUSR)\n        perms |= APR_UREAD;\n    if (mode & S_IWUSR)\n        perms |= APR_UWRITE;\n    if (mode & S_IXUSR)\n        perms |= APR_UEXECUTE;\n\n    if (mode & S_ISGID)\n        perms |= APR_GSETID;\n    if (mode & S_IRGRP)\n        perms |= APR_GREAD;\n    if (mode & S_IWGRP)\n        perms |= APR_GWRITE;\n    if (mode & S_IXGRP)\n        perms |= APR_GEXECUTE;\n\n#ifdef S_ISVTX\n    if (mode & S_ISVTX)\n        perms |= APR_WSTICKY;\n#endif\n    if (mode & S_IROTH)\n        perms |= APR_WREAD;\n    if (mode & S_IWOTH)\n        perms |= APR_WWRITE;\n    if (mode & S_IXOTH)\n        perms |= APR_WEXECUTE;\n\n    return perms;\n}",
    "decom_sum": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Converts a Unix file mode bitmask into an APR permission bit representation with mapped read, write, execute, and special mode flags.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs X509 certificate policy check, updates context on specific policy errors, and invokes callbacks based on verification results.",
    "filter2_prorec_aug_sum": "Performs X509 certificate policy checking and updates verification context state or errors based on policy check results and certificate chain attributes.",
    "filter2_prorec_aug2_sum": "Performs X.509 certificate policy check, handles specific error codes by setting context fields and invoking a callback, and returns verification success or failure.",
    "source_code": "\nstatic int check_policy(X509_STORE_CTX *ctx)\n\t{\n\tint ret;\n\tif (ctx->parent)\n\t\treturn 1;\n\tret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n\t\t\t\tctx->param->policies, ctx->param->flags);\n\tif (ret == 0)\n\t\t{\n\t\tX509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\t/* Invalid or inconsistent extensions */\n\tif (ret == -1)\n\t\t{\n\t\t/* Locate certificates with bad extensions and notify\n\t\t * callback.\n\t\t */\n\t\tX509 *x;\n\t\tint i;\n\t\tfor (i = 1; i < sk_X509_num(ctx->chain); i++)\n\t\t\t{\n\t\t\tx = sk_X509_value(ctx->chain, i);\n\t\t\tif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n\t\t\t\tcontinue;\n\t\t\tctx->current_cert = x;\n\t\t\tctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\n\t\t\tif(!ctx->verify_cb(0, ctx))\n\t\t\t\treturn 0;\n\t\t\t}\n\t\treturn 1;\n\t\t}\n\tif (ret == -2)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n\t\treturn ctx->verify_cb(0, ctx);\n\t\t}\n\n\tif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)\n\t\t{\n\t\tctx->current_cert = NULL;\n\t\tctx->error = X509_V_OK;\n\t\tif (!ctx->verify_cb(2, ctx))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}",
    "decom_sum": "Checks X.509 certificate policies using `X509_policy_check` and triggers appropriate callbacks or errors based on policy validation results.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs X509 certificate policy check, updates context on specific policy errors, and invokes callbacks based on verification results.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs X509 certificate policy checking and updates verification context state or errors based on policy check results and certificate chain attributes.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs X.509 certificate policy check, handles specific error codes by setting context fields and invoking a callback, and returns verification success or failure.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
    "filter2_prorec_aug_sum": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
    "filter2_prorec_aug2_sum": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
    "source_code": "void\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);\n\n  if (z == 2) /* simplify sqrt loop: z-1 == 1 */\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_tdiv_q (t, y, u);\t\t/* t = y/x */\n      mpz_add (t, t, u);\t\t/* t = y/x + x */\n      mpz_tdiv_q_2exp (t, t, 1);\t/* x'= (y/x + x)/2 */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n  else /* z != 2 */ {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_pow_ui (t, u, z - 1);\t\t/* t = x^(z-1) */\n      mpz_tdiv_q (t, y, t);\t\t/* t = y/x^(z-1) */\n      mpz_mul_ui (v, u, z - 1);\t\t/* v = x*(z-1) */\n      mpz_add (t, t, v);\t\t/* t = y/x^(z-1) + x*(z-1) */\n      mpz_tdiv_q_ui (t, t, z);\t\t/* x'=(y/x^(z-1) + x*(z-1))/z */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}",
    "decom_sum": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Computes the integer n\u2011th root of a large number and optionally its remainder, handling edge cases for zero, even roots, and negative inputs.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses a delimited string into key=value pairs, stores them in an associative array, and returns an error code on failure.",
    "filter2_prorec_aug_sum": "Parses a colon-separated string into key-value pairs at '=' and stores them in an associative map, returning error codes on failure.",
    "filter2_prorec_aug2_sum": "Parses a colon-delimited string into key-value pairs, storing them in an associative map and reporting errors on malformed entries.",
    "source_code": "\nint\nmutil_parse_field_map (const char *map, mu_assoc_t *passoc_tab, int *perr)\n{\n  int rc;\n  int i;\n  struct mu_wordsplit ws;\n  mu_assoc_t assoc_tab = NULL;\n\n  ws.ws_delim = \":\";\n  if (mu_wordsplit (map, &ws, MU_WRDSF_DEFFLAGS|MU_WRDSF_DELIM))\n    {\n      mu_error (_(\"cannot split line `%s': %s\"), map,\n\t\tmu_wordsplit_strerror (&ws));\n      return errno;\n    }\n\n  for (i = 0; i < ws.ws_wordc; i++)\n    {\n      char *tok = ws.ws_wordv[i];\n      char *p = strchr (tok, '=');\n      char *pptr;\n      \n      if (!p)\n\t{\n\t  rc = EINVAL;\n\t  break;\n\t}\n      if (!assoc_tab)\n\t{\n\t  rc = mu_assoc_create (&assoc_tab, 0);\n\t  if (rc)\n\t    break;\n\t  mu_assoc_set_destroy_item (assoc_tab, mu_list_free_item);\n\t  *passoc_tab = assoc_tab;\n\t}\n      *p++ = 0;\n      pptr = strdup (p);\n      if (!pptr)\n\t{\n\t  rc = errno;\n\t  break;\n\t}\n      rc = mu_assoc_install (assoc_tab, tok, pptr);\n      if (rc)\n\t{\n\t  free (p);\n\t  break;\n\t}\n    }\n\n  mu_wordsplit_free (&ws);\n  if (rc && perr)\n    *perr = i;\n  return rc;\n}",
    "decom_sum": "Parses a colon-delimited string of key=value pairs into an associative map, creating and storing entries, and returns error codes on failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses a delimited string into key=value pairs, stores them in an associative array, and returns an error code on failure.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses a colon-separated string into key-value pairs at '=' and stores them in an associative map, returning error codes on failure.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses a colon-delimited string into key-value pairs, storing them in an associative map and reporting errors on malformed entries.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Registers a new Relax-NG types library by name if not already registered, storing associated handlers and returning success or error code.",
    "filter2_prorec_aug_sum": "Registers a new Relax-NG types library by name in a global hash table, returning error if already registered or on allocation failure.",
    "filter2_prorec_aug2_sum": "Registers a new Relax-NG types library by name and associated handlers in the global hash table, reporting errors if the name already exists or allocation fails.",
    "source_code": "static int\nxmlRelaxNGRegisterTypeLibrary(const xmlChar * namespace, void *data,\n                              xmlRelaxNGTypeHave have,\n                              xmlRelaxNGTypeCheck check,\n                              xmlRelaxNGTypeCompare comp,\n                              xmlRelaxNGFacetCheck facet,\n                              xmlRelaxNGTypeFree freef)\n{\n    xmlRelaxNGTypeLibraryPtr lib;\n    int ret;\n\n    if ((xmlRelaxNGRegisteredTypes == NULL) || (namespace == NULL) ||\n        (check == NULL) || (comp == NULL))\n        return (-1);\n    if (xmlHashLookup(xmlRelaxNGRegisteredTypes, namespace) != NULL) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library '%s' already registered\\n\",\n                        namespace);\n        return (-1);\n    }\n    lib =\n        (xmlRelaxNGTypeLibraryPtr)\n        xmlMalloc(sizeof(xmlRelaxNGTypeLibrary));\n    if (lib == NULL) {\n        xmlRngVErrMemory(NULL, \"adding types library\\n\");\n        return (-1);\n    }\n    memset(lib, 0, sizeof(xmlRelaxNGTypeLibrary));\n    lib->namespace = xmlStrdup(namespace);\n    lib->data = data;\n    lib->have = have;\n    lib->comp = comp;\n    lib->check = check;\n    lib->facet = facet;\n    lib->freef = freef;\n    ret = xmlHashAddEntry(xmlRelaxNGRegisteredTypes, namespace, lib);\n    if (ret < 0) {\n        xmlGenericError(xmlGenericErrorContext,\n                        \"Relax-NG types library failed to register '%s'\\n\",\n                        namespace);\n        xmlRelaxNGFreeTypeLibrary(lib, namespace);\n        return (-1);\n    }\n    return (0);\n}",
    "decom_sum": "Registers a new Relax-NG types library in a global XML hash table, allocating and storing its callbacks, and reports errors if registration fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Registers a new Relax-NG types library by name if not already registered, storing associated handlers and returning success or error code.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Registers a new Relax-NG types library by name in a global hash table, returning error if already registered or on allocation failure.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Registers a new Relax-NG types library by name and associated handlers in the global hash table, reporting errors if the name already exists or allocation fails.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses HTTP headers from input buffer, handles HTTP response states, triggers debug logging, and manages connection failures or response writing accordingly.",
    "filter2_prorec_aug_sum": "Parses HTTP headers from a buffered event, handles status-specific responses, and triggers connection failure or subsequent processing based on parsing and status codes.",
    "filter2_prorec_aug2_sum": "Parses HTTP headers from input buffer, handles response states, triggers callbacks or errors, manages connection failures, and initiates HTTP writing based on status codes.",
    "source_code": "\nstatic void\nevhttp_read_header(struct evhttp_connection *evcon,\n\t\t   struct evhttp_request *req)\n{\n\tenum message_read_status res;\n\tevutil_socket_t fd = evcon->fd;\n\n\tres = evhttp_parse_headers_(req, bufferevent_get_input(evcon->bufev));\n\tif (res == DATA_CORRUPTED || res == DATA_TOO_LONG) {\n\t\t/* Error while reading, terminate */\n\t\tevent_debug((\"%s: bad header lines on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\treturn;\n\t} else if (res == MORE_DATA_EXPECTED) {\n\t\t/* Need more header lines */\n\t\treturn;\n\t}\n\n\t/* Callback can shut down connection with negative return value */\n\tif (req->header_cb != NULL) {\n\t\tif ((*req->header_cb)(req, req->cb_arg) < 0) {\n\t\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_EOF);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Done reading headers, do the real work */\n\tswitch (req->kind) {\n\tcase EVHTTP_REQUEST:\n\t\tevent_debug((\"%s: checking for post data on \"EV_SOCK_FMT\"\\n\",\n\t\t\t__func__, EV_SOCK_ARG(fd)));\n\t\tevhttp_get_body(evcon, req);\n\t\t/* note the request may have been freed in evhttp_get_body */\n\t\tbreak;\n\n\tcase EVHTTP_RESPONSE:\n\t\t/* Start over if we got a 100 Continue response. */\n\t\tif (req->response_code == 100) {\n\t\t\tstruct evbuffer *output = bufferevent_get_output(evcon->bufev);\n\t\t\tevbuffer_add_buffer(output, req->output_buffer);\n\t\t\tevhttp_start_write_(evcon);\n\t\t\treturn;\n\t\t}\n\t\tif (!evhttp_response_needs_body(req)) {\n\t\t\tevent_debug((\"%s: skipping body for code %d\\n\",\n\t\t\t\t\t__func__, req->response_code));\n\t\t\tevhttp_connection_done(evcon);\n\t\t} else {\n\t\t\tevent_debug((\"%s: start of read body for %s on \"\n\t\t\t\tEV_SOCK_FMT\"\\n\",\n\t\t\t\t__func__, req->remote_host, EV_SOCK_ARG(fd)));\n\t\t\tevhttp_get_body(evcon, req);\n\t\t\t/* note the request may have been freed in\n\t\t\t * evhttp_get_body */\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tevent_warnx(\"%s: bad header on \"EV_SOCK_FMT, __func__,\n\t\t    EV_SOCK_ARG(fd));\n\t\tevhttp_connection_fail_(evcon, EVREQ_HTTP_INVALID_HEADER);\n\t\tbreak;\n\t}\n\t/* request may have been freed above */\n}",
    "decom_sum": "Parses HTTP headers from a buffered event, handles status-specific responses, and triggers connection failure or subsequent processing based on parsing and status codes.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses HTTP headers from input buffer, handles HTTP response states, triggers debug logging, and manages connection failures or response writing accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses HTTP headers from a buffered event, handles status-specific responses, and triggers connection failure or subsequent processing based on parsing and status codes.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses HTTP headers from input buffer, handles response states, triggers callbacks or errors, manages connection failures, and initiates HTTP writing based on status codes.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses a level-indent configuration string, setting indentation strings or emitting errors for invalid or unknown options.",
    "filter2_prorec_aug_sum": "Parses a level-indent option string, either setting global indent patterns from named options or creating a space-filled string of specified length.",
    "filter2_prorec_aug2_sum": "Parses a level-indent setting from a string, validates and applies corresponding indentation strings or initializes space-filled indent buffers accordingly.",
    "source_code": "\nstatic void\nset_level_indent(const char *str)\n{\n     long n;\n     const char *p;\n     char *q;\n     \n     n = strtol(str, &q, 0);\n     if (*q == 0 && n > 0) {\n\t  char *s = xmalloc(n+1);\n\t  memset(s, ' ', n-1);\n\t  s[n-1] = 0;\n\t  level_indent[0] = level_indent[1] = s;\n\t  return;\n     }\n     \n     p = str;\n     while (*p != '=') {\n\t  if (*p == 0)\n\t       error(EX_USAGE, 0, _(\"level-indent syntax\"));\n\t  p++;\n     }\n     ++p;\n    \n     switch (find_option_type(level_indent_optype, str, p - str - 1)) {\n     case LEVEL_BEGIN:\n\t  parse_level_string(p, &level_begin);\n\t  break;\n     case LEVEL_INDENT0:\n\t  parse_level_string(p, &level_indent[0]);\n\t  break;\n     case LEVEL_INDENT1:\n\t  parse_level_string(p, &level_indent[1]);\n\t  break;\n     case LEVEL_END0:\n\t  parse_level_string(p, &level_end[0]);\n\t  break;\n     case LEVEL_END1:\n\t  parse_level_string(p, &level_end[1]);\n\t  break;\n     default:\n\t  error(EX_USAGE, 0, _(\"unknown level indent option: %s\"), str);\n     }\n}",
    "decom_sum": "Parses a level-indent option string, either setting global indent patterns from named options or creating a space-filled string of specified length.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses a level-indent configuration string, setting indentation strings or emitting errors for invalid or unknown options.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses a level-indent option string, either setting global indent patterns from named options or creating a space-filled string of specified length.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses a level-indent setting from a string, validates and applies corresponding indentation strings or initializes space-filled indent buffers accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Searches a lowercase-mapped key in the combined hash table or iterates regex patterns to find and return the associated mapped value.",
    "filter2_prorec_aug_sum": "Searches a map for a case-insensitive key match and, if not found, attempts regex pattern matches before returning the associated value or NULL.",
    "filter2_prorec_aug2_sum": "Looks up a lowercased key in a combined hash and falls back to regex matching against map patterns to return the mapped value or zero if not found.",
    "source_code": "\n\nvoid *\nngx_http_map_find(ngx_http_request_t *r, ngx_http_map_t *map, ngx_str_t *match)\n{\n    void        *value;\n    u_char      *low;\n    size_t       len;\n    ngx_uint_t   key;\n\n    len = match->len;\n\n    if (len) {\n        low = ngx_pnalloc(r->pool, len);\n        if (low == NULL) {\n            return NULL;\n        }\n\n    } else {\n        low = NULL;\n    }\n\n    key = ngx_hash_strlow(low, match->data, len);\n\n    value = ngx_hash_find_combined(&map->hash, key, low, len);\n    if (value) {\n        return value;\n    }\n\n#if (NGX_PCRE)\n\n    if (len && map->nregex) {\n        ngx_int_t              n;\n        ngx_uint_t             i;\n        ngx_http_map_regex_t  *reg;\n\n        reg = map->regex;\n\n        for (i = 0; i < map->nregex; i++) {\n\n            n = ngx_http_regex_exec(r, reg[i].regex, match);\n\n            if (n == NGX_OK) {\n                return reg[i].value;\n            }\n\n            if (n == NGX_DECLINED) {\n                continue;\n            }\n\n            /* NGX_ERROR */\n\n            return NULL;\n        }\n    }\n\n#endif\n\n    return NULL;\n}",
    "decom_sum": "Finds a matching HTTP map entry by lowercased hash key, falling back to regex rules when no direct hash match is found.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Searches a lowercase-mapped key in the combined hash table or iterates regex patterns to find and return the associated mapped value.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Searches a map for a case-insensitive key match and, if not found, attempts regex pattern matches before returning the associated value or NULL.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Looks up a lowercased key in a combined hash and falls back to regex matching against map patterns to return the mapped value or zero if not found.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes HTTP request body buffers by copying chain links, conditionally invoking sub_56600, and managing free buffer allocation, returning HTTP status codes on failure.",
    "filter2_prorec_aug_sum": "Handles saving the HTTP request body by copying chains, checking flags, invoking a sub-filter, and managing buffer allocation or returning error status.",
    "filter2_prorec_aug2_sum": "Validates and saves HTTP request body buffers into the request chain, manages buffer allocation, and returns HTTP error code on failure.",
    "source_code": "\n\nngx_int_t\nngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n{\n    ngx_buf_t                 *b;\n    ngx_chain_t               *cl;\n    ngx_http_request_body_t   *rb;\n\n    rb = r->request_body;\n\n#if (NGX_DEBUG)\n\n#if 0\n    for (cl = rb->bufs; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body old buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n#endif\n\n    for (cl = in; cl; cl = cl->next) {\n        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                       \"http body new buf t:%d f:%d %p, pos %p, size: %z \"\n                       \"file: %O, size: %O\",\n                       cl->buf->temporary, cl->buf->in_file,\n                       cl->buf->start, cl->buf->pos,\n                       cl->buf->last - cl->buf->pos,\n                       cl->buf->file_pos,\n                       cl->buf->file_last - cl->buf->file_pos);\n    }\n\n#endif\n\n    /* TODO: coalesce neighbouring buffers */\n\n    if (ngx_chain_add_copy(r->pool, &rb->bufs, in) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (r->request_body_no_buffering) {\n        return NGX_OK;\n    }\n\n    if (rb->rest > 0) {\n\n        if (rb->buf && rb->buf->last == rb->buf->end\n            && ngx_http_write_request_body(r) != NGX_OK)\n        {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        return NGX_OK;\n    }\n\n    /* rb->rest == 0 */\n\n    if (rb->temp_file || r->request_body_in_file_only) {\n\n        if (ngx_http_write_request_body(r) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (rb->temp_file->file.offset != 0) {\n\n            cl = ngx_chain_get_free_buf(r->pool, &rb->free);\n            if (cl == NULL) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            b = cl->buf;\n\n            ngx_memzero(b, sizeof(ngx_buf_t));\n\n            b->in_file = 1;\n            b->file_last = rb->temp_file->file.offset;\n            b->file = &rb->temp_file->file;\n\n            rb->bufs = cl;\n        }\n    }\n\n    return NGX_OK;\n}",
    "decom_sum": "Processes and stores HTTP request body buffers, invoking sub_56600 for further handling, and allocates or frees buffers as needed, returning 0 or HTTP 500 on error.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes HTTP request body buffers by copying chain links, conditionally invoking sub_56600, and managing free buffer allocation, returning HTTP status codes on failure.",
            "flag": false,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Handles saving the HTTP request body by copying chains, checking flags, invoking a sub-filter, and managing buffer allocation or returning error status.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.5
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and saves HTTP request body buffers into the request chain, manages buffer allocation, and returns HTTP error code on failure.",
            "flag": false,
            "score": [
                0.7,
                0.6,
                0.5
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes or resets a global state, performs conditional processing and synchronization on a 1024-integer buffer, and invokes subsystem handler callbacks based on runtime flags.",
    "filter2_prorec_aug_sum": "Initializes hardware state and buffers, triggers device-specific routines, and updates global flags based on configuration and operational mode bits.",
    "filter2_prorec_aug2_sum": "Initializes or resets a buffer with a sentinel, processes input parameters if enabled, and conditionally performs synchronization and callback operations based on global state flags.",
    "source_code": "\nint __init APIC_init_uniprocessor(void)\n{\n\tif (disable_apic) {\n\t\tpr_info(\"Apic disabled\\n\");\n\t\treturn -1;\n\t}\n#ifdef CONFIG_X86_64\n\tif (!cpu_has_apic) {\n\t\tdisable_apic = 1;\n\t\tpr_info(\"Apic disabled by BIOS\\n\");\n\t\treturn -1;\n\t}\n#else\n\tif (!smp_found_config && !cpu_has_apic)\n\t\treturn -1;\n\n\t/*\n\t * Complain if the BIOS pretends there is one.\n\t */\n\tif (!cpu_has_apic &&\n\t    APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {\n\t\tpr_err(\"BIOS bug, local APIC 0x%x not detected!...\\n\",\n\t\t\tboot_cpu_physical_apicid);\n\t\treturn -1;\n\t}\n#endif\n\n\tdefault_setup_apic_routing();\n\n\tverify_local_APIC();\n\tconnect_bsp_APIC();\n\n#ifdef CONFIG_X86_64\n\tapic_write(APIC_ID, SET_APIC_ID(boot_cpu_physical_apicid));\n#else\n\t/*\n\t * Hack: In case of kdump, after a crash, kernel might be booting\n\t * on a cpu with non-zero lapic id. But boot_cpu_physical_apicid\n\t * might be zero if read from MP tables. Get it from LAPIC.\n\t */\n# ifdef CONFIG_CRASH_DUMP\n\tboot_cpu_physical_apicid = read_apic_id();\n# endif\n#endif\n\tphysid_set_mask_of_physid(boot_cpu_physical_apicid, &phys_cpu_present_map);\n\tsetup_local_APIC();\n\n#ifdef CONFIG_X86_IO_APIC\n\t/*\n\t * Now enable IO-APICs, actually call clear_IO_APIC\n\t * We need clear_IO_APIC before enabling error vector\n\t */\n\tif (!skip_ioapic_setup && nr_ioapics)\n\t\tenable_IO_APIC();\n#endif\n\n\tbsp_end_local_APIC_setup();\n\n#ifdef CONFIG_X86_IO_APIC\n\tif (smp_found_config && !skip_ioapic_setup && nr_ioapics)\n\t\tsetup_IO_APIC();\n\telse {\n\t\tnr_ioapics = 0;\n\t}\n#endif\n\n\tx86_init.timers.setup_percpu_clockev();\n\treturn 0;\n}",
    "decom_sum": "Initializes hardware state and buffers, triggers device-specific routines, and updates global flags based on configuration and operational mode bits.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes or resets a global state, performs conditional processing and synchronization on a 1024-integer buffer, and invokes subsystem handler callbacks based on runtime flags.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes hardware state and buffers, triggers device-specific routines, and updates global flags based on configuration and operational mode bits.",
            "flag": true,
            "score": [
                0.2,
                0.1,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes or resets a buffer with a sentinel, processes input parameters if enabled, and conditionally performs synchronization and callback operations based on global state flags.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Decodes ASN.1 data with constructed flags, validates the decoding, manages errors, and advances the input pointer accordingly on success.",
    "filter2_prorec_aug_sum": "Decodes an ASN.1 structure using template-based parsing and handles explicit tagging, error checking, and buffer advancement in DER/BER encoding.",
    "filter2_prorec_aug2_sum": "Decodes ASN.1 complex templates with special tag processing, error handling, and buffer pointer adjustments for advanced ASN.1 structure parsing.",
    "source_code": "\nstatic int asn1_template_ex_d2i(ASN1_VALUE **val,\n\t\t\t\tconst unsigned char **in, long inlen,\n\t\t\t\tconst ASN1_TEMPLATE *tt, char opt,\n\t\t\t\t\t\t\tASN1_TLC *ctx)\n\t{\n\tint flags, aclass;\n\tint ret;\n\tlong len;\n\tconst unsigned char *p, *q;\n\tchar exp_eoc;\n\tif (!val)\n\t\treturn 0;\n\tflags = tt->flags;\n\taclass = flags & ASN1_TFLG_TAG_CLASS;\n\n\tp = *in;\n\n\t/* Check if EXPLICIT tag expected */\n\tif (flags & ASN1_TFLG_EXPTAG)\n\t\t{\n\t\tchar cst;\n\t\t/* Need to work out amount of data available to the inner\n\t\t * content and where it starts: so read in EXPLICIT header to\n\t\t * get the info.\n\t\t */\n\t\tret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,\n\t\t\t\t\t&p, inlen, tt->tag, aclass, opt, ctx);\n\t\tq = p;\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\telse if (ret == -1)\n\t\t\treturn -1;\n\t\tif (!cst)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We've found the field so it can't be OPTIONAL now */\n\t\tret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);\n\t\tif (!ret)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tERR_R_NESTED_ASN1_ERROR);\n\t\t\treturn 0;\n\t\t\t}\n\t\t/* We read the field in OK so update length */\n\t\tlen -= p - q;\n\t\tif (exp_eoc)\n\t\t\t{\n\t\t\t/* If NDEF we must have an EOC here */\n\t\t\tif (!asn1_check_eoc(&p, len))\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\t\tASN1_R_MISSING_EOC);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* Otherwise we must hit the EXPLICIT tag end or its\n\t\t\t * an error */\n\t\t\tif (len)\n\t\t\t\t{\n\t\t\t\tASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\n\t\t\t\t\tASN1_R_EXPLICIT_LENGTH_MISMATCH);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t\treturn asn1_template_noexp_d2i(val, in, inlen,\n\t\t\t\t\t\t\t\ttt, opt, ctx);\n\n\t*in = p;\n\treturn 1;\n\n\terr:\n\tASN1_template_free(val, tt);\n\treturn 0;\n\t}",
    "decom_sum": "Parses and validates ASN.1 encoded data using template-based decoding, handles errors, and updates buffer pointers while freeing resources on failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Decodes ASN.1 data with constructed flags, validates the decoding, manages errors, and advances the input pointer accordingly on success.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Decodes an ASN.1 structure using template-based parsing and handles explicit tagging, error checking, and buffer advancement in DER/BER encoding.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Decodes ASN.1 complex templates with special tag processing, error handling, and buffer pointer adjustments for advanced ASN.1 structure parsing.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
    "filter2_prorec_aug_sum": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
    "filter2_prorec_aug2_sum": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
    "source_code": "\nstatic psmouse_ret_t cypress_protocol_handler(struct psmouse *psmouse)\n{\n\tstruct cytp_data *cytp = psmouse->private;\n\n\tif (psmouse->pktcnt >= cytp->pkt_size) {\n\t\tcypress_process_packet(psmouse, 0);\n\t\treturn PSMOUSE_FULL_PACKET;\n\t}\n\n\treturn cypress_validate_byte(psmouse);\n}",
    "decom_sum": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates and updates a device state counter, modifying control registers and invoking a handler when conditions fail or specific flags are unset.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Handles specific signals by resetting handlers, blocking the signal, sending it to the current process, and restoring previous signal actions for controlled termination or abort.",
    "filter2_prorec_aug_sum": "Handles specific UNIX signals by temporarily swapping handlers, masking, triggering the signal to self, executing cleanup routines, then restoring original handlers.",
    "filter2_prorec_aug2_sum": "Handles specific signals by setting custom sigaction handlers, blocking the signal, sending the signal to the process, and restoring original handlers to ensure controlled signal termination.",
    "source_code": "\nstatic void\ninfo_signal_proc (int sig)\n{\n  signal_info *old_signal_handler = NULL;\n\n#if !defined (HAVE_SIGACTION)\n  /* best effort: first increment this counter and later block signals */\n  if (term_conf_busy)\n    return;\n  term_conf_busy++;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_BLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n  switch (sig)\n    {\n#if defined (SIGTSTP)\n    case SIGTSTP:\n    case SIGTTOU:\n    case SIGTTIN:\n#endif\n#if defined (SIGQUIT)\n    case SIGQUIT:\n#endif\n#if defined (SIGINT)\n    case SIGINT:\n#endif\n#if defined (SIGTERM)\n    case SIGTERM:\n#endif\n      {\n#if defined (SIGTSTP)\n        if (sig == SIGTSTP)\n          old_signal_handler = &old_TSTP;\n        if (sig == SIGTTOU)\n          old_signal_handler = &old_TTOU;\n        if (sig == SIGTTIN)\n          old_signal_handler = &old_TTIN;\n#endif /* SIGTSTP */\n#if defined (SIGQUIT)\n        if (sig == SIGQUIT)\n          old_signal_handler = &old_QUIT;\n#endif /* SIGQUIT */\n#if defined (SIGINT)\n        if (sig == SIGINT)\n          old_signal_handler = &old_INT;\n#endif /* SIGINT */\n#if defined (SIGTERM)\n        if (sig == SIGTERM)\n          old_signal_handler = &old_TERM;\n#endif /* SIGTERM */\n\n        /* For stop signals, restore the terminal IO, leave the cursor\n           at the bottom of the window, and stop us. */\n        terminal_goto_xy (0, screenheight - 1);\n        terminal_clear_to_eol ();\n        fflush (stdout);\n        terminal_unprep_terminal ();\n\trestore_termsig (sig, old_signal_handler);\n\tUNBLOCK_SIGNAL (sig);\n\tkill (getpid (), sig);\n\n        /* The program is returning now.  Restore our signal handler,\n           turn on terminal handling, redraw the screen, and place the\n           cursor where it belongs. */\n        terminal_prep_terminal ();\n\tset_termsig (sig, old_signal_handler);\n\t/* window size might be changed while sleeping */\n\treset_info_window_sizes ();\n      }\n      break;\n\n#if defined (SIGWINCH) || defined (SIGUSR1)\n#ifdef SIGWINCH\n    case SIGWINCH:\n#endif\n#ifdef SIGUSR1\n    case SIGUSR1:\n#endif\n      {\n\t/* Turn off terminal IO, tell our parent that the window has changed,\n\t   then reinitialize the terminal and rebuild our windows. */\n#ifdef SIGWINCH\n\tif (sig == SIGWINCH)\n\t  old_signal_handler = &old_WINCH;\n#endif\n#ifdef SIGUSR1\n\tif (sig == SIGUSR1)\n\t  old_signal_handler = &old_USR1;\n#endif\n\n        /* This seems risky: what if we receive a (real) signal before\n           the next line is reached? */\n#if 0\n\trestore_termsig (sig, old_signal_handler);\n\tkill (getpid (), sig);\n#endif\n\n\t/* After our old signal handler returns... */\n\tset_termsig (sig, old_signal_handler); /* needless? */\n\n        if (sigwinch_block_count != 0)\n          abort ();\n\n        /* Avoid any of the code unblocking the signal too early.  This\n           should set the variable to 1 because we shouldn't be here if\n           sigwinch_block_count > 0. */\n        sigwinch_block_count++;\n\n\treset_info_window_sizes ();\n\n        sigwinch_block_count--;\n        /* Don't unblock the signal until after we've finished. */\n\tUNBLOCK_SIGNAL (sig);\n      }\n      break;\n#endif /* SIGWINCH || SIGUSR1 */\n    }\n#if !defined (HAVE_SIGACTION)\n  /* at this time it is safer to perform unblock after decrement */\n  term_conf_busy--;\n#if defined (HAVE_SIGPROCMASK)\n    {\n      sigset_t nvar, ovar;\n      sigemptyset (&nvar);\n      mask_termsig (&nvar);\n      sigprocmask (SIG_UNBLOCK, &nvar, &ovar);\n    }\n#endif /* HAVE_SIGPROCMASK */\n#endif /* !HAVE_SIGACTION */\n}",
    "decom_sum": "Handles specific UNIX signals by temporarily swapping handlers, masking, triggering the signal to self, executing cleanup routines, then restoring original handlers.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Handles specific signals by resetting handlers, blocking the signal, sending it to the current process, and restoring previous signal actions for controlled termination or abort.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Handles specific UNIX signals by temporarily swapping handlers, masking, triggering the signal to self, executing cleanup routines, then restoring original handlers.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Handles specific signals by setting custom sigaction handlers, blocking the signal, sending the signal to the process, and restoring original handlers to ensure controlled signal termination.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Registers and links a new ENGINE structure into the global engine list, ensuring uniqueness, thread safety, and updating related tracking pointers.",
    "filter2_prorec_aug_sum": "Adds a new unique ENGINE structure to the global linked list, locking the list and updating pointers while handling duplicate and error conditions.",
    "filter2_prorec_aug2_sum": "Registers and links a new ENGINE structure into the global engine list, ensuring uniqueness, thread safety, and updating related tracking pointers.",
    "source_code": "int ENGINE_add(ENGINE *e)\n\t{\n\tint to_return = 1;\n\tif(e == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\tif((e->id == NULL) || (e->name == NULL))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_ID_OR_NAME_MISSING);\n\t\t}\n\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\tif(!engine_list_add(e))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_ADD,\n\t\t\tENGINE_R_INTERNAL_LIST_ERROR);\n\t\tto_return = 0;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\treturn to_return;\n\t}",
    "decom_sum": "Registers and links a new ENGINE structure into the global engine list, ensuring uniqueness, thread safety, and updating related tracking pointers.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Registers and links a new ENGINE structure into the global engine list, ensuring uniqueness, thread safety, and updating related tracking pointers.",
            "flag": true,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Adds a new unique ENGINE structure to the global linked list, locking the list and updating pointers while handling duplicate and error conditions.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Registers and links a new ENGINE structure into the global engine list, ensuring uniqueness, thread safety, and updating related tracking pointers.",
            "flag": true,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Searches a structure list for an entry matching given key and size, increments its reference count, and updates associated state using provided parameters.",
    "filter2_prorec_aug_sum": "Searches for a resource entry matching given keys, increments its reference count, updates it with parameters, and returns status or error codes accordingly.",
    "filter2_prorec_aug2_sum": "Searches for an entry matching a key and size in a data structure, increments its reference count, updates it with given parameters, or returns an error code.",
    "source_code": "\nstatic int inet6_addr_del(struct net *net, int ifindex, const struct in6_addr *pfx,\n\t\t\t  unsigned int plen)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\n\tif (plen > 128)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif ((idev = __in6_dev_get(dev)) == NULL)\n\t\treturn -ENXIO;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->prefix_len == plen &&\n\t\t    ipv6_addr_equal(pfx, &ifp->addr)) {\n\t\t\tin6_ifa_hold(ifp);\n\t\t\tread_unlock_bh(&idev->lock);\n\n\t\t\tipv6_del_addr(ifp);\n\n\t\t\t/* If the last address is deleted administratively,\n\t\t\t   disable IPv6 on this interface.\n\t\t\t */\n\t\t\tif (list_empty(&idev->addr_list))\n\t\t\t\taddrconf_ifdown(idev->dev, 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock_bh(&idev->lock);\n\treturn -EADDRNOTAVAIL;\n}",
    "decom_sum": "Searches a linked list for a matching entry by ID and 128-bit key, increments its reference count, and triggers associated processing routines.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Searches a structure list for an entry matching given key and size, increments its reference count, and updates associated state using provided parameters.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Searches for a resource entry matching given keys, increments its reference count, updates it with parameters, and returns status or error codes accordingly.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Searches for an entry matching a key and size in a data structure, increments its reference count, updates it with given parameters, or returns an error code.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
    "filter2_prorec_aug_sum": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
    "filter2_prorec_aug2_sum": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
    "source_code": "\nstatic char *\nstyle_sheet_mixed_new (const uchar * ancestors)\n{\n  struct style_sheet *sheet, *ancestor;\n  char *ancestor_key, *key, *cp;\n  char *ancestors_keys;\n  struct darray *ancestors_array;\n\n  /* It cannot be longer than ancestors_keys. */\n  key = ALLOCA (char, ustrlen (ancestors) + 1);\n  astrcpy (ancestors_keys, ancestors);\n\n  /* Create the darray of ancestors keys, and build the final key. */\n  ancestors_array = ancestors_new ();\n  ancestor_key = strtok (ancestors_keys, MIXED_SHEET_SEP);\n  da_append (ancestors_array, ancestor_key);\n  ancestor = get_style_sheet (ancestor_key);\n  cp = stpcpy (key, ancestor->key);\n\n  while ((ancestor_key = strtok (NULL, MIXED_SHEET_SEP)))\n    {\n      da_append (ancestors_array, ancestor_key);\n      ancestor = get_style_sheet (ancestor_key);\n      *cp++ =',';\n      cp = stpcpy (cp, ancestor->key);\n    }\n  *cp = '\\0';\n  key = xstrdup (key);\n\n  /* Create the style sheet. */\n  message (msg_sheet,\n\t   (stderr, \"Creating a mixed style sheet \\\"%s\\\"\\n\", key));\n  /* Its name is its key. */\n  sheet = new_style_sheet ((uchar *) key);\n  sheet->key = strdup (key);\n  da_concat (sheet->ancestors, ancestors_array);\n  da_erase (ancestors_array);\n  style_sheet_finalize (sheet);\n\n  return key;\n}",
    "decom_sum": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses a comma\u2011delimited style sheet list, registers each entry, builds a combined sheet named via `sub_438B00`, and attaches it to the target object.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
    "filter2_prorec_aug_sum": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
    "filter2_prorec_aug2_sum": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
    "source_code": "EXPORT BITCODE_H\ndwg_find_tablehandle (Dwg_Data *restrict dwg, const char *restrict name,\n                      const char *restrict table)\n{\n  BITCODE_BL i, num_entries = 0;\n  BITCODE_H ctrl = NULL, *hdlv = NULL;\n  Dwg_Object *obj;\n  Dwg_Object_APPID_CONTROL *_obj; // just some random generic type\n  Dwg_Header_Variables *vars = &dwg->header_vars;\n\n  if (!dwg || !name || !table)\n    return NULL;\n  // look for the _CONTROL table, and search for name in all entries\n  ctrl = dwg_ctrl_table (dwg, table);\n  if (strEQc (table, \"LTYPE\"))\n    {\n      if (strEQc (name, \"BYLAYER\") || strEQc (name, \"ByLayer\"))\n        {\n          if (vars->LTYPE_BYLAYER)\n            return vars->LTYPE_BYLAYER;\n        }\n      else if (strEQc (name, \"BYBLOCK\") || strEQc (name, \"ByBlock\"))\n        {\n          if (vars->LTYPE_BYBLOCK)\n            return vars->LTYPE_BYBLOCK;\n        }\n      else if (strEQc (name, \"CONTINUOUS\") || strEQc (name, \"Continuous\"))\n        {\n          if (vars->LTYPE_CONTINUOUS)\n            return vars->LTYPE_CONTINUOUS;\n        }\n    }\n  if (!ctrl)\n    { // TODO: silently search table_control. header_vars can be empty\n      LOG_TRACE (\"dwg_find_tablehandle: Empty header_vars table %s\\n\", table);\n      return NULL;\n    }\n  obj = dwg_resolve_handle (dwg, ctrl->absolute_ref);\n  if (!obj)\n    {\n      LOG_TRACE (\"dwg_find_tablehandle: Could not resolve table %s\\n\", table);\n      return NULL;\n    }\n  if (obj->type == DWG_TYPE_DICTIONARY)\n    return dwg_find_dicthandle_objname (dwg, ctrl, name);\n  if (!dwg_obj_is_control (obj))\n    {\n      LOG_ERROR (\"dwg_find_tablehandle: Could not resolve CONTROL object %s \"\n                 \"for table %s\",\n                 obj->name, table);\n      return NULL;\n    }\n  _obj = obj->tio.object->tio.APPID_CONTROL; // just random type\n  dwg_dynapi_entity_value (_obj, obj->name, \"num_entries\", &num_entries, NULL);\n  if (!num_entries)\n    return NULL;\n  dwg_dynapi_entity_value (_obj, obj->name, \"entries\", &hdlv, NULL);\n  if (!hdlv)\n    return NULL;\n  for (i = 0; i < num_entries; i++)\n    {\n      char *hdlname;\n      Dwg_Object *hobj;\n      Dwg_Object_APPID *_o;\n      int isnew = 0;\n      bool ok;\n\n      if (!hdlv[i])\n        continue;\n      hobj = dwg_resolve_handle (dwg, hdlv[i]->absolute_ref);\n      if (!hobj || !hobj->tio.object || !hobj->tio.object->tio.APPID)\n        continue;\n      _o = hobj->tio.object->tio.APPID;\n      ok = dwg_dynapi_entity_utf8text (_o, hobj->name, \"name\", &hdlname, &isnew, NULL);\n      LOG_HANDLE (\" %s.%s[%d] => %s.name: %s\\n\", obj->name, \"entries\", i,\n                  hobj->name, hdlname ? hdlname : \"NULL\");\n      if (ok && hdlname && (strEQ (name, hdlname) || !strcasecmp (name, hdlname)))\n        {\n          if (isnew)\n            free (hdlname);\n          return hdlv[i];\n        }\n      if (ok && isnew && hdlname)\n        free (hdlname);\n    }\n\n  return NULL;\n}",
    "decom_sum": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.5
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Retrieves a DWG table handle for a given table type and entry name, using predefined cases for LTYPE and error reporting if resolution fails.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.5
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
    "filter2_prorec_aug_sum": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
    "filter2_prorec_aug2_sum": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
    "source_code": "static void\nPerform_Justification(FIELD *field, WINDOW *win)\n{\n  FIELD_CELL *bp;\n  int len;\n\n  bp = (Field_Has_Option(field, O_NO_LEFT_STRIP)\n\t? field->buf\n\t: Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);\n\n  if (len > 0)\n    {\n      int col = 0;\n\n      assert(win && (field->drows == 1));\n\n      if (field->cols - len >= 0)\n\tswitch (field->just)\n\t  {\n\t  case JUSTIFY_LEFT:\n\t    break;\n\t  case JUSTIFY_CENTER:\n\t    col = (field->cols - len) / 2;\n\t    break;\n\t  case JUSTIFY_RIGHT:\n\t    col = field->cols - len;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n      wmove(win, 0, col);\n      myADDNSTR(win, bp, len);\n    }\n}",
    "decom_sum": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Trims leading and trailing spaces from a text buffer and writes the processed content with adjusted length metadata to the target output.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes and clears arrays of hardware-specific registers by invoking multiple specialized functions with given double-precision parameters and state pointers.",
    "filter2_prorec_aug_sum": "Clears specific global state entries by processing indexed data blocks and invokes a sequence of transformation functions with floating-point parameters and status flags.",
    "filter2_prorec_aug2_sum": "Processes and clears an array of 8 filter coefficients by calling sub-functions to update multiple global filter state arrays, then finalizes with a specific filter state operation.",
    "source_code": "\nvoid acpi_ut_mutex_terminate(void)\n{\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_terminate);\n\n\t/* Delete each predefined mutex object */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tacpi_ut_delete_mutex(i);\n\t}\n\n\tacpi_os_delete_mutex(acpi_gbl_osi_mutex);\n\n\t/* Delete the spinlocks */\n\n\tacpi_os_delete_lock(acpi_gbl_gpe_lock);\n\tacpi_os_delete_lock(acpi_gbl_hardware_lock);\n\tacpi_os_delete_lock(acpi_gbl_reference_count_lock);\n\n\t/* Delete the reader/writer lock */\n\n\tacpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_VOID;\n}",
    "decom_sum": "Resets multiple global data entries, processes them with helper routines, and produces a final result through structured sequential computation using provided parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes and clears arrays of hardware-specific registers by invoking multiple specialized functions with given double-precision parameters and state pointers.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Clears specific global state entries by processing indexed data blocks and invokes a sequence of transformation functions with floating-point parameters and status flags.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes and clears an array of 8 filter coefficients by calling sub-functions to update multiple global filter state arrays, then finalizes with a specific filter state operation.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Opens the specified file or stdin, performs initialization and validation, reports errors, and returns status via a3 flag and return value.",
    "filter2_prorec_aug_sum": "Opens the specified file or stdin, validates its readability, sets a status flag on ENOENT, and reports errors through the `error` function.",
    "filter2_prorec_aug2_sum": "Opens a file by name or stdin, checks for read errors, sets a flag if not found, and reports detailed errors accordingly.",
    "source_code": "\nstatic bool\ndigest_file (const char *filename, int *binary, unsigned char *bin_result,\n             bool *missing)\n{\n  FILE *fp;\n  int err;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  *missing = false;\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fp = stdin;\n      if (O_BINARY && *binary)\n        {\n          if (*binary < 0)\n            *binary = ! isatty (STDIN_FILENO);\n          if (*binary)\n            xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n    }\n  else\n    {\n      fp = fopen (filename, (O_BINARY && *binary ? \"rb\" : \"r\"));\n      if (fp == NULL)\n        {\n          if (ignore_missing && errno == ENOENT)\n            {\n              *missing = true;\n              return true;\n            }\n          error (0, errno, \"%s\", quotef (filename));\n          return false;\n        }\n    }\n\n  fadvise (fp, FADVISE_SEQUENTIAL);\n\n#if HASH_ALGO_BLAKE2\n  err = DIGEST_STREAM (fp, bin_result, b2_length / 8);\n#else\n  err = DIGEST_STREAM (fp, bin_result);\n#endif\n  if (err)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      if (fp != stdin)\n        fclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return true;\n}",
    "decom_sum": "Opens the specified file or stdin, validates its readability, sets a status flag on ENOENT, and reports errors through the `error` function.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Opens the specified file or stdin, performs initialization and validation, reports errors, and returns status via a3 flag and return value.",
            "flag": false,
            "score": [
                0.4,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Opens the specified file or stdin, validates its readability, sets a status flag on ENOENT, and reports errors through the `error` function.",
            "flag": true,
            "score": [
                0.8,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Opens a file by name or stdin, checks for read errors, sets a flag if not found, and reports detailed errors accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates and updates a configuration structure by advancing an index, checking status flags, computing adjusted limits, updating metrics, and incrementing counters accordingly.",
    "filter2_prorec_aug_sum": "Validates and updates indexing and size parameters related to a data structure, adjusts associated flags and counters, then increments a reference count if conditions are met.",
    "filter2_prorec_aug2_sum": "Updates configuration state based on indexed flags, validates and adjusts parameters, increments counters, sets bitmasks, and triggers state synchronization with interlocked reference counting.",
    "source_code": "static noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}",
    "decom_sum": "Updates internal state with new buffer parameters from `a2` based on `v2` index, then validates and increments related counters and device statistics.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates and updates a configuration structure by advancing an index, checking status flags, computing adjusted limits, updating metrics, and incrementing counters accordingly.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates and updates indexing and size parameters related to a data structure, adjusts associated flags and counters, then increments a reference count if conditions are met.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Updates configuration state based on indexed flags, validates and adjusts parameters, increments counters, sets bitmasks, and triggers state synchronization with interlocked reference counting.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Scales a matrix by applying the Cholesky factors from a vector, verifying matrix squareness and vector length, and updates matrix elements accordingly.",
    "filter2_prorec_aug_sum": "Scales a matrix by applying element-wise products with values derived from the Cholesky factor and a scaling vector, validating square matrix and vector dimensions.",
    "filter2_prorec_aug2_sum": "Scales the columns of a matrix by elements of a vector after verifying matrix is square and vector length matches matrix dimension.",
    "source_code": "\nint\ngsl_linalg_cholesky_scale_apply(gsl_matrix * A, const gsl_vector * S)\n{\n  const size_t M = A->size1;\n  const size_t N = A->size2;\n\n  if (M != N)\n    {\n      GSL_ERROR(\"A is not a square matrix\", GSL_ENOTSQR);\n    }\n  else if (N != S->size)\n    {\n      GSL_ERROR(\"S must have length N\", GSL_EBADLEN);\n    }\n  else\n    {\n      size_t i, j;\n\n      /* compute: A <- diag(S) A diag(S) using lower triangle */\n      for (j = 0; j < N; ++j)\n        {\n          double sj = gsl_vector_get(S, j);\n\n          for (i = j; i < N; ++i)\n            {\n              double si = gsl_vector_get(S, i);\n              double *Aij = gsl_matrix_ptr(A, i, j);\n              *Aij *= si * sj;\n            }\n        }\n\n      return GSL_SUCCESS;\n    }\n}",
    "decom_sum": "Scales the elements of a Cholesky factor matrix using a provided vector after validating that both inputs have matching square dimensions.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Scales a matrix by applying the Cholesky factors from a vector, verifying matrix squareness and vector length, and updates matrix elements accordingly.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Scales a matrix by applying element-wise products with values derived from the Cholesky factor and a scaling vector, validating square matrix and vector dimensions.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Scales the columns of a matrix by elements of a vector after verifying matrix is square and vector length matches matrix dimension.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates device context, manages resource accounting, adjusts input structure fields, and invokes device-specific or generic processing for I/O or memory operations.",
    "filter2_prorec_aug_sum": "Validates a device context, locks it, updates buffer and page counters, sets flags, and dispatches a final data operation via its handler.",
    "filter2_prorec_aug2_sum": "Validates device state and resource availability, adjusts input parameters accordingly, then initiates a device-specific operation with updated arguments.",
    "source_code": "\nstatic int\nfb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}",
    "decom_sum": "Validates a device context, locks it, updates buffer and page counters, sets flags, and dispatches a final data operation via its handler.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates device context, manages resource accounting, adjusts input structure fields, and invokes device-specific or generic processing for I/O or memory operations.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates a device context, locks it, updates buffer and page counters, sets flags, and dispatches a final data operation via its handler.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates device state and resource availability, adjusts input parameters accordingly, then initiates a device-specific operation with updated arguments.",
            "flag": false,
            "score": [
                0.6,
                0.5,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
    "filter2_prorec_aug_sum": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
    "filter2_prorec_aug2_sum": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
    "source_code": "static void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!VT_BUSY(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES) {\n\t\t\ttty_port_destroy(&vc[i]->port);\n\t\t\tkfree(vc[i]);\n\t\t}\n\t}\n}",
    "decom_sum": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Iterates over 62 entity slots, initializes eligible ones, and applies two spatial update routines with provided position and transformation parameters.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
    "filter2_prorec_aug_sum": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
    "filter2_prorec_aug2_sum": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
    "source_code": "\nvoid FAST_FUNC bb_herror_msg(const char *s, ...)\n{\n\tva_list p;\n\n\tva_start(p, s);\n\tbb_verror_msg(s, p, hstrerror(h_errno));\n\tva_end(p);\n}",
    "decom_sum": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes transformation parameters and forwards multiple SIMD vectors and scalars to `sub_5176F5` for computational processing using configuration from `sub_4B60D0` and `sub_4BABE0`.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and processes a list of string pattern handlers, invoking match and cleanup callbacks, then decrements reference count and frees resources if unused.",
    "filter2_prorec_aug_sum": "Processes a list of target objects, executing validation and cleanup operations, and returns success status or an error code if initialization fails.",
    "filter2_prorec_aug2_sum": "Performs string matching against multiple patterns using an external matcher, then cleans up matched resources and returns the match status.",
    "source_code": "int sysfs_merge_group(struct kobject *kobj,\n\t\t       const struct attribute_group *grp)\n{\n\tstruct sysfs_dirent *dir_sd;\n\tint error = 0;\n\tstruct attribute *const *attr;\n\tint i;\n\n\tdir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);\n\tif (!dir_sd)\n\t\treturn -ENOENT;\n\n\tfor ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))\n\t\terror = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);\n\tif (error) {\n\t\twhile (--i >= 0)\n\t\t\tsysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);\n\t}\n\tsysfs_put(dir_sd);\n\n\treturn error;\n}",
    "decom_sum": "Processes a list of target objects, executing validation and cleanup operations, and returns success status or an error code if initialization fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and processes a list of string pattern handlers, invoking match and cleanup callbacks, then decrements reference count and frees resources if unused.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes a list of target objects, executing validation and cleanup operations, and returns success status or an error code if initialization fails.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs string matching against multiple patterns using an external matcher, then cleans up matched resources and returns the match status.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Copies a memory range in 4KB chunks by mapping each page, copying data to the destination, and updating the source pointer and offset accordingly.",
    "filter2_prorec_aug_sum": "Copies data from the source address into page-aligned kernel memory chunks, updating the destination offset and enforcing strict address range limits.",
    "filter2_prorec_aug2_sum": "Copies a memory range from a source address to a destination, handling page boundaries and access validation, updating the start address pointer accordingly.",
    "source_code": "static int __kprobes write_mem(unsigned long val, unsigned long ea, int nb,\n\t\t\t       struct pt_regs *regs)\n{\n\tif (!address_ok(regs, ea, nb))\n\t\treturn -EFAULT;\n\tif ((ea & (nb - 1)) == 0)\n\t\treturn write_mem_aligned(val, ea, nb);\n\treturn write_mem_unaligned(val, ea, nb, regs);\n}",
    "decom_sum": "Copies data from the source address into page-aligned kernel memory chunks, updating the destination offset and enforcing strict address range limits.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Copies a memory range in 4KB chunks by mapping each page, copying data to the destination, and updating the source pointer and offset accordingly.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Copies data from the source address into page-aligned kernel memory chunks, updating the destination offset and enforcing strict address range limits.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Copies a memory range from a source address to a destination, handling page boundaries and access validation, updating the start address pointer accordingly.",
            "flag": false,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
    "filter2_prorec_aug_sum": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
    "filter2_prorec_aug2_sum": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
    "source_code": "\nstatic int __init i8042_create_aux_port(int idx)\n{\n\tstruct serio *serio;\n\tint port_no = idx < 0 ? I8042_AUX_PORT_NO : I8042_MUX_PORT_NO + idx;\n\tstruct i8042_port *port = &i8042_ports[port_no];\n\n\tserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\n\tif (!serio)\n\t\treturn -ENOMEM;\n\n\tserio->id.type\t\t= SERIO_8042;\n\tserio->write\t\t= i8042_aux_write;\n\tserio->start\t\t= i8042_start;\n\tserio->stop\t\t= i8042_stop;\n\tserio->port_data\t= port;\n\tserio->dev.parent\t= &i8042_platform_device->dev;\n\tif (idx < 0) {\n\t\tstrlcpy(serio->name, \"i8042 AUX port\", sizeof(serio->name));\n\t\tstrlcpy(serio->phys, I8042_AUX_PHYS_DESC, sizeof(serio->phys));\n\t\tserio->close = i8042_port_close;\n\t} else {\n\t\tsnprintf(serio->name, sizeof(serio->name), \"i8042 AUX%d port\", idx);\n\t\tsnprintf(serio->phys, sizeof(serio->phys), I8042_MUX_PHYS_DESC, idx + 1);\n\t}\n\n\tport->serio = serio;\n\tport->mux = idx;\n\tport->irq = I8042_AUX_IRQ;\n\n\treturn 0;\n}",
    "decom_sum": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and registers an i8042 AUX PS/2 port device structure with handlers, names, and global tables based on provided port index.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and prepares two buffers with alignment checks, processes them via sub_FFFFFFFF8125C660, then performs further operations with sub_FFFFFFFF8125B5F0 before returning a status.",
    "filter2_prorec_aug_sum": "Processes two memory-mapped data blocks retrieved via sub_FFFFFFFF8125FA30, performs computations on them with floating-point parameters, and updates both using sub_FFFFFFFF8125B5F0.",
    "filter2_prorec_aug2_sum": "Allocates and conditionally manages two buffers using input sizes and processes them through cryptographic-related functions with multiple floating-point parameters.",
    "source_code": "long keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_unlink(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "decom_sum": "Processes two memory-mapped data blocks retrieved via sub_FFFFFFFF8125FA30, performs computations on them with floating-point parameters, and updates both using sub_FFFFFFFF8125B5F0.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and prepares two buffers with alignment checks, processes them via sub_FFFFFFFF8125C660, then performs further operations with sub_FFFFFFFF8125B5F0 before returning a status.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes two memory-mapped data blocks retrieved via sub_FFFFFFFF8125FA30, performs computations on them with floating-point parameters, and updates both using sub_FFFFFFFF8125B5F0.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and conditionally manages two buffers using input sizes and processes them through cryptographic-related functions with multiple floating-point parameters.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
    "filter2_prorec_aug_sum": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
    "filter2_prorec_aug2_sum": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
    "source_code": "\nbool ssh2_common_filter_queue(PacketProtocolLayer *ppl)\n{\n    static const char *const ssh2_disconnect_reasons[] = {\n        NULL,\n        \"host not allowed to connect\",\n        \"protocol error\",\n        \"key exchange failed\",\n        \"host authentication failed\",\n        \"MAC error\",\n        \"compression error\",\n        \"service not available\",\n        \"protocol version not supported\",\n        \"host key not verifiable\",\n        \"connection lost\",\n        \"by application\",\n        \"too many connections\",\n        \"auth cancelled by user\",\n        \"no more auth methods available\",\n        \"illegal user name\",\n    };\n\n    PktIn *pktin;\n    ptrlen msg;\n    int reason;\n\n    while ((pktin = pq_peek(ppl->in_pq)) != NULL) {\n        switch (pktin->type) {\n          case SSH2_MSG_DISCONNECT:\n            reason = get_uint32(pktin);\n            msg = get_string(pktin);\n\n            ssh_remote_error(\n                ppl->ssh, \"Remote side sent disconnect message\\n\"\n                \"type %d (%s):\\n\\\"%.*s\\\"\", reason,\n                ((reason > 0 && reason < lenof(ssh2_disconnect_reasons)) ?\n                 ssh2_disconnect_reasons[reason] : \"unknown\"),\n                PTRLEN_PRINTF(msg));\n            /* don't try to pop the queue, because we've been freed! */\n            return true;               /* indicate that we've been freed */\n\n          case SSH2_MSG_DEBUG:\n            /* XXX maybe we should actually take notice of the return value */\n            get_bool(pktin);\n            msg = get_string(pktin);\n            ppl_logevent(\"Remote debug message: %.*s\", PTRLEN_PRINTF(msg));\n            pq_pop(ppl->in_pq);\n            break;\n\n          case SSH2_MSG_IGNORE:\n            /* Do nothing, because we're ignoring it! Duhh. */\n            pq_pop(ppl->in_pq);\n            break;\n\n          default:\n            return false;\n        }\n    }\n\n    return false;\n}",
    "decom_sum": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes commands from the object at a1+16, handling types 1, 2, and 4, and dispatches type-specific actions via sub_11CF or parameterized callbacks.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes a structure with three configuration calls, stores it in the context at offset 568, and cleans up on any initialization failure.",
    "filter2_prorec_aug_sum": "Initializes a data structure at a1 by invoking setup and validation routines with specified double parameters, storing the result pointer and resetting a status byte on success.",
    "filter2_prorec_aug2_sum": "Initializes a structure with three configuration calls, stores it in the context at offset 568, and cleans up on any initialization failure.",
    "source_code": "\nint __net_init fib4_rules_init(struct net *net)\n{\n\tint err;\n\tstruct fib_rules_ops *ops;\n\n\tops = fib_rules_register(&fib4_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rules_init(ops);\n\tif (err < 0)\n\t\tgoto fail;\n\tnet->ipv4.rules_ops = ops;\n\tnet->ipv4.fib_has_custom_rules = false;\n\treturn 0;\n\nfail:\n\t/* also cleans all rules already added */\n\tfib_rules_unregister(ops);\n\treturn err;\n}",
    "decom_sum": "Initializes a structure with three configuration calls, stores it in the context at offset 568, and cleans up on any initialization failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes a structure with three configuration calls, stores it in the context at offset 568, and cleans up on any initialization failure.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a data structure at a1 by invoking setup and validation routines with specified double parameters, storing the result pointer and resetting a status byte on success.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a structure with three configuration calls, stores it in the context at offset 568, and cleans up on any initialization failure.",
            "flag": true,
            "score": [
                0.3,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
    "filter2_prorec_aug_sum": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
    "filter2_prorec_aug2_sum": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
    "source_code": "static int whereLoopCheaperProperSubset(\n  const WhereLoop *pX,       /* First WhereLoop to compare */\n  const WhereLoop *pY        /* Compare against this WhereLoop */\n){\n  int i, j;\n  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){\n    return 0; /* X is not a subset of Y */\n  }\n  if( pY->nSkip > pX->nSkip ) return 0;\n  if( pX->rRun >= pY->rRun ){\n    if( pX->rRun > pY->rRun ) return 0;    /* X costs more than Y */\n    if( pX->nOut > pY->nOut ) return 0;    /* X costs more than Y */\n  }\n  for(i=pX->nLTerm-1; i>=0; i--){\n    if( pX->aLTerm[i]==0 ) continue;\n    for(j=pY->nLTerm-1; j>=0; j--){\n      if( pY->aLTerm[j]==pX->aLTerm[i] ) break;\n    }\n    if( j<0 ) return 0;  /* X not a subset of Y since term X[i] not used by Y */\n  }\n  return 1;  /* All conditions meet */\n}",
    "decom_sum": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates coordinate ranges and checks matching 64-bit entries between two indexed tables, returning success if all required positions match expected reference values.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes or resets entries in a global array by invoking sub_FFFFFFFF812FBA00, and on exhaustion, allocates and zeroes multiple _WORD buffers before final setup calls.",
    "filter2_prorec_aug_sum": "Initializes and caches hardware capability structures by repeatedly attempting setup, allocating resources on failure, and finalizing with configuration calls.",
    "filter2_prorec_aug2_sum": "Initializes and allocates multiple hardware-related data buffers, populates tracking structures, and invokes processing routines until successful or returning an error code.",
    "source_code": "\nacpi_status acpi_ut_mutex_initialize(void)\n{\n\tu32 i;\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ut_mutex_initialize);\n\n\t/* Create each of the predefined mutex objects */\n\n\tfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\n\t\tstatus = acpi_ut_create_mutex(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\treturn_ACPI_STATUS(status);\n\t\t}\n\t}\n\n\t/* Create the spinlocks for use at interrupt level or for speed */\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_gpe_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock (&acpi_gbl_hardware_lock);\n\tif (ACPI_FAILURE (status)) {\n\t\treturn_ACPI_STATUS (status);\n\t}\n\n\tstatus = acpi_os_create_lock(&acpi_gbl_reference_count_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Mutex for _OSI support */\n\n\tstatus = acpi_os_create_mutex(&acpi_gbl_osi_mutex);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Create the reader/writer lock for namespace access */\n\n\tstatus = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);\n\treturn_ACPI_STATUS(status);\n}",
    "decom_sum": "Initializes and allocates multiple hardware-related data buffers, populates tracking structures, and invokes processing routines until successful or returning an error code.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes or resets entries in a global array by invoking sub_FFFFFFFF812FBA00, and on exhaustion, allocates and zeroes multiple _WORD buffers before final setup calls.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes and caches hardware capability structures by repeatedly attempting setup, allocating resources on failure, and finalizing with configuration calls.",
            "flag": false,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes and allocates multiple hardware-related data buffers, populates tracking structures, and invokes processing routines until successful or returning an error code.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
    "filter2_prorec_aug_sum": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
    "filter2_prorec_aug2_sum": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
    "source_code": "void __key_link(struct key *keyring, struct key *key,\n\t\tunsigned long *_prealloc)\n{\n\tstruct keyring_list *klist, *nklist;\n\tstruct key *discard;\n\n\tnklist = (struct keyring_list *)(*_prealloc & ~KEY_LINK_FIXQUOTA);\n\t*_prealloc = 0;\n\n\tkenter(\"%d,%d,%p\", keyring->serial, key->serial, nklist);\n\n\tklist = rcu_dereference_locked_keyring(keyring);\n\n\tatomic_inc(&key->usage);\n\tkeyring->last_used_at = key->last_used_at =\n\t\tcurrent_kernel_time().tv_sec;\n\n\t/* there's a matching key we can displace or an empty slot in a newly\n\t * allocated list we can fill */\n\tif (nklist) {\n\t\tkdebug(\"reissue %hu/%hu/%hu\",\n\t\t       nklist->delkey, nklist->nkeys, nklist->maxkeys);\n\n\t\tRCU_INIT_POINTER(nklist->keys[nklist->delkey], key);\n\n\t\trcu_assign_pointer(keyring->payload.subscriptions, nklist);\n\n\t\t/* dispose of the old keyring list and, if there was one, the\n\t\t * displaced key */\n\t\tif (klist) {\n\t\t\tkdebug(\"dispose %hu/%hu/%hu\",\n\t\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\t\t\tcall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\n\t\t}\n\t} else if (klist->delkey < klist->nkeys) {\n\t\tkdebug(\"replace %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tdiscard = rcu_dereference_protected(\n\t\t\tklist->keys[klist->delkey],\n\t\t\trwsem_is_locked(&keyring->sem));\n\t\trcu_assign_pointer(klist->keys[klist->delkey], key);\n\t\t/* The garbage collector will take care of RCU\n\t\t * synchronisation */\n\t\tkey_put(discard);\n\t} else {\n\t\t/* there's sufficient slack space to append directly */\n\t\tkdebug(\"append %hu/%hu/%hu\",\n\t\t       klist->delkey, klist->nkeys, klist->maxkeys);\n\n\t\tRCU_INIT_POINTER(klist->keys[klist->delkey], key);\n\t\tsmp_wmb();\n\t\tklist->nkeys++;\n\t}\n}",
    "decom_sum": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Links or reassigns an object into a container structure, updating reference counts and triggering callbacks or processing with provided floating-point parameters.",
            "flag": true,
            "score": [
                0.2,
                0.3,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks for socket readiness to read one byte without blocking; on error or special flags, it cleans up connection and updates linked lists accordingly.",
    "filter2_prorec_aug_sum": "Checks for non-blocking socket readability, and on error or readiness, cleans up resources, closes the connection, and updates linked connection queues.",
    "filter2_prorec_aug2_sum": "Checks socket readability, handles errors by destroying the pool, closing the connection, and updating linked connection queues accordingly.",
    "source_code": "\n\nstatic void\nngx_http_upstream_keepalive_close_handler(ngx_event_t *ev)\n{\n    ngx_http_upstream_keepalive_srv_conf_t  *conf;\n    ngx_http_upstream_keepalive_cache_t     *item;\n\n    int                n;\n    char               buf[1];\n    ngx_connection_t  *c;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0,\n                   \"keepalive close handler\");\n\n    c = ev->data;\n\n    if (c->close || c->read->timedout) {\n        goto close;\n    }\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    if (n == -1 && ngx_socket_errno == NGX_EAGAIN) {\n        ev->ready = 0;\n\n        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n            goto close;\n        }\n\n        return;\n    }\n\nclose:\n\n    item = c->data;\n    conf = item->conf;\n\n    ngx_http_upstream_keepalive_close(c);\n\n    ngx_queue_remove(&item->queue);\n    ngx_queue_insert_head(&conf->free, &item->queue);\n}",
    "decom_sum": "Closes a network connection and cleans associated resources when socket readiness or error conditions indicate the connection should be terminated.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks for socket readiness to read one byte without blocking; on error or special flags, it cleans up connection and updates linked lists accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks for non-blocking socket readability, and on error or readiness, cleans up resources, closes the connection, and updates linked connection queues.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks socket readability, handles errors by destroying the pool, closing the connection, and updating linked connection queues accordingly.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
    "filter2_prorec_aug_sum": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
    "filter2_prorec_aug2_sum": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
    "source_code": "\nstatic void\nshow_arch (FILE *stream, int ext, int check)\n{\n  static char message[] = MESSAGE_TEMPLATE;\n  char *start = message + 27;\n  char *p;\n  int size = sizeof (MESSAGE_TEMPLATE);\n  int left;\n  const char *name;\n  int len;\n  unsigned int j;\n\n  p = start;\n  left = size - (start - message);\n  for (j = 0; j < ARRAY_SIZE (cpu_arch); j++)\n    {\n      /* Should it be skipped?  */\n      if (cpu_arch [j].skip)\n\tcontinue;\n\n      name = cpu_arch [j].name;\n      len = cpu_arch [j].len;\n      if (*name == '.')\n\t{\n\t  /* It is an extension.  Skip if we aren't asked to show it.  */\n\t  if (ext)\n\t    {\n\t      name++;\n\t      len--;\n\t    }\n\t  else\n\t    continue;\n\t}\n      else if (ext)\n\t{\n\t  /* It is an processor.  Skip if we show only extension.  */\n\t  continue;\n\t}\n      else if (check && ! cpu_arch[j].flags.bitfield.cpui386)\n\t{\n\t  /* It is an impossible processor - skip.  */\n\t  continue;\n\t}\n\n      p = output_message (stream, p, message, start, &left, name, len);\n    }\n\n  /* Display disabled extensions.  */\n  if (ext)\n    for (j = 0; j < ARRAY_SIZE (cpu_noarch); j++)\n      {\n\tname = cpu_noarch [j].name;\n\tlen = cpu_noarch [j].len;\n\tp = output_message (stream, p, message, start, &left, name,\n\t\t\t    len);\n      }\n\n  *p = '\\0';\n  fprintf (stream, \"%s\\n\", message);\n}",
    "decom_sum": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Formats and writes a composite string to the output stream by processing predefined token tables and appending conditionally selected entries, then outputs with a newline.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
    "filter2_prorec_aug_sum": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
    "filter2_prorec_aug2_sum": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
    "source_code": "\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  Image\n    *image;\n\n  long\n    length;\n\n  register long\n    i;\n\n  unsigned char\n    *profile;\n\n  /*\n    Determine length of color profile.\n  */\n  length=(long) GetCharacter(jpeg_info) << 8;\n  length+=(long) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (--length >= 0)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,\"ICC_PROFILE\") != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < length-12; i++)\n        (void) GetCharacter(jpeg_info);\n      return(True);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n\n  /*\n    Read color profile.\n  */\n  profile=error_manager->buffer;\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                        \"ICC profile chunk: %ld bytes\",\n    length);\n\n  for (i=0 ; i < length; i++)\n   profile[i]=GetCharacter(jpeg_info);\n\n  (void) AppendImageProfile(image,\"ICM\",profile,length);\n\n  return(True);\n}",
    "decom_sum": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses JPEG application marker data and extracts embedded ICC color profile bytes, passing them to the ICM handler for processing.",
            "flag": true,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Converts a linear permutation representation into its canonical form, verifying size equality and storing the canonical permutation in the provided output structure.",
    "filter2_prorec_aug_sum": "Converts a linear permutation representation into its canonical form by reorganizing elements according to cycle structure, verifying size consistency between inputs.",
    "filter2_prorec_aug2_sum": "Converts an input linear permutation into its canonical form by traversing and rearranging permutation cycles into a standard representation stored in the output array.",
    "source_code": "\nint\ngsl_permutation_linear_to_canonical (gsl_permutation * q,\n                                     const gsl_permutation * p)\n{\n  const size_t n = p->size;\n  size_t i, k, s;\n  size_t t = n;\n\n  const size_t *const pp = p->data;\n  size_t *const qq = q->data;\n\n  if (q->size != p->size)\n    {\n      GSL_ERROR (\"size of q does not match size of p\", GSL_EINVAL);\n    }\n\n  for (i = 0; i < n; i++)\n    {\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          k = pp[k];\n          s++;\n        }\n\n      if (k < i)\n        continue;\n\n      /* Now have k == i, i.e the least in its cycle, and s == cycle length */\n\n      t -= s;\n\n      qq[t] = i;\n\n      k = pp[i];\n      s = 1;\n\n      while (k > i)\n        {\n          qq[t + s] = k;\n          k = pp[k];\n          s++;\n        }\n\n      if (t == 0)\n        break;\n    }\n\n  return GSL_SUCCESS;\n}",
    "decom_sum": "Converts a linear permutation array into its canonical cycle representation after verifying equal sizes, else reports a size mismatch error.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Converts a linear permutation representation into its canonical form, verifying size equality and storing the canonical permutation in the provided output structure.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Converts a linear permutation representation into its canonical form by reorganizing elements according to cycle structure, verifying size consistency between inputs.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Converts an input linear permutation into its canonical form by traversing and rearranging permutation cycles into a standard representation stored in the output array.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
    "filter2_prorec_aug_sum": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
    "filter2_prorec_aug2_sum": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
    "source_code": "\nstatic int slave_update(struct link_slave *slave)\n{\n\tstruct snd_ctl_elem_value *uctl;\n\tint err, ch;\n\n\tuctl = kmalloc(sizeof(*uctl), GFP_KERNEL);\n\tif (!uctl)\n\t\treturn -ENOMEM;\n\tuctl->id = slave->slave.id;\n\terr = slave->slave.get(&slave->slave, uctl);\n\tfor (ch = 0; ch < slave->info.count; ch++)\n\t\tslave->vals[ch] = uctl->value.integer.value[ch];\n\tkfree(uctl);\n\treturn 0;\n}",
    "decom_sum": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes a 0xD0-byte structure with fields from `a1`, invokes its callback, updates state variables, and processes it with `sub_FFFFFFFF8112DCD0`.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates input arguments and types, then constructs an argument list and invokes sub_ACE0 with extracted parameters for alias processing.",
    "filter2_prorec_aug_sum": "Validates an alias statement's arguments, extracts and converts each argument, then calls sub_ACE0 with the alias name, argument count, argument array, and a provided vector.",
    "filter2_prorec_aug2_sum": "Validates alias arguments count and types, extracts and converts them, then invokes a handler function with these processed arguments and context.",
    "source_code": "\n\f\nint\nalias_cb(enum grecs_callback_command cmd,\n\t grecs_locus_t *locus,\n\t void *varptr,\n\t grecs_value_t *value,\n\t void *cb_data)\n{\n    char **argv;\n    int argc;\n    int i;\n\n    if (cmd != grecs_callback_set_value) {\n\tgrecs_error(locus, 0, _(\"Unexpected block statement\"));\n\treturn 1;\n    }\n    if (value->type != GRECS_TYPE_ARRAY) {\n\tgrecs_error(locus, 0, _(\"Not enough arguments for alias\"));\n\treturn 1;\n    }\n    argc = value->v.arg.c - 1;\n    argv = xcalloc(argc + 1, sizeof(argv[0]));\n    for (i = 0; i < argc; i++) {\n\tif (value->v.arg.v[i+1]->type != GRECS_TYPE_STRING) {\n\t    grecs_error(locus, 0, _(\"argument %d has wrong type\"), i+1);\n\t    return 1;\n\t}\n\targv[i] = xstrdup(value->v.arg.v[i+1]->v.string);\n    }\n    argv[i] = NULL;\n    return alias_install(value->v.arg.v[0]->v.string, argc, argv, locus);\n}",
    "decom_sum": "Validates alias command arguments, converts them to string array, and invokes sub_ACE0 with the alias name, argument count, and provided context.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates input arguments and types, then constructs an argument list and invokes sub_ACE0 with extracted parameters for alias processing.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates an alias statement's arguments, extracts and converts each argument, then calls sub_ACE0 with the alias name, argument count, argument array, and a provided vector.",
            "flag": false,
            "score": [
                0.6,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates alias arguments count and types, extracts and converts them, then invokes a handler function with these processed arguments and context.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
    "filter2_prorec_aug_sum": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
    "filter2_prorec_aug2_sum": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
    "source_code": "static int\nis_hidden_fd(struct redirtab *rp, int fd)\n{\n\tint i;\n\tstruct parsefile *pf;\n\n\tif (fd == -1)\n\t\treturn 0;\n\t/* Check open scripts' fds */\n\tpf = g_parsefile;\n\twhile (pf) {\n\t\t/* We skip pf_fd == 0 case because of the following case:\n\t\t * $ ash  # running ash interactively\n\t\t * $ . ./script.sh\n\t\t * and in script.sh: \"exec 9>&0\".\n\t\t * Even though top-level pf_fd _is_ 0,\n\t\t * it's still ok to use it: \"read\" builtin uses it,\n\t\t * why should we cripple \"exec\" builtin?\n\t\t */\n\t\tif (pf->pf_fd > 0 && fd == pf->pf_fd) {\n\t\t\treturn 1;\n\t\t}\n\t\tpf = pf->prev;\n\t}\n\n\tif (!rp)\n\t\treturn 0;\n\t/* Check saved fds of redirects */\n\tfd |= COPYFD_RESTORE;\n\tfor (i = 0; i < rp->pair_count; i++) {\n\t\tif (rp->two_fd[i].copy == fd) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "decom_sum": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
            "flag": true,
            "score": [
                0.2,
                0.1,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Checks if the given integer ID exists and is valid in a global linked list or in the ID array of the specified object.",
            "flag": true,
            "score": [
                0.2,
                0.1,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Disables the ironlake eDP panel power by logging, verifying VDD state, configuring hardware registers, and waiting for the panel power-off interval.",
    "filter2_prorec_aug_sum": "Disables the eDP panel power on Ironlake hardware, ensuring VDD is active, updating power state, waiting for power-off delay, and writing power-off commands.",
    "filter2_prorec_aug2_sum": "Turns off the Intel Ironlake eDP panel by disabling power, waiting the required off time, and updating hardware state registers accordingly.",
    "source_code": "\nvoid ironlake_edp_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_device *dev = intel_dp_to_dev(intel_dp);\n\tstruct drm_i915_private *dev_priv = dev->dev_private;\n\tu32 pp;\n\tu32 pp_ctrl_reg;\n\n\tif (!is_edp(intel_dp))\n\t\treturn;\n\n\tDRM_DEBUG_KMS(\"Turn eDP power off\\n\");\n\n\tWARN(!intel_dp->want_panel_vdd, \"Need VDD to turn off panel\\n\");\n\n\tpp = ironlake_get_pp_control(intel_dp);\n\t/* We need to switch off panel power _and_ force vdd, for otherwise some\n\t * panels get very unhappy and cease to work. */\n\tpp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = IS_VALLEYVIEW(dev) ? PIPEA_PP_CONTROL : PCH_PP_CONTROL;\n\n\tI915_WRITE(pp_ctrl_reg, pp);\n\tPOSTING_READ(pp_ctrl_reg);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tironlake_wait_panel_off(intel_dp);\n}",
    "decom_sum": "Turns off an Intel Ironlake eDP panel, logs actions, updates power state flags, and waits for the required panel power-off time.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Disables the ironlake eDP panel power by logging, verifying VDD state, configuring hardware registers, and waiting for the panel power-off interval.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Disables the eDP panel power on Ironlake hardware, ensuring VDD is active, updating power state, waiting for power-off delay, and writing power-off commands.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Turns off the Intel Ironlake eDP panel by disabling power, waiting the required off time, and updating hardware state registers accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
    "filter2_prorec_aug_sum": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
    "filter2_prorec_aug2_sum": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
    "source_code": "\nstatic void die_if_script(unsigned lineno, const char *fmt, ...)\n{\n\tva_list p;\n\n#if HUSH_DEBUG >= 2\n\tbb_error_msg(\"hush.c:%u\", lineno);\n#endif\n\tva_start(p, fmt);\n\tbb_verror_msg(fmt, p, NULL);\n\tva_end(p);\n\tif (!G_interactive_fd)\n\t\txfunc_die();\n}",
    "decom_sum": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Packages input parameters and SIMD vectors, calls sub_5176F5 to process them, and triggers sub_517B39 if a global status flag is unset.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes a structure from input parameters, performs a callback-based processing routine, and conditionally triggers further processing with floating-point values.",
    "filter2_prorec_aug_sum": "Initializes a resource context from input parameters, performs a conditional operation with a callback, and optionally triggers a complex processing routine based on intermediate results.",
    "filter2_prorec_aug2_sum": "Initializes a module with provided parameters, validates input ranges, sets up internal structures, and conditionally triggers a processing routine with given floating-point arguments.",
    "source_code": "\nasmlinkage long compat_sys_getdents64(unsigned int fd,\n\t\tstruct linux_dirent64 __user * dirent, unsigned int count)\n{\n\tstruct fd f;\n\tstruct linux_dirent64 __user * lastdirent;\n\tstruct compat_getdents_callback64 buf;\n\tint error;\n\n\tif (!access_ok(VERIFY_WRITE, dirent, count))\n\t\treturn -EFAULT;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tbuf.current_dir = dirent;\n\tbuf.previous = NULL;\n\tbuf.count = count;\n\tbuf.error = 0;\n\n\terror = vfs_readdir(f.file, compat_filldir64, &buf);\n\tif (error >= 0)\n\t\terror = buf.error;\n\tlastdirent = buf.previous;\n\tif (lastdirent) {\n\t\ttypeof(lastdirent->d_off) d_off = f.file->f_pos;\n\t\tif (__put_user_unaligned(d_off, &lastdirent->d_off))\n\t\t\terror = -EFAULT;\n\t\telse\n\t\t\terror = count - buf.count;\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "decom_sum": "Initializes a context from input parameters, registers a callback, and processes data with optional extended computation before returning a status code.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes a structure from input parameters, performs a callback-based processing routine, and conditionally triggers further processing with floating-point values.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a resource context from input parameters, performs a conditional operation with a callback, and optionally triggers a complex processing routine based on intermediate results.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a module with provided parameters, validates input ranges, sets up internal structures, and conditionally triggers a processing routine with given floating-point arguments.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates vector sizes based on code and calls a function pointer to compute derivatives, returning error 19 on size mismatch.",
    "filter2_prorec_aug_sum": "Validates input vector sizes for a specified evaluation type and calls the associated function pointer, reporting errors on size mismatches and updating evaluation counters.",
    "filter2_prorec_aug2_sum": "Validates vector sizes based on mode and calls a function pointer to evaluate function, gradient, and Hessian with optional vector and JTJ matrix inputs.",
    "source_code": "\nint\ngsl_multilarge_nlinear_eval_df(const CBLAS_TRANSPOSE_t TransJ,\n                               const gsl_vector *x,\n                               const gsl_vector *f,\n                               const gsl_vector *u,\n                               const gsl_vector *swts,\n                               const double h,\n                               const gsl_multilarge_nlinear_fdtype fdtype,\n                               gsl_multilarge_nlinear_fdf *fdf,\n                               gsl_vector *v,\n                               gsl_matrix *JTJ,\n                               gsl_vector *work)\n{\n  const size_t n = fdf->n;\n  const size_t p = fdf->p;\n\n  if (u != NULL && ((TransJ == CblasNoTrans && u->size != p) ||\n                    (TransJ == CblasTrans && u->size != n)))\n    {\n      GSL_ERROR(\"u vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (v != NULL && ((TransJ == CblasNoTrans && v->size != n) ||\n                         (TransJ == CblasTrans && v->size != p)))\n    {\n      GSL_ERROR(\"v vector has wrong size\", GSL_EBADLEN);\n    }\n  else if (JTJ != NULL && ((JTJ->size1 != p) || (JTJ->size2 != p)))\n    {\n      GSL_ERROR(\"JTJ matrix has wrong size\", GSL_EBADLEN);\n    }\n  else\n    {\n      int status;\n\n      if (fdf->df)\n        {\n          /* call user-supplied function */\n          status = ((*((fdf)->df)) (TransJ, x, u, fdf->params, v, JTJ));\n\n          if (v)\n            ++(fdf->nevaldfu);\n\n          if (JTJ)\n            ++(fdf->nevaldf2);\n        }\n      else\n        {\n#if 0\n          /* use finite difference Jacobian approximation */\n          status = gsl_multilarge_nlinear_df(h, fdtype, x, swts, fdf, f, df, work);\n#endif\n        }\n\n      return status;\n    }\n}",
    "decom_sum": "Validates vector and matrix dimensions for nonlinear large-scale evaluation, then calls the callback function and updates evaluation counters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates vector sizes based on code and calls a function pointer to compute derivatives, returning error 19 on size mismatch.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates input vector sizes for a specified evaluation type and calls the associated function pointer, reporting errors on size mismatches and updating evaluation counters.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates vector sizes based on mode and calls a function pointer to evaluate function, gradient, and Hessian with optional vector and JTJ matrix inputs.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
    "filter2_prorec_aug_sum": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
    "filter2_prorec_aug2_sum": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
    "source_code": "\nvoid\njitter_hash_table_add (struct jitter_hash_table *t,\n                       const union jitter_word key,\n                       const union jitter_word value,\n                       jitter_hash_function f)\n{\n  /* We only enlarge the table (when it's getting too full) on add, and never\n     shrink it. */\n  if (jitter_hash_table_overfull (t))\n    jitter_hash_table_enlarge (t, f);\n\n  t->binding_no ++;\n  jitter_uint bucket_index = f (key) % t->bucket_no;\n\n  /* Find the bucket; make it if needed. */\n  struct jitter_hash_bucket *b = t->buckets [bucket_index];\n  if (b == NULL)\n    {\n      b = jitter_xmalloc (sizeof (struct jitter_hash_bucket));\n      b->allocated_binding_no = INITIAL_BINDING_NO_PER_BUCKET;\n      b->used_binding_no = 0;\n      b->bindings\n        = jitter_xmalloc (sizeof (struct jitter_hash_binding)\n                          * INITIAL_BINDING_NO_PER_BUCKET);\n      t->buckets [bucket_index] = b;\n    }\n\n  /* Find the binding where we need to write within the bucket; make place and\n     reallocate if needed. */\n  if (b->used_binding_no == b->allocated_binding_no)\n    {\n      //printf (\"enlarging the %i-th bucket: %li to %li\\n\", (int)bucket_index, (long)b->allocated_binding_no, (long)(b->allocated_binding_no * 2));\n\n      b->bindings = jitter_xrealloc (b->bindings,\n                                     sizeof (struct jitter_hash_binding)\n                                     * (b->allocated_binding_no *= 2));\n    }\n  struct jitter_hash_binding *bi = b->bindings + (b->used_binding_no ++);\n  bi->key = key;\n  bi->value = value;\n}",
    "decom_sum": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Inserts a key\u2013value pair into a hash table with dynamic bucket allocation, resizing and linked entry creation based on a hash of the key.",
            "flag": true,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
    "filter2_prorec_aug_sum": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
    "filter2_prorec_aug2_sum": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
    "source_code": "\n\nvoid generate_file_priorities(struct dir_info *dir, int priority,\n\tstruct stat *buf)\n{\n\tstruct dir_ent *dir_ent = dir->list;\n\n\tpriority = get_priority(dir->pathname, buf, priority);\n\n\tfor(; dir_ent; dir_ent = dir_ent->next) {\n\t\tstruct stat *buf = &dir_ent->inode->buf;\n\t\tif(dir_ent->inode->root_entry)\n\t\t\tcontinue;\n\n\t\tswitch(buf->st_mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tadd_priority_list(dir_ent,\n\t\t\t\t\tget_priority(pathname(dir_ent), buf,\n\t\t\t\t\tpriority));\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tgenerate_file_priorities(dir_ent->dir,\n\t\t\t\t\tpriority, buf);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "decom_sum": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Traverses hierarchical data structures, resolves IDs via `qword_829940`, and invokes handlers `sub_16B70` or `sub_16660` based on node type and flags.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes or retrieves a data structure using conditionally chosen subroutines based on internal flags and updates status fields accordingly.",
    "filter2_prorec_aug_sum": "Initializes or updates a hardware/resource handle based on stored state, creating it if absent, and records readiness status for subsequent operations.",
    "filter2_prorec_aug2_sum": "Initializes or refreshes a resource handle in a data structure by conditionally opening or updating related sub-handles based on internal state flags and parameters.",
    "source_code": "void ZSTDMT_compressChunk(void* jobDescription)\n{\n    ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;\n    const void* const src = (const char*)job->srcStart + job->dictSize;\n    buffer_t const dstBuff = job->dstBuff;\n    DEBUGLOG(3, \"job (first:%u) (last:%u) : dictSize %u, srcSize %u\", job->firstChunk, job->lastChunk, (U32)job->dictSize, (U32)job->srcSize);\n    if (job->cdict) {\n        size_t const initError = ZSTD_compressBegin_usingCDict(job->cctx, job->cdict, job->fullFrameSize);\n        if (job->cdict) DEBUGLOG(3, \"using CDict \");\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n    } else {\n        size_t const initError = ZSTD_compressBegin_advanced(job->cctx, job->srcStart, job->dictSize, job->params, job->fullFrameSize);\n        if (ZSTD_isError(initError)) { job->cSize = initError; goto _endJob; }\n        ZSTD_setCCtxParameter(job->cctx, ZSTD_p_forceWindow, 1);\n    }\n    if (!job->firstChunk) {  /* flush frame header */\n        size_t const hSize = ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, 0);\n        if (ZSTD_isError(hSize)) { job->cSize = hSize; goto _endJob; }\n        ZSTD_invalidateRepCodes(job->cctx);\n    }\n\n    DEBUGLOG(4, \"Compressing : \");\n    DEBUG_PRINTHEX(4, job->srcStart, 12);\n    job->cSize = (job->lastChunk) ?   /* last chunk signal */\n                 ZSTD_compressEnd     (job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize) :\n                 ZSTD_compressContinue(job->cctx, dstBuff.start, dstBuff.size, src, job->srcSize);\n    DEBUGLOG(3, \"compressed %u bytes into %u bytes   (first:%u) (last:%u)\", (unsigned)job->srcSize, (unsigned)job->cSize, job->firstChunk, job->lastChunk);\n\n_endJob:\n    PTHREAD_MUTEX_LOCK(job->jobCompleted_mutex);\n    job->jobCompleted = 1;\n    job->jobScanned = 0;\n    pthread_cond_signal(job->jobCompleted_cond);\n    pthread_mutex_unlock(job->jobCompleted_mutex);\n}",
    "decom_sum": "Initializes or updates a hardware/resource handle based on stored state, creating it if absent, and records readiness status for subsequent operations.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes or retrieves a data structure using conditionally chosen subroutines based on internal flags and updates status fields accordingly.",
            "flag": false,
            "score": [
                0.7,
                0.3,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes or updates a hardware/resource handle based on stored state, creating it if absent, and records readiness status for subsequent operations.",
            "flag": true,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes or refreshes a resource handle in a data structure by conditionally opening or updating related sub-handles based on internal state flags and parameters.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Retrieves the R home directory path, constructs and returns a single-element R character vector containing that path, raising an error if retrieval fails.",
    "filter2_prorec_aug_sum": "Retrieves the R home directory path, allocates a length-1 character vector, and stores the R home path as its single string element.",
    "filter2_prorec_aug2_sum": "Retrieves the R home directory path, allocates a character vector, stores the path as a string element, and returns it as an R vector object.",
    "source_code": "\nSEXP attribute_hidden do_Rhome(SEXP call, SEXP op, SEXP args, SEXP rho)\n{\n    char *path;\n    checkArity(op, args);\n    if (!(path = R_HomeDir()))\n\terror(_(\"unable to determine R home location\"));\n    return mkString(path);\n}",
    "decom_sum": "Creates a protected R string vector containing the R home directory path and returns it after ensuring stack integrity and proper memory allocation.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Retrieves the R home directory path, constructs and returns a single-element R character vector containing that path, raising an error if retrieval fails.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.9
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Retrieves the R home directory path, allocates a length-1 character vector, and stores the R home path as its single string element.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Retrieves the R home directory path, allocates a character vector, stores the path as a string element, and returns it as an R vector object.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Calculates and updates specific offsets in the structure at a2 based on flags and values extracted from bitfields at a1, calling a helper for conditional value retrieval.",
    "filter2_prorec_aug_sum": "Updates two counters at offsets 72 or 80 in `a2` by computing differences between function call results influenced by flags extracted from `a1+120` bitfields.",
    "filter2_prorec_aug2_sum": "Calculates adjusted values based on flags in a1, calls sub_FFFFFFFF81593DC0 for counts, and updates counters at offsets 72 or 80 in a2 accordingly.",
    "source_code": "int snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\n\thda_nid_t nid = get_amp_nid(kcontrol);\n\tint chs = get_amp_channels(kcontrol);\n\tint dir = get_amp_direction(kcontrol);\n\tint idx = get_amp_index(kcontrol);\n\tunsigned int ofs = get_amp_offset(kcontrol);\n\tlong *valp = ucontrol->value.integer.value;\n\n\tif (chs & 1)\n\t\t*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\n\tif (chs & 2)\n\t\t*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\n\treturn 0;\n}",
    "decom_sum": "Computes adjusted 7\u2011bit values from hardware register bits using sub_FFFFFFFF81593DC0 and stores results into specific offsets within the target structure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Calculates and updates specific offsets in the structure at a2 based on flags and values extracted from bitfields at a1, calling a helper for conditional value retrieval.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Updates two counters at offsets 72 or 80 in `a2` by computing differences between function call results influenced by flags extracted from `a1+120` bitfields.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Calculates adjusted values based on flags in a1, calls sub_FFFFFFFF81593DC0 for counts, and updates counters at offsets 72 or 80 in a2 accordingly.",
            "flag": false,
            "score": [
                0.0,
                0.1,
                0.1
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
    "filter2_prorec_aug_sum": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
    "filter2_prorec_aug2_sum": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
    "source_code": "\nstatic struct demangle_component *\nd_make_comp (struct d_info *di, enum demangle_component_type type,\n             struct demangle_component *left,\n             struct demangle_component *right)\n{\n  struct demangle_component *p;\n\n  /* We check for errors here.  A typical error would be a NULL return\n     from a subroutine.  We catch those here, and return NULL\n     upward.  */\n  switch (type)\n    {\n      /* These types require two parameters.  */\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_CLONE:\n      if (left == NULL || right == NULL)\n\treturn NULL;\n      break;\n\n      /* These types only require one parameter.  */\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      if (left == NULL)\n\treturn NULL;\n      break;\n\n      /* This needs a right parameter, but the left parameter can be\n\t empty.  */\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      if (right == NULL)\n\treturn NULL;\n      break;\n\n      /* These are allowed to have no parameters--in some cases they\n\t will be filled in later.  */\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    FNQUAL_COMPONENT_CASE:\n      break;\n\n      /* Other types should not be seen here.  */\n    default:\n      return NULL;\n    }\n\n  p = d_make_empty (di);\n  if (p != NULL)\n    {\n      p->type = type;\n      p->u.s_binary.left = left;\n      p->u.s_binary.right = right;\n    }\n  return p;\n}",
    "decom_sum": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Appends a new event entry with type, parameters, and validation to an internal fixed-size queue based on specific `a2` opcode and argument checks.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses and unquotes a backslash-escaped input byte array, converting escape sequences into corresponding characters, and stores the result in a separate output buffer.",
    "filter2_prorec_aug_sum": "Processes a byte array by unescaping backslash-escaped characters using mu_wordsplit_c_unquote_char and updates input pointers with processed lengths.",
    "filter2_prorec_aug2_sum": "Decodes escape sequences in input buffer *a3, replacing backslash escapes with their unquoted characters, updating input and output lengths accordingly.",
    "source_code": "static enum mu_filter_result\n_c_escape_decoder (void *xd MU_ARG_UNUSED,\n\t\t   enum mu_filter_command cmd,\n\t\t   struct mu_filter_io *iobuf)\n{\n  size_t i, j;\n  const unsigned char *iptr;\n  size_t isize;\n  char *optr;\n  size_t osize;\n  \n  switch (cmd)\n    {\n    case mu_filter_init:\n    case mu_filter_done:\n      return mu_filter_ok;\n    default:\n      break;\n    }\n  \n  iptr = (const unsigned char *) iobuf->input;\n  isize = iobuf->isize;\n  optr = iobuf->output;\n  osize = iobuf->osize;\n\n  for (i = j = 0; i < isize && j < osize; i++)\n    {\n      unsigned char c = *iptr++;\n      if (c == '\\\\')\n\t{\n\t  int x;\n\t  if (i + 1 == isize)\n\t    break;\n\t  c = *iptr++;\n\t  i++;\n\t  x = mu_wordsplit_c_unquote_char (c);\n\t  optr[j++] = (x == -1) ? c : x;\n\t}\n      else\n\toptr[j++] = c;\n    }\n\n  iobuf->isize = i;\n  iobuf->osize = j;\n  return mu_filter_ok;\n}",
    "decom_sum": "Parses input bytes into an output buffer, handling backslash escape sequences via `mu_wordsplit_c_unquote_char` and updating processed input and output counters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses and unquotes a backslash-escaped input byte array, converting escape sequences into corresponding characters, and stores the result in a separate output buffer.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes a byte array by unescaping backslash-escaped characters using mu_wordsplit_c_unquote_char and updates input pointers with processed lengths.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Decodes escape sequences in input buffer *a3, replacing backslash escapes with their unquoted characters, updating input and output lengths accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Reads the entire content of the specified file into a newly allocated, null-terminated buffer, returning the buffer pointer and read size.",
    "filter2_prorec_aug_sum": "Reads an entire file into a newly allocated null-terminated buffer, returning its size and pointer, with error handling for open, stat, and read failures.",
    "filter2_prorec_aug2_sum": "Reads the entire contents of a file into a newly allocated buffer, null-terminates it, and returns the buffer and its size through output parameters.",
    "source_code": "int\nevutil_read_file_(const char *filename, char **content_out, size_t *len_out,\n    int is_binary)\n{\n\tint fd, r;\n\tstruct stat st;\n\tchar *mem;\n\tsize_t read_so_far=0;\n\tint mode = O_RDONLY;\n\n\tEVUTIL_ASSERT(content_out);\n\tEVUTIL_ASSERT(len_out);\n\t*content_out = NULL;\n\t*len_out = 0;\n\n#ifdef O_BINARY\n\tif (is_binary)\n\t\tmode |= O_BINARY;\n#endif\n\n\tfd = evutil_open_closeonexec_(filename, mode, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st) || st.st_size < 0 ||\n\t    st.st_size > EV_SSIZE_MAX-1 ) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tmem = mm_malloc((size_t)st.st_size + 1);\n\tif (!mem) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tread_so_far = 0;\n#ifdef _WIN32\n#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))\n#else\n#define N_TO_READ(x) (x)\n#endif\n\twhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {\n\t\tread_so_far += r;\n\t\tif (read_so_far >= (size_t)st.st_size)\n\t\t\tbreak;\n\t\tEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);\n\t}\n\tclose(fd);\n\tif (r < 0) {\n\t\tmm_free(mem);\n\t\treturn -2;\n\t}\n\tmem[read_so_far] = 0;\n\n\t*len_out = read_so_far;\n\t*content_out = mem;\n\treturn 0;\n}",
    "decom_sum": "Reads an entire file into a newly allocated null-terminated buffer, returning its size and pointer, with error handling for open, stat, and read failures.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Reads the entire content of the specified file into a newly allocated, null-terminated buffer, returning the buffer pointer and read size.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Reads an entire file into a newly allocated null-terminated buffer, returning its size and pointer, with error handling for open, stat, and read failures.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Reads the entire contents of a file into a newly allocated buffer, null-terminates it, and returns the buffer and its size through output parameters.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
    "filter2_prorec_aug_sum": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
    "filter2_prorec_aug2_sum": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
    "source_code": "\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\n\t\t       char *result, unsigned int maxlen)\n{\n\tint sz = 0;\n\tstruct log_c *lc = log->context;\n\n\tswitch(status) {\n\tcase STATUSTYPE_INFO:\n\t\tDMEMIT(\"3 %s %s %c\", log->type->name, lc->log_dev->name,\n\t\t       lc->log_dev_flush_failed ? 'F' :\n\t\t       lc->log_dev_failed ? 'D' :\n\t\t       'A');\n\t\tbreak;\n\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\"%s %u %s %u \", log->type->name,\n\t\t       lc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\n\t\t       lc->region_size);\n\t\tDMEMIT_SYNC;\n\t}\n\n\treturn sz;\n}",
    "decom_sum": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Formats and writes protocol-specific status or synchronization messages into a provided buffer based on device state and command type parameters.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Inserts a given string at the current cursor position in the line buffer, shifts existing text, updates cursor/end positions, and manages undo history accordingly.",
    "filter2_prorec_aug_sum": "Inserts given text into the readline buffer at the cursor position, shifting existing content, updating undo history, and adjusting buffer size if necessary.",
    "filter2_prorec_aug2_sum": "Inserts the given text into the readline buffer at the current cursor position, extending the buffer if needed and updating undo history accordingly.",
    "source_code": "int\nrl_insert_text (const char *string)\n{\n  register int i, l;\n\n  l = (string && *string) ? strlen (string) : 0;\n  if (l == 0)\n    return 0;\n\n  if (rl_end + l >= rl_line_buffer_len)\n    rl_extend_line_buffer (rl_end + l);\n\n  for (i = rl_end; i >= rl_point; i--)\n    rl_line_buffer[i + l] = rl_line_buffer[i];\n\n  strncpy (rl_line_buffer + rl_point, string, l);\n\n  /* Remember how to undo this if we aren't undoing something. */\n  if (_rl_doing_an_undo == 0)\n    {\n      /* If possible and desirable, concatenate the undos. */\n      if ((l == 1) &&\n\t  rl_undo_list &&\n\t  (rl_undo_list->what == UNDO_INSERT) &&\n\t  (rl_undo_list->end == rl_point) &&\n\t  (rl_undo_list->end - rl_undo_list->start < 20))\n\trl_undo_list->end++;\n      else\n\trl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);\n    }\n  rl_point += l;\n  rl_end += l;\n  rl_line_buffer[rl_end] = '\\0';\n  return l;\n}",
    "decom_sum": "Inserts given text into the readline buffer at the cursor position, shifting existing content, updating undo history, and adjusting buffer size if necessary.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Inserts a given string at the current cursor position in the line buffer, shifts existing text, updates cursor/end positions, and manages undo history accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Inserts given text into the readline buffer at the cursor position, shifting existing content, updating undo history, and adjusting buffer size if necessary.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Inserts the given text into the readline buffer at the current cursor position, extending the buffer if needed and updating undo history accordingly.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
    "filter2_prorec_aug_sum": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
    "filter2_prorec_aug2_sum": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
    "source_code": "\nstatic int restore(struct ks *ks, char x[])\n{     int j, k, z;\n      z = ks->c0;\n      for (j = 1, k = 0; j <= ks->orig_n; j++)\n      {  if (ks->x[j] & 0x10)\n         {  k++;\n            xassert(k <= ks->n);\n            xassert(x[k] == 0 || x[k] == 1);\n            if (ks->x[j] & 1)\n               ks->x[j] = 1 - x[k];\n            else\n               ks->x[j] = x[k];\n            if (x[k])\n               z += ks->c[k];\n         }\n      }\n      xassert(k == ks->n);\n      return z;\n}",
    "decom_sum": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.8
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes flagged items in a structure, validates binary values, toggles bits, updates a sum from weights, and asserts expected item count consistency.",
            "flag": true,
            "score": [
                0.9,
                0.9,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
    "filter2_prorec_aug_sum": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
    "filter2_prorec_aug2_sum": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
    "source_code": "\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\tconst ProtobufCFieldDescriptor *field;\n\n\tif (desc == NULL || desc->fields_sorted_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_fields;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}",
    "decom_sum": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs a binary search on an indexed table to locate an entry with a zeroed computed field and returns its associated data pointer.",
            "flag": true,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
    "filter2_prorec_aug_sum": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
    "filter2_prorec_aug2_sum": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
    "source_code": "\nvoid\npkl_asm_for (pkl_asm pasm, pkl_ast_node head)\n{\n  pkl_asm_pushlevel (pasm, PKL_ASM_ENV_FOR_LOOP);\n\n  pasm->level->node1 = ASTREF (head);\n  pasm->level->label1 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label2 = pvm_program_fresh_label (pasm->program);\n  pasm->level->label3 = pvm_program_fresh_label (pasm->program);\n  pasm->level->continue_label = pvm_program_fresh_label (pasm->program);\n  pasm->level->break_label = pvm_program_fresh_label (pasm->program);\n\n  if (head)\n    pkl_asm_insn (pasm, PKL_INSN_PUSHF, 0);\n}",
    "decom_sum": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.1
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a data structure at `a1+16` with repeated `sub_8A6E0` values, links it to `a2`, and triggers `sub_81880` if `a2` is provided.",
            "flag": true,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
    "filter2_prorec_aug_sum": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
    "filter2_prorec_aug2_sum": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
    "source_code": "BITCODE_BL\ndwg_object_polyline_2d_get_numpoints (const dwg_object *restrict obj,\n                                      int *restrict error)\n{\n  if (obj && obj->type == DWG_TYPE_POLYLINE_2D)\n    {\n      BITCODE_BL num_points = 0;\n      Dwg_Data *dwg = obj->parent;\n      Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;\n      Dwg_Entity_VERTEX_2D *vertex;\n      *error = 0;\n\n      if (dwg->header.version >= R_2004)\n        return obj->tio.entity->tio.POLYLINE_2D->num_owned;\n      // iterate over first_vertex - last_vertex\n      else if (dwg->header.version >= R_13)\n        {\n          Dwg_Object *vobj = dwg_ref_object (dwg, _obj->first_vertex);\n          Dwg_Object *vlast = dwg_ref_object (dwg, _obj->last_vertex);\n          if (!vobj)\n            *error = 1;\n          else\n            {\n              do\n                {\n                  if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                    {\n                      num_points++;\n                    }\n                  else\n                    {\n                      *error = 1; // return not all vertices, but some\n                    }\n                }\n              while ((vobj = dwg_next_object (vobj)) && vobj != vlast);\n            }\n        }\n      else // <r13: iterate over vertices until seqend\n        {\n          Dwg_Object *vobj;\n          while ((vobj = dwg_next_object (obj))\n                 && vobj->type != DWG_TYPE_SEQEND)\n            {\n              if ((vertex = dwg_object_to_VERTEX_2D (vobj)))\n                num_points++;\n              else\n                *error = 1; // return not all vertices, but some\n            }\n        }\n      return num_points;\n    }\n  else\n    {\n      LOG_ERROR (\"%s: empty or wrong arg\", __FUNCTION__)\n      *error = 1;\n      return 0L;\n    }\n}",
    "decom_sum": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Retrieves and returns the number of 2D vertex points in a DWG polyline object, setting an error flag if structure validation fails.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
    "filter2_prorec_aug_sum": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
    "filter2_prorec_aug2_sum": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
    "source_code": "int ed_main(int argc UNUSED_PARAM, char **argv)\n{\n\tINIT_G();\n\n\tbufSize = INITBUF_SIZE;\n\tbufBase = xmalloc(bufSize);\n\tbufPtr = bufBase;\n\tlines.next = &lines;\n\tlines.prev = &lines;\n\n\tif (argv[1]) {\n\t\tfileName = xstrdup(argv[1]);\n\t\tif (!readLines(fileName, 1)) {\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (lastNum)\n\t\t\tsetCurNum(1);\n\t\tdirty = FALSE;\n\t}\n\n\tdoCommands();\n\treturn EXIT_SUCCESS;\n}",
    "decom_sum": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
            "flag": true,
            "score": [
                0.5,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes a structured memory block, configures linked resources using provided vectors and scalars, validates them, and triggers a follow\u2011up processing routine.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs a recursive divide-and-conquer division algorithm on large multi-precision integers using GMP low-level limb operations.",
    "filter2_prorec_aug_sum": "Performs recursive division of large GMP limb arrays, computing quotient and remainder using divide-and-conquer and base case algorithms for efficiency.",
    "filter2_prorec_aug2_sum": "Recursively performs division with remainder on large multi-precision numbers using divide-and-conquer and base-case GMP low-level division primitives.",
    "source_code": "\nstatic void\nmpn_dcpi1_bdiv_q_n (mp_ptr qp,\n\t\t    mp_ptr np, mp_srcptr dp, mp_size_t n,\n\t\t    mp_limb_t dinv, mp_ptr tp)\n{\n  while (ABOVE_THRESHOLD (n, DC_BDIV_Q_THRESHOLD))\n    {\n      mp_size_t lo, hi;\n      mp_limb_t cy;\n\n      lo = n >> 1;\t\t\t/* floor(n/2) */\n      hi = n - lo;\t\t\t/* ceil(n/2) */\n\n      cy = mpn_dcpi1_bdiv_qr_n (qp, np, dp, lo, dinv, tp);\n\n      mpn_mullo_n (tp, qp, dp + hi, lo);\n      mpn_add_n (np + hi, np + hi, tp, lo);\n\n      if (lo < hi)\n\t{\n\t  cy += mpn_addmul_1 (np + lo, qp, lo, dp[lo]);\n\t  np[n - 1] += cy;\n\t}\n      qp += lo;\n      np += lo;\n      n -= lo;\n    }\n  mpn_sbpi1_bdiv_q (qp, np, n, dp, n, dinv);\n}",
    "decom_sum": "Performs multi-limb division using GMP\u2019s divide-and-conquer and schoolbook algorithms, computing quotient limbs and adjusting remainder across large operand segments.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs a recursive divide-and-conquer division algorithm on large multi-precision integers using GMP low-level limb operations.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Performs recursive division of large GMP limb arrays, computing quotient and remainder using divide-and-conquer and base case algorithms for efficiency.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Recursively performs division with remainder on large multi-precision numbers using divide-and-conquer and base-case GMP low-level division primitives.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
    "filter2_prorec_aug_sum": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
    "filter2_prorec_aug2_sum": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
    "source_code": "\nstatic int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,\n\tenum kobj_ns_type type, const void *ns, const char *name,\n\tstruct sysfs_dirent **p_sd)\n{\n\tumode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;\n\tstruct sysfs_addrm_cxt acxt;\n\tstruct sysfs_dirent *sd;\n\tint rc;\n\n\t/* allocate */\n\tsd = sysfs_new_dirent(name, mode, SYSFS_DIR);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\n\tsd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);\n\tsd->s_ns = ns;\n\tsd->s_dir.kobj = kobj;\n\n\t/* link in */\n\tsysfs_addrm_start(&acxt, parent_sd);\n\trc = sysfs_add_one(&acxt, sd);\n\tsysfs_addrm_finish(&acxt);\n\n\tif (rc == 0)\n\t\t*p_sd = sd;\n\telse\n\t\tsysfs_put(sd);\n\n\treturn rc;\n}",
    "decom_sum": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes a structured object with configuration parameters, invokes setup routines, and returns it to the caller or cleans up on failure.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Processes an input structure by validating, matching against a global descriptor list, invoking handlers, and performing state updates with given parameters.",
    "filter2_prorec_aug_sum": "Processes an entry matching a specific byte value, invokes associated callbacks, and executes a sequence of hardware-related operations with provided parameters.",
    "filter2_prorec_aug2_sum": "Validates input, iterates a global array to match and process entries based on a specific byte, performs conditional callbacks, and returns a status code.",
    "source_code": "acpi_status acpi_unload_parent_table(acpi_handle object)\n{\n\tstruct acpi_namespace_node *node =\n\t    ACPI_CAST_PTR(struct acpi_namespace_node, object);\n\tacpi_status status = AE_NOT_EXIST;\n\tacpi_owner_id owner_id;\n\tu32 i;\n\n\tACPI_FUNCTION_TRACE(acpi_unload_parent_table);\n\n\t/* Parameter validation */\n\n\tif (!object) {\n\t\treturn_ACPI_STATUS(AE_BAD_PARAMETER);\n\t}\n\n\t/*\n\t * The node owner_id is currently the same as the parent table ID.\n\t * However, this could change in the future.\n\t */\n\towner_id = node->owner_id;\n\tif (!owner_id) {\n\n\t\t/* owner_id==0 means DSDT is the owner. DSDT cannot be unloaded */\n\n\t\treturn_ACPI_STATUS(AE_TYPE);\n\t}\n\n\t/* Must acquire the interpreter lock during this operation */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_ACPI_STATUS(status);\n\t}\n\n\t/* Find the table in the global table list */\n\n\tfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\n\t\tif (owner_id != acpi_gbl_root_table_list.tables[i].owner_id) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Allow unload of SSDT and OEMx tables only. Do not allow unload\n\t\t * of the DSDT. No other types of tables should get here, since\n\t\t * only these types can contain AML and thus are the only types\n\t\t * that can create namespace objects.\n\t\t */\n\t\tif (ACPI_COMPARE_NAME\n\t\t    (acpi_gbl_root_table_list.tables[i].signature.ascii,\n\t\t     ACPI_SIG_DSDT)) {\n\t\t\tstatus = AE_TYPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Ensure the table is actually loaded */\n\n\t\tif (!acpi_tb_is_table_loaded(i)) {\n\t\t\tstatus = AE_NOT_EXIST;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Invoke table handler if present */\n\n\t\tif (acpi_gbl_table_handler) {\n\t\t\t(void)acpi_gbl_table_handler(ACPI_TABLE_EVENT_UNLOAD,\n\t\t\t\t\t\t     acpi_gbl_root_table_list.\n\t\t\t\t\t\t     tables[i].pointer,\n\t\t\t\t\t\t     acpi_gbl_table_handler_context);\n\t\t}\n\n\t\t/*\n\t\t * Delete all namespace objects owned by this table. Note that\n\t\t * these objects can appear anywhere in the namespace by virtue\n\t\t * of the AML \"Scope\" operator. Thus, we need to track ownership\n\t\t * by an ID, not simply a position within the hierarchy.\n\t\t */\n\t\tstatus = acpi_tb_delete_namespace_by_owner(i);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = acpi_tb_release_owner_id(i);\n\t\tacpi_tb_set_table_loaded_flag(i, FALSE);\n\t\tbreak;\n\t}\n\n\t(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\n\treturn_ACPI_STATUS(status);\n}",
    "decom_sum": "Processes an entry matching a specific byte value, invokes associated callbacks, and executes a sequence of hardware-related operations with provided parameters.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Processes an input structure by validating, matching against a global descriptor list, invoking handlers, and performing state updates with given parameters.",
            "flag": false,
            "score": [
                0.7,
                0.4,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes an entry matching a specific byte value, invokes associated callbacks, and executes a sequence of hardware-related operations with provided parameters.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Validates input, iterates a global array to match and process entries based on a specific byte, performs conditional callbacks, and returns a status code.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Manages readline callback dispatch by processing input, handling subsequences, signals, and errors, cleaning contexts, and freeing memory accordingly.",
    "filter2_prorec_aug_sum": "Processes a readline callback context by dispatching subsequences, handling signals, managing key state contexts, freeing memory, and returning the execution result code.",
    "filter2_prorec_aug2_sum": "Processes a readline callback by dispatching subsequences, handling signals, managing key sequence contexts, and cleaning up resources based on dispatch and subsequence results.",
    "source_code": "int\n_rl_dispatch_callback (_rl_keyseq_cxt *cxt)\n{\n  int nkey, r;\n\n  /* For now */\n  /* The first time this context is used, we want to read input and dispatch\n     on it.  When traversing the chain of contexts back `up', we want to use\n     the value from the next context down.  We're simulating recursion using\n     a chain of contexts. */\n  if ((cxt->flags & KSEQ_DISPATCHED) == 0)\n    {\n      nkey = _rl_subseq_getchar (cxt->okey);\n      if (nkey < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);\n      cxt->flags |= KSEQ_DISPATCHED;\n    }\n  else\n    r = cxt->childval;\n\n  /* For now */\n  if (r != -3)\t/* don't do this if we indicate there will be other matches */\n    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));\n\n  RL_CHECK_SIGNALS ();\n  /* We only treat values < 0 specially to simulate recursion. */\n  if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))\t/* success! or failure! */\n    {\n      _rl_keyseq_chain_dispose ();\n      RL_UNSETSTATE (RL_STATE_MULTIKEY);\n      return r;\n    }\n\n  if (r != -3)\t\t\t/* magic value that says we added to the chain */\n    _rl_kscxt = cxt->ocxt;\n  if (_rl_kscxt)\n    _rl_kscxt->childval = r;\n  if (r != -3)\n    _rl_keyseq_cxt_dispose (cxt);\n\n  return r;\n}",
    "decom_sum": "Dispatches and processes a readline input sequence, handling subdispatch results, signals, cleanup of context structures, and returning operation status codes.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Manages readline callback dispatch by processing input, handling subsequences, signals, and errors, cleaning contexts, and freeing memory accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes a readline callback context by dispatching subsequences, handling signals, managing key state contexts, freeing memory, and returning the execution result code.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes a readline callback by dispatching subsequences, handling signals, managing key sequence contexts, and cleaning up resources based on dispatch and subsequence results.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Searches for a matching entry in a global table by string key and outputs associated integers, falling back to an alternate retrieval function.",
    "filter2_prorec_aug_sum": "Searches for a matching entry in a global table by string key and outputs associated integers, falling back to an alternate retrieval function.",
    "filter2_prorec_aug2_sum": "Allocates a buffer, searches a data structure for a matching string, retrieves associated integer values into output pointers, and returns success or error status.",
    "source_code": "int burn_drive_obtain_scsi_adr(char *path,\n\t\t\t       int *bus_no, int *host_no, int *channel_no,\n\t\t\t       int *target_no, int *lun_no)\n{\n\tint ret, i;\n\tchar *adr = NULL;\n\n\tBURN_ALLOC_MEM(adr, char, BURN_DRIVE_ADR_LEN);\n\n\t/* open drives cannot be inquired by sg_obtain_scsi_adr() */\n\tfor (i = 0; i < drivetop + 1; i++) {\n\t\tif (drive_array[i].global_index < 0)\n\tcontinue;\n\t\tret = burn_drive_d_get_adr(&(drive_array[i]),adr);\n\t\tif (ret < 0)\n\t\t\t{ret = 1; goto ex;}\n\t\tif (ret == 0)\n\tcontinue;\n\t\tif (strcmp(adr, path) == 0) {\n\t\t\t*host_no = drive_array[i].host;\n\t\t\t*channel_no = drive_array[i].channel;\n\t\t\t*target_no = drive_array[i].id;\n\t\t\t*lun_no = drive_array[i].lun;\n\t\t\t*bus_no = drive_array[i].bus_no;\n\t\t\tif (*host_no < 0 || *channel_no < 0 ||\n\t\t\t    *target_no < 0 || *lun_no < 0)\n\t\t\t\t{ret = 0; goto ex;}\n\t\t\t{ret = 1; goto ex;}\n\t\t}\n\t}\n\n\tret = sg_obtain_scsi_adr(path, bus_no, host_no, channel_no,\n\t\t\t\t target_no, lun_no);\nex:;\n\tBURN_FREE_MEM(adr);\n\treturn ret;\n}",
    "decom_sum": "Searches for a matching entry in a global table by string key and outputs associated integers, falling back to an alternate retrieval function.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Searches for a matching entry in a global table by string key and outputs associated integers, falling back to an alternate retrieval function.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Searches for a matching entry in a global table by string key and outputs associated integers, falling back to an alternate retrieval function.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates a buffer, searches a data structure for a matching string, retrieves associated integer values into output pointers, and returns success or error status.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
    "filter2_prorec_aug_sum": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
    "filter2_prorec_aug2_sum": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
    "source_code": "\nint\ncontext_init (char *str)\n{\n  mem_init ();\n  context = mem_alloc (sizeof (struct context));\n  context->num_pat = expr_init (str);\n  if (!context->num_pat)\n    return 0;\n\n  context->tmp = mem_alloc (sizeof (struct line) - sizeof (char[4])\n      + opt.context + 1);\n\n  if (!opt.out_quiet)\n    {\n      register int i, j, occurrences;\n      struct line **line;\n\n      context->lines = mem_alloc (context->num_pat\n\t  * sizeof (struct line **));\n      occurrences = opt.occurrences ? opt.occurrences : 1;\n\n      for (i = 0; i < context->num_pat; i++)\n\t{\n\t  line = mem_alloc (occurrences * sizeof (struct line *));\n\t  for (j = 0; j < occurrences; j++)\n\t    line[j] = mem_alloc (sizeof (struct line) - sizeof (char[4])\n\t\t+ opt.context + 1);\n\n\t  context->lines[i] = line;\n\t}\n    }\n\n  return context->num_pat;\n}",
    "decom_sum": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes nested memory structures based on configuration flags and input count, storing pointers in global state for subsequent processing.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Formats and writes a PROXY protocol header with source and destination IP addresses and ports from the local and peer socket addresses into a provided buffer.",
    "filter2_prorec_aug_sum": "Constructs and writes a PROXY protocol header with source and destination IP addresses and ports into the specified buffer.",
    "filter2_prorec_aug2_sum": "Constructs and writes a PROXY protocol header string with source/destination IP and port based on connection socket address.",
    "source_code": "\n\nu_char *\nngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n{\n    ngx_uint_t  port, lport;\n\n    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {\n        return NULL;\n    }\n\n    if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n        return NULL;\n    }\n\n    switch (c->sockaddr->sa_family) {\n\n    case AF_INET:\n        buf = ngx_cpymem(buf, \"PROXY TCP4 \", sizeof(\"PROXY TCP4 \") - 1);\n        break;\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        buf = ngx_cpymem(buf, \"PROXY TCP6 \", sizeof(\"PROXY TCP6 \") - 1);\n        break;\n#endif\n\n    default:\n        return ngx_cpymem(buf, \"PROXY UNKNOWN\" CRLF,\n                          sizeof(\"PROXY UNKNOWN\" CRLF) - 1);\n    }\n\n    buf += ngx_sock_ntop(c->sockaddr, c->socklen, buf, last - buf, 0);\n\n    *buf++ = ' ';\n\n    buf += ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, last - buf,\n                         0);\n\n    port = ngx_inet_get_port(c->sockaddr);\n    lport = ngx_inet_get_port(c->local_sockaddr);\n\n    return ngx_slprintf(buf, last, \" %ui %ui\" CRLF, port, lport);\n}",
    "decom_sum": "Constructs and writes a PROXY protocol header with source and destination IP addresses and ports into the specified buffer.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Formats and writes a PROXY protocol header with source and destination IP addresses and ports from the local and peer socket addresses into a provided buffer.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Constructs and writes a PROXY protocol header with source and destination IP addresses and ports into the specified buffer.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Constructs and writes a PROXY protocol header string with source/destination IP and port based on connection socket address.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Handles writing inline ext4 data by validating conditions, performing the write operation, updating flags, and invoking metadata and cleanup routines accordingly.",
    "filter2_prorec_aug_sum": "Finalizes ext4 inline data write by verifying conditions, updating metadata flags, and committing inline data to storage if necessary.",
    "filter2_prorec_aug2_sum": "Handles writing inline data to an ext4 inode by validating conditions, updating flags atomically, invoking related block and journaling functions, and managing associated metadata.",
    "source_code": "\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
    "decom_sum": "Handles ext4 inline data write completion, performing validation, locking, block updates, flag manipulation, and logging errors for invalid or failed writes.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Handles writing inline ext4 data by validating conditions, performing the write operation, updating flags, and invoking metadata and cleanup routines accordingly.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Finalizes ext4 inline data write by verifying conditions, updating metadata flags, and committing inline data to storage if necessary.",
            "flag": false,
            "score": [
                0.7,
                0.7,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Handles writing inline data to an ext4 inode by validating conditions, updating flags atomically, invoking related block and journaling functions, and managing associated metadata.",
            "flag": false,
            "score": [
                0.4,
                0.5,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
    "filter2_prorec_aug_sum": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
    "filter2_prorec_aug2_sum": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
    "source_code": "void luaS_resize(lua_State* L, int newsize) {\n  int i;\n  stringtable* tb = &G(L)->strt; // global string table\n  if (newsize > tb->size) { /* grow table if needed */\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n    for (i = tb->size; i < newsize; i++)\n      // open hash table, tb->hash is the pointer for linked list\n      tb->hash[i] = NULL;\n  }\n  for (i = 0; i < tb->size; i++) { /* rehash */\n    TString* p = tb->hash[i];\n    tb->hash[i] = NULL;\n    while (p) { /* for each node in the list */\n      TString* hnext = p->u.hnext; /* save next */\n      unsigned int h = lmod(p->hash, newsize); /* new position */\n      p->u.hnext = tb->hash[h]; /* chain it */\n      tb->hash[h] = p;\n      p = hnext;\n    }\n  }\n  if (newsize < tb->size) { /* shrink table if needed */\n    /* vanishing slice should be empty */\n    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, TString*);\n  }\n  tb->size = newsize;\n}",
    "decom_sum": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Resizes a hash table\u2019s bucket array and rehashes all linked entries to fit the new bucket count.",
            "flag": true,
            "score": [
                0.9,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
    "filter2_prorec_aug_sum": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
    "filter2_prorec_aug2_sum": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
    "source_code": "\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\n\t{\n\tint ret=0;\n\tunsigned long alg_k;\n\n\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n#ifndef OPENSSL_NO_GOST\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tif (alg_k & SSL_kGOST)\n\t\t\t{\n\t\t\tp[ret++]=TLS_CT_GOST94_SIGN;\n\t\t\tp[ret++]=TLS_CT_GOST01_SIGN;\n\t\t\treturn(ret);\n\t\t\t}\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_DH\n\tif (alg_k & (SSL_kDHr|SSL_kEDH))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_FIXED_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_FIXED_DH;\n#  endif\n\t\t}\n\tif ((s->version == SSL3_VERSION) &&\n\t\t(alg_k & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\n\t\t{\n#  ifndef OPENSSL_NO_RSA\n\t\tp[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\n#  endif\n#  ifndef OPENSSL_NO_DSA\n\t\tp[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\n#  endif\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_RSA\n\tp[ret++]=SSL3_CT_RSA_SIGN;\n#endif\n#ifndef OPENSSL_NO_DSA\n\tp[ret++]=SSL3_CT_DSS_SIGN;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif ((alg_k & (SSL_kECDHr|SSL_kECDHe)) && (s->version >= TLS1_VERSION))\n\t\t{\n\t\tp[ret++]=TLS_CT_RSA_FIXED_ECDH;\n\t\tp[ret++]=TLS_CT_ECDSA_FIXED_ECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_ECDSA\n\t/* ECDSA certs can be used with RSA cipher suites as well \n\t * so we don't need to check for SSL_kECDH or SSL_kEECDH\n\t */\n\tif (s->version >= TLS1_VERSION)\n\t\t{\n\t\tp[ret++]=TLS_CT_ECDSA_SIGN;\n\t\t}\n#endif\t\n\treturn(ret);\n\t}",
    "decom_sum": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
            "flag": true,
            "score": [
                0.6,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
            "flag": true,
            "score": [
                0.4,
                0.6,
                0.4
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Builds an SSL/TLS certificate request type list in `a2` based on protocol version and bit flags from the connection context.",
            "flag": true,
            "score": [
                0.4,
                0.6,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Configures wake-up packet capability flags in a2 based on a1\u2019s hardware status, supported features, and interface wake-up support checks.",
    "filter2_prorec_aug_sum": "Configures wake-up frame settings in the given structure based on device flags and interface capabilities, enabling appropriate wake-up packet types.",
    "filter2_prorec_aug2_sum": "Configures wake-up packet capability flags in a2 based on a1\u2019s hardware status, supported features, and interface wake-up support checks.",
    "source_code": "\nstatic void e1000_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\twol->supported = WAKE_UCAST | WAKE_MCAST |\n\t                 WAKE_BCAST | WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\t/* this function will set ->supported = 0 and return 1 if wol is not\n\t * supported by this hardware\n\t */\n\tif (e1000_wol_exclusion(adapter, wol) ||\n\t    !device_can_wakeup(&adapter->pdev->dev))\n\t\treturn;\n\n\t/* apply any specific unsupported masks here */\n\tswitch (hw->device_id) {\n\tcase E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3:\n\t\t/* KSP3 does not support UCAST wake-ups */\n\t\twol->supported &= ~WAKE_UCAST;\n\n\t\tif (adapter->wol & E1000_WUFC_EX)\n\t\t\te_err(drv, \"Interface does not support directed \"\n\t\t\t      \"(unicast) frame wake-up packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (adapter->wol & E1000_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & E1000_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & E1000_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & E1000_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n}",
    "decom_sum": "Configures wake-up packet capability flags in a2 based on a1\u2019s hardware status, supported features, and interface wake-up support checks.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Configures wake-up packet capability flags in a2 based on a1\u2019s hardware status, supported features, and interface wake-up support checks.",
            "flag": true,
            "score": [
                0.4,
                0.5,
                0.4
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Configures wake-up frame settings in the given structure based on device flags and interface capabilities, enabling appropriate wake-up packet types.",
            "flag": false,
            "score": [
                0.8,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Configures wake-up packet capability flags in a2 based on a1\u2019s hardware status, supported features, and interface wake-up support checks.",
            "flag": true,
            "score": [
                0.4,
                0.4,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Configures hardware device flags from control bits, validates prerequisites, and updates related registers and masks based on a1's status field.",
    "filter2_prorec_aug_sum": "Configures and validates device flags based on input bitmap, applies security checks, and sets access and exclusion masks for resource access control.",
    "filter2_prorec_aug2_sum": "Configures hardware device flags from control bits, validates prerequisites, and updates related registers and masks based on a1's status field.",
    "source_code": "\nint intel_pmu_setup_lbr_filter(struct perf_event *event)\n{\n\tint ret = 0;\n\n\t/*\n\t * no LBR on this PMU\n\t */\n\tif (!x86_pmu.lbr_nr)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * setup SW LBR filter\n\t */\n\tret = intel_pmu_setup_sw_lbr_filter(event);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * setup HW LBR filter, if any\n\t */\n\tif (x86_pmu.lbr_sel_map)\n\t\tret = intel_pmu_setup_hw_lbr_filter(event);\n\n\treturn ret;\n}",
    "decom_sum": "Configures hardware device flags from control bits, validates prerequisites, and updates related registers and masks based on a1's status field.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Configures hardware device flags from control bits, validates prerequisites, and updates related registers and masks based on a1's status field.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Configures and validates device flags based on input bitmap, applies security checks, and sets access and exclusion masks for resource access control.",
            "flag": false,
            "score": [
                0.0,
                0.0,
                0.0
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Configures hardware device flags from control bits, validates prerequisites, and updates related registers and masks based on a1's status field.",
            "flag": true,
            "score": [
                0.1,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
    "filter2_prorec_aug_sum": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
    "filter2_prorec_aug2_sum": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
    "source_code": "\nstatic int __init dquot_init(void)\n{\n\tint i, ret;\n\tunsigned long nr_hash, order;\n\n\tprintk(KERN_NOTICE \"VFS: Disk quotas %s\\n\", __DQUOT_VERSION__);\n\n\tregister_sysctl_table(sys_table);\n\n\tdquot_cachep = kmem_cache_create(\"dquot\",\n\t\t\tsizeof(struct dquot), sizeof(unsigned long) * 4,\n\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tNULL);\n\n\torder = 0;\n\tdquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);\n\tif (!dquot_hash)\n\t\tpanic(\"Cannot create dquot hash table\");\n\n\tfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\n\t\tret = percpu_counter_init(&dqstats.counter[i], 0);\n\t\tif (ret)\n\t\t\tpanic(\"Cannot create dquot stat counters\");\n\t}\n\n\t/* Find power-of-two hlist_heads which can fit into allocation */\n\tnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\n\tdq_hash_bits = 0;\n\tdo {\n\t\tdq_hash_bits++;\n\t} while (nr_hash >> dq_hash_bits);\n\tdq_hash_bits--;\n\n\tnr_hash = 1UL << dq_hash_bits;\n\tdq_hash_mask = nr_hash - 1;\n\tfor (i = 0; i < nr_hash; i++)\n\t\tINIT_HLIST_HEAD(dquot_hash + i);\n\n\tprintk(\"Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\\n\",\n\t\t\tnr_hash, order, (PAGE_SIZE << order));\n\n\tregister_shrinker(&dqcache_shrinker);\n\n\treturn 0;\n}",
    "decom_sum": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
            "flag": true,
            "score": [
                0.8,
                0.7,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Initializes the disk quota subsystem by allocating and zeroing hash tables, creating statistic counters, and logging cache table configuration details.",
            "flag": true,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Allocates and initializes a data structure, processes it with parameters from a10, sets header size, then submits it to a device or service, returning success or error code.",
    "filter2_prorec_aug_sum": "Allocates and initializes a device-specific structure, configures it with parameters from a10, and performs a final command submission or cleanup on failure.",
    "filter2_prorec_aug2_sum": "Allocates and initializes a network packet buffer, processes it with specified parameters, updates its header, and sends it through a connection endpoint, returning success or error code.",
    "source_code": "static int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct sk_buff *ans_skb;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\tgoto list_failure;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\n\t\t\t\t 0, NLBL_UNLABEL_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u8(ans_skb,\n\t\t\t     NLBL_UNLABEL_A_ACPTFLG,\n\t\t\t     netlabel_unlabel_acceptflg);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}",
    "decom_sum": "Allocates and initializes a device-specific structure, configures it with parameters from a10, and performs a final command submission or cleanup on failure.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Allocates and initializes a data structure, processes it with parameters from a10, sets header size, then submits it to a device or service, returning success or error code.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Allocates and initializes a device-specific structure, configures it with parameters from a10, and performs a final command submission or cleanup on failure.",
            "flag": true,
            "score": [
                0.1,
                0.1,
                0.1
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Allocates and initializes a network packet buffer, processes it with specified parameters, updates its header, and sends it through a connection endpoint, returning success or error code.",
            "flag": false,
            "score": [
                0.4,
                0.6,
                0.4
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Marks the symbol at the given address as global unless it is already global or a disallowed register symbol, enforcing symbol linkage constraints.",
    "filter2_prorec_aug_sum": "Sets the given symbol's section symbol flags to global unless already global or if it references a register symbol, triggering appropriate error messages.",
    "filter2_prorec_aug2_sum": "Marks a given symbol as global if not already global, verifying and restricting register symbols to prevent invalid global promotion.",
    "source_code": "\nvoid\nS_SET_EXTERNAL (symbolS *s)\n{\n  if (LOCAL_SYMBOL_CHECK (s))\n    s = local_symbol_convert ((struct local_symbol *) s);\n  if ((s->bsym->flags & BSF_WEAK) != 0)\n    {\n      /* Let .weak override .global.  */\n      return;\n    }\n  if (s->bsym->flags & BSF_SECTION_SYM)\n    {\n      /* Do not reassign section symbols.  */\n      as_warn (_(\"section symbols are already global\"));\n      return;\n    }\n#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK\n  if (S_GET_SEGMENT (s) == reg_section)\n    {\n      as_bad (\"can't make register symbol `%s' global\",\n\t      S_GET_NAME (s));\n      return;\n    }\n#endif\n  s->bsym->flags |= BSF_GLOBAL;\n  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);\n\n#ifdef TE_PE\n  if (! an_external_name && S_GET_NAME(s)[0] != '.')\n    an_external_name = S_GET_NAME (s);\n#endif\n}",
    "decom_sum": "Marks a section symbol as global unless it is a register symbol, otherwise reports an error that it cannot be made global.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Marks the symbol at the given address as global unless it is already global or a disallowed register symbol, enforcing symbol linkage constraints.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Sets the given symbol's section symbol flags to global unless already global or if it references a register symbol, triggering appropriate error messages.",
            "flag": false,
            "score": [
                0.6,
                0.7,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Marks a given symbol as global if not already global, verifying and restricting register symbols to prevent invalid global promotion.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
    "filter2_prorec_aug_sum": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
    "filter2_prorec_aug2_sum": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
    "source_code": "\nint FAST_FUNC ll_addr_a2n(unsigned char *lladdr, int len, char *arg)\n{\n\tint i;\n\n\tif (strchr(arg, '.')) {\n\t\tinet_prefix pfx;\n\t\tif (get_addr_1(&pfx, arg, AF_INET)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 4) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(lladdr, pfx.data, 4);\n\t\treturn 4;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tint temp;\n\t\tchar *cp = strchr(arg, ':');\n\t\tif (cp) {\n\t\t\t*cp = 0;\n\t\t\tcp++;\n\t\t}\n\t\tif (sscanf(arg, \"%x\", &temp) != 1 || (temp < 0 || temp > 255)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tlladdr[i] = temp;\n\t\tif (!cp) {\n\t\t\tbreak;\n\t\t}\n\t\targ = cp;\n\t}\n\treturn i+1;\n}",
    "decom_sum": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Parses and validates a MAC address string, storing parsed bytes into the provided buffer or reporting an error if the format is invalid.",
            "flag": true,
            "score": [
                0.7,
                0.6,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Updates linked list pointers and synchronization flags, increments counters, and triggers notifications based on status bits in the volatile input structure.",
    "filter2_prorec_aug_sum": "Handles queue node removal and reassignment, updates linked structures, sets status flags, and increments performance counters when specific control bits are set.",
    "filter2_prorec_aug2_sum": "Handles queue node removal and reassignment, updates linked structures, sets status flags, and increments performance counters when specific control bits are set.",
    "source_code": "\nstatic void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}",
    "decom_sum": "Handles queue node removal and reassignment, updates linked structures, sets status flags, and increments performance counters when specific control bits are set.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Updates linked list pointers and synchronization flags, increments counters, and triggers notifications based on status bits in the volatile input structure.",
            "flag": false,
            "score": [
                0.2,
                0.1,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Handles queue node removal and reassignment, updates linked structures, sets status flags, and increments performance counters when specific control bits are set.",
            "flag": true,
            "score": [
                0.2,
                0.4,
                0.3
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Handles queue node removal and reassignment, updates linked structures, sets status flags, and increments performance counters when specific control bits are set.",
            "flag": true,
            "score": [
                0.2,
                0.4,
                0.3
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs cleanup and reference count decrement on a network UNIX socket structure, logs errors, and finalizes socket closure operations.",
    "filter2_prorec_aug_sum": "Processes UNIX socket state and reference counts, logs errors on invalid states, and finalizes connection cleanup and resource release.",
    "filter2_prorec_aug2_sum": "Performs socket state maintenance by invoking state updates, logging socket status, managing reference counts, and finalizing Unix socket cleanup operations.",
    "source_code": "\nstatic void unix_sock_destructor(struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(!sk_unhashed(sk));\n\tWARN_ON(sk->sk_socket);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tprintk(KERN_INFO \"Attempt to release alive unix socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tif (u->addr)\n\t\tunix_release_addr(u->addr);\n\n\tatomic_long_dec(&unix_nr_socks);\n\tlocal_bh_disable();\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n#ifdef UNIX_REFCNT_DEBUG\n\tprintk(KERN_DEBUG \"UNIX %p is destroyed, %ld are still alive.\\n\", sk,\n\t\tatomic_long_read(&unix_nr_socks));\n#endif\n}",
    "decom_sum": "Cleans up and finalizes a UNIX socket connection, logging state checks, decrementing reference counters, and releasing associated resources.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs cleanup and reference count decrement on a network UNIX socket structure, logs errors, and finalizes socket closure operations.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes UNIX socket state and reference counts, logs errors on invalid states, and finalizes connection cleanup and resource release.",
            "flag": false,
            "score": [
                0.8,
                0.8,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Performs socket state maintenance by invoking state updates, logging socket status, managing reference counts, and finalizing Unix socket cleanup operations.",
            "flag": false,
            "score": [
                0.7,
                0.8,
                0.6
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Validates parameters and configures or clears internal character set data structures for matching, copying or resetting character mask sets based on mode.",
    "filter2_prorec_aug_sum": "Validates inputs and sets character mapping data at specific offsets based on a2 and a3 parameters, managing memory and bitmask-filtered ASCII subsets.",
    "filter2_prorec_aug2_sum": "Processes and sets character mapping data in the context structure based on a mode and input parameters, managing memory and updating internal pointers accordingly.",
    "source_code": "\nstatic int\n_nullstream_ctl (struct _mu_stream *str, int code, int opcode, void *arg)\n{\n  struct _mu_nullstream *np = (struct _mu_nullstream *)str;\n\n  if (code != MU_IOCTL_NULLSTREAM)\n    /* Only this code is supported */\n    return ENOSYS;\n  switch (opcode)\n    {\n    case MU_IOCTL_NULLSTREAM_SET_PATTERN:\n      if (!arg)\n\t_nullstream_free_pattern (np);\n      else\n\t{\n\t  struct mu_nullstream_pattern *pat = arg;\n\t  char *p;\n\t  \n\t  p = malloc (pat->size);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, pat->pattern, pat->size);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = pat->size;\n\t}\n      break;\n\n    case MU_IOCTL_NULLSTREAM_SET_PATCLASS:\n      if (!arg)\n\treturn EINVAL;\n      else\n\t{\n\t  char buf[256];\n\t  int cnt = 0, i;\n\t  int class = *(int*)arg;\n\t  char *p;\n\t  \n\t  for (i = 0; i < 256; i++)\n\t    {\n\t      if (mu_c_is_class (i, class))\n\t\tbuf[cnt++] = i;\n\t    }\n\n\t  p = malloc (cnt);\n\t  if (!p)\n\t    return ENOMEM;\n\t  memcpy (p, buf, cnt);\n\t  _nullstream_free_pattern (np);\n\t  np->pattern = p;\n\t  np->patsize = cnt;\n\t}\n      break;\n\t  \n    case MU_IOCTL_NULLSTREAM_SETSIZE:\n      if (!arg)\n\treturn EINVAL;\n      else\n\treturn _nullstream_truncate (str, *(mu_off_t*)arg);\n      break;\n\n    case MU_IOCTL_NULLSTREAM_CLRSIZE:\n      np->mode &= ~MU_NULLSTREAM_SIZE;\n      np->base.size = NULL;\n      break;\n      \n    default:\n      return ENOSYS;\n    }\n  return 0;\n}",
    "decom_sum": "Configures a structure at `a1` by setting filter bytes, copying provided data, or modifying flags based on mode `a3` and input `a4`.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Validates parameters and configures or clears internal character set data structures for matching, copying or resetting character mask sets based on mode.",
            "flag": false,
            "score": [
                0.3,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Validates inputs and sets character mapping data at specific offsets based on a2 and a3 parameters, managing memory and bitmask-filtered ASCII subsets.",
            "flag": false,
            "score": [
                0.2,
                0.3,
                0.2
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes and sets character mapping data in the context structure based on a mode and input parameters, managing memory and updating internal pointers accordingly.",
            "flag": false,
            "score": [
                0.2,
                0.2,
                0.2
            ]
        }
    }
}
{
    "filter2_prorec_sum": "Performs segmented DES-EDE3 encryption or decryption in CFB64 mode on input data exceeding 2^62 bytes to handle large buffers securely.",
    "filter2_prorec_aug_sum": "Processes input data in segments larger than 0x3FFFFFFFFFFFFFFF bytes using triple-DES CFB64 encryption, handling remaining bytes separately for complete encryption output.",
    "filter2_prorec_aug2_sum": "Processes input data with DES-EDE3 in CFB64 mode, handling large buffers by chunked encryption calls based on size limits.",
    "source_code": "\nstatic int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n\t\t\t      const unsigned char *in, size_t inl)\n{\n\twhile (inl>=EVP_MAXCHUNK)\n\t\t{\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, \n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n\t\t\t       (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\t\tinl-=EVP_MAXCHUNK;\n\t\tin +=EVP_MAXCHUNK;\n\t\tout+=EVP_MAXCHUNK;\n\t\t}\n\tif (inl)\n\t\tDES_ede3_cfb64_encrypt(in, out, (long)inl,\n\t\t\t       &data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\n                               (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\n\treturn 1;\n}",
    "decom_sum": "Encrypts data in chunks using 3DES CFB64 mode, handling extremely large lengths by processing 2^62-byte segments before a final partial block.",
    "work_score": {
        "filter2_prorec": {
            "summary": "Performs segmented DES-EDE3 encryption or decryption in CFB64 mode on input data exceeding 2^62 bytes to handle large buffers securely.",
            "flag": false,
            "score": [
                0.6,
                0.8,
                0.6
            ]
        },
        "filter2_prorec_aug": {
            "summary": "Processes input data in segments larger than 0x3FFFFFFFFFFFFFFF bytes using triple-DES CFB64 encryption, handling remaining bytes separately for complete encryption output.",
            "flag": false,
            "score": [
                0.3,
                0.6,
                0.7
            ]
        },
        "filter2_prorec_aug2": {
            "summary": "Processes input data with DES-EDE3 in CFB64 mode, handling large buffers by chunked encryption calls based on size limits.",
            "flag": false,
            "score": [
                0.9,
                0.8,
                0.8
            ]
        }
    }
}
